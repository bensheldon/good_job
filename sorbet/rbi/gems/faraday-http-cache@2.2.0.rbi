# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `faraday-http-cache` gem.
# Please instead update this file by running `bin/tapioca gem faraday-http-cache`.

# This is the main namespace for Faraday.
#
# It provides methods to create {Connection} objects, and HTTP-related
# methods to use directly.
#
# @example Helpful class methods for easy usage
#   Faraday.get "http://faraday.com"
# @example Helpful class method `.new` to create {Connection} objects.
#   conn = Faraday.new "http://faraday.com"
#   conn.get '/'
module Faraday
  class << self
    # @overload default_adapter
    # @overload default_adapter=
    def default_adapter; end

    # Documented elsewhere, see default_adapter reader
    def default_adapter=(adapter); end

    # @overload default_connection
    # @overload default_connection=
    def default_connection; end

    # Documented below, see default_connection
    def default_connection=(_arg0); end

    # Gets the default connection options used when calling {Faraday#new}.
    #
    # @return [Faraday::ConnectionOptions]
    def default_connection_options; end

    # Sets the default options used when calling {Faraday#new}.
    #
    # @param options [Hash, Faraday::ConnectionOptions]
    def default_connection_options=(options); end

    # Tells Faraday to ignore the environment proxy (http_proxy).
    # Defaults to `false`.
    #
    # @return [Boolean]
    def ignore_env_proxy; end

    # Tells Faraday to ignore the environment proxy (http_proxy).
    # Defaults to `false`.
    #
    # @return [Boolean]
    def ignore_env_proxy=(_arg0); end

    # Gets or sets the path that the Faraday libs are loaded from.
    #
    # @return [String]
    def lib_path; end

    # Gets or sets the path that the Faraday libs are loaded from.
    #
    # @return [String]
    def lib_path=(_arg0); end

    # Initializes a new {Connection}.
    #
    # @example With an URL argument
    #   Faraday.new 'http://faraday.com'
    #   # => Faraday::Connection to http://faraday.com
    # @example With everything in an options hash
    #   Faraday.new url: 'http://faraday.com',
    #   params: { page: 1 }
    #   # => Faraday::Connection to http://faraday.com?page=1
    # @example With an URL argument and an options hash
    #   Faraday.new 'http://faraday.com', params: { page: 1 }
    #   # => Faraday::Connection to http://faraday.com?page=1
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @param url [String, Hash] The optional String base URL to use as a prefix
    #   for all requests.  Can also be the options Hash. Any of these
    #   values will be set on every request made, unless overridden
    #   for a specific request.
    # @param options [Hash]
    # @return [Faraday::Connection]
    def new(url = T.unsafe(nil), options = T.unsafe(nil), &block); end

    # Internal: Requires internal Faraday libraries.
    #
    # @param libs [Array] one or more relative String names to Faraday classes.
    # @private
    # @return [void]
    def require_lib(*libs); end

    # Internal: Requires internal Faraday libraries.
    #
    # @param libs [Array] one or more relative String names to Faraday classes.
    # @private
    # @return [void]
    def require_libs(*libs); end

    # @return [Boolean]
    def respond_to_missing?(symbol, include_private = T.unsafe(nil)); end

    # The root path that Faraday is being loaded from.
    #
    # This is the root from where the libraries are auto-loaded.
    #
    # @return [String]
    def root_path; end

    # The root path that Faraday is being loaded from.
    #
    # This is the root from where the libraries are auto-loaded.
    #
    # @return [String]
    def root_path=(_arg0); end

    private

    # Internal: Proxies method calls on the Faraday constant to
    # .default_connection.
    def method_missing(name, *args, &block); end
  end
end

Faraday::CONTENT_TYPE = T.let(T.unsafe(nil), String)
Faraday::CompositeReadIO = Faraday::Multipart::CompositeReadIO
Faraday::FilePart = UploadIO

# Public: The middleware responsible for caching and serving responses.
# The middleware use the provided configuration options to establish a
# 'Faraday::HttpCache::Storage' to cache responses retrieved by the stack
# adapter. If a stored response can be served again for a subsequent
# request, the middleware will return the response instead of issuing a new
# request to it's server. This middleware should be the last attached handler
# to your stack, so it will be closest to the inner app, avoiding issues
# with other middlewares on your stack.
#
# Examples:
#
#   # Using the middleware with a simple client:
#   client = Faraday.new do |builder|
#     builder.use :http_cache, store: my_store_backend
#     builder.adapter Faraday.default_adapter
#   end
#
#   # Attach a Logger to the middleware.
#   client = Faraday.new do |builder|
#     builder.use :http_cache, logger: my_logger_instance, store: my_store_backend
#     builder.adapter Faraday.default_adapter
#   end
#
#   # Provide an existing CacheStore (for instance, from a Rails app)
#   client = Faraday.new do |builder|
#     builder.use :http_cache, store: Rails.cache
#   end
#
#   # Use Marshal for serialization
#   client = Faraday.new do |builder|
#     builder.use :http_cache, store: Rails.cache, serializer: Marshal
#   end
#
#   # Instrument events using ActiveSupport::Notifications
#   client = Faraday.new do |builder|
#     builder.use :http_cache, store: Rails.cache, instrumenter: ActiveSupport::Notifications
#   end
class Faraday::HttpCache < ::Faraday::Middleware
  # Public: Initializes a new HttpCache middleware.
  #
  # app  - the next endpoint on the 'Faraday' stack.
  # :store           - A cache store that should respond to 'read', 'write', and 'delete'.
  # :serializer      - A serializer that should respond to 'dump' and 'load'.
  # :shared_cache    - A flag to mark the middleware as a shared cache or not.
  # :instrumenter    - An instrumentation object that should respond to 'instrument'.
  # :instrument_name - The String name of the instrument being reported on (optional).
  # :logger          - A logger object.
  #
  # Examples:
  #
  #   # Initialize the middleware with a logger.
  #   Faraday::HttpCache.new(app, logger: my_logger)
  #
  #   # Initialize the middleware with a logger and Marshal as a serializer
  #   Faraday:HttpCache.new(app, logger: my_logger, serializer: Marshal)
  #
  #   # Initialize the middleware with a FileStore at the 'tmp' dir.
  #   store = ActiveSupport::Cache.lookup_store(:file_store, ['tmp'])
  #   Faraday::HttpCache.new(app, store: store)
  #
  #   # Initialize the middleware with a MemoryStore and logger
  #   store = ActiveSupport::Cache.lookup_store
  #   Faraday::HttpCache.new(app, store: store, logger: my_logger)
  #
  # @return [HttpCache] a new instance of HttpCache
  def initialize(app, store: T.unsafe(nil), serializer: T.unsafe(nil), shared_cache: T.unsafe(nil), instrumenter: T.unsafe(nil), instrument_name: T.unsafe(nil), logger: T.unsafe(nil)); end

  # Public: Process the request into a duplicate of this instance to
  # ensure that the internal state is preserved.
  def call(env); end

  # Internal: Process the stack request to try to serve a cache response.
  # On a cacheable request, the middleware will attempt to locate a
  # valid stored response to serve. On a cache miss, the middleware will
  # forward the request and try to store the response for future requests.
  # If the request can't be cached, the request will be delegated directly
  # to the underlying app and does nothing to the response.
  # The processed steps will be recorded to be logged once the whole
  # process is finished.
  #
  # Returns a 'Faraday::Response' instance.
  def call!(env); end

  protected

  # Internal: Gets the request object created from the Faraday env Hash.
  def request; end

  # Internal: Gets the storage instance associated with the middleware.
  def storage; end

  private

  def create_request(env); end

  # Internal: Creates a new 'Hash' containing the response information.
  #
  # env - the environment 'Hash' from the Faraday stack.
  #
  # Returns a 'Hash' containing the ':status', ':body' and 'response_headers'
  # entries.
  def create_response(env); end

  def delete(request, response); end

  # Internal: Extracts the cache status from a trace.
  #
  # Returns the Symbol status or nil if none was available.
  def extract_status(trace); end

  # Internal: Fetches the response from the Faraday stack and stores it.
  #
  # env - the environment 'Hash' from the Faraday stack.
  #
  # Returns the fresh 'Faraday::Response' instance.
  def fetch(env); end

  # Internal: instruments the request processing.
  #
  # Returns nothing.
  def instrument(env); end

  # Internal: Logs the trace info about the incoming request
  # and how the middleware handled it.
  # This method does nothing if theresn't a logger present.
  #
  # Returns nothing.
  def log_request; end

  # Internal: Tries to locate a valid response or forwards the call to the stack.
  # * If no entry is present on the storage, the 'fetch' method will forward
  # the call to the remaining stack and return the new response.
  # * If a fresh response is found, the middleware will abort the remaining
  # stack calls and return the stored response back to the client.
  # * If a response is found but isn't fresh anymore, the middleware will
  # revalidate the response back to the server.
  #
  # env - the environment 'Hash' provided from the 'Faraday' stack.
  #
  # Returns the 'Faraday::Response' instance to be served.
  def process(env); end

  # Internal: Should this cache instance act like a "shared cache" according
  # to the the definition in RFC 2616?
  #
  # @return [Boolean]
  def shared_cache?; end

  # Internal: Checks if the current request method should remove any existing
  # cache entries for the same resource.
  #
  # Returns true or false.
  #
  # @return [Boolean]
  def should_delete?(status, method); end

  # Internal: Stores the response into the storage.
  # If the response isn't cacheable, a trace action 'uncacheable' will be
  # recorded for logging purposes.
  #
  # response - a 'Faraday::HttpCache::Response' instance to be stored.
  #
  # Returns nothing.
  def store(response); end

  # Internal: Records a traced action to be used by the logger once the
  # request/response phase is finished.
  #
  # operation - the name of the performed action, a String or Symbol.
  #
  # Returns nothing.
  def trace(operation); end

  # Internal: Tries to validated a stored entry back to it's origin server
  # using the 'If-Modified-Since' and 'If-None-Match' headers with the
  # existing 'Last-Modified' and 'ETag' headers. If the new response
  # is marked as 'Not Modified', the previous stored response will be used
  # and forwarded against the Faraday stack. Otherwise, the freshly new
  # response will be stored (replacing the old one) and used.
  #
  # entry - a stale 'Faraday::HttpCache::Response' retrieved from the cache.
  # env - the environment 'Hash' to perform the request.
  #
  # Returns the 'Faraday::HttpCache::Response' to be forwarded into the stack.
  def validate(entry, env); end
end

Faraday::HttpCache::CACHE_STATUSES = T.let(T.unsafe(nil), Array)

# Internal: A class to represent the 'Cache-Control' header options.
# This implementation is based on 'rack-cache' internals by Ryan Tomayko.
# It breaks the several directives into keys/values and stores them into
# a Hash.
class Faraday::HttpCache::CacheControl
  # Internal: Initialize a new CacheControl.
  #
  # @return [CacheControl] a new instance of CacheControl
  def initialize(header); end

  # Internal: Gets the 'max-age' directive as an Integer.
  #
  # Returns nil if the 'max-age' directive isn't present.
  def max_age; end

  # Internal: Checks if the 'must-revalidate' directive is present.
  #
  # @return [Boolean]
  def must_revalidate?; end

  # Internal: Checks if the 'no-cache' directive is present.
  #
  # @return [Boolean]
  def no_cache?; end

  # Internal: Checks if the 'no-store' directive is present.
  #
  # @return [Boolean]
  def no_store?; end

  # Internal: Gets the 'max-age' directive as an Integer.
  #
  # takes the age header integer value and reduces the max-age and s-maxage
  # if present to account for having to remove static age header when caching responses
  def normalize_max_ages(age); end

  # Internal: Checks if the 'private' directive is present.
  #
  # @return [Boolean]
  def private?; end

  # Internal: Checks if the 'proxy-revalidate' directive is present.
  #
  # @return [Boolean]
  def proxy_revalidate?; end

  # Internal: Checks if the 'public' directive is present.
  #
  # @return [Boolean]
  def public?; end

  # Internal: Gets the 's-maxage' directive as an Integer.
  #
  # Returns nil if the 's-maxage' directive isn't present.
  def s_maxage; end

  # Internal: Gets the 's-maxage' directive as an Integer.
  #
  # Returns nil if the 's-maxage' directive isn't present.
  def shared_max_age; end

  # Internal: Gets the String representation for the cache directives.
  # Directives are joined by a '=' and then combined into a single String
  # separated by commas. Directives with a 'true' value will omit the '='
  # sign and their value.
  #
  # Returns the Cache Control string.
  def to_s; end

  private

  # Internal: Parses the Cache Control string to a Hash.
  # Existing whitespace will be removed and the string is split on commas.
  # For each part everything before a '=' will be treated as the key
  # and the exceeding will be treated as the value. If only the key is
  # present then the assigned value will default to true.
  #
  # Examples:
  #   parse("max-age=600")
  #   # => { "max-age" => "600"}
  #
  #   parse("max-age")
  #   # => { "max-age" => true }
  #
  # Returns a Hash.
  def parse(header); end
end

Faraday::HttpCache::ERROR_STATUSES = T.let(T.unsafe(nil), Range)

# The name of the instrumentation event.
Faraday::HttpCache::EVENT_NAME = T.let(T.unsafe(nil), String)

# Internal: A Hash based store to be used by the 'Storage' class
# when a 'store' is not provided for the middleware setup.
class Faraday::HttpCache::MemoryStore
  # @return [MemoryStore] a new instance of MemoryStore
  def initialize; end

  def delete(key); end
  def read(key); end
  def write(key, value); end
end

# Internal: A class to represent a request
class Faraday::HttpCache::Request
  # @return [Request] a new instance of Request
  def initialize(method:, url:, headers:); end

  # Internal: Gets the 'CacheControl' object.
  def cache_control; end

  # Internal: Validates if the current request method is valid for caching.
  #
  # Returns true if the method is ':get' or ':head'.
  #
  # @return [Boolean]
  def cacheable?; end

  # Returns the value of attribute headers.
  def headers; end

  # Returns the value of attribute method.
  def method; end

  # @return [Boolean]
  def no_cache?; end

  def serializable_hash; end

  # Returns the value of attribute url.
  def url; end

  class << self
    def from_env(env); end
  end
end

# Internal: A class to represent a response from a Faraday request.
# It decorates the response hash into a smarter object that queries
# the response headers and status informations about how the caching
# middleware should handle this specific response.
class Faraday::HttpCache::Response
  # Internal: Initialize a new Response with the response payload from
  # a Faraday request.
  #
  # payload - the response Hash returned by a Faraday request.
  #           :status - the status code from the response.
  #           :response_headers - a 'Hash' like object with the headers.
  #           :body - the response body.
  #
  # @return [Response] a new instance of Response
  def initialize(payload = T.unsafe(nil)); end

  # Internal: Gets the response age in seconds.
  #
  # Returns the 'Age' header if present, or subtracts the response 'date'
  # from the current time.
  def age; end

  # Internal: Checks if the response can be cached by the client when the
  # client is acting as a private cache per RFC 2616. This is validated by
  # the 'Cache-Control' directives, the response status code and it's
  # freshness or validation status.
  #
  # Returns false if the 'Cache-Control' says that we can't store the
  # response, or if isn't fresh or it can't be revalidated with the origin
  # server. Otherwise, returns true.
  #
  # @return [Boolean]
  def cacheable_in_private_cache?; end

  # Internal: Checks if the response can be cached by the client when the
  # client is acting as a shared cache per RFC 2616. This is validated by
  # the 'Cache-Control' directives, the response status code and it's
  # freshness or validation status.
  #
  # Returns false if the 'Cache-Control' says that we can't store the
  # response, or it can be stored in private caches only, or if isn't fresh
  # or it can't be revalidated with the origin server. Otherwise, returns
  # true.
  #
  # @return [Boolean]
  def cacheable_in_shared_cache?; end

  # Internal: Parses the 'Date' header back into a Time instance.
  #
  # Returns the Time object.
  def date; end

  # Internal: Gets the 'ETag' header from the headers Hash.
  def etag; end

  # Internal: Checks the response freshness based on expiration headers.
  # The calculated 'ttl' should be present and bigger than 0.
  #
  # Returns true if the response is fresh, otherwise false.
  #
  # @return [Boolean]
  def fresh?; end

  # Internal: Gets the 'Last-Modified' header from the headers Hash.
  def last_modified; end

  # Internal: Gets the response max age.
  # The max age is extracted from one of the following:
  # * The shared max age directive from the 'Cache-Control' header;
  # * The max age directive from the 'Cache-Control' header;
  # * The difference between the 'Expires' header and the response
  #   date.
  #
  # Returns the max age value in seconds or nil if all options above fails.
  def max_age; end

  # Internal: Checks if the Response returned a 'Not Modified' status.
  #
  # Returns true if the response status code is 304.
  #
  # @return [Boolean]
  def not_modified?; end

  # Internal: Gets the actual response Hash (status, headers and body).
  def payload; end

  # Internal: Exposes a representation of the current
  # payload that we can serialize and cache properly.
  #
  # Returns a 'Hash'.
  def serializable_hash; end

  # Internal: Creates a new 'Faraday::Response', merging the stored
  # response with the supplied 'env' object.
  #
  # Returns a new instance of a 'Faraday::Response' with the payload.
  def to_response(env); end

  # Internal: Calculates the 'Time to live' left on the Response.
  #
  # Returns the remaining seconds for the response, or nil the 'max_age'
  # isn't present.
  def ttl; end

  private

  # Internal: Gets the 'CacheControl' object.
  def cache_control; end

  # Internal: The logic behind cacheable_in_private_cache? and
  # cacheable_in_shared_cache? The logic is the same except for the
  # treatment of the private Cache-Control directive.
  #
  # @return [Boolean]
  def cacheable?(shared_cache); end

  # Internal: Validates the response status against the
  # `CACHEABLE_STATUS_CODES' constant.
  #
  # Returns true if the constant includes the response status code.
  #
  # @return [Boolean]
  def cacheable_status_code?; end

  # Internal: Try to parse the Date header, if it fails set it to @now.
  #
  # Returns nothing.
  def ensure_date_header!; end

  # Internal: Gets the 'Expires' in a Time object.
  #
  # Returns the Time object, or nil if the header isn't present or isn't RFC 2616 compliant.
  def expires; end

  # Internal: Gets the headers 'Hash' from the payload.
  def headers; end

  # Internal: Prepares the response headers to be cached.
  #
  # It removes the 'Age' header if present to allow cached responses
  # to continue aging while cached. It also normalizes the 'max-age'
  # related headers if the 'Age' header is provided to ensure accuracy
  # once the 'Age' header is removed.
  #
  # Returns nothing.
  def prepare_to_cache; end

  # Internal: Checks if this response can be revalidated.
  #
  # Returns true if the 'headers' contains a 'Last-Modified' or an 'ETag'
  # entry.
  #
  # @return [Boolean]
  def validateable?; end

  # Internal: Converts the headers 'Hash' into 'Faraday::Utils::Headers'.
  # Faraday actually uses a Hash subclass, `Faraday::Utils::Headers` to
  # store the headers hash. When retrieving a serialized response,
  # the headers object is decoded as a 'Hash' instead of the actual
  # 'Faraday::Utils::Headers' object, so we need to ensure that the
  # 'response_headers' is always a 'Headers' instead of a plain 'Hash'.
  #
  # Returns nothing.
  def wrap_headers!; end
end

# Internal: List of status codes that can be cached:
# * 200 - 'OK'
# * 203 - 'Non-Authoritative Information'
# * 300 - 'Multiple Choices'
# * 301 - 'Moved Permanently'
# * 302 - 'Found'
# * 404 - 'Not Found'
# * 410 - 'Gone'
Faraday::HttpCache::Response::CACHEABLE_STATUS_CODES = T.let(T.unsafe(nil), Array)

# Internal: A wrapper around an ActiveSupport::CacheStore to store responses.
#
# Examples
#
#   # Creates a new Storage using a MemCached backend from ActiveSupport.
#   mem_cache_store = ActiveSupport::Cache.lookup_store(:mem_cache_store, ['localhost:11211'])
#   Faraday::HttpCache::Storage.new(store: mem_cache_store)
#
#   # Reuse some other instance of an ActiveSupport::Cache::Store object.
#   Faraday::HttpCache::Storage.new(store: Rails.cache)
#
#   # Creates a new Storage using Marshal for serialization.
#   Faraday::HttpCache::Storage.new(store: Rails.cache, serializer: Marshal)
class Faraday::HttpCache::Storage
  # Internal: Initialize a new Storage object with a cache backend.
  #
  # :logger     - A Logger object to be used to emit warnings.
  # :store      - An cache store object that should respond to 'read',
  #              'write', and 'delete'.
  # :serializer - A serializer object that should respond to 'dump'
  #               and 'load'.
  #
  # @return [Storage] a new instance of Storage
  def initialize(store: T.unsafe(nil), serializer: T.unsafe(nil), logger: T.unsafe(nil)); end

  # Public: Gets the underlying cache store object.
  def cache; end

  def delete(url); end

  # Internal: Attempt to retrieve an stored response that suits the incoming
  # HTTP request.
  #
  # request  - A Faraday::HttpCache::::Request instance of the incoming HTTP
  #            request.
  # klass    - The Class to be instantiated with the stored response.
  #
  # Returns an instance of 'klass'.
  def read(request, klass: T.unsafe(nil)); end

  # Internal: Store a response inside the cache.
  #
  # request  - A Faraday::HttpCache::::Request instance of the executed HTTP
  #            request.
  # response - The Faraday::HttpCache::Response instance to be stored.
  #
  # Returns nothing.
  def write(request, response); end

  private

  # Internal: Checks if the given cache object supports the
  # expect API ('read' and 'write').
  #
  # Raises an 'ArgumentError'.
  #
  # Returns nothing.
  def assert_valid_store!; end

  # Internal: Computes the cache key for a specific request, taking in
  # account the current serializer to avoid cross serialization issues.
  #
  # url - The request URL.
  #
  # Returns a String.
  def cache_key_for(url); end

  def deserialize_entry(*objects); end
  def deserialize_object(object); end

  # Internal: Retrieve a response Hash from the list of entries that match
  # the given request.
  #
  # request  - A Faraday::HttpCache::::Request instance of the incoming HTTP
  #            request.
  # entries  - An Array of pairs of Hashes (request, response).
  #
  # Returns a Hash or nil.
  def lookup_response(request, entries); end

  # Internal: Check if a cached response and request matches the given
  # request.
  #
  # request         - A Faraday::HttpCache::::Request instance of the
  #                   current HTTP request.
  # cached_request  - The Hash of the request that was cached.
  # cached_response - The Hash of the response that was cached.
  #
  # Returns true or false.
  #
  # @return [Boolean]
  def response_matches?(request, cached_request, cached_response); end

  def serialize_entry(*objects); end
  def serialize_object(object); end

  # @return [Boolean]
  def vary_matches?(cached_response, request, cached_request); end

  def warn(message); end
end

Faraday::HttpCache::UNSAFE_METHODS = T.let(T.unsafe(nil), Array)
Faraday::METHODS_WITH_BODY = T.let(T.unsafe(nil), Array)
Faraday::METHODS_WITH_QUERY = T.let(T.unsafe(nil), Array)
Faraday::ParamPart = Faraday::Multipart::ParamPart
Faraday::Parts = Parts
Faraday::Timer = Timeout
Faraday::UploadIO = UploadIO
Faraday::VERSION = T.let(T.unsafe(nil), String)
