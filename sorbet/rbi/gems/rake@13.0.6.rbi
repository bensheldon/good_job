# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `rake` gem.
# Please instead update this file by running `bin/tapioca gem rake`.

# :stopdoc:
#
# Some top level Constants.
FileList = Rake::FileList

# --
# This a FileUtils extension that defines several additional commands to be
# added to the FileUtils utility functions.
module FileUtils
  include ::FileUtils::StreamUtils_
  extend ::FileUtils::StreamUtils_

  # Run a Ruby interpreter with the given arguments.
  #
  # Example:
  #   ruby %{-pe '$_.upcase!' <README}
  def ruby(*args, **options, &block); end

  # Attempt to do a normal file link, but fall back to a copy if the link
  #  fails.
  def safe_ln(*args, **options); end

  # Run the system command +cmd+.  If multiple arguments are given the command
  # is run directly (without the shell, same semantics as Kernel::exec and
  # Kernel::system).
  #
  # It is recommended you use the multiple argument form over interpolating
  # user input for both usability and security reasons.  With the multiple
  # argument form you can easily process files with spaces or other shell
  # reserved characters in them.  With the multiple argument form your rake
  # tasks are not vulnerable to users providing an argument like
  # <code>; rm # -rf /</code>.
  #
  # If a block is given, upon command completion the block is called with an
  # OK flag (true on a zero exit status) and a Process::Status object.
  # Without a block a RuntimeError is raised when the command exits non-zero.
  #
  # Examples:
  #
  #   sh 'ls -ltr'
  #
  #   sh 'ls', 'file with spaces'
  #
  #   # check exit status after command runs
  #   sh %{grep pattern file} do |ok, res|
  #     if !ok
  #       puts "pattern not found (status = #{res.exitstatus})"
  #     end
  #   end
  def sh(*cmd, &block); end

  # Split a file path into individual directory names.
  #
  # Example:
  #   split_all("a/b/c") =>  ['a', 'b', 'c']
  def split_all(path); end

  private

  def create_shell_runner(cmd); end
  def set_verbose_option(options); end
  def sh_show_command(cmd); end
end

FileUtils::LN_SUPPORTED = T.let(T.unsafe(nil), Array)

# Path to the currently running Ruby program
FileUtils::RUBY = T.let(T.unsafe(nil), String)

class Module
  include ::ActiveSupport::Dependencies::ModuleConstMissing
  include ::Module::Concerning

  # Check for an existing method in the current class before extending.  If
  # the method already exists, then a warning is printed and the extension is
  # not added.  Otherwise the block is yielded and any definitions in the
  # block will take effect.
  #
  # Usage:
  #
  #   class String
  #     rake_extension("xyz") do
  #       def xyz
  #         ...
  #       end
  #     end
  #   end
  def rake_extension(method); end
end

Module::DELEGATION_RESERVED_KEYWORDS = T.let(T.unsafe(nil), Array)
Module::DELEGATION_RESERVED_METHOD_NAMES = T.let(T.unsafe(nil), Set)
Module::RUBY_RESERVED_KEYWORDS = T.let(T.unsafe(nil), Array)

module Rake
  extend ::FileUtils::StreamUtils_
  extend ::FileUtils
  extend ::Rake::FileUtilsExt

  class << self
    # Add files to the rakelib list
    def add_rakelib(*files); end

    # Current Rake Application
    def application; end

    # Set the current Rake application object.
    def application=(app); end

    # Yield each file or directory component.
    def each_dir_parent(dir); end

    # Convert Pathname and Pathname-like objects to strings;
    # leave everything else alone
    def from_pathname(path); end

    # Load a rakefile.
    def load_rakefile(path); end

    # Return the original directory where the Rake application was started.
    def original_dir; end

    def suggested_thread_count; end

    # Make +block_application+ the default rake application inside a block so
    # you can load rakefiles into a different application.
    #
    # This is useful when you want to run rake tasks inside a library without
    # running rake in a sub-shell.
    #
    # Example:
    #
    #   Dir.chdir 'other/directory'
    #
    #   other_rake = Rake.with_application do |rake|
    #     rake.load_rakefile
    #   end
    #
    #   puts other_rake.tasks
    def with_application(block_application = T.unsafe(nil)); end
  end
end

# Rake main application object.  When invoking +rake+ from the
# command line, a Rake::Application object is created and run.
class Rake::Application
  include ::Rake::TaskManager
  include ::Rake::TraceOutput

  # Initialize a Rake::Application object.
  #
  # @return [Application] a new instance of Application
  def initialize; end

  # Add a file to the list of files to be imported.
  def add_import(fn); end

  # Add a loader to handle imported files ending in the extension
  # +ext+.
  def add_loader(ext, loader); end

  # Collect the list of tasks on the command line.  If no tasks are
  # given, return a list containing only the default task.
  # Environmental assignments are processed at this time as well.
  #
  # `args` is the list of arguments to peruse to get the list of tasks.
  # It should be the command line that was given to rake, less any
  # recognised command-line options, which OptionParser.parse will
  # have taken care of already.
  def collect_command_line_tasks(args); end

  # Default task name ("default").
  # (May be overridden by subclasses)
  def default_task_name; end

  # Warn about deprecated usage.
  #
  # Example:
  #    Rake.application.deprecate("import", "Rake.import", caller.first)
  def deprecate(old_usage, new_usage, call_site); end

  def display_cause_details(ex); end

  # Display the error message that caused the exception.
  def display_error_message(ex); end

  def display_exception_backtrace(ex); end
  def display_exception_details(ex); end
  def display_exception_details_seen; end
  def display_exception_message_details(ex); end

  # Display the tasks and prerequisites
  def display_prerequisites; end

  # Display the tasks and comments.
  def display_tasks_and_comments; end

  # Calculate the dynamic width of the
  def dynamic_width; end

  def dynamic_width_stty; end
  def dynamic_width_tput; end

  # Exit the program because of an unhandled exception.
  # (may be overridden by subclasses)
  def exit_because_of_exception(ex); end

  def find_rakefile_location; end

  # Read and handle the command line options.  Returns the command line
  # arguments that we didn't understand, which should (in theory) be just
  # task names and env vars.
  def handle_options(argv); end

  # @return [Boolean]
  def has_cause?(ex); end

  # True if one of the files in RAKEFILES is in the current directory.
  # If a match is found, it is copied into @rakefile.
  def have_rakefile; end

  # Initialize the command line parameters and app name.
  def init(app_name = T.unsafe(nil), argv = T.unsafe(nil)); end

  # Invokes a task with arguments that are extracted from +task_string+
  def invoke_task(task_string); end

  # Load the pending list of imported files.
  def load_imports; end

  # Find the rakefile and then load it and any pending imports.
  def load_rakefile; end

  # The name of the application (typically 'rake')
  def name; end

  # Application options from the command line
  def options; end

  # The original directory where rake was invoked.
  def original_dir; end

  def parse_task_string(string); end
  def print_rakefile_directory(location); end

  # Similar to the regular Ruby +require+ command, but will check
  # for *.rake files in addition to *.rb files.
  def rake_require(file_name, paths = T.unsafe(nil), loaded = T.unsafe(nil)); end

  # Name of the actual rakefile used.
  def rakefile; end

  def rakefile_location(backtrace = T.unsafe(nil)); end
  def raw_load_rakefile; end

  # Run the Rake application.  The run method performs the following
  # three steps:
  #
  # * Initialize the command line options (+init+).
  # * Define the tasks (+load_rakefile+).
  # * Run the top level tasks (+top_level+).
  #
  # If you wish to build a custom rake command, you should call
  # +init+ on your application.  Then define any tasks.  Finally,
  # call +top_level+ to run your top level tasks.
  def run(argv = T.unsafe(nil)); end

  # Run the given block with the thread startup and shutdown.
  def run_with_threads; end

  def set_default_options; end

  # Provide standard exception handling for the given block.
  def standard_exception_handling; end

  # A list of all the standard options used in rake, suitable for
  # passing to OptionParser.
  def standard_rake_options; end

  # The directory path containing the system wide rakefiles.
  def system_dir; end

  # Number of columns on the terminal
  def terminal_columns; end

  # Number of columns on the terminal
  def terminal_columns=(_arg0); end

  def terminal_width; end

  # Return the thread pool used for multithreaded processing.
  def thread_pool; end

  # Run the top level tasks of a Rake application.
  def top_level; end

  # List of the top level task names (task names from the command line).
  def top_level_tasks; end

  def trace(*strings); end
  def truncate(string, width); end

  # We will truncate output if we are outputting to a TTY or if we've been
  # given an explicit column width to honor
  #
  # @return [Boolean]
  def truncate_output?; end

  # Override the detected TTY output state (mostly for testing)
  def tty_output=(_arg0); end

  # True if we are outputting to TTY, false otherwise
  #
  # @return [Boolean]
  def tty_output?; end

  # @return [Boolean]
  def unix?; end

  # @return [Boolean]
  def windows?; end

  private

  def glob(path, &block); end

  # Does the exception have a task invocation chain?
  #
  # @return [Boolean]
  def has_chain?(exception); end

  def select_tasks_to_show(options, show_tasks, value); end
  def select_trace_output(options, trace_option, value); end
  def sort_options(options); end
  def standard_system_dir; end
end

Rake::Application::DEFAULT_RAKEFILES = T.let(T.unsafe(nil), Array)

module Rake::Backtrace
  class << self
    def collapse(backtrace); end
  end
end

Rake::Backtrace::SUPPRESSED_PATHS = T.let(T.unsafe(nil), Array)
Rake::Backtrace::SUPPRESSED_PATHS_RE = T.let(T.unsafe(nil), String)
Rake::Backtrace::SUPPRESS_PATTERN = T.let(T.unsafe(nil), Regexp)
Rake::Backtrace::SYS_KEYS = T.let(T.unsafe(nil), Array)
Rake::Backtrace::SYS_PATHS = T.let(T.unsafe(nil), Array)

# Mixin for creating easily cloned objects.
module Rake::Cloneable
  private

  # The hook that is invoked by 'clone' and 'dup' methods.
  def initialize_copy(source); end
end

class Rake::CommandLineOptionError < ::StandardError; end

# Based on a script at:
#   http://stackoverflow.com/questions/891537/ruby-detect-number-of-cpus-installed
class Rake::CpuCounter
  def count; end
  def count_with_default(default = T.unsafe(nil)); end

  class << self
    def count; end
  end
end

# DSL is a module that provides #task, #desc, #namespace, etc.  Use this
# when you'd like to use rake outside the top level scope.
#
# For a Rakefile you run from the command line this module is automatically
# included.
module Rake::DSL
  include ::FileUtils::StreamUtils_
  include ::FileUtils
  include ::Rake::FileUtilsExt

  private

  # Describes the next rake task.  Duplicate descriptions are discarded.
  # Descriptions are shown with <code>rake -T</code> (up to the first
  # sentence) and <code>rake -D</code> (the entire description).
  #
  # Example:
  #   desc "Run the Unit Tests"
  #   task test: [:build]
  #     # ... run tests
  #   end
  def desc(description); end

  # Declare a set of files tasks to create the given directories on
  # demand.
  #
  # Example:
  #   directory "testdata/doc"
  def directory(*args, &block); end

  # Declare a file task.
  #
  # Example:
  #   file "config.cfg" => ["config.template"] do
  #     open("config.cfg", "w") do |outfile|
  #       open("config.template") do |infile|
  #         while line = infile.gets
  #           outfile.puts line
  #         end
  #       end
  #     end
  #  end
  def file(*args, &block); end

  # Declare a file creation task.
  # (Mainly used for the directory command).
  def file_create(*args, &block); end

  # Import the partial Rakefiles +fn+.  Imported files are loaded
  # _after_ the current file is completely loaded.  This allows the
  # import statement to appear anywhere in the importing file, and yet
  # allowing the imported files to depend on objects defined in the
  # importing file.
  #
  # A common use of the import statement is to include files
  # containing dependency declarations.
  #
  # See also the --rakelibdir command line option.
  #
  # Example:
  #   import ".depend", "my_rules"
  def import(*fns); end

  # Declare a task that performs its prerequisites in
  # parallel. Multitasks does *not* guarantee that its prerequisites
  # will execute in any given order (which is obvious when you think
  # about it)
  #
  # Example:
  #   multitask deploy: %w[deploy_gem deploy_rdoc]
  def multitask(*args, &block); end

  # Create a new rake namespace and use it for evaluating the given
  # block.  Returns a NameSpace object that can be used to lookup
  # tasks defined in the namespace.
  #
  # Example:
  #
  #   ns = namespace "nested" do
  #     # the "nested:run" task
  #     task :run
  #   end
  #   task_run = ns[:run] # find :run in the given namespace.
  #
  # Tasks can also be defined in a namespace by using a ":" in the task
  # name:
  #
  #   task "nested:test" do
  #     # ...
  #   end
  def namespace(name = T.unsafe(nil), &block); end

  # Declare a rule for auto-tasks.
  #
  # Example:
  #  rule '.o' => '.c' do |t|
  #    sh 'cc', '-o', t.name, t.source
  #  end
  def rule(*args, &block); end

  # :call-seq:
  #   task(task_name)
  #   task(task_name: dependencies)
  #   task(task_name, arguments => dependencies)
  #
  # Declare a basic task.  The +task_name+ is always the first argument.  If
  # the task name contains a ":" it is defined in that namespace.
  #
  # The +dependencies+ may be a single task name or an Array of task names.
  # The +argument+ (a single name) or +arguments+ (an Array of names) define
  # the arguments provided to the task.
  #
  # The task, argument and dependency names may be either symbols or
  # strings.
  #
  # A task with a single dependency:
  #
  #   task clobber: %w[clean] do
  #     rm_rf "html"
  #   end
  #
  # A task with an argument and a dependency:
  #
  #   task :package, [:version] => :test do |t, args|
  #     # ...
  #   end
  #
  # To invoke this task from the command line:
  #
  #   $ rake package[1.2.3]
  def task(*args, &block); end
end

# Default Rakefile loader used by +import+.
class Rake::DefaultLoader
  # Loads a rakefile into the current application from +fn+
  def load(fn); end
end

Rake::EARLY = T.let(T.unsafe(nil), Rake::EarlyTime)
Rake::EMPTY_TASK_ARGS = T.let(T.unsafe(nil), Rake::TaskArguments)

# EarlyTime is a fake timestamp that occurs _before_ any other time value.
class Rake::EarlyTime
  include ::Comparable
  include ::Singleton
  extend ::Singleton::SingletonClassMethods

  # The EarlyTime always comes before +other+!
  def <=>(other); end

  def to_s; end
end

# A FileCreationTask is a file task that when used as a dependency will be
# needed if and only if the file has not been created.  Once created, it is
# not re-triggered if any of its dependencies are newer, nor does trigger
# any rebuilds of tasks that depend on it whenever it is updated.
class Rake::FileCreationTask < ::Rake::FileTask
  # Is this file task needed?  Yes if it doesn't exist.
  #
  # @return [Boolean]
  def needed?; end

  # Time stamp for file creation task.  This time stamp is earlier
  # than any other time stamp.
  def timestamp; end
end

# A FileList is essentially an array with a few helper methods defined to
# make file manipulation a bit easier.
#
# FileLists are lazy.  When given a list of glob patterns for possible files
# to be included in the file list, instead of searching the file structures
# to find the files, a FileList holds the pattern for latter use.
#
# This allows us to define a number of FileList to match any number of
# files, but only search out the actual files when then FileList itself is
# actually used.  The key is that the first time an element of the
# FileList/Array is requested, the pending patterns are resolved into a real
# list of file names.
class Rake::FileList
  include ::Rake::Cloneable

  # Create a file list from the globbable patterns given.  If you wish to
  # perform multiple includes or excludes at object build time, use the
  # "yield self" pattern.
  #
  # Example:
  #   file_list = FileList.new('lib/**/*.rb', 'test/test*.rb')
  #
  #   pkg_files = FileList.new('lib/**/*') do |fl|
  #     fl.exclude(/\bCVS\b/)
  #   end
  #
  # @return [FileList] a new instance of FileList
  # @yield [_self]
  # @yieldparam _self [Rake::FileList] the object that the method was called on
  def initialize(*patterns); end

  def &(*args, &block); end

  # Redefine * to return either a string or a new file list.
  def *(other); end

  def +(*args, &block); end
  def -(*args, &block); end
  def <<(obj); end
  def <=>(*args, &block); end

  # A FileList is equal through array equality.
  def ==(array); end

  def [](*args, &block); end
  def []=(*args, &block); end

  # Add file names defined by glob patterns to the file list.  If an array
  # is given, add each element of the array.
  #
  # Example:
  #   file_list.include("*.java", "*.cfg")
  #   file_list.include %w( math.c lib.h *.o )
  def add(*filenames); end

  def all?(*args, &block); end
  def any?(*args, &block); end
  def append(*args, &block); end
  def assoc(*args, &block); end
  def at(*args, &block); end
  def bsearch(*args, &block); end
  def bsearch_index(*args, &block); end
  def chain(*args, &block); end
  def chunk(*args, &block); end
  def chunk_while(*args, &block); end
  def clear(*args, &block); end

  # Clear all the exclude patterns so that we exclude nothing.
  def clear_exclude; end

  def collect(*args, &block); end
  def collect!(*args, &block); end
  def collect_concat(*args, &block); end
  def combination(*args, &block); end
  def compact(*args, &block); end
  def compact!(*args, &block); end
  def compact_blank(*args, &block); end
  def compact_blank!(*args, &block); end
  def concat(*args, &block); end
  def count(*args, &block); end
  def cycle(*args, &block); end
  def deconstruct(*args, &block); end
  def delete(*args, &block); end
  def delete_at(*args, &block); end
  def delete_if(*args, &block); end
  def detect(*args, &block); end
  def difference(*args, &block); end
  def dig(*args, &block); end
  def drop(*args, &block); end
  def drop_while(*args, &block); end
  def each(*args, &block); end
  def each_cons(*args, &block); end
  def each_entry(*args, &block); end
  def each_index(*args, &block); end
  def each_slice(*args, &block); end
  def each_with_index(*args, &block); end
  def each_with_object(*args, &block); end

  # Grep each of the files in the filelist using the given pattern. If a
  # block is given, call the block on each matching line, passing the file
  # name, line number, and the matching line of text.  If no block is given,
  # a standard emacs style file:linenumber:line message will be printed to
  # standard out.  Returns the number of matched items.
  def egrep(pattern, *options); end

  def empty?(*args, &block); end
  def entries(*args, &block); end

  # Register a list of file name patterns that should be excluded from the
  # list.  Patterns may be regular expressions, glob patterns or regular
  # strings.  In addition, a block given to exclude will remove entries that
  # return true when given to the block.
  #
  # Note that glob patterns are expanded against the file system. If a file
  # is explicitly added to a file list, but does not exist in the file
  # system, then an glob pattern in the exclude list will not exclude the
  # file.
  #
  # Examples:
  #   FileList['a.c', 'b.c'].exclude("a.c") => ['b.c']
  #   FileList['a.c', 'b.c'].exclude(/^a/)  => ['b.c']
  #
  # If "a.c" is a file, then ...
  #   FileList['a.c', 'b.c'].exclude("a.*") => ['b.c']
  #
  # If "a.c" is not a file, then ...
  #   FileList['a.c', 'b.c'].exclude("a.*") => ['a.c', 'b.c']
  def exclude(*patterns, &block); end

  def exclude?(*args, &block); end

  # Should the given file name be excluded from the list?
  #
  # NOTE: This method was formerly named "exclude?", but Rails
  # introduced an exclude? method as an array method and setup a
  # conflict with file list. We renamed the method to avoid
  # confusion. If you were using "FileList#exclude?" in your user
  # code, you will need to update.
  #
  # @return [Boolean]
  def excluded_from_list?(fn); end

  def excluding(*args, &block); end

  # Return a new file list that only contains file names from the current
  # file list that exist on the file system.
  def existing; end

  # Modify the current file list so that it contains only file name that
  # exist on the file system.
  def existing!; end

  # Return a new FileList with <tt>String#ext</tt> method applied to
  # each member of the array.
  #
  # This method is a shortcut for:
  #
  #    array.collect { |item| item.ext(newext) }
  #
  # +ext+ is a user added method for the Array class.
  def ext(newext = T.unsafe(nil)); end

  def extract_options!(*args, &block); end
  def fetch(*args, &block); end
  def fifth(*args, &block); end
  def fill(*args, &block); end
  def filter(*args, &block); end
  def filter!(*args, &block); end
  def filter_map(*args, &block); end
  def find(*args, &block); end
  def find_all(*args, &block); end
  def find_index(*args, &block); end
  def first(*args, &block); end
  def flat_map(*args, &block); end
  def flatten(*args, &block); end
  def flatten!(*args, &block); end
  def forty_two(*args, &block); end
  def fourth(*args, &block); end
  def from(*args, &block); end
  def grep(*args, &block); end
  def grep_v(*args, &block); end
  def group_by(*args, &block); end

  # Return a new FileList with the results of running +gsub+ against each
  # element of the original list.
  #
  # Example:
  #   FileList['lib/test/file', 'x/y'].gsub(/\//, "\\")
  #      => ['lib\\test\\file', 'x\\y']
  def gsub(pat, rep); end

  # Same as +gsub+ except that the original file list is modified.
  def gsub!(pat, rep); end

  def import(array); end

  # Add file names defined by glob patterns to the file list.  If an array
  # is given, add each element of the array.
  #
  # Example:
  #   file_list.include("*.java", "*.cfg")
  #   file_list.include %w( math.c lib.h *.o )
  def include(*filenames); end

  def include?(*args, &block); end
  def including(*args, &block); end
  def index(*args, &block); end
  def index_by(*args, &block); end
  def index_with(*args, &block); end
  def inject(*args, &block); end
  def insert(*args, &block); end
  def inspect(*args, &block); end
  def intersection(*args, &block); end

  # Lie about our class.
  #
  # @return [Boolean]
  def is_a?(klass); end

  def join(*args, &block); end
  def keep_if(*args, &block); end

  # Lie about our class.
  #
  # @return [Boolean]
  def kind_of?(klass); end

  def last(*args, &block); end
  def lazy(*args, &block); end
  def length(*args, &block); end
  def many?(*args, &block); end
  def map(*args, &block); end
  def map!(*args, &block); end
  def max(*args, &block); end
  def max_by(*args, &block); end
  def member?(*args, &block); end
  def min(*args, &block); end
  def min_by(*args, &block); end
  def minmax(*args, &block); end
  def minmax_by(*args, &block); end
  def none?(*args, &block); end
  def one?(*args, &block); end
  def pack(*args, &block); end

  # FileList version of partition.  Needed because the nested arrays should
  # be FileLists in this version.
  def partition(&block); end

  # Apply the pathmap spec to each of the included file names, returning a
  # new file list with the modified paths.  (See String#pathmap for
  # details.)
  def pathmap(spec = T.unsafe(nil), &block); end

  def permutation(*args, &block); end
  def pick(*args, &block); end
  def place(*args, &block); end
  def pluck(*args, &block); end
  def pop(*args, &block); end
  def prepend(*args, &block); end
  def product(*args, &block); end
  def push(*args, &block); end
  def rassoc(*args, &block); end
  def reduce(*args, &block); end
  def reject(*args, &block); end
  def reject!(*args, &block); end
  def repeated_combination(*args, &block); end
  def repeated_permutation(*args, &block); end
  def replace(*args, &block); end

  # Resolve all the pending adds now.
  def resolve; end

  def reverse(*args, &block); end
  def reverse!(*args, &block); end
  def reverse_each(*args, &block); end
  def rindex(*args, &block); end
  def rotate(*args, &block); end
  def rotate!(*args, &block); end
  def sample(*args, &block); end
  def second(*args, &block); end
  def second_to_last(*args, &block); end
  def select(*args, &block); end
  def select!(*args, &block); end
  def shelljoin(*args, &block); end
  def shift(*args, &block); end
  def shuffle(*args, &block); end
  def shuffle!(*args, &block); end
  def size(*args, &block); end
  def slice(*args, &block); end
  def slice!(*args, &block); end
  def slice_after(*args, &block); end
  def slice_before(*args, &block); end
  def slice_when(*args, &block); end
  def sort(*args, &block); end
  def sort!(*args, &block); end
  def sort_by(*args, &block); end
  def sort_by!(*args, &block); end

  # Return a new FileList with the results of running +sub+ against each
  # element of the original list.
  #
  # Example:
  #   FileList['a.c', 'b.c'].sub(/\.c$/, '.o')  => ['a.o', 'b.o']
  def sub(pat, rep); end

  # Same as +sub+ except that the original file list is modified.
  def sub!(pat, rep); end

  def sum(*args, &block); end
  def take(*args, &block); end
  def take_while(*args, &block); end
  def tally(*args, &block); end
  def third(*args, &block); end
  def third_to_last(*args, &block); end
  def to(*args, &block); end

  # Return the internal array object.
  def to_a; end

  # Return the internal array object.
  def to_ary; end

  def to_default_s(*args, &block); end
  def to_formatted_s(*args, &block); end
  def to_h(*args, &block); end

  # Convert a FileList to a string by joining all elements with a space.
  def to_s; end

  def to_sentence(*args, &block); end
  def to_set(*args, &block); end
  def to_xml(*args, &block); end
  def transpose(*args, &block); end
  def union(*args, &block); end
  def uniq(*args, &block); end
  def uniq!(*args, &block); end
  def unshift(*args, &block); end
  def values_at(*args, &block); end
  def without(*args, &block); end
  def zip(*args, &block); end
  def |(*args, &block); end

  private

  # Add matching glob patterns.
  def add_matching(pattern); end

  def resolve_add(fn); end
  def resolve_exclude; end

  class << self
    # Create a new file list including the files listed. Similar to:
    #
    #   FileList.new(*args)
    def [](*args); end

    # Get a sorted list of files matching the pattern. This method
    # should be preferred to Dir[pattern] and Dir.glob(pattern) because
    # the files returned are guaranteed to be sorted.
    def glob(pattern, *args); end
  end
end

# List of array methods (that are not in +Object+) that need to be
# delegated.
Rake::FileList::ARRAY_METHODS = T.let(T.unsafe(nil), Array)

Rake::FileList::DEFAULT_IGNORE_PATTERNS = T.let(T.unsafe(nil), Array)
Rake::FileList::DEFAULT_IGNORE_PROCS = T.let(T.unsafe(nil), Array)
Rake::FileList::DELEGATING_METHODS = T.let(T.unsafe(nil), Array)
Rake::FileList::GLOB_PATTERN = T.let(T.unsafe(nil), Regexp)

# List of additional methods that must be delegated.
Rake::FileList::MUST_DEFINE = T.let(T.unsafe(nil), Array)

# List of methods that should not be delegated here (we define special
# versions of them explicitly below).
Rake::FileList::MUST_NOT_DEFINE = T.let(T.unsafe(nil), Array)

# List of delegated methods that return new array values which need
# wrapping.
Rake::FileList::SPECIAL_RETURN = T.let(T.unsafe(nil), Array)

# A FileTask is a task that includes time based dependencies.  If any of a
# FileTask's prerequisites have a timestamp that is later than the file
# represented by this task, then the file must be rebuilt (using the
# supplied actions).
class Rake::FileTask < ::Rake::Task
  # Is this file task needed?  Yes if it doesn't exist, or if its time stamp
  # is out of date.
  #
  # @return [Boolean]
  def needed?; end

  # Time stamp for file task.
  def timestamp; end

  private

  # Are there any prerequisites with a later time than the given time stamp?
  #
  # @return [Boolean]
  def out_of_date?(stamp); end

  class << self
    # Apply the scope to the task name according to the rules for this kind
    # of task.  File based tasks ignore the scope when creating the name.
    def scope_name(scope, task_name); end
  end
end

# FileUtilsExt provides a custom version of the FileUtils methods
# that respond to the <tt>verbose</tt> and <tt>nowrite</tt>
# commands.
module Rake::FileUtilsExt
  include ::FileUtils::StreamUtils_
  include ::FileUtils
  extend ::FileUtils::StreamUtils_
  extend ::FileUtils
  extend ::Rake::FileUtilsExt

  def cd(*args, **options, &block); end
  def chdir(*args, **options, &block); end
  def chmod(*args, **options, &block); end
  def chmod_R(*args, **options, &block); end
  def chown(*args, **options, &block); end
  def chown_R(*args, **options, &block); end
  def copy(*args, **options, &block); end
  def cp(*args, **options, &block); end
  def cp_lr(*args, **options, &block); end
  def cp_r(*args, **options, &block); end
  def install(*args, **options, &block); end
  def link(*args, **options, &block); end
  def ln(*args, **options, &block); end
  def ln_s(*args, **options, &block); end
  def ln_sf(*args, **options, &block); end
  def makedirs(*args, **options, &block); end
  def mkdir(*args, **options, &block); end
  def mkdir_p(*args, **options, &block); end
  def mkpath(*args, **options, &block); end
  def move(*args, **options, &block); end
  def mv(*args, **options, &block); end

  # Get/set the nowrite flag controlling output from the FileUtils
  # utilities.  If verbose is true, then the utility method is
  # echoed to standard output.
  #
  # Examples:
  #    nowrite              # return the current value of the
  #                         # nowrite flag
  #    nowrite(v)           # set the nowrite flag to _v_.
  #    nowrite(v) { code }  # Execute code with the nowrite flag set
  #                         # temporarily to _v_. Return to the
  #                         # original value when code is done.
  def nowrite(value = T.unsafe(nil)); end

  # Check that the options do not contain options not listed in
  # +optdecl+.  An ArgumentError exception is thrown if non-declared
  # options are found.
  #
  # @raise [ArgumentError]
  def rake_check_options(options, *optdecl); end

  # Send the message to the default rake output (which is $stderr).
  def rake_output_message(message); end

  def remove(*args, **options, &block); end
  def rm(*args, **options, &block); end
  def rm_f(*args, **options, &block); end
  def rm_r(*args, **options, &block); end
  def rm_rf(*args, **options, &block); end
  def rmdir(*args, **options, &block); end
  def rmtree(*args, **options, &block); end
  def safe_unlink(*args, **options, &block); end
  def symlink(*args, **options, &block); end
  def touch(*args, **options, &block); end

  # Get/set the verbose flag controlling output from the FileUtils
  # utilities.  If verbose is true, then the utility method is
  # echoed to standard output.
  #
  # Examples:
  #    verbose              # return the current value of the
  #                         # verbose flag
  #    verbose(v)           # set the verbose flag to _v_.
  #    verbose(v) { code }  # Execute code with the verbose flag set
  #                         # temporarily to _v_.  Return to the
  #                         # original value when code is done.
  def verbose(value = T.unsafe(nil)); end

  # Use this function to prevent potentially destructive ruby code
  # from running when the :nowrite flag is set.
  #
  # Example:
  #
  #   when_writing("Building Project") do
  #     project.build
  #   end
  #
  # The following code will build the project under normal
  # conditions. If the nowrite(true) flag is set, then the example
  # will print:
  #
  #      DRYRUN: Building Project
  #
  # instead of actually building the project.
  def when_writing(msg = T.unsafe(nil)); end

  class << self
    # Returns the value of attribute nowrite_flag.
    def nowrite_flag; end

    # Sets the attribute nowrite_flag
    #
    # @param value the value to set the attribute nowrite_flag to.
    def nowrite_flag=(_arg0); end

    # Returns the value of attribute verbose_flag.
    def verbose_flag; end

    # Sets the attribute verbose_flag
    #
    # @param value the value to set the attribute verbose_flag to.
    def verbose_flag=(_arg0); end
  end
end

Rake::FileUtilsExt::DEFAULT = T.let(T.unsafe(nil), Object)

# InvocationChain tracks the chain of task invocations to detect
# circular dependencies.
class Rake::InvocationChain < ::Rake::LinkedList
  # Append an invocation to the chain of invocations. It is an error
  # if the invocation already listed.
  def append(invocation); end

  # Is the invocation already in the chain?
  #
  # @return [Boolean]
  def member?(invocation); end

  # Convert to string, ie: TOP => invocation => invocation
  def to_s; end

  private

  def prefix; end

  class << self
    # Class level append.
    def append(invocation, chain); end
  end
end

Rake::InvocationChain::EMPTY = T.let(T.unsafe(nil), Rake::InvocationChain::EmptyInvocationChain)

# Null object for an empty chain.
class Rake::InvocationChain::EmptyInvocationChain < ::Rake::LinkedList::EmptyLinkedList
  def append(invocation); end

  # @return [Boolean]
  def member?(obj); end

  def to_s; end
end

module Rake::InvocationExceptionMixin
  # Return the invocation chain (list of Rake tasks) that were in
  # effect when this exception was detected by rake.  May be null if
  # no tasks were active.
  def chain; end

  # Set the invocation chain in effect when this exception was
  # detected.
  def chain=(value); end
end

Rake::LATE = T.let(T.unsafe(nil), Rake::LateTime)

# LateTime is a fake timestamp that occurs _after_ any other time value.
class Rake::LateTime
  include ::Comparable
  include ::Singleton
  extend ::Singleton::SingletonClassMethods

  def <=>(other); end
  def to_s; end
end

# Polylithic linked list structure used to implement several data
# structures in Rake.
class Rake::LinkedList
  include ::Enumerable

  # @return [LinkedList] a new instance of LinkedList
  def initialize(head, tail = T.unsafe(nil)); end

  # Lists are structurally equivalent.
  def ==(other); end

  # Polymorphically add a new element to the head of a list. The
  # type of head node will be the same list type as the tail.
  def conj(item); end

  # For each item in the list.
  def each; end

  # Is the list empty?
  # .make guards against a list being empty making any instantiated LinkedList
  # object not empty by default
  # You should consider overriding this method if you implement your own .make method
  #
  # @return [Boolean]
  def empty?; end

  # Returns the value of attribute head.
  def head; end

  # Same as +to_s+, but with inspected items.
  def inspect; end

  # Returns the value of attribute tail.
  def tail; end

  # Convert to string: LL(item, item...)
  def to_s; end

  class << self
    # Cons a new head onto the tail list.
    def cons(head, tail); end

    # The standard empty list class for the given LinkedList class.
    def empty; end

    # Make a list out of the given arguments. This method is
    # polymorphic
    def make(*args); end
  end
end

Rake::LinkedList::EMPTY = T.let(T.unsafe(nil), Rake::LinkedList::EmptyLinkedList)

# Represent an empty list, using the Null Object Pattern.
#
# When inheriting from the LinkedList class, you should implement
# a type specific Empty class as well. Make sure you set the class
# instance variable @parent to the associated list class (this
# allows conj, cons and make to work polymorphically).
class Rake::LinkedList::EmptyLinkedList < ::Rake::LinkedList
  # @return [EmptyLinkedList] a new instance of EmptyLinkedList
  def initialize; end

  # @return [Boolean]
  def empty?; end

  class << self
    def cons(head, tail); end
  end
end

# Same as a regular task, but the immediate prerequisites are done in
# parallel using Ruby threads.
class Rake::MultiTask < ::Rake::Task
  private

  def invoke_prerequisites(task_args, invocation_chain); end
end

# The NameSpace class will lookup task names in the scope defined by a
# +namespace+ command.
class Rake::NameSpace
  # Create a namespace lookup object using the given task manager
  # and the list of scopes.
  #
  # @return [NameSpace] a new instance of NameSpace
  def initialize(task_manager, scope_list); end

  # Lookup a task named +name+ in the namespace.
  def [](name); end

  # The scope of the namespace (a LinkedList)
  def scope; end

  # Return the list of tasks defined in this and nested namespaces.
  def tasks; end
end

# Include PrivateReader to use +private_reader+.
module Rake::PrivateReader
  mixes_in_class_methods ::Rake::PrivateReader::ClassMethods

  class << self
    def included(base); end
  end
end

module Rake::PrivateReader::ClassMethods
  # Declare a list of private accessors
  def private_reader(*names); end
end

# A Promise object represents a promise to do work (a chore) in the
# future. The promise is created with a block and a list of
# arguments for the block. Calling value will return the value of
# the promised chore.
#
# Used by ThreadPool.
class Rake::Promise
  # Create a promise to do the chore specified by the block.
  #
  # @return [Promise] a new instance of Promise
  def initialize(args, &block); end

  def recorder; end
  def recorder=(_arg0); end

  # Return the value of this promise.
  #
  # If the promised chore is not yet complete, then do the work
  # synchronously. We will wait.
  def value; end

  # If no one else is working this promise, go ahead and do the chore.
  def work; end

  private

  # Perform the chore promised
  def chore; end

  # Are we done with the promise
  #
  # @return [Boolean]
  def complete?; end

  # free up these items for the GC
  def discard; end

  # Did the promise throw an error
  #
  # @return [Boolean]
  def error?; end

  # Do we have a result for the promise
  #
  # @return [Boolean]
  def result?; end

  # Record execution statistics if there is a recorder
  def stat(*args); end
end

Rake::Promise::NOT_SET = T.let(T.unsafe(nil), Object)

# Exit status class for times the system just gives us a nil.
class Rake::PseudoStatus
  # @return [PseudoStatus] a new instance of PseudoStatus
  def initialize(code = T.unsafe(nil)); end

  def >>(n); end

  # @return [Boolean]
  def exited?; end

  def exitstatus; end

  # @return [Boolean]
  def stopped?; end

  def to_i; end
end

Rake::RDocTask = RDoc::Task

# Error indicating a recursion overflow error in task selection.
class Rake::RuleRecursionOverflowError < ::StandardError
  # @return [RuleRecursionOverflowError] a new instance of RuleRecursionOverflowError
  def initialize(*args); end

  def add_target(target); end
  def message; end
end

class Rake::Scope < ::Rake::LinkedList
  # Path for the scope.
  def path; end

  # Path for the scope + the named path.
  def path_with_task_name(task_name); end

  # Trim +n+ innermost scope levels from the scope. In no case will
  # this trim beyond the toplevel scope.
  def trim(n); end
end

# Singleton null object for an empty scope.
Rake::Scope::EMPTY = T.let(T.unsafe(nil), Rake::Scope::EmptyScope)

# Scope lists always end with an EmptyScope object. See Null
# Object Pattern)
class Rake::Scope::EmptyScope < ::Rake::LinkedList::EmptyLinkedList
  def path; end
  def path_with_task_name(task_name); end
end

# A Task is the basic unit of work in a Rakefile.  Tasks have associated
# actions (possibly more than one) and a list of prerequisites.  When
# invoked, a task will first ensure that all of its prerequisites have an
# opportunity to run and then it will execute its own actions.
#
# Tasks are not usually created directly using the new method, but rather
# use the +file+ and +task+ convenience methods.
class Rake::Task
  # Create a task named +task_name+ with no actions or prerequisites. Use
  # +enhance+ to add actions and prerequisites.
  #
  # @return [Task] a new instance of Task
  def initialize(task_name, app); end

  # List of actions attached to a task.
  def actions; end

  # Add a description to the task.  The description can consist of an option
  # argument list (enclosed brackets) and an optional comment.
  def add_description(description); end

  # List of all unique prerequisite tasks including prerequisite tasks'
  # prerequisites.
  # Includes self when cyclic dependencies are found.
  def all_prerequisite_tasks; end

  # Has this task already been invoked?  Already invoked tasks
  # will be skipped unless you reenable them.
  def already_invoked; end

  # Application owning this task.
  def application; end

  # Application owning this task.
  def application=(_arg0); end

  # Argument description (nil if none).
  def arg_description; end

  # Name of arguments for this task.
  def arg_names; end

  # Clear the existing prerequisites, actions, comments, and arguments of a rake task.
  def clear; end

  # Clear the existing actions on a rake task.
  def clear_actions; end

  # Clear the existing arguments on a rake task.
  def clear_args; end

  # Clear the existing comments on a rake task.
  def clear_comments; end

  # Clear the existing prerequisites of a rake task.
  def clear_prerequisites; end

  # First line (or sentence) of all comments. Multiple comments are
  # separated by a "/".
  def comment; end

  def comment=(comment); end

  # Enhance a task with prerequisites or actions.  Returns self.
  def enhance(deps = T.unsafe(nil), &block); end

  # Execute the actions associated with this task.
  def execute(args = T.unsafe(nil)); end

  # Full collection of comments. Multiple comments are separated by
  # newlines.
  def full_comment; end

  def inspect; end

  # Return a string describing the internal state of a task.  Useful for
  # debugging.
  def investigation; end

  # Invoke the task if it is needed.  Prerequisites are invoked first.
  def invoke(*args); end

  # Invoke all the prerequisites of a task.
  def invoke_prerequisites(task_args, invocation_chain); end

  # Invoke all the prerequisites of a task in parallel.
  def invoke_prerequisites_concurrently(task_args, invocation_chain); end

  # File/Line locations of each of the task definitions for this
  # task (only valid if the task was defined with the detect
  # location option set).
  def locations; end

  # Name of the task, including any namespace qualifiers.
  def name; end

  # Name of task with argument list description.
  def name_with_args; end

  # Is this task needed?
  #
  # @return [Boolean]
  def needed?; end

  # List of order only prerequisites for a task.
  def order_only_prerequisites; end

  # List of prerequisites for a task.
  def prereqs; end

  # List of prerequisite tasks
  def prerequisite_tasks; end

  # List of prerequisites for a task.
  def prerequisites; end

  # Reenable the task, allowing its tasks to be executed if the task
  # is invoked again.
  def reenable; end

  # Array of nested namespaces names used for task lookup by this task.
  def scope; end

  # Set the names of the arguments for this task. +args+ should be
  # an array of symbols, one for each argument name.
  def set_arg_names(args); end

  # First source from a rule (nil if no sources)
  def source; end

  def sources; end

  # List of sources for task.
  def sources=(_arg0); end

  # Timestamp for this task.  Basic tasks return the current time for their
  # time stamp.  Other tasks can be more sophisticated.
  def timestamp; end

  # Return task name
  def to_s; end

  # Add order only dependencies.
  def |(deps); end

  protected

  def collect_prerequisites(seen); end

  # Same as invoke, but explicitly pass a call chain to detect
  # circular dependencies.
  #
  # If multiple tasks depend on this
  # one in parallel, they will all fail if the first execution of
  # this task fails.
  def invoke_with_call_chain(task_args, invocation_chain); end

  private

  def add_chain_to(exception, new_chain); end
  def add_comment(comment); end

  # Get the first sentence in a string. The sentence is terminated
  # by the first period, exclamation mark, or the end of the line.
  # Decimal points do not count as periods.
  def first_sentence(string); end

  # Format the trace flags for display.
  def format_trace_flags; end

  def lookup_prerequisite(prerequisite_name); end

  # Transform the list of comments as specified by the block and
  # join with the separator.
  def transform_comments(separator, &block); end

  class << self
    # Return a task with the given name.  If the task is not currently
    # known, try to synthesize one from the defined rules.  If no rules are
    # found, but an existing file matches the task name, assume it is a file
    # task with no dependencies or actions.
    def [](task_name); end

    # Clear the task list.  This cause rake to immediately forget all the
    # tasks that have been assigned.  (Normally used in the unit tests.)
    def clear; end

    # Define a rule for synthesizing tasks.
    def create_rule(*args, &block); end

    # Define a task given +args+ and an option block.  If a rule with the
    # given name already exists, the prerequisites and actions are added to
    # the existing task.  Returns the defined task.
    def define_task(*args, &block); end

    # Format dependencies parameter to pass to task.
    def format_deps(deps); end

    # Apply the scope to the task name according to the rules for
    # this kind of task.  Generic tasks will accept the scope as
    # part of the name.
    def scope_name(scope, task_name); end

    # TRUE if the task name is already defined.
    #
    # @return [Boolean]
    def task_defined?(task_name); end

    # List of all defined tasks.
    def tasks; end
  end
end

# Error indicating an ill-formed task declaration.
class Rake::TaskArgumentError < ::ArgumentError; end

# TaskArguments manage the arguments passed to a task.
class Rake::TaskArguments
  include ::Enumerable

  # Create a TaskArgument object with a list of argument +names+ and a set
  # of associated +values+.  +parent+ is the parent argument object.
  #
  # @return [TaskArguments] a new instance of TaskArguments
  def initialize(names, values, parent = T.unsafe(nil)); end

  # Find an argument value by name or index.
  def [](index); end

  # Enumerates the arguments and their values
  def each(&block); end

  # Retrieve the list of values not associated with named arguments
  def extras; end

  def fetch(*args, &block); end

  # Returns true if +key+ is one of the arguments
  #
  # @return [Boolean]
  def has_key?(key); end

  def inspect; end

  # Returns true if +key+ is one of the arguments
  #
  # @return [Boolean]
  def key?(key); end

  # Returns the value of the given argument via method_missing
  def method_missing(sym, *args); end

  # Argument names
  def names; end

  # Create a new argument scope using the prerequisite argument
  # names.
  def new_scope(names); end

  # Retrieve the complete array of sequential values
  def to_a; end

  # Returns a Hash of arguments and their values
  def to_hash; end

  def to_s; end

  # Extracts the argument values at +keys+
  def values_at(*keys); end

  # Specify a hash of default values for task arguments. Use the
  # defaults only if there is no specific value for the given
  # argument.
  def with_defaults(defaults); end

  protected

  def lookup(name); end
end

# Base class for Task Libraries.
class Rake::TaskLib
  include ::Rake::Cloneable
  include ::FileUtils::StreamUtils_
  include ::FileUtils
  include ::Rake::FileUtilsExt
  include ::Rake::DSL
end

# The TaskManager module is a mixin for managing tasks.
module Rake::TaskManager
  def initialize; end

  # Find a matching task for +task_name+.
  def [](task_name, scopes = T.unsafe(nil)); end

  # Clear all tasks in this application.
  def clear; end

  def create_rule(*args, &block); end

  # Return the list of scope names currently active in the task
  # manager.
  def current_scope; end

  def define_task(task_class, *args, &block); end

  # If a rule can be found that matches the task name, enhance the
  # task with the prerequisites and actions from the rule.  Set the
  # source attribute of the task appropriately for the rule.  Return
  # the enhanced task or nil of no rule was found.
  def enhance_with_matching_rule(task_name, level = T.unsafe(nil)); end

  def generate_did_you_mean_suggestions(task_name); end
  def generate_message_for_undefined_task(task_name); end

  # Evaluate the block in a nested namespace named +name+.  Create
  # an anonymous namespace if +name+ is nil.
  def in_namespace(name); end

  # Lookup a task.  Return an existing task if found, otherwise
  # create a task of the current type.
  def intern(task_class, task_name); end

  # Track the last comment made in the Rakefile.
  def last_description; end

  # Track the last comment made in the Rakefile.
  def last_description=(_arg0); end

  # Lookup a task, using scope and the scope hints in the task name.
  # This method performs straight lookups without trying to
  # synthesize file tasks or rules.  Special scope names (e.g. '^')
  # are recognized.  If no scope argument is supplied, use the
  # current scope.  Return nil if the task cannot be found.
  def lookup(task_name, initial_scope = T.unsafe(nil)); end

  # Resolve the arguments for a task/rule.  Returns a tuple of
  # [task_name, arg_name_list, prerequisites, order_only_prerequisites].
  def resolve_args(args); end

  def synthesize_file_task(task_name); end

  # List of all defined tasks in this application.
  def tasks; end

  # List of all the tasks defined in the given scope (and its
  # sub-scopes).
  def tasks_in_scope(scope); end

  private

  # Add a location to the locations field of the given task.
  def add_location(task); end

  # Attempt to create a rule given the list of prerequisites.
  def attempt_rule(task_name, task_pattern, args, extensions, block, level); end

  # Find the location that called into the dsl layer.
  def find_location; end

  # Generate an anonymous namespace name.
  def generate_name; end

  # Return the current description, clearing it in the process.
  def get_description(task); end

  # Lookup the task name
  def lookup_in_scope(name, scope); end

  # Make a list of sources from the list of file name extensions /
  # translation procs.
  def make_sources(task_name, task_pattern, extensions); end

  # Resolve task arguments for a task or rule when there are
  # dependencies declared.
  #
  # The patterns recognized by this argument resolving function are:
  #
  #   task :t, order_only: [:e]
  #   task :t => [:d]
  #   task :t => [:d], order_only: [:e]
  #   task :t, [a] => [:d]
  #   task :t, [a] => [:d], order_only: [:e]
  def resolve_args_with_dependencies(args, hash); end

  # Resolve task arguments for a task or rule when there are no
  # dependencies declared.
  #
  # The patterns recognized by this argument resolving function are:
  #
  #   task :t
  #   task :t, [:a]
  def resolve_args_without_dependencies(args); end

  def trace_rule(level, message); end

  class << self
    def record_task_metadata; end
    def record_task_metadata=(_arg0); end
  end
end

class Rake::ThreadHistoryDisplay
  include ::Rake::PrivateReader
  extend ::Rake::PrivateReader::ClassMethods

  # @return [ThreadHistoryDisplay] a new instance of ThreadHistoryDisplay
  def initialize(stats); end

  def show; end

  private

  def items; end
  def rename(hash, key, renames); end
  def stats; end
  def threads; end
end

class Rake::ThreadPool
  # Creates a ThreadPool object.  The +thread_count+ parameter is the size
  # of the pool.
  #
  # @return [ThreadPool] a new instance of ThreadPool
  def initialize(thread_count); end

  # Creates a future executed by the +ThreadPool+.
  #
  # The args are passed to the block when executing (similarly to
  # Thread#new) The return value is an object representing
  # a future which has been created and added to the queue in the
  # pool. Sending #value to the object will sleep the
  # current thread until the future is finished and will return the
  # result (or raise an exception thrown from the future)
  def future(*args, &block); end

  # Enable the gathering of history events.
  def gather_history; end

  # Return a array of history events for the thread pool.
  #
  # History gathering must be enabled to be able to see the events
  # (see #gather_history). Best to call this when the job is
  # complete (i.e. after ThreadPool#join is called).
  def history; end

  # Waits until the queue of futures is empty and all threads have exited.
  def join; end

  # Return a hash of always collected statistics for the thread pool.
  def statistics; end

  private

  # for testing only
  def __queue__; end

  # processes one item on the queue. Returns true if there was an
  # item to process, false if there was no item
  def process_queue_item; end

  def safe_thread_count; end
  def start_thread; end
  def stat(event, data = T.unsafe(nil)); end
end

module Rake::TraceOutput
  # Write trace output to output stream +out+.
  #
  # The write is done as a single IO call (to print) to lessen the
  # chance that the trace output is interrupted by other tasks also
  # producing output.
  def trace_on(out, *strings); end
end

Rake::VERSION = T.let(T.unsafe(nil), String)
module Rake::Version; end
Rake::Version::BUILD = T.let(T.unsafe(nil), String)
Rake::Version::MAJOR = T.let(T.unsafe(nil), String)
Rake::Version::MINOR = T.let(T.unsafe(nil), String)
Rake::Version::NUMBERS = T.let(T.unsafe(nil), Array)
Rake::Version::OTHER = T.let(T.unsafe(nil), Array)

# Win 32 interface methods for Rake. Windows specific functionality
# will be placed here to collect that knowledge in one spot.
module Rake::Win32
  class << self
    # Normalize a win32 path so that the slashes are all forward slashes.
    def normalize(path); end

    # The standard directory containing system wide rake files on
    # Win 32 systems. Try the following environment variables (in
    # order):
    #
    # * HOME
    # * HOMEDRIVE + HOMEPATH
    # * APPDATA
    # * USERPROFILE
    #
    # If the above are not defined, the return nil.
    #
    # @raise [Win32HomeError]
    def win32_system_dir; end

    # True if running on a windows system.
    #
    # @return [Boolean]
    def windows?; end
  end
end

# Error indicating a problem in locating the home directory on a
# Win32 system.
class Rake::Win32::Win32HomeError < ::RuntimeError; end

RakeFileUtils = Rake::FileUtilsExt

class String
  include ::Comparable
  include ::JSON::Ext::Generator::GeneratorMethods::String
  extend ::JSON::Ext::Generator::GeneratorMethods::String::Extend

  def ext(newext = T.unsafe(nil)); end
  def pathmap(spec = T.unsafe(nil), &block); end

  protected

  def pathmap_explode; end
  def pathmap_partial(n); end
  def pathmap_replace(patterns, &block); end
end

String::BLANK_RE = T.let(T.unsafe(nil), Regexp)
String::ENCODED_BLANKS = T.let(T.unsafe(nil), Concurrent::Map)
