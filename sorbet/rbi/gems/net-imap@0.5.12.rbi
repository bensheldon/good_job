# typed: false

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `net-imap` gem.
# Please instead update this file by running `bin/tapioca gem net-imap`.


# source://net-imap//lib/net/imap.rb#790
class Net::IMAP < ::Net::Protocol
  include ::Net::IMAP::DeprecatedClientOptions
  include ::MonitorMixin
  include ::OpenSSL
  include ::OpenSSL::SSL
  extend ::Net::IMAP::Authenticators

  # source://net-imap//lib/net/imap.rb#1082
  def initialize(host, port_or_options = T.unsafe(nil), *deprecated, **options); end

  # source://net-imap//lib/net/imap.rb#3327
  def add_response_handler(handler = T.unsafe(nil), &block); end

  # source://net-imap//lib/net/imap.rb#2034
  def append(mailbox, message, flags = T.unsafe(nil), date_time = T.unsafe(nil)); end

  # source://net-imap//lib/net/imap.rb#1229
  def auth_capable?(mechanism); end

  # source://net-imap//lib/net/imap.rb#1212
  def auth_mechanisms; end

  # source://net-imap//lib/net/imap.rb#1524
  def authenticate(*args, sasl_ir: T.unsafe(nil), **props, &callback); end

  # source://net-imap//lib/net/imap.rb#1188
  def capabilities; end

  # source://net-imap//lib/net/imap.rb#1239
  def capabilities_cached?; end

  # source://net-imap//lib/net/imap.rb#1277
  def capability; end

  # source://net-imap//lib/net/imap.rb#1175
  def capability?(capability); end

  # source://net-imap//lib/net/imap.rb#1174
  def capable?(capability); end

  # source://net-imap//lib/net/imap.rb#2050
  def check; end

  # source://net-imap//lib/net/imap.rb#1252
  def clear_cached_capabilities; end

  # source://net-imap//lib/net/imap.rb#3256
  def clear_responses(type = T.unsafe(nil)); end

  # source://net-imap//lib/net/imap.rb#2060
  def close; end

  # source://net-imap//lib/net/imap.rb#865
  def config; end

  # source://net-imap//lib/net/imap.rb#970
  def connection_state; end

  # source://net-imap//lib/net/imap.rb#2789
  def copy(set, mailbox); end

  # source://net-imap//lib/net/imap.rb#1634
  def create(mailbox); end

  # source://net-imap//lib/net/imap.rb#1646
  def delete(mailbox); end

  # source://net-imap//lib/net/imap.rb#1138
  def disconnect; end

  # source://net-imap//lib/net/imap.rb#1160
  def disconnected?; end

  # source://net-imap//lib/net/imap.rb#3031
  def enable(*capabilities); end

  # source://net-imap//lib/net/imap.rb#1616
  def examine(mailbox, condstore: T.unsafe(nil)); end

  # source://net-imap//lib/net/imap.rb#2108
  def expunge; end

  # source://net-imap//lib/net/imap.rb#3280
  def extract_responses(type); end

  # source://net-imap//lib/net/imap.rb#2633
  def fetch(*_arg0, **_arg1, &_arg2); end

  # source://net-imap//lib/net/imap.rb#1914
  def getacl(mailbox); end

  # source://net-imap//lib/net/imap.rb#1858
  def getquota(mailbox); end

  # source://net-imap//lib/net/imap.rb#1837
  def getquotaroot(mailbox); end

  # source://net-imap//lib/net/imap.rb#859
  def greeting; end

  # source://net-imap//lib/net/imap.rb#891
  def host; end

  # source://net-imap//lib/net/imap.rb#1306
  def id(client_id = T.unsafe(nil)); end

  # source://net-imap//lib/net/imap.rb#3075
  def idle(timeout = T.unsafe(nil), &response_handler); end

  # source://net-imap//lib/net/imap.rb#3111
  def idle_done; end

  # source://net-imap//lib/net/imap.rb#885
  def idle_response_timeout; end

  # source://net-imap//lib/net/imap.rb#1718
  def list(refname, mailbox); end

  # source://net-imap//lib/net/imap.rb#1555
  def login(user, password); end

  # source://net-imap//lib/net/imap.rb#1334
  def logout; end

  # source://net-imap//lib/net/imap.rb#1351
  def logout!; end

  # source://net-imap//lib/net/imap.rb#1929
  def lsub(refname, mailbox); end

  # source://net-imap//lib/net/imap.rb#886
  def max_response_size; end

  # source://net-imap//lib/net/imap.rb#887
  def max_response_size=(val); end

  # source://net-imap//lib/net/imap.rb#2830
  def move(set, mailbox); end

  # source://net-imap//lib/net/imap.rb#1775
  def namespace; end

  # source://net-imap//lib/net/imap.rb#1325
  def noop; end

  # source://net-imap//lib/net/imap.rb#884
  def open_timeout; end

  # source://net-imap//lib/net/imap.rb#894
  def port; end

  # source://net-imap//lib/net/imap.rb#3337
  def remove_response_handler(handler); end

  # source://net-imap//lib/net/imap.rb#1659
  def rename(mailbox, newname); end

  # source://net-imap//lib/net/imap.rb#3306
  def response_handlers; end

  # source://net-imap//lib/net/imap.rb#3222
  def responses(type = T.unsafe(nil)); end

  # source://net-imap//lib/net/imap.rb#2552
  def search(*_arg0, **_arg1, &_arg2); end

  # source://net-imap//lib/net/imap.rb#1596
  def select(mailbox, condstore: T.unsafe(nil)); end

  # source://net-imap//lib/net/imap.rb#1896
  def setacl(mailbox, user, rights); end

  # source://net-imap//lib/net/imap.rb#1876
  def setquota(mailbox, quota); end

  # source://net-imap//lib/net/imap.rb#2878
  def sort(sort_keys, search_keys, charset); end

  # source://net-imap//lib/net/imap.rb#902
  def ssl_ctx; end

  # source://net-imap//lib/net/imap.rb#909
  def ssl_ctx_params; end

  # source://net-imap//lib/net/imap.rb#1395
  def starttls(*deprecated, **options); end

  # source://net-imap//lib/net/imap.rb#1996
  def status(mailbox, attr); end

  # source://net-imap//lib/net/imap.rb#2745
  def store(set, attr, flags, unchangedsince: T.unsafe(nil)); end

  # source://net-imap//lib/net/imap.rb#1671
  def subscribe(mailbox); end

  # source://net-imap//lib/net/imap.rb#2918
  def thread(algorithm, search_keys, charset); end

  # source://net-imap//lib/net/imap.rb#1130
  def tls_verified?; end

  # source://net-imap//lib/net/imap.rb#2805
  def uid_copy(set, mailbox); end

  # source://net-imap//lib/net/imap.rb#2138
  def uid_expunge(uid_set); end

  # source://net-imap//lib/net/imap.rb#2695
  def uid_fetch(*_arg0, **_arg1, &_arg2); end

  # source://net-imap//lib/net/imap.rb#2852
  def uid_move(set, mailbox); end

  # source://net-imap//lib/net/imap.rb#2579
  def uid_search(*_arg0, **_arg1, &_arg2); end

  # source://net-imap//lib/net/imap.rb#2893
  def uid_sort(sort_keys, search_keys, charset); end

  # source://net-imap//lib/net/imap.rb#2768
  def uid_store(set, attr, flags, unchangedsince: T.unsafe(nil)); end

  # source://net-imap//lib/net/imap.rb#2932
  def uid_thread(algorithm, search_keys, charset); end

  # source://net-imap//lib/net/imap.rb#2077
  def unselect; end

  # source://net-imap//lib/net/imap.rb#1684
  def unsubscribe(mailbox); end

  # source://net-imap//lib/net/imap.rb#1819
  def xlist(refname, mailbox); end

  private

  # source://net-imap//lib/net/imap.rb#3781
  def build_ssl_ctx(ssl); end

  # source://net-imap//lib/net/imap.rb#3514
  def capabilities_from_resp_code(resp); end

  # source://net-imap//lib/net/imap.rb#3763
  def coerce_search_arg_to_seqset?(obj); end

  # source://net-imap//lib/net/imap.rb#3772
  def coerce_search_array_arg_to_seqset?(obj); end

  # source://net-imap//lib/net/imap.rb#3645
  def convert_return_opts(unconverted); end

  # source://net-imap//lib/net/imap.rb#3732
  def copy_internal(cmd, set, mailbox); end

  # source://net-imap//lib/net/imap.rb#3583
  def enforce_logindisabled?; end

  # source://net-imap//lib/net/imap.rb#3591
  def expunge_internal(*_arg0, **_arg1, &_arg2); end

  # source://net-imap//lib/net/imap.rb#3686
  def fetch_internal(cmd, set, attr, mod = T.unsafe(nil), partial: T.unsafe(nil), changedsince: T.unsafe(nil)); end

  # source://net-imap//lib/net/imap.rb#3563
  def generate_tag; end

  # source://net-imap//lib/net/imap.rb#3490
  def get_response; end

  # source://net-imap//lib/net/imap.rb#3360
  def get_server_greeting; end

  # source://net-imap//lib/net/imap.rb#3462
  def get_tagged_response(tag, cmd, timeout = T.unsafe(nil)); end

  # source://net-imap//lib/net/imap.rb#3752
  def normalize_searching_criteria(criteria); end

  # source://net-imap//lib/net/imap.rb#3568
  def put_string(str); end

  # source://net-imap//lib/net/imap.rb#3389
  def receive_responses; end

  # source://net-imap//lib/net/imap.rb#3501
  def record_untagged_response(resp); end

  # source://net-imap//lib/net/imap.rb#3507
  def record_untagged_response_code(resp); end

  # source://net-imap//lib/net/imap.rb#3848
  def sasl_adapter; end

  # source://net-imap//lib/net/imap.rb#3611
  def search_args(keys, charset_arg = T.unsafe(nil), return: T.unsafe(nil), charset: T.unsafe(nil)); end

  # source://net-imap//lib/net/imap.rb#3660
  def search_internal(cmd, *_arg1, **_arg2, &_arg3); end

  # source://net-imap//lib/net/imap.rb#3535
  def send_command(cmd, *args, &block); end

  # source://net-imap//lib/net/imap.rb#3721
  def send_command_returning_fetch_results(*_arg0, **_arg1, &_arg2); end

  # source://net-imap//lib/net/imap.rb#3526
  def send_command_with_continuations(cmd, *args); end

  # source://net-imap//lib/net/imap/command_data.rb#34
  def send_data(data, tag = T.unsafe(nil)); end

  # source://net-imap//lib/net/imap/command_data.rb#116
  def send_date_data(date); end

  # source://net-imap//lib/net/imap/command_data.rb#102
  def send_list_data(list, tag = T.unsafe(nil)); end

  # source://net-imap//lib/net/imap/command_data.rb#81
  def send_literal(str, tag = T.unsafe(nil)); end

  # source://net-imap//lib/net/imap/command_data.rb#98
  def send_number_data(num); end

  # source://net-imap//lib/net/imap/command_data.rb#77
  def send_quoted_string(str); end

  # source://net-imap//lib/net/imap/command_data.rb#55
  def send_string_data(str, tag = T.unsafe(nil)); end

  # source://net-imap//lib/net/imap/command_data.rb#119
  def send_symbol_data(symbol); end

  # source://net-imap//lib/net/imap/command_data.rb#117
  def send_time_data(time); end

  # source://net-imap//lib/net/imap.rb#3736
  def sort_internal(cmd, sort_keys, search_keys, charset); end

  # source://net-imap//lib/net/imap.rb#3349
  def start_imap_connection; end

  # source://net-imap//lib/net/imap.rb#3371
  def start_receiver_thread; end

  # source://net-imap//lib/net/imap.rb#3796
  def start_tls_session; end

  # source://net-imap//lib/net/imap.rb#3811
  def state_authenticated!(resp = T.unsafe(nil)); end

  # source://net-imap//lib/net/imap.rb#3830
  def state_logout!; end

  # source://net-imap//lib/net/imap.rb#3818
  def state_selected!; end

  # source://net-imap//lib/net/imap.rb#3824
  def state_unselected!; end

  # source://net-imap//lib/net/imap.rb#3713
  def store_internal(cmd, set, attr, flags, unchangedsince: T.unsafe(nil)); end

  # source://net-imap//lib/net/imap.rb#3380
  def tcp_socket(host, port); end

  # source://net-imap//lib/net/imap.rb#3744
  def thread_internal(cmd, algorithm, search_keys, charset); end

  # source://net-imap//lib/net/imap.rb#3839
  def try_state_logout?; end

  # source://net-imap//lib/net/imap/command_data.rb#13
  def validate_data(data); end

  class << self
    # source://net-imap//lib/net/imap.rb#825
    def SequenceSet(set = T.unsafe(nil)); end

    # source://net-imap//lib/net/imap.rb#830
    def config; end

    # source://net-imap//lib/net/imap.rb#834
    def debug; end

    # source://net-imap//lib/net/imap.rb#838
    def debug=(val); end

    # :call-seq: decode_date(string) -> Date
    #
    # Decodes +string+ as an IMAP formatted "date".
    #
    # Double quotes are optional.  Day of month may be padded with zero or
    # space.  See STRFDATE.
    #
    # source://net-imap//lib/net/imap/data_encoding.rb#90
    def decode_date(string); end

    # :call-seq: decode_datetime(string) -> DateTime
    #
    # Decodes +string+ as an IMAP4 formatted "date-time".
    #
    # NOTE: Although double-quotes are not optional in the IMAP grammar,
    # Net::IMAP currently parses "date-time" values as "quoted" strings and this
    # removes the quotation marks.  To be useful for strings which have already
    # been parsed as a quoted string, this method makes double-quotes optional.
    #
    # See STRFTIME.
    #
    # source://net-imap//lib/net/imap/data_encoding.rb#112
    def decode_datetime(string); end

    # :call-seq: decode_time(string) -> Time
    #
    # Decodes +string+ as an IMAP4 formatted "date-time".
    #
    # Same as +decode_datetime+, but returning a Time instead.
    #
    # source://net-imap//lib/net/imap/data_encoding.rb#124
    def decode_time(string); end

    # Decode a string from modified UTF-7 format to UTF-8.
    #
    # UTF-7 is a 7-bit encoding of Unicode [UTF7].  IMAP uses a
    # slightly modified version of this to encode mailbox names
    # containing non-ASCII characters; see [IMAP] section 5.1.3.
    #
    # Net::IMAP does _not_ automatically encode and decode
    # mailbox names to and from UTF-7.
    #
    # source://net-imap//lib/net/imap/data_encoding.rb#57
    def decode_utf7(s); end

    # source://net-imap//lib/net/imap.rb#853
    def default_imap_port; end

    # source://net-imap//lib/net/imap.rb#854
    def default_imaps_port; end

    # source://net-imap//lib/net/imap.rb#843
    def default_port; end

    # source://net-imap//lib/net/imap.rb#855
    def default_ssl_port; end

    # source://net-imap//lib/net/imap.rb#848
    def default_tls_port; end

    # Formats +time+ as an IMAP4 date.
    #
    # source://net-imap//lib/net/imap/data_encoding.rb#80
    def encode_date(date); end

    # :call-seq: encode_datetime(time) -> string
    #
    # Formats +time+ as an IMAP4 date-time.
    #
    # source://net-imap//lib/net/imap/data_encoding.rb#98
    def encode_datetime(time); end

    # :call-seq: encode_datetime(time) -> string
    #
    # Formats +time+ as an IMAP4 date-time.
    #
    # source://net-imap//lib/net/imap/data_encoding.rb#132
    def encode_time(time); end

    # Encode a string from UTF-8 format to modified UTF-7.
    #
    # source://net-imap//lib/net/imap/data_encoding.rb#68
    def encode_utf7(s); end

    # Formats +time+ as an IMAP4 date.
    #
    # source://net-imap//lib/net/imap/data_encoding.rb#133
    def format_date(date); end

    # DEPRECATED:: The original version returned incorrectly formatted strings.
    #              Strings returned by encode_datetime or format_time use the
    #              correct IMAP4rev1 syntax for "date-time".
    #
    # This invalid format has been temporarily retained for backward
    # compatibility.  A future release will change this method to return the
    # correct format.
    #
    # source://net-imap//lib/net/imap/data_encoding.rb#149
    def format_datetime(time); end

    # :call-seq: encode_datetime(time) -> string
    #
    # Formats +time+ as an IMAP4 date-time.
    #
    # source://net-imap//lib/net/imap/data_encoding.rb#134
    def format_time(time); end

    # :call-seq: decode_date(string) -> Date
    #
    # Decodes +string+ as an IMAP formatted "date".
    #
    # Double quotes are optional.  Day of month may be padded with zero or
    # space.  See STRFDATE.
    #
    # source://net-imap//lib/net/imap/data_encoding.rb#135
    def parse_date(string); end

    # :call-seq: decode_datetime(string) -> DateTime
    #
    # Decodes +string+ as an IMAP4 formatted "date-time".
    #
    # NOTE: Although double-quotes are not optional in the IMAP grammar,
    # Net::IMAP currently parses "date-time" values as "quoted" strings and this
    # removes the quotation marks.  To be useful for strings which have already
    # been parsed as a quoted string, this method makes double-quotes optional.
    #
    # See STRFTIME.
    #
    # source://net-imap//lib/net/imap/data_encoding.rb#136
    def parse_datetime(string); end

    # :call-seq: decode_time(string) -> Time
    #
    # Decodes +string+ as an IMAP4 formatted "date-time".
    #
    # Same as +decode_datetime+, but returning a Time instead.
    #
    # source://net-imap//lib/net/imap/data_encoding.rb#137
    def parse_time(string); end

    # source://net-imap//lib/net/imap.rb#3858
    def saslprep(string, **opts); end
  end
end

# Mailbox attribute indicating that this mailbox presents all messages in
# the user's message store. Implementations MAY omit some messages, such as,
# perhaps, those in \Trash and \Junk. When this special use is supported, it
# is almost certain to represent a virtual mailbox
#
# source://net-imap//lib/net/imap/flags.rb#218
Net::IMAP::ALL = T.let(T.unsafe(nil), Symbol)

# Mailbox attribute indicating that this mailbox is used to archive
# messages. The meaning of an "archival" mailbox is server dependent;
# typically, it will be used to get messages out of the inbox, or otherwise
# keep them out of the user's way, while still making them accessible
#
# source://net-imap//lib/net/imap/flags.rb#224
Net::IMAP::ARCHIVE = T.let(T.unsafe(nil), Symbol)

# >>>
#   *NOTE:* <em>AppendUIDData will replace UIDPlusData for +APPENDUID+ in the
#   +0.6.0+ release.</em>  To use AppendUIDData before +0.6.0+, set
#   Config#parser_use_deprecated_uidplus_data to +false+.
#
# AppendUIDData represents the ResponseCode#data that accompanies the
# +APPENDUID+ {response code}[rdoc-ref:ResponseCode].
#
# A server that supports +UIDPLUS+ (or +IMAP4rev2+) should send
# AppendUIDData inside every TaggedResponse returned by the
# append[rdoc-ref:Net::IMAP#append] command---unless the target mailbox
# reports +UIDNOTSTICKY+.
#
# == Required capability
# Requires either +UIDPLUS+ [RFC4315[https://www.rfc-editor.org/rfc/rfc4315]]
# or +IMAP4rev2+ capability.
#
# source://net-imap//lib/net/imap/uidplus_data.rb#83
class Net::IMAP::AppendUIDData < ::Net::IMAP::DataLite
  # @return [AppendUIDData] a new instance of AppendUIDData
  #
  # source://net-imap//lib/net/imap/uidplus_data.rb#84
  def initialize(uidvalidity:, assigned_uids:); end

  # Returns the number of messages that have been appended.
  #
  # source://net-imap//lib/net/imap/uidplus_data.rb#106
  def size; end
end

# source://net-imap//lib/net/imap/command_data.rb#138
class Net::IMAP::Atom < ::Net::IMAP::CommandData
  # source://net-imap//lib/net/imap/command_data.rb#139
  def send_data(imap, tag); end
end

# Backward compatible delegators from Net::IMAP to Net::IMAP::SASL.
#
# source://net-imap//lib/net/imap/authenticators.rb#4
module Net::IMAP::Authenticators
  # Deprecated.  Use Net::IMAP::SASL.add_authenticator instead.
  #
  # source://net-imap//lib/net/imap/authenticators.rb#7
  def add_authenticator(*_arg0, **_arg1, &_arg2); end

  # Deprecated.  Use Net::IMAP::SASL.authenticator instead.
  #
  # source://net-imap//lib/net/imap/authenticators.rb#18
  def authenticator(*_arg0, **_arg1, &_arg2); end
end

# Net::IMAP::BodyStructure is included by all of the structs that can be
# returned from a <tt>"BODYSTRUCTURE"</tt> or <tt>"BODY"</tt>
# FetchData#attr value.  Although these classes don't share a base class,
# this module can be used to pattern match all of them.
#
# See {[IMAP4rev1] §7.4.2}[https://www.rfc-editor.org/rfc/rfc3501#section-7.4.2]
# and {[IMAP4rev2] §7.5.2}[https://www.rfc-editor.org/rfc/rfc9051#section-7.5.2-4.9]
# for full description of all +BODYSTRUCTURE+ fields, and also
# Net::IMAP@Message+envelope+and+body+structure for other relevant RFCs.
#
# == Classes that include BodyStructure
# BodyTypeBasic:: Represents any message parts that are not handled by
#                 BodyTypeText, BodyTypeMessage, or BodyTypeMultipart.
# BodyTypeText:: Used by <tt>text/*</tt> parts.  Contains all of the
#                BodyTypeBasic fields.
# BodyTypeMessage:: Used by <tt>message/rfc822</tt> and
#                   <tt>message/global</tt> parts.  Contains all of the
#                   BodyTypeBasic fields.  Other <tt>message/*</tt> types
#                   should use BodyTypeBasic.
# BodyTypeMultipart:: for <tt>multipart/*</tt> parts
#
# source://net-imap//lib/net/imap/response_data.rb#786
module Net::IMAP::BodyStructure; end

# Net::IMAP::BodyTypeBasic represents basic body structures of messages and
# message parts, unless they have a <tt>Content-Type</tt> that is handled by
# BodyTypeText, BodyTypeMessage, or BodyTypeMultipart.
#
# See {[IMAP4rev1] §7.4.2}[https://www.rfc-editor.org/rfc/rfc3501#section-7.4.2]
# and {[IMAP4rev2] §7.5.2}[https://www.rfc-editor.org/rfc/rfc9051#section-7.5.2-4.9]
# for full description of all +BODYSTRUCTURE+ fields, and also
# Net::IMAP@Message+envelope+and+body+structure for other relevant RFCs.
#
# source://net-imap//lib/net/imap/response_data.rb#803
class Net::IMAP::BodyTypeBasic < ::Struct
  include ::Net::IMAP::BodyStructure

  # :call-seq: media_subtype -> subtype
  #
  # >>>
  #   [Obsolete]
  #     Use +subtype+ instead.  Calling this will generate a warning message
  #     to +stderr+, then return the value of +subtype+.
  # --
  # TODO: why not just keep this as an alias?  Would "media_subtype" be used
  # for something else?
  # ++
  #
  # source://net-imap//lib/net/imap/response_data.rb#914
  def media_subtype; end

  # :call-seq: multipart? -> false
  #
  # BodyTypeBasic is not used for multipart MIME parts.
  #
  # @return [Boolean]
  #
  # source://net-imap//lib/net/imap/response_data.rb#900
  def multipart?; end
end

# Net::IMAP::BodyTypeMessage represents the body structures of messages and
# message parts, when <tt>Content-Type</tt> is <tt>message/rfc822</tt> or
# <tt>message/global</tt>.
#
# BodyTypeMessage contains all of the fields of BodyTypeBasic.  See
# BodyTypeBasic for documentation of the following fields:
# * {media_type}[rdoc-ref:BodyTypeBasic#media_type]
# * subtype[rdoc-ref:BodyTypeBasic#subtype]
# * param[rdoc-ref:BodyTypeBasic#param]
# * {content_id}[rdoc-ref:BodyTypeBasic#content_id]
# * description[rdoc-ref:BodyTypeBasic#description]
# * encoding[rdoc-ref:BodyTypeBasic#encoding]
# * size[rdoc-ref:BodyTypeBasic#size]
#
# source://net-imap//lib/net/imap/response_data.rb#986
class Net::IMAP::BodyTypeMessage < ::Struct
  include ::Net::IMAP::BodyStructure

  # Obsolete: use +subtype+ instead.  Calling this will
  # generate a warning message to +stderr+, then return
  # the value of +subtype+.
  #
  # source://net-imap//lib/net/imap/response_data.rb#1012
  def media_subtype; end

  # :call-seq: multipart? -> false
  #
  # BodyTypeMessage is not used for multipart MIME parts.
  #
  # @return [Boolean]
  #
  # source://net-imap//lib/net/imap/response_data.rb#1005
  def multipart?; end
end

# Net::IMAP::BodyTypeMultipart represents body structures of messages and
# message parts, when <tt>Content-Type</tt> is <tt>multipart/*</tt>.
#
# source://net-imap//lib/net/imap/response_data.rb#1024
class Net::IMAP::BodyTypeMultipart < ::Struct
  include ::Net::IMAP::BodyStructure

  # Obsolete: use +subtype+ instead.  Calling this will
  # generate a warning message to +stderr+, then return
  # the value of +subtype+.
  #
  # source://net-imap//lib/net/imap/response_data.rb#1088
  def media_subtype; end

  # :call-seq: multipart? -> true
  #
  # BodyTypeMultipart is used for multipart MIME parts.
  #
  # @return [Boolean]
  #
  # source://net-imap//lib/net/imap/response_data.rb#1080
  def multipart?; end
end

# Net::IMAP::BodyTypeText represents the body structures of messages and
# message parts, when <tt>Content-Type</tt> is <tt>text/*</tt>.
#
# BodyTypeText contains all of the fields of BodyTypeBasic.  See
# BodyTypeBasic for documentation of the following:
# * {media_type}[rdoc-ref:BodyTypeBasic#media_type]
# * subtype[rdoc-ref:BodyTypeBasic#subtype]
# * param[rdoc-ref:BodyTypeBasic#param]
# * {content_id}[rdoc-ref:BodyTypeBasic#content_id]
# * description[rdoc-ref:BodyTypeBasic#description]
# * encoding[rdoc-ref:BodyTypeBasic#encoding]
# * size[rdoc-ref:BodyTypeBasic#size]
#
# source://net-imap//lib/net/imap/response_data.rb#940
class Net::IMAP::BodyTypeText < ::Struct
  include ::Net::IMAP::BodyStructure

  # Obsolete: use +subtype+ instead.  Calling this will
  # generate a warning message to +stderr+, then return
  # the value of +subtype+.
  #
  # source://net-imap//lib/net/imap/response_data.rb#960
  def media_subtype; end

  # :call-seq: multipart? -> false
  #
  # BodyTypeText is not used for multipart MIME parts.
  #
  # @return [Boolean]
  #
  # source://net-imap//lib/net/imap/response_data.rb#953
  def multipart?; end
end

# source://net-imap//lib/net/imap/command_data.rb#255
class Net::IMAP::ClientID < ::Net::IMAP::CommandData
  # source://net-imap//lib/net/imap/command_data.rb#257
  def send_data(imap, tag); end

  # source://net-imap//lib/net/imap/command_data.rb#261
  def validate; end

  private

  # source://net-imap//lib/net/imap/command_data.rb#277
  def format_internal(client_id); end

  # source://net-imap//lib/net/imap/command_data.rb#267
  def validate_internal(client_id); end
end

class Net::IMAP::CommandData < ::Net::IMAP::DataLite
  # source://net-imap//lib/net/imap/command_data.rb#123
  def data; end

  # source://net-imap//lib/net/imap/command_data.rb#124
  def send_data(imap, tag); end

  # source://net-imap//lib/net/imap/command_data.rb#128
  def validate; end

  class << self
    # source://net-imap//lib/net/imap/command_data.rb#123
    def [](*_arg0); end

    # source://net-imap//lib/net/imap/command_data.rb#123
    def inspect; end

    # source://net-imap//lib/net/imap/command_data.rb#123
    def members; end

    # source://net-imap//lib/net/imap/command_data.rb#123
    def new(*_arg0); end
  end
end

# Net::IMAP::Config <em>(available since +v0.4.13+)</em> stores
# configuration options for Net::IMAP clients.  The global configuration can
# be seen at either Net::IMAP.config or Net::IMAP::Config.global, and the
# client-specific configuration can be seen at Net::IMAP#config.
#
# When creating a new client, all unhandled keyword arguments to
# Net::IMAP.new are delegated to Config.new.  Every client has its own
# config.
#
#   debug_client = Net::IMAP.new(hostname, debug: true)
#   quiet_client = Net::IMAP.new(hostname, debug: false)
#   debug_client.config.debug?  # => true
#   quiet_client.config.debug?  # => false
#
# == Inheritance
#
# Configs have a parent[rdoc-ref:Config::AttrInheritance#parent] config, and
# any attributes which have not been set locally will inherit the parent's
# value.  Every client creates its own specific config.  By default, client
# configs inherit from Config.global.
#
#   plain_client = Net::IMAP.new(hostname)
#   debug_client = Net::IMAP.new(hostname, debug: true)
#   quiet_client = Net::IMAP.new(hostname, debug: false)
#
#   plain_client.config.inherited?(:debug)  # => true
#   debug_client.config.inherited?(:debug)  # => false
#   quiet_client.config.inherited?(:debug)  # => false
#
#   plain_client.config.debug?  # => false
#   debug_client.config.debug?  # => true
#   quiet_client.config.debug?  # => false
#
#   # Net::IMAP.debug is delegated to Net::IMAP::Config.global.debug
#   Net::IMAP.debug = true
#   plain_client.config.debug?  # => true
#   debug_client.config.debug?  # => true
#   quiet_client.config.debug?  # => false
#
#   Net::IMAP.debug = false
#   plain_client.config.debug = true
#   plain_client.config.inherited?(:debug)  # => false
#   plain_client.config.debug?  # => true
#   plain_client.config.reset(:debug)
#   plain_client.config.inherited?(:debug)  # => true
#   plain_client.config.debug?  # => false
#
# == Versioned defaults
#
# The effective default configuration for a specific +x.y+ version of
# +net-imap+ can be loaded with the +config+ keyword argument to
# Net::IMAP.new.  Requesting default configurations for previous versions
# enables extra backward compatibility with those versions:
#
#   client = Net::IMAP.new(hostname, config: 0.3)
#   client.config.sasl_ir                  # => false
#   client.config.responses_without_block  # => :silence_deprecation_warning
#
#   client = Net::IMAP.new(hostname, config: 0.4)
#   client.config.sasl_ir                  # => true
#   client.config.responses_without_block  # => :silence_deprecation_warning
#
#   client = Net::IMAP.new(hostname, config: 0.5)
#   client.config.sasl_ir                  # => true
#   client.config.responses_without_block  # => :warn
#
#   client = Net::IMAP.new(hostname, config: :future)
#   client.config.sasl_ir                  # => true
#   client.config.responses_without_block  # => :frozen_dup
#
# The versioned default configs inherit certain specific config options from
# Config.global, for example #debug:
#
#   client = Net::IMAP.new(hostname, config: 0.4)
#   Net::IMAP.debug = false
#   client.config.debug?  # => false
#
#   Net::IMAP.debug = true
#   client.config.debug?  # => true
#
# Use #load_defaults to globally behave like a specific version:
#   client = Net::IMAP.new(hostname)
#   client.config.sasl_ir              # => true
#   Net::IMAP.config.load_defaults 0.3
#   client.config.sasl_ir              # => false
#
# === Named defaults
# In addition to +x.y+ version numbers, the following aliases are supported:
#
# [+:default+]
#   An alias for +:current+.
#
#   >>>
#   *NOTE*: This is _not_ the same as Config.default.  It inherits some
#   attributes from Config.global, for example: #debug.
# [+:current+]
#   An alias for the current +x.y+ version's defaults.
# [+:next+]
#   The _planned_ config for the next +x.y+ version.
# [+:future+]
#   The _planned_ eventual config for some future +x.y+ version.
#
# For example, to disable all currently deprecated behavior:
#   client = Net::IMAP.new(hostname, config: :future)
#   client.config.response_without_args     # => :frozen_dup
#   client.responses.frozen?                # => true
#   client.responses.values.all?(&:frozen?) # => true
#
# == Thread Safety
#
# *NOTE:* Updates to config objects are not synchronized for thread-safety.
#
# source://net-imap//lib/net/imap/config/attr_accessors.rb#7
class Net::IMAP::Config
  include ::Net::IMAP::Config::AttrAccessors
  include ::Net::IMAP::Config::AttrInheritance
  include ::Net::IMAP::Config::AttrTypeCoercion
  extend ::Net::IMAP::Config::AttrAccessors::Macros
  extend ::Net::IMAP::Config::AttrInheritance::Macros
  extend ::Net::IMAP::Config::AttrTypeCoercion::Macros

  # Creates a new config object and initialize its attribute with +attrs+.
  #
  # If +parent+ is not given, the global config is used by default.
  #
  # If a block is given, the new config object is yielded to it.
  #
  # @return [Config] a new instance of Config
  # @yield [_self]
  # @yieldparam _self [Net::IMAP::Config] the object that the method was called on
  #
  # source://net-imap//lib/net/imap/config.rb#409
  def initialize(parent = T.unsafe(nil), **attrs); end

  # :call-seq: load_defaults(version) -> self
  #
  # Resets the current config to behave like the versioned default
  # configuration for +version+.  #parent will not be changed.
  #
  # Some config attributes default to inheriting from their #parent (which
  # is usually Config.global) and are left unchanged, for example: #debug.
  #
  # See Config@Versioned+defaults and Config@Named+defaults.
  #
  # source://net-imap//lib/net/imap/config.rb#460
  def load_defaults(version); end

  # source://net-imap//lib/net/imap/config.rb#335
  def responses_without_args; end

  # source://net-imap//lib/net/imap/config.rb#336
  def responses_without_args=(val); end

  # :call-seq: to_h -> hash
  #
  # Returns all config attributes in a hash.
  #
  # source://net-imap//lib/net/imap/config.rb#469
  def to_h; end

  # :call-seq: update(**attrs) -> self
  #
  # Assigns all of the provided +attrs+ to this config, and returns +self+.
  #
  # An ArgumentError is raised unless every key in +attrs+ matches an
  # assignment method on Config.
  #
  # >>>
  #   *NOTE:*  #update is not atomic.  If an exception is raised due to an
  #   invalid attribute value, +attrs+ may be partially applied.
  #
  # source://net-imap//lib/net/imap/config.rb#425
  def update(**attrs); end

  # :call-seq:
  #   with(**attrs) -> config
  #   with(**attrs) {|config| } -> result
  #
  # Without a block, returns a new config which inherits from self.  With a
  # block, yields the new config and returns the block's result.
  #
  # If no keyword arguments are given, an ArgumentError will be raised.
  #
  # If +self+ is frozen, the copy will also be frozen.
  #
  # source://net-imap//lib/net/imap/config.rb#443
  def with(**attrs); end

  protected

  # source://net-imap//lib/net/imap/config.rb#473
  def defaults_hash; end

  class << self
    # :call-seq:
    #  Net::IMAP::Config[number] -> versioned config
    #  Net::IMAP::Config[symbol] -> named config
    #  Net::IMAP::Config[hash]   -> new frozen config
    #  Net::IMAP::Config[config] -> same config
    #
    # Given a version number, returns the default configuration for the target
    # version.  See Config@Versioned+defaults.
    #
    # Given a version name, returns the default configuration for the target
    # version.  See Config@Named+defaults.
    #
    # Given a Hash, creates a new _frozen_ config which inherits from
    # Config.global.  Use Config.new for an unfrozen config.
    #
    # Given a config, returns that same config.
    #
    # source://net-imap//lib/net/imap/config.rb#170
    def [](config); end

    # The default config, which is hardcoded and frozen.
    #
    # source://net-imap//lib/net/imap/config.rb#128
    def default; end

    # The global config object.  Also available from Net::IMAP.config.
    #
    # source://net-imap//lib/net/imap/config.rb#131
    def global; end

    # A hash of hard-coded configurations, indexed by version number or name.
    # Values can be accessed with any object that responds to +to_sym+ or
    # +to_r+/+to_f+ with a non-zero number.
    #
    # Config::[] gets named or numbered versions from this hash.
    #
    # For example:
    #     Net::IMAP::Config.version_defaults[0.5] == Net::IMAP::Config[0.5]
    #     Net::IMAP::Config[0.5]       == Net::IMAP::Config[0.5r]     # => true
    #     Net::IMAP::Config["current"] == Net::IMAP::Config[:current] # => true
    #     Net::IMAP::Config["0.5.6"]   == Net::IMAP::Config[0.5r]     # => true
    #
    # source://net-imap//lib/net/imap/config.rb#144
    def version_defaults; end
  end
end

# >>>
#   *NOTE:* This module is an internal implementation detail, with no
#   guarantee of backward compatibility.
#
# +attr_accessor+ values are stored in a struct rather than ivars, making
# it simpler to ensure that all config objects share a single object
# shape.  This also simplifies iteration over all defined attributes.
#
# source://net-imap//lib/net/imap/config/attr_accessors.rb#15
module Net::IMAP::Config::AttrAccessors
  extend ::Forwardable

  mixes_in_class_methods ::Net::IMAP::Config::AttrAccessors::Macros

  # :notnew:
  #
  # source://net-imap//lib/net/imap/config/attr_accessors.rb#45
  def initialize; end

  # source://net-imap//lib/net/imap/config.rb#203
  def debug(*args, **_arg1, &block); end

  # source://net-imap//lib/net/imap/config.rb#203
  def debug=(*args, **_arg1, &block); end

  # source://net-imap//lib/net/imap/config.rb#267
  def enforce_logindisabled(*args, **_arg1, &block); end

  # source://net-imap//lib/net/imap/config.rb#267
  def enforce_logindisabled=(*args, **_arg1, &block); end

  # Freezes the internal attributes struct, in addition to +self+.
  #
  # source://net-imap//lib/net/imap/config/attr_accessors.rb#51
  def freeze; end

  # source://net-imap//lib/net/imap/config.rb#229
  def idle_response_timeout(*args, **_arg1, &block); end

  # source://net-imap//lib/net/imap/config.rb#229
  def idle_response_timeout=(*args, **_arg1, &block); end

  # source://net-imap//lib/net/imap/config.rb#303
  def max_response_size(*args, **_arg1, &block); end

  # source://net-imap//lib/net/imap/config.rb#303
  def max_response_size=(*args, **_arg1, &block); end

  # source://net-imap//lib/net/imap/config.rb#221
  def open_timeout(*args, **_arg1, &block); end

  # source://net-imap//lib/net/imap/config.rb#221
  def open_timeout=(*args, **_arg1, &block); end

  # source://net-imap//lib/net/imap/config.rb#402
  def parser_max_deprecated_uidplus_data_size(*args, **_arg1, &block); end

  # source://net-imap//lib/net/imap/config.rb#402
  def parser_max_deprecated_uidplus_data_size=(*args, **_arg1, &block); end

  # source://net-imap//lib/net/imap/config.rb#376
  def parser_use_deprecated_uidplus_data(*args, **_arg1, &block); end

  # source://net-imap//lib/net/imap/config.rb#376
  def parser_use_deprecated_uidplus_data=(*args, **_arg1, &block); end

  # source://net-imap//lib/net/imap/config.rb#331
  def responses_without_block(*args, **_arg1, &block); end

  # source://net-imap//lib/net/imap/config.rb#331
  def responses_without_block=(*args, **_arg1, &block); end

  # source://net-imap//lib/net/imap/config.rb#245
  def sasl_ir(*args, **_arg1, &block); end

  # source://net-imap//lib/net/imap/config.rb#245
  def sasl_ir=(*args, **_arg1, &block); end

  protected

  # source://net-imap//lib/net/imap/config/attr_accessors.rb#58
  def data; end

  private

  # source://net-imap//lib/net/imap/config/attr_accessors.rb#62
  def initialize_clone(other); end

  # source://net-imap//lib/net/imap/config/attr_accessors.rb#67
  def initialize_dup(other); end

  class << self
    # source://net-imap//lib/net/imap/config/attr_accessors.rb#28
    def attr_accessor(name); end

    # source://net-imap//lib/net/imap/config/attr_accessors.rb#38
    def struct; end

    private

    # source://net-imap//lib/net/imap/config/attr_accessors.rb#33
    def attributes; end

    # @private
    #
    # source://net-imap//lib/net/imap/config/attr_accessors.rb#21
    def included(mod); end
  end
end

# source://net-imap//lib/net/imap/config/attr_accessors.rb#16
module Net::IMAP::Config::AttrAccessors::Macros
  # source://net-imap//lib/net/imap/config/attr_accessors.rb#17
  def attr_accessor(name); end
end

# source://net-imap//lib/net/imap/config.rb#410
class Net::IMAP::Config::AttrAccessors::Struct < ::Struct
  # source://net-imap//lib/net/imap/config.rb#410
  def debug; end

  # source://net-imap//lib/net/imap/config.rb#410
  def debug=(_); end

  # source://net-imap//lib/net/imap/config.rb#410
  def enforce_logindisabled; end

  # source://net-imap//lib/net/imap/config.rb#410
  def enforce_logindisabled=(_); end

  # source://net-imap//lib/net/imap/config.rb#410
  def idle_response_timeout; end

  # source://net-imap//lib/net/imap/config.rb#410
  def idle_response_timeout=(_); end

  # source://net-imap//lib/net/imap/config.rb#410
  def max_response_size; end

  # source://net-imap//lib/net/imap/config.rb#410
  def max_response_size=(_); end

  # source://net-imap//lib/net/imap/config.rb#410
  def open_timeout; end

  # source://net-imap//lib/net/imap/config.rb#410
  def open_timeout=(_); end

  # source://net-imap//lib/net/imap/config.rb#410
  def parser_max_deprecated_uidplus_data_size; end

  # source://net-imap//lib/net/imap/config.rb#410
  def parser_max_deprecated_uidplus_data_size=(_); end

  # source://net-imap//lib/net/imap/config.rb#410
  def parser_use_deprecated_uidplus_data; end

  # source://net-imap//lib/net/imap/config.rb#410
  def parser_use_deprecated_uidplus_data=(_); end

  # source://net-imap//lib/net/imap/config.rb#410
  def responses_without_block; end

  # source://net-imap//lib/net/imap/config.rb#410
  def responses_without_block=(_); end

  # source://net-imap//lib/net/imap/config.rb#410
  def sasl_ir; end

  # source://net-imap//lib/net/imap/config.rb#410
  def sasl_ir=(_); end

  class << self
    # source://net-imap//lib/net/imap/config.rb#410
    def [](*_arg0); end

    # source://net-imap//lib/net/imap/config.rb#410
    def inspect; end

    # source://net-imap//lib/net/imap/config.rb#410
    def keyword_init?; end

    # source://net-imap//lib/net/imap/config.rb#410
    def members; end

    # source://net-imap//lib/net/imap/config.rb#410
    def new(*_arg0); end
  end
end

# >>>
#   *NOTE:* The public methods on this module are part of the stable
#   public API of Net::IMAP::Config.  But the module itself is an internal
#   implementation detail, with no guarantee of backward compatibility.
#
# +attr_accessor+ methods will delegate to their #parent when the local
# value does not contain an override.  Inheritance forms a singly linked
# list, so lookup will be <tt>O(n)</tt> on the number of ancestors.  In
# practice, the ancestor chain is not expected to be long.  Without
# customization, it is only three deep:
# >>>
#     IMAP#config → Config.global → Config.default
#
# When creating a client with the +config+ keyword, for example to use
# the appropriate defaults for an application or a library while still
# relying on global for configuration of +debug+ or +logger+, most likely
# the ancestor chain is still only four deep:
# >>>
#     IMAP#config → alternate defaults → Config.global → Config.default
#
# source://net-imap//lib/net/imap/config/attr_inheritance.rb#25
module Net::IMAP::Config::AttrInheritance
  mixes_in_class_methods ::Net::IMAP::Config::AttrInheritance::Macros

  # :notnew:
  #
  # source://net-imap//lib/net/imap/config/attr_inheritance.rb#48
  def initialize(parent = T.unsafe(nil)); end

  # source://net-imap//lib/net/imap/config.rb#203
  def debug; end

  # source://net-imap//lib/net/imap/config.rb#267
  def enforce_logindisabled; end

  # source://net-imap//lib/net/imap/config.rb#229
  def idle_response_timeout; end

  # Returns +true+ if +attr+ is inherited from #parent and not overridden
  # by this config.
  #
  # @return [Boolean]
  #
  # source://net-imap//lib/net/imap/config/attr_inheritance.rb#59
  def inherited?(attr); end

  # source://net-imap//lib/net/imap/config.rb#303
  def max_response_size; end

  # Creates a new config, which inherits from +self+.
  #
  # source://net-imap//lib/net/imap/config/attr_inheritance.rb#55
  def new(**attrs); end

  # source://net-imap//lib/net/imap/config.rb#221
  def open_timeout; end

  # The parent Config object
  #
  # source://net-imap//lib/net/imap/config/attr_inheritance.rb#46
  def parent; end

  # source://net-imap//lib/net/imap/config.rb#402
  def parser_max_deprecated_uidplus_data_size; end

  # source://net-imap//lib/net/imap/config.rb#376
  def parser_use_deprecated_uidplus_data; end

  # :call-seq:
  #   reset -> self
  #   reset(attr) -> attribute value
  #
  # Resets an +attr+ to inherit from the #parent config.
  #
  # When +attr+ is nil or not given, all attributes are reset.
  #
  # source://net-imap//lib/net/imap/config/attr_inheritance.rb#68
  def reset(attr = T.unsafe(nil)); end

  # source://net-imap//lib/net/imap/config.rb#331
  def responses_without_block; end

  # source://net-imap//lib/net/imap/config.rb#245
  def sasl_ir; end

  private

  # source://net-imap//lib/net/imap/config/attr_inheritance.rb#82
  def initialize_copy(other); end

  class << self
    # source://net-imap//lib/net/imap/config/attr_inheritance.rb#39
    def attr_accessor(name); end

    private

    # @private
    #
    # source://net-imap//lib/net/imap/config/attr_inheritance.rb#34
    def included(mod); end
  end
end

# source://net-imap//lib/net/imap/config/attr_inheritance.rb#26
module Net::IMAP::Config::AttrInheritance::INHERITED; end

# source://net-imap//lib/net/imap/config/attr_inheritance.rb#29
module Net::IMAP::Config::AttrInheritance::Macros
  # source://net-imap//lib/net/imap/config/attr_inheritance.rb#30
  def attr_accessor(name); end
end

# source://net-imap//lib/net/imap/config/attr_type_coercion.rb#13
module Net::IMAP::Config::AttrTypeCoercion
  mixes_in_class_methods ::Net::IMAP::Config::AttrTypeCoercion::Macros

  # source://net-imap//lib/net/imap/config.rb#203
  def debug=(val); end

  # source://net-imap//lib/net/imap/config.rb#203
  def debug?; end

  # source://net-imap//lib/net/imap/config.rb#267
  def enforce_logindisabled=(val); end

  # source://net-imap//lib/net/imap/config.rb#229
  def idle_response_timeout=(val); end

  # source://net-imap//lib/net/imap/config.rb#303
  def max_response_size=(val); end

  # source://net-imap//lib/net/imap/config.rb#221
  def open_timeout=(val); end

  # source://net-imap//lib/net/imap/config.rb#402
  def parser_max_deprecated_uidplus_data_size=(val); end

  # source://net-imap//lib/net/imap/config.rb#376
  def parser_use_deprecated_uidplus_data=(val); end

  # source://net-imap//lib/net/imap/config.rb#331
  def responses_without_block=(val); end

  # source://net-imap//lib/net/imap/config.rb#245
  def sasl_ir=(val); end

  # source://net-imap//lib/net/imap/config.rb#245
  def sasl_ir?; end

  class << self
    # source://net-imap//lib/net/imap/config/attr_type_coercion.rb#54
    def attr_accessor(attr, type: T.unsafe(nil)); end

    private

    # source://net-imap//lib/net/imap/config/attr_type_coercion.rb#26
    def included(mod); end

    # source://net-imap//lib/net/imap/config/attr_type_coercion.rb#41
    def safe(&b); end
  end
end

# source://net-imap//lib/net/imap/config/attr_type_coercion.rb#51
Net::IMAP::Config::AttrTypeCoercion::Boolean = T.let(T.unsafe(nil), Proc)

# source://net-imap//lib/net/imap/config/attr_type_coercion.rb#62
Net::IMAP::Config::AttrTypeCoercion::Enum = T.let(T.unsafe(nil), Proc)

# source://net-imap//lib/net/imap/config/attr_type_coercion.rb#16
module Net::IMAP::Config::AttrTypeCoercion::Macros
  # source://net-imap//lib/net/imap/config/attr_type_coercion.rb#17
  def attr_accessor(attr, type: T.unsafe(nil)); end

  private

  # source://net-imap//lib/net/imap/config/attr_type_coercion.rb#22
  def Integer?; end

  class << self
    # source://net-imap//lib/net/imap/config/attr_type_coercion.rb#22
    def Integer?; end
  end
end

# source://net-imap//lib/net/imap/config/attr_type_coercion.rb#60
Net::IMAP::Config::AttrTypeCoercion::NilOrInteger = T.let(T.unsafe(nil), Proc)

# source://net-imap//lib/net/imap/config/attr_type_coercion.rb#50
Net::IMAP::Config::AttrTypeCoercion::Types = T.let(T.unsafe(nil), Hash)

# Array of attribute names that are _not_ loaded by #load_defaults.
#
# source://net-imap//lib/net/imap/config.rb#124
Net::IMAP::Config::DEFAULT_TO_INHERIT = T.let(T.unsafe(nil), Array)

# source://net-imap//lib/net/imap/connection_state.rb#5
class Net::IMAP::ConnectionState < ::Net::IMAP::DataLite
  # @return [Boolean]
  #
  # source://net-imap//lib/net/imap/connection_state.rb#32
  def authenticated?; end

  # source://net-imap//lib/net/imap/connection_state.rb#17
  def deconstruct; end

  # source://net-imap//lib/net/imap/connection_state.rb#19
  def deconstruct_keys(names); end

  # @return [Boolean]
  #
  # source://net-imap//lib/net/imap/connection_state.rb#34
  def logout?; end

  # source://net-imap//lib/net/imap/connection_state.rb#14
  def name; end

  # @return [Boolean]
  #
  # source://net-imap//lib/net/imap/connection_state.rb#31
  def not_authenticated?; end

  # @return [Boolean]
  #
  # source://net-imap//lib/net/imap/connection_state.rb#33
  def selected?; end

  # source://net-imap//lib/net/imap/connection_state.rb#13
  def symbol; end

  # source://net-imap//lib/net/imap/connection_state.rb#26
  def to_h(&block); end

  # source://net-imap//lib/net/imap/connection_state.rb#15
  def to_sym; end
end

class Net::IMAP::ConnectionState::Authenticated < ::Net::IMAP::ConnectionState
  class << self
    # source://net-imap//lib/net/imap/connection_state.rb#8
    def [](*_arg0); end

    # source://net-imap//lib/net/imap/connection_state.rb#8
    def inspect; end

    # source://net-imap//lib/net/imap/connection_state.rb#8
    def members; end

    # source://net-imap//lib/net/imap/connection_state.rb#8
    def new(*_arg0); end
  end
end

# source://net-imap//lib/net/imap/connection_state.rb#9
Net::IMAP::ConnectionState::Authenticated::NAME = T.let(T.unsafe(nil), Symbol)

class Net::IMAP::ConnectionState::Logout < ::Net::IMAP::ConnectionState
  class << self
    # source://net-imap//lib/net/imap/connection_state.rb#8
    def [](*_arg0); end

    # source://net-imap//lib/net/imap/connection_state.rb#8
    def inspect; end

    # source://net-imap//lib/net/imap/connection_state.rb#8
    def members; end

    # source://net-imap//lib/net/imap/connection_state.rb#8
    def new(*_arg0); end
  end
end

# source://net-imap//lib/net/imap/connection_state.rb#9
Net::IMAP::ConnectionState::Logout::NAME = T.let(T.unsafe(nil), Symbol)

class Net::IMAP::ConnectionState::NotAuthenticated < ::Net::IMAP::ConnectionState
  class << self
    # source://net-imap//lib/net/imap/connection_state.rb#8
    def [](*_arg0); end

    # source://net-imap//lib/net/imap/connection_state.rb#8
    def inspect; end

    # source://net-imap//lib/net/imap/connection_state.rb#8
    def members; end

    # source://net-imap//lib/net/imap/connection_state.rb#8
    def new(*_arg0); end
  end
end

# source://net-imap//lib/net/imap/connection_state.rb#9
Net::IMAP::ConnectionState::NotAuthenticated::NAME = T.let(T.unsafe(nil), Symbol)

class Net::IMAP::ConnectionState::Selected < ::Net::IMAP::ConnectionState
  class << self
    # source://net-imap//lib/net/imap/connection_state.rb#8
    def [](*_arg0); end

    # source://net-imap//lib/net/imap/connection_state.rb#8
    def inspect; end

    # source://net-imap//lib/net/imap/connection_state.rb#8
    def members; end

    # source://net-imap//lib/net/imap/connection_state.rb#8
    def new(*_arg0); end
  end
end

# source://net-imap//lib/net/imap/connection_state.rb#9
Net::IMAP::ConnectionState::Selected::NAME = T.let(T.unsafe(nil), Symbol)

# >>>
#   *NOTE:* <em>CopyUIDData will replace UIDPlusData for +COPYUID+ in the
#   +0.6.0+ release.</em>  To use CopyUIDData before +0.6.0+, set
#   Config#parser_use_deprecated_uidplus_data to +false+.
#
# CopyUIDData represents the ResponseCode#data that accompanies the
# +COPYUID+ {response code}[rdoc-ref:ResponseCode].
#
# A server that supports +UIDPLUS+ (or +IMAP4rev2+) should send CopyUIDData
# in response to
# copy[rdoc-ref:Net::IMAP#copy], {uid_copy}[rdoc-ref:Net::IMAP#uid_copy],
# move[rdoc-ref:Net::IMAP#copy], and {uid_move}[rdoc-ref:Net::IMAP#uid_move]
# commands---unless the destination mailbox reports +UIDNOTSTICKY+.
#
# Note that copy[rdoc-ref:Net::IMAP#copy] and
# {uid_copy}[rdoc-ref:Net::IMAP#uid_copy] return CopyUIDData in their
# TaggedResponse.  But move[rdoc-ref:Net::IMAP#copy] and
# {uid_move}[rdoc-ref:Net::IMAP#uid_move] _should_ send CopyUIDData in an
# UntaggedResponse response before sending their TaggedResponse.  However
# some servers do send CopyUIDData in the TaggedResponse for +MOVE+
# commands---this complies with the older +UIDPLUS+ specification but is
# discouraged by the +MOVE+ extension and disallowed by +IMAP4rev2+.
#
# == Required capability
# Requires either +UIDPLUS+ [RFC4315[https://www.rfc-editor.org/rfc/rfc4315]]
# or +IMAP4rev2+ capability.
#
# source://net-imap//lib/net/imap/uidplus_data.rb#137
class Net::IMAP::CopyUIDData < ::Net::IMAP::DataLite
  # @return [CopyUIDData] a new instance of CopyUIDData
  #
  # source://net-imap//lib/net/imap/uidplus_data.rb#138
  def initialize(uidvalidity:, source_uids:, assigned_uids:); end

  # :call-seq:
  #   assigned_uid_for(source_uid) -> uid
  #   self[source_uid] -> uid
  #
  # Returns the UID in the destination mailbox for the message that was
  # copied from +source_uid+ in the source mailbox.
  #
  # This is the reverse of #source_uid_for.
  #
  # Related: source_uid_for, each_uid_pair, uid_mapping
  #
  # source://net-imap//lib/net/imap/uidplus_data.rb#190
  def [](source_uid); end

  # :call-seq:
  #   assigned_uid_for(source_uid) -> uid
  #   self[source_uid] -> uid
  #
  # Returns the UID in the destination mailbox for the message that was
  # copied from +source_uid+ in the source mailbox.
  #
  # This is the reverse of #source_uid_for.
  #
  # Related: source_uid_for, each_uid_pair, uid_mapping
  #
  # source://net-imap//lib/net/imap/uidplus_data.rb#186
  def assigned_uid_for(source_uid); end

  # Yields a pair of UIDs for each copied message.  The first is the
  # message's UID in the source mailbox and the second is the UID in the
  # destination mailbox.
  #
  # Returns an enumerator when no block is given.
  #
  # Please note the warning on uid_mapping before calling methods like
  # +to_h+ or +to_a+ on the returned enumerator.
  #
  # Related: uid_mapping, assigned_uid_for, source_uid_for
  #
  # source://net-imap//lib/net/imap/uidplus_data.rb#225
  def each; end

  # Yields a pair of UIDs for each copied message.  The first is the
  # message's UID in the source mailbox and the second is the UID in the
  # destination mailbox.
  #
  # Returns an enumerator when no block is given.
  #
  # Please note the warning on uid_mapping before calling methods like
  # +to_h+ or +to_a+ on the returned enumerator.
  #
  # Related: uid_mapping, assigned_uid_for, source_uid_for
  #
  # source://net-imap//lib/net/imap/uidplus_data.rb#224
  def each_pair; end

  # Yields a pair of UIDs for each copied message.  The first is the
  # message's UID in the source mailbox and the second is the UID in the
  # destination mailbox.
  #
  # Returns an enumerator when no block is given.
  #
  # Please note the warning on uid_mapping before calling methods like
  # +to_h+ or +to_a+ on the returned enumerator.
  #
  # Related: uid_mapping, assigned_uid_for, source_uid_for
  #
  # source://net-imap//lib/net/imap/uidplus_data.rb#216
  def each_uid_pair; end

  # Returns the number of messages that have been copied or moved.
  # source_uids and the assigned_uids will both the same number of UIDs.
  #
  # source://net-imap//lib/net/imap/uidplus_data.rb#172
  def size; end

  # :call-seq:
  #   source_uid_for(assigned_uid) -> uid
  #
  # Returns the UID in the source mailbox for the message that was copied to
  # +assigned_uid+ in the source mailbox.
  #
  # This is the reverse of #assigned_uid_for.
  #
  # Related: assigned_uid_for, each_uid_pair, uid_mapping
  #
  # source://net-imap//lib/net/imap/uidplus_data.rb#201
  def source_uid_for(assigned_uid); end

  # :call-seq: uid_mapping -> hash
  #
  # Returns a hash mapping each source UID to the newly assigned destination
  # UID.
  #
  # <em>*Warning:*</em> The hash that is created may consume _much_ more
  # memory than the data used to create it.  When handling responses from an
  # untrusted server, check #size before calling this method.
  #
  # Related: each_uid_pair, assigned_uid_for, source_uid_for
  #
  # source://net-imap//lib/net/imap/uidplus_data.rb#237
  def uid_mapping; end
end

# Mailbox attribute indicating that this mailbox is used to hold draft
# messages -- typically, messages that are being composed but have not yet
# been sent. In some server implementations, this might be a virtual
# mailbox, containing messages from other mailboxes that are marked with the
# "\Draft" message flag. Alternatively, this might just be advice that a
# client put drafts here
#
# source://net-imap//lib/net/imap/flags.rb#232
Net::IMAP::DRAFTS = T.let(T.unsafe(nil), Symbol)

# source://net-imap//lib/net/imap/data_lite.rb#36
Net::IMAP::Data = Net::IMAP::DataLite

# source://net-imap//lib/net/imap/data_lite.rb#31
class Net::IMAP::DataLite < ::Data
  # source://net-imap//lib/net/imap/data_lite.rb#32
  def encode_with(coder); end

  # source://net-imap//lib/net/imap/data_lite.rb#33
  def init_with(coder); end
end

# This module handles deprecated arguments to various Net::IMAP methods.
#
# source://net-imap//lib/net/imap/deprecated_client_options.rb#7
module Net::IMAP::DeprecatedClientOptions
  # :call-seq:
  #   Net::IMAP.new(host, **options) # standard keyword options
  #   Net::IMAP.new(host, options)   # obsolete hash options
  #   Net::IMAP.new(host, port)      # obsolete port argument
  #   Net::IMAP.new(host, port, usessl, certs = nil, verify = true) # deprecated SSL arguments
  #
  # Translates Net::IMAP.new arguments for backward compatibility.
  #
  # ==== Obsolete arguments
  #
  # Use of obsolete arguments does not print a warning.  Obsolete arguments
  # will be deprecated by a future release.
  #
  # If a second positional argument is given and it is a hash (or is
  # convertible via +#to_hash+), it is converted to keyword arguments.
  #
  #     # Obsolete:
  #     Net::IMAP.new("imap.example.com", options_hash)
  #     # Use instead:
  #     Net::IMAP.new("imap.example.com", **options_hash)
  #
  # If a second positional argument is given and it is not a hash, it is
  # converted to the +port+ keyword argument.
  #     # Obsolete:
  #     Net::IMAP.new("imap.example.com", 114433)
  #     # Use instead:
  #     Net::IMAP.new("imap.example.com", port: 114433)
  #
  # ==== Deprecated arguments
  #
  # Using deprecated arguments prints a warning.  Convert to keyword
  # arguments to avoid the warning.  Deprecated arguments will be removed in
  # a future release.
  #
  # If +usessl+ is false, +certs+, and +verify+ are ignored.  When it true,
  # all three arguments are converted to the +ssl+ keyword argument.
  # Without +certs+ or +verify+, it is converted to <tt>ssl: true</tt>.
  #     # DEPRECATED:
  #     Net::IMAP.new("imap.example.com", nil, true) # => prints a warning
  #     # Use instead:
  #     Net::IMAP.new("imap.example.com", ssl: true)
  #
  # When +certs+ is a path to a directory, it is converted to <tt>ca_path:
  # certs</tt>.
  #     # DEPRECATED:
  #     Net::IMAP.new("imap.example.com", nil, true, "/path/to/certs") # => prints a warning
  #     # Use instead:
  #     Net::IMAP.new("imap.example.com", ssl: {ca_path: "/path/to/certs"})
  #
  # When +certs+ is a path to a file, it is converted to <tt>ca_file:
  # certs</tt>.
  #     # DEPRECATED:
  #     Net::IMAP.new("imap.example.com", nil, true, "/path/to/cert.pem") # => prints a warning
  #     # Use instead:
  #     Net::IMAP.new("imap.example.com", ssl: {ca_file: "/path/to/cert.pem"})
  #
  # When +verify+ is +false+, it is converted to <tt>verify_mode:
  # OpenSSL::SSL::VERIFY_NONE</tt>.
  #     # DEPRECATED:
  #     Net::IMAP.new("imap.example.com", nil, true, nil, false) # => prints a warning
  #     # Use instead:
  #     Net::IMAP.new("imap.example.com", ssl: {verify_mode: OpenSSL::SSL::VERIFY_NONE})
  #
  # source://net-imap//lib/net/imap/deprecated_client_options.rb#72
  def initialize(host, port_or_options = T.unsafe(nil), *deprecated, **options); end

  # :call-seq:
  #   starttls(**options) # standard
  #   starttls(options = {}) # obsolete
  #   starttls(certs = nil, verify = true) # deprecated
  #
  # Translates Net::IMAP#starttls arguments for backward compatibility.
  #
  # Support for +certs+ and +verify+ will be dropped in a future release.
  #
  # See ::new for interpretation of +certs+ and +verify+.
  #
  # source://net-imap//lib/net/imap/deprecated_client_options.rb#106
  def starttls(*deprecated, **options); end

  private

  # source://net-imap//lib/net/imap/deprecated_client_options.rb#126
  def create_ssl_params(certs = T.unsafe(nil), verify = T.unsafe(nil)); end
end

# source://net-imap//lib/net/imap.rb#794
Net::IMAP::ENABLE_ALIASES = T.let(T.unsafe(nil), Hash)

# An "extended search" response (+ESEARCH+).  ESearchResult should be
# returned (instead of SearchResult) by IMAP#search, IMAP#uid_search,
# IMAP#sort, and IMAP#uid_sort under any of the following conditions:
#
# * Return options were specified for IMAP#search or IMAP#uid_search.
#   The server must support a search extension which allows
#   RFC4466[https://www.rfc-editor.org/rfc/rfc4466.html] +return+ options,
#   such as +ESEARCH+, +PARTIAL+, or +IMAP4rev2+.
# * Return options were specified for IMAP#sort or IMAP#uid_sort.
#   The server must support the +ESORT+ extension
#   {[RFC5267]}[https://www.rfc-editor.org/rfc/rfc5267.html#section-3].
#
#   *NOTE:* IMAP#search and IMAP#uid_search do not support +ESORT+ yet.
# * The server supports +IMAP4rev2+ but _not_ +IMAP4rev1+, or +IMAP4rev2+
#   has been enabled.  +IMAP4rev2+ requires +ESEARCH+ results.
#
# Note that some servers may claim to support a search extension which
# requires an +ESEARCH+ result, such as +PARTIAL+, but still only return a
# +SEARCH+ result when +return+ options are specified.
#
# Some search extensions may result in the server sending ESearchResult
# responses after the initiating command has completed.  Use
# IMAP#add_response_handler to handle these responses.
#
# source://net-imap//lib/net/imap/esearch_result.rb#28
class Net::IMAP::ESearchResult < ::Net::IMAP::DataLite
  # @return [ESearchResult] a new instance of ESearchResult
  #
  # source://net-imap//lib/net/imap/esearch_result.rb#29
  def initialize(tag: T.unsafe(nil), uid: T.unsafe(nil), data: T.unsafe(nil)); end

  # :call-seq: all -> sequence set or nil
  #
  # A SequenceSet containing all message sequence numbers or UIDs that
  # satisfy the SEARCH criteria.
  #
  # Returns +nil+ when the associated search command has no results, or when
  # the +ALL+ return option was not specified but other return options were.
  #
  # Requires +ESEARCH+ {[RFC4731]}[https://www.rfc-editor.org/rfc/rfc4731.html#section-3.1] or
  # +IMAP4rev2+ {[RFC9051]}[https://www.rfc-editor.org/rfc/rfc9051.html#section-7.3.4].
  #
  # See also: #to_a
  #
  # source://net-imap//lib/net/imap/esearch_result.rb#147
  def all; end

  # :call-seq: count -> integer or nil
  #
  # Returns the number of messages that satisfy the SEARCH criteria.
  #
  # Returns +nil+ when the associated search command has no results, or when
  # the +COUNT+ return option wasn't specified.
  #
  # Requires +ESEARCH+ {[RFC4731]}[https://www.rfc-editor.org/rfc/rfc4731.html#section-3.1] or
  # +IMAP4rev2+ {[RFC9051]}[https://www.rfc-editor.org/rfc/rfc9051.html#section-7.3.4].
  #
  # source://net-imap//lib/net/imap/esearch_result.rb#158
  def count; end

  # When either #all or #partial contains a SequenceSet of message sequence
  # numbers or UIDs, +each+ yields each integer in the set.
  #
  # When both #all and #partial are +nil+, either because the server
  # returned no results or because +ALL+ and +PARTIAL+ were not included in
  # the IMAP#search +RETURN+ options, #each does not yield.
  #
  # Note that SearchResult also implements +#each+, so it can be used
  # without checking if the server returned +SEARCH+ or +ESEARCH+ data.
  #
  # Related: #to_sequence_set, #to_a, #all, #partial
  #
  # source://net-imap//lib/net/imap/esearch_result.rb#80
  def each(&_arg0); end

  # :call-seq: max -> integer or nil
  #
  # The highest message number/UID that satisfies the SEARCH criteria.
  #
  # Returns +nil+ when the associated search command has no results, or when
  # the +MAX+ return option wasn't specified.
  #
  # Requires +ESEARCH+ {[RFC4731]}[https://www.rfc-editor.org/rfc/rfc4731.html#section-3.1] or
  # +IMAP4rev2+ {[RFC9051]}[https://www.rfc-editor.org/rfc/rfc9051.html#section-7.3.4].
  #
  # source://net-imap//lib/net/imap/esearch_result.rb#133
  def max; end

  # :call-seq: min -> integer or nil
  #
  # The lowest message number/UID that satisfies the SEARCH criteria.
  #
  # Returns +nil+ when the associated search command has no results, or when
  # the +MIN+ return option wasn't specified.
  #
  # Requires +ESEARCH+ {[RFC4731]}[https://www.rfc-editor.org/rfc/rfc4731.html#section-3.1] or
  # +IMAP4rev2+ {[RFC9051]}[https://www.rfc-editor.org/rfc/rfc9051.html#section-7.3.4].
  #
  # source://net-imap//lib/net/imap/esearch_result.rb#122
  def min; end

  # :call-seq: modseq -> integer or nil
  #
  # The highest +mod-sequence+ of all messages being returned.
  #
  # Returns +nil+ when the associated search command has no results, or when
  # the +MODSEQ+ search criterion wasn't specified.
  #
  # Note that there is no search +return+ option for +MODSEQ+.  It will be
  # returned whenever the +CONDSTORE+ extension has been enabled.  Using the
  # +MODSEQ+ search criteria will implicitly enable +CONDSTORE+.
  #
  # Requires +CONDSTORE+ {[RFC7162]}[https://www.rfc-editor.org/rfc/rfc7162.html]
  # and +ESEARCH+ {[RFC4731]}[https://www.rfc-editor.org/rfc/rfc4731.html#section-3.2].
  #
  # source://net-imap//lib/net/imap/esearch_result.rb#173
  def modseq; end

  # :call-seq: partial -> PartialResult or nil
  #
  # A PartialResult containing a subset of the message sequence numbers or
  # UIDs that satisfy the SEARCH criteria.
  #
  # Requires +PARTIAL+ {[RFC9394]}[https://www.rfc-editor.org/rfc/rfc9394.html]
  # or <tt>CONTEXT=SEARCH</tt>/<tt>CONTEXT=SORT</tt>
  # {[RFC5267]}[https://www.rfc-editor.org/rfc/rfc5267.html]
  #
  # See also: #to_a
  #
  # source://net-imap//lib/net/imap/esearch_result.rb#215
  def partial; end

  # :call-seq: to_a -> Array of integers
  #
  # When either #all or #partial contains a SequenceSet of message sequence
  # numbers or UIDs, +to_a+ returns that set as an array of integers.
  #
  # When both #all and #partial are +nil+, either because the server
  # returned no results or because neither +ALL+ or +PARTIAL+ were included
  # in the IMAP#search +RETURN+ options, #to_a returns an empty array.
  #
  # Note that SearchResult also implements +to_a+, so it can be used without
  # checking if the server returned +SEARCH+ or +ESEARCH+ data.
  #
  # Related: #each, #to_sequence_set, #all, #partial
  #
  # source://net-imap//lib/net/imap/esearch_result.rb#49
  def to_a; end

  # :call-seq: to_sequence_set -> SequenceSet or nil
  #
  # When either #all or #partial contains a SequenceSet of message sequence
  # numbers or UIDs, +to_sequence_set+ returns that sequence set.
  #
  # When both #all and #partial are +nil+, either because the server
  # returned no results or because neither +ALL+ or +PARTIAL+ were included
  # in the IMAP#search +RETURN+ options, #to_sequence_set returns
  # SequenceSet.empty.
  #
  # Note that SearchResult also implements +to_sequence_set+, so it can be
  # used without checking if the server returned +SEARCH+ or +ESEARCH+ data.
  #
  # Related: #each, #to_a, #all, #partial
  #
  # source://net-imap//lib/net/imap/esearch_result.rb#65
  def to_sequence_set; end

  # source://net-imap//lib/net/imap/esearch_result.rb#100
  def uid?; end
end

# Returned by ESearchResult#partial.
#
# Requires +PARTIAL+ {[RFC9394]}[https://www.rfc-editor.org/rfc/rfc9394.html]
# or <tt>CONTEXT=SEARCH</tt>/<tt>CONTEXT=SORT</tt>
# {[RFC5267]}[https://www.rfc-editor.org/rfc/rfc5267.html]
#
# See also: #to_a
#
# source://net-imap//lib/net/imap/esearch_result.rb#182
class Net::IMAP::ESearchResult::PartialResult < ::Net::IMAP::DataLite
  # @return [PartialResult] a new instance of PartialResult
  #
  # source://net-imap//lib/net/imap/esearch_result.rb#183
  def initialize(range:, results:); end

  # Converts #results to an array of integers.
  #
  # See also: ESearchResult#to_a.
  #
  # source://net-imap//lib/net/imap/esearch_result.rb#200
  def to_a; end

  # source://net-imap//lib/net/imap/esearch_result.rb#202
  def to_sequence_set; end
end

# **Note:** This represents an intentionally _unstable_ API.  Where
# instances of this class are returned, future releases may return a
# different (incompatible) object <em>without deprecation or warning</em>.
#
# Net::IMAP::ExtensionData represents data that is parsable according to the
# forward-compatible extension syntax in RFC3501, RFC4466, or RFC9051, but
# isn't directly known or understood by Net::IMAP yet.
#
# See also: UnparsedData, UnparsedNumericResponseData, IgnoredResponse
#
# source://net-imap//lib/net/imap/response_data.rb#125
class Net::IMAP::ExtensionData < ::Struct; end

# Net::IMAP::FetchStruct is the superclass for FetchData and UIDFetchData.
# Net::IMAP#fetch, Net::IMAP#uid_fetch, Net::IMAP#store, and
# Net::IMAP#uid_store all return arrays of FetchStruct objects.
#
# === Fetch attributes
#
# See {[IMAP4rev1 §7.4.2]}[https://www.rfc-editor.org/rfc/rfc3501.html#section-7.4.2]
# and {[IMAP4rev2 §7.5.2]}[https://www.rfc-editor.org/rfc/rfc9051.html#section-7.5.2]
# for a full description of the standard fetch response data items, and
# Net::IMAP@Message+envelope+and+body+structure for other relevant RFCs.
#
# ==== Static fetch data items
#
# Most message attributes are static, and must never change for a given
# <tt>(server, account, mailbox, UIDVALIDITY, UID)</tt> tuple.
#
# The static fetch data items defined by both
# IMAP4rev1[https://www.rfc-editor.org/rfc/rfc3501.html] and
# IMAP4rev2[https://www.rfc-editor.org/rfc/rfc9051.html] are:
#
# * <b><tt>"UID"</tt></b> --- See #uid.
# * <b><tt>"BODY"</tt></b> --- See #body.
# * <b><tt>"BODY[#{section_spec}]"</tt></b>,
#   <b><tt>"BODY[#{section_spec}]<#{offset}>"</tt></b> --- See #message,
#   #part, #header, #header_fields, #header_fields_not, #mime, and #text.
# * <b><tt>"BODYSTRUCTURE"</tt></b> --- See #bodystructure.
# * <b><tt>"ENVELOPE"</tt></b> --- See #envelope.
# * <b><tt>"INTERNALDATE"</tt></b> --- See #internaldate.
# * <b><tt>"RFC822.SIZE"</tt></b> --- See #rfc822_size.
#
# IMAP4rev2[https://www.rfc-editor.org/rfc/rfc9051.html] adds the
# additional fetch items from the +BINARY+ extension
# {[RFC3516]}[https://www.rfc-editor.org/rfc/rfc3516.html]:
#
# * <b><tt>"BINARY[#{part}]"</tt></b>,
#   <b><tt>"BINARY[#{part}]<#{offset}>"</tt></b> -- See #binary.
# * <b><tt>"BINARY.SIZE[#{part}]"</tt></b> -- See #binary_size.
#
# Several static message attributes in
# IMAP4rev1[https://www.rfc-editor.org/rfc/rfc3501.html] are obsolete and
# been removed from
# IMAP4rev2[https://www.rfc-editor.org/rfc/rfc9051.html]:
#
# * <b><tt>"RFC822"</tt></b> --- See #rfc822 or replace with
#   <tt>"BODY[]"</tt> and #message.
# * <b><tt>"RFC822.HEADER"</tt></b> --- See #rfc822_header or replace with
#   <tt>"BODY[HEADER]"</tt> and #header.
# * <b><tt>"RFC822.TEXT"</tt></b> --- See #rfc822_text or replace with
#   <tt>"BODY[TEXT]"</tt> and #text.
#
# Net::IMAP supports static attributes defined by the following extensions:
# * +OBJECTID+ {[RFC8474]}[https://www.rfc-editor.org/rfc/rfc8474.html]
#   * <b><tt>"EMAILID"</tt></b> --- See #emailid.
#   * <b><tt>"THREADID"</tt></b> --- See #threadid.
#
# * +X-GM-EXT-1+ {[non-standard Gmail
#   extension]}[https://developers.google.com/gmail/imap/imap-extensions]
#   * <b><tt>"X-GM-MSGID"</tt></b> --- unique message ID.  Access via #attr.
#   * <b><tt>"X-GM-THRID"</tt></b> --- Thread ID.  Access via #attr.
#
# [NOTE:]
#     Additional static fields are defined in other \IMAP extensions, but
#     Net::IMAP can't parse them yet.
#
# ==== Dynamic message attributes
#
# Some message attributes can be dynamically changed, for example using the
# {STORE command}[rdoc-ref:Net::IMAP#store].
#
# The only dynamic message attribute defined by
# IMAP4rev1[https://www.rfc-editor.org/rfc/rfc3501.html] and
# IMAP4rev2[https://www.rfc-editor.org/rfc/rfc9051.html] is:
#
# * <b><tt>"FLAGS"</tt></b> --- See #flags.
#
# Net::IMAP supports dynamic attributes defined by the following extensions:
#
# * +CONDSTORE+ {[RFC7162]}[https://www.rfc-editor.org/rfc/rfc7162.html]:
#   * <b><tt>"MODSEQ"</tt></b> --- See #modseq.
# * +X-GM-EXT-1+ {[non-standard Gmail
#   extension]}[https://developers.google.com/gmail/imap/imap-extensions]
#   * <b><tt>"X-GM-LABELS"</tt></b> --- Gmail labels.  Access via #attr.
#
# [NOTE:]
#     Additional dynamic fields are defined in other \IMAP extensions, but
#     Net::IMAP can't parse them yet.
#
# === Implicitly setting <tt>\Seen</tt> and using +PEEK+
#
# Unless the mailbox has been opened as read-only, fetching
# <tt>BODY[#{section}]</tt> or <tt>BINARY[#{section}]</tt>
# will implicitly set the <tt>\Seen</tt> flag.  To avoid this, fetch using
# <tt>BODY.PEEK[#{section}]</tt> or <tt>BINARY.PEEK[#{section}]</tt>
# instead.
#
# [NOTE:]
#   The data will always be _returned_ without the <tt>".PEEK"</tt> suffix,
#   as <tt>BODY[#{specifier}]</tt> or <tt>BINARY[#{section}]</tt>.
#
# source://net-imap//lib/net/imap/fetch_data.rb#105
class Net::IMAP::FetchStruct < ::Struct
  # :call-seq: attr_upcase -> hash
  #
  # A transformation of #attr, with all the keys converted to upper case.
  #
  # Header field names are case-preserved but not case-sensitive, so this is
  # used by #header_fields and #header_fields_not.
  #
  # source://net-imap//lib/net/imap/fetch_data.rb#121
  def attr_upcase; end

  # :call-seq:
  #   binary(*part_nums, offset: nil) -> string or nil
  #
  # Returns the binary representation of a particular MIME part, which has
  # already been decoded according to its Content-Transfer-Encoding.
  #
  # See #part for a description of +part_nums+ and +offset+.
  #
  # This is the same as getting the value of
  # <tt>"BINARY[#{part_nums.join(".")}]"</tt> or
  # <tt>"BINARY[#{part_nums.join(".")}]<#{offset}>"</tt> from #attr.
  #
  # The server must support either
  # IMAP4rev2[https://www.rfc-editor.org/rfc/rfc9051.html]
  # or the +BINARY+ extension
  # {[RFC3516]}[https://www.rfc-editor.org/rfc/rfc3516.html].
  #
  # See also: #binary_size, #mime
  #
  # source://net-imap//lib/net/imap/fetch_data.rb#428
  def binary(*part_nums, offset: T.unsafe(nil)); end

  # :call-seq:
  #   binary_size(*part_nums) -> integer or nil
  #
  # Returns the decoded size of a particular MIME part (the size to expect
  # in response to a <tt>BINARY</tt> fetch request).
  #
  # See #part for a description of +part_nums+.
  #
  # This is the same as getting the value of
  # <tt>"BINARY.SIZE[#{part_nums.join(".")}]"</tt> from #attr.
  #
  # The server must support either
  # IMAP4rev2[https://www.rfc-editor.org/rfc/rfc9051.html]
  # or the +BINARY+ extension
  # {[RFC3516]}[https://www.rfc-editor.org/rfc/rfc3516.html].
  #
  # See also: #binary, #mime
  #
  # source://net-imap//lib/net/imap/fetch_data.rb#449
  def binary_size(*part_nums); end

  # :call-seq:
  #   body -> body structure or nil
  #
  # Returns an alternate form of #bodystructure, without any extension data.
  #
  # This is the same as getting the value for <tt>"BODY"</tt> from #attr.
  #
  # [NOTE:]
  #   Use #message, #part, #header, #header_fields, #header_fields_not,
  #   #text, or #mime to retrieve <tt>BODY[#{section_spec}]</tt> attributes.
  #
  # source://net-imap//lib/net/imap/fetch_data.rb#133
  def body; end

  # :call-seq:
  #   bodystructure -> BodyStructure struct or nil
  #
  # A BodyStructure object that describes the message, if it was fetched.
  #
  # This is the same as getting the value for <tt>"BODYSTRUCTURE"</tt> from
  # #attr.
  #
  # source://net-imap//lib/net/imap/fetch_data.rb#297
  def body_structure; end

  # :call-seq:
  #   bodystructure -> BodyStructure struct or nil
  #
  # A BodyStructure object that describes the message, if it was fetched.
  #
  # This is the same as getting the value for <tt>"BODYSTRUCTURE"</tt> from
  # #attr.
  #
  # source://net-imap//lib/net/imap/fetch_data.rb#295
  def bodystructure; end

  # :call-seq: emailid -> string or nil
  #
  # An ObjectID that uniquely identifies the immutable content of a single
  # message.
  #
  # The server must return the same +EMAILID+ for both the source and
  # destination messages after a COPY or MOVE command.  However, it is
  # possible for different messages with the same EMAILID to have different
  # mutable attributes, such as flags.
  #
  # This is the same as getting the value for <tt>"EMAILID"</tt> from
  # #attr.
  #
  # The server must support the +OBJECTID+ extension
  # {[RFC8474]}[https://www.rfc-editor.org/rfc/rfc8474.html].
  #
  # source://net-imap//lib/net/imap/fetch_data.rb#482
  def emailid; end

  # :call-seq: envelope -> Envelope or nil
  #
  # An Envelope object that describes the envelope structure of a message.
  # See the documentation for Envelope for a description of the envelope
  # structure attributes.
  #
  # This is the same as getting the value for <tt>"ENVELOPE"</tt> from
  # #attr.
  #
  # source://net-imap//lib/net/imap/fetch_data.rb#307
  def envelope; end

  # :call-seq: flags -> array of Symbols and Strings, or nil
  #
  # A array of flags that are set for this message.  System flags are
  # symbols that have been capitalized by String#capitalize.  Keyword flags
  # are strings and their case is not changed.
  #
  # This is the same as getting the value for <tt>"FLAGS"</tt> from #attr.
  #
  # [NOTE:]
  #   The +FLAGS+ field is dynamic, and can change for a uniquely identified
  #   message.
  #
  # source://net-imap//lib/net/imap/fetch_data.rb#320
  def flags; end

  # :call-seq:
  #   header(*part_nums,                offset: nil) -> string or nil
  #   header(*part_nums, fields: names, offset: nil) -> string or nil
  #   header(*part_nums, except: names, offset: nil) -> string or nil
  #
  # The {[RFC5322]}[https://www.rfc-editor.org/rfc/rfc5322.html] header of a
  # message or of an encapsulated
  # {[MIME-IMT]}[https://www.rfc-editor.org/rfc/rfc2046.html]
  # MESSAGE/RFC822 or MESSAGE/GLOBAL message.
  #
  # <em>Headers can be parsed using the "mail" gem.</em>
  #
  # See #part for a description of +part_nums+ and +offset+.
  #
  # ==== Without +fields+ or +except+
  # This is the same as getting the value from #attr for one of:
  # * <tt>BODY[HEADER]</tt>
  # * <tt>BODY[HEADER]<#{offset}></tt>
  # * <tt>BODY[#{part_nums.join "."}.HEADER]"</tt>
  # * <tt>BODY[#{part_nums.join "."}.HEADER]<#{offset}>"</tt>
  #
  # ==== With +fields+
  # When +fields+ is sent, returns a subset of the header which contains
  # only the header fields that match one of the names in the list.
  #
  # This is the same as getting the value from #attr_upcase for one of:
  # * <tt>BODY[HEADER.FIELDS (#{names.join " "})]</tt>
  # * <tt>BODY[HEADER.FIELDS (#{names.join " "})]<#{offset}></tt>
  # * <tt>BODY[#{part_nums.join "."}.HEADER.FIELDS (#{names.join " "})]</tt>
  # * <tt>BODY[#{part_nums.join "."}.HEADER.FIELDS (#{names.join " "})]<#{offset}></tt>
  #
  # See also: #header_fields
  #
  # ==== With +except+
  # When +except+ is sent, returns a subset of the header which contains
  # only the header fields that do _not_ match one of the names in the list.
  #
  # This is the same as getting the value from #attr_upcase for one of:
  # * <tt>BODY[HEADER.FIELDS.NOT (#{names.join " "})]</tt>
  # * <tt>BODY[HEADER.FIELDS.NOT (#{names.join " "})]<#{offset}></tt>
  # * <tt>BODY[#{part_nums.join "."}.HEADER.FIELDS.NOT (#{names.join " "})]</tt>
  # * <tt>BODY[#{part_nums.join "."}.HEADER.FIELDS.NOT (#{names.join " "})]<#{offset}></tt>
  #
  # See also: #header_fields_not
  #
  # source://net-imap//lib/net/imap/fetch_data.rb#219
  def header(*part_nums, fields: T.unsafe(nil), except: T.unsafe(nil), offset: T.unsafe(nil)); end

  # :call-seq:
  #   header_fields(*names, part: [], offset: nil) -> string or nil
  #
  # The result from #header when called with <tt>fields: names</tt>.
  #
  # source://net-imap//lib/net/imap/fetch_data.rb#237
  def header_fields(first, *rest, part: T.unsafe(nil), offset: T.unsafe(nil)); end

  # :call-seq:
  #   header_fields_not(*names, part: [], offset: nil) -> string or nil
  #
  # The result from #header when called with <tt>except: names</tt>.
  #
  # source://net-imap//lib/net/imap/fetch_data.rb#245
  def header_fields_not(first, *rest, part: T.unsafe(nil), offset: T.unsafe(nil)); end

  # :call-seq: internaldate -> Time or nil
  #
  # The internal date and time of the message on the server.  This is not
  # the date and time in the [RFC5322[https://www.rfc-editor.org/rfc/rfc5322]]
  # header, but rather a date and time which reflects when the message was
  # received.
  #
  # This is similar to getting the value for <tt>"INTERNALDATE"</tt> from
  # #attr.
  #
  # [NOTE:]
  #   <tt>attr["INTERNALDATE"]</tt> returns a string, and this method
  #   returns a Time object.
  #
  # source://net-imap//lib/net/imap/fetch_data.rb#339
  def internal_date; end

  # :call-seq: internaldate -> Time or nil
  #
  # The internal date and time of the message on the server.  This is not
  # the date and time in the [RFC5322[https://www.rfc-editor.org/rfc/rfc5322]]
  # header, but rather a date and time which reflects when the message was
  # received.
  #
  # This is similar to getting the value for <tt>"INTERNALDATE"</tt> from
  # #attr.
  #
  # [NOTE:]
  #   <tt>attr["INTERNALDATE"]</tt> returns a string, and this method
  #   returns a Time object.
  #
  # source://net-imap//lib/net/imap/fetch_data.rb#335
  def internaldate; end

  # :call-seq:
  #   message(offset: bytes) -> string or nil
  #
  # The RFC5322[https://www.rfc-editor.org/rfc/rfc5322.html]
  # expression of the entire message, as a string.
  #
  # See #part for a description of +offset+.
  #
  # <em>RFC5322 messages can be parsed using the "mail" gem.</em>
  #
  # This is the same as getting the value for <tt>"BODY[]"</tt> or
  # <tt>"BODY[]<#{offset}>"</tt> from #attr.
  #
  # See also: #header, #text, and #mime.
  #
  # source://net-imap//lib/net/imap/fetch_data.rb#149
  def message(offset: T.unsafe(nil)); end

  # :call-seq:
  #   mime(*part_nums)                -> string or nil
  #   mime(*part_nums, offset: bytes) -> string or nil
  #
  # The {[MIME-IMB]}[https://www.rfc-editor.org/rfc/rfc2045.html] header for
  # a message part, if it was fetched.
  #
  # See #part for a description of +part_nums+ and +offset+.
  #
  # This is the same as getting the value for
  # <tt>"BODY[#{part_nums}.MIME]"</tt> or
  # <tt>"BODY[#{part_nums}.MIME]<#{offset}>"</tt> from #attr.
  #
  # See also: #message, #header, and #text.
  #
  # source://net-imap//lib/net/imap/fetch_data.rb#263
  def mime(part, *subparts, offset: T.unsafe(nil)); end

  # :call-seq: modseq -> Integer or nil
  #
  # The modification sequence number associated with this IMAP message.
  #
  # This is the same as getting the value for <tt>"MODSEQ"</tt> from #attr.
  #
  # The server must support the +CONDSTORE+ extension
  # {[RFC7162]}[https://www.rfc-editor.org/rfc/rfc7162.html].
  #
  # [NOTE:]
  #   The +MODSEQ+ field is dynamic, and can change for a uniquely
  #   identified message.
  #
  # source://net-imap//lib/net/imap/fetch_data.rb#465
  def modseq; end

  # :call-seq:
  #   part(*part_nums, offset: bytes) -> string or nil
  #
  # The string representation of a particular MIME part.
  #
  # +part_nums+ forms a path of MIME part numbers, counting up from +1+,
  # which may specify an arbitrarily nested part, similarly to Array#dig.
  # Messages that don't use MIME, or MIME messages that are not multipart
  # and don't hold an encapsulated message, only have part +1+.
  #
  # If a zero-based +offset+ is given, the returned string is a substring of
  # the entire contents, starting at that origin octet.  This means that
  # <tt>BODY[]<0></tt> MAY be truncated, but <tt>BODY[]</tt> is never
  # truncated.
  #
  # This is the same as getting the value of
  # <tt>"BODY[#{part_nums.join(".")}]"</tt> or
  # <tt>"BODY[#{part_nums.join(".")}]<#{offset}>"</tt> from #attr.
  #
  # See also: #message, #header, #text, and #mime.
  #
  # source://net-imap//lib/net/imap/fetch_data.rb#171
  def part(index, *subparts, offset: T.unsafe(nil)); end

  # :call-seq: rfc822 -> String or nil
  #
  # Semantically equivalent to #message with no arguments.
  #
  # This is the same as getting the value for <tt>"RFC822"</tt> from #attr.
  #
  # [NOTE:]
  #   +IMAP4rev2+ deprecates <tt>RFC822</tt>.
  #
  # source://net-imap//lib/net/imap/fetch_data.rb#349
  def rfc822; end

  # :call-seq: rfc822_header -> String or nil
  #
  # Semantically equivalent to #header, with no arguments.
  #
  # This is the same as getting the value for <tt>"RFC822.HEADER"</tt> from #attr.
  #
  # [NOTE:]
  #   +IMAP4rev2+ deprecates <tt>RFC822.HEADER</tt>.
  #
  # source://net-imap//lib/net/imap/fetch_data.rb#386
  def rfc822_header; end

  # :call-seq: rfc822_size -> Integer or nil
  #
  # A number expressing the [RFC5322[https://www.rfc-editor.org/rfc/rfc5322]]
  # size of the message.
  #
  # This is the same as getting the value for <tt>"RFC822.SIZE"</tt> from
  # #attr.
  #
  # [NOTE:]
  #   \IMAP was originally developed for the older
  #   RFC822[https://www.rfc-editor.org/rfc/rfc822.html] standard, and as a
  #   consequence several fetch items in \IMAP incorporate "RFC822" in their
  #   name.  With the exception of +RFC822.SIZE+, there are more modern
  #   replacements; for example, the modern version of +RFC822.HEADER+ is
  #   <tt>BODY.PEEK[HEADER]</tt>.  In all cases, "RFC822" should be
  #   interpreted as a reference to the updated
  #   RFC5322[https://www.rfc-editor.org/rfc/rfc5322.html] standard.
  #
  # source://net-imap//lib/net/imap/fetch_data.rb#368
  def rfc822_size; end

  # :call-seq: rfc822_text -> String or nil
  #
  # Semantically equivalent to #text, with no arguments.
  #
  # This is the same as getting the value for <tt>"RFC822.TEXT"</tt> from
  # #attr.
  #
  # [NOTE:]
  #   +IMAP4rev2+ deprecates <tt>RFC822.TEXT</tt>.
  #
  # source://net-imap//lib/net/imap/fetch_data.rb#397
  def rfc822_text; end

  # Alias for: rfc822_size
  #
  # source://net-imap//lib/net/imap/fetch_data.rb#375
  def size; end

  # :call-seq:
  #   text(*part_nums)                -> string or nil
  #   text(*part_nums, offset: bytes) -> string or nil
  #
  # The text body of a message or a message part, if it was fetched,
  # omitting the {[RFC5322]}[https://www.rfc-editor.org/rfc/rfc5322.html]
  # header.
  #
  # See #part for a description of +part_nums+ and +offset+.
  #
  # This is the same as getting the value from #attr for one of:
  # * <tt>"BODY[TEXT]"</tt>,
  # * <tt>"BODY[TEXT]<#{offset}>"</tt>,
  # * <tt>"BODY[#{section}.TEXT]"</tt>, or
  # * <tt>"BODY[#{section}.TEXT]<#{offset}>"</tt>.
  #
  # See also: #message, #header, and #mime.
  #
  # source://net-imap//lib/net/imap/fetch_data.rb#284
  def text(*part, offset: T.unsafe(nil)); end

  # :call-seq: threadid -> string or nil
  #
  # An ObjectID that uniquely identifies a set of messages that the server
  # believes should be grouped together.
  #
  # It is generally based on some combination of References, In-Reply-To,
  # and Subject, but the exact implementation is left up to the server
  # implementation.  The server should return the same thread identifier for
  # related messages, even if they are in different mailboxes.
  #
  # This is the same as getting the value for <tt>"THREADID"</tt> from
  # #attr.
  #
  # The server must support the +OBJECTID+ extension
  # {[RFC8474]}[https://www.rfc-editor.org/rfc/rfc8474.html].
  #
  # source://net-imap//lib/net/imap/fetch_data.rb#499
  def threadid; end

  # :call-seq: uid -> Integer or nil
  #
  # A number expressing the unique identifier of the message.
  #
  # This is the same as getting the value for <tt>"UID"</tt> from #attr.
  #
  # [NOTE:]
  #   For UIDFetchData, this returns the uniqueid at the beginning of the
  #   +UIDFETCH+ response, _not_ the value from #attr.
  #
  # source://net-imap//lib/net/imap/fetch_data.rb#408
  def uid; end

  private

  # source://net-imap//lib/net/imap/fetch_data.rb#503
  def body_section_attr(*_arg0, **_arg1, &_arg2); end

  # source://net-imap//lib/net/imap/fetch_data.rb#505
  def section_attr(attr, part = T.unsafe(nil), text = T.unsafe(nil), offset: T.unsafe(nil)); end
end

# Alias for HAS_CHILDREN, to match the \IMAP spelling.
#
# source://net-imap//lib/net/imap/flags.rb#183
Net::IMAP::HASCHILDREN = T.let(T.unsafe(nil), Symbol)

# Alias for HAS_NO_CHILDREN, to match the \IMAP spelling.
#
# source://net-imap//lib/net/imap/flags.rb#185
Net::IMAP::HASNOCHILDREN = T.let(T.unsafe(nil), Symbol)

# The presence of this attribute indicates that the mailbox has child
# mailboxes. A server SHOULD NOT set this attribute if there are child
# mailboxes and the user does not have permission to access any of them.  In
# this case, +\HasNoChildren+ SHOULD be used. In many cases, however, a
# server may not be able to efficiently compute whether a user has access to
# any child mailboxes. Note that even though the +\HasChildren+ attribute
# for a mailbox must be correct at the time of processing the mailbox, a
# client must be prepared to deal with a situation when a mailbox is marked
# with the +\HasChildren+ attribute, but no child mailbox appears in the
# response to the #list command. This might happen, for example, due to child
# mailboxes being deleted or made inaccessible to the user (using access
# control) by another client before the server is able to list them.
#
# It is an error for the server to return both a +\HasChildren+ and a
# +\HasNoChildren+ attribute in the same #list response. A client that
# encounters a #list response with both +\HasChildren+ and +\HasNoChildren+
# attributes present should act as if both are absent in the #list response.
#
# source://net-imap//lib/net/imap/flags.rb#136
Net::IMAP::HAS_CHILDREN = T.let(T.unsafe(nil), Symbol)

# The presence of this attribute indicates that the mailbox has NO child
# mailboxes that are accessible to the currently authenticated user.
#
# It is an error for the server to return both a +\HasChildren+ and a
# +\HasNoChildren+ attribute in the same #list response. A client that
# encounters a #list response with both +\HasChildren+ and +\HasNoChildren+
# attributes present should act as if both are absent in the #list response.
#
# Note: the +\HasNoChildren+ attribute should not be confused with the
# +\NoInferiors+ attribute, which indicates that no child mailboxes exist
# now and none can be created in the future.
#
# source://net-imap//lib/net/imap/flags.rb#149
Net::IMAP::HAS_NO_CHILDREN = T.let(T.unsafe(nil), Symbol)

# Net::IMAP::IgnoredResponse represents intentionally ignored responses.
#
# This includes untagged response "NOOP" sent by e.g. Zimbra to avoid
# some clients to close the connection.
#
# It matches no IMAP standard.
#
# source://net-imap//lib/net/imap/response_data.rb#70
class Net::IMAP::IgnoredResponse < ::Net::IMAP::UntaggedResponse; end

# Error raised when the server sends an invalid response.
#
# This is different from UnknownResponseError: the response has been
# rejected.  Although it may be parsable, the server is forbidden from
# sending it in the current context.  The client should automatically
# disconnect, abruptly (without logout).
#
# Note that InvalidResponseError does not inherit from ResponseError: it
# can be raised before the response is fully parsed.  A related
# ResponseParseError or ResponseError may be the #cause.
#
# source://net-imap//lib/net/imap/errors.rb#99
class Net::IMAP::InvalidResponseError < ::Net::IMAP::Error; end

# Mailbox attribute indicating that this mailbox is where messages deemed to
# be junk mail are held. Some server implementations might put messages here
# automatically.  Alternatively, this might just be advice to a client-side
# spam filter.
#
# source://net-imap//lib/net/imap/flags.rb#242
Net::IMAP::JUNK = T.let(T.unsafe(nil), Symbol)

# source://net-imap//lib/net/imap/command_data.rb#150
class Net::IMAP::Literal < ::Net::IMAP::CommandData
  # source://net-imap//lib/net/imap/command_data.rb#151
  def send_data(imap, tag); end
end

# source://net-imap//lib/net/imap/errors.rb#10
class Net::IMAP::LoginDisabledError < ::Net::IMAP::Error
  # @return [LoginDisabledError] a new instance of LoginDisabledError
  #
  # source://net-imap//lib/net/imap/errors.rb#11
  def initialize(msg = T.unsafe(nil), *_arg1, **_arg2, &_arg3); end
end

# source://net-imap//lib/net/imap/command_data.rb#189
class Net::IMAP::MessageSet < ::Net::IMAP::CommandData
  # source://net-imap//lib/net/imap/command_data.rb#200
  def initialize(data:); end

  # source://net-imap//lib/net/imap/command_data.rb#190
  def send_data(imap, tag); end

  # source://net-imap//lib/net/imap/command_data.rb#194
  def validate; end

  private

  # source://net-imap//lib/net/imap/command_data.rb#214
  def format_internal(data); end

  # source://net-imap//lib/net/imap/command_data.rb#235
  def validate_internal(data); end
end

# The +\NonExistent+ attribute indicates that a mailbox name does not refer
# to an existing mailbox. Note that this attribute is not meaningful by
# itself, as mailbox names that match the canonical #list pattern but don't
# exist must not be returned unless one of the two conditions listed below
# is also satisfied:
#
# 1. The mailbox name also satisfies the selection criteria (for example,
#    it is subscribed and the "SUBSCRIBED" selection option has been
#    specified).
#
# 2. "RECURSIVEMATCH" has been specified, and the mailbox name has at least
#    one descendant mailbox name that does not match the #list pattern and
#    does match the selection criteria.
#
# In practice, this means that the +\NonExistent+ attribute is usually
# returned with one or more of +\Subscribed+, +\Remote+, +\HasChildren+, or
# the CHILDINFO extended data item.
#
# The client must treat the presence of the +\NonExistent+ attribute as if the
# +\NoSelect+ attribute was also sent by the server
#
# source://net-imap//lib/net/imap/flags.rb#105
Net::IMAP::NONEXISTENT = T.let(T.unsafe(nil), Symbol)

# Mailbox attribute indicating it is not possible for any child levels of
# hierarchy to exist under this name; no child levels exist now and none can
# be created in the future children.
#
# The client must treat the presence of the +\NoInferiors+ attribute as if the
# +\HasNoChildren+ attribute was also sent by the server
#
# source://net-imap//lib/net/imap/flags.rb#113
Net::IMAP::NO_INFERIORS = T.let(T.unsafe(nil), Symbol)

# Mailbox attribute indicating it is not possible to use this name as a
# selectable mailbox.
#
# source://net-imap//lib/net/imap/flags.rb#117
Net::IMAP::NO_SELECT = T.let(T.unsafe(nil), Symbol)

# Namespace represents a _single_ namespace, contained inside a Namespaces
# object.
#
# == Required capability
# Requires either +NAMESPACE+ [RFC2342[https://www.rfc-editor.org/rfc/rfc2342]]
# or +IMAP4rev2+ capability.
#
# source://net-imap//lib/net/imap/response_data.rb#466
class Net::IMAP::Namespace < ::Struct; end

# Namespaces represents the data of an untagged +NAMESPACE+ response,
# returned by IMAP#namespace.
#
# Contains lists of #personal, #shared, and #other namespaces.
#
# == Required capability
# Requires either +NAMESPACE+ [RFC2342[https://www.rfc-editor.org/rfc/rfc2342]]
# or +IMAP4rev2+ capability.
#
# source://net-imap//lib/net/imap/response_data.rb#495
class Net::IMAP::Namespaces < ::Struct; end

# Common validators of number and nz_number types
#
# source://net-imap//lib/net/imap/data_encoding.rb#157
module Net::IMAP::NumValidator
  private

  # Ensure argument is 'mod_sequence_value' or raise DataFormatError
  #
  # source://net-imap//lib/net/imap/data_encoding.rb#204
  def ensure_mod_sequence_value(num); end

  # Ensure argument is 'number' or raise DataFormatError
  #
  # source://net-imap//lib/net/imap/data_encoding.rb#188
  def ensure_number(num); end

  # Ensure argument is 'nz_number' or raise DataFormatError
  #
  # source://net-imap//lib/net/imap/data_encoding.rb#196
  def ensure_nz_number(num); end

  # Check is passed argument valid 'mod_sequence_value' in RFC 4551 terminology
  #
  # source://net-imap//lib/net/imap/data_encoding.rb#179
  def valid_mod_sequence_value?(num); end

  # Check is passed argument valid 'number' in RFC 3501 terminology
  #
  # source://net-imap//lib/net/imap/data_encoding.rb#161
  def valid_number?(num); end

  # Check is passed argument valid 'nz_number' in RFC 3501 terminology
  #
  # source://net-imap//lib/net/imap/data_encoding.rb#170
  def valid_nz_number?(num); end

  class << self
    # Ensure argument is 'mod_sequence_value' or raise DataFormatError
    #
    # @raise [DataFormatError]
    #
    # source://net-imap//lib/net/imap/data_encoding.rb#204
    def ensure_mod_sequence_value(num); end

    # Ensure argument is 'number' or raise DataFormatError
    #
    # @raise [DataFormatError]
    #
    # source://net-imap//lib/net/imap/data_encoding.rb#188
    def ensure_number(num); end

    # Ensure argument is 'nz_number' or raise DataFormatError
    #
    # @raise [DataFormatError]
    #
    # source://net-imap//lib/net/imap/data_encoding.rb#196
    def ensure_nz_number(num); end

    # Check is passed argument valid 'mod_sequence_value' in RFC 4551 terminology
    #
    # @return [Boolean]
    #
    # source://net-imap//lib/net/imap/data_encoding.rb#179
    def valid_mod_sequence_value?(num); end

    # Check is passed argument valid 'number' in RFC 3501 terminology
    #
    # @return [Boolean]
    #
    # source://net-imap//lib/net/imap/data_encoding.rb#161
    def valid_number?(num); end

    # Check is passed argument valid 'nz_number' in RFC 3501 terminology
    #
    # @return [Boolean]
    #
    # source://net-imap//lib/net/imap/data_encoding.rb#170
    def valid_nz_number?(num); end
  end
end

# source://net-imap//lib/net/imap/command_data.rb#156
class Net::IMAP::PartialRange < ::Net::IMAP::CommandData
  # source://net-imap//lib/net/imap/command_data.rb#163
  def initialize(data:); end

  # source://net-imap//lib/net/imap/command_data.rb#181
  def formatted; end

  # source://net-imap//lib/net/imap/command_data.rb#183
  def send_data(imap, tag); end
end

# source://net-imap//lib/net/imap/command_data.rb#159
Net::IMAP::PartialRange::NEG_RANGE = T.let(T.unsafe(nil), Range)

# source://net-imap//lib/net/imap/command_data.rb#161
Net::IMAP::PartialRange::Negative = T.let(T.unsafe(nil), Proc)

# source://net-imap//lib/net/imap/command_data.rb#158
Net::IMAP::PartialRange::POS_RANGE = T.let(T.unsafe(nil), Range)

# source://net-imap//lib/net/imap/command_data.rb#160
Net::IMAP::PartialRange::Positive = T.let(T.unsafe(nil), Proc)

# source://net-imap//lib/net/imap/command_data.rb#144
class Net::IMAP::QuotedString < ::Net::IMAP::CommandData
  # source://net-imap//lib/net/imap/command_data.rb#145
  def send_data(imap, tag); end
end

# The mailbox is a remote mailbox.
#
# source://net-imap//lib/net/imap/flags.rb#176
Net::IMAP::REMOTE = T.let(T.unsafe(nil), Symbol)

# source://net-imap//lib/net/imap.rb#3120
Net::IMAP::RESPONSES_DEPRECATION_MSG = T.let(T.unsafe(nil), String)

# source://net-imap//lib/net/imap/errors.rb#113
Net::IMAP::RESPONSE_ERRORS = T.let(T.unsafe(nil), Hash)

# source://net-imap//lib/net/imap.rb#3608
Net::IMAP::RETURN_START = T.let(T.unsafe(nil), Regexp)

# source://net-imap//lib/net/imap.rb#3607
Net::IMAP::RETURN_WHOLE = T.let(T.unsafe(nil), Regexp)

# source://net-imap//lib/net/imap/command_data.rb#132
class Net::IMAP::RawData < ::Net::IMAP::CommandData
  # source://net-imap//lib/net/imap/command_data.rb#133
  def send_data(imap, tag); end
end

# Superclass of all errors used to encapsulate "fail" responses
# from the server.
#
# source://net-imap//lib/net/imap/errors.rb#59
class Net::IMAP::ResponseError < ::Net::IMAP::Error
  # @return [ResponseError] a new instance of ResponseError
  #
  # source://net-imap//lib/net/imap/errors.rb#64
  def initialize(response); end

  # The response that caused this error
  #
  # source://net-imap//lib/net/imap/errors.rb#62
  def response; end

  # The response that caused this error
  #
  # source://net-imap//lib/net/imap/errors.rb#62
  def response=(_arg0); end
end

# Parses an \IMAP server response.
#
# source://net-imap//lib/net/imap/response_parser/parser_utils.rb#5
class Net::IMAP::ResponseParser
  include ::Net::IMAP::ResponseParser::ParserUtils
  include ::Net::IMAP::ResponseParser::ResponseConditions
  extend ::Net::IMAP::ResponseParser::ParserUtils::Generator

  # Creates a new ResponseParser.
  #
  # When +config+ is frozen or global, the parser #config inherits from it.
  # Otherwise, +config+ will be used directly.
  #
  # @return [ResponseParser] a new instance of ResponseParser
  #
  # source://net-imap//lib/net/imap/response_parser.rb#20
  def initialize(config: T.unsafe(nil)); end

  # source://net-imap//lib/net/imap/response_parser.rb#477
  def CRLF!; end

  # source://net-imap//lib/net/imap/response_parser.rb#477
  def CRLF?; end

  # source://net-imap//lib/net/imap/response_parser.rb#478
  def EOF!; end

  # source://net-imap//lib/net/imap/response_parser.rb#478
  def EOF?; end

  # source://net-imap//lib/net/imap/response_parser.rb#460
  def NIL!; end

  # source://net-imap//lib/net/imap/response_parser.rb#460
  def NIL?; end

  # source://net-imap//lib/net/imap/response_parser.rb#430
  def PLUS!; end

  # source://net-imap//lib/net/imap/response_parser.rb#430
  def PLUS?; end

  # source://net-imap//lib/net/imap/response_parser.rb#429
  def SP!; end

  # source://net-imap//lib/net/imap/response_parser.rb#429
  def SP?; end

  # source://net-imap//lib/net/imap/response_parser.rb#431
  def STAR!; end

  # source://net-imap//lib/net/imap/response_parser.rb#431
  def STAR?; end

  # RFC-3501 & RFC-9051:
  #   body-fld-enc    = (DQUOTE ("7BIT" / "8BIT" / "BINARY" / "BASE64"/
  #                     "QUOTED-PRINTABLE") DQUOTE) / string
  #
  # source://net-imap//lib/net/imap/response_parser.rb#1263
  def body_fld_enc; end

  # valid number ranges are not enforced by parser
  #   number64        = 1*DIGIT
  #                       ; Unsigned 63-bit integer
  #                       ; (0 <= n <= 9,223,372,036,854,775,807)
  # number in 3501, number64 in 9051
  #
  # source://net-imap//lib/net/imap/response_parser.rb#1256
  def body_fld_lines; end

  # source://net-imap//lib/net/imap/response_parser.rb#1258
  def body_fld_octets; end

  # source://net-imap//lib/net/imap/response_parser.rb#454
  def case_insensitive__string; end

  # source://net-imap//lib/net/imap/response_parser.rb#454
  def case_insensitive__string?; end

  # Returns the value of attribute config.
  #
  # source://net-imap//lib/net/imap/response_parser.rb#14
  def config; end

  # date-time       = DQUOTE date-day-fixed "-" date-month "-" date-year
  #                     SP time SP zone DQUOTE
  #
  # source://net-imap//lib/net/imap/response_parser.rb#1048
  def date_time; end

  # source://net-imap//lib/net/imap/response_parser.rb#436
  def lbra; end

  # source://net-imap//lib/net/imap/response_parser.rb#436
  def lbra?; end

  # source://net-imap//lib/net/imap/response_parser.rb#477
  def lookahead_CRLF!; end

  # source://net-imap//lib/net/imap/response_parser.rb#478
  def lookahead_EOF!; end

  # source://net-imap//lib/net/imap/response_parser.rb#460
  def lookahead_NIL!; end

  # source://net-imap//lib/net/imap/response_parser.rb#430
  def lookahead_PLUS?; end

  # source://net-imap//lib/net/imap/response_parser.rb#429
  def lookahead_SP?; end

  # source://net-imap//lib/net/imap/response_parser.rb#431
  def lookahead_STAR?; end

  # source://net-imap//lib/net/imap/response_parser.rb#1060
  def lookahead_body?; end

  # source://net-imap//lib/net/imap/response_parser.rb#454
  def lookahead_case_insensitive__string!; end

  # source://net-imap//lib/net/imap/response_parser.rb#436
  def lookahead_lbra?; end

  # source://net-imap//lib/net/imap/response_parser.rb#433
  def lookahead_lpar?; end

  # source://net-imap//lib/net/imap/response_parser.rb#443
  def lookahead_number!; end

  # source://net-imap//lib/net/imap/response_parser.rb#445
  def lookahead_quoted!; end

  # source://net-imap//lib/net/imap/response_parser.rb#437
  def lookahead_rbra?; end

  # source://net-imap//lib/net/imap/response_parser.rb#434
  def lookahead_rpar?; end

  # source://net-imap//lib/net/imap/response_parser.rb#448
  def lookahead_string!; end

  # source://net-imap//lib/net/imap/response_parser.rb#451
  def lookahead_string8!; end

  # source://net-imap//lib/net/imap/response_parser.rb#475
  def lookahead_tagged_ext_label!; end

  # source://net-imap//lib/net/imap/response_parser.rb#1628
  def lookahead_thread_list?; end

  # source://net-imap//lib/net/imap/response_parser.rb#1629
  def lookahead_thread_nested?; end

  # source://net-imap//lib/net/imap/response_parser.rb#433
  def lpar; end

  # source://net-imap//lib/net/imap/response_parser.rb#433
  def lpar?; end

  # text/*
  #
  # source://net-imap//lib/net/imap/response_parser.rb#1184
  def media_subtype; end

  # valid number ranges are not enforced by parser
  #   nz-number       = digit-nz *DIGIT
  #                       ; Non-zero unsigned 32-bit integer
  #                       ; (0 < n < 4,294,967,296)
  # valid number ranges are not enforced by parser
  #   nz-number64     = digit-nz *DIGIT
  #                       ; Unsigned 63-bit integer
  #                       ; (0 < n <= 9,223,372,036,854,775,807)
  # RFC7162:
  # mod-sequence-value  = 1*DIGIT
  #                        ;; Positive unsigned 63-bit integer
  #                        ;; (mod-sequence)
  #                        ;; (1 <= n <= 9,223,372,036,854,775,807).
  #
  # source://net-imap//lib/net/imap/response_parser.rb#2130
  def mod_sequence_value; end

  # valid number ranges are not enforced by parser
  #   number64        = 1*DIGIT
  #                       ; Unsigned 63-bit integer
  #                       ; (0 <= n <= 9,223,372,036,854,775,807)
  # RFC7162:
  # mod-sequence-valzer = "0" / mod-sequence-value
  #
  # source://net-imap//lib/net/imap/response_parser.rb#2139
  def mod_sequence_valzer; end

  # source://net-imap//lib/net/imap/response_parser.rb#443
  def number; end

  # valid number ranges are not enforced by parser
  #   number64        = 1*DIGIT
  #                       ; Unsigned 63-bit integer
  #                       ; (0 <= n <= 9,223,372,036,854,775,807)
  #
  # source://net-imap//lib/net/imap/response_parser.rb#643
  def number64; end

  # source://net-imap//lib/net/imap/response_parser.rb#644
  def number64?; end

  # source://net-imap//lib/net/imap/response_parser.rb#443
  def number?; end

  # valid number ranges are not enforced by parser
  #   nz-number       = digit-nz *DIGIT
  #                       ; Non-zero unsigned 32-bit integer
  #                       ; (0 < n < 4,294,967,296)
  #
  # source://net-imap//lib/net/imap/response_parser.rb#650
  def nz_number; end

  # valid number ranges are not enforced by parser
  #   nz-number       = digit-nz *DIGIT
  #                       ; Non-zero unsigned 32-bit integer
  #                       ; (0 < n < 4,294,967,296)
  # valid number ranges are not enforced by parser
  #   nz-number64     = digit-nz *DIGIT
  #                       ; Unsigned 63-bit integer
  #                       ; (0 < n <= 9,223,372,036,854,775,807)
  #
  # source://net-imap//lib/net/imap/response_parser.rb#657
  def nz_number64; end

  # source://net-imap//lib/net/imap/response_parser.rb#651
  def nz_number?; end

  # :call-seq:
  #   parse(str) -> ContinuationRequest
  #   parse(str) -> UntaggedResponse
  #   parse(str) -> TaggedResponse
  #
  # Raises ResponseParseError for unparsable strings.
  #
  # source://net-imap//lib/net/imap/response_parser.rb#35
  def parse(str); end

  # source://net-imap//lib/net/imap/response_parser.rb#430
  def peek_PLUS?; end

  # source://net-imap//lib/net/imap/response_parser.rb#429
  def peek_SP?; end

  # source://net-imap//lib/net/imap/response_parser.rb#431
  def peek_STAR?; end

  # source://net-imap//lib/net/imap/response_parser.rb#436
  def peek_lbra?; end

  # source://net-imap//lib/net/imap/response_parser.rb#433
  def peek_lpar?; end

  # source://net-imap//lib/net/imap/response_parser.rb#437
  def peek_rbra?; end

  # source://net-imap//lib/net/imap/response_parser.rb#434
  def peek_rpar?; end

  # valid number ranges are not enforced by parser
  #   nz-number       = digit-nz *DIGIT
  #                       ; Non-zero unsigned 32-bit integer
  #                       ; (0 < n < 4,294,967,296)
  # valid number ranges are not enforced by parser
  #   nz-number64     = digit-nz *DIGIT
  #                       ; Unsigned 63-bit integer
  #                       ; (0 < n <= 9,223,372,036,854,775,807)
  # RFC7162:
  # mod-sequence-value  = 1*DIGIT
  #                        ;; Positive unsigned 63-bit integer
  #                        ;; (mod-sequence)
  #                        ;; (1 <= n <= 9,223,372,036,854,775,807).
  # RFC7162:
  # permsg-modsequence  = mod-sequence-value
  #                        ;; Per-message mod-sequence.
  #
  # source://net-imap//lib/net/imap/response_parser.rb#2135
  def permsg_modsequence; end

  # Used when servers erroneously send an extra SP.
  #
  # As of 2023-11-28, Outlook.com (still) sends SP
  #   between +address+ in <tt>env-*</tt> lists.
  #
  # source://net-imap//lib/net/imap/response_parser.rb#1044
  def quirky_SP?; end

  # source://net-imap//lib/net/imap/response_parser.rb#445
  def quoted; end

  # source://net-imap//lib/net/imap/response_parser.rb#445
  def quoted?; end

  # source://net-imap//lib/net/imap/response_parser.rb#437
  def rbra; end

  # source://net-imap//lib/net/imap/response_parser.rb#437
  def rbra?; end

  # source://net-imap//lib/net/imap/response_parser.rb#434
  def rpar; end

  # source://net-imap//lib/net/imap/response_parser.rb#434
  def rpar?; end

  # search-modifier-name = tagged-ext-label
  #
  # source://net-imap//lib/net/imap/response_parser.rb#1597
  def search_modifier_name; end

  # source://net-imap//lib/net/imap/response_parser.rb#448
  def string; end

  # source://net-imap//lib/net/imap/response_parser.rb#451
  def string8; end

  # source://net-imap//lib/net/imap/response_parser.rb#451
  def string8?; end

  # source://net-imap//lib/net/imap/response_parser.rb#448
  def string?; end

  # source://net-imap//lib/net/imap/response_parser.rb#475
  def tagged_ext_label; end

  # source://net-imap//lib/net/imap/response_parser.rb#475
  def tagged_ext_label?; end

  # valid number ranges are not enforced by parser
  #   nz-number       = digit-nz *DIGIT
  #                       ; Non-zero unsigned 32-bit integer
  #                       ; (0 < n < 4,294,967,296)
  # valid number ranges are not enforced by parser
  #      uniqueid        = nz-number
  #                          ; Strictly ascending
  #
  # source://net-imap//lib/net/imap/response_parser.rb#662
  def uniqueid; end

  # valid number ranges are not enforced by parser
  #
  # a 64-bit unsigned integer and is the decimal equivalent for the ID hex
  # string used in the web interface and the Gmail API.
  #
  # source://net-imap//lib/net/imap/response_parser.rb#668
  def x_gm_id; end

  private

  # source://net-imap//lib/net/imap/response_parser.rb#2020
  def AppendUID(*_arg0, **_arg1, &_arg2); end

  # source://net-imap//lib/net/imap/response_parser.rb#2021
  def CopyUID(*_arg0, **_arg1, &_arg2); end

  # TODO: remove this code in the v0.6.0 release
  #
  # source://net-imap//lib/net/imap/response_parser.rb#2024
  def DeprecatedUIDPlus(validity, src_uids = T.unsafe(nil), dst_uids); end

  # The RFC is very strict about this and usually we should be too.
  # But skipping spaces is usually a safe workaround for buggy servers.
  #
  # This advances @pos directly so it's safe before changing @lex_state.
  #
  # source://net-imap//lib/net/imap/response_parser.rb#2177
  def accept_spaces; end

  # acl-data        = "ACL" SP mailbox *(SP identifier SP rights)
  #
  # source://net-imap//lib/net/imap/response_parser.rb#1458
  def acl_data; end

  # nstring         = string / nil
  #
  # source://net-imap//lib/net/imap/response_parser.rb#2067
  def addr_adl; end

  # nstring         = string / nil
  #
  # source://net-imap//lib/net/imap/response_parser.rb#2068
  def addr_host; end

  # nstring         = string / nil
  #
  # source://net-imap//lib/net/imap/response_parser.rb#2069
  def addr_mailbox; end

  # nstring         = string / nil
  #
  # source://net-imap//lib/net/imap/response_parser.rb#2070
  def addr_name; end

  # address         = "(" addr-name SP addr-adl SP addr-mailbox SP
  #                     addr-host ")"
  #   addr-adl        = nstring
  #   addr-host       = nstring
  #   addr-mailbox    = nstring
  #   addr-name       = nstring
  #
  # source://net-imap//lib/net/imap/response_parser.rb#2052
  def address; end

  # astring         = 1*ASTRING-CHAR / string
  #
  # source://net-imap//lib/net/imap/response_parser.rb#528
  def astring; end

  # @return [Boolean]
  #
  # source://net-imap//lib/net/imap/response_parser.rb#532
  def astring?; end

  # source://net-imap//lib/net/imap/response_parser.rb#513
  def astring_chars; end

  # TODO: handle atom, astring_chars, and tag entirely inside the lexer
  #
  # source://net-imap//lib/net/imap/response_parser.rb#512
  def atom; end

  # the #accept version of #atom
  #
  # @return [Boolean]
  #
  # source://net-imap//lib/net/imap/response_parser.rb#517
  def atom?; end

  # RFC-3501 & RFC-9051:
  #   body            = "(" (body-type-1part / body-type-mpart) ")"
  #
  # source://net-imap//lib/net/imap/response_parser.rb#1053
  def body; end

  # RFC2060
  #   body_ext_1part  ::= body_fld_md5 [SPACE body_fld_dsp
  #                       [SPACE body_fld_lang
  #                       [SPACE 1#body_extension]]]
  #                       ;; MUST NOT be returned on non-extensible
  #                       ;; "BODY" fetch
  # RFC3501 & RFC9051
  #   body-ext-1part  = body-fld-md5 [SP body-fld-dsp [SP body-fld-lang
  #                     [SP body-fld-loc *(SP body-extension)]]]
  #                       ; MUST NOT be returned on non-extensible
  #                       ; "BODY" fetch
  #
  # source://net-imap//lib/net/imap/response_parser.rb#1225
  def body_ext_1part; end

  # RFC-2060:
  #   body_ext_mpart  = body_fld_param [SP body_fld_dsp SP body_fld_lang
  #                     [SP 1#body_extension]]
  #                       ;; MUST NOT be returned on non-extensible
  #                       ;; "BODY" fetch
  # RFC-3501 & RFC-9051:
  #   body-ext-mpart  = body-fld-param [SP body-fld-dsp [SP body-fld-lang
  #                     [SP body-fld-loc *(SP body-extension)]]]
  #                       ; MUST NOT be returned on non-extensible
  #                       ; "BODY" fetch
  #
  # source://net-imap//lib/net/imap/response_parser.rb#1244
  def body_ext_mpart; end

  # body-extension  = nstring / number / number64 /
  #                      "(" body-extension *(SP body-extension) ")"
  #                       ; Future expansion.  Client implementations
  #                       ; MUST accept body-extension fields.  Server
  #                       ; implementations MUST NOT generate
  #                       ; body-extension fields except as defined by
  #                       ; future Standard or Standards Track
  #                       ; revisions of this specification.
  #
  # source://net-imap//lib/net/imap/response_parser.rb#1301
  def body_extension; end

  # body-extension *(SP body-extension)
  #
  # source://net-imap//lib/net/imap/response_parser.rb#1287
  def body_extensions; end

  # RFC-3501 & RFC-9051:
  #   body-fields     = body-fld-param SP body-fld-id SP body-fld-desc SP
  #                     body-fld-enc SP body-fld-octets
  #
  # source://net-imap//lib/net/imap/response_parser.rb#1189
  def body_fields; end

  # nstring         = string / nil
  #
  # source://net-imap//lib/net/imap/response_parser.rb#1253
  def body_fld_desc; end

  # body-fld-dsp    = "(" string SP body-fld-param ")" / nil
  #
  # source://net-imap//lib/net/imap/response_parser.rb#1266
  def body_fld_dsp; end

  # nstring         = string / nil
  #
  # source://net-imap//lib/net/imap/response_parser.rb#1254
  def body_fld_id; end

  # body-fld-lang   = nstring / "(" string *(SP string) ")"
  #
  # source://net-imap//lib/net/imap/response_parser.rb#1275
  def body_fld_lang; end

  # nstring         = string / nil
  #
  # source://net-imap//lib/net/imap/response_parser.rb#1255
  def body_fld_loc; end

  # nstring         = string / nil
  #
  # source://net-imap//lib/net/imap/response_parser.rb#1257
  def body_fld_md5; end

  # RFC3501, RFC9051:
  # body-fld-param  = "(" string SP string *(SP string SP string) ")" / nil
  #
  # source://net-imap//lib/net/imap/response_parser.rb#1201
  def body_fld_param; end

  # RFC-3501 & RFC9051:
  #   body-type-1part = (body-type-basic / body-type-msg / body-type-text)
  #                     [SP body-ext-1part]
  #
  # source://net-imap//lib/net/imap/response_parser.rb#1065
  def body_type_1part; end

  # RFC-3501 & RFC9051:
  #   body-type-basic = media-basic SP body-fields
  #
  # source://net-imap//lib/net/imap/response_parser.rb#1089
  def body_type_basic; end

  # This is a malformed body-type-mpart with no subparts.
  #
  # source://net-imap//lib/net/imap/response_parser.rb#1138
  def body_type_mixed; end

  # RFC-3501 & RFC-9051:
  #   body-type-mpart = 1*body SP media-subtype
  #                     [SP body-ext-mpart]
  #
  # source://net-imap//lib/net/imap/response_parser.rb#1148
  def body_type_mpart; end

  # RFC-3501 & RFC-9051:
  #   body-type-msg   = media-message SP body-fields SP envelope
  #                     SP body SP body-fld-lines
  #
  # source://net-imap//lib/net/imap/response_parser.rb#1110
  def body_type_msg; end

  # RFC-3501 & RFC-9051:
  #   body-type-text  = media-text SP body-fields SP body-fld-lines
  #
  # source://net-imap//lib/net/imap/response_parser.rb#1099
  def body_type_text; end

  # Returns <tt>atom.upcase</tt>
  # capability      = ("AUTH=" auth-type) / atom
  #                     ; New capabilities MUST begin with "X" or be
  #                     ; registered with IANA as standard or
  #                     ; standards-track
  #
  # source://net-imap//lib/net/imap/response_parser.rb#1776
  def capability; end

  # Returns <tt>atom?&.upcase</tt>
  #
  # @return [Boolean]
  #
  # source://net-imap//lib/net/imap/response_parser.rb#1777
  def capability?; end

  # As a workaround for buggy servers, allow a trailing SP:
  #     *(SP capability) [SP]
  #
  # source://net-imap//lib/net/imap/response_parser.rb#1766
  def capability__list; end

  # The presence of "IMAP4rev1" or "IMAP4rev2" is unenforced here.
  # The grammar rule is used by both response-data and resp-text-code.
  # But this method only returns UntaggedResponse (response-data).
  #
  # RFC3501:
  #   capability-data  = "CAPABILITY" *(SP capability) SP "IMAP4rev1"
  #                      *(SP capability)
  # RFC9051:
  #   capability-data  = "CAPABILITY" *(SP capability) SP "IMAP4rev2"
  #                      *(SP capability)
  #
  # source://net-imap//lib/net/imap/response_parser.rb#1755
  def capability_data__untagged; end

  # Returns <tt>atom.upcase</tt>
  #
  # source://net-imap//lib/net/imap/response_parser.rb#520
  def case_insensitive__atom; end

  # Returns <tt>atom?&.upcase</tt>
  #
  # @return [Boolean]
  #
  # source://net-imap//lib/net/imap/response_parser.rb#523
  def case_insensitive__atom?; end

  # use where nstring represents "LABEL" values
  #
  # source://net-imap//lib/net/imap/response_parser.rb#581
  def case_insensitive__nstring; end

  # See https://www.rfc-editor.org/errata/rfc3501
  #
  # charset = atom / quoted
  #
  # source://net-imap//lib/net/imap/response_parser.rb#2123
  def charset; end

  # "(" charset *(SP charset) ")"
  #
  # source://net-imap//lib/net/imap/response_parser.rb#1989
  def charset__list; end

  # source://net-imap//lib/net/imap/response_parser.rb#798
  def comparator_data(klass = T.unsafe(nil)); end

  # RFC3501 & RFC9051:
  #   continue-req    = "+" SP (resp-text / base64) CRLF
  #
  # n.b: base64 is valid resp-text.  And in the spirit of RFC9051 Appx E 23
  # (and to workaround existing servers), we use the following grammar:
  #
  #   continue-req    = "+" (SP (resp-text)) CRLF
  #
  # source://net-imap//lib/net/imap/response_parser.rb#698
  def continue_req; end

  # enable-data   = "ENABLED" *(SP capability)
  #
  # source://net-imap//lib/net/imap/response_parser.rb#1760
  def enable_data; end

  # env-from        = "(" 1*address ")" / nil
  #   env-sender      = "(" 1*address ")" / nil
  #   env-reply-to    = "(" 1*address ")" / nil
  #   env-to          = "(" 1*address ")" / nil
  #   env-cc          = "(" 1*address ")" / nil
  #   env-bcc         = "(" 1*address ")" / nil
  #
  # source://net-imap//lib/net/imap/response_parser.rb#1038
  def env_bcc; end

  # env-from        = "(" 1*address ")" / nil
  #   env-sender      = "(" 1*address ")" / nil
  #   env-reply-to    = "(" 1*address ")" / nil
  #   env-to          = "(" 1*address ")" / nil
  #   env-cc          = "(" 1*address ")" / nil
  #   env-bcc         = "(" 1*address ")" / nil
  #
  # source://net-imap//lib/net/imap/response_parser.rb#1037
  def env_cc; end

  # nstring         = string / nil
  #   env-date        = nstring
  #   env-subject     = nstring
  #   env-in-reply-to = nstring
  #   env-message-id  = nstring
  #
  # source://net-imap//lib/net/imap/response_parser.rb#1016
  def env_date; end

  # env-from        = "(" 1*address ")" / nil
  #   env-sender      = "(" 1*address ")" / nil
  #   env-reply-to    = "(" 1*address ")" / nil
  #   env-to          = "(" 1*address ")" / nil
  #   env-cc          = "(" 1*address ")" / nil
  #   env-bcc         = "(" 1*address ")" / nil
  #
  # source://net-imap//lib/net/imap/response_parser.rb#1033
  def env_from; end

  # nstring         = string / nil
  #
  # source://net-imap//lib/net/imap/response_parser.rb#1018
  def env_in_reply_to; end

  # nstring         = string / nil
  #
  # source://net-imap//lib/net/imap/response_parser.rb#1019
  def env_message_id; end

  # env-from        = "(" 1*address ")" / nil
  #   env-sender      = "(" 1*address ")" / nil
  #   env-reply-to    = "(" 1*address ")" / nil
  #   env-to          = "(" 1*address ")" / nil
  #   env-cc          = "(" 1*address ")" / nil
  #   env-bcc         = "(" 1*address ")" / nil
  #
  # source://net-imap//lib/net/imap/response_parser.rb#1035
  def env_reply_to; end

  # env-from        = "(" 1*address ")" / nil
  #   env-sender      = "(" 1*address ")" / nil
  #   env-reply-to    = "(" 1*address ")" / nil
  #   env-to          = "(" 1*address ")" / nil
  #   env-cc          = "(" 1*address ")" / nil
  #   env-bcc         = "(" 1*address ")" / nil
  #
  # source://net-imap//lib/net/imap/response_parser.rb#1034
  def env_sender; end

  # nstring         = string / nil
  #
  # source://net-imap//lib/net/imap/response_parser.rb#1017
  def env_subject; end

  # env-from        = "(" 1*address ")" / nil
  #   env-sender      = "(" 1*address ")" / nil
  #   env-reply-to    = "(" 1*address ")" / nil
  #   env-to          = "(" 1*address ")" / nil
  #   env-cc          = "(" 1*address ")" / nil
  #   env-bcc         = "(" 1*address ")" / nil
  #
  # source://net-imap//lib/net/imap/response_parser.rb#1036
  def env_to; end

  # RFC3501 & RFC9051:
  #   envelope        = "(" env-date SP env-subject SP env-from SP
  #                     env-sender SP env-reply-to SP env-to SP env-cc SP
  #                     env-bcc SP env-in-reply-to SP env-message-id ")"
  #
  # source://net-imap//lib/net/imap/response_parser.rb#993
  def envelope; end

  # esearch-response  = "ESEARCH" [search-correlator] [SP "UID"]
  #                      *(SP search-return-data)
  #                    ;; Note that SEARCH and ESEARCH responses
  #                    ;; SHOULD be mutually exclusive,
  #                    ;; i.e., only one of the response types
  #                    ;; should be
  #                    ;; returned as a result of a command.
  # esearch-response  = "ESEARCH" [search-correlator] [SP "UID"]
  #                     *(SP search-return-data)
  #                   ; ESEARCH response replaces SEARCH response
  #                   ; from IMAP4rev1.
  # search-correlator  = SP "(" "TAG" SP tag-string ")"
  #
  # source://net-imap//lib/net/imap/response_parser.rb#1524
  def esearch_response; end

  # The name for this is confusing, because it *replaces* EXPUNGE
  # >>>
  #   expunged-resp       =  "VANISHED" [SP "(EARLIER)"] SP known-uids
  #
  # source://net-imap//lib/net/imap/response_parser.rb#875
  def expunged_resp; end

  # flag-list       = "(" [flag *(SP flag)] ")"
  #
  # source://net-imap//lib/net/imap/response_parser.rb#2073
  def flag_list; end

  # "(" [flag-perm *(SP flag-perm)] ")"
  #
  # source://net-imap//lib/net/imap/response_parser.rb#2083
  def flag_perm__list; end

  # TODO: handle atom, astring_chars, and tag entirely inside the lexer
  # this represents the partial size for BODY or BINARY
  #
  # source://net-imap//lib/net/imap/response_parser.rb#987
  def gt__number__lt; end

  # astring         = 1*ASTRING-CHAR / string
  # RFC3501 & RFC9051:
  #   header-fld-name = astring
  #
  # NOTE: Previously, Net::IMAP recreated the raw original source string.
  # Now, it returns the decoded astring value.  Although this is technically
  # incompatible, it should almost never make a difference: all standard
  # header field names are valid atoms:
  #
  # https://www.iana.org/assignments/message-headers/message-headers.xhtml
  #
  # See also RFC5233:
  #     optional-field  =   field-name ":" unstructured CRLF
  #     field-name      =   1*ftext
  #     ftext           =   %d33-57 /          ; Printable US-ASCII
  #                         %d59-126           ;  characters not including
  #                                            ;  ":".
  #
  # source://net-imap//lib/net/imap/response_parser.rb#1373
  def header_fld_name; end

  # header-list     = "(" header-fld-name *(SP header-fld-name) ")"
  #
  # source://net-imap//lib/net/imap/response_parser.rb#1345
  def header_list; end

  # source://net-imap//lib/net/imap/response_parser.rb#1779
  def id_response; end

  # sequence-set    = (seq-number / seq-range) ["," sequence-set]
  #   sequence-set    =/ seq-last-command
  #                       ; Allow for "result of the last command"
  #                       ; indicator.
  #   seq-last-command   = "$"
  #
  # *note*: doesn't match seq-last-command
  # TODO: replace with uid_set
  #
  # source://net-imap//lib/net/imap/response_parser.rb#884
  def known_uids; end

  # Use #label or #label_in to assert specific known labels
  # (+tagged-ext-label+ only, not +atom+).
  #
  # source://net-imap//lib/net/imap/response_parser.rb#538
  def label(word); end

  # Use #label or #label_in to assert specific known labels
  # (+tagged-ext-label+ only, not +atom+).
  #
  # source://net-imap//lib/net/imap/response_parser.rb#545
  def label_in(*labels); end

  # source://net-imap//lib/net/imap/response_parser.rb#797
  def language_data(klass = T.unsafe(nil)); end

  # source://net-imap//lib/net/imap/response_parser.rb#794
  def listrights_data(klass = T.unsafe(nil)); end

  # astring         = 1*ASTRING-CHAR / string
  # mailbox         = "INBOX" / astring
  #                     ; INBOX is case-insensitive.  All case variants of
  #                     ; INBOX (e.g., "iNbOx") MUST be interpreted as INBOX
  #                     ; not as an astring.  An astring which consists of
  #                     ; the case-insensitive sequence "I" "N" "B" "O" "X"
  #                     ; is considered to be INBOX and not an astring.
  #                     ;  Refer to section 5.1 for further
  #                     ; semantic details of mailbox names.
  #
  # source://net-imap//lib/net/imap/response_parser.rb#637
  def mailbox; end

  # source://net-imap//lib/net/imap/response_parser.rb#869
  def mailbox_data__exists; end

  # mailbox-data    =  "FLAGS" SP flag-list / "LIST" SP mailbox-list /
  #                    "LSUB" SP mailbox-list / "SEARCH" *(SP nz-number) /
  #                    "STATUS" SP mailbox SP "(" [status-att-list] ")" /
  #                    number SP "EXISTS" / number SP "RECENT"
  #
  # source://net-imap//lib/net/imap/response_parser.rb#1380
  def mailbox_data__flags; end

  # source://net-imap//lib/net/imap/response_parser.rb#1386
  def mailbox_data__list; end

  # source://net-imap//lib/net/imap/response_parser.rb#1391
  def mailbox_data__lsub; end

  # source://net-imap//lib/net/imap/response_parser.rb#870
  def mailbox_data__recent; end

  # RFC3501:
  #   mailbox-data        = "SEARCH" *(SP nz-number) / ...
  # RFC5256: SORT
  #   sort-data           = "SORT" *(SP nz-number)
  # RFC7162: CONDSTORE, QRESYNC
  #   mailbox-data        =/ "SEARCH" [1*(SP nz-number) SP
  #                          search-sort-mod-seq]
  #   sort-data           = "SORT" [1*(SP nz-number) SP
  #                           search-sort-mod-seq]
  #                           ; Updates the SORT response from RFC 5256.
  #   search-sort-mod-seq = "(" "MODSEQ" SP mod-sequence-value ")"
  # RFC9051:
  #   mailbox-data        = obsolete-search-response / ...
  #   obsolete-search-response = "SEARCH" *(SP nz-number)
  #
  # source://net-imap//lib/net/imap/response_parser.rb#1498
  def mailbox_data__search; end

  # mailbox-data    =/ "STATUS" SP mailbox SP "(" [status-att-list] ")"
  #
  # source://net-imap//lib/net/imap/response_parser.rb#1669
  def mailbox_data__status; end

  # source://net-imap//lib/net/imap/response_parser.rb#1392
  def mailbox_data__xlist; end

  # mailbox-list    = "(" [mbx-list-flags] ")" SP
  #                    (DQUOTE QUOTED-CHAR DQUOTE / nil) SP mailbox
  #                    [SP mbox-list-extended]
  #             ; This is the list information pointed to by the ABNF
  #             ; item "mailbox-data", which is defined above
  #
  # source://net-imap//lib/net/imap/response_parser.rb#1399
  def mailbox_list; end

  # See Patterns::MBX_LIST_FLAGS
  #
  # source://net-imap//lib/net/imap/response_parser.rb#2101
  def mbx_list_flags; end

  # n.b. this handles both type and subtype
  #
  # RFC-3501 vs RFC-9051:
  #   media-basic     = ((DQUOTE ("APPLICATION" / "AUDIO" / "IMAGE" /
  #                     "MESSAGE" /
  #                     "VIDEO") DQUOTE) / string) SP media-subtype
  #   media-basic     = ((DQUOTE ("APPLICATION" / "AUDIO" / "IMAGE" /
  #                     "FONT" / "MESSAGE" / "MODEL" /
  #                     "VIDEO") DQUOTE) / string) SP media-subtype
  #
  #   media-message   = DQUOTE "MESSAGE" DQUOTE SP
  #                     DQUOTE "RFC822" DQUOTE
  #   media-message   = DQUOTE "MESSAGE" DQUOTE SP
  #                     DQUOTE ("RFC822" / "GLOBAL") DQUOTE
  #
  # RFC-3501 & RFC-9051:
  #   media-text      = DQUOTE "TEXT" DQUOTE SP media-subtype
  #   media-subtype   = string
  # TODO: check types
  #
  # source://net-imap//lib/net/imap/response_parser.rb#1180
  def media_basic; end

  # n.b. this handles both type and subtype
  #
  # RFC-3501 vs RFC-9051:
  #   media-basic     = ((DQUOTE ("APPLICATION" / "AUDIO" / "IMAGE" /
  #                     "MESSAGE" /
  #                     "VIDEO") DQUOTE) / string) SP media-subtype
  #   media-basic     = ((DQUOTE ("APPLICATION" / "AUDIO" / "IMAGE" /
  #                     "FONT" / "MESSAGE" / "MODEL" /
  #                     "VIDEO") DQUOTE) / string) SP media-subtype
  #
  #   media-message   = DQUOTE "MESSAGE" DQUOTE SP
  #                     DQUOTE "RFC822" DQUOTE
  #   media-message   = DQUOTE "MESSAGE" DQUOTE SP
  #                     DQUOTE ("RFC822" / "GLOBAL") DQUOTE
  #
  # RFC-3501 & RFC-9051:
  #   media-text      = DQUOTE "TEXT" DQUOTE SP media-subtype
  #   media-subtype   = string
  # */* --- catchall
  #
  # source://net-imap//lib/net/imap/response_parser.rb#1181
  def media_message; end

  # n.b. this handles both type and subtype
  #
  # RFC-3501 vs RFC-9051:
  #   media-basic     = ((DQUOTE ("APPLICATION" / "AUDIO" / "IMAGE" /
  #                     "MESSAGE" /
  #                     "VIDEO") DQUOTE) / string) SP media-subtype
  #   media-basic     = ((DQUOTE ("APPLICATION" / "AUDIO" / "IMAGE" /
  #                     "FONT" / "MESSAGE" / "MODEL" /
  #                     "VIDEO") DQUOTE) / string) SP media-subtype
  #
  #   media-message   = DQUOTE "MESSAGE" DQUOTE SP
  #                     DQUOTE "RFC822" DQUOTE
  #   media-message   = DQUOTE "MESSAGE" DQUOTE SP
  #                     DQUOTE ("RFC822" / "GLOBAL") DQUOTE
  #
  # RFC-3501 & RFC-9051:
  #   media-text      = DQUOTE "TEXT" DQUOTE SP media-subtype
  #   media-subtype   = string
  # message/rfc822, message/global
  #
  # source://net-imap//lib/net/imap/response_parser.rb#1182
  def media_text; end

  # n.b. this handles both type and subtype
  #
  # RFC-3501 vs RFC-9051:
  #   media-basic     = ((DQUOTE ("APPLICATION" / "AUDIO" / "IMAGE" /
  #                     "MESSAGE" /
  #                     "VIDEO") DQUOTE) / string) SP media-subtype
  #   media-basic     = ((DQUOTE ("APPLICATION" / "AUDIO" / "IMAGE" /
  #                     "FONT" / "MESSAGE" / "MODEL" /
  #                     "VIDEO") DQUOTE) / string) SP media-subtype
  #
  #   media-message   = DQUOTE "MESSAGE" DQUOTE SP
  #                     DQUOTE "RFC822" DQUOTE
  #   media-message   = DQUOTE "MESSAGE" DQUOTE SP
  #                     DQUOTE ("RFC822" / "GLOBAL") DQUOTE
  #
  # RFC-3501 & RFC-9051:
  #   media-text      = DQUOTE "TEXT" DQUOTE SP media-subtype
  #   media-subtype   = string
  #
  # source://net-imap//lib/net/imap/response_parser.rb#1172
  def media_type; end

  # source://net-imap//lib/net/imap/response_parser.rb#799
  def message_data__converted(klass = T.unsafe(nil)); end

  # source://net-imap//lib/net/imap/response_parser.rb#868
  def message_data__expunge; end

  # message-data    = nz-number SP ("EXPUNGE" / ("FETCH" SP msg-att))
  #
  # source://net-imap//lib/net/imap/response_parser.rb#847
  def message_data__fetch; end

  # source://net-imap//lib/net/imap/response_parser.rb#796
  def metadata_resp(klass = T.unsafe(nil)); end

  # RFC3501 & RFC9051:
  #   msg-att         = "(" (msg-att-dynamic / msg-att-static)
  #                      *(SP (msg-att-dynamic / msg-att-static)) ")"
  #
  #   msg-att-dynamic = "FLAGS" SP "(" [flag-fetch *(SP flag-fetch)] ")"
  # RFC5257 (ANNOTATE extension):
  #   msg-att-dynamic =/ "ANNOTATION" SP
  #                        ( "(" entry-att *(SP entry-att) ")" /
  #                          "(" entry *(SP entry) ")" )
  # RFC7162 (CONDSTORE extension):
  #   msg-att-dynamic =/ fetch-mod-resp
  #   fetch-mod-resp  = "MODSEQ" SP "(" permsg-modsequence ")"
  # RFC8970 (PREVIEW extension):
  #   msg-att-dynamic =/ "PREVIEW" SP nstring
  #
  # RFC3501:
  #   msg-att-static  = "ENVELOPE" SP envelope /
  #                     "INTERNALDATE" SP date-time /
  #                     "RFC822" [".HEADER" / ".TEXT"] SP nstring /
  #                     "RFC822.SIZE" SP number /
  #                     "BODY" ["STRUCTURE"] SP body /
  #                     "BODY" section ["<" number ">"] SP nstring /
  #                     "UID" SP uniqueid
  # RFC3516 (BINARY extension):
  #   msg-att-static  =/ "BINARY" section-binary SP (nstring / literal8)
  #                    / "BINARY.SIZE" section-binary SP number
  # RFC8514 (SAVEDATE extension):
  #   msg-att-static  =/ "SAVEDATE" SP (date-time / nil)
  # RFC8474 (OBJECTID extension):
  #   msg-att-static =/ fetch-emailid-resp / fetch-threadid-resp
  #   fetch-emailid-resp  = "EMAILID" SP "(" objectid ")"
  #   fetch-threadid-resp = "THREADID" SP ( "(" objectid ")" / nil )
  # RFC9051:
  #   msg-att-static  = "ENVELOPE" SP envelope /
  #                     "INTERNALDATE" SP date-time /
  #                     "RFC822.SIZE" SP number64 /
  #                     "BODY" ["STRUCTURE"] SP body /
  #                     "BODY" section ["<" number ">"] SP nstring /
  #                     "BINARY" section-binary SP (nstring / literal8) /
  #                     "BINARY.SIZE" section-binary SP number /
  #                     "UID" SP uniqueid
  #
  # Re https://www.rfc-editor.org/errata/eid7246, I'm adding "offset" to the
  # official "BINARY" ABNF, like so:
  #
  #   msg-att-static   =/ "BINARY" section-binary ["<" number ">"] SP
  #                       (nstring / literal8)
  #
  # source://net-imap//lib/net/imap/response_parser.rb#933
  def msg_att(n); end

  # appends "[section]" and "<partial>" to the base label
  #
  # source://net-imap//lib/net/imap/response_parser.rb#970
  def msg_att__label; end

  # source://net-imap//lib/net/imap/response_parser.rb#795
  def myrights_data(klass = T.unsafe(nil)); end

  # namespace         = nil / "(" 1*namespace-descr ")"
  #
  # source://net-imap//lib/net/imap/response_parser.rb#1826
  def namespace; end

  # namespace-descr   = "(" string SP
  #                        (DQUOTE QUOTED-CHAR DQUOTE / nil)
  #                         [namespace-response-extensions] ")"
  #
  # source://net-imap//lib/net/imap/response_parser.rb#1837
  def namespace_descr; end

  # namespace-response = "NAMESPACE" SP namespace
  #                       SP namespace SP namespace
  #                  ; The first Namespace is the Personal Namespace(s).
  #                  ; The second Namespace is the Other Users'
  #                  ; Namespace(s).
  #                  ; The third Namespace is the Shared Namespace(s).
  #
  # source://net-imap//lib/net/imap/response_parser.rb#1814
  def namespace_response; end

  # namespace-response-extensions = *namespace-response-extension
  # namespace-response-extension = SP string SP
  #                   "(" string *(SP string) ")"
  #
  # source://net-imap//lib/net/imap/response_parser.rb#1849
  def namespace_response_extensions; end

  # source://net-imap//lib/net/imap/response_parser.rb#1049
  def ndatetime; end

  # source://net-imap//lib/net/imap/response_parser.rb#2184
  def next_token; end

  # source://net-imap//lib/net/imap/response_parser.rb#2166
  def nil_atom; end

  # env-from        = "(" 1*address ")" / nil
  #   env-sender      = "(" 1*address ")" / nil
  #   env-reply-to    = "(" 1*address ")" / nil
  #   env-to          = "(" 1*address ")" / nil
  #   env-cc          = "(" 1*address ")" / nil
  #   env-bcc         = "(" 1*address ")" / nil
  #
  # source://net-imap//lib/net/imap/response_parser.rb#1027
  def nlist__address; end

  # source://net-imap//lib/net/imap/response_parser.rb#2150
  def nparens__objectid; end

  # source://net-imap//lib/net/imap/response_parser.rb#576
  def nquoted; end

  # nstring         = string / nil
  #
  # source://net-imap//lib/net/imap/response_parser.rb#568
  def nstring; end

  # source://net-imap//lib/net/imap/response_parser.rb#572
  def nstring8; end

  # TODO: handle atom, astring_chars, and tag entirely inside the lexer
  # RFC8474:
  # objectid = 1*255(ALPHA / DIGIT / "_" / "-")
  #         ; characters in object identifiers are case
  #         ; significant
  #
  # source://net-imap//lib/net/imap/response_parser.rb#2147
  def objectid; end

  # source://net-imap//lib/net/imap/response_parser.rb#2141
  def parens__modseq; end

  # source://net-imap//lib/net/imap/response_parser.rb#2149
  def parens__objectid; end

  # partial-range       = partial-range-first / partial-range-last
  # tagged-ext-simple   =/ partial-range-last
  #
  # source://net-imap//lib/net/imap/response_parser.rb#1580
  def partial_range; end

  # partial-results     = sequence-set / "NIL"
  #     ;; <sequence-set> from [RFC3501].
  #     ;; NIL indicates that no results correspond to
  #     ;; the requested range.
  #
  # source://net-imap//lib/net/imap/response_parser.rb#1594
  def partial_results; end

  # This allows illegal "]" in flag names (Gmail),
  # or "\*" in a FLAGS response (greenmail).
  #
  # source://net-imap//lib/net/imap/response_parser.rb#2094
  def quirky__flag_list(name); end

  # source://net-imap//lib/net/imap/response_parser.rb#1407
  def quota_response; end

  # source://net-imap//lib/net/imap/response_parser.rb#1440
  def quotaroot_response; end

  # reads all the way up until CRLF
  #
  # source://net-imap//lib/net/imap/response_parser.rb#786
  def remaining_unparsed; end

  # As a workaround for buggy servers, allow a trailing SP:
  #     *(SP capability) [SP]
  #
  # source://net-imap//lib/net/imap/response_parser.rb#1770
  def resp_code__capability; end

  # already matched:  "APPENDUID"
  #
  # +UIDPLUS+ ABNF:: https://www.rfc-editor.org/rfc/rfc4315.html#section-4
  #   resp-code-apnd  = "APPENDUID" SP nz-number SP append-uid
  #   append-uid      = uniqueid
  #   append-uid      =/ uid-set
  #                     ; only permitted if client uses [MULTIAPPEND]
  #                     ; to append multiple messages.
  #
  # n.b, uniqueid ⊂ uid-set.  To avoid inconsistent return types, we always
  # match uid_set even if that returns a single-member array.
  #
  # source://net-imap//lib/net/imap/response_parser.rb#2004
  def resp_code_apnd__data; end

  # already matched:  "COPYUID"
  #
  # resp-code-copy  = "COPYUID" SP nz-number SP uid-set SP uid-set
  #
  # source://net-imap//lib/net/imap/response_parser.rb#2013
  def resp_code_copy__data; end

  # resp-cond-auth   = ("OK" / "PREAUTH") SP resp-text
  #
  # NOTE: In the spirit of RFC9051 Appx E 23 (and to workaround existing
  # servers), we don't require a final SP and instead parse this as:
  #
  #   resp-cond-auth   = ("OK" / "PREAUTH") [SP resp-text]
  #
  # source://net-imap//lib/net/imap/response_parser.rb#828
  def resp_cond_auth; end

  # expects "OK" or "PREAUTH" and raises InvalidResponseError on failure
  #
  # @raise [InvalidResponseError]
  #
  # source://net-imap//lib/net/imap/response_parser.rb#552
  def resp_cond_auth__name; end

  # resp-cond-bye    = "BYE" SP resp-text
  #
  # NOTE: In the spirit of RFC9051 Appx E 23 (and to workaround existing
  # servers), we don't require a final SP and instead parse this as:
  #
  #   resp-cond-bye    = "BYE" [SP resp-text]
  #
  # source://net-imap//lib/net/imap/response_parser.rb#840
  def resp_cond_bye; end

  # RFC3501 & RFC9051:
  #   resp-cond-state  = ("OK" / "NO" / "BAD") SP resp-text
  #
  # NOTE: In the spirit of RFC9051 Appx E 23 (and to workaround existing
  # servers), we don't require a final SP and instead parse this as:
  #
  #   resp-cond-state = ("OK" / "NO" / "BAD") [SP resp-text]
  #
  # source://net-imap//lib/net/imap/response_parser.rb#814
  def resp_cond_state; end

  # expects "OK" or "NO" or "BAD" and raises InvalidResponseError on failure
  #
  # @raise [InvalidResponseError]
  #
  # source://net-imap//lib/net/imap/response_parser.rb#560
  def resp_cond_state__name; end

  # source://net-imap//lib/net/imap/response_parser.rb#818
  def resp_cond_state__untagged; end

  # RFC3501:
  #   resp-text       = ["[" resp-text-code "]" SP] text
  # RFC9051:
  #   resp-text       = ["[" resp-text-code "]" SP] [text]
  #
  # We leniently re-interpret this as
  #   resp-text       = ["[" resp-text-code "]" [SP [text]] / [text]
  #
  # source://net-imap//lib/net/imap/response_parser.rb#1885
  def resp_text; end

  # RFC3501 (See https://www.rfc-editor.org/errata/rfc3501):
  #   resp-text-code   = "ALERT" /
  #                      "BADCHARSET" [SP "(" charset *(SP charset) ")" ] /
  #                      capability-data / "PARSE" /
  #                      "PERMANENTFLAGS" SP "(" [flag-perm *(SP flag-perm)] ")" /
  #                      "READ-ONLY" / "READ-WRITE" / "TRYCREATE" /
  #                      "UIDNEXT" SP nz-number / "UIDVALIDITY" SP nz-number /
  #                      "UNSEEN" SP nz-number /
  #                      atom [SP 1*<any TEXT-CHAR except "]">]
  #   capability-data  = "CAPABILITY" *(SP capability) SP "IMAP4rev1"
  #                      *(SP capability)
  #
  # RFC5530:
  #   resp-text-code  =/ "UNAVAILABLE" / "AUTHENTICATIONFAILED" /
  #                     "AUTHORIZATIONFAILED" / "EXPIRED" /
  #                     "PRIVACYREQUIRED" / "CONTACTADMIN" / "NOPERM" /
  #                     "INUSE" / "EXPUNGEISSUED" / "CORRUPTION" /
  #                     "SERVERBUG" / "CLIENTBUG" / "CANNOT" /
  #                     "LIMIT" / "OVERQUOTA" / "ALREADYEXISTS" /
  #                     "NONEXISTENT"
  # RFC9051:
  #   resp-text-code   = "ALERT" /
  #                      "BADCHARSET" [SP "(" charset *(SP charset) ")" ] /
  #                      capability-data / "PARSE" /
  #                      "PERMANENTFLAGS" SP "(" [flag-perm *(SP flag-perm)] ")" /
  #                      "READ-ONLY" / "READ-WRITE" / "TRYCREATE" /
  #                      "UIDNEXT" SP nz-number / "UIDVALIDITY" SP nz-number /
  #                      resp-code-apnd / resp-code-copy / "UIDNOTSTICKY" /
  #                      "UNAVAILABLE" / "AUTHENTICATIONFAILED" /
  #                      "AUTHORIZATIONFAILED" / "EXPIRED" /
  #                      "PRIVACYREQUIRED" / "CONTACTADMIN" / "NOPERM" /
  #                      "INUSE" / "EXPUNGEISSUED" / "CORRUPTION" /
  #                      "SERVERBUG" / "CLIENTBUG" / "CANNOT" /
  #                      "LIMIT" / "OVERQUOTA" / "ALREADYEXISTS" /
  #                      "NONEXISTENT" / "NOTSAVED" / "HASCHILDREN" /
  #                      "CLOSED" /
  #                      "UNKNOWN-CTE" /
  #                      atom [SP 1*<any TEXT-CHAR except "]">]
  #   capability-data  = "CAPABILITY" *(SP capability) SP "IMAP4rev2"
  #                      *(SP capability)
  #
  # RFC4315 (UIDPLUS), RFC9051 (IMAP4rev2):
  #   resp-code-apnd   = "APPENDUID" SP nz-number SP append-uid
  #   resp-code-copy   = "COPYUID" SP nz-number SP uid-set SP uid-set
  #   resp-text-code   =/ resp-code-apnd / resp-code-copy / "UIDNOTSTICKY"
  #
  # RFC7162 (CONDSTORE):
  #   resp-text-code   =/ "HIGHESTMODSEQ" SP mod-sequence-value /
  #                       "NOMODSEQ" /
  #                       "MODIFIED" SP sequence-set
  # RFC7162 (QRESYNC):
  #   resp-text-code   =/ "CLOSED"
  #
  # RFC8474: OBJECTID
  #   resp-text-code   =/ "MAILBOXID" SP "(" objectid ")"
  #
  # RFC9586: UIDONLY
  #   resp-text-code   =/ "UIDREQUIRED"
  #
  # source://net-imap//lib/net/imap/response_parser.rb#1952
  def resp_text_code; end

  # Returns <tt>atom.upcase</tt>
  #
  # source://net-imap//lib/net/imap/response_parser.rb#1981
  def resp_text_code__name; end

  # [RFC3501 & RFC9051:]
  #   response        = *(continue-req / response-data) response-done
  #
  # For simplicity, response isn't interpreted as the combination of the
  # three response types, but instead represents any individual server
  # response.  Our simplified interpretation is defined as:
  #   response        = continue-req | response_data | response-tagged
  #
  # n.b: our "response-tagged" definition parses "greeting" too.
  #
  # source://net-imap//lib/net/imap/response_parser.rb#679
  def response; end

  # [RFC3501:]
  #   response-data    = "*" SP (resp-cond-state / resp-cond-bye /
  #                      mailbox-data / message-data / capability-data) CRLF
  # [RFC4466:]
  #   response-data    = "*" SP response-payload CRLF
  #   response-payload = resp-cond-state / resp-cond-bye /
  #                       mailbox-data / message-data / capability-data
  # RFC5161 (ENABLE capability):
  #   response-data    =/ "*" SP enable-data CRLF
  # RFC5255 (LANGUAGE capability)
  #   response-payload =/ language-data
  # RFC5255 (I18NLEVEL=1 and I18NLEVEL=2 capabilities)
  #   response-payload =/ comparator-data
  # [RFC9051:]
  #   response-data    = "*" SP (resp-cond-state / resp-cond-bye /
  #                      mailbox-data / message-data / capability-data /
  #                      enable-data) CRLF
  #
  # [merging in greeting and response-fatal:]
  #   greeting         =  "*" SP (resp-cond-auth / resp-cond-bye) CRLF
  #   response-fatal   =  "*" SP resp-cond-bye CRLF
  #   response-data    =/ "*" SP (resp-cond-auth / resp-cond-bye) CRLF
  # [removing duplicates, this is simply]
  #   response-payload =/ resp-cond-auth
  #
  # TODO: remove resp-cond-auth and handle greeting separately
  #
  # source://net-imap//lib/net/imap/response_parser.rb#731
  def response_data; end

  # source://net-imap//lib/net/imap/response_parser.rb#791
  def response_data__ignored; end

  # source://net-imap//lib/net/imap/response_parser.rb#792
  def response_data__noop; end

  # source://net-imap//lib/net/imap/response_parser.rb#862
  def response_data__simple_numeric; end

  # source://net-imap//lib/net/imap/response_parser.rb#773
  def response_data__unhandled(klass = T.unsafe(nil)); end

  # RFC3501 & RFC9051:
  #   response-tagged = tag SP resp-cond-state CRLF
  #
  # source://net-imap//lib/net/imap/response_parser.rb#803
  def response_tagged; end

  # From RFC5267 (CONTEXT=SEARCH, CONTEXT=SORT) and RFC9394 (PARTIAL):
  #   ret-data-partial    = "PARTIAL"
  #                         SP "(" partial-range SP partial-results ")"
  #
  # source://net-imap//lib/net/imap/response_parser.rb#1570
  def ret_data_partial__value; end

  # search-correlator  = SP "(" "TAG" SP tag-string ")"
  #
  # source://net-imap//lib/net/imap/response_parser.rb#1608
  def search_correlator; end

  # From RFC4731 (ESEARCH):
  #   search-return-data    = "MIN" SP nz-number /
  #                           "MAX" SP nz-number /
  #                           "ALL" SP sequence-set /
  #                           "COUNT" SP number /
  #                           search-ret-data-ext
  #                           ; All return data items conform to
  #                           ; search-ret-data-ext syntax.
  #   search-ret-data-ext   = search-modifier-name SP search-return-value
  #   search-modifier-name  = tagged-ext-label
  #   search-return-value   = tagged-ext-val
  #
  # From RFC4731 (ESEARCH):
  #   search-return-data    =/ "MODSEQ" SP mod-sequence-value
  #
  # From RFC9394 (PARTIAL):
  #   search-return-data  =/ ret-data-partial
  #
  # source://net-imap//lib/net/imap/response_parser.rb#1552
  def search_return_data; end

  # search-return-value = tagged-ext-val
  #                     ; Data for the returned search option.
  #                     ; A single "nz-number"/"number"/"number64" value
  #                     ; can be returned as an atom (i.e., without
  #                     ; quoting).  A sequence-set can be returned
  #                     ; as an atom as well.
  #
  # source://net-imap//lib/net/imap/response_parser.rb#1605
  def search_return_value; end

  # section         = "[" [section-spec] "]"
  #
  # source://net-imap//lib/net/imap/response_parser.rb#1309
  def section; end

  # section-binary  = "[" [section-part] "]"
  #
  # source://net-imap//lib/net/imap/response_parser.rb#1316
  def section_binary; end

  # TODO: handle atom, astring_chars, and tag entirely inside the lexer
  # section-part    = nz-number *("." nz-number)
  #                     ; body part reference.
  #                     ; Allows for accessing nested body parts.
  #
  # source://net-imap//lib/net/imap/response_parser.rb#1355
  def section_part; end

  # section-spec    = section-msgtext / (section-part ["." section-text])
  # section-msgtext = "HEADER" /
  #                   "HEADER.FIELDS" [".NOT"] SP header-list /
  #                   "TEXT"
  #                     ; top-level or MESSAGE/RFC822 or
  #                     ; MESSAGE/GLOBAL part
  # section-part    = nz-number *("." nz-number)
  #                     ; body part reference.
  #                     ; Allows for accessing nested body parts.
  # section-text    = section-msgtext / "MIME"
  #                     ; text other than actual body part (headers,
  #                     ; etc.)
  #
  # n.b: we could "cheat" here and just grab all text inside the brackets,
  # but literals would need special treatment.
  #
  # source://net-imap//lib/net/imap/response_parser.rb#1337
  def section_spec; end

  # sequence-set    = (seq-number / seq-range) ["," sequence-set]
  #   sequence-set    =/ seq-last-command
  #                       ; Allow for "result of the last command"
  #                       ; indicator.
  #   seq-last-command   = "$"
  #
  # *note*: doesn't match seq-last-command
  #
  # source://net-imap//lib/net/imap/response_parser.rb#493
  def sequence_set; end

  # RFC3501:
  #   mailbox-data        = "SEARCH" *(SP nz-number) / ...
  # RFC5256: SORT
  #   sort-data           = "SORT" *(SP nz-number)
  # RFC7162: CONDSTORE, QRESYNC
  #   mailbox-data        =/ "SEARCH" [1*(SP nz-number) SP
  #                          search-sort-mod-seq]
  #   sort-data           = "SORT" [1*(SP nz-number) SP
  #                           search-sort-mod-seq]
  #                           ; Updates the SORT response from RFC 5256.
  #   search-sort-mod-seq = "(" "MODSEQ" SP mod-sequence-value ")"
  # RFC9051:
  #   mailbox-data        = obsolete-search-response / ...
  #   obsolete-search-response = "SEARCH" *(SP nz-number)
  #
  # source://net-imap//lib/net/imap/response_parser.rb#1510
  def sort_data; end

  # RFC3501
  #   status-att-list = status-att SP number *(SP status-att SP number)
  # RFC4466, RFC9051, and RFC3501 Errata
  #   status-att-list = status-att-val *(SP status-att-val)
  #
  # source://net-imap//lib/net/imap/response_parser.rb#1680
  def status_att_list; end

  # RFC3501 Errata:
  # status-att-val  = ("MESSAGES" SP number) / ("RECENT" SP number) /
  #                   ("UIDNEXT" SP nz-number) / ("UIDVALIDITY" SP nz-number) /
  #                   ("UNSEEN" SP number)
  # RFC4466:
  # status-att-val  = ("MESSAGES" SP number) /
  #                   ("RECENT" SP number) /
  #                   ("UIDNEXT" SP nz-number) /
  #                   ("UIDVALIDITY" SP nz-number) /
  #                   ("UNSEEN" SP number)
  #                   ;; Extensions to the STATUS responses
  #                   ;; should extend this production.
  #                   ;; Extensions should use the generic
  #                   ;; syntax defined by tagged-ext.
  # RFC9051:
  # status-att-val  = ("MESSAGES" SP number) /
  #                   ("UIDNEXT" SP nz-number) /
  #                   ("UIDVALIDITY" SP nz-number) /
  #                   ("UNSEEN" SP number) /
  #                   ("DELETED" SP number) /
  #                   ("SIZE" SP number64)
  #                     ; Extensions to the STATUS responses
  #                     ; should extend this production.
  #                     ; Extensions should use the generic
  #                     ; syntax defined by tagged-ext.
  # RFC7162:
  # status-att-val      =/ "HIGHESTMODSEQ" SP mod-sequence-valzer
  #                        ;; Extends non-terminal defined in [RFC4466].
  #                        ;; Value 0 denotes that the mailbox doesn't
  #                        ;; support persistent mod-sequences
  #                        ;; as described in Section 3.1.2.2.
  # RFC7889:
  # status-att-val =/ "APPENDLIMIT" SP (number / nil)
  #                 ;; status-att-val is defined in RFC 4466
  # RFC8438:
  # status-att-val =/ "SIZE" SP number64
  # RFC8474:
  # status-att-val =/ "MAILBOXID" SP "(" objectid ")"
  #         ; follows tagged-ext production from [RFC4466]
  #
  # source://net-imap//lib/net/imap/response_parser.rb#1725
  def status_att_val; end

  # source://net-imap//lib/net/imap/response_parser.rb#514
  def tag; end

  # astring         = 1*ASTRING-CHAR / string
  # tag-string      = astring
  #                   ; <tag> represented as <astring>
  #
  # source://net-imap//lib/net/imap/response_parser.rb#1615
  def tag_string; end

  # tagged-ext-comp     = astring /
  #                       tagged-ext-comp *(SP tagged-ext-comp) /
  #                       "(" tagged-ext-comp ")"
  #                       ; Extensions that follow this general
  #                       ; syntax should use nstring instead of
  #                       ; astring when appropriate in the context
  #                       ; of the extension.
  #                       ; Note that a message set or a "number"
  #                       ; can always be represented as an "atom".
  #                       ; A URL should be represented as
  #                       ; a "quoted" string.
  #
  # source://net-imap//lib/net/imap/response_parser.rb#596
  def tagged_ext_comp; end

  # tagged-ext-simple is a subset of atom
  # TODO: recognize sequence-set in the lexer
  #
  # tagged-ext-simple   = sequence-set / number / number64
  #
  # source://net-imap//lib/net/imap/response_parser.rb#613
  def tagged_ext_simple; end

  # tagged-ext-val      = tagged-ext-simple /
  #                       "(" [tagged-ext-comp] ")"
  #
  # source://net-imap//lib/net/imap/response_parser.rb#619
  def tagged_ext_val; end

  # TEXT-CHAR       = <any CHAR except CR and LF>
  # RFC3501:
  #   text            = 1*TEXT-CHAR
  # RFC9051:
  #   text            = 1*(TEXT-CHAR / UTF8-2 / UTF8-3 / UTF8-4)
  #                     ; Non-ASCII text can only be returned
  #                     ; after ENABLE IMAP4rev2 command
  #
  # source://net-imap//lib/net/imap/response_parser.rb#1869
  def text; end

  # an "accept" versiun of #text
  #
  # @return [Boolean]
  #
  # source://net-imap//lib/net/imap/response_parser.rb#1874
  def text?; end

  # 1*<any TEXT-CHAR except "]">
  #
  # source://net-imap//lib/net/imap/response_parser.rb#1984
  def text_chars_except_rbra; end

  # RFC5256: THREAD
  #   thread-data     = "THREAD" [SP 1*thread-list]
  #
  # source://net-imap//lib/net/imap/response_parser.rb#1619
  def thread_data; end

  # RFC5256: THREAD
  #   thread-list     = "(" (thread-members / thread-nested) ")"
  #
  # source://net-imap//lib/net/imap/response_parser.rb#1633
  def thread_list; end

  # RFC5256: THREAD
  #   thread-members  = nz-number *(SP nz-number) [SP thread-nested]
  #
  # source://net-imap//lib/net/imap/response_parser.rb#1646
  def thread_members; end

  # RFC5256: THREAD
  #   thread-nested   = 2*thread-list
  #
  # source://net-imap//lib/net/imap/response_parser.rb#1662
  def thread_nested; end

  # RFC-4315 (UIDPLUS) or RFC9051 (IMAP4rev2):
  #      uid-set         = (uniqueid / uid-range) *("," uid-set)
  #      uid-range       = (uniqueid ":" uniqueid)
  #                          ; two uniqueid values and all values
  #                          ; between these two regardless of order.
  #                          ; Example: 2:4 and 4:2 are equivalent.
  #      uniqueid        = nz-number
  #                          ; Strictly ascending
  #
  # source://net-imap//lib/net/imap/response_parser.rb#2160
  def uid_set; end

  # uidfetch-resp = uniqueid SP "UIDFETCH" SP msg-att
  #
  # source://net-imap//lib/net/imap/response_parser.rb#855
  def uidfetch_resp; end

  # See https://developers.google.com/gmail/imap/imap-extensions
  #
  # source://net-imap//lib/net/imap/response_parser.rb#2108
  def x_gm_label; end

  # See https://developers.google.com/gmail/imap/imap-extensions
  #
  # source://net-imap//lib/net/imap/response_parser.rb#2111
  def x_gm_labels; end
end

# ASTRING-CHAR    = ATOM-CHAR / resp-specials
# resp-specials   = "]"
#
# source://net-imap//lib/net/imap/response_parser.rb#504
Net::IMAP::ResponseParser::ASTRING_CHARS_TOKENS = T.let(T.unsafe(nil), Array)

# source://net-imap//lib/net/imap/response_parser.rb#506
Net::IMAP::ResponseParser::ASTRING_TOKENS = T.let(T.unsafe(nil), Array)

# basic utility methods for parsing.
#
# (internal API, subject to change)
#
# source://net-imap//lib/net/imap/response_parser/parser_utils.rb#9
module Net::IMAP::ResponseParser::ParserUtils
  private

  # like match, but does not raise error on failure.
  #
  # returns and shifts token on successful match
  # returns nil and leaves @token unshifted on no match
  #
  # source://net-imap//lib/net/imap/response_parser/parser_utils.rb#148
  def accept(*args); end

  # source://net-imap//lib/net/imap/response_parser/parser_utils.rb#198
  def accept_re(re); end

  # To be used conditionally:
  #   assert_no_lookahead if config.debug?
  #
  # source://net-imap//lib/net/imap/response_parser/parser_utils.rb#158
  def assert_no_lookahead; end

  # TODO: after checking the lookahead, use a regexp for remaining chars.
  # That way a loop isn't needed.
  #
  # source://net-imap//lib/net/imap/response_parser/parser_utils.rb#121
  def combine_adjacent(*tokens); end

  # source://net-imap//lib/net/imap/response_parser/parser_utils.rb#169
  def lookahead; end

  # like match, without consuming the token
  #
  # source://net-imap//lib/net/imap/response_parser/parser_utils.rb#174
  def lookahead!(*args); end

  # like accept, without consuming the token
  #
  # @return [Boolean]
  #
  # source://net-imap//lib/net/imap/response_parser/parser_utils.rb#165
  def lookahead?(*symbols); end

  # source://net-imap//lib/net/imap/response_parser/parser_utils.rb#133
  def match(*args); end

  # source://net-imap//lib/net/imap/response_parser/parser_utils.rb#204
  def match_re(re, name); end

  # @raise [ResponseParseError]
  #
  # source://net-imap//lib/net/imap/response_parser/parser_utils.rb#218
  def parse_error(fmt, *args); end

  # source://net-imap//lib/net/imap/response_parser/parser_utils.rb#193
  def peek_re(re); end

  # @return [Boolean]
  #
  # source://net-imap//lib/net/imap/response_parser/parser_utils.rb#188
  def peek_re?(re); end

  # @return [Boolean]
  #
  # source://net-imap//lib/net/imap/response_parser/parser_utils.rb#183
  def peek_str?(str); end

  # source://net-imap//lib/net/imap/response_parser/parser_utils.rb#214
  def shift_token; end
end

# source://net-imap//lib/net/imap/response_parser/parser_utils.rb#11
module Net::IMAP::ResponseParser::ParserUtils::Generator
  # we can skip lexer for single character matches, as a shortcut
  #
  # source://net-imap//lib/net/imap/response_parser/parser_utils.rb#17
  def def_char_matchers(name, char, token); end

  # TODO: move coersion to the token.value method?
  #
  # source://net-imap//lib/net/imap/response_parser/parser_utils.rb#62
  def def_token_matchers(name, *token_symbols, coerce: T.unsafe(nil), send: T.unsafe(nil)); end
end

# source://net-imap//lib/net/imap/response_parser/parser_utils.rb#13
Net::IMAP::ResponseParser::ParserUtils::Generator::LOOKAHEAD = T.let(T.unsafe(nil), String)

# source://net-imap//lib/net/imap/response_parser/parser_utils.rb#14
Net::IMAP::ResponseParser::ParserUtils::Generator::SHIFT_TOKEN = T.let(T.unsafe(nil), String)

# source://net-imap//lib/net/imap/response_parser.rb#84
module Net::IMAP::ResponseParser::Patterns
  include ::Net::IMAP::ResponseParser::Patterns::RFC5234
  include ::Net::IMAP::ResponseParser::Patterns::RFC3629

  private

  # source://net-imap//lib/net/imap/response_parser.rb#377
  def unescape_quoted(quoted); end

  # source://net-imap//lib/net/imap/response_parser.rb#371
  def unescape_quoted!(quoted); end

  class << self
    # source://net-imap//lib/net/imap/response_parser.rb#377
    def unescape_quoted(quoted); end

    # source://net-imap//lib/net/imap/response_parser.rb#371
    def unescape_quoted!(quoted); end
  end
end

# source://net-imap//lib/net/imap/response_parser.rb#181
Net::IMAP::ResponseParser::Patterns::ASTRING_CHAR = T.let(T.unsafe(nil), Regexp)

# source://net-imap//lib/net/imap/response_parser.rb#185
Net::IMAP::ResponseParser::Patterns::ASTRING_CHARS = T.let(T.unsafe(nil), Regexp)

# source://net-imap//lib/net/imap/response_parser.rb#179
Net::IMAP::ResponseParser::Patterns::ASTRING_SPECIALS = T.let(T.unsafe(nil), Regexp)

# source://net-imap//lib/net/imap/response_parser.rb#184
Net::IMAP::ResponseParser::Patterns::ATOM = T.let(T.unsafe(nil), Regexp)

# source://net-imap//lib/net/imap/response_parser.rb#186
Net::IMAP::ResponseParser::Patterns::ATOMISH = T.let(T.unsafe(nil), Regexp)

# source://net-imap//lib/net/imap/response_parser.rb#182
Net::IMAP::ResponseParser::Patterns::ATOM_CHAR = T.let(T.unsafe(nil), Regexp)

# atomish         = 1*<any ATOM-CHAR except "[">
#                 ; We use "atomish" for msg-att and section, in order
#                 ; to simplify "BODY[HEADER.FIELDS (foo bar)]".
#
# atom-specials   = "(" / ")" / "{" / SP / CTL / list-wildcards /
#                   quoted-specials / resp-specials
# ATOM-CHAR       = <any CHAR except atom-specials>
# atom            = 1*ATOM-CHAR
# ASTRING-CHAR    = ATOM-CHAR / resp-specials
# tag             = 1*<any ASTRING-CHAR except "+">
#
# source://net-imap//lib/net/imap/response_parser.rb#178
Net::IMAP::ResponseParser::Patterns::ATOM_SPECIALS = T.let(T.unsafe(nil), Regexp)

# CHAR8           = %x01-ff
#                     ; any OCTET except NUL, %x00
#
# source://net-imap//lib/net/imap/response_parser.rb#158
Net::IMAP::ResponseParser::Patterns::CHAR8 = T.let(T.unsafe(nil), Regexp)

# source://net-imap//lib/net/imap/response_parser.rb#194
Net::IMAP::ResponseParser::Patterns::CODE_TEXT = T.let(T.unsafe(nil), Regexp)

# resp-text-code  = ... / atom [SP 1*<any TEXT-CHAR except "]">]
#
# source://net-imap//lib/net/imap/response_parser.rb#193
Net::IMAP::ResponseParser::Patterns::CODE_TEXT_CHAR = T.let(T.unsafe(nil), Regexp)

# source://net-imap//lib/net/imap/response_parser.rb#86
module Net::IMAP::ResponseParser::Patterns::CharClassSubtraction; end

# flag            = "\Answered" / "\Flagged" / "\Deleted" /
#                   "\Seen" / "\Draft" / flag-keyword / flag-extension
#                     ; Does not include "\Recent"
# flag-extension  = "\" atom
#                     ; Future expansion.  Client implementations
#                     ; MUST accept flag-extension flags.  Server
#                     ; implementations MUST NOT generate
#                     ; flag-extension flags except as defined by
#                     ; a future Standard or Standards Track
#                     ; revisions of this specification.
# flag-keyword    = "$MDNSent" / "$Forwarded" / "$Junk" /
#                   "$NotJunk" / "$Phishing" / atom
#
# flag-perm       = flag / "\*"
#
# Not checking for max one mbx-list-sflag in the parser.
# >>>
# mbx-list-oflag  = "\Noinferiors" / child-mbox-flag /
#                   "\Subscribed" / "\Remote" / flag-extension
#                    ; Other flags; multiple from this list are
#                    ; possible per LIST response, but each flag
#                    ; can only appear once per LIST response
# mbx-list-sflag  = "\NonExistent" / "\Noselect" / "\Marked" /
#                   "\Unmarked"
#                    ; Selectability flags; only one per LIST response
# child-mbox-flag =  "\HasChildren" / "\HasNoChildren"
#                    ; attributes for the CHILDREN return option, at most
#                    ; one possible per LIST response
#
# source://net-imap//lib/net/imap/response_parser.rb#224
Net::IMAP::ResponseParser::Patterns::FLAG = T.let(T.unsafe(nil), Regexp)

# source://net-imap//lib/net/imap/response_parser.rb#225
Net::IMAP::ResponseParser::Patterns::FLAG_EXTENSION = T.let(T.unsafe(nil), Regexp)

# source://net-imap//lib/net/imap/response_parser.rb#226
Net::IMAP::ResponseParser::Patterns::FLAG_KEYWORD = T.let(T.unsafe(nil), Regexp)

# flag-list       = "(" [flag *(SP flag)] ")"
# resp-text-code =/ "PERMANENTFLAGS" SP
#                   "(" [flag-perm *(SP flag-perm)] ")"
# mbx-list-flags  = *(mbx-list-oflag SP) mbx-list-sflag
#                   *(SP mbx-list-oflag) /
#                   mbx-list-oflag *(SP mbx-list-oflag)
# (Not checking for max one mbx-list-sflag in the parser.)
#
# source://net-imap//lib/net/imap/response_parser.rb#237
Net::IMAP::ResponseParser::Patterns::FLAG_LIST = T.let(T.unsafe(nil), Regexp)

# source://net-imap//lib/net/imap/response_parser.rb#227
Net::IMAP::ResponseParser::Patterns::FLAG_PERM = T.let(T.unsafe(nil), Regexp)

# source://net-imap//lib/net/imap/response_parser.rb#238
Net::IMAP::ResponseParser::Patterns::FLAG_PERM_LIST = T.let(T.unsafe(nil), Regexp)

# list-wildcards  = "%" / "*"
#
# source://net-imap//lib/net/imap/response_parser.rb#161
Net::IMAP::ResponseParser::Patterns::LIST_WILDCARDS = T.let(T.unsafe(nil), Regexp)

# RFC3501:
#   literal          = "{" number "}" CRLF *CHAR8
#                        ; Number represents the number of CHAR8s
# RFC9051:
#   literal          = "{" number64 ["+"] "}" CRLF *CHAR8
#                        ; <number64> represents the number of CHAR8s.
#                        ; A non-synchronizing literal is distinguished
#                        ; from a synchronizing literal by the presence of
#                        ; "+" before the closing "}".
#                        ; Non-synchronizing literals are not allowed when
#                        ; sent from server to the client.
#
# source://net-imap//lib/net/imap/response_parser.rb#357
Net::IMAP::ResponseParser::Patterns::LITERAL = T.let(T.unsafe(nil), Regexp)

# RFC3516 (BINARY):
#   literal8         =   "~{" number "}" CRLF *OCTET
#                        ; <number> represents the number of OCTETs
#                        ; in the response string.
# RFC9051:
#   literal8         =  "~{" number64 "}" CRLF *OCTET
#                        ; <number64> represents the number of OCTETs
#                        ; in the response string.
#
# source://net-imap//lib/net/imap/response_parser.rb#367
Net::IMAP::ResponseParser::Patterns::LITERAL8 = T.let(T.unsafe(nil), Regexp)

# source://net-imap//lib/net/imap/response_parser.rb#228
Net::IMAP::ResponseParser::Patterns::MBX_FLAG = T.let(T.unsafe(nil), Regexp)

# source://net-imap//lib/net/imap/response_parser.rb#239
Net::IMAP::ResponseParser::Patterns::MBX_LIST_FLAGS = T.let(T.unsafe(nil), Regexp)

# nz-number       = digit-nz *DIGIT
#                     ; Non-zero unsigned 32-bit integer
#                     ; (0 < n < 4,294,967,296)
#
# source://net-imap//lib/net/imap/response_parser.rb#281
Net::IMAP::ResponseParser::Patterns::NZ_NUMBER = T.let(T.unsafe(nil), Regexp)

# partial-range     = partial-range-first / partial-range-last
#
# source://net-imap//lib/net/imap/response_parser.rb#343
Net::IMAP::ResponseParser::Patterns::PARTIAL_RANGE = T.let(T.unsafe(nil), Regexp)

# partial-range-first = nz-number ":" nz-number
#     ;; Request to search from oldest (lowest UIDs) to
#     ;; more recent messages.
#     ;; A range 500:400 is the same as 400:500.
#     ;; This is similar to <seq-range> from [RFC3501]
#     ;; but cannot contain "*".
#
# source://net-imap//lib/net/imap/response_parser.rb#334
Net::IMAP::ResponseParser::Patterns::PARTIAL_RANGE_FIRST = T.let(T.unsafe(nil), Regexp)

# partial-range-last  = MINUS nz-number ":" MINUS nz-number
#     ;; Request to search from newest (highest UIDs) to
#     ;; oldest messages.
#     ;; A range -500:-400 is the same as -400:-500.
#
# source://net-imap//lib/net/imap/response_parser.rb#340
Net::IMAP::ResponseParser::Patterns::PARTIAL_RANGE_LAST = T.let(T.unsafe(nil), Regexp)

# Gmail allows SP and "]" in flags.......
#
# source://net-imap//lib/net/imap/response_parser.rb#242
Net::IMAP::ResponseParser::Patterns::QUIRKY_FLAG = T.let(T.unsafe(nil), Regexp)

# source://net-imap//lib/net/imap/response_parser.rb#243
Net::IMAP::ResponseParser::Patterns::QUIRKY_FLAGS_LIST = T.let(T.unsafe(nil), Regexp)

# source://net-imap//lib/net/imap/response_parser.rb#254
Net::IMAP::ResponseParser::Patterns::QUOTED_CHAR_esc = T.let(T.unsafe(nil), Regexp)

# source://net-imap//lib/net/imap/response_parser.rb#255
Net::IMAP::ResponseParser::Patterns::QUOTED_CHAR_rev1 = T.let(T.unsafe(nil), Regexp)

# source://net-imap//lib/net/imap/response_parser.rb#256
Net::IMAP::ResponseParser::Patterns::QUOTED_CHAR_rev2 = T.let(T.unsafe(nil), Regexp)

# RFC3501:
#   QUOTED-CHAR   = <any TEXT-CHAR except quoted-specials> /
#                   "\" quoted-specials
# RFC9051:
#   QUOTED-CHAR   = <any TEXT-CHAR except quoted-specials> /
#                   "\" quoted-specials / UTF8-2 / UTF8-3 / UTF8-4
# RFC3501 & RFC9051:
#   quoted          = DQUOTE *QUOTED-CHAR DQUOTE
#
# source://net-imap//lib/net/imap/response_parser.rb#253
Net::IMAP::ResponseParser::Patterns::QUOTED_CHAR_safe = T.let(T.unsafe(nil), Regexp)

# quoted-specials = DQUOTE / "\"
#
# source://net-imap//lib/net/imap/response_parser.rb#163
Net::IMAP::ResponseParser::Patterns::QUOTED_SPECIALS = T.let(T.unsafe(nil), Regexp)

# source://net-imap//lib/net/imap/response_parser.rb#258
Net::IMAP::ResponseParser::Patterns::QUOTED_rev1 = T.let(T.unsafe(nil), Regexp)

# source://net-imap//lib/net/imap/response_parser.rb#259
Net::IMAP::ResponseParser::Patterns::QUOTED_rev2 = T.let(T.unsafe(nil), Regexp)

# resp-specials   = "]"
#
# source://net-imap//lib/net/imap/response_parser.rb#165
Net::IMAP::ResponseParser::Patterns::RESP_SPECIALS = T.let(T.unsafe(nil), Regexp)

# UTF-8, a transformation format of ISO 10646
# >>>
#   UTF8-1      = %x00-7F
#   UTF8-tail   = %x80-BF
#   UTF8-2      = %xC2-DF UTF8-tail
#   UTF8-3      = %xE0 %xA0-BF UTF8-tail / %xE1-EC 2( UTF8-tail ) /
#                 %xED %x80-9F UTF8-tail / %xEE-EF 2( UTF8-tail )
#   UTF8-4      = %xF0 %x90-BF 2( UTF8-tail ) / %xF1-F3 3( UTF8-tail ) /
#                 %xF4 %x80-8F 2( UTF8-tail )
#   UTF8-char   = UTF8-1 / UTF8-2 / UTF8-3 / UTF8-4
#   UTF8-octets = *( UTF8-char )
#
# n.b. String * Integer is used for repetition, rather than /x{3}/,
# because ruby 3.2's linear-time cache-based optimization doesn't work
# with "bounded or fixed times repetition nesting in another repetition
# (e.g. /(a{2,3})*/). It is an implementation issue entirely, but we
# believe it is hard to support this case correctly."
# See https://bugs.ruby-lang.org/issues/19104
#
# source://net-imap//lib/net/imap/response_parser.rb#138
module Net::IMAP::ResponseParser::Patterns::RFC3629; end

# aka ASCII 7bit
#
# source://net-imap//lib/net/imap/response_parser.rb#139
Net::IMAP::ResponseParser::Patterns::RFC3629::UTF8_1 = T.let(T.unsafe(nil), Regexp)

# source://net-imap//lib/net/imap/response_parser.rb#141
Net::IMAP::ResponseParser::Patterns::RFC3629::UTF8_2 = T.let(T.unsafe(nil), Regexp)

# source://net-imap//lib/net/imap/response_parser.rb#142
Net::IMAP::ResponseParser::Patterns::RFC3629::UTF8_3 = T.let(T.unsafe(nil), Regexp)

# source://net-imap//lib/net/imap/response_parser.rb#146
Net::IMAP::ResponseParser::Patterns::RFC3629::UTF8_4 = T.let(T.unsafe(nil), Regexp)

# source://net-imap//lib/net/imap/response_parser.rb#149
Net::IMAP::ResponseParser::Patterns::RFC3629::UTF8_CHAR = T.let(T.unsafe(nil), Regexp)

# source://net-imap//lib/net/imap/response_parser.rb#150
Net::IMAP::ResponseParser::Patterns::RFC3629::UTF8_OCTETS = T.let(T.unsafe(nil), Regexp)

# source://net-imap//lib/net/imap/response_parser.rb#140
Net::IMAP::ResponseParser::Patterns::RFC3629::UTF8_TAIL = T.let(T.unsafe(nil), Regexp)

# From RFC5234, "Augmented BNF for Syntax Specifications: ABNF"
# >>>
#   ALPHA   =  %x41-5A / %x61-7A   ; A-Z / a-z
#   CHAR    = %x01-7F
#   CRLF    =  CR LF
#                   ; Internet standard newline
#   CTL     = %x00-1F / %x7F
#                ; controls
#   DIGIT   =  %x30-39
#                   ; 0-9
#   DQUOTE  =  %x22
#                   ; " (Double Quote)
#   HEXDIG  =  DIGIT / "A" / "B" / "C" / "D" / "E" / "F"
#   OCTET   = %x00-FF
#   SP      =  %x20
#
# source://net-imap//lib/net/imap/response_parser.rb#108
module Net::IMAP::ResponseParser::Patterns::RFC5234; end

# source://net-imap//lib/net/imap/response_parser.rb#109
Net::IMAP::ResponseParser::Patterns::RFC5234::ALPHA = T.let(T.unsafe(nil), Regexp)

# source://net-imap//lib/net/imap/response_parser.rb#110
Net::IMAP::ResponseParser::Patterns::RFC5234::CHAR = T.let(T.unsafe(nil), Regexp)

# source://net-imap//lib/net/imap/response_parser.rb#111
Net::IMAP::ResponseParser::Patterns::RFC5234::CRLF = T.let(T.unsafe(nil), Regexp)

# source://net-imap//lib/net/imap/response_parser.rb#112
Net::IMAP::ResponseParser::Patterns::RFC5234::CTL = T.let(T.unsafe(nil), Regexp)

# source://net-imap//lib/net/imap/response_parser.rb#113
Net::IMAP::ResponseParser::Patterns::RFC5234::DIGIT = T.let(T.unsafe(nil), Regexp)

# source://net-imap//lib/net/imap/response_parser.rb#114
Net::IMAP::ResponseParser::Patterns::RFC5234::DQUOTE = T.let(T.unsafe(nil), Regexp)

# source://net-imap//lib/net/imap/response_parser.rb#115
Net::IMAP::ResponseParser::Patterns::RFC5234::HEXDIG = T.let(T.unsafe(nil), Regexp)

# not using /./m for embedding purposes
#
# source://net-imap//lib/net/imap/response_parser.rb#116
Net::IMAP::ResponseParser::Patterns::RFC5234::OCTET = T.let(T.unsafe(nil), Regexp)

# source://net-imap//lib/net/imap/response_parser.rb#117
Net::IMAP::ResponseParser::Patterns::RFC5234::SP = T.let(T.unsafe(nil), Regexp)

# source://net-imap//lib/net/imap/response_parser.rb#325
Net::IMAP::ResponseParser::Patterns::SEQUENCE_SET = T.let(T.unsafe(nil), Regexp)

# sequence-set    = (seq-number / seq-range) ["," sequence-set]
#                     ; set of seq-number values, regardless of order.
#                     ; Servers MAY coalesce overlaps and/or execute
#                     ; the sequence in any order.
#                     ; Example: a message sequence number set of
#                     ; 2,4:7,9,12:* for a mailbox with 15 messages is
#                     ; equivalent to 2,4,5,6,7,9,12,13,14,15
#                     ; Example: a message sequence number set of
#                     ; *:4,5:7 for a mailbox with 10 messages is
#                     ; equivalent to 10,9,8,7,6,5,4,5,6,7 and MAY
#                     ; be reordered and overlap coalesced to be
#                     ; 4,5,6,7,8,9,10.
#
# source://net-imap//lib/net/imap/response_parser.rb#324
Net::IMAP::ResponseParser::Patterns::SEQUENCE_SET_ITEM = T.let(T.unsafe(nil), Regexp)

# source://net-imap//lib/net/imap/response_parser.rb#326
Net::IMAP::ResponseParser::Patterns::SEQUENCE_SET_STR = T.let(T.unsafe(nil), Regexp)

# seq-number      = nz-number / "*"
#                     ; message sequence number (COPY, FETCH, STORE
#                     ; commands) or unique identifier (UID COPY,
#                     ; UID FETCH, UID STORE commands).
#                     ; * represents the largest number in use.  In
#                     ; the case of message sequence numbers, it is
#                     ; the number of messages in a non-empty mailbox.
#                     ; In the case of unique identifiers, it is the
#                     ; unique identifier of the last message in the
#                     ; mailbox or, if the mailbox is empty, the
#                     ; mailbox's current UIDNEXT value.
#                     ; The server should respond with a tagged BAD
#                     ; response to a command that uses a message
#                     ; sequence number greater than the number of
#                     ; messages in the selected mailbox.  This
#                     ; includes "*" if the selected mailbox is empty.
#
# source://net-imap//lib/net/imap/response_parser.rb#299
Net::IMAP::ResponseParser::Patterns::SEQ_NUMBER = T.let(T.unsafe(nil), Regexp)

# seq-range       = seq-number ":" seq-number
#                     ; two seq-number values and all values between
#                     ; these two regardless of order.
#                     ; Example: 2:4 and 4:2 are equivalent and
#                     ; indicate values 2, 3, and 4.
#                     ; Example: a unique identifier sequence range of
#                     ; 3291:* includes the UID of the last message in
#                     ; the mailbox, even if that value is less than
#                     ; 3291.
#
# source://net-imap//lib/net/imap/response_parser.rb#310
Net::IMAP::ResponseParser::Patterns::SEQ_RANGE = T.let(T.unsafe(nil), Regexp)

# source://net-imap//lib/net/imap/response_parser.rb#187
Net::IMAP::ResponseParser::Patterns::TAG = T.let(T.unsafe(nil), Regexp)

# tagged-ext-label   = tagged-label-fchar *tagged-label-char
#                      ; Is a valid RFC 3501 "atom".
#
# source://net-imap//lib/net/imap/response_parser.rb#276
Net::IMAP::ResponseParser::Patterns::TAGGED_EXT_LABEL = T.let(T.unsafe(nil), Regexp)

# tagged-label-char  = tagged-label-fchar / DIGIT / ":"
#
# source://net-imap//lib/net/imap/response_parser.rb#273
Net::IMAP::ResponseParser::Patterns::TAGGED_LABEL_CHAR = T.let(T.unsafe(nil), Regexp)

# tagged-label-fchar = ALPHA / "-" / "_" / "."
#
# source://net-imap//lib/net/imap/response_parser.rb#271
Net::IMAP::ResponseParser::Patterns::TAGGED_LABEL_FCHAR = T.let(T.unsafe(nil), Regexp)

# TEXT-CHAR       = <any CHAR except CR and LF>
#
# source://net-imap//lib/net/imap/response_parser.rb#190
Net::IMAP::ResponseParser::Patterns::TEXT_CHAR = T.let(T.unsafe(nil), Regexp)

# RFC3501:
#   text          = 1*TEXT-CHAR
# RFC9051:
#   text          = 1*(TEXT-CHAR / UTF8-2 / UTF8-3 / UTF8-4)
#                     ; Non-ASCII text can only be returned
#                     ; after ENABLE IMAP4rev2 command
#
# source://net-imap//lib/net/imap/response_parser.rb#267
Net::IMAP::ResponseParser::Patterns::TEXT_rev1 = T.let(T.unsafe(nil), Regexp)

# source://net-imap//lib/net/imap/response_parser.rb#268
Net::IMAP::ResponseParser::Patterns::TEXT_rev2 = T.let(T.unsafe(nil), Regexp)

# source://net-imap//lib/net/imap/response_parser.rb#703
Net::IMAP::ResponseParser::RE_RESPONSE_TYPE = T.let(T.unsafe(nil), Regexp)

# end of response string
#
# source://net-imap//lib/net/imap/response_parser.rb#69
module Net::IMAP::ResponseParser::ResponseConditions; end

# source://net-imap//lib/net/imap/response_parser.rb#78
Net::IMAP::ResponseParser::ResponseConditions::AUTH_CONDS = T.let(T.unsafe(nil), Array)

# source://net-imap//lib/net/imap/response_parser.rb#72
Net::IMAP::ResponseParser::ResponseConditions::BAD = T.let(T.unsafe(nil), String)

# source://net-imap//lib/net/imap/response_parser.rb#73
Net::IMAP::ResponseParser::ResponseConditions::BYE = T.let(T.unsafe(nil), String)

# source://net-imap//lib/net/imap/response_parser.rb#79
Net::IMAP::ResponseParser::ResponseConditions::GREETING_CONDS = T.let(T.unsafe(nil), Array)

# source://net-imap//lib/net/imap/response_parser.rb#71
Net::IMAP::ResponseParser::ResponseConditions::NO = T.let(T.unsafe(nil), String)

# source://net-imap//lib/net/imap/response_parser.rb#70
Net::IMAP::ResponseParser::ResponseConditions::OK = T.let(T.unsafe(nil), String)

# source://net-imap//lib/net/imap/response_parser.rb#74
Net::IMAP::ResponseParser::ResponseConditions::PREAUTH = T.let(T.unsafe(nil), String)

# source://net-imap//lib/net/imap/response_parser.rb#80
Net::IMAP::ResponseParser::ResponseConditions::RESP_CONDS = T.let(T.unsafe(nil), Array)

# source://net-imap//lib/net/imap/response_parser.rb#76
Net::IMAP::ResponseParser::ResponseConditions::RESP_COND_STATES = T.let(T.unsafe(nil), Array)

# source://net-imap//lib/net/imap/response_parser.rb#77
Net::IMAP::ResponseParser::ResponseConditions::RESP_DATA_CONDS = T.let(T.unsafe(nil), Array)

# source://net-imap//lib/net/imap/response_parser.rb#484
Net::IMAP::ResponseParser::SEQUENCE_SET_TOKENS = T.let(T.unsafe(nil), Array)

# source://net-imap//lib/net/imap/response_parser.rb#2171
Net::IMAP::ResponseParser::SPACES_REGEXP = T.let(T.unsafe(nil), Regexp)

# tag             = 1*<any ASTRING-CHAR except "+">
#
# source://net-imap//lib/net/imap/response_parser.rb#509
Net::IMAP::ResponseParser::TAG_TOKENS = T.let(T.unsafe(nil), Array)

# starts with atom special
#
# source://net-imap//lib/net/imap/response_parser.rb#64
Net::IMAP::ResponseParser::T_LITERAL8 = T.let(T.unsafe(nil), Symbol)

# source://net-imap//lib/net/imap/response_parser.rb#427
class Net::IMAP::ResponseParser::Token < ::Struct
  # Returns the value of attribute symbol
  #
  # @return [Object] the current value of symbol
  #
  # source://net-imap//lib/net/imap/response_parser.rb#427
  def symbol; end

  # Sets the attribute symbol
  #
  # @param value [Object] the value to set the attribute symbol to.
  # @return [Object] the newly set value
  #
  # source://net-imap//lib/net/imap/response_parser.rb#427
  def symbol=(_); end

  # Returns the value of attribute value
  #
  # @return [Object] the current value of value
  #
  # source://net-imap//lib/net/imap/response_parser.rb#427
  def value; end

  # Sets the attribute value
  #
  # @param value [Object] the value to set the attribute value to.
  # @return [Object] the newly set value
  #
  # source://net-imap//lib/net/imap/response_parser.rb#427
  def value=(_); end

  class << self
    # source://net-imap//lib/net/imap/response_parser.rb#427
    def [](*_arg0); end

    # source://net-imap//lib/net/imap/response_parser.rb#427
    def inspect; end

    # source://net-imap//lib/net/imap/response_parser.rb#427
    def keyword_init?; end

    # source://net-imap//lib/net/imap/response_parser.rb#427
    def members; end

    # source://net-imap//lib/net/imap/response_parser.rb#427
    def new(*_arg0); end
  end
end

# Error raised when the socket cannot be read, due to a Config limit.
#
# source://net-imap//lib/net/imap/errors.rb#21
class Net::IMAP::ResponseReadError < ::Net::IMAP::Error; end

# See https://www.rfc-editor.org/rfc/rfc9051#section-2.2.2
#
# source://net-imap//lib/net/imap/response_reader.rb#6
class Net::IMAP::ResponseReader
  # @return [ResponseReader] a new instance of ResponseReader
  #
  # source://net-imap//lib/net/imap/response_reader.rb#9
  def initialize(client, sock); end

  # source://net-imap//lib/net/imap/response_reader.rb#7
  def client; end

  # source://net-imap//lib/net/imap/response_reader.rb#13
  def read_response_buffer; end

  private

  # Returns the value of attribute buff.
  #
  # source://net-imap//lib/net/imap/response_reader.rb#29
  def buff; end

  # source://net-imap//lib/net/imap/response_reader.rb#31
  def bytes_read; end

  # @return [Boolean]
  #
  # source://net-imap//lib/net/imap/response_reader.rb#33
  def done?; end

  # @return [Boolean]
  #
  # source://net-imap//lib/net/imap/response_reader.rb#32
  def empty?; end

  # source://net-imap//lib/net/imap/response_reader.rb#35
  def get_literal_size; end

  # @return [Boolean]
  #
  # source://net-imap//lib/net/imap/response_reader.rb#34
  def line_done?; end

  # Returns the value of attribute literal_size.
  #
  # source://net-imap//lib/net/imap/response_reader.rb#29
  def literal_size; end

  # source://net-imap//lib/net/imap/response_reader.rb#56
  def max_response_remaining; end

  # @raise [ResponseTooLargeError]
  #
  # source://net-imap//lib/net/imap/response_reader.rb#64
  def max_response_remaining!; end

  # source://net-imap//lib/net/imap/response_reader.rb#55
  def max_response_size; end

  # source://net-imap//lib/net/imap/response_reader.rb#60
  def min_response_remaining; end

  # source://net-imap//lib/net/imap/response_reader.rb#58
  def min_response_size; end

  # source://net-imap//lib/net/imap/response_reader.rb#51
  def read_limit(limit = T.unsafe(nil)); end

  # source://net-imap//lib/net/imap/response_reader.rb#37
  def read_line; end

  # source://net-imap//lib/net/imap/response_reader.rb#42
  def read_literal; end

  # @return [Boolean]
  #
  # source://net-imap//lib/net/imap/response_reader.rb#57
  def response_too_large?; end
end

# Used to avoid an allocation when ResponseText is empty
#
# source://net-imap//lib/net/imap/response_data.rb#181
Net::IMAP::ResponseText::EMPTY = T.let(T.unsafe(nil), Net::IMAP::ResponseText)

# Error raised when a response is larger than IMAP#max_response_size.
#
# source://net-imap//lib/net/imap/errors.rb#25
class Net::IMAP::ResponseTooLargeError < ::Net::IMAP::ResponseReadError
  # @return [ResponseTooLargeError] a new instance of ResponseTooLargeError
  #
  # source://net-imap//lib/net/imap/errors.rb#29
  def initialize(msg = T.unsafe(nil), *args, bytes_read: T.unsafe(nil), literal_size: T.unsafe(nil), max_response_size: T.unsafe(nil), **kwargs); end

  # Returns the value of attribute bytes_read.
  #
  # source://net-imap//lib/net/imap/errors.rb#26
  def bytes_read; end

  # Returns the value of attribute literal_size.
  #
  # source://net-imap//lib/net/imap/errors.rb#26
  def literal_size; end

  # Returns the value of attribute max_response_size.
  #
  # source://net-imap//lib/net/imap/errors.rb#27
  def max_response_size; end

  private

  # source://net-imap//lib/net/imap/errors.rb#46
  def response_size_msg; end
end

# Pluggable authentication mechanisms for protocols which support SASL
# (Simple Authentication and Security Layer), such as IMAP4, SMTP, LDAP, and
# XMPP.  {RFC-4422}[https://www.rfc-editor.org/rfc/rfc4422] specifies the
# common \SASL framework:
# >>>
#   SASL is conceptually a framework that provides an abstraction layer
#   between protocols and mechanisms as illustrated in the following
#   diagram.
#
#               SMTP    LDAP    XMPP   Other protocols ...
#                  \       |    |      /
#                   \      |    |     /
#                  SASL abstraction layer
#                   /      |    |     \
#                  /       |    |      \
#           EXTERNAL   GSSAPI  PLAIN   Other mechanisms ...
#
# Net::IMAP uses SASL via the Net::IMAP#authenticate method.
#
# == Mechanisms
#
# Each mechanism has different properties and requirements.  Please consult
# the documentation for the specific mechanisms you are using:
#
# +ANONYMOUS+::
#     See AnonymousAuthenticator.
#
#     Allows the user to gain access to public services or resources without
#     authenticating or disclosing an identity.
#
# +EXTERNAL+::
#     See ExternalAuthenticator.
#
#     Authenticates using already established credentials, such as a TLS
#     certificate or IPSec.
#
# +OAUTHBEARER+::
#     See OAuthBearerAuthenticator.
#
#     Login using an OAuth2 Bearer token.  This is the standard mechanism
#     for using OAuth2 with \SASL, but it is not yet deployed as widely as
#     +XOAUTH2+.
#
# +PLAIN+::
#     See PlainAuthenticator.
#
#     Login using clear-text username and password.
#
# +SCRAM-SHA-1+::
# +SCRAM-SHA-256+::
#     See ScramAuthenticator.
#
#     Login by username and password.  The password is not sent to the
#     server but is used in a salted challenge/response exchange.
#     +SCRAM-SHA-1+ and +SCRAM-SHA-256+ are directly supported by
#     Net::IMAP::SASL.  New authenticators can easily be added for any other
#     <tt>SCRAM-*</tt> mechanism if the digest algorithm is supported by
#     OpenSSL::Digest.
#
# +XOAUTH2+::
#     See XOAuth2Authenticator.
#
#     Login using a username and an OAuth2 access token.  Non-standard and
#     obsoleted by +OAUTHBEARER+, but widely supported.
#
# See the {SASL mechanism
# registry}[https://www.iana.org/assignments/sasl-mechanisms/sasl-mechanisms.xhtml]
# for a list of all SASL mechanisms and their specifications.  To register
# new authenticators, see Authenticators.
#
# === Deprecated mechanisms
#
# <em>Obsolete mechanisms should be avoided, but are still available for
# backwards compatibility.</em>
#
# >>>
#   For +DIGEST-MD5+ see DigestMD5Authenticator.
#
#   For +LOGIN+, see LoginAuthenticator.
#
#   For +CRAM-MD5+, see CramMD5Authenticator.
#
# <em>Using a deprecated mechanism will print a warning.</em>
#
# source://net-imap//lib/net/imap/sasl.rb#90
module Net::IMAP::SASL
  private

  # See Net::IMAP::StringPrep::SASLprep#saslprep.
  #
  # source://net-imap//lib/net/imap/sasl.rb#176
  def saslprep(string, **opts); end

  class << self
    # Delegates to ::authenticators.  See Authenticators#add_authenticator.
    #
    # source://net-imap//lib/net/imap/sasl.rb#171
    def add_authenticator(*_arg0, **_arg1, &_arg2); end

    # Creates a new SASL authenticator, using SASL::Authenticators#new.
    #
    # +registry+ defaults to SASL.authenticators.  All other arguments are
    # forwarded to to <tt>registry.new</tt>.
    #
    # source://net-imap//lib/net/imap/sasl.rb#166
    def authenticator(*args, registry: T.unsafe(nil), **kwargs, &block); end

    # Returns the default global SASL::Authenticators instance.
    #
    # source://net-imap//lib/net/imap/sasl.rb#160
    def authenticators; end

    # See Net::IMAP::StringPrep::SASLprep#saslprep.
    #
    # source://net-imap//lib/net/imap/sasl.rb#176
    def saslprep(string, **opts); end
  end
end

# Authenticator for the "+ANONYMOUS+" SASL mechanism, as specified by
# RFC-4505[https://www.rfc-editor.org/rfc/rfc4505].  See
# Net::IMAP#authenticate.
#
# source://net-imap//lib/net/imap/sasl/anonymous_authenticator.rb#10
class Net::IMAP::SASL::AnonymousAuthenticator
  # :call-seq:
  #   new(anonymous_message = "", **) -> authenticator
  #   new(anonymous_message:  "", **) -> authenticator
  #
  # Creates an Authenticator for the "+ANONYMOUS+" SASL mechanism, as
  # specified in RFC-4505[https://www.rfc-editor.org/rfc/rfc4505].  To use
  # this, see Net::IMAP#authenticate or your client's authentication
  # method.
  #
  # ==== Parameters
  #
  # * _optional_ #anonymous_message — a message to send to the server.
  #
  # Any other keyword arguments are silently ignored.
  #
  # @return [AnonymousAuthenticator] a new instance of AnonymousAuthenticator
  #
  # source://net-imap//lib/net/imap/sasl/anonymous_authenticator.rb#37
  def initialize(anon_msg = T.unsafe(nil), anonymous_message: T.unsafe(nil), **_arg2); end

  # An optional token sent for the +ANONYMOUS+ mechanism., up to 255 UTF-8
  # characters in length.
  #
  # If it contains an "@" sign, the message must be a valid email address
  # (+addr-spec+ from RFC-2822[https://www.rfc-editor.org/rfc/rfc2822]).
  # Email syntax is _not_ validated by AnonymousAuthenticator.
  #
  # Otherwise, it can be any UTF8 string which is permitted by the
  # StringPrep::Trace profile.
  #
  # source://net-imap//lib/net/imap/sasl/anonymous_authenticator.rb#21
  def anonymous_message; end

  # Returns true when the initial client response was sent.
  #
  # The authentication should not succeed unless this returns true, but it
  # does *not* indicate success.
  #
  # @return [Boolean]
  #
  # source://net-imap//lib/net/imap/sasl/anonymous_authenticator.rb#64
  def done?; end

  # :call-seq:
  #   initial_response? -> true
  #
  # +ANONYMOUS+ can send an initial client response.
  #
  # @return [Boolean]
  #
  # source://net-imap//lib/net/imap/sasl/anonymous_authenticator.rb#51
  def initial_response?; end

  # Returns #anonymous_message.
  #
  # source://net-imap//lib/net/imap/sasl/anonymous_authenticator.rb#54
  def process(_server_challenge_string); end
end

# Indicates an authentication exchange that will be or has been canceled
# by the client, not due to any error or failure during processing.
#
# source://net-imap//lib/net/imap/sasl.rb#106
class Net::IMAP::SASL::AuthenticationCanceled < ::Net::IMAP::SASL::Error; end

# Indicates an error when processing a server challenge, e.g: an invalid
# or unparsable challenge.  An underlying exception may be available as
# the exception's #cause.
#
# source://net-imap//lib/net/imap/sasl.rb#111
class Net::IMAP::SASL::AuthenticationError < ::Net::IMAP::SASL::Error; end

# AuthenticationExchange is used internally by Net::IMAP#authenticate.
# But the API is still *experimental*, and may change.
#
# TODO: catch exceptions in #process and send #cancel_response.
# TODO: raise an error if the command succeeds after being canceled.
# TODO: use with more clients, to verify the API can accommodate them.
# TODO: pass ClientAdapter#service to SASL.authenticator
#
# An AuthenticationExchange represents a single attempt to authenticate
# a SASL client to a SASL server.  It is created from a client adapter, a
# mechanism name, and a mechanism authenticator.  When #authenticate is
# called, it will send the appropriate authenticate command to the server,
# returning the client response on success and raising an exception on
# failure.
#
# In most cases, the client will not need to use
# SASL::AuthenticationExchange directly at all.  Instead, use
# SASL::ClientAdapter#authenticate.  If customizations are needed, the
# custom client adapter is probably the best place for that code.
#
#     def authenticate(...)
#       MyClient::SASLAdapter.new(self).authenticate(...)
#     end
#
# SASL::ClientAdapter#authenticate delegates to ::authenticate, like so:
#
#     def authenticate(...)
#       sasl_adapter = MyClient::SASLAdapter.new(self)
#       SASL::AuthenticationExchange.authenticate(sasl_adapter, ...)
#     end
#
# ::authenticate simply delegates to ::build and #authenticate, like so:
#
#     def authenticate(...)
#       sasl_adapter = MyClient::SASLAdapter.new(self)
#       SASL::AuthenticationExchange
#         .build(sasl_adapter, ...)
#         .authenticate
#     end
#
# And ::build delegates to SASL.authenticator and ::new, like so:
#
#     def authenticate(mechanism, ...)
#       sasl_adapter = MyClient::SASLAdapter.new(self)
#       authenticator = SASL.authenticator(mechanism, ...)
#       SASL::AuthenticationExchange
#         .new(sasl_adapter, mechanism, authenticator)
#         .authenticate
#     end
#
# source://net-imap//lib/net/imap/sasl/authentication_exchange.rb#57
class Net::IMAP::SASL::AuthenticationExchange
  # @return [AuthenticationExchange] a new instance of AuthenticationExchange
  #
  # source://net-imap//lib/net/imap/sasl/authentication_exchange.rb#84
  def initialize(client, mechanism, authenticator, sasl_ir: T.unsafe(nil)); end

  # Call #authenticate to execute an authentication exchange for #client
  # using #authenticator.  Authentication failures will raise an
  # exception.  Any exceptions other than those in RESPONSE_ERRORS will
  # drop the connection.
  #
  # source://net-imap//lib/net/imap/sasl/authentication_exchange.rb#96
  def authenticate; end

  # Returns the value of attribute authenticator.
  #
  # source://net-imap//lib/net/imap/sasl/authentication_exchange.rb#82
  def authenticator; end

  # @return [Boolean]
  #
  # source://net-imap//lib/net/imap/sasl/authentication_exchange.rb#117
  def done?; end

  # Returns the value of attribute mechanism.
  #
  # source://net-imap//lib/net/imap/sasl/authentication_exchange.rb#82
  def mechanism; end

  # @return [Boolean]
  #
  # source://net-imap//lib/net/imap/sasl/authentication_exchange.rb#109
  def send_initial_response?; end

  private

  # Returns the value of attribute client.
  #
  # source://net-imap//lib/net/imap/sasl/authentication_exchange.rb#123
  def client; end

  # source://net-imap//lib/net/imap/sasl/authentication_exchange.rb#125
  def initial_response; end

  # source://net-imap//lib/net/imap/sasl/authentication_exchange.rb#130
  def process(challenge); end

  class << self
    # Convenience method for <tt>build(...).authenticate</tt>
    #
    # See also: SASL::ClientAdapter#authenticate
    #
    # source://net-imap//lib/net/imap/sasl/authentication_exchange.rb#61
    def authenticate(*_arg0, **_arg1, &_arg2); end

    # Convenience method to combine the creation of a new authenticator and
    # a new Authentication exchange.
    #
    # +client+ must be an instance of SASL::ClientAdapter.
    #
    # +mechanism+ must be a SASL mechanism name, as a string or symbol.
    #
    # +sasl_ir+ allows or disallows sending an "initial response", depending
    # also on whether the server capabilities, mechanism authenticator, and
    # client adapter all support it.  Defaults to +true+.
    #
    # +mechanism+, +args+, +kwargs+, and +block+ are all forwarded to
    # SASL.authenticator.  Use the +registry+ kwarg to override the global
    # SASL::Authenticators registry.
    #
    # source://net-imap//lib/net/imap/sasl/authentication_exchange.rb#77
    def build(client, mechanism, *args, sasl_ir: T.unsafe(nil), **kwargs, &block); end
  end
end

# Indicates that authentication cannot proceed because one of the server's
# messages has not passed integrity checks.
#
# source://net-imap//lib/net/imap/sasl.rb#115
class Net::IMAP::SASL::AuthenticationFailed < ::Net::IMAP::SASL::Error; end

# Indicates that authentication cannot proceed because the server ended
# authentication prematurely.
#
# source://net-imap//lib/net/imap/sasl.rb#119
class Net::IMAP::SASL::AuthenticationIncomplete < ::Net::IMAP::SASL::AuthenticationFailed
  # @return [AuthenticationIncomplete] a new instance of AuthenticationIncomplete
  #
  # source://net-imap//lib/net/imap/sasl.rb#123
  def initialize(response, message = T.unsafe(nil)); end

  # The success response from the server
  #
  # source://net-imap//lib/net/imap/sasl.rb#121
  def response; end
end

# Registry for SASL authenticators
#
# Registered authenticators must respond to +#new+ or +#call+ (e.g. a class or
# a proc), receiving any credentials and options and returning an
# authenticator instance. The returned object represents a single
# authentication exchange and <em>must not</em> be reused for multiple
# authentication attempts.
#
# An authenticator instance object must respond to +#process+, receiving the
# server's challenge and returning the client's response.  Optionally, it may
# also respond to +#initial_response?+ and +#done?+.  When
# +#initial_response?+ returns +true+, +#process+ may be called the first
# time with +nil+.  When +#done?+ returns +false+, the exchange is incomplete
# and an exception should be raised if the exchange terminates prematurely.
#
# See the source for PlainAuthenticator, XOAuth2Authenticator, and
# ScramSHA1Authenticator for examples.
#
# source://net-imap//lib/net/imap/sasl/authenticators.rb#22
class Net::IMAP::SASL::Authenticators
  # Create a new Authenticators registry.
  #
  # This class is usually not instantiated directly.  Use SASL.authenticators
  # to reuse the default global registry.
  #
  # When +use_defaults+ is +false+, the registry will start empty.  When
  # +use_deprecated+ is +false+, deprecated authenticators will not be
  # included with the defaults.
  #
  # @return [Authenticators] a new instance of Authenticators
  #
  # source://net-imap//lib/net/imap/sasl/authenticators.rb#36
  def initialize(use_defaults: T.unsafe(nil), use_deprecated: T.unsafe(nil)); end

  # :call-seq:
  #   add_authenticator(mechanism)
  #   add_authenticator(mechanism, authenticator_class)
  #   add_authenticator(mechanism, authenticator_proc)
  #
  # Registers an authenticator for #authenticator to use.  +mechanism+ is the
  # name of the
  # {SASL mechanism}[https://www.iana.org/assignments/sasl-mechanisms/sasl-mechanisms.xhtml]
  # implemented by +authenticator_class+ (for instance, <tt>"PLAIN"</tt>).
  #
  # If +mechanism+ refers to an existing authenticator,
  # the old authenticator will be replaced.
  #
  # When only a single argument is given, the authenticator class will be
  # lazily loaded from <tt>Net::IMAP::SASL::#{name}Authenticator</tt> (case is
  # preserved and non-alphanumeric characters are removed..
  #
  # source://net-imap//lib/net/imap/sasl/authenticators.rb#71
  def add_authenticator(name, authenticator = T.unsafe(nil)); end

  # :call-seq:
  #   authenticator(mechanism, ...) -> auth_session
  #
  # Builds an authenticator instance using the authenticator registered to
  # +mechanism+.  The returned object represents a single authentication
  # exchange and <em>must not</em> be reused for multiple authentication
  # attempts.
  #
  # All arguments (except +mechanism+) are forwarded to the registered
  # authenticator's +#new+ or +#call+ method.  Each authenticator must
  # document its own arguments.
  #
  # [Note]
  #   This method is intended for internal use by connection protocol code
  #   only.  Protocol client users should see refer to their client's
  #   documentation, e.g. Net::IMAP#authenticate.
  #
  # source://net-imap//lib/net/imap/sasl/authenticators.rb#111
  def authenticator(mechanism, *_arg1, **_arg2, &_arg3); end

  # @return [Boolean]
  #
  # source://net-imap//lib/net/imap/sasl/authenticators.rb#90
  def mechanism?(name); end

  # Returns the names of all registered SASL mechanisms.
  #
  # source://net-imap//lib/net/imap/sasl/authenticators.rb#53
  def names; end

  # :call-seq:
  #   authenticator(mechanism, ...) -> auth_session
  #
  # Builds an authenticator instance using the authenticator registered to
  # +mechanism+.  The returned object represents a single authentication
  # exchange and <em>must not</em> be reused for multiple authentication
  # attempts.
  #
  # All arguments (except +mechanism+) are forwarded to the registered
  # authenticator's +#new+ or +#call+ method.  Each authenticator must
  # document its own arguments.
  #
  # [Note]
  #   This method is intended for internal use by connection protocol code
  #   only.  Protocol client users should see refer to their client's
  #   documentation, e.g. Net::IMAP#authenticate.
  #
  # source://net-imap//lib/net/imap/sasl/authenticators.rb#118
  def new(mechanism, *_arg1, **_arg2, &_arg3); end

  # Removes the authenticator registered for +name+
  #
  # source://net-imap//lib/net/imap/sasl/authenticators.rb#85
  def remove_authenticator(name); end

  class << self
    # Normalize the mechanism name as an uppercase string, with underscores
    # converted to dashes.
    #
    # source://net-imap//lib/net/imap/sasl/authenticators.rb#26
    def normalize_name(mechanism); end
  end
end

# source://net-imap//lib/net/imap/sasl/stringprep.rb#8
Net::IMAP::SASL::BidiStringError = Net::IMAP::StringPrep::BidiStringError

# This API is *experimental*, and may change.
#
# TODO: use with more clients, to verify the API can accommodate them.
#
# Represents the client to a SASL::AuthenticationExchange.  By default,
# most methods simply delegate to #client.  Clients should subclass
# SASL::ClientAdapter and override methods as needed to match the
# semantics of this API to their API.
#
# Subclasses should also include a protocol adapter mixin when the default
# ProtocolAdapters::Generic isn't sufficient.
#
# === Protocol Requirements
#
# {RFC4422 §4}[https://www.rfc-editor.org/rfc/rfc4422.html#section-4]
# lists requirements for protocol specifications to offer SASL.  Where
# possible, ClientAdapter delegates the handling of these requirements to
# SASL::ProtocolAdapters.
#
# source://net-imap//lib/net/imap/sasl/client_adapter.rb#27
class Net::IMAP::SASL::ClientAdapter
  include ::Net::IMAP::SASL::ProtocolAdapters::Generic
  extend ::Forwardable

  # By default, this simply sets the #client and #command_proc attributes.
  # Subclasses may override it, for example: to set the appropriate
  # command_proc automatically.
  #
  # @return [ClientAdapter] a new instance of ClientAdapter
  #
  # source://net-imap//lib/net/imap/sasl/client_adapter.rb#56
  def initialize(client, &command_proc); end

  # source://net-imap//lib/net/imap/sasl/client_adapter.rb#76
  def auth_capable?(*args, **_arg1, &block); end

  # Attempt to authenticate #client to the server.
  #
  # By default, this simply delegates to
  # AuthenticationExchange.authenticate.
  #
  # source://net-imap//lib/net/imap/sasl/client_adapter.rb#64
  def authenticate(*_arg0, **_arg1, &_arg2); end

  # method: drop_connection!
  # Drop the connection abruptly, closing the socket without logging out.
  #
  # source://net-imap//lib/net/imap/sasl/client_adapter.rb#35
  def client; end

  # +command_proc+ can used to avoid exposing private methods on #client.
  # It's value is set by the block that is passed to ::new, and it is used
  # by the default implementation of #run_command.  Subclasses that
  # override #run_command may use #command_proc for any other purpose they
  # find useful.
  #
  # In the default implementation of #run_command, command_proc is called
  # with the protocols authenticate +command+ name, the +mechanism+ name,
  # an _optional_ +initial_response+ argument, and a +continuations+
  # block.  command_proc must run the protocol command with the arguments
  # sent to it, _yield_ the payload of each continuation, respond to the
  # continuation with the result of each _yield_, and _return_ the
  # command's successful result.  Non-successful results *MUST* raise
  # an exception.
  #
  # source://net-imap//lib/net/imap/sasl/client_adapter.rb#51
  def command_proc; end

  # source://net-imap//lib/net/imap/sasl/client_adapter.rb#113
  def drop_connection(*args, **_arg1, &block); end

  # source://net-imap//lib/net/imap/sasl/client_adapter.rb#118
  def drop_connection!(*args, **_arg1, &block); end

  # source://net-imap//lib/net/imap/sasl/client_adapter.rb#99
  def host(*args, **_arg1, &block); end

  # source://net-imap//lib/net/imap/sasl/client_adapter.rb#104
  def port(*args, **_arg1, &block); end

  # Returns an array of server responses errors raised by run_command.
  # Exceptions in this array won't drop the connection.
  #
  # source://net-imap//lib/net/imap/sasl/client_adapter.rb#108
  def response_errors; end

  # Calls command_proc with +command_name+ (see
  # SASL::ProtocolAdapters::Generic#command_name),
  # +mechanism+, +initial_response+, and a +continuations_handler+ block.
  # The +initial_response+ is optional; when it's nil, it won't be sent to
  # command_proc.
  #
  # Yields each continuation payload, responds to the server with the
  # result of each yield, and returns the result.  Non-successful results
  # *MUST* raise an exception.  Exceptions in the block *MUST* cause the
  # command to fail.
  #
  # Subclasses that override this may use #command_proc differently.
  #
  # source://net-imap//lib/net/imap/sasl/client_adapter.rb#90
  def run_command(mechanism, initial_response = T.unsafe(nil), &continuations_handler); end

  # source://net-imap//lib/net/imap/sasl/client_adapter.rb#69
  def sasl_ir_capable?(*args, **_arg1, &block); end
end

# Authenticator for the "+CRAM-MD5+" SASL mechanism, specified in
# RFC2195[https://www.rfc-editor.org/rfc/rfc2195].  See Net::IMAP#authenticate.
#
# == Deprecated
#
# +CRAM-MD5+ is obsolete and insecure.  It is included for compatibility with
# existing servers.
# {draft-ietf-sasl-crammd5-to-historic}[https://www.rfc-editor.org/rfc/draft-ietf-sasl-crammd5-to-historic-00.html]
# recommends using +SCRAM-*+ or +PLAIN+ protected by TLS instead.
#
# Additionally, RFC8314[https://www.rfc-editor.org/rfc/rfc8314] discourage the use
# of cleartext and recommends TLS version 1.2 or greater be used for all
# traffic.  With TLS +CRAM-MD5+ is okay, but so is +PLAIN+
#
# source://net-imap//lib/net/imap/sasl/cram_md5_authenticator.rb#16
class Net::IMAP::SASL::CramMD5Authenticator
  # @return [CramMD5Authenticator] a new instance of CramMD5Authenticator
  #
  # source://net-imap//lib/net/imap/sasl/cram_md5_authenticator.rb#17
  def initialize(user = T.unsafe(nil), pass = T.unsafe(nil), authcid: T.unsafe(nil), username: T.unsafe(nil), password: T.unsafe(nil), secret: T.unsafe(nil), warn_deprecation: T.unsafe(nil), **_arg7); end

  # @return [Boolean]
  #
  # source://net-imap//lib/net/imap/sasl/cram_md5_authenticator.rb#40
  def done?; end

  # @return [Boolean]
  #
  # source://net-imap//lib/net/imap/sasl/cram_md5_authenticator.rb#31
  def initial_response?; end

  # source://net-imap//lib/net/imap/sasl/cram_md5_authenticator.rb#33
  def process(challenge); end

  private

  # source://net-imap//lib/net/imap/sasl/cram_md5_authenticator.rb#44
  def hmac_md5(text, key); end
end

# Net::IMAP authenticator for the +DIGEST-MD5+ SASL mechanism type, specified
# in RFC-2831[https://www.rfc-editor.org/rfc/rfc2831].  See Net::IMAP#authenticate.
#
# == Deprecated
#
# "+DIGEST-MD5+" has been deprecated by
# RFC-6331[https://www.rfc-editor.org/rfc/rfc6331] and should not be relied on for
# security.  It is included for compatibility with existing servers.
#
# source://net-imap//lib/net/imap/sasl/digest_md5_authenticator.rb#11
class Net::IMAP::SASL::DigestMD5Authenticator
  # :call-seq:
  #   new(username,  password,  authzid = nil, **options) -> authenticator
  #   new(username:, password:, authzid:  nil, **options) -> authenticator
  #   new(authcid:,  password:, authzid:  nil, **options) -> authenticator
  #
  # Creates an Authenticator for the "+DIGEST-MD5+" SASL mechanism.
  #
  # Called by Net::IMAP#authenticate and similar methods on other clients.
  #
  # ==== Parameters
  #
  # * #authcid  ― Authentication identity that is associated with #password.
  #
  #   #username ― An alias for +authcid+.
  #
  # * #password ― A password or passphrase associated with this #authcid.
  #
  # * _optional_ #authzid  ― Authorization identity to act as or on behalf of.
  #
  #   When +authzid+ is not set, the server should derive the authorization
  #   identity from the authentication identity.
  #
  # * _optional_ #realm — A namespace for the #username, e.g. a domain.
  #   <em>Defaults to the last realm in the server-provided realms list.</em>
  # * _optional_ #host — FQDN for requested service.
  #   <em>Defaults to</em> #realm.
  # * _optional_ #service_name — The generic host name when the server is
  #   replicated.
  # * _optional_ #service — the registered service protocol.  E.g. "imap",
  #   "smtp", "ldap", "xmpp".
  #   <em>For Net::IMAP, this defaults to "imap".</em>
  #
  # * _optional_ +warn_deprecation+ — Set to +false+ to silence the warning.
  #
  # Any other keyword arguments are silently ignored.
  #
  # @return [DigestMD5Authenticator] a new instance of DigestMD5Authenticator
  #
  # source://net-imap//lib/net/imap/sasl/digest_md5_authenticator.rb#154
  def initialize(user = T.unsafe(nil), pass = T.unsafe(nil), authz = T.unsafe(nil), username: T.unsafe(nil), password: T.unsafe(nil), authzid: T.unsafe(nil), authcid: T.unsafe(nil), secret: T.unsafe(nil), realm: T.unsafe(nil), service: T.unsafe(nil), host: T.unsafe(nil), service_name: T.unsafe(nil), warn_deprecation: T.unsafe(nil), **_arg13); end

  # Authentication identity: the identity that matches the #password.
  #
  # RFC-2831[https://www.rfc-editor.org/rfc/rfc2831] uses the term +username+.
  # "Authentication identity" is the generic term used by
  # RFC-4422[https://www.rfc-editor.org/rfc/rfc4422].
  # RFC-4616[https://www.rfc-editor.org/rfc/rfc4616] and many later RFCs abbreviate
  # this to +authcid+.
  #
  # source://net-imap//lib/net/imap/sasl/digest_md5_authenticator.rb#46
  def authcid; end

  # Authorization identity: an identity to act as or on behalf of.  The identity
  # form is application protocol specific.  If not provided or left blank, the
  # server derives an authorization identity from the authentication identity.
  # The server is responsible for verifying the client's credentials and
  # verifying that the identity it associates with the client's authentication
  # identity is allowed to act as (or on behalf of) the authorization identity.
  #
  # For example, an administrator or superuser might take on another role:
  #
  #     imap.authenticate "DIGEST-MD5", "root", ->{passwd}, authzid: "user"
  #
  # source://net-imap//lib/net/imap/sasl/digest_md5_authenticator.rb#64
  def authzid; end

  # The charset sent by the server.  "UTF-8" (case insensitive) is the only
  # allowed value.  +nil+ should be interpreted as ISO 8859-1.
  #
  # source://net-imap//lib/net/imap/sasl/digest_md5_authenticator.rb#111
  def charset; end

  # From RFC-2831[https://www.rfc-editor.org/rfc/rfc2831]:
  # >>>
  #     Indicates the principal name of the service with which the client wishes
  #     to connect, formed from the serv-type, host, and serv-name.  For
  #     example, the FTP service on "ftp.example.com" would have a "digest-uri"
  #     value of "ftp/ftp.example.com"; the SMTP server from the example above
  #     would have a "digest-uri" value of "smtp/mail3.example.com/example.com".
  #
  # source://net-imap//lib/net/imap/sasl/digest_md5_authenticator.rb#186
  def digest_uri; end

  # @return [Boolean]
  #
  # source://net-imap//lib/net/imap/sasl/digest_md5_authenticator.rb#246
  def done?; end

  # Fully qualified canonical DNS host name for the requested service.
  #
  # <em>Defaults to #realm.</em>
  #
  # source://net-imap//lib/net/imap/sasl/digest_md5_authenticator.rb#78
  def host; end

  # @return [Boolean]
  #
  # source://net-imap//lib/net/imap/sasl/digest_md5_authenticator.rb#194
  def initial_response?; end

  # nonce sent by the server
  #
  # source://net-imap//lib/net/imap/sasl/digest_md5_authenticator.rb#114
  def nonce; end

  # A password or passphrase that matches the #username.
  #
  # The +password+ will be used to create the response digest.
  #
  # source://net-imap//lib/net/imap/sasl/digest_md5_authenticator.rb#51
  def password; end

  # Responds to server challenge in two stages.
  #
  # source://net-imap//lib/net/imap/sasl/digest_md5_authenticator.rb#197
  def process(challenge); end

  # qop-options sent by the server
  #
  # source://net-imap//lib/net/imap/sasl/digest_md5_authenticator.rb#117
  def qop; end

  # A namespace or collection of identities which contains +username+.
  #
  # Used by DIGEST-MD5, GSS-API, and NTLM.  This is often a domain name that
  # contains the name of the host performing the authentication.
  #
  # <em>Defaults to the last realm in the server-provided list of
  # realms.</em>
  #
  # source://net-imap//lib/net/imap/sasl/digest_md5_authenticator.rb#73
  def realm; end

  # The service protocol, a
  # {registered GSSAPI service name}[https://www.iana.org/assignments/gssapi-service-names/gssapi-service-names.xhtml],
  # e.g. "imap", "ldap", or "xmpp".
  #
  # For Net::IMAP, the default is "imap" and should not be overridden.  This
  # must be set appropriately to use authenticators in other protocols.
  #
  # If an IANA-registered name isn't available, GSS-API
  # (RFC-2743[https://www.rfc-editor.org/rfc/rfc2743]) allows the generic name
  # "host".
  #
  # source://net-imap//lib/net/imap/sasl/digest_md5_authenticator.rb#90
  def service; end

  # The generic server name when the server is replicated.
  #
  # +service_name+ will be ignored when it is +nil+ or identical to +host+.
  #
  # From RFC-2831[https://www.rfc-editor.org/rfc/rfc2831]:
  # >>>
  #     The service is considered to be replicated if the client's
  #     service-location process involves resolution using standard DNS lookup
  #     operations, and if these operations involve DNS records (such as SRV, or
  #     MX) which resolve one DNS name into a set of other DNS names.  In this
  #     case, the initial name used by the client is the "serv-name", and the
  #     final name is the "host" component.
  #
  # source://net-imap//lib/net/imap/sasl/digest_md5_authenticator.rb#104
  def service_name; end

  # Parameters sent by the server are stored in this hash.
  #
  # source://net-imap//lib/net/imap/sasl/digest_md5_authenticator.rb#107
  def sparams; end

  # Authentication identity: the identity that matches the #password.
  #
  # RFC-2831[https://www.rfc-editor.org/rfc/rfc2831] uses the term +username+.
  # "Authentication identity" is the generic term used by
  # RFC-4422[https://www.rfc-editor.org/rfc/rfc4422].
  # RFC-4616[https://www.rfc-editor.org/rfc/rfc4616] and many later RFCs abbreviate
  # this to +authcid+.
  #
  # source://net-imap//lib/net/imap/sasl/digest_md5_authenticator.rb#45
  def username; end

  private

  # source://net-imap//lib/net/imap/sasl/digest_md5_authenticator.rb#306
  def compute_a0(response); end

  # source://net-imap//lib/net/imap/sasl/digest_md5_authenticator.rb#312
  def compute_a1(response); end

  # source://net-imap//lib/net/imap/sasl/digest_md5_authenticator.rb#319
  def compute_a2(response); end

  # source://net-imap//lib/net/imap/sasl/digest_md5_authenticator.rb#327
  def format_response(response); end

  # source://net-imap//lib/net/imap/sasl/digest_md5_authenticator.rb#286
  def nc(nonce); end

  # source://net-imap//lib/net/imap/sasl/digest_md5_authenticator.rb#259
  def parse_challenge(challenge); end

  # some responses need quoting
  #
  # source://net-imap//lib/net/imap/sasl/digest_md5_authenticator.rb#332
  def qdval(k, v); end

  # source://net-imap//lib/net/imap/sasl/digest_md5_authenticator.rb#294
  def response_value(response); end

  # source://net-imap//lib/net/imap/sasl/digest_md5_authenticator.rb#280
  def split_quoted_list(value, challenge); end
end

# source://net-imap//lib/net/imap/sasl/digest_md5_authenticator.rb#254
Net::IMAP::SASL::DigestMD5Authenticator::AUTH_PARAM = T.let(T.unsafe(nil), Regexp)

# source://net-imap//lib/net/imap/sasl/digest_md5_authenticator.rb#12
Net::IMAP::SASL::DigestMD5Authenticator::DataFormatError = Net::IMAP::DataFormatError

# source://net-imap//lib/net/imap/sasl/digest_md5_authenticator.rb#253
Net::IMAP::SASL::DigestMD5Authenticator::LIST_DELIM = T.let(T.unsafe(nil), Regexp)

# less strict than RFC, more strict than '\s'
#
# source://net-imap//lib/net/imap/sasl/digest_md5_authenticator.rb#250
Net::IMAP::SASL::DigestMD5Authenticator::LWS = T.let(T.unsafe(nil), Regexp)

# Directives which must not have multiples.  The RFC states:
# >>>
#   This directive may appear at most once; if multiple instances are present,
#   the client should abort the authentication exchange.
#
# source://net-imap//lib/net/imap/sasl/digest_md5_authenticator.rb#25
Net::IMAP::SASL::DigestMD5Authenticator::NO_MULTIPLES = T.let(T.unsafe(nil), Array)

# Directives which are composed of one or more comma delimited tokens
#
# source://net-imap//lib/net/imap/sasl/digest_md5_authenticator.rb#34
Net::IMAP::SASL::DigestMD5Authenticator::QUOTED_LISTABLE = T.let(T.unsafe(nil), Array)

# source://net-imap//lib/net/imap/sasl/digest_md5_authenticator.rb#252
Net::IMAP::SASL::DigestMD5Authenticator::QUOTED_STR = T.let(T.unsafe(nil), Regexp)

# Required directives which must occur exactly once.  The RFC states: >>>
#   This directive is required and MUST appear exactly once; if not present,
#   or if multiple instances are present, the client should abort the
#   authentication exchange.
#
# source://net-imap//lib/net/imap/sasl/digest_md5_authenticator.rb#31
Net::IMAP::SASL::DigestMD5Authenticator::REQUIRED = T.let(T.unsafe(nil), Array)

# source://net-imap//lib/net/imap/sasl/digest_md5_authenticator.rb#13
Net::IMAP::SASL::DigestMD5Authenticator::ResponseParseError = Net::IMAP::ResponseParseError

# source://net-imap//lib/net/imap/sasl/digest_md5_authenticator.rb#18
Net::IMAP::SASL::DigestMD5Authenticator::STAGE_DONE = T.let(T.unsafe(nil), Symbol)

# source://net-imap//lib/net/imap/sasl/digest_md5_authenticator.rb#16
Net::IMAP::SASL::DigestMD5Authenticator::STAGE_ONE = T.let(T.unsafe(nil), Symbol)

# source://net-imap//lib/net/imap/sasl/digest_md5_authenticator.rb#17
Net::IMAP::SASL::DigestMD5Authenticator::STAGE_TWO = T.let(T.unsafe(nil), Symbol)

# source://net-imap//lib/net/imap/sasl/digest_md5_authenticator.rb#251
Net::IMAP::SASL::DigestMD5Authenticator::TOKEN = T.let(T.unsafe(nil), Regexp)

# Exception class for any client error detected during the authentication
# exchange.
#
# When the _server_ reports an authentication failure, it will respond
# with a protocol specific error instead, e.g: +BAD+ or +NO+ in IMAP.
#
# When the client encounters any error, it *must* consider the
# authentication exchange to be unsuccessful and it might need to drop the
# connection.  For example, if the server reports that the authentication
# exchange was successful or the protocol does not allow additional
# authentication attempts.
#
# source://net-imap//lib/net/imap/sasl.rb#102
class Net::IMAP::SASL::Error < ::StandardError; end

# Authenticator for the "+EXTERNAL+" SASL mechanism, as specified by
# RFC-4422[https://www.rfc-editor.org/rfc/rfc4422].  See
# Net::IMAP#authenticate.
#
# The EXTERNAL mechanism requests that the server use client credentials
# established external to SASL, for example by TLS certificate or IPSec.
#
# source://net-imap//lib/net/imap/sasl/external_authenticator.rb#13
class Net::IMAP::SASL::ExternalAuthenticator
  # :call-seq:
  #   new(authzid: nil, **) -> authenticator
  #   new(username: nil, **) -> authenticator
  #   new(username = nil, **) -> authenticator
  #
  # Creates an Authenticator for the "+EXTERNAL+" SASL mechanism, as
  # specified in RFC-4422[https://www.rfc-editor.org/rfc/rfc4422].  To use
  # this, see Net::IMAP#authenticate or your client's authentication
  # method.
  #
  # ==== Parameters
  #
  # * _optional_ #authzid  ― Authorization identity to act as or on behalf of.
  #
  #   _optional_ #username ― An alias for #authzid.
  #
  #   Note that, unlike some other authenticators, +username+ sets the
  #   _authorization_ identity and not the _authentication_ identity.  The
  #   authentication identity is established for the client by the
  #   external credentials.
  #
  # Any other keyword parameters are quietly ignored.
  #
  # @return [ExternalAuthenticator] a new instance of ExternalAuthenticator
  #
  # source://net-imap//lib/net/imap/sasl/external_authenticator.rb#52
  def initialize(user = T.unsafe(nil), authzid: T.unsafe(nil), username: T.unsafe(nil), **_arg3); end

  # Authorization identity: an identity to act as or on behalf of.  The
  # identity form is application protocol specific.  If not provided or
  # left blank, the server derives an authorization identity from the
  # authentication identity.  The server is responsible for verifying the
  # client's credentials and verifying that the identity it associates
  # with the client's authentication identity is allowed to act as (or on
  # behalf of) the authorization identity.
  #
  # For example, an administrator or superuser might take on another role:
  #
  #     imap.authenticate "PLAIN", "root", passwd, authzid: "user"
  #
  # source://net-imap//lib/net/imap/sasl/external_authenticator.rb#27
  def authzid; end

  # Returns true when the initial client response was sent.
  #
  # The authentication should not succeed unless this returns true, but it
  # does *not* indicate success.
  #
  # @return [Boolean]
  #
  # source://net-imap//lib/net/imap/sasl/external_authenticator.rb#78
  def done?; end

  # :call-seq:
  #   initial_response? -> true
  #
  # +EXTERNAL+ can send an initial client response.
  #
  # @return [Boolean]
  #
  # source://net-imap//lib/net/imap/sasl/external_authenticator.rb#65
  def initial_response?; end

  # Returns #authzid, or an empty string if there is no authzid.
  #
  # source://net-imap//lib/net/imap/sasl/external_authenticator.rb#68
  def process(_); end

  # Authorization identity: an identity to act as or on behalf of.  The
  # identity form is application protocol specific.  If not provided or
  # left blank, the server derives an authorization identity from the
  # authentication identity.  The server is responsible for verifying the
  # client's credentials and verifying that the identity it associates
  # with the client's authentication identity is allowed to act as (or on
  # behalf of) the authorization identity.
  #
  # For example, an administrator or superuser might take on another role:
  #
  #     imap.authenticate "PLAIN", "root", passwd, authzid: "user"
  #
  # source://net-imap//lib/net/imap/sasl/external_authenticator.rb#28
  def username; end
end

# Originally defined for the GS2 mechanism family in
# RFC5801[https://www.rfc-editor.org/rfc/rfc5801],
# several different mechanisms start with a GS2 header:
# * +GS2-*+       --- RFC5801[https://www.rfc-editor.org/rfc/rfc5801]
# * +SCRAM-*+     --- RFC5802[https://www.rfc-editor.org/rfc/rfc5802]
#   (ScramAuthenticator)
# * +SAML20+      --- RFC6595[https://www.rfc-editor.org/rfc/rfc6595]
# * +OPENID20+    --- RFC6616[https://www.rfc-editor.org/rfc/rfc6616]
# * +OAUTH10A+    --- RFC7628[https://www.rfc-editor.org/rfc/rfc7628]
# * +OAUTHBEARER+ --- RFC7628[https://www.rfc-editor.org/rfc/rfc7628]
#   (OAuthBearerAuthenticator)
#
# Classes that include this module must implement +#authzid+.
#
# source://net-imap//lib/net/imap/sasl/gs2_header.rb#20
module Net::IMAP::SASL::GS2Header
  # The {RFC5801 §4}[https://www.rfc-editor.org/rfc/rfc5801#section-4]
  # +gs2-authzid+ header, when +#authzid+ is not empty.
  #
  # If +#authzid+ is empty or +nil+, an empty string is returned.
  #
  # source://net-imap//lib/net/imap/sasl/gs2_header.rb#59
  def gs2_authzid; end

  # The {RFC5801 §4}[https://www.rfc-editor.org/rfc/rfc5801#section-4]
  # +gs2-cb-flag+:
  #
  # "+n+":: The client doesn't support channel binding.
  # "+y+":: The client does support channel binding
  #         but thinks the server does not.
  # "+p+":: The client requires channel binding.
  #         The selected channel binding follows "+p=+".
  #
  # The default always returns "+n+".  A mechanism that supports channel
  # binding must override this method.
  #
  # source://net-imap//lib/net/imap/sasl/gs2_header.rb#53
  def gs2_cb_flag; end

  # The {RFC5801 §4}[https://www.rfc-editor.org/rfc/rfc5801#section-4]
  # +gs2-header+, which prefixes the #initial_client_response.
  #
  # >>>
  #   <em>Note: the actual GS2 header includes an optional flag to
  #   indicate that the GSS mechanism is not "standard", but since all of
  #   the SASL mechanisms using GS2 are "standard", we don't include that
  #   flag.  A class for a nonstandard GSSAPI mechanism should prefix with
  #   "+F,+".</em>
  #
  # source://net-imap//lib/net/imap/sasl/gs2_header.rb#37
  def gs2_header; end

  private

  # Encodes +str+ to match RFC5801_SASLNAME.
  #
  # source://net-imap//lib/net/imap/sasl/gs2_header.rb#67
  def gs2_saslname_encode(str); end

  class << self
    # Encodes +str+ to match RFC5801_SASLNAME.
    #
    # source://net-imap//lib/net/imap/sasl/gs2_header.rb#67
    def gs2_saslname_encode(str); end
  end
end

# source://net-imap//lib/net/imap/sasl/gs2_header.rb#21
Net::IMAP::SASL::GS2Header::NO_NULL_CHARS = T.let(T.unsafe(nil), Regexp)

# Matches {RFC5801 §4}[https://www.rfc-editor.org/rfc/rfc5801#section-4]
# +saslname+.  The output from gs2_saslname_encode matches this Regexp.
#
# source://net-imap//lib/net/imap/sasl/gs2_header.rb#26
Net::IMAP::SASL::GS2Header::RFC5801_SASLNAME = T.let(T.unsafe(nil), Regexp)

# Authenticator for the "+LOGIN+" SASL mechanism.  See Net::IMAP#authenticate.
#
# +LOGIN+ authentication sends the password in cleartext.
# RFC3501[https://www.rfc-editor.org/rfc/rfc3501] encourages servers to disable
# cleartext authentication until after TLS has been negotiated.
# RFC8314[https://www.rfc-editor.org/rfc/rfc8314] recommends TLS version 1.2 or
# greater be used for all traffic, and deprecate cleartext access ASAP.  +LOGIN+
# can be secured by TLS encryption.
#
# == Deprecated
#
# The {SASL mechanisms
# registry}[https://www.iana.org/assignments/sasl-mechanisms/sasl-mechanisms.xhtml]
# marks "LOGIN" as obsoleted in favor of "PLAIN".  It is included here for
# compatibility with existing servers.  See
# {draft-murchison-sasl-login}[https://www.iana.org/go/draft-murchison-sasl-login]
# for both specification and deprecation.
#
# source://net-imap//lib/net/imap/sasl/login_authenticator.rb#20
class Net::IMAP::SASL::LoginAuthenticator
  # @return [LoginAuthenticator] a new instance of LoginAuthenticator
  #
  # source://net-imap//lib/net/imap/sasl/login_authenticator.rb#26
  def initialize(user = T.unsafe(nil), pass = T.unsafe(nil), authcid: T.unsafe(nil), username: T.unsafe(nil), password: T.unsafe(nil), secret: T.unsafe(nil), warn_deprecation: T.unsafe(nil), **_arg7); end

  # @return [Boolean]
  #
  # source://net-imap//lib/net/imap/sasl/login_authenticator.rb#55
  def done?; end

  # @return [Boolean]
  #
  # source://net-imap//lib/net/imap/sasl/login_authenticator.rb#40
  def initial_response?; end

  # source://net-imap//lib/net/imap/sasl/login_authenticator.rb#42
  def process(data); end
end

# source://net-imap//lib/net/imap/sasl/login_authenticator.rb#23
Net::IMAP::SASL::LoginAuthenticator::STATE_DONE = T.let(T.unsafe(nil), Symbol)

# source://net-imap//lib/net/imap/sasl/login_authenticator.rb#22
Net::IMAP::SASL::LoginAuthenticator::STATE_PASSWORD = T.let(T.unsafe(nil), Symbol)

# source://net-imap//lib/net/imap/sasl/login_authenticator.rb#21
Net::IMAP::SASL::LoginAuthenticator::STATE_USER = T.let(T.unsafe(nil), Symbol)

# Abstract base class for the SASL mechanisms defined in
# RFC7628[https://www.rfc-editor.org/rfc/rfc7628]:
# * OAUTHBEARER[rdoc-ref:OAuthBearerAuthenticator]
#   (OAuthBearerAuthenticator)
# * OAUTH10A
#
# source://net-imap//lib/net/imap/sasl/oauthbearer_authenticator.rb#14
class Net::IMAP::SASL::OAuthAuthenticator
  include ::Net::IMAP::SASL::GS2Header

  # Creates an RFC7628[https://www.rfc-editor.org/rfc/rfc7628] OAuth
  # authenticator.
  #
  # ==== Parameters
  #
  # See child classes for required parameter(s).  The following parameters
  # are all optional, but it is worth noting that <b>application protocols
  # are allowed to require</b> #authzid (or other parameters, such as
  # #host or #port) <b>as are specific server implementations</b>.
  #
  # * _optional_ #authzid  ― Authorization identity to act as or on behalf of.
  #
  #   _optional_ #username — An alias for #authzid.
  #
  #   Note that, unlike some other authenticators, +username+ sets the
  #   _authorization_ identity and not the _authentication_ identity.  The
  #   authentication identity is established for the client by the OAuth
  #   token.
  #
  # * _optional_ #host — Hostname to which the client connected.
  # * _optional_ #port — Service port to which the client connected.
  # * _optional_ #mthd — HTTP method
  # * _optional_ #path — HTTP path data
  # * _optional_ #post — HTTP post data
  # * _optional_ #qs   — HTTP query string
  #
  #   _optional_ #query — An alias for #qs
  #
  # Any other keyword parameters are quietly ignored.
  #
  # @return [OAuthAuthenticator] a new instance of OAuthAuthenticator
  #
  # source://net-imap//lib/net/imap/sasl/oauthbearer_authenticator.rb#84
  def initialize(authzid: T.unsafe(nil), host: T.unsafe(nil), port: T.unsafe(nil), username: T.unsafe(nil), query: T.unsafe(nil), mthd: T.unsafe(nil), path: T.unsafe(nil), post: T.unsafe(nil), qs: T.unsafe(nil), **_arg9); end

  # Value of the HTTP Authorization header
  #
  # <b>Implemented by subclasses.</b>
  #
  # source://net-imap//lib/net/imap/sasl/oauthbearer_authenticator.rb#124
  def authorization; end

  # Authorization identity: an identity to act as or on behalf of.  The
  # identity form is application protocol specific.  If not provided or
  # left blank, the server derives an authorization identity from the
  # authentication identity.  The server is responsible for verifying the
  # client's credentials and verifying that the identity it associates
  # with the client's authentication identity is allowed to act as (or on
  # behalf of) the authorization identity.
  #
  # For example, an administrator or superuser might take on another role:
  #
  #     imap.authenticate "PLAIN", "root", passwd, authzid: "user"
  #
  # source://net-imap//lib/net/imap/sasl/oauthbearer_authenticator.rb#29
  def authzid; end

  # Returns true when the initial client response was sent.
  #
  # The authentication should not succeed unless this returns true, but it
  # does *not* indicate success.
  #
  # @return [Boolean]
  #
  # source://net-imap//lib/net/imap/sasl/oauthbearer_authenticator.rb#119
  def done?; end

  # Hostname to which the client connected.  (optional)
  #
  # source://net-imap//lib/net/imap/sasl/oauthbearer_authenticator.rb#33
  def host; end

  # The {RFC7628 §3.1}[https://www.rfc-editor.org/rfc/rfc7628#section-3.1]
  # formatted response.
  #
  # source://net-imap//lib/net/imap/sasl/oauthbearer_authenticator.rb#99
  def initial_client_response; end

  # Stores the most recent server "challenge".  When authentication fails,
  # this may hold information about the failure reason, as JSON.
  #
  # source://net-imap//lib/net/imap/sasl/oauthbearer_authenticator.rb#53
  def last_server_response; end

  # HTTP method.  (optional)
  #
  # source://net-imap//lib/net/imap/sasl/oauthbearer_authenticator.rb#39
  def mthd; end

  # HTTP path data.  (optional)
  #
  # source://net-imap//lib/net/imap/sasl/oauthbearer_authenticator.rb#42
  def path; end

  # Service port to which the client connected.  (optional)
  #
  # source://net-imap//lib/net/imap/sasl/oauthbearer_authenticator.rb#36
  def port; end

  # HTTP post data.  (optional)
  #
  # source://net-imap//lib/net/imap/sasl/oauthbearer_authenticator.rb#45
  def post; end

  # Returns initial_client_response the first time, then "<tt>^A</tt>".
  #
  # source://net-imap//lib/net/imap/sasl/oauthbearer_authenticator.rb#108
  def process(data); end

  # The query string.  (optional)
  #
  # source://net-imap//lib/net/imap/sasl/oauthbearer_authenticator.rb#48
  def qs; end

  # The query string.  (optional)
  #
  # source://net-imap//lib/net/imap/sasl/oauthbearer_authenticator.rb#49
  def query; end

  # Authorization identity: an identity to act as or on behalf of.  The
  # identity form is application protocol specific.  If not provided or
  # left blank, the server derives an authorization identity from the
  # authentication identity.  The server is responsible for verifying the
  # client's credentials and verifying that the identity it associates
  # with the client's authentication identity is allowed to act as (or on
  # behalf of) the authorization identity.
  #
  # For example, an administrator or superuser might take on another role:
  #
  #     imap.authenticate "PLAIN", "root", passwd, authzid: "user"
  #
  # source://net-imap//lib/net/imap/sasl/oauthbearer_authenticator.rb#30
  def username; end
end

# Authenticator for the "+OAUTHBEARER+" SASL mechanism, specified in
# RFC7628[https://www.rfc-editor.org/rfc/rfc7628].  Authenticates using
# OAuth 2.0 bearer tokens, as described in
# RFC6750[https://www.rfc-editor.org/rfc/rfc6750].  Use via
# Net::IMAP#authenticate.
#
# RFC6750[https://www.rfc-editor.org/rfc/rfc6750] requires Transport Layer
# Security (TLS) to secure the protocol interaction between the client and
# the resource server.  TLS _MUST_ be used for +OAUTHBEARER+ to protect
# the bearer token.
#
# source://net-imap//lib/net/imap/sasl/oauthbearer_authenticator.rb#138
class Net::IMAP::SASL::OAuthBearerAuthenticator < ::Net::IMAP::SASL::OAuthAuthenticator
  # :call-seq:
  #   new(oauth2_token,          **options) -> authenticator
  #   new(authzid, oauth2_token, **options) -> authenticator
  #   new(oauth2_token:,         **options) -> authenticator
  #
  # Creates an Authenticator for the "+OAUTHBEARER+" SASL mechanism.
  #
  # Called by Net::IMAP#authenticate and similar methods on other clients.
  #
  # ==== Parameters
  #
  # * #oauth2_token — An OAuth2 bearer token
  #
  # All other keyword parameters are passed to
  # {super}[rdoc-ref:OAuthAuthenticator::new] (see OAuthAuthenticator).
  # The most common ones are:
  #
  # * _optional_ #authzid  ― Authorization identity to act as or on behalf of.
  #
  #   _optional_ #username — An alias for #authzid.
  #
  #   Note that, unlike some other authenticators, +username+ sets the
  #   _authorization_ identity and not the _authentication_ identity.  The
  #   authentication identity is established for the client by
  #   #oauth2_token.
  #
  # * _optional_ #host — Hostname to which the client connected.
  # * _optional_ #port — Service port to which the client connected.
  #
  # Although only oauth2_token is required by this mechanism, it is worth
  # noting that <b><em>application protocols are allowed to
  # require</em></b> #authzid (<em>or other parameters, such as</em> #host
  # _or_ #port) <b><em>as are specific server implementations</em></b>.
  #
  # @return [OAuthBearerAuthenticator] a new instance of OAuthBearerAuthenticator
  #
  # source://net-imap//lib/net/imap/sasl/oauthbearer_authenticator.rb#177
  def initialize(arg1 = T.unsafe(nil), arg2 = T.unsafe(nil), oauth2_token: T.unsafe(nil), secret: T.unsafe(nil), **args, &blk); end

  # Value of the HTTP Authorization header
  #
  # source://net-imap//lib/net/imap/sasl/oauthbearer_authenticator.rb#193
  def authorization; end

  # :call-seq:
  #   initial_response? -> true
  #
  # +OAUTHBEARER+ sends an initial client response.
  #
  # @return [Boolean]
  #
  # source://net-imap//lib/net/imap/sasl/oauthbearer_authenticator.rb#190
  def initial_response?; end

  # An OAuth 2.0 bearer token.  See {RFC-6750}[https://www.rfc-editor.org/rfc/rfc6750]
  #
  # source://net-imap//lib/net/imap/sasl/oauthbearer_authenticator.rb#141
  def oauth2_token; end

  # An OAuth 2.0 bearer token.  See {RFC-6750}[https://www.rfc-editor.org/rfc/rfc6750]
  #
  # source://net-imap//lib/net/imap/sasl/oauthbearer_authenticator.rb#142
  def secret; end
end

# Authenticator for the "+PLAIN+" SASL mechanism, specified in
# RFC-4616[https://www.rfc-editor.org/rfc/rfc4616].  See Net::IMAP#authenticate.
#
# +PLAIN+ authentication sends the password in cleartext.
# RFC-3501[https://www.rfc-editor.org/rfc/rfc3501] encourages servers to disable
# cleartext authentication until after TLS has been negotiated.
# RFC-8314[https://www.rfc-editor.org/rfc/rfc8314] recommends TLS version 1.2 or
# greater be used for all traffic, and deprecate cleartext access ASAP.  +PLAIN+
# can be secured by TLS encryption.
#
# source://net-imap//lib/net/imap/sasl/plain_authenticator.rb#12
class Net::IMAP::SASL::PlainAuthenticator
  # :call-seq:
  #   new(username,  password,  authzid: nil, **) -> authenticator
  #   new(username:, password:, authzid: nil, **) -> authenticator
  #   new(authcid:,  password:, authzid: nil, **) -> authenticator
  #
  # Creates an Authenticator for the "+PLAIN+" SASL mechanism.
  #
  # Called by Net::IMAP#authenticate and similar methods on other clients.
  #
  # ==== Parameters
  #
  # * #authcid ― Authentication identity that is associated with #password.
  #
  #   #username ― An alias for #authcid.
  #
  # * #password ― A password or passphrase associated with the #authcid.
  #
  # * _optional_ #authzid  ― Authorization identity to act as or on behalf of.
  #
  #   When +authzid+ is not set, the server should derive the authorization
  #   identity from the authentication identity.
  #
  # Any other keyword parameters are quietly ignored.
  #
  # @raise [ArgumentError]
  # @return [PlainAuthenticator] a new instance of PlainAuthenticator
  #
  # source://net-imap//lib/net/imap/sasl/plain_authenticator.rb#67
  def initialize(user = T.unsafe(nil), pass = T.unsafe(nil), authcid: T.unsafe(nil), secret: T.unsafe(nil), username: T.unsafe(nil), password: T.unsafe(nil), authzid: T.unsafe(nil), **_arg7); end

  # Authentication identity: the identity that matches the #password.
  #
  # RFC-2831[https://www.rfc-editor.org/rfc/rfc2831] uses the term +username+.
  # "Authentication identity" is the generic term used by
  # RFC-4422[https://www.rfc-editor.org/rfc/rfc4422].
  # RFC-4616[https://www.rfc-editor.org/rfc/rfc4616] and many later RFCs
  # abbreviate this to +authcid+.
  #
  # source://net-imap//lib/net/imap/sasl/plain_authenticator.rb#25
  def authcid; end

  # Authorization identity: an identity to act as or on behalf of.  The identity
  # form is application protocol specific.  If not provided or left blank, the
  # server derives an authorization identity from the authentication identity.
  # The server is responsible for verifying the client's credentials and
  # verifying that the identity it associates with the client's authentication
  # identity is allowed to act as (or on behalf of) the authorization identity.
  #
  # For example, an administrator or superuser might take on another role:
  #
  #     imap.authenticate "PLAIN", "root", passwd, authzid: "user"
  #
  # source://net-imap//lib/net/imap/sasl/plain_authenticator.rb#42
  def authzid; end

  # Returns true when the initial client response was sent.
  #
  # The authentication should not succeed unless this returns true, but it
  # does *not* indicate success.
  #
  # @return [Boolean]
  #
  # source://net-imap//lib/net/imap/sasl/plain_authenticator.rb#99
  def done?; end

  # :call-seq:
  #   initial_response? -> true
  #
  # +PLAIN+ can send an initial client response.
  #
  # @return [Boolean]
  #
  # source://net-imap//lib/net/imap/sasl/plain_authenticator.rb#86
  def initial_response?; end

  # A password or passphrase that matches the #username.
  #
  # source://net-imap//lib/net/imap/sasl/plain_authenticator.rb#28
  def password; end

  # Responds with the client's credentials.
  #
  # source://net-imap//lib/net/imap/sasl/plain_authenticator.rb#89
  def process(data); end

  # A password or passphrase that matches the #username.
  #
  # source://net-imap//lib/net/imap/sasl/plain_authenticator.rb#29
  def secret; end

  # Authentication identity: the identity that matches the #password.
  #
  # RFC-2831[https://www.rfc-editor.org/rfc/rfc2831] uses the term +username+.
  # "Authentication identity" is the generic term used by
  # RFC-4422[https://www.rfc-editor.org/rfc/rfc4422].
  # RFC-4616[https://www.rfc-editor.org/rfc/rfc4616] and many later RFCs
  # abbreviate this to +authcid+.
  #
  # source://net-imap//lib/net/imap/sasl/plain_authenticator.rb#24
  def username; end
end

# source://net-imap//lib/net/imap/sasl/plain_authenticator.rb#14
Net::IMAP::SASL::PlainAuthenticator::NULL = T.let(T.unsafe(nil), String)

# source://net-imap//lib/net/imap/sasl/stringprep.rb#9
Net::IMAP::SASL::ProhibitedCodepoint = Net::IMAP::StringPrep::ProhibitedCodepoint

# SASL::ProtocolAdapters modules are meant to be used as mixins for
# SASL::ClientAdapter and its subclasses.  Where the client adapter must
# be customized for each client library, the protocol adapter mixin
# handles \SASL requirements that are part of the protocol specification,
# but not specific to any particular client library.  In particular, see
# {RFC4422 §4}[https://www.rfc-editor.org/rfc/rfc4422.html#section-4]
#
# === Interface
#
# >>>
#   NOTE: This API is experimental, and may change.
#
# - {#command_name}[rdoc-ref:Generic#command_name] -- The name of the
#   command used to to initiate an authentication exchange.
# - {#service}[rdoc-ref:Generic#service] -- The GSSAPI service name.
# - {#encode_ir}[rdoc-ref:Generic#encode_ir]--Encodes an initial response.
# - {#decode}[rdoc-ref:Generic#decode] -- Decodes a server challenge.
# - {#encode}[rdoc-ref:Generic#encode] -- Encodes a client response.
# - {#cancel_response}[rdoc-ref:Generic#cancel_response] -- The encoded
#   client response used to cancel an authentication exchange.
#
# Other protocol requirements of the \SASL authentication exchange are
# handled by SASL::ClientAdapter.
#
# === Included protocol adapters
#
# - Generic -- a basic implementation of all of the methods listed above.
# - IMAP -- An adapter for the IMAP4 protocol.
# - SMTP -- An adapter for the \SMTP protocol with the +AUTH+ capability.
# - POP  -- An adapter for the POP3  protocol with the +SASL+ capability.
#
# source://net-imap//lib/net/imap/sasl/protocol_adapters.rb#37
module Net::IMAP::SASL::ProtocolAdapters; end

# See SASL::ProtocolAdapters@Interface.
#
# source://net-imap//lib/net/imap/sasl/protocol_adapters.rb#39
module Net::IMAP::SASL::ProtocolAdapters::Generic
  # Returns the message used by the client to abort an authentication
  # exchange.
  #
  # The generic implementation returns <tt>"*"</tt>.
  #
  # source://net-imap//lib/net/imap/sasl/protocol_adapters.rb#73
  def cancel_response; end

  # The name of the protocol command used to initiate a \SASL
  # authentication exchange.
  #
  # The generic implementation returns <tt>"AUTHENTICATE"</tt>.
  #
  # source://net-imap//lib/net/imap/sasl/protocol_adapters.rb#44
  def command_name; end

  # Decodes a server challenge string.
  #
  # The generic implementation returns the Base64 decoding of +string+.
  #
  # source://net-imap//lib/net/imap/sasl/protocol_adapters.rb#67
  def decode(string); end

  # Encodes a client response string.
  #
  # The generic implementation returns the Base64 encoding of +string+.
  #
  # source://net-imap//lib/net/imap/sasl/protocol_adapters.rb#62
  def encode(string); end

  # Encodes an initial response string.
  #
  # The generic implementation returns the result of #encode, or returns
  # <tt>"="</tt> when +string+ is empty.
  #
  # source://net-imap//lib/net/imap/sasl/protocol_adapters.rb#57
  def encode_ir(string); end

  # A service name from the {GSSAPI/Kerberos/SASL Service Names
  # registry}[https://www.iana.org/assignments/gssapi-service-names/gssapi-service-names.xhtml].
  #
  # The generic implementation returns <tt>"host"</tt>, which is the
  # generic GSSAPI host-based service name.
  #
  # source://net-imap//lib/net/imap/sasl/protocol_adapters.rb#51
  def service; end
end

# See RFC-3501 (IMAP4rev1), RFC-4959 (SASL-IR capability),
# and RFC-9051 (IMAP4rev2).
#
# source://net-imap//lib/net/imap/sasl/protocol_adapters.rb#78
module Net::IMAP::SASL::ProtocolAdapters::IMAP
  include ::Net::IMAP::SASL::ProtocolAdapters::Generic

  # source://net-imap//lib/net/imap/sasl/protocol_adapters.rb#80
  def service; end
end

# See RFC-5034 (SASL capability).
#
# source://net-imap//lib/net/imap/sasl/protocol_adapters.rb#91
module Net::IMAP::SASL::ProtocolAdapters::POP
  include ::Net::IMAP::SASL::ProtocolAdapters::Generic

  # source://net-imap//lib/net/imap/sasl/protocol_adapters.rb#93
  def command_name; end

  # source://net-imap//lib/net/imap/sasl/protocol_adapters.rb#94
  def service; end
end

# See RFC-4954 (AUTH capability).
#
# source://net-imap//lib/net/imap/sasl/protocol_adapters.rb#84
module Net::IMAP::SASL::ProtocolAdapters::SMTP
  include ::Net::IMAP::SASL::ProtocolAdapters::Generic

  # source://net-imap//lib/net/imap/sasl/protocol_adapters.rb#86
  def command_name; end

  # source://net-imap//lib/net/imap/sasl/protocol_adapters.rb#87
  def service; end
end

# Alias for Net::IMAP::StringPrep::SASLprep.
#
# source://net-imap//lib/net/imap/sasl/stringprep.rb#6
Net::IMAP::SASL::SASLprep = Net::IMAP::StringPrep::SASLprep

# For method descriptions,
# see {RFC5802 §2.2}[https://www.rfc-editor.org/rfc/rfc5802#section-2.2]
# and {RFC5802 §3}[https://www.rfc-editor.org/rfc/rfc5802#section-3].
#
# source://net-imap//lib/net/imap/sasl/scram_algorithm.rb#10
module Net::IMAP::SASL::ScramAlgorithm
  # source://net-imap//lib/net/imap/sasl/scram_algorithm.rb#24
  def H(str); end

  # source://net-imap//lib/net/imap/sasl/scram_algorithm.rb#26
  def HMAC(key, data); end

  # source://net-imap//lib/net/imap/sasl/scram_algorithm.rb#13
  def Hi(str, salt, iterations); end

  # source://net-imap//lib/net/imap/sasl/scram_algorithm.rb#11
  def Normalize(str); end

  # source://net-imap//lib/net/imap/sasl/scram_algorithm.rb#28
  def XOR(str1, str2); end

  # source://net-imap//lib/net/imap/sasl/scram_algorithm.rb#35
  def auth_message; end

  # source://net-imap//lib/net/imap/sasl/scram_algorithm.rb#48
  def client_key; end

  # source://net-imap//lib/net/imap/sasl/scram_algorithm.rb#53
  def client_proof; end

  # source://net-imap//lib/net/imap/sasl/scram_algorithm.rb#51
  def client_signature; end

  # source://net-imap//lib/net/imap/sasl/scram_algorithm.rb#44
  def salted_password; end

  # source://net-imap//lib/net/imap/sasl/scram_algorithm.rb#49
  def server_key; end

  # source://net-imap//lib/net/imap/sasl/scram_algorithm.rb#52
  def server_signature; end

  # source://net-imap//lib/net/imap/sasl/scram_algorithm.rb#50
  def stored_key; end
end

# Abstract base class for the "+SCRAM-*+" family of SASL mechanisms,
# defined in RFC5802[https://www.rfc-editor.org/rfc/rfc5802].  Use via
# Net::IMAP#authenticate.
#
# Directly supported:
# * +SCRAM-SHA-1+   --- ScramSHA1Authenticator
# * +SCRAM-SHA-256+ --- ScramSHA256Authenticator
#
# New +SCRAM-*+ mechanisms can easily be added for any hash algorithm
# supported by
# OpenSSL::Digest[https://ruby.github.io/openssl/OpenSSL/Digest.html].
# Subclasses need only set an appropriate +DIGEST_NAME+ constant.
#
# === SCRAM algorithm
#
# See the documentation and method definitions on ScramAlgorithm for an
# overview of the algorithm.  The different mechanisms differ only by
# which hash function that is used (or by support for channel binding with
# +-PLUS+).
#
# See also the methods on GS2Header.
#
# ==== Server messages
#
# As server messages are received, they are validated and loaded into
# the various attributes, e.g: #snonce, #salt, #iterations, #verifier,
# #server_error, etc.
#
# Unlike many other SASL mechanisms, the +SCRAM-*+ family supports mutual
# authentication and can return server error data in the server messages.
# If #process raises an Error for the server-final-message, then
# server_error may contain error details.
#
# === TLS Channel binding
#
# <em>The <tt>SCRAM-*-PLUS</tt> mechanisms and channel binding are not
# supported yet.</em>
#
# === Caching SCRAM secrets
#
# <em>Caching of salted_password, client_key, stored_key, and server_key
# is not supported yet.</em>
#
# source://net-imap//lib/net/imap/sasl/scram_authenticator.rb#56
class Net::IMAP::SASL::ScramAuthenticator
  include ::Net::IMAP::SASL::GS2Header
  include ::Net::IMAP::SASL::ScramAlgorithm

  # :call-seq:
  #   new(username,  password,  **options) -> auth_ctx
  #   new(username:, password:, **options) -> auth_ctx
  #   new(authcid:,  password:, **options) -> auth_ctx
  #
  # Creates an authenticator for one of the "+SCRAM-*+" SASL mechanisms.
  # Each subclass defines #digest to match a specific mechanism.
  #
  # Called by Net::IMAP#authenticate and similar methods on other clients.
  #
  # === Parameters
  #
  # * #authcid  ― Identity whose #password is used.
  #
  #   #username - An alias for #authcid.
  # * #password ― Password or passphrase associated with this #username.
  # * _optional_ #authzid ― Alternate identity to act as or on behalf of.
  # * _optional_ #min_iterations - Overrides the default value (4096).
  #
  # Any other keyword parameters are quietly ignored.
  #
  # @return [ScramAuthenticator] a new instance of ScramAuthenticator
  #
  # source://net-imap//lib/net/imap/sasl/scram_authenticator.rb#80
  def initialize(username_arg = T.unsafe(nil), password_arg = T.unsafe(nil), authcid: T.unsafe(nil), username: T.unsafe(nil), authzid: T.unsafe(nil), password: T.unsafe(nil), secret: T.unsafe(nil), min_iterations: T.unsafe(nil), cnonce: T.unsafe(nil), **options); end

  # Authentication identity: the identity that matches the #password.
  #
  # RFC-2831[https://www.rfc-editor.org/rfc/rfc2831] uses the term
  # +username+.  "Authentication identity" is the generic term used by
  # RFC-4422[https://www.rfc-editor.org/rfc/rfc4422].
  # RFC-4616[https://www.rfc-editor.org/rfc/rfc4616] and many later RFCs
  # abbreviate this to +authcid+.
  #
  # source://net-imap//lib/net/imap/sasl/scram_authenticator.rb#108
  def authcid; end

  # Authorization identity: an identity to act as or on behalf of.  The
  # identity form is application protocol specific.  If not provided or
  # left blank, the server derives an authorization identity from the
  # authentication identity.  For example, an administrator or superuser
  # might take on another role:
  #
  #     imap.authenticate "SCRAM-SHA-256", "root", passwd, authzid: "user"
  #
  # The server is responsible for verifying the client's credentials and
  # verifying that the identity it associates with the client's
  # authentication identity is allowed to act as (or on behalf of) the
  # authorization identity.
  #
  # source://net-imap//lib/net/imap/sasl/scram_authenticator.rb#126
  def authzid; end

  # See {RFC5802 §7}[https://www.rfc-editor.org/rfc/rfc5802#section-7]
  # +cbind-input+.
  #
  # >>>
  #   *TODO:* implement channel binding, appending +cbind-data+ here.
  #
  # source://net-imap//lib/net/imap/sasl/scram_authenticator.rb#251
  def cbind_input; end

  # The client nonce, generated by SecureRandom
  #
  # source://net-imap//lib/net/imap/sasl/scram_authenticator.rb#133
  def cnonce; end

  # Returns a new OpenSSL::Digest object, set to the appropriate hash
  # function for the chosen mechanism.
  #
  # <em>The class's +DIGEST_NAME+ constant must be set to the name of an
  # algorithm supported by OpenSSL::Digest.</em>
  #
  # source://net-imap//lib/net/imap/sasl/scram_authenticator.rb#155
  def digest; end

  # Is the authentication exchange complete?
  #
  # If false, another server continuation is required.
  #
  # @return [Boolean]
  #
  # source://net-imap//lib/net/imap/sasl/scram_authenticator.rb#185
  def done?; end

  # See {RFC5802 §7}[https://www.rfc-editor.org/rfc/rfc5802#section-7]
  # +client-first-message+.
  #
  # source://net-imap//lib/net/imap/sasl/scram_authenticator.rb#159
  def initial_client_response; end

  # The iteration count for the selected hash function and user
  #
  # source://net-imap//lib/net/imap/sasl/scram_authenticator.rb#142
  def iterations; end

  # The minimal allowed iteration count.  Lower #iterations will raise an
  # Error.
  #
  # source://net-imap//lib/net/imap/sasl/scram_authenticator.rb#130
  def min_iterations; end

  # A password or passphrase that matches the #username.
  #
  # source://net-imap//lib/net/imap/sasl/scram_authenticator.rb#111
  def password; end

  # responds to the server's challenges
  #
  # source://net-imap//lib/net/imap/sasl/scram_authenticator.rb#164
  def process(challenge); end

  # The salt used by the server for this user
  #
  # source://net-imap//lib/net/imap/sasl/scram_authenticator.rb#139
  def salt; end

  # A password or passphrase that matches the #username.
  #
  # source://net-imap//lib/net/imap/sasl/scram_authenticator.rb#112
  def secret; end

  # An error reported by the server during the \SASL exchange.
  #
  # Does not include errors reported by the protocol, e.g.
  # Net::IMAP::NoResponseError.
  #
  # source://net-imap//lib/net/imap/sasl/scram_authenticator.rb#148
  def server_error; end

  # The server nonce, which must start with #cnonce
  #
  # source://net-imap//lib/net/imap/sasl/scram_authenticator.rb#136
  def snonce; end

  # Authentication identity: the identity that matches the #password.
  #
  # RFC-2831[https://www.rfc-editor.org/rfc/rfc2831] uses the term
  # +username+.  "Authentication identity" is the generic term used by
  # RFC-4422[https://www.rfc-editor.org/rfc/rfc4422].
  # RFC-4616[https://www.rfc-editor.org/rfc/rfc4616] and many later RFCs
  # abbreviate this to +authcid+.
  #
  # source://net-imap//lib/net/imap/sasl/scram_authenticator.rb#107
  def username; end

  private

  # See {RFC5802 §7}[https://www.rfc-editor.org/rfc/rfc5802#section-7]
  # +client-final-message-without-proof+.
  #
  # source://net-imap//lib/net/imap/sasl/scram_authenticator.rb#240
  def client_final_message_without_proof; end

  # See {RFC5802 §7}[https://www.rfc-editor.org/rfc/rfc5802#section-7]
  # +client-first-message-bare+.
  #
  # source://net-imap//lib/net/imap/sasl/scram_authenticator.rb#225
  def client_first_message_bare; end

  # See {RFC5802 §7}[https://www.rfc-editor.org/rfc/rfc5802#section-7]
  # +client-final-message+.
  #
  # source://net-imap//lib/net/imap/sasl/scram_authenticator.rb#233
  def final_message_with_proof; end

  # source://net-imap//lib/net/imap/sasl/scram_authenticator.rb#192
  def format_message(hash); end

  # RFC5802 specifies "that the order of attributes in client or server
  # messages is fixed, with the exception of extension attributes", but
  # this parses it simply as a hash, without respect to order.  Note that
  # repeated keys (violating the spec) will use the last value.
  #
  # source://net-imap//lib/net/imap/sasl/scram_authenticator.rb#257
  def parse_challenge(challenge); end

  # source://net-imap//lib/net/imap/sasl/scram_authenticator.rb#211
  def recv_server_final_message(server_final_message); end

  # source://net-imap//lib/net/imap/sasl/scram_authenticator.rb#194
  def recv_server_first_message(server_first_message); end

  # Need to store this for auth_message
  #
  # source://net-imap//lib/net/imap/sasl/scram_authenticator.rb#190
  def server_first_message; end
end

# Authenticator for the "+SCRAM-SHA-1+" SASL mechanism, defined in
# RFC5802[https://www.rfc-editor.org/rfc/rfc5802].
#
# Uses the "SHA-1" digest algorithm from OpenSSL::Digest.
#
# See ScramAuthenticator.
#
# source://net-imap//lib/net/imap/sasl/scram_authenticator.rb#271
class Net::IMAP::SASL::ScramSHA1Authenticator < ::Net::IMAP::SASL::ScramAuthenticator; end

# source://net-imap//lib/net/imap/sasl/scram_authenticator.rb#272
Net::IMAP::SASL::ScramSHA1Authenticator::DIGEST_NAME = T.let(T.unsafe(nil), String)

# Authenticator for the "+SCRAM-SHA-256+" SASL mechanism, defined in
# RFC7677[https://www.rfc-editor.org/rfc/rfc7677].
#
# Uses the "SHA-256" digest algorithm from OpenSSL::Digest.
#
# See ScramAuthenticator.
#
# source://net-imap//lib/net/imap/sasl/scram_authenticator.rb#281
class Net::IMAP::SASL::ScramSHA256Authenticator < ::Net::IMAP::SASL::ScramAuthenticator; end

# source://net-imap//lib/net/imap/sasl/scram_authenticator.rb#282
Net::IMAP::SASL::ScramSHA256Authenticator::DIGEST_NAME = T.let(T.unsafe(nil), String)

# source://net-imap//lib/net/imap/sasl/stringprep.rb#7
Net::IMAP::SASL::StringPrep = Net::IMAP::StringPrep

# source://net-imap//lib/net/imap/sasl/stringprep.rb#10
Net::IMAP::SASL::StringPrepError = Net::IMAP::StringPrep::StringPrepError

# Authenticator for the "+XOAUTH2+" SASL mechanism.  This mechanism was
# originally created for GMail and widely adopted by hosted email providers.
# +XOAUTH2+ has been documented by
# Google[https://developers.google.com/gmail/imap/xoauth2-protocol] and
# Microsoft[https://learn.microsoft.com/en-us/exchange/client-developer/legacy-protocols/how-to-authenticate-an-imap-pop-smtp-application-by-using-oauth].
#
# This mechanism requires an OAuth2 access token which has been authorized
# with the appropriate OAuth2 scopes to access the user's services.  Most of
# these scopes are not standardized---consult each service provider's
# documentation for their scopes.
#
# Although this mechanism was never standardized and has been obsoleted by
# "+OAUTHBEARER+", it is still very widely supported.
#
# See Net::IMAP::SASL::OAuthBearerAuthenticator.
#
# source://net-imap//lib/net/imap/sasl/xoauth2_authenticator.rb#18
class Net::IMAP::SASL::XOAuth2Authenticator
  # :call-seq:
  #   new(username,  oauth2_token,  **) -> authenticator
  #   new(username:, oauth2_token:, **) -> authenticator
  #   new(authzid:,  oauth2_token:, **) -> authenticator
  #
  # Creates an Authenticator for the "+XOAUTH2+" SASL mechanism, as specified by
  # Google[https://developers.google.com/gmail/imap/xoauth2-protocol],
  # Microsoft[https://learn.microsoft.com/en-us/exchange/client-developer/legacy-protocols/how-to-authenticate-an-imap-pop-smtp-application-by-using-oauth]
  # and Yahoo[https://senders.yahooinc.com/developer/documentation].
  #
  # === Properties
  #
  # * #username --- the username for the account being accessed.
  #
  #   #authzid  --- an alias for #username.
  #
  #   Note that, unlike some other authenticators, +username+ sets the
  #   _authorization_ identity and not the _authentication_ identity.  The
  #   authenticated identity is established for the client with the OAuth token.
  #
  # * #oauth2_token --- An OAuth2.0 access token which is authorized to access
  #   the service for #username.
  #
  # Any other keyword parameters are quietly ignored.
  #
  # @return [XOAuth2Authenticator] a new instance of XOAuth2Authenticator
  #
  # source://net-imap//lib/net/imap/sasl/xoauth2_authenticator.rb#71
  def initialize(user = T.unsafe(nil), token = T.unsafe(nil), username: T.unsafe(nil), oauth2_token: T.unsafe(nil), authzid: T.unsafe(nil), secret: T.unsafe(nil), **_arg6); end

  # It is unclear from {Google's original XOAUTH2
  # documentation}[https://developers.google.com/gmail/imap/xoauth2-protocol],
  # whether "User" refers to the authentication identity (+authcid+) or the
  # authorization identity (+authzid+).  The authentication identity is
  # established for the client by the OAuth token, so it seems that +username+
  # must be the authorization identity.
  #
  # {Microsoft's documentation for shared
  # mailboxes}[https://learn.microsoft.com/en-us/exchange/client-developer/legacy-protocols/how-to-authenticate-an-imap-pop-smtp-application-by-using-oauth#sasl-xoauth2-authentication-for-shared-mailboxes-in-office-365]
  # _clearly_ indicates that the Office 365 server interprets it as the
  # authorization identity.
  #
  # Although they _should_ validate that the token has been authorized to access
  # the service for +username+, _some_ servers appear to ignore this field,
  # relying only the identity and scope authorized by the token.
  # Note that, unlike most other authenticators, #username is an alias for the
  # authorization identity and not the authentication identity.  The
  # authenticated identity is established for the client by the #oauth2_token.
  #
  # source://net-imap//lib/net/imap/sasl/xoauth2_authenticator.rb#40
  def authzid; end

  # Returns true when the initial client response was sent.
  #
  # The authentication should not succeed unless this returns true, but it
  # does *not* indicate success.
  #
  # @return [Boolean]
  #
  # source://net-imap//lib/net/imap/sasl/xoauth2_authenticator.rb#98
  def done?; end

  # :call-seq:
  #   initial_response? -> true
  #
  # +XOAUTH2+ can send an initial client response.
  #
  # @return [Boolean]
  #
  # source://net-imap//lib/net/imap/sasl/xoauth2_authenticator.rb#84
  def initial_response?; end

  # An OAuth2 access token which has been authorized with the appropriate OAuth2
  # scopes to use the service for #username.
  #
  # source://net-imap//lib/net/imap/sasl/xoauth2_authenticator.rb#44
  def oauth2_token; end

  # Returns the XOAUTH2 formatted response, which combines the +username+
  # with the +oauth2_token+.
  #
  # source://net-imap//lib/net/imap/sasl/xoauth2_authenticator.rb#88
  def process(_data); end

  # An OAuth2 access token which has been authorized with the appropriate OAuth2
  # scopes to use the service for #username.
  #
  # source://net-imap//lib/net/imap/sasl/xoauth2_authenticator.rb#45
  def secret; end

  # It is unclear from {Google's original XOAUTH2
  # documentation}[https://developers.google.com/gmail/imap/xoauth2-protocol],
  # whether "User" refers to the authentication identity (+authcid+) or the
  # authorization identity (+authzid+).  The authentication identity is
  # established for the client by the OAuth token, so it seems that +username+
  # must be the authorization identity.
  #
  # {Microsoft's documentation for shared
  # mailboxes}[https://learn.microsoft.com/en-us/exchange/client-developer/legacy-protocols/how-to-authenticate-an-imap-pop-smtp-application-by-using-oauth#sasl-xoauth2-authentication-for-shared-mailboxes-in-office-365]
  # _clearly_ indicates that the Office 365 server interprets it as the
  # authorization identity.
  #
  # Although they _should_ validate that the token has been authorized to access
  # the service for +username+, _some_ servers appear to ignore this field,
  # relying only the identity and scope authorized by the token.
  #
  # source://net-imap//lib/net/imap/sasl/xoauth2_authenticator.rb#35
  def username; end

  private

  # source://net-imap//lib/net/imap/sasl/xoauth2_authenticator.rb#102
  def build_oauth2_string(username, oauth2_token); end
end

# Experimental
#
# source://net-imap//lib/net/imap/sasl_adapter.rb#7
class Net::IMAP::SASLAdapter < ::Net::IMAP::SASL::ClientAdapter
  include ::Net::IMAP::SASL::ProtocolAdapters::IMAP

  # source://net-imap//lib/net/imap/sasl_adapter.rb#15
  def drop_connection; end

  # source://net-imap//lib/net/imap/sasl_adapter.rb#16
  def drop_connection!; end

  # source://net-imap//lib/net/imap/sasl_adapter.rb#13
  def response_errors; end

  # @return [Boolean]
  #
  # source://net-imap//lib/net/imap/sasl_adapter.rb#14
  def sasl_ir_capable?; end
end

# source://net-imap//lib/net/imap/sasl_adapter.rb#10
Net::IMAP::SASLAdapter::RESPONSE_ERRORS = T.let(T.unsafe(nil), Array)

# Mailbox attribute indicating that this mailbox is used to hold copies of
# messages that have been sent. Some server implementations might put
# messages here automatically. Alternatively, this might just be advice that
# a client save sent messages here.
#
# source://net-imap//lib/net/imap/flags.rb#248
Net::IMAP::SENT = T.let(T.unsafe(nil), Symbol)

# strftime/strptime format for an IMAP4 +date+, excluding optional dquotes.
# Use via the encode_date and decode_date methods.
#
#   date            = date-text / DQUOTE date-text DQUOTE
#   date-text       = date-day "-" date-month "-" date-year
#
#   date-day        = 1*2DIGIT
#                       ; Day of month
#   date-month      = "Jan" / "Feb" / "Mar" / "Apr" / "May" / "Jun" /
#                     "Jul" / "Aug" / "Sep" / "Oct" / "Nov" / "Dec"
#   date-year       = 4DIGIT
#
# source://net-imap//lib/net/imap/data_encoding.rb#22
Net::IMAP::STRFDATE = T.let(T.unsafe(nil), String)

# strftime/strptime format for an IMAP4 +date-time+, including dquotes.
# See the encode_datetime and decode_datetime methods.
#
#   date-time       = DQUOTE date-day-fixed "-" date-month "-" date-year
#                     SP time SP zone DQUOTE
#
#   date-day-fixed  = (SP DIGIT) / 2DIGIT
#                       ; Fixed-format version of date-day
#   date-month      = "Jan" / "Feb" / "Mar" / "Apr" / "May" / "Jun" /
#                     "Jul" / "Aug" / "Sep" / "Oct" / "Nov" / "Dec"
#   date-year       = 4DIGIT
#   time            = 2DIGIT ":" 2DIGIT ":" 2DIGIT
#                       ; Hours minutes seconds
#   zone            = ("+" / "-") 4DIGIT
#                       ; Signed four-digit value of hhmm representing
#                       ; hours and minutes east of Greenwich (that is,
#                       ; the amount that the given time differs from
#                       ; Universal Time).  Subtracting the timezone
#                       ; from the given time will give the UT form.
#                       ; The Universal Time zone is "+0000".
#
# Note that Time.strptime <tt>"%d"</tt> flexibly parses either space or zero
# padding.  However, the DQUOTEs are *not* optional.
#
# source://net-imap//lib/net/imap/data_encoding.rb#47
Net::IMAP::STRFTIME = T.let(T.unsafe(nil), String)

# The mailbox name was subscribed to using the #subscribe command.
#
# source://net-imap//lib/net/imap/flags.rb#173
Net::IMAP::SUBSCRIBED = T.let(T.unsafe(nil), Symbol)

# An array of sequence numbers returned by Net::IMAP#search, or unique
# identifiers returned by Net::IMAP#uid_search.
#
# For backward compatibility, SearchResult inherits from Array.
#
# source://net-imap//lib/net/imap/search_result.rb#10
class Net::IMAP::SearchResult < ::Array
  # Returns a SearchResult populated with the given +seq_nums+.
  #
  #     Net::IMAP::SearchResult.new([1, 3, 5], modseq: 9)
  #     # => Net::IMAP::SearchResult[1, 3, 5, modseq: 9]
  #
  # @return [SearchResult] a new instance of SearchResult
  #
  # source://net-imap//lib/net/imap/search_result.rb#29
  def initialize(seq_nums, modseq: T.unsafe(nil)); end

  # Returns whether +other+ is a SearchResult with the same values and the
  # same #modseq.  The order of numbers is irrelevant.
  #
  #     Net::IMAP::SearchResult[123, 456, modseq: 789] ==
  #       Net::IMAP::SearchResult[123, 456, modseq: 789]
  #     # => true
  #     Net::IMAP::SearchResult[123, 456, modseq: 789] ==
  #       Net::IMAP::SearchResult[456, 123, modseq: 789]
  #     # => true
  #
  #     Net::IMAP::SearchResult[123, 456, modseq: 789] ==
  #       Net::IMAP::SearchResult[987, 654, modseq: 789]
  #     # => false
  #     Net::IMAP::SearchResult[123, 456, modseq: 789] ==
  #       Net::IMAP::SearchResult[1, 2, 3, modseq: 9999]
  #     # => false
  #
  # SearchResult can be compared directly with Array, if #modseq is nil and
  # the array is sorted.
  #
  #     Net::IMAP::SearchResult[9, 8, 6, 4, 1] == [1, 4, 6, 8, 9] # => true
  #     Net::IMAP::SearchResult[3, 5, 7, modseq: 99] == [3, 5, 7] # => false
  #
  # Note that Array#== does require matching order and ignores #modseq.
  #
  #     [9, 8, 6, 4, 1] == Net::IMAP::SearchResult[1, 4, 6, 8, 9] # => false
  #     [3, 5, 7] == Net::IMAP::SearchResult[3, 5, 7, modseq: 99] # => true
  #
  # source://net-imap//lib/net/imap/search_result.rb#62
  def ==(other); end

  # Hash equality.  Unlike #==, order will be taken into account.
  #
  # @return [Boolean]
  #
  # source://net-imap//lib/net/imap/search_result.rb#76
  def eql?(other); end

  # Hash equality.  Unlike #==, order will be taken into account.
  #
  # source://net-imap//lib/net/imap/search_result.rb#70
  def hash; end

  # Returns a string that represents the SearchResult.
  #
  #    Net::IMAP::SearchResult[123, 456, 789].inspect
  #    # => "[123, 456, 789]"
  #
  #    Net::IMAP::SearchResult[543, 210, 678, modseq: 2048].inspect
  #    # => "Net::IMAP::SearchResult[543, 210, 678, modseq: 2048]"
  #
  # source://net-imap//lib/net/imap/search_result.rb#89
  def inspect; end

  # A modification sequence number, as described by the +CONDSTORE+
  # extension in {[RFC7162
  # §3.1.6]}[https://www.rfc-editor.org/rfc/rfc7162.html#section-3.1.6].
  #
  # source://net-imap//lib/net/imap/search_result.rb#23
  def modseq; end

  # source://net-imap//lib/net/imap/search_result.rb#122
  def pretty_print(pp); end

  # Returns a string that follows the formal \IMAP syntax.
  #
  #    data = Net::IMAP::SearchResult[2, 8, 32, 128, 256, 512]
  #    data.to_s           # => "* SEARCH 2 8 32 128 256 512"
  #    data.to_s("SEARCH") # => "* SEARCH 2 8 32 128 256 512"
  #    data.to_s("SORT")   # => "* SORT 2 8 32 128 256 512"
  #    data.to_s(nil)      # => "2 8 32 128 256 512"
  #
  #    data = Net::IMAP::SearchResult[1, 3, 16, 1024, modseq: 2048]
  #    data.to_s           # => "* SEARCH 1 3 16 1024 (MODSEQ 2048)"
  #    data.to_s("SORT")   # => "* SORT 1 3 16 1024 (MODSEQ 2048)"
  #    data.to_s(nil)      # => "1 3 16 1024 (MODSEQ 2048)"
  #
  # source://net-imap//lib/net/imap/search_result.rb#107
  def to_s(type = T.unsafe(nil)); end

  # Converts the SearchResult into a SequenceSet.
  #
  #     Net::IMAP::SearchResult[9, 1, 2, 4, 10, 12, 3, modseq: 123_456]
  #       .to_sequence_set
  #     # => Net::IMAP::SequenceSet["1:4,9:10,12"]
  #
  # source://net-imap//lib/net/imap/search_result.rb#120
  def to_sequence_set; end

  class << self
    # Returns a SearchResult populated with the given +seq_nums+.
    #
    #     Net::IMAP::SearchResult[1, 3, 5, modseq: 9]
    #     # => Net::IMAP::SearchResult[1, 3, 5, modseq: 9]
    #
    # source://net-imap//lib/net/imap/search_result.rb#16
    def [](*seq_nums, modseq: T.unsafe(nil)); end
  end
end

# An \IMAP sequence set is a set of message sequence numbers or unique
# identifier numbers ("UIDs").  It contains numbers and ranges of numbers.
# The numbers are all non-zero unsigned 32-bit integers and one special
# value (<tt>"*"</tt>) that represents the largest value in the mailbox.
#
# Certain types of \IMAP responses will contain a SequenceSet, for example
# the data for a <tt>"MODIFIED"</tt> ResponseCode.  Some \IMAP commands may
# receive a SequenceSet as an argument, for example IMAP#search, IMAP#fetch,
# and IMAP#store.
#
# == Creating sequence sets
#
# SequenceSet.new may receive a single optional argument: a non-zero 32 bit
# unsigned integer, a range, a <tt>sequence-set</tt> formatted string,
# another SequenceSet, a Set (containing only numbers or <tt>*</tt>), or an
# Array containing any of these (array inputs may be nested).
#
#     set = Net::IMAP::SequenceSet.new(1)
#     set.valid_string  #=> "1"
#     set = Net::IMAP::SequenceSet.new(1..100)
#     set.valid_string  #=> "1:100"
#     set = Net::IMAP::SequenceSet.new(1...100)
#     set.valid_string  #=> "1:99"
#     set = Net::IMAP::SequenceSet.new([1, 2, 5..])
#     set.valid_string  #=> "1:2,5:*"
#     set = Net::IMAP::SequenceSet.new("1,2,3:7,5,6:10,2048,1024")
#     set.valid_string  #=> "1,2,3:7,5,6:10,2048,1024"
#     set = Net::IMAP::SequenceSet.new(1, 2, 3..7, 5, 6..10, 2048, 1024)
#     set.valid_string  #=> "1:10,55,1024:2048"
#
# SequenceSet.new with no arguments creates an empty sequence set.  Note
# that an empty sequence set is invalid in the \IMAP grammar.
#
#     set = Net::IMAP::SequenceSet.new
#     set.empty?        #=> true
#     set.valid?        #=> false
#     set.valid_string  #!> raises DataFormatError
#     set << 1..10
#     set.empty?        #=> false
#     set.valid?        #=> true
#     set.valid_string  #=> "1:10"
#
# Using SequenceSet.new with another SequenceSet input behaves the same as
# calling #dup on the other set.  The input's #string will be preserved.
#
#     input = Net::IMAP::SequenceSet.new("1,2,3:7,5,6:10,2048,1024")
#     copy  = Net::IMAP::SequenceSet.new(input)
#     input.valid_string  #=> "1,2,3:7,5,6:10,2048,1024"
#     copy.valid_string   #=> "1,2,3:7,5,6:10,2048,1024"
#     copy2 = input.dup   # same as calling new with a SequenceSet input
#     copy ==     input   #=> true,  same set membership
#     copy.eql?   input   #=> true,  same string value
#     copy.equal? input   #=> false, different objects
#
#     copy.normalize!
#     copy.valid_string   #=> "1:10,1024,2048"
#     copy ==   input     #=> true,  same set membership
#     copy.eql? input     #=> false, different string value
#
#     copy << 999
#     copy.valid_string   #=> "1:10,999,1024,2048"
#     copy ==   input     #=> false, different set membership
#     copy.eql? input     #=> false, different string value
#
# Use Net::IMAP::SequenceSet() to coerce a single (optional) input.
# A SequenceSet input is returned without duplication, even when frozen.
#
#     set = Net::IMAP::SequenceSet()
#     set.string   #=> nil
#     set.frozen?  #=> false
#
#     # String order is preserved
#     set = Net::IMAP::SequenceSet("1,2,3:7,5,6:10,2048,1024")
#     set.valid_string  #=> "1,2,3:7,5,6:10,2048,1024"
#     set.frozen?       #=> false
#
#     # Other inputs are normalized
#     set = Net::IMAP::SequenceSet([1, 2, [3..7, 5], 6..10, 2048, 1024])
#     set.valid_string  #=> "1:10,1024,2048"
#     set.frozen?       #=> false
#
#     unfrozen = set
#     frozen   = set.dup.freeze
#     unfrozen.equal? Net::IMAP::SequenceSet(unfrozen)  #=> true
#     frozen.equal?   Net::IMAP::SequenceSet(frozen)    #=> true
#
# Use ::[] to coerce one or more arguments into a valid frozen SequenceSet.
# A valid frozen SequenceSet is returned directly, without allocating a new
# object.  ::[] will not create an invalid (empty) set.
#
#     Net::IMAP::SequenceSet[]     #!> raises ArgumentError
#     Net::IMAP::SequenceSet[nil]  #!> raises DataFormatError
#     Net::IMAP::SequenceSet[""]   #!> raises DataFormatError
#
#     # String order is preserved
#     set = Net::IMAP::SequenceSet["1,2,3:7,5,6:10,2048,1024"]
#     set.valid_string  #=> "1,2,3:7,5,6:10,2048,1024"
#     set.frozen?       #=> true
#
#     # Other inputs are normalized
#     set = Net::IMAP::SequenceSet[1, 2, [3..7, 5], 6..10, 2048, 1024]
#     set.valid_string  #=> "1:10,1024,2048"
#     set.frozen?       #=> true
#
#     frozen   = set
#     unfrozen = set.dup
#     frozen.equal?   Net::IMAP::SequenceSet[frozen]    #=> true
#     unfrozen.equal? Net::IMAP::SequenceSet[unfrozen]  #=> false
#
# Objects which respond to +to_sequence_set+ (such as SearchResult and
# ThreadMember) can be coerced to a SequenceSet with ::new, ::try_convert,
# ::[], or Net::IMAP::SequenceSet.
#
#     search = imap.uid_search(["SUBJECT", "hello", "NOT", "SEEN"])
#     seqset = Net::IMAP::SequenceSet(search) - already_fetched
#     fetch  = imap.uid_fetch(seqset, "FAST")
#
# == Ordered and Normalized sets
#
# Sometimes the order of the set's members is significant, such as with the
# +ESORT+, <tt>CONTEXT=SORT</tt>, and +UIDPLUS+ extensions.  So, when a
# sequence set is created from a single string (such as by the parser), that
# #string representation is preserved.  Assigning a string with #string= or
# #replace will also preserve that string.  Use #each_entry, #entries, or
# #each_ordered_number to enumerate the entries in their #string order.
# Hash equality (using #eql?) is based on the string representation.
#
# Internally, SequenceSet uses a normalized uint32 set representation which
# sorts and de-duplicates all numbers and coalesces adjacent or overlapping
# entries.  Many methods use this sorted set representation for <tt>O(lg
# n)</tt> searches.  Use #each_element, #elements, #each_range, #ranges,
# #each_number, or #numbers to enumerate the set in sorted order.  Basic
# object equality (using #==) is based on set membership, without regard to
# #entry order or #string normalization.
#
# Most modification methods reset #string to its #normalized form, so that
# #entries and #elements are identical.  Use #append to preserve #entries
# order while modifying a set.
#
# == Using <tt>*</tt>
#
# \IMAP sequence sets may contain a special value <tt>"*"</tt>, which
# represents the largest number in use.  From +seq-number+ in
# {RFC9051 §9}[https://www.rfc-editor.org/rfc/rfc9051.html#section-9-5]:
# >>>
#   In the case of message sequence numbers, it is the number of messages
#   in a non-empty mailbox.  In the case of unique identifiers, it is the
#   unique identifier of the last message in the mailbox or, if the
#   mailbox is empty, the mailbox's current UIDNEXT value.
#
# When creating a SequenceSet, <tt>*</tt> may be input as <tt>-1</tt>,
# <tt>"*"</tt>, <tt>:*</tt>, an endless range, or a range ending in
# <tt>-1</tt>.  When converting to #elements, #ranges, or #numbers, it will
# output as either <tt>:*</tt> or an endless range.  For example:
#
#   Net::IMAP::SequenceSet["1,3,*"].to_a      #=> [1, 3, :*]
#   Net::IMAP::SequenceSet["1,234:*"].to_a    #=> [1, 234..]
#   Net::IMAP::SequenceSet[1234..-1].to_a     #=> [1234..]
#   Net::IMAP::SequenceSet[1234..].to_a       #=> [1234..]
#
#   Net::IMAP::SequenceSet[1234..].to_s       #=> "1234:*"
#   Net::IMAP::SequenceSet[1234..-1].to_s     #=> "1234:*"
#
# Use #limit to convert <tt>"*"</tt> to a maximum value.  When a range
# includes <tt>"*"</tt>, the maximum value will always be matched:
#
#   Net::IMAP::SequenceSet["9999:*"].limit(max: 25)
#   #=> Net::IMAP::SequenceSet["25"]
#
# === Surprising <tt>*</tt> behavior
#
# When a set includes <tt>*</tt>, some methods may have surprising behavior.
#
# For example, #complement treats <tt>*</tt> as its own number.  This way,
# the #intersection of a set and its #complement will always be empty.  And
# <tt>*</tt> is sorted as greater than any other number in the set.  This is
# not how an \IMAP server interprets the set: it will convert <tt>*</tt> to
# the number of messages in the mailbox, the +UID+ of the last message in
# the mailbox, or +UIDNEXT+, as appropriate.  Several methods have an
# argument for how <tt>*</tt> should be interpreted.
#
# But, for example, this means that there may be overlap between a set and
# its complement after #limit is applied to each:
#
#   ~Net::IMAP::SequenceSet["*"]  == Net::IMAP::SequenceSet[1..(2**32-1)]
#   ~Net::IMAP::SequenceSet[1..5] == Net::IMAP::SequenceSet["6:*"]
#
#   set = Net::IMAP::SequenceSet[1..5]
#   (set & ~set).empty? => true
#
#   (set.limit(max: 4) & (~set).limit(max: 4)).to_a => [4]
#
# When counting the number of numbers in a set, <tt>*</tt> will be counted
# _except_ when UINT32_MAX is also in the set:
#   UINT32_MAX = 2**32 - 1
#   Net::IMAP::SequenceSet["*"].count                   => 1
#   Net::IMAP::SequenceSet[1..UINT32_MAX - 1, :*].count => UINT32_MAX
#
#   Net::IMAP::SequenceSet["1:*"].count                 => UINT32_MAX
#   Net::IMAP::SequenceSet[UINT32_MAX, :*].count        => 1
#   Net::IMAP::SequenceSet[UINT32_MAX..].count          => 1
#
# == What's here?
#
# SequenceSet provides methods for:
# * {Creating a SequenceSet}[rdoc-ref:SequenceSet@Methods+for+Creating+a+SequenceSet]
# * {Comparing}[rdoc-ref:SequenceSet@Methods+for+Comparing]
# * {Querying}[rdoc-ref:SequenceSet@Methods+for+Querying]
# * {Iterating}[rdoc-ref:SequenceSet@Methods+for+Iterating]
# * {Set Operations}[rdoc-ref:SequenceSet@Methods+for+Set+Operations]
# * {Assigning}[rdoc-ref:SequenceSet@Methods+for+Assigning]
# * {Deleting}[rdoc-ref:SequenceSet@Methods+for+Deleting]
# * {IMAP String Formatting}[rdoc-ref:SequenceSet@Methods+for+IMAP+String+Formatting]
#
# === Methods for Creating a \SequenceSet
# * ::[]: Creates a validated frozen sequence set from one or more inputs.
# * ::new: Creates a new mutable sequence set, which may be empty (invalid).
# * ::try_convert: Calls +to_sequence_set+ on an object and verifies that
#   the result is a SequenceSet.
# * Net::IMAP::SequenceSet(): Coerce an input using ::try_convert or ::new.
# * ::empty: Returns a frozen empty (invalid) SequenceSet.
# * ::full: Returns a frozen SequenceSet containing every possible number.
#
# === Methods for Comparing
#
# <i>Comparison to another \SequenceSet:</i>
# - #==: Returns whether a given set contains the same numbers as +self+.
# - #eql?: Returns whether a given set uses the same #string as +self+.
#
# <i>Comparison to objects which are convertible to \SequenceSet:</i>
# - #===:
#   Returns whether a given object is fully contained within +self+, or
#   +nil+ if the object cannot be converted to a compatible type.
# - #cover?:
#   Returns whether a given object is fully contained within +self+.
# - #intersect? (aliased as #overlap?):
#   Returns whether +self+ and a given object have any common elements.
# - #disjoint?:
#   Returns whether +self+ and a given object have no common elements.
#
# === Methods for Querying
# These methods do not modify +self+.
#
# <i>Set membership:</i>
# - #include? (aliased as #member?):
#   Returns whether a given element is contained by the set.
# - #include_star?: Returns whether the set contains <tt>*</tt>.
#
# <i>Minimum and maximum value elements:</i>
# - #min: Returns one or more of the lowest numbers in the set.
# - #max: Returns one or more of the highest numbers in the set.
# - #minmax: Returns the lowest and highest numbers in the set.
#
# <i>Accessing value by offset in sorted set:</i>
# - #[] (aliased as #slice): Returns the number or consecutive subset at a
#   given offset or range of offsets in the sorted set.
# - #at: Returns the number at a given offset in the sorted set.
# - #find_index: Returns the given number's offset in the sorted set.
#
# <i>Accessing value by offset in ordered entries</i>
# - #ordered_at: Returns the number at a given offset in the ordered entries.
# - #find_ordered_index: Returns the index of the given number's first
#   occurrence in entries.
#
# <i>Set cardinality:</i>
# - #count (aliased as #size): Returns the count of numbers in the set.
#   Duplicated numbers are not counted.
# - #empty?: Returns whether the set has no members.  \IMAP syntax does not
#   allow empty sequence sets.
# - #valid?: Returns whether the set has any members.
# - #full?: Returns whether the set contains every possible value, including
#   <tt>*</tt>.
#
# <i>Denormalized properties:</i>
# - #has_duplicates?: Returns whether the ordered entries repeat any
#   numbers.
# - #count_duplicates: Returns the count of repeated numbers in the ordered
#   entries.
# - #count_with_duplicates: Returns the count of numbers in the ordered
#   entries, including any repeated numbers.
#
# === Methods for Iterating
#
# <i>Normalized (sorted and coalesced):</i>
# - #each_element: Yields each number and range in the set, sorted and
#   coalesced, and returns +self+.
# - #elements (aliased as #to_a): Returns an Array of every number and range
#   in the set, sorted and coalesced.
# - #each_range:
#   Yields each element in the set as a Range and returns +self+.
# - #ranges: Returns an Array of every element in the set, converting
#   numbers into ranges of a single value.
# - #each_number: Yields each number in the set and returns +self+.
# - #numbers: Returns an Array with every number in the set, expanding
#   ranges into all of their contained numbers.
# - #to_set: Returns a Set containing all of the #numbers in the set.
#
# <i>Order preserving:</i>
# - #each_entry: Yields each number and range in the set, unsorted and
#   without deduplicating numbers or coalescing ranges, and returns +self+.
# - #entries: Returns an Array of every number and range in the set,
#   unsorted and without deduplicating numbers or coalescing ranges.
# - #each_ordered_number: Yields each number in the ordered entries and
#   returns +self+.
#
# === Methods for \Set Operations
# These methods do not modify +self+.
#
# - #| (aliased as #union and #+): Returns a new set combining all members
#   from +self+ with all members from the other set.
# - #& (aliased as #intersection): Returns a new set containing all members
#   common to +self+ and the other set.
# - #- (aliased as #difference): Returns a copy of +self+ with all members
#   in the other set removed.
# - #^ (aliased as #xor): Returns a new set containing all members from
#   +self+ and the other set except those common to both.
# - #~ (aliased as #complement): Returns a new set containing all members
#   that are not in +self+
# - #above: Return a copy of +self+ which only contains numbers above a
#   given number.
# - #below: Return a copy of +self+ which only contains numbers below a
#   given value.
# - #limit: Returns a copy of +self+ which has replaced <tt>*</tt> with a
#   given maximum value and removed all members over that maximum.
#
# === Methods for Assigning
# These methods add or replace elements in +self+.
#
# <i>Normalized (sorted and coalesced):</i>
#
# These methods always update #string to be fully sorted and coalesced.
#
# - #add (aliased as #<<): Adds a given element to the set; returns +self+.
# - #add?: If the given element is not fully included the set, adds it and
#   returns +self+; otherwise, returns +nil+.
# - #merge: Adds all members of the given sets into this set; returns +self+.
# - #complement!: Replaces the contents of the set with its own #complement.
#
# <i>Order preserving:</i>
#
# These methods _may_ cause #string to not be sorted or coalesced.
#
# - #append: Adds the given entry to the set, appending it to the existing
#   string, and returns +self+.
# - #string=: Assigns a new #string value and replaces #elements to match.
# - #replace: Replaces the contents of the set with the contents
#   of a given object.
#
# === Methods for Deleting
# These methods remove elements from +self+, and update #string to be fully
# sorted and coalesced.
#
# - #clear: Removes all elements in the set; returns +self+.
# - #delete: Removes a given element from the set; returns +self+.
# - #delete?: If the given element is included in the set, removes it and
#   returns it; otherwise, returns +nil+.
# - #delete_at: Removes the number at a given offset.
# - #slice!: Removes the number or consecutive numbers at a given offset or
#   range of offsets.
# - #subtract: Removes all members of the given sets from this set; returns
#   +self+.
# - #limit!: Replaces <tt>*</tt> with a given maximum value and removes all
#   members over that maximum; returns +self+.
#
# === Methods for \IMAP String Formatting
#
# - #to_s: Returns the +sequence-set+ string, or an empty string when the
#   set is empty.
# - #string: Returns the +sequence-set+ string, or nil when empty.
# - #valid_string: Returns the +sequence-set+ string, or raises
#   DataFormatError when the set is empty.
# - #normalized_string: Returns a <tt>sequence-set</tt> string with its
#   elements sorted and coalesced, or nil when the set is empty.
# - #normalize: Returns a new set with this set's normalized +sequence-set+
#   representation.
# - #normalize!: Updates #string to its normalized +sequence-set+
#   representation and returns +self+.
#
# source://net-imap//lib/net/imap/sequence_set.rb#387
class Net::IMAP::SequenceSet
  # Create a new SequenceSet object from +input+, which may be another
  # SequenceSet, an IMAP formatted +sequence-set+ string, a non-zero 32 bit
  # unsigned integer, a range, <tt>:*</tt>, a Set of numbers or <tt>*</tt>,
  # an object that responds to +to_sequence_set+ (such as SearchResult) or
  # an Array of these (array inputs may be nested).
  #
  #     set = Net::IMAP::SequenceSet.new(1)
  #     set.valid_string  #=> "1"
  #     set = Net::IMAP::SequenceSet.new(1..100)
  #     set.valid_string  #=> "1:100"
  #     set = Net::IMAP::SequenceSet.new(1...100)
  #     set.valid_string  #=> "1:99"
  #     set = Net::IMAP::SequenceSet.new([1, 2, 5..])
  #     set.valid_string  #=> "1:2,5:*"
  #     set = Net::IMAP::SequenceSet.new("1,2,3:7,5,6:10,2048,1024")
  #     set.valid_string  #=> "1,2,3:7,5,6:10,2048,1024"
  #     set = Net::IMAP::SequenceSet.new(1, 2, 3..7, 5, 6..10, 2048, 1024)
  #     set.valid_string  #=> "1:10,1024,2048"
  #
  # With no arguments (or +nil+) creates an empty sequence set.  Note that
  # an empty sequence set is invalid in the \IMAP grammar.
  #
  #     set = Net::IMAP::SequenceSet.new
  #     set.empty?        #=> true
  #     set.valid?        #=> false
  #     set.valid_string  #!> raises DataFormatError
  #     set << 1..10
  #     set.empty?        #=> false
  #     set.valid?        #=> true
  #     set.valid_string  #=> "1:10"
  #
  # When +input+ is a SequenceSet, ::new behaves the same as calling #dup on
  # that other set.  The input's #string will be preserved.
  #
  #     input = Net::IMAP::SequenceSet.new("1,2,3:7,5,6:10,2048,1024")
  #     copy  = Net::IMAP::SequenceSet.new(input)
  #     input.valid_string  #=> "1,2,3:7,5,6:10,2048,1024"
  #     copy.valid_string   #=> "1,2,3:7,5,6:10,2048,1024"
  #     copy2 = input.dup   # same as calling new with a SequenceSet input
  #     copy ==     input   #=> true,  same set membership
  #     copy.eql?   input   #=> true,  same string value
  #     copy.equal? input   #=> false, different objects
  #
  #     copy.normalize!
  #     copy.valid_string   #=> "1:10,1024,2048"
  #     copy ==   input     #=> true,  same set membership
  #     copy.eql? input     #=> false, different string value
  #
  #     copy << 999
  #     copy.valid_string   #=> "1:10,999,1024,2048"
  #     copy ==   input     #=> false, different set membership
  #     copy.eql? input     #=> false, different string value
  #
  # === Alternative set creation methods
  #
  # * ::[] returns a frozen validated (non-empty) SequenceSet, without
  #   allocating a new object when the input is already a valid frozen
  #   SequenceSet.
  # * Net::IMAP::SequenceSet() coerces an input to SequenceSet, without
  #   allocating a new object when the input is already a SequenceSet.
  # * ::try_convert calls +to_sequence_set+ on inputs that support it and
  #   returns +nil+ for inputs that don't.
  # * ::empty and ::full both return frozen singleton sets which can be
  #   combined with set operations (#|, #&, #^, #-, etc) to make new sets.
  #
  # See SequenceSet@Creating+sequence+sets.
  #
  # @return [SequenceSet] a new instance of SequenceSet
  #
  # source://net-imap//lib/net/imap/sequence_set.rb#534
  def initialize(input = T.unsafe(nil)); end

  # :call-seq:
  #   self & other        -> sequence set
  #   intersection(other) -> sequence set
  #
  # Returns a new sequence set containing only the numbers common to this
  # set and +other+.
  #
  # +other+ may be any object that would be accepted by ::new.
  #
  #     Net::IMAP::SequenceSet[1..5] & [2, 4, 6]
  #     #=> Net::IMAP::SequenceSet["2,4"]
  #
  # Related: #intersect?, #|, #-, #^, #~
  #
  # ==== Set identities
  #
  # <tt>lhs & rhs</tt> is equivalent to:
  # * <tt>rhs & lhs</tt> (commutative)
  # * <tt>~(~lhs | ~rhs)</tt> (De Morgan's Law)
  # * <tt>lhs - ~rhs</tt>
  # * <tt>lhs - (lhs - rhs)</tt>
  # * <tt>lhs - (lhs ^ rhs)</tt>
  # * <tt>lhs ^ (lhs - rhs)</tt>
  #
  # source://net-imap//lib/net/imap/sequence_set.rb#876
  def &(other); end

  # :call-seq:
  #   self + other -> sequence set
  #   self | other -> sequence set
  #   union(other) -> sequence set
  #
  # Returns a new sequence set that has every number in the +other+ object
  # added.
  #
  # +other+ may be any object that would be accepted by ::new.
  #
  #     Net::IMAP::SequenceSet["1:5"] | 2 | [4..6, 99]
  #     #=> Net::IMAP::SequenceSet["1:6,99"]
  #
  # Related: #add, #merge, #&, #-, #^, #~
  #
  # ==== Set identities
  #
  # <tt>lhs | rhs</tt> is equivalent to:
  # * <tt>rhs | lhs</tt> (commutative)
  # * <tt>~(~lhs & ~rhs)</tt> (De Morgan's Law)
  # * <tt>(lhs & rhs) ^ (lhs ^ rhs)</tt>
  #
  # source://net-imap//lib/net/imap/sequence_set.rb#824
  def +(other); end

  # :call-seq:
  #   self - other      -> sequence set
  #   difference(other) -> sequence set
  #
  # Returns a new sequence set built by duplicating this set and removing
  # every number that appears in +other+.
  #
  # +other+ may be any object that would be accepted by ::new.
  #
  #     Net::IMAP::SequenceSet[1..5] - 2 - 4 - 6
  #     #=> Net::IMAP::SequenceSet["1,3,5"]
  #
  # Related: #subtract, #|, #&, #^, #~
  #
  # ==== Set identities
  #
  # <tt>lhs - rhs</tt> is equivalent to:
  # * <tt>~rhs - ~lhs</tt>
  # * <tt>lhs & ~rhs</tt>
  # * <tt>~(~lhs | rhs)</tt>
  # * <tt>lhs & (lhs ^ rhs)</tt>
  # * <tt>lhs ^ (lhs & rhs)</tt>
  # * <tt>rhs ^ (lhs | rhs)</tt>
  #
  # source://net-imap//lib/net/imap/sequence_set.rb#850
  def -(other); end

  # :call-seq:
  #   add(element)   -> self
  #   self << other -> self
  #
  # Adds a range or number to the set and returns +self+.
  #
  # #string will be regenerated.  Use #merge to add many elements at once.
  #
  # Use #append to append new elements to #string.  See
  # SequenceSet@Ordered+and+Normalized+sets.
  #
  # Related: #add?, #merge, #union, #append
  #
  # source://net-imap//lib/net/imap/sequence_set.rb#946
  def <<(element); end

  # :call-seq: self == other -> true or false
  #
  # Returns true when the other SequenceSet represents the same message
  # identifiers.  Encoding difference—such as order, overlaps, or
  # duplicates—are ignored.
  #
  #   Net::IMAP::SequenceSet["1:3"]   == Net::IMAP::SequenceSet["1:3"]
  #   #=> true
  #   Net::IMAP::SequenceSet["1,2,3"] == Net::IMAP::SequenceSet["1:3"]
  #   #=> true
  #   Net::IMAP::SequenceSet["1,3"]   == Net::IMAP::SequenceSet["3,1"]
  #   #=> true
  #   Net::IMAP::SequenceSet["9,1:*"] == Net::IMAP::SequenceSet["1:*"]
  #   #=> true
  #
  # Related: #eql?, #normalize
  #
  # source://net-imap//lib/net/imap/sequence_set.rb#642
  def ==(other); end

  # :call-seq: self === other -> true | false | nil
  #
  # Returns whether +other+ is contained within the set.  +other+ may be any
  # object that would be accepted by ::new.  Returns +nil+ if StandardError
  # is raised while converting +other+ to a comparable type.
  #
  # Related: #cover?, #include?, #include_star?
  #
  # source://net-imap//lib/net/imap/sequence_set.rb#673
  def ===(other); end

  # :call-seq:
  #    seqset[index]         -> integer or :* or nil
  #    slice(index)          -> integer or :* or nil
  #    seqset[start, length] -> sequence set or nil
  #    slice(start, length)  -> sequence set or nil
  #    seqset[range]         -> sequence set or nil
  #    slice(range)          -> sequence set or nil
  #
  # Returns a number or a subset from the _sorted_ set, without modifying
  # the set.
  #
  # When an Integer argument +index+ is given, the number at offset +index+
  # in the sorted set is returned:
  #
  #     set = Net::IMAP::SequenceSet["10:15,20:23,26"]
  #     set[0]   #=> 10
  #     set[5]   #=> 15
  #     set[10]  #=> 26
  #
  # If +index+ is negative, it counts relative to the end of the sorted set:
  #     set = Net::IMAP::SequenceSet["10:15,20:23,26"]
  #     set[-1]  #=> 26
  #     set[-3]  #=> 22
  #     set[-6]  #=> 15
  #
  # If +index+ is out of range, +nil+ is returned.
  #
  #     set = Net::IMAP::SequenceSet["10:15,20:23,26"]
  #     set[11]  #=> nil
  #     set[-12] #=> nil
  #
  # The result is based on the sorted and de-duplicated set, not on the
  # ordered #entries in #string.
  #
  #     set = Net::IMAP::SequenceSet["12,20:23,11:16,21"]
  #     set[0]   #=> 11
  #     set[-1]  #=> 23
  #
  # Related: #at
  #
  # source://net-imap//lib/net/imap/sequence_set.rb#1464
  def [](index, length = T.unsafe(nil)); end

  # :call-seq:
  #   self ^ other -> sequence set
  #   xor(other)   -> sequence set
  #
  # Returns a new sequence set containing numbers that are exclusive between
  # this set and +other+.
  #
  # +other+ may be any object that would be accepted by ::new.
  #
  #     Net::IMAP::SequenceSet[1..5] ^ [2, 4, 6]
  #     #=> Net::IMAP::SequenceSet["1,3,5:6"]
  #
  # Related: #|, #&, #-, #~
  #
  # ==== Set identities
  #
  # <tt>lhs ^ rhs</tt> is equivalent to:
  # * <tt>rhs ^ lhs</tt> (commutative)
  # * <tt>~lhs ^ ~rhs</tt>
  # * <tt>(lhs | rhs) - (lhs & rhs)</tt>
  # * <tt>(lhs - rhs) | (rhs - lhs)</tt>
  # * <tt>(lhs ^ other) ^ (other ^ rhs)</tt>
  #
  # source://net-imap//lib/net/imap/sequence_set.rb#903
  def ^(other); end

  # Returns a copy of +self+ which only contains the numbers above +num+.
  #
  #   Net::IMAP::SequenceSet["5,10:22,50"].above(10) # to_s => "11:22,50"
  #   Net::IMAP::SequenceSet["5,10:22,50"].above(20) # to_s => "21:22,50
  #   Net::IMAP::SequenceSet["5,10:22,50"].above(30) # to_s => "50"
  #
  # This returns the same result as #intersection with <tt>((num+1)..)</tt>
  # or #difference with <tt>(..num)</tt>.
  #
  #   Net::IMAP::SequenceSet["5,10:22,50"] & (11..)   # to_s => "11:22,50"
  #   Net::IMAP::SequenceSet["5,10:22,50"] - (..10)   # to_s => "11:22,50"
  #   Net::IMAP::SequenceSet["5,10:22,50"] & (21..)   # to_s => "21:22,50"
  #   Net::IMAP::SequenceSet["5,10:22,50"] - (..20)   # to_s => "21:22,50"
  #
  # Related: #above, #-, #&
  #
  # source://net-imap//lib/net/imap/sequence_set.rb#1519
  def above(num); end

  # :call-seq:
  #   add(element)   -> self
  #   self << other -> self
  #
  # Adds a range or number to the set and returns +self+.
  #
  # #string will be regenerated.  Use #merge to add many elements at once.
  #
  # Use #append to append new elements to #string.  See
  # SequenceSet@Ordered+and+Normalized+sets.
  #
  # Related: #add?, #merge, #union, #append
  #
  # source://net-imap//lib/net/imap/sequence_set.rb#941
  def add(element); end

  # :call-seq: add?(element) -> self or nil
  #
  # Adds a range or number to the set and returns +self+.  Returns +nil+
  # when the element is already included in the set.
  #
  # #string will be regenerated.  Use #merge to add many elements at once.
  #
  # Related: #add, #merge, #union, #include?
  #
  # @return [Boolean]
  #
  # source://net-imap//lib/net/imap/sequence_set.rb#974
  def add?(element); end

  # Adds a range or number to the set and returns +self+.
  #
  # Unlike #add, #merge, or #union, the new value is appended to #string.
  # This may result in a #string which has duplicates or is out-of-order.
  #
  # See SequenceSet@Ordered+and+Normalized+sets.
  #
  # Related: #add, #merge, #union
  #
  # source://net-imap//lib/net/imap/sequence_set.rb#956
  def append(entry); end

  # :call-seq: at(index) -> integer or nil
  #
  # Returns the number at the given +index+ in the sorted set, without
  # modifying the set.
  #
  # +index+ is interpreted the same as in #[], except that #at only allows a
  # single integer argument.
  #
  # Related: #[], #slice, #ordered_at
  #
  # source://net-imap//lib/net/imap/sequence_set.rb#1394
  def at(index); end

  # Returns a copy of +self+ which only contains numbers below +num+.
  #
  #   Net::IMAP::SequenceSet["5,10:22,50"].below(10) # to_s => "5"
  #   Net::IMAP::SequenceSet["5,10:22,50"].below(20) # to_s => "5,10:19"
  #   Net::IMAP::SequenceSet["5,10:22,50"].below(30) # to_s => "5,10:22"
  #
  # This returns the same result as #intersection with <tt>(..(num-1))</tt>
  # or #difference with <tt>(num..)</tt>.
  #
  #   Net::IMAP::SequenceSet["5,10:22,50"] & (..9)    # to_s => "5"
  #   Net::IMAP::SequenceSet["5,10:22,50"] - (10..)   # to_s => "5"
  #   Net::IMAP::SequenceSet["5,10:22,50"] & (..19)   # to_s => "5,10:19"
  #   Net::IMAP::SequenceSet["5,10:22,50"] - (20..)   # to_s => "5,10:19"
  #
  # When the set does not contain <tt>*</tt>, #below is identical to #limit
  # with <tt>max: num - 1</tt>.  When the set does contain <tt>*</tt>,
  # #below always drops it from the result.  Use #limit when the IMAP
  # semantics for <tt>*</tt> must be enforced.
  #
  #   Net::IMAP::SequenceSet["5,10:22,50"].below(30)      # to_s => "5,10:22"
  #   Net::IMAP::SequenceSet["5,10:22,50"].limit(max: 29) # to_s => "5,10:22"
  #   Net::IMAP::SequenceSet["5,10:22,*"].below(30)       # to_s => "5,10:22"
  #   Net::IMAP::SequenceSet["5,10:22,*"].limit(max: 29)  # to_s => "5,10:22,29"
  #
  # Related: #above, #-, #&, #limit
  #
  # source://net-imap//lib/net/imap/sequence_set.rb#1550
  def below(num); end

  # Removes all elements and returns self.
  #
  # source://net-imap//lib/net/imap/sequence_set.rb#537
  def clear; end

  # :call-seq:
  #   ~ self     -> sequence set
  #   complement -> sequence set
  #
  # Returns the complement of self, a SequenceSet which contains all numbers
  # _except_ for those in this set.
  #
  #     ~Net::IMAP::SequenceSet.full  #=> Net::IMAP::SequenceSet.empty
  #     ~Net::IMAP::SequenceSet.empty #=> Net::IMAP::SequenceSet.full
  #     ~Net::IMAP::SequenceSet["1:5,100:222"]
  #     #=> Net::IMAP::SequenceSet["6:99,223:*"]
  #     ~Net::IMAP::SequenceSet["6:99,223:*"]
  #     #=> Net::IMAP::SequenceSet["1:5,100:222"]
  #
  # Related: #complement!, #|, #&, #-, #^
  #
  # ==== Set identities
  #
  # <tt>~set</tt> is equivalent to:
  # * <tt>full - set</tt>, where "full" is Net::IMAP::SequenceSet.full
  #
  # source://net-imap//lib/net/imap/sequence_set.rb#927
  def complement; end

  # :call-seq: complement! -> self
  #
  # Converts the SequenceSet to its own #complement.  It will contain all
  # possible values _except_ for those currently in the set.
  #
  # Related: #complement
  #
  # source://net-imap//lib/net/imap/sequence_set.rb#1602
  def complement!; end

  # Returns the count of #numbers in the set.
  #
  # <tt>*</tt> will be counted as <tt>2**32 - 1</tt> (the maximum 32-bit
  # unsigned integer value).
  #
  # Related: #count_with_duplicates
  #
  # source://net-imap//lib/net/imap/sequence_set.rb#1289
  def count; end

  # Returns the count of repeated numbers in the ordered #entries, the
  # difference between #count_with_duplicates and #count.
  #
  # When #string is normalized, this is zero.
  #
  # Related: #entries, #count_with_duplicates, #has_duplicates?
  #
  # source://net-imap//lib/net/imap/sequence_set.rb#1318
  def count_duplicates; end

  # Returns the count of numbers in the ordered #entries, including any
  # repeated numbers.
  #
  # <tt>*</tt> will be counted as <tt>2**32 - 1</tt> (the maximum 32-bit
  # unsigned integer value).
  #
  # When #string is normalized, this behaves the same as #count.
  #
  # Related: #entries, #count_duplicates, #has_duplicates?
  #
  # source://net-imap//lib/net/imap/sequence_set.rb#1305
  def count_with_duplicates; end

  # :call-seq: cover?(other) -> true | false | nil
  #
  # Returns whether +other+ is contained within the set.  +other+ may be any
  # object that would be accepted by ::new.
  #
  # Related: #===, #include?, #include_star?, #intersect?
  #
  # @return [Boolean]
  #
  # source://net-imap//lib/net/imap/sequence_set.rb#685
  def cover?(other); end

  # Returns an array with #normalized_string when valid and an empty array
  # otherwise.
  #
  # source://net-imap//lib/net/imap/sequence_set.rb#587
  def deconstruct; end

  # :call-seq: delete(element) -> self
  #
  # Deletes the given range or number from the set and returns +self+.
  #
  # #string will be regenerated after deletion.  Use #subtract to remove
  # many elements at once.
  #
  # Related: #delete?, #delete_at, #subtract, #difference
  #
  # source://net-imap//lib/net/imap/sequence_set.rb#987
  def delete(element); end

  # :call-seq:
  #   delete?(number) -> integer or nil
  #   delete?(star)   -> :* or nil
  #   delete?(range)  -> sequence set or nil
  #
  # Removes a specified value from the set, and returns the removed value.
  # Returns +nil+ if nothing was removed.
  #
  # Returns an integer when the specified +number+ argument was removed:
  #     set = Net::IMAP::SequenceSet.new [5..10, 20]
  #     set.delete?(7)      #=> 7
  #     set                 #=> #<Net::IMAP::SequenceSet "5:6,8:10,20">
  #     set.delete?("20")   #=> 20
  #     set                 #=> #<Net::IMAP::SequenceSet "5:6,8:10">
  #     set.delete?(30)     #=> nil
  #
  # Returns <tt>:*</tt> when <tt>*</tt> or <tt>-1</tt> is specified and
  # removed:
  #     set = Net::IMAP::SequenceSet.new "5:9,20,35,*"
  #     set.delete?(-1)  #=> :*
  #     set              #=> #<Net::IMAP::SequenceSet "5:9,20,35">
  #
  # And returns a new SequenceSet when a range is specified:
  #
  #     set = Net::IMAP::SequenceSet.new [5..10, 20]
  #     set.delete?(9..)  #=> #<Net::IMAP::SequenceSet "9:10,20">
  #     set               #=> #<Net::IMAP::SequenceSet "5:8">
  #     set.delete?(21..) #=> nil
  #
  # #string will be regenerated after deletion.
  #
  # Related: #delete, #delete_at, #subtract, #difference, #disjoint?
  #
  # @return [Boolean]
  #
  # source://net-imap//lib/net/imap/sequence_set.rb#1025
  def delete?(element); end

  # :call-seq: delete_at(index) -> number or :* or nil
  #
  # Deletes a number the set, indicated by the given +index+.  Returns the
  # number that was removed, or +nil+ if nothing was removed.
  #
  # #string will be regenerated after deletion.
  #
  # Related: #delete, #delete?, #slice!, #subtract, #difference
  #
  # source://net-imap//lib/net/imap/sequence_set.rb#1049
  def delete_at(index); end

  # :call-seq:
  #   self - other      -> sequence set
  #   difference(other) -> sequence set
  #
  # Returns a new sequence set built by duplicating this set and removing
  # every number that appears in +other+.
  #
  # +other+ may be any object that would be accepted by ::new.
  #
  #     Net::IMAP::SequenceSet[1..5] - 2 - 4 - 6
  #     #=> Net::IMAP::SequenceSet["1,3,5"]
  #
  # Related: #subtract, #|, #&, #^, #~
  #
  # ==== Set identities
  #
  # <tt>lhs - rhs</tt> is equivalent to:
  # * <tt>~rhs - ~lhs</tt>
  # * <tt>lhs & ~rhs</tt>
  # * <tt>~(~lhs | rhs)</tt>
  # * <tt>lhs & (lhs ^ rhs)</tt>
  # * <tt>lhs ^ (lhs & rhs)</tt>
  # * <tt>rhs ^ (lhs | rhs)</tt>
  #
  # source://net-imap//lib/net/imap/sequence_set.rb#851
  def difference(other); end

  # Returns +true+ if the set and a given object have no common elements,
  # +false+ otherwise.
  #
  #     Net::IMAP::SequenceSet["5:10"].disjoint? "7,9,11" #=> false
  #     Net::IMAP::SequenceSet["5:10"].disjoint? "11:33"  #=> true
  #
  # Related: #intersection, #intersect?
  #
  # @return [Boolean]
  #
  # source://net-imap//lib/net/imap/sequence_set.rb#740
  def disjoint?(other); end

  # Yields each number or range (or <tt>:*</tt>) in #elements to the block
  # and returns self.  Returns an enumerator when called without a block.
  #
  # The returned numbers are sorted and de-duplicated, even when the input
  # #string is not.  See #normalize, SequenceSet@Ordered+and+Normalized+sets.
  #
  # Related: #elements, #each_entry
  #
  # source://net-imap//lib/net/imap/sequence_set.rb#1195
  def each_element; end

  # Yields each number or range in #string to the block and returns +self+.
  # Returns an enumerator when called without a block.
  #
  # The entries are yielded in the same order they appear in #string, with
  # no sorting, deduplication, or coalescing.  When #string is in its
  # normalized form, this will yield the same values as #each_element.
  #
  # See SequenceSet@Ordered+and+Normalized+sets.
  #
  # Related: #entries, #each_element
  #
  # source://net-imap//lib/net/imap/sequence_set.rb#1183
  def each_entry(&block); end

  # Yields each number in #numbers to the block and returns self.
  # If the set contains a <tt>*</tt>, RangeError will be raised.
  #
  # Returns an enumerator when called without a block (even if the set
  # contains <tt>*</tt>).
  #
  # Related: #numbers, #each_ordered_number
  #
  # @raise [RangeError]
  #
  # source://net-imap//lib/net/imap/sequence_set.rb#1245
  def each_number(&block); end

  # Yields each number in #entries to the block and returns self.
  # If the set contains a <tt>*</tt>, RangeError will be raised.
  #
  # Returns an enumerator when called without a block (even if the set
  # contains <tt>*</tt>).
  #
  # Related: #entries, #each_number
  #
  # @raise [RangeError]
  #
  # source://net-imap//lib/net/imap/sequence_set.rb#1259
  def each_ordered_number(&block); end

  # Yields each range in #ranges to the block and returns self.
  # Returns an enumerator when called without a block.
  #
  # Related: #ranges
  #
  # source://net-imap//lib/net/imap/sequence_set.rb#1227
  def each_range; end

  # Returns an array of ranges and integers and <tt>:*</tt>.
  #
  # The returned elements are sorted and coalesced, even when the input
  # #string is not.  <tt>*</tt> will sort last.  See #normalize,
  # SequenceSet@Ordered+and+Normalized+sets.
  #
  # By itself, <tt>*</tt> translates to <tt>:*</tt>.  A range containing
  # <tt>*</tt> translates to an endless range.  Use #limit to translate both
  # cases to a maximum value.
  #
  #   Net::IMAP::SequenceSet["2,5:9,6,*,12:11"].elements
  #   #=> [2, 5..9, 11..12, :*]
  #
  # Related: #each_element, #ranges, #numbers
  #
  # source://net-imap//lib/net/imap/sequence_set.rb#1124
  def elements; end

  # Returns true if the set contains no elements
  #
  # @return [Boolean]
  #
  # source://net-imap//lib/net/imap/sequence_set.rb#797
  def empty?; end

  # For YAML serialization
  #
  # source://net-imap//lib/net/imap/sequence_set.rb#1725
  def encode_with(coder); end

  # Returns an array of ranges and integers and <tt>:*</tt>.
  #
  # The entries are in the same order they appear in #string, with no
  # sorting, deduplication, or coalescing.  When #string is in its
  # normalized form, this will return the same result as #elements.
  # This is useful when the given order is significant, for example in a
  # ESEARCH response to IMAP#sort.
  #
  # See SequenceSet@Ordered+and+Normalized+sets.
  #
  # Related: #each_entry, #elements
  #
  # source://net-imap//lib/net/imap/sequence_set.rb#1108
  def entries; end

  # :call-seq: eql?(other) -> true or false
  #
  # Hash equality requires the same encoded #string representation.
  #
  #   Net::IMAP::SequenceSet["1:3"]  .eql? Net::IMAP::SequenceSet["1:3"]
  #   #=> true
  #   Net::IMAP::SequenceSet["1,2,3"].eql? Net::IMAP::SequenceSet["1:3"]
  #   #=> false
  #   Net::IMAP::SequenceSet["1,3"]  .eql? Net::IMAP::SequenceSet["3,1"]
  #   #=> false
  #   Net::IMAP::SequenceSet["9,1:*"].eql? Net::IMAP::SequenceSet["1:*"]
  #   #=> false
  #
  # Related: #==, #normalize
  #
  # @return [Boolean]
  #
  # source://net-imap//lib/net/imap/sequence_set.rb#661
  def eql?(other); end

  # Returns the (sorted and deduplicated) index of +number+ in the set, or
  # +nil+ if +number+ isn't in the set.
  #
  # Related: #[], #at, #find_ordered_index
  #
  # source://net-imap//lib/net/imap/sequence_set.rb#1339
  def find_index(number); end

  # Returns the first index of +number+ in the ordered #entries, or
  # +nil+ if +number+ isn't in the set.
  #
  # Related: #find_index
  #
  # source://net-imap//lib/net/imap/sequence_set.rb#1352
  def find_ordered_index(number); end

  # Freezes and returns the set.  A frozen SequenceSet is Ractor-safe.
  #
  # source://net-imap//lib/net/imap/sequence_set.rb#619
  def freeze; end

  # Returns true if the set contains every possible element.
  #
  # @return [Boolean]
  #
  # source://net-imap//lib/net/imap/sequence_set.rb#800
  def full?; end

  # :call-seq: has_duplicates? -> true | false
  #
  # Returns whether or not the ordered #entries repeat any numbers.
  #
  # Always returns +false+ when #string is normalized.
  #
  # Related: #entries, #count_with_duplicates, #count_duplicates?
  #
  # @return [Boolean]
  #
  # source://net-imap//lib/net/imap/sequence_set.rb#1330
  def has_duplicates?; end

  # See #eql?
  #
  # source://net-imap//lib/net/imap/sequence_set.rb#664
  def hash; end

  # Returns +true+ when a given number or range is in +self+, and +false+
  # otherwise.  Returns +nil+ when +number+ isn't a valid SequenceSet
  # element (Integer, Range, <tt>*</tt>, +sequence-set+ string).
  #
  #     set = Net::IMAP::SequenceSet["5:10,100,111:115"]
  #     set.include? 1      #=> false
  #     set.include? 5..10  #=> true
  #     set.include? 11..20 #=> false
  #     set.include? 100    #=> true
  #     set.include? 6      #=> true, covered by "5:10"
  #     set.include? 6..9   #=> true, covered by "5:10"
  #     set.include? "6:9"  #=> true, strings are parsed
  #     set.include? 4..9   #=> false, intersection is not sufficient
  #     set.include? "*"    #=> false, use #limit to re-interpret "*"
  #     set.include? -1     #=> false, -1 is interpreted as "*"
  #
  #     set = Net::IMAP::SequenceSet["5:10,100,111:*"]
  #     set.include? :*     #=> true
  #     set.include? "*"    #=> true
  #     set.include? -1     #=> true
  #     set.include?(200..) #=> true
  #     set.include?(100..) #=> false
  #
  # Related: #include_star?, #cover?, #===, #intersect?
  #
  # @return [Boolean]
  #
  # source://net-imap//lib/net/imap/sequence_set.rb#711
  def include?(element); end

  # Returns +true+ when the set contains <tt>*</tt>.
  #
  # @return [Boolean]
  #
  # source://net-imap//lib/net/imap/sequence_set.rb#719
  def include_star?; end

  # For YAML deserialization
  #
  # source://net-imap//lib/net/imap/sequence_set.rb#1731
  def init_with(coder); end

  # Returns an inspection string for the SequenceSet.
  #
  #   Net::IMAP::SequenceSet.new.inspect
  #   #=> "Net::IMAP::SequenceSet()"
  #
  #   Net::IMAP::SequenceSet(1..5, 1024, 15, 2000).inspect
  #   #=> 'Net::IMAP::SequenceSet("1:5,15,1024,2000")'
  #
  # Frozen sets have slightly different output:
  #
  #   Net::IMAP::SequenceSet.empty.inspect
  #   #=> "Net::IMAP::SequenceSet.empty"
  #
  #   Net::IMAP::SequenceSet[1..5, 1024, 15, 2000].inspect
  #   #=> 'Net::IMAP::SequenceSet["1:5,15,1024,2000"]'
  #
  # Large sets (by number of #entries) have abridged output, with only the
  # first and last entries:
  #
  #   Net::IMAP::SequenceSet(((1..5000) % 2).to_a).inspect
  #   #=> #<Net::IMAP::SequenceSet 2500 entries "1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,...(2468 entries omitted)...,4969,4971,4973,4975,4977,4979,4981,4983,4985,4987,4989,4991,4993,4995,4997,4999">
  #
  # Related: #to_s, #string
  #
  # source://net-imap//lib/net/imap/sequence_set.rb#1676
  def inspect; end

  # Returns +true+ if the set and a given object have any common elements,
  # +false+ otherwise.
  #
  #     Net::IMAP::SequenceSet["5:10"].intersect? "7,9,11" #=> true
  #     Net::IMAP::SequenceSet["5:10"].intersect? "11:33"  #=> false
  #
  # Related: #intersection, #disjoint?, #cover?, #include?
  #
  # @return [Boolean]
  #
  # source://net-imap//lib/net/imap/sequence_set.rb#728
  def intersect?(other); end

  # :call-seq:
  #   self & other        -> sequence set
  #   intersection(other) -> sequence set
  #
  # Returns a new sequence set containing only the numbers common to this
  # set and +other+.
  #
  # +other+ may be any object that would be accepted by ::new.
  #
  #     Net::IMAP::SequenceSet[1..5] & [2, 4, 6]
  #     #=> Net::IMAP::SequenceSet["2,4"]
  #
  # Related: #intersect?, #|, #-, #^, #~
  #
  # ==== Set identities
  #
  # <tt>lhs & rhs</tt> is equivalent to:
  # * <tt>rhs & lhs</tt> (commutative)
  # * <tt>~(~lhs | ~rhs)</tt> (De Morgan's Law)
  # * <tt>lhs - ~rhs</tt>
  # * <tt>lhs - (lhs - rhs)</tt>
  # * <tt>lhs - (lhs ^ rhs)</tt>
  # * <tt>lhs ^ (lhs - rhs)</tt>
  #
  # source://net-imap//lib/net/imap/sequence_set.rb#879
  def intersection(other); end

  # Returns a frozen SequenceSet with <tt>*</tt> converted to +max+, numbers
  # and ranges over +max+ removed, and ranges containing +max+ converted to
  # end at +max+.
  #
  #   Net::IMAP::SequenceSet["5,10:22,50"].limit(max: 20).to_s
  #   #=> "5,10:20"
  #
  # <tt>*</tt> is always interpreted as the maximum value.  When the set
  # contains <tt>*</tt>, it will be set equal to the limit.
  #
  #   Net::IMAP::SequenceSet["*"].limit(max: 37)
  #   #=> Net::IMAP::SequenceSet["37"]
  #   Net::IMAP::SequenceSet["5:*"].limit(max: 37)
  #   #=> Net::IMAP::SequenceSet["5:37"]
  #   Net::IMAP::SequenceSet["500:*"].limit(max: 37)
  #   #=> Net::IMAP::SequenceSet["37"]
  #
  # Related: #limit!
  #
  # source://net-imap//lib/net/imap/sequence_set.rb#1574
  def limit(max:); end

  # Removes all members over +max+ and returns self.  If <tt>*</tt> is a
  # member, it will be converted to +max+.
  #
  # Related: #limit
  #
  # source://net-imap//lib/net/imap/sequence_set.rb#1587
  def limit!(max:); end

  # :call-seq:
  #   max(star: :*) => integer or star or nil
  #   max(count) => SequenceSet
  #
  # Returns the maximum value in +self+, +star+ when the set includes
  # <tt>*</tt>, or +nil+ when the set is empty.
  #
  # When +count+ is given, a new SequenceSet is returned, containing only
  # the last +count+ numbers.  An empty SequenceSet is returned when +self+
  # is empty.  (+star+ is ignored when +count+ is given.)
  #
  # Related: #min, #minmax, #slice
  #
  # source://net-imap//lib/net/imap/sequence_set.rb#756
  def max(count = T.unsafe(nil), star: T.unsafe(nil)); end

  # Returns +true+ when a given number or range is in +self+, and +false+
  # otherwise.  Returns +nil+ when +number+ isn't a valid SequenceSet
  # element (Integer, Range, <tt>*</tt>, +sequence-set+ string).
  #
  #     set = Net::IMAP::SequenceSet["5:10,100,111:115"]
  #     set.include? 1      #=> false
  #     set.include? 5..10  #=> true
  #     set.include? 11..20 #=> false
  #     set.include? 100    #=> true
  #     set.include? 6      #=> true, covered by "5:10"
  #     set.include? 6..9   #=> true, covered by "5:10"
  #     set.include? "6:9"  #=> true, strings are parsed
  #     set.include? 4..9   #=> false, intersection is not sufficient
  #     set.include? "*"    #=> false, use #limit to re-interpret "*"
  #     set.include? -1     #=> false, -1 is interpreted as "*"
  #
  #     set = Net::IMAP::SequenceSet["5:10,100,111:*"]
  #     set.include? :*     #=> true
  #     set.include? "*"    #=> true
  #     set.include? -1     #=> true
  #     set.include?(200..) #=> true
  #     set.include?(100..) #=> false
  #
  # Related: #include_star?, #cover?, #===, #intersect?
  #
  # @return [Boolean]
  #
  # source://net-imap//lib/net/imap/sequence_set.rb#716
  def member?(element); end

  # Merges all of the elements that appear in any of the +sets+ into the
  # set, and returns +self+.
  #
  # The +sets+ may be any objects that would be accepted by ::new.
  #
  # #string will be regenerated after all sets have been merged.
  #
  # Related: #add, #add?, #union
  #
  # source://net-imap//lib/net/imap/sequence_set.rb#1080
  def merge(*sets); end

  # :call-seq:
  #   min(star: :*) => integer or star or nil
  #   min(count) => SequenceSet
  #
  # Returns the minimum value in +self+, +star+ when the only value in the
  # set is <tt>*</tt>, or +nil+ when the set is empty.
  #
  # When +count+ is given, a new SequenceSet is returned, containing only
  # the first +count+ numbers.  An empty SequenceSet is returned when +self+
  # is empty.  (+star+ is ignored when +count+ is given.)
  #
  # Related: #max, #minmax, #slice
  #
  # source://net-imap//lib/net/imap/sequence_set.rb#776
  def min(count = T.unsafe(nil), star: T.unsafe(nil)); end

  # :call-seq: minmax(star: :*) => [min, max] or nil
  #
  # Returns a 2-element array containing the minimum and maximum numbers in
  # +self+, or +nil+ when the set is empty.  +star+ is handled the same way
  # as by #min and #max.
  #
  # Related: #min, #max
  #
  # source://net-imap//lib/net/imap/sequence_set.rb#791
  def minmax(star: T.unsafe(nil)); end

  # Returns a new SequenceSet with a normalized string representation.
  #
  # The returned set's #string is sorted and deduplicated.  Adjacent or
  # overlapping elements will be merged into a single larger range.
  # See SequenceSet@Ordered+and+Normalized+sets.
  #
  #   Net::IMAP::SequenceSet["1:5,3:7,10:9,10:11"].normalize
  #   #=> Net::IMAP::SequenceSet["1:7,9:11"]
  #
  # Related: #normalize!, #normalized_string
  #
  # source://net-imap//lib/net/imap/sequence_set.rb#1623
  def normalize; end

  # Resets #string to be sorted, deduplicated, and coalesced.  Returns
  # +self+.  See SequenceSet@Ordered+and+Normalized+sets.
  #
  # Related: #normalize, #normalized_string
  #
  # source://net-imap//lib/net/imap/sequence_set.rb#1633
  def normalize!; end

  # Returns a normalized +sequence-set+ string representation, sorted
  # and deduplicated.  Adjacent or overlapping elements will be merged into
  # a single larger range.  See SequenceSet@Ordered+and+Normalized+sets.
  #
  #   Net::IMAP::SequenceSet["1:5,3:7,10:9,10:11"].normalized_string
  #   #=> "1:7,9:11"
  #
  # Returns +nil+ when the set is empty.
  #
  # Related: #normalize!, #normalize, #string, #to_s
  #
  # source://net-imap//lib/net/imap/sequence_set.rb#1649
  def normalized_string; end

  # Returns a sorted array of all of the number values in the sequence set.
  #
  # The returned numbers are sorted and de-duplicated, even when the input
  # #string is not.  See #normalize, SequenceSet@Ordered+and+Normalized+sets.
  #
  #   Net::IMAP::SequenceSet["2,5:9,6,12:11"].numbers
  #   #=> [2, 5, 6, 7, 8, 9, 11, 12]
  #
  # If the set contains a <tt>*</tt>, RangeError is raised.  See #limit.
  #
  #   Net::IMAP::SequenceSet["10000:*"].numbers
  #   #!> RangeError
  #
  # *WARNING:* Even excluding sets with <tt>*</tt>, an enormous result can
  # easily be created.  An array with over 4 billion integers could be
  # returned, requiring up to 32GiB of memory on a 64-bit architecture.
  #
  #   Net::IMAP::SequenceSet[10000..2**32-1].numbers
  #   # ...probably freezes the process for a while...
  #   #!> NoMemoryError (probably)
  #
  # For safety, consider using #limit or #intersection to set an upper
  # bound.  Alternatively, use #each_element, #each_range, or even
  # #each_number to avoid allocation of a result array.
  #
  # Related: #elements, #ranges, #to_set
  #
  # source://net-imap//lib/net/imap/sequence_set.rb#1171
  def numbers; end

  # :call-seq: ordered_at(index) -> integer or nil
  #
  # Returns the number at the given +index+ in the ordered #entries, without
  # modifying the set.
  #
  # +index+ is interpreted the same as in #at (and #[]), except that
  # #ordered_at applies to the ordered #entries, not the sorted set.
  #
  # Related: #[], #slice, #ordered_at
  #
  # source://net-imap//lib/net/imap/sequence_set.rb#1407
  def ordered_at(index); end

  # Returns +true+ if the set and a given object have any common elements,
  # +false+ otherwise.
  #
  #     Net::IMAP::SequenceSet["5:10"].intersect? "7,9,11" #=> true
  #     Net::IMAP::SequenceSet["5:10"].intersect? "11:33"  #=> false
  #
  # Related: #intersection, #disjoint?, #cover?, #include?
  #
  # @return [Boolean]
  #
  # source://net-imap//lib/net/imap/sequence_set.rb#731
  def overlap?(other); end

  # Returns an array of ranges
  #
  # The returned elements are sorted and coalesced, even when the input
  # #string is not.  <tt>*</tt> will sort last.  See #normalize,
  # SequenceSet@Ordered+and+Normalized+sets.
  #
  # <tt>*</tt> translates to an endless range.  By itself, <tt>*</tt>
  # translates to <tt>:*..</tt>.  Use #limit to set <tt>*</tt> to a maximum
  # value.
  #
  #   Net::IMAP::SequenceSet["2,5:9,6,*,12:11"].ranges
  #   #=> [2..2, 5..9, 11..12, :*..]
  #   Net::IMAP::SequenceSet["123,999:*,456:789"].ranges
  #   #=> [123..123, 456..789, 999..]
  #
  # Related: #each_range, #elements, #numbers, #to_set
  #
  # source://net-imap//lib/net/imap/sequence_set.rb#1143
  def ranges; end

  # Replace the contents of the set with the contents of +other+ and returns
  # +self+.
  #
  # +other+ may be another SequenceSet or any other object that would be
  # accepted by ::new.
  #
  # source://net-imap//lib/net/imap/sequence_set.rb#548
  def replace(other); end

  # Unstable API: for internal use only (Net::IMAP#send_data)
  #
  # source://net-imap//lib/net/imap/sequence_set.rb#1720
  def send_data(imap, tag); end

  # Returns the count of #numbers in the set.
  #
  # <tt>*</tt> will be counted as <tt>2**32 - 1</tt> (the maximum 32-bit
  # unsigned integer value).
  #
  # Related: #count_with_duplicates
  #
  # source://net-imap//lib/net/imap/sequence_set.rb#1294
  def size; end

  # :call-seq:
  #    seqset[index]         -> integer or :* or nil
  #    slice(index)          -> integer or :* or nil
  #    seqset[start, length] -> sequence set or nil
  #    slice(start, length)  -> sequence set or nil
  #    seqset[range]         -> sequence set or nil
  #    slice(range)          -> sequence set or nil
  #
  # Returns a number or a subset from the _sorted_ set, without modifying
  # the set.
  #
  # When an Integer argument +index+ is given, the number at offset +index+
  # in the sorted set is returned:
  #
  #     set = Net::IMAP::SequenceSet["10:15,20:23,26"]
  #     set[0]   #=> 10
  #     set[5]   #=> 15
  #     set[10]  #=> 26
  #
  # If +index+ is negative, it counts relative to the end of the sorted set:
  #     set = Net::IMAP::SequenceSet["10:15,20:23,26"]
  #     set[-1]  #=> 26
  #     set[-3]  #=> 22
  #     set[-6]  #=> 15
  #
  # If +index+ is out of range, +nil+ is returned.
  #
  #     set = Net::IMAP::SequenceSet["10:15,20:23,26"]
  #     set[11]  #=> nil
  #     set[-12] #=> nil
  #
  # The result is based on the sorted and de-duplicated set, not on the
  # ordered #entries in #string.
  #
  #     set = Net::IMAP::SequenceSet["12,20:23,11:16,21"]
  #     set[0]   #=> 11
  #     set[-1]  #=> 23
  #
  # Related: #at
  #
  # source://net-imap//lib/net/imap/sequence_set.rb#1471
  def slice(index, length = T.unsafe(nil)); end

  # :call-seq:
  #    slice!(index)          -> integer or :* or nil
  #    slice!(start, length)  -> sequence set or nil
  #    slice!(range)          -> sequence set or nil
  #
  # Deletes a number or consecutive numbers from the set, indicated by the
  # given +index+, +start+ and +length+, or +range+ of offsets.  Returns the
  # number or sequence set that was removed, or +nil+ if nothing was
  # removed.  Arguments are interpreted the same as for #slice or #[].
  #
  # #string will be regenerated after deletion.
  #
  # Related: #slice, #delete_at, #delete, #delete?, #subtract, #difference
  #
  # source://net-imap//lib/net/imap/sequence_set.rb#1066
  def slice!(index, length = T.unsafe(nil)); end

  # Returns the \IMAP +sequence-set+ string representation, or +nil+ when
  # the set is empty.  Note that an empty set is invalid in the \IMAP
  # syntax.
  #
  # Use #valid_string to raise an exception when the set is empty, or #to_s
  # to return an empty string.
  #
  # If the set was created from a single string, it is not normalized.  If
  # the set is updated the string will be normalized.
  #
  # Related: #valid_string, #normalized_string, #to_s, #inspect
  #
  # source://net-imap//lib/net/imap/sequence_set.rb#583
  def string; end

  # Assigns a new string to #string and resets #elements to match.
  # Assigning +nil+ or an empty string are equivalent to calling #clear.
  #
  # Non-empty strings are validated but not normalized.
  #
  # Use #add, #merge, or #append to add a string to an existing set.
  #
  # Related: #replace, #clear
  #
  # source://net-imap//lib/net/imap/sequence_set.rb#597
  def string=(input); end

  # Removes all of the elements that appear in any of the given +sets+ from
  # the set, and returns +self+.
  #
  # The +sets+ may be any objects that would be accepted by ::new.
  #
  # Related: #difference
  #
  # source://net-imap//lib/net/imap/sequence_set.rb#1092
  def subtract(*sets); end

  # Returns an array of ranges and integers and <tt>:*</tt>.
  #
  # The returned elements are sorted and coalesced, even when the input
  # #string is not.  <tt>*</tt> will sort last.  See #normalize,
  # SequenceSet@Ordered+and+Normalized+sets.
  #
  # By itself, <tt>*</tt> translates to <tt>:*</tt>.  A range containing
  # <tt>*</tt> translates to an endless range.  Use #limit to translate both
  # cases to a maximum value.
  #
  #   Net::IMAP::SequenceSet["2,5:9,6,*,12:11"].elements
  #   #=> [2, 5..9, 11..12, :*]
  #
  # Related: #each_element, #ranges, #numbers
  #
  # source://net-imap//lib/net/imap/sequence_set.rb#1125
  def to_a; end

  # Returns the \IMAP +sequence-set+ string representation, or an empty
  # string when the set is empty.  Note that an empty set is invalid in the
  # \IMAP syntax.
  #
  # Related: #string, #valid_string, #normalized_string, #inspect
  #
  # source://net-imap//lib/net/imap/sequence_set.rb#616
  def to_s; end

  # source://net-imap//lib/net/imap/sequence_set.rb#1711
  def to_sequence_set; end

  # Returns a Set with all of the #numbers in the sequence set.
  #
  # If the set contains a <tt>*</tt>, RangeError will be raised.
  #
  # See #numbers for the warning about very large sets.
  #
  # Related: #elements, #ranges, #numbers
  #
  # source://net-imap//lib/net/imap/sequence_set.rb#1281
  def to_set; end

  # :call-seq:
  #   self + other -> sequence set
  #   self | other -> sequence set
  #   union(other) -> sequence set
  #
  # Returns a new sequence set that has every number in the +other+ object
  # added.
  #
  # +other+ may be any object that would be accepted by ::new.
  #
  #     Net::IMAP::SequenceSet["1:5"] | 2 | [4..6, 99]
  #     #=> Net::IMAP::SequenceSet["1:6,99"]
  #
  # Related: #add, #merge, #&, #-, #^, #~
  #
  # ==== Set identities
  #
  # <tt>lhs | rhs</tt> is equivalent to:
  # * <tt>rhs | lhs</tt> (commutative)
  # * <tt>~(~lhs & ~rhs)</tt> (De Morgan's Law)
  # * <tt>(lhs & rhs) ^ (lhs ^ rhs)</tt>
  #
  # source://net-imap//lib/net/imap/sequence_set.rb#825
  def union(other); end

  # Returns false when the set is empty.
  #
  # @return [Boolean]
  #
  # source://net-imap//lib/net/imap/sequence_set.rb#794
  def valid?; end

  # Returns the \IMAP +sequence-set+ string representation, or raises a
  # DataFormatError when the set is empty.
  #
  # Use #string to return +nil+ or #to_s to return an empty string without
  # error.
  #
  # Related: #string, #normalized_string, #to_s
  #
  # @raise [DataFormatError]
  #
  # source://net-imap//lib/net/imap/sequence_set.rb#567
  def valid_string; end

  # Unstable API: currently for internal use only (Net::IMAP#validate_data)
  #
  # source://net-imap//lib/net/imap/sequence_set.rb#1714
  def validate; end

  # :call-seq:
  #   self ^ other -> sequence set
  #   xor(other)   -> sequence set
  #
  # Returns a new sequence set containing numbers that are exclusive between
  # this set and +other+.
  #
  # +other+ may be any object that would be accepted by ::new.
  #
  #     Net::IMAP::SequenceSet[1..5] ^ [2, 4, 6]
  #     #=> Net::IMAP::SequenceSet["1,3,5:6"]
  #
  # Related: #|, #&, #-, #~
  #
  # ==== Set identities
  #
  # <tt>lhs ^ rhs</tt> is equivalent to:
  # * <tt>rhs ^ lhs</tt> (commutative)
  # * <tt>~lhs ^ ~rhs</tt>
  # * <tt>(lhs | rhs) - (lhs & rhs)</tt>
  # * <tt>(lhs - rhs) | (rhs - lhs)</tt>
  # * <tt>(lhs ^ other) ^ (other ^ rhs)</tt>
  #
  # source://net-imap//lib/net/imap/sequence_set.rb#904
  def xor(other); end

  # :call-seq:
  #   self + other -> sequence set
  #   self | other -> sequence set
  #   union(other) -> sequence set
  #
  # Returns a new sequence set that has every number in the +other+ object
  # added.
  #
  # +other+ may be any object that would be accepted by ::new.
  #
  #     Net::IMAP::SequenceSet["1:5"] | 2 | [4..6, 99]
  #     #=> Net::IMAP::SequenceSet["1:6,99"]
  #
  # Related: #add, #merge, #&, #-, #^, #~
  #
  # ==== Set identities
  #
  # <tt>lhs | rhs</tt> is equivalent to:
  # * <tt>rhs | lhs</tt> (commutative)
  # * <tt>~(~lhs & ~rhs)</tt> (De Morgan's Law)
  # * <tt>(lhs & rhs) ^ (lhs ^ rhs)</tt>
  #
  # source://net-imap//lib/net/imap/sequence_set.rb#823
  def |(other); end

  # :call-seq:
  #   ~ self     -> sequence set
  #   complement -> sequence set
  #
  # Returns the complement of self, a SequenceSet which contains all numbers
  # _except_ for those in this set.
  #
  #     ~Net::IMAP::SequenceSet.full  #=> Net::IMAP::SequenceSet.empty
  #     ~Net::IMAP::SequenceSet.empty #=> Net::IMAP::SequenceSet.full
  #     ~Net::IMAP::SequenceSet["1:5,100:222"]
  #     #=> Net::IMAP::SequenceSet["6:99,223:*"]
  #     ~Net::IMAP::SequenceSet["6:99,223:*"]
  #     #=> Net::IMAP::SequenceSet["1:5,100:222"]
  #
  # Related: #complement!, #|, #&, #-, #^
  #
  # ==== Set identities
  #
  # <tt>~set</tt> is equivalent to:
  # * <tt>full - set</tt>, where "full" is Net::IMAP::SequenceSet.full
  #
  # source://net-imap//lib/net/imap/sequence_set.rb#926
  def ~; end

  protected

  # source://net-imap//lib/net/imap/sequence_set.rb#1740
  def deep_copy_tuples; end

  # source://net-imap//lib/net/imap/sequence_set.rb#1738
  def tuples; end

  private

  # source://net-imap//lib/net/imap/sequence_set.rb#1698
  def count_entries; end

  # source://net-imap//lib/net/imap/sequence_set.rb#1203
  def each_entry_tuple(&block); end

  # source://net-imap//lib/net/imap/sequence_set.rb#1265
  def each_number_in_tuple(min, max, &block); end

  # source://net-imap//lib/net/imap/sequence_set.rb#1364
  def each_tuple_with_index(tuples); end

  # source://net-imap//lib/net/imap/sequence_set.rb#1806
  def export_string_entries(entries); end

  # source://net-imap//lib/net/imap/sequence_set.rb#1804
  def from_tuple_int(num); end

  # @return [Boolean]
  #
  # source://net-imap//lib/net/imap/sequence_set.rb#1817
  def include_tuple?(_arg0); end

  # frozen clones are shallow copied
  #
  # source://net-imap//lib/net/imap/sequence_set.rb#1748
  def initialize_clone(other); end

  # source://net-imap//lib/net/imap/sequence_set.rb#1753
  def initialize_dup(other); end

  # source://net-imap//lib/net/imap/sequence_set.rb#1758
  def input_to_tuple(entry); end

  # source://net-imap//lib/net/imap/sequence_set.rb#1769
  def input_to_tuples(set); end

  # unlike SequenceSet#try_convert, this returns an Integer, Range,
  # String, Set, Array, or... any type of object.
  #
  # source://net-imap//lib/net/imap/sequence_set.rb#1786
  def input_try_convert(input); end

  # @return [Boolean]
  #
  # source://net-imap//lib/net/imap/sequence_set.rb#1819
  def intersect_tuple?(_arg0); end

  # source://net-imap//lib/net/imap/sequence_set.rb#1411
  def lookup_number_by_tuple_index(tuples, index); end

  # source://net-imap//lib/net/imap/sequence_set.rb#1824
  def modifying!; end

  # source://net-imap//lib/net/imap/sequence_set.rb#1921
  def nz_number(num); end

  # source://net-imap//lib/net/imap/sequence_set.rb#1916
  def range_gte_to(num); end

  # source://net-imap//lib/net/imap/sequence_set.rb#1793
  def range_to_tuple(range); end

  # source://net-imap//lib/net/imap/sequence_set.rb#1744
  def remain_frozen(set); end

  # source://net-imap//lib/net/imap/sequence_set.rb#1745
  def remain_frozen_empty; end

  # source://net-imap//lib/net/imap/sequence_set.rb#1374
  def reverse_each_tuple_with_index(tuples); end

  # @raise [ArgumentError]
  #
  # source://net-imap//lib/net/imap/sequence_set.rb#1475
  def slice_length(start, length); end

  # source://net-imap//lib/net/imap/sequence_set.rb#1483
  def slice_range(range); end

  # @raise [DataFormatError]
  #
  # source://net-imap//lib/net/imap/sequence_set.rb#1812
  def str_to_tuple(str); end

  # source://net-imap//lib/net/imap/sequence_set.rb#1811
  def str_to_tuples(str); end

  # source://net-imap//lib/net/imap/sequence_set.rb#1803
  def to_tuple_int(obj); end

  # --|=====| |=====new tuple=====|                 append
  #   ?????????-|=====new tuple=====|-|===lower===|-- insert
  #
  #             |=====new tuple=====|
  #   ---------??=======lower=======??--------------- noop
  #
  #   ---------??===lower==|--|==|                    join remaining
  #   ---------??===lower==|--|==|----|===upper===|-- join until upper
  #   ---------??===lower==|--|==|--|=====upper===|-- join to upper
  #
  # source://net-imap//lib/net/imap/sequence_set.rb#1843
  def tuple_add(tuple); end

  # source://net-imap//lib/net/imap/sequence_set.rb#1853
  def tuple_coalesce(lower, lower_idx, min, max); end

  # source://net-imap//lib/net/imap/sequence_set.rb#1912
  def tuple_gte_with_index(num); end

  # |====tuple================|
  # --|====|                               no more       1. noop
  # --|====|---------------------------|====lower====|-- 2. noop
  # -------|======lower================|---------------- 3. split
  # --------|=====lower================|---------------- 4. trim beginning
  #
  # -------|======lower====????????????----------------- trim lower
  # --------|=====lower====????????????----------------- delete lower
  #
  # -------??=====lower===============|----------------- 5. trim/delete one
  # -------??=====lower====|--|====|       no more       6. delete rest
  # -------??=====lower====|--|====|---|====upper====|-- 7. delete until
  # -------??=====lower====|--|====|--|=====upper====|-- 8. delete and trim
  #
  # source://net-imap//lib/net/imap/sequence_set.rb#1880
  def tuple_subtract(tuple); end

  # source://net-imap//lib/net/imap/sequence_set.rb#1213
  def tuple_to_entry(_arg0); end

  # source://net-imap//lib/net/imap/sequence_set.rb#1810
  def tuple_to_str(tuple); end

  # source://net-imap//lib/net/imap/sequence_set.rb#1891
  def tuple_trim_or_split(lower, idx, tmin, tmax); end

  # source://net-imap//lib/net/imap/sequence_set.rb#1830
  def tuples_add(tuples); end

  # source://net-imap//lib/net/imap/sequence_set.rb#1831
  def tuples_subtract(tuples); end

  # source://net-imap//lib/net/imap/sequence_set.rb#1898
  def tuples_trim_or_delete(lower, lower_idx, tmin, tmax); end

  class << self
    # :call-seq:
    #   SequenceSet[*inputs] -> valid frozen sequence set
    #
    # Returns a frozen SequenceSet, constructed from +inputs+.
    #
    # When only a single valid frozen SequenceSet is given, that same set is
    # returned.
    #
    # An empty SequenceSet is invalid and will raise a DataFormatError.
    #
    # Use ::new to create a mutable or empty SequenceSet.
    #
    # Related: ::new, Net::IMAP::SequenceSet(), ::try_convert
    #
    # source://net-imap//lib/net/imap/sequence_set.rb#431
    def [](first, *rest); end

    # Returns a frozen empty set singleton.  Note that valid \IMAP sequence
    # sets cannot be empty, so this set is _invalid_.
    #
    # source://net-imap//lib/net/imap/sequence_set.rb#461
    def empty; end

    # Returns a frozen full set singleton: <tt>"1:*"</tt>
    #
    # source://net-imap//lib/net/imap/sequence_set.rb#464
    def full; end

    # :call-seq:
    #   SequenceSet.try_convert(obj) -> sequence set or nil
    #
    # If +obj+ is a SequenceSet, returns +obj+.  If +obj+ responds_to
    # +to_sequence_set+, calls +obj.to_sequence_set+ and returns the result.
    # Otherwise returns +nil+.
    #
    # If +obj.to_sequence_set+ doesn't return a SequenceSet or +nil+, an
    # exception is raised.
    #
    # Related: Net::IMAP::SequenceSet(), ::new, ::[]
    #
    # @raise [DataFormatError]
    #
    # source://net-imap//lib/net/imap/sequence_set.rb#451
    def try_convert(obj); end
  end
end

# intentionally defined after the class implementation
#
# source://net-imap//lib/net/imap/sequence_set.rb#1931
Net::IMAP::SequenceSet::EMPTY = T.let(T.unsafe(nil), Net::IMAP::SequenceSet)

# source://net-imap//lib/net/imap/sequence_set.rb#1932
Net::IMAP::SequenceSet::FULL = T.let(T.unsafe(nil), Net::IMAP::SequenceSet)

# source://net-imap//lib/net/imap/sequence_set.rb#412
Net::IMAP::SequenceSet::INSPECT_ABRIDGED_HEAD_RE = T.let(T.unsafe(nil), Regexp)

# source://net-imap//lib/net/imap/sequence_set.rb#413
Net::IMAP::SequenceSet::INSPECT_ABRIDGED_TAIL_RE = T.let(T.unsafe(nil), Regexp)

# source://net-imap//lib/net/imap/sequence_set.rb#399
Net::IMAP::SequenceSet::INSPECT_MAX_LEN = T.let(T.unsafe(nil), Integer)

# source://net-imap//lib/net/imap/sequence_set.rb#400
Net::IMAP::SequenceSet::INSPECT_TRUNCATE_LEN = T.let(T.unsafe(nil), Integer)

# valid inputs for "*"
#
# source://net-imap//lib/net/imap/sequence_set.rb#396
Net::IMAP::SequenceSet::STARS = T.let(T.unsafe(nil), Array)

# represents "*" internally, to simplify sorting (etc)
#
# source://net-imap//lib/net/imap/sequence_set.rb#392
Net::IMAP::SequenceSet::STAR_INT = T.let(T.unsafe(nil), Integer)

# The largest possible non-zero unsigned 32-bit integer
#
# source://net-imap//lib/net/imap/sequence_set.rb#389
Net::IMAP::SequenceSet::UINT32_MAX = T.let(T.unsafe(nil), Integer)

# source://net-imap//lib/net/imap/command_data.rb#286
module Net::IMAP::StringFormatter
  private

  # source://net-imap//lib/net/imap/command_data.rb#313
  def nstring(str); end

  # source://net-imap//lib/net/imap/command_data.rb#303
  def string(str); end

  # source://net-imap//lib/net/imap/command_data.rb#298
  def valid_nstring?(str); end

  # source://net-imap//lib/net/imap/command_data.rb#293
  def valid_string?(str); end

  class << self
    # source://net-imap//lib/net/imap/command_data.rb#313
    def nstring(str); end

    # source://net-imap//lib/net/imap/command_data.rb#303
    def string(str); end

    # source://net-imap//lib/net/imap/command_data.rb#298
    def valid_nstring?(str); end

    # source://net-imap//lib/net/imap/command_data.rb#293
    def valid_string?(str); end
  end
end

# source://net-imap//lib/net/imap/command_data.rb#288
Net::IMAP::StringFormatter::LITERAL_REGEX = T.let(T.unsafe(nil), Regexp)

# Regexps and utility methods for implementing stringprep profiles.  The
# \StringPrep algorithm is defined by
# {RFC-3454}[https://www.rfc-editor.org/rfc/rfc3454.html].  Each
# codepoint table defined in the RFC-3454 appendices is matched by a Regexp
# defined in this module.
#
# source://net-imap//lib/net/imap/stringprep.rb#11
module Net::IMAP::StringPrep
  private

  # Checks that +string+ obeys all of the "Bidirectional Characters"
  # requirements in RFC-3454, §6:
  #
  # * The characters in \StringPrep\[\"C.8\"] MUST be prohibited
  # * If a string contains any RandALCat character, the string MUST NOT
  #   contain any LCat character.
  # * If a string contains any RandALCat character, a RandALCat
  #   character MUST be the first character of the string, and a
  #   RandALCat character MUST be the last character of the string.
  #
  # This is usually combined with #check_prohibited!, so table "C.8" is only
  # checked when <tt>c_8: true</tt>.
  #
  # Raises either ProhibitedCodepoint or BidiStringError unless all
  # requirements are met.  +profile+ is an optional string which will be
  # added to any exception that is raised (it does not affect behavior).
  #
  # source://net-imap//lib/net/imap/stringprep.rb#144
  def check_bidi!(string, c_8: T.unsafe(nil), profile: T.unsafe(nil)); end

  # Checks +string+ for any codepoint in +tables+. Raises a
  # ProhibitedCodepoint describing the first matching table.
  #
  # Also checks bidirectional characters, when <tt>bidi: true</tt>, which may
  # raise a BidiStringError.
  #
  # +profile+ is an optional string which will be added to any exception that
  # is raised (it does not affect behavior).
  #
  # source://net-imap//lib/net/imap/stringprep.rb#104
  def check_prohibited!(string, *tables, bidi: T.unsafe(nil), unassigned: T.unsafe(nil), stored: T.unsafe(nil), profile: T.unsafe(nil)); end

  # source://net-imap//lib/net/imap/stringprep.rb#88
  def map_tables!(string, *tables); end

  # >>>
  #   1. Map -- For each character in the input, check if it has a mapping
  #      and, if so, replace it with its mapping.  This is described in
  #      section 3.
  #
  #   2. Normalize -- Possibly normalize the result of step 1 using Unicode
  #      normalization.  This is described in section 4.
  #
  #   3. Prohibit -- Check for any characters that are not allowed in the
  #      output.  If any are found, return an error.  This is described in
  #      section 5.
  #
  #   4. Check bidi -- Possibly check for right-to-left characters, and if
  #      any are found, make sure that the whole string satisfies the
  #      requirements for bidirectional strings.  If the string does not
  #      satisfy the requirements for bidirectional strings, return an
  #      error.  This is described in section 6.
  #
  #   The above steps MUST be performed in the order given to comply with
  #   this specification.
  #
  # source://net-imap//lib/net/imap/stringprep.rb#76
  def stringprep(string, maps:, normalization:, prohibited:, **opts); end

  class << self
    # Returns a Regexp matching the given +table+ name.
    #
    # source://net-imap//lib/net/imap/stringprep.rb#49
    def [](table); end

    # Checks that +string+ obeys all of the "Bidirectional Characters"
    # requirements in RFC-3454, §6:
    #
    # * The characters in \StringPrep\[\"C.8\"] MUST be prohibited
    # * If a string contains any RandALCat character, the string MUST NOT
    #   contain any LCat character.
    # * If a string contains any RandALCat character, a RandALCat
    #   character MUST be the first character of the string, and a
    #   RandALCat character MUST be the last character of the string.
    #
    # This is usually combined with #check_prohibited!, so table "C.8" is only
    # checked when <tt>c_8: true</tt>.
    #
    # Raises either ProhibitedCodepoint or BidiStringError unless all
    # requirements are met.  +profile+ is an optional string which will be
    # added to any exception that is raised (it does not affect behavior).
    #
    # source://net-imap//lib/net/imap/stringprep.rb#144
    def check_bidi!(string, c_8: T.unsafe(nil), profile: T.unsafe(nil)); end

    # Checks +string+ for any codepoint in +tables+. Raises a
    # ProhibitedCodepoint describing the first matching table.
    #
    # Also checks bidirectional characters, when <tt>bidi: true</tt>, which may
    # raise a BidiStringError.
    #
    # +profile+ is an optional string which will be added to any exception that
    # is raised (it does not affect behavior).
    #
    # source://net-imap//lib/net/imap/stringprep.rb#104
    def check_prohibited!(string, *tables, bidi: T.unsafe(nil), unassigned: T.unsafe(nil), stored: T.unsafe(nil), profile: T.unsafe(nil)); end

    # source://net-imap//lib/net/imap/stringprep.rb#88
    def map_tables!(string, *tables); end

    # >>>
    #   1. Map -- For each character in the input, check if it has a mapping
    #      and, if so, replace it with its mapping.  This is described in
    #      section 3.
    #
    #   2. Normalize -- Possibly normalize the result of step 1 using Unicode
    #      normalization.  This is described in section 4.
    #
    #   3. Prohibit -- Check for any characters that are not allowed in the
    #      output.  If any are found, return an error.  This is described in
    #      section 5.
    #
    #   4. Check bidi -- Possibly check for right-to-left characters, and if
    #      any are found, make sure that the whole string satisfies the
    #      requirements for bidirectional strings.  If the string does not
    #      satisfy the requirements for bidirectional strings, return an
    #      error.  This is described in section 6.
    #
    #   The above steps MUST be performed in the order given to comply with
    #   this specification.
    #
    # source://net-imap//lib/net/imap/stringprep.rb#76
    def stringprep(string, maps:, normalization:, prohibited:, **opts); end
  end
end

# StringPrepError raised when +string+ contains bidirectional characters
# which violate the StringPrep requirements.
#
# source://net-imap//lib/net/imap/stringprep.rb#45
class Net::IMAP::StringPrep::BidiStringError < ::Net::IMAP::StringPrep::StringPrepError; end

# Defined in RFC3491[https://www.rfc-editor.org/rfc/rfc3491], the +nameprep+
# profile of "Stringprep" is:
# >>>
#   used by the IDNA protocol for preparing domain names; it is not
#   designed for any other purpose.  It is explicitly not designed for
#   processing arbitrary free text and SHOULD NOT be used for that
#   purpose.
#
#   ...
#
#   This profile specifies prohibiting using the following tables...:
#
#   - C.1.2 (Non-ASCII space characters)
#   - C.2.2 (Non-ASCII control characters)
#   - C.3 (Private use characters)
#   - C.4 (Non-character code points)
#   - C.5 (Surrogate codes)
#   - C.6 (Inappropriate for plain text)
#   - C.7 (Inappropriate for canonical representation)
#   - C.8 (Change display properties are deprecated)
#   - C.9 (Tagging characters)
#
#   IMPORTANT NOTE: This profile MUST be used with the IDNA protocol.
#   The IDNA protocol has additional prohibitions that are checked
#   outside of this profile.
#
# source://net-imap//lib/net/imap/stringprep/nameprep.rb#32
module Net::IMAP::StringPrep::NamePrep
  private

  # source://net-imap//lib/net/imap/stringprep/nameprep.rb#54
  def nameprep(string, **opts); end

  class << self
    # source://net-imap//lib/net/imap/stringprep/nameprep.rb#54
    def nameprep(string, **opts); end
  end
end

# From RFC3491[https://www.rfc-editor.org/rfc/rfc3491.html] §6
#
# source://net-imap//lib/net/imap/stringprep/nameprep.rb#50
Net::IMAP::StringPrep::NamePrep::CHECK_BIDI = T.let(T.unsafe(nil), TrueClass)

# From RFC3491[https://www.rfc-editor.org/rfc/rfc3491.html] §3
#
# source://net-imap//lib/net/imap/stringprep/nameprep.rb#41
Net::IMAP::StringPrep::NamePrep::MAPPING_TABLES = T.let(T.unsafe(nil), Array)

# From RFC3491[https://www.rfc-editor.org/rfc/rfc3491.html] §4
#
# source://net-imap//lib/net/imap/stringprep/nameprep.rb#44
Net::IMAP::StringPrep::NamePrep::NORMALIZATION = T.let(T.unsafe(nil), Symbol)

# From RFC3491[https://www.rfc-editor.org/rfc/rfc3491.html] §5
#
# source://net-imap//lib/net/imap/stringprep/nameprep.rb#47
Net::IMAP::StringPrep::NamePrep::PROHIBITED_TABLES = T.let(T.unsafe(nil), Array)

# From RFC3491[https://www.rfc-editor.org/rfc/rfc3491.html] §10
#
# source://net-imap//lib/net/imap/stringprep/nameprep.rb#35
Net::IMAP::StringPrep::NamePrep::STRINGPREP_PROFILE = T.let(T.unsafe(nil), String)

# From RFC3491[https://www.rfc-editor.org/rfc/rfc3491.html] §2
#
# source://net-imap//lib/net/imap/stringprep/nameprep.rb#38
Net::IMAP::StringPrep::NamePrep::UNASSIGNED_TABLE = T.let(T.unsafe(nil), String)

# StringPrepError raised when +string+ contains a codepoint prohibited by
# +table+.
#
# source://net-imap//lib/net/imap/stringprep.rb#31
class Net::IMAP::StringPrep::ProhibitedCodepoint < ::Net::IMAP::StringPrep::StringPrepError
  # @return [ProhibitedCodepoint] a new instance of ProhibitedCodepoint
  #
  # source://net-imap//lib/net/imap/stringprep.rb#34
  def initialize(table, *args, **kwargs); end

  # Returns the value of attribute table.
  #
  # source://net-imap//lib/net/imap/stringprep.rb#32
  def table; end
end

# SASLprep#saslprep can be used to prepare a string according to [RFC4013].
#
# \SASLprep maps characters three ways: to nothing, to space, and Unicode
# normalization form KC.  \SASLprep prohibits codepoints from nearly all
# standard StringPrep tables (RFC3454, Appendix "C"), and uses
# \StringPrep's standard bidirectional characters requirements (Appendix
# "D").  \SASLprep also uses \StringPrep's definition of "Unassigned"
# codepoints (Appendix "A").
#
# source://net-imap//lib/net/imap/stringprep/saslprep.rb#15
module Net::IMAP::StringPrep::SASLprep
  private

  # Prepares a UTF-8 +string+ for comparison, using the \SASLprep profile
  # RFC4013 of the StringPrep algorithm RFC3454.
  #
  # By default, prohibited strings will return +nil+.  When +exception+ is
  # +true+, a StringPrepError describing the violation will be raised.
  #
  # When +stored+ is +true+, "unassigned" codepoints will be prohibited.
  # For \StringPrep and the \SASLprep profile, "unassigned" refers to
  # Unicode 3.2, and not later versions.  See RFC3454 §7 for more
  # information.
  #
  # source://net-imap//lib/net/imap/stringprep/saslprep.rb#42
  def saslprep(str, stored: T.unsafe(nil), exception: T.unsafe(nil)); end

  class << self
    # Prepares a UTF-8 +string+ for comparison, using the \SASLprep profile
    # RFC4013 of the StringPrep algorithm RFC3454.
    #
    # By default, prohibited strings will return +nil+.  When +exception+ is
    # +true+, a StringPrepError describing the violation will be raised.
    #
    # When +stored+ is +true+, "unassigned" codepoints will be prohibited.
    # For \StringPrep and the \SASLprep profile, "unassigned" refers to
    # Unicode 3.2, and not later versions.  See RFC3454 §7 for more
    # information.
    #
    # source://net-imap//lib/net/imap/stringprep/saslprep.rb#42
    def saslprep(str, stored: T.unsafe(nil), exception: T.unsafe(nil)); end
  end
end

# Used to short-circuit strings that don't need preparation.
#
# source://net-imap//lib/net/imap/stringprep/saslprep.rb#18
Net::IMAP::StringPrep::SASLprep::ASCII_NO_CTRLS = T.let(T.unsafe(nil), Regexp)

# Bidirectional Characters [StringPrep, §6]
#
# A Regexp for strings that don't satisfy StringPrep's Bidirectional
# Characters rules.
#
# Equal to StringPrep::Tables::BIDI_FAILURE.
# Redefined here to avoid loading StringPrep::Tables unless necessary.
#
# source://net-imap//lib/net/imap/stringprep/saslprep_tables.rb#79
Net::IMAP::StringPrep::SASLprep::BIDI_FAILURE = T.let(T.unsafe(nil), Regexp)

# RFC4013 §2.1 Mapping - mapped to nothing
# >>>
#   the "commonly mapped to nothing" characters
#   (\StringPrep\[\"B.1\"]) that can be mapped to nothing.
#
# Equal to \StringPrep\[\"B.1\"].
# Redefined here to avoid loading StringPrep::Tables unless necessary.
#
# source://net-imap//lib/net/imap/stringprep/saslprep_tables.rb#27
Net::IMAP::StringPrep::SASLprep::MAP_TO_NOTHING = T.let(T.unsafe(nil), Regexp)

# RFC4013 §2.1 Mapping - mapped to space
# >>>
#   non-ASCII space characters (\StringPrep\[\"C.1.2\"]) that can
#   be mapped to SPACE (U+0020)
#
# Equal to \StringPrep\[\"C.1.2\"].
# Redefined here to avoid loading StringPrep::Tables unless necessary.
#
# source://net-imap//lib/net/imap/stringprep/saslprep_tables.rb#18
Net::IMAP::StringPrep::SASLprep::MAP_TO_SPACE = T.let(T.unsafe(nil), Regexp)

# A Regexp matching strings prohibited by RFC4013 §2.3 and §2.4.
#
# This combines PROHIBITED_OUTPUT and BIDI_FAILURE.
#
# source://net-imap//lib/net/imap/stringprep/saslprep_tables.rb#84
Net::IMAP::StringPrep::SASLprep::PROHIBITED = T.let(T.unsafe(nil), Regexp)

# A Regexp matching codepoints prohibited by RFC4013 §2.3.
#
# This combines all of the TABLES_PROHIBITED tables.
#
# source://net-imap//lib/net/imap/stringprep/saslprep_tables.rb#54
Net::IMAP::StringPrep::SASLprep::PROHIBITED_OUTPUT = T.let(T.unsafe(nil), Regexp)

# A Regexp matching codepoints prohibited by RFC4013 §2.3 and §2.5.
#
# This combines PROHIBITED_OUTPUT and UNASSIGNED.
#
# source://net-imap//lib/net/imap/stringprep/saslprep_tables.rb#68
Net::IMAP::StringPrep::SASLprep::PROHIBITED_OUTPUT_STORED = T.let(T.unsafe(nil), Regexp)

# A Regexp matching strings prohibited by RFC4013 §2.3, §2.4, and §2.5.
#
# This combines PROHIBITED_OUTPUT_STORED and BIDI_FAILURE.
#
# source://net-imap//lib/net/imap/stringprep/saslprep_tables.rb#91
Net::IMAP::StringPrep::SASLprep::PROHIBITED_STORED = T.let(T.unsafe(nil), Regexp)

# RFC4013 §2.3 Prohibited Output
# >>>
# * Non-ASCII space characters — \StringPrep\[\"C.1.2\"]
# * ASCII control characters — \StringPrep\[\"C.2.1\"]
# * Non-ASCII control characters — \StringPrep\[\"C.2.2\"]
# * Private Use characters — \StringPrep\[\"C.3\"]
# * Non-character code points — \StringPrep\[\"C.4\"]
# * Surrogate code points — \StringPrep\[\"C.5\"]
# * Inappropriate for plain text characters — \StringPrep\[\"C.6\"]
# * Inappropriate for canonical representation characters — \StringPrep\[\"C.7\"]
# * Change display properties or deprecated characters — \StringPrep\[\"C.8\"]
# * Tagging characters — \StringPrep\[\"C.9\"]
#
# source://net-imap//lib/net/imap/stringprep/saslprep_tables.rb#41
Net::IMAP::StringPrep::SASLprep::TABLES_PROHIBITED = T.let(T.unsafe(nil), Array)

# Adds unassigned (by Unicode 3.2) codepoints to TABLES_PROHIBITED.
#
# RFC4013 §2.5 Unassigned Code Points
# >>>
#   This profile specifies the \StringPrep\[\"A.1\"] table as its
#   list of unassigned code points.
#
# source://net-imap//lib/net/imap/stringprep/saslprep_tables.rb#49
Net::IMAP::StringPrep::SASLprep::TABLES_PROHIBITED_STORED = T.let(T.unsafe(nil), Array)

# RFC4013 §2.5 Unassigned Code Points
# >>>
#   This profile specifies the \StringPrep\[\"A.1\"] table as its
#   list of unassigned code points.
#
# Equal to \StringPrep\[\"A.1\"].
# Redefined here to avoid loading StringPrep::Tables unless necessary.
#
# source://net-imap//lib/net/imap/stringprep/saslprep_tables.rb#63
Net::IMAP::StringPrep::SASLprep::UNASSIGNED = T.let(T.unsafe(nil), Regexp)

# ArgumentError raised when +string+ is invalid for the stringprep
# +profile+.
#
# source://net-imap//lib/net/imap/stringprep.rb#19
class Net::IMAP::StringPrep::StringPrepError < ::ArgumentError
  # @return [StringPrepError] a new instance of StringPrepError
  #
  # source://net-imap//lib/net/imap/stringprep.rb#22
  def initialize(*args, string: T.unsafe(nil), profile: T.unsafe(nil)); end

  # Returns the value of attribute profile.
  #
  # source://net-imap//lib/net/imap/stringprep.rb#20
  def profile; end

  # Returns the value of attribute string.
  #
  # source://net-imap//lib/net/imap/stringprep.rb#20
  def string; end
end

# source://net-imap//lib/net/imap/stringprep/tables.rb#9
module Net::IMAP::StringPrep::Tables; end

# source://net-imap//lib/net/imap/stringprep/tables.rb#75
Net::IMAP::StringPrep::Tables::BIDI_DESC_REQ2 = T.let(T.unsafe(nil), String)

# source://net-imap//lib/net/imap/stringprep/tables.rb#83
Net::IMAP::StringPrep::Tables::BIDI_DESC_REQ3 = T.let(T.unsafe(nil), String)

# Bidirectional Characters [StringPrep, §6], Requirement 2
# >>>
#   If a string contains any RandALCat character, the string MUST NOT
#   contain any LCat character.
#
# source://net-imap//lib/net/imap/stringprep/tables.rb#81
Net::IMAP::StringPrep::Tables::BIDI_FAILS_REQ2 = T.let(T.unsafe(nil), Regexp)

# Bidirectional Characters [StringPrep, §6], Requirement 3
# >>>
#   If a string contains any RandALCat character, a RandALCat
#   character MUST be the first character of the string, and a
#   RandALCat character MUST be the last character of the string.
#
# source://net-imap//lib/net/imap/stringprep/tables.rb#90
Net::IMAP::StringPrep::Tables::BIDI_FAILS_REQ3 = T.let(T.unsafe(nil), Regexp)

# Bidirectional Characters [StringPrep, §6]
#
# source://net-imap//lib/net/imap/stringprep/tables.rb#93
Net::IMAP::StringPrep::Tables::BIDI_FAILURE = T.let(T.unsafe(nil), Regexp)

# Unassigned code points in Unicode 3.2 \StringPrep\[\"A.1\"]
#
# source://net-imap//lib/net/imap/stringprep/tables.rb#12
Net::IMAP::StringPrep::Tables::IN_A_1 = T.let(T.unsafe(nil), Regexp)

# Commonly mapped to nothing \StringPrep\[\"B.1\"]
#
# source://net-imap//lib/net/imap/stringprep/tables.rb#15
Net::IMAP::StringPrep::Tables::IN_B_1 = T.let(T.unsafe(nil), Regexp)

# Mapping for case-folding used with NFKC \StringPrep\[\"B.2\"]
#
# source://net-imap//lib/net/imap/stringprep/tables.rb#18
Net::IMAP::StringPrep::Tables::IN_B_2 = T.let(T.unsafe(nil), Regexp)

# Mapping for case-folding used with no normalization \StringPrep\[\"B.3\"]
#
# source://net-imap//lib/net/imap/stringprep/tables.rb#21
Net::IMAP::StringPrep::Tables::IN_B_3 = T.let(T.unsafe(nil), Regexp)

# ASCII space characters \StringPrep\[\"C.1.1\"]
#
# source://net-imap//lib/net/imap/stringprep/tables.rb#33
Net::IMAP::StringPrep::Tables::IN_C_1_1 = T.let(T.unsafe(nil), Regexp)

# Non-ASCII space characters \StringPrep\[\"C.1.2\"]
#
# source://net-imap//lib/net/imap/stringprep/tables.rb#36
Net::IMAP::StringPrep::Tables::IN_C_1_2 = T.let(T.unsafe(nil), Regexp)

# ASCII control characters \StringPrep\[\"C.2.1\"]
#
# source://net-imap//lib/net/imap/stringprep/tables.rb#39
Net::IMAP::StringPrep::Tables::IN_C_2_1 = T.let(T.unsafe(nil), Regexp)

# Non-ASCII control characters \StringPrep\[\"C.2.2\"]
#
# source://net-imap//lib/net/imap/stringprep/tables.rb#42
Net::IMAP::StringPrep::Tables::IN_C_2_2 = T.let(T.unsafe(nil), Regexp)

# Private use \StringPrep\[\"C.3\"]
#
# source://net-imap//lib/net/imap/stringprep/tables.rb#45
Net::IMAP::StringPrep::Tables::IN_C_3 = T.let(T.unsafe(nil), Regexp)

# Non-character code points \StringPrep\[\"C.4\"]
#
# source://net-imap//lib/net/imap/stringprep/tables.rb#48
Net::IMAP::StringPrep::Tables::IN_C_4 = T.let(T.unsafe(nil), Regexp)

# Surrogate codes \StringPrep\[\"C.5\"]
#
# source://net-imap//lib/net/imap/stringprep/tables.rb#51
Net::IMAP::StringPrep::Tables::IN_C_5 = T.let(T.unsafe(nil), Regexp)

# Inappropriate for plain text \StringPrep\[\"C.6\"]
#
# source://net-imap//lib/net/imap/stringprep/tables.rb#54
Net::IMAP::StringPrep::Tables::IN_C_6 = T.let(T.unsafe(nil), Regexp)

# Inappropriate for canonical representation \StringPrep\[\"C.7\"]
#
# source://net-imap//lib/net/imap/stringprep/tables.rb#57
Net::IMAP::StringPrep::Tables::IN_C_7 = T.let(T.unsafe(nil), Regexp)

# Change display properties or are deprecated \StringPrep\[\"C.8\"]
#
# source://net-imap//lib/net/imap/stringprep/tables.rb#60
Net::IMAP::StringPrep::Tables::IN_C_8 = T.let(T.unsafe(nil), Regexp)

# Tagging characters \StringPrep\[\"C.9\"]
#
# source://net-imap//lib/net/imap/stringprep/tables.rb#63
Net::IMAP::StringPrep::Tables::IN_C_9 = T.let(T.unsafe(nil), Regexp)

# Characters with bidirectional property "R" or "AL" \StringPrep\[\"D.1\"]
#
# source://net-imap//lib/net/imap/stringprep/tables.rb#66
Net::IMAP::StringPrep::Tables::IN_D_1 = T.let(T.unsafe(nil), Regexp)

# Used to check req3 of bidirectional checks
# Matches the negation of the D.1 table
#
# source://net-imap//lib/net/imap/stringprep/tables.rb#70
Net::IMAP::StringPrep::Tables::IN_D_1_NEGATED = T.let(T.unsafe(nil), Regexp)

# Characters with bidirectional property "L" \StringPrep\[\"D.2\"]
#
# source://net-imap//lib/net/imap/stringprep/tables.rb#73
Net::IMAP::StringPrep::Tables::IN_D_2 = T.let(T.unsafe(nil), Regexp)

# source://net-imap//lib/net/imap/stringprep/tables.rb#139
Net::IMAP::StringPrep::Tables::MAPPINGS = T.let(T.unsafe(nil), Hash)

# Replacements for IN_B.1
#
# source://net-imap//lib/net/imap/stringprep/tables.rb#24
Net::IMAP::StringPrep::Tables::MAP_B_1 = T.let(T.unsafe(nil), String)

# Replacements for IN_B.2
#
# source://net-imap//lib/net/imap/stringprep/tables.rb#27
Net::IMAP::StringPrep::Tables::MAP_B_2 = T.let(T.unsafe(nil), Hash)

# Replacements for IN_B.3
#
# source://net-imap//lib/net/imap/stringprep/tables.rb#30
Net::IMAP::StringPrep::Tables::MAP_B_3 = T.let(T.unsafe(nil), Hash)

# Regexps matching each codepoint table in the RFC-3454 appendices
#
# source://net-imap//lib/net/imap/stringprep/tables.rb#119
Net::IMAP::StringPrep::Tables::REGEXPS = T.let(T.unsafe(nil), Hash)

# Names of each codepoint table in the RFC-3454 appendices
#
# source://net-imap//lib/net/imap/stringprep/tables.rb#96
Net::IMAP::StringPrep::Tables::TITLES = T.let(T.unsafe(nil), Hash)

# Defined in RFC-4505[https://www.rfc-editor.org/rfc/rfc4505] §3, The +trace+
# profile of \StringPrep is used by the +ANONYMOUS+ \SASL mechanism.
#
# source://net-imap//lib/net/imap/stringprep/trace.rb#9
module Net::IMAP::StringPrep::Trace
  private

  # From RFC-4505[https://www.rfc-editor.org/rfc/rfc4505] §3, The "trace"
  # Profile of "Stringprep":
  # >>>
  #   The character repertoire of this profile is Unicode 3.2 [Unicode].
  #
  #   No mapping is required by this profile.
  #
  #   No Unicode normalization is required by this profile.
  #
  #   The list of unassigned code points for this profile is that provided
  #   in Appendix A of [StringPrep].  Unassigned code points are not
  #   prohibited.
  #
  #   Characters from the following tables of [StringPrep] are prohibited:
  #   (documented on PROHIBITED_TABLES)
  #
  #   This profile requires bidirectional character checking per Section 6
  #   of [StringPrep].
  #
  # source://net-imap//lib/net/imap/stringprep/trace.rb#68
  def stringprep_trace(string, **opts); end

  class << self
    # From RFC-4505[https://www.rfc-editor.org/rfc/rfc4505] §3, The "trace"
    # Profile of "Stringprep":
    # >>>
    #   The character repertoire of this profile is Unicode 3.2 [Unicode].
    #
    #   No mapping is required by this profile.
    #
    #   No Unicode normalization is required by this profile.
    #
    #   The list of unassigned code points for this profile is that provided
    #   in Appendix A of [StringPrep].  Unassigned code points are not
    #   prohibited.
    #
    #   Characters from the following tables of [StringPrep] are prohibited:
    #   (documented on PROHIBITED_TABLES)
    #
    #   This profile requires bidirectional character checking per Section 6
    #   of [StringPrep].
    #
    # source://net-imap//lib/net/imap/stringprep/trace.rb#68
    def stringprep_trace(string, **opts); end
  end
end

# >>>
#   This profile requires bidirectional character checking per Section 6
#   of [StringPrep].
#
# source://net-imap//lib/net/imap/stringprep/trace.rb#46
Net::IMAP::StringPrep::Trace::CHECK_BIDI = T.let(T.unsafe(nil), TrueClass)

# >>>
#   No mapping is required by this profile.
#
# source://net-imap//lib/net/imap/stringprep/trace.rb#20
Net::IMAP::StringPrep::Trace::MAPPING_TABLES = T.let(T.unsafe(nil), T.untyped)

# >>>
#   No Unicode normalization is required by this profile.
#
# source://net-imap//lib/net/imap/stringprep/trace.rb#24
Net::IMAP::StringPrep::Trace::NORMALIZATION = T.let(T.unsafe(nil), T.untyped)

# From RFC-4505[https://www.rfc-editor.org/rfc/rfc4505] §3, The "trace"
# Profile of "Stringprep":
# >>>
#   Characters from the following tables of [StringPrep] are prohibited:
#
#   - C.2.1 (ASCII control characters)
#   - C.2.2 (Non-ASCII control characters)
#   - C.3 (Private use characters)
#   - C.4 (Non-character code points)
#   - C.5 (Surrogate codes)
#   - C.6 (Inappropriate for plain text)
#   - C.8 (Change display properties are deprecated)
#   - C.9 (Tagging characters)
#
#   No additional characters are prohibited.
#
# source://net-imap//lib/net/imap/stringprep/trace.rb#41
Net::IMAP::StringPrep::Trace::PROHIBITED_TABLES = T.let(T.unsafe(nil), Array)

# Defined in RFC-4505[https://www.rfc-editor.org/rfc/rfc4505] §3.
#
# source://net-imap//lib/net/imap/stringprep/trace.rb#12
Net::IMAP::StringPrep::Trace::STRINGPREP_PROFILE = T.let(T.unsafe(nil), String)

# >>>
#   The character repertoire of this profile is Unicode 3.2 [Unicode].
#
# source://net-imap//lib/net/imap/stringprep/trace.rb#16
Net::IMAP::StringPrep::Trace::UNASSIGNED_TABLE = T.let(T.unsafe(nil), String)

# Mailbox attribute indicating that this mailbox is used to hold messages
# that have been deleted or marked for deletion. In some server
# implementations, this might be a virtual mailbox, containing messages from
# other mailboxes that are marked with the +\Deleted+ message flag.
# Alternatively, this might just be advice that a client that chooses not to
# use the \IMAP +\Deleted+ model should use as its trash location. In server
# implementations that strictly expect the \IMAP +\Deleted+ model, this
# special use is likely not to be supported.
#
# source://net-imap//lib/net/imap/flags.rb#258
Net::IMAP::TRASH = T.let(T.unsafe(nil), Symbol)

# Net::IMAP::ThreadMember represents a thread-node returned
# by Net::IMAP#thread.
#
# source://net-imap//lib/net/imap/response_data.rb#737
class Net::IMAP::ThreadMember < ::Struct
  # Returns a SequenceSet containing #seqno and all #children's seqno,
  # recursively.
  #
  # source://net-imap//lib/net/imap/response_data.rb#753
  def to_sequence_set; end

  protected

  # source://net-imap//lib/net/imap/response_data.rb#759
  def all_seqnos(node = T.unsafe(nil)); end
end

# Net::IMAP::UIDFetchData represents the contents of a +UIDFETCH+ response,
# When the +UIDONLY+ extension has been enabled, Net::IMAP#uid_fetch and
# Net::IMAP#uid_store will both return an array of UIDFetchData objects.
#
# UIDFetchData contains the same message attributes as FetchData.  However,
# +UIDFETCH+ responses return the UID at the beginning of the response,
# replacing FetchData#seqno.  UIDFetchData never contains a message sequence
# number.
#
# See FetchStruct documentation for a list of standard message attributes.
#
# source://net-imap//lib/net/imap/fetch_data.rb#559
class Net::IMAP::UIDFetchData < ::Net::IMAP::FetchStruct
  # UIDFetchData will print a warning if <tt>#attr["UID"]</tt> is present
  # but not identical to #uid.
  #
  # @return [UIDFetchData] a new instance of UIDFetchData
  #
  # source://net-imap//lib/net/imap/fetch_data.rb#588
  def initialize(*_arg0, **_arg1, &_arg2); end
end

# *NOTE:* <em>UIDPlusData is deprecated and will be removed in the +0.6.0+
# release.</em>  To use AppendUIDData and CopyUIDData before +0.6.0+, set
# Config#parser_use_deprecated_uidplus_data to +false+.
#
# UIDPlusData represents the ResponseCode#data that accompanies the
# +APPENDUID+ and +COPYUID+ {response codes}[rdoc-ref:ResponseCode].
#
# A server that supports +UIDPLUS+ should send UIDPlusData in response to
# the append[rdoc-ref:Net::IMAP#append], copy[rdoc-ref:Net::IMAP#copy],
# move[rdoc-ref:Net::IMAP#move], {uid copy}[rdoc-ref:Net::IMAP#uid_copy],
# and {uid move}[rdoc-ref:Net::IMAP#uid_move] commands---unless the
# destination mailbox reports +UIDNOTSTICKY+.
#
# Note that append[rdoc-ref:Net::IMAP#append], copy[rdoc-ref:Net::IMAP#copy]
# and {uid_copy}[rdoc-ref:Net::IMAP#uid_copy] return UIDPlusData in their
# TaggedResponse.  But move[rdoc-ref:Net::IMAP#copy] and
# {uid_move}[rdoc-ref:Net::IMAP#uid_move] _should_ send UIDPlusData in an
# UntaggedResponse response before sending their TaggedResponse.  However
# some servers do send UIDPlusData in the TaggedResponse for +MOVE+
# commands---this complies with the older +UIDPLUS+ specification but is
# discouraged by the +MOVE+ extension and disallowed by +IMAP4rev2+.
#
# == Required capability
# Requires either +UIDPLUS+ [RFC4315[https://www.rfc-editor.org/rfc/rfc4315]]
# or +IMAP4rev2+ capability.
#
# source://net-imap//lib/net/imap/uidplus_data.rb#32
class Net::IMAP::UIDPlusData < ::Struct
  # :call-seq: uid_mapping -> nil or a hash
  #
  # Returns a hash mapping each source UID to the newly assigned destination
  # UID.
  #
  # Note:: Returns +nil+ for Net::IMAP#append.
  #
  # source://net-imap//lib/net/imap/uidplus_data.rb#62
  def uid_mapping; end
end

# Error raised upon an unknown response from the server.
#
# This is different from InvalidResponseError: the response may be a
# valid extension response and the server may be allowed to send it in
# this context, but Net::IMAP either does not know how to parse it or
# how to handle it.  This could result from enabling unknown or
# unhandled extensions.  The connection may still be usable,
# but—depending on context—it may be prudent to disconnect.
#
# source://net-imap//lib/net/imap/errors.rb#110
class Net::IMAP::UnknownResponseError < ::Net::IMAP::ResponseError; end

# **Note:** This represents an intentionally _unstable_ API.  Where
# instances of this class are returned, future releases may return a
# different (incompatible) object <em>without deprecation or warning</em>.
#
# Net::IMAP::UnparsedData represents data for unknown response types or
# unknown extensions to response types without a well-defined extension
# grammar.
#
# See also: UnparsedNumericResponseData, ExtensionData, IgnoredResponse
#
# source://net-imap//lib/net/imap/response_data.rb#82
class Net::IMAP::UnparsedData < ::Struct; end

# **Note:** This represents an intentionally _unstable_ API.  Where
# instances of this class are returned, future releases may return a
# different (incompatible) object <em>without deprecation or warning</em>.
#
# Net::IMAP::UnparsedNumericResponseData represents data for unhandled
# response types with a numeric prefix.  See the documentation for #number.
#
# See also: UnparsedData, ExtensionData, IgnoredResponse
#
# source://net-imap//lib/net/imap/response_data.rb#98
class Net::IMAP::UnparsedNumericResponseData < ::Struct; end

# source://net-imap//lib/net/imap.rb#791
Net::IMAP::VERSION = T.let(T.unsafe(nil), String)

# Net::IMAP::VanishedData represents the contents of a +VANISHED+ response,
# which is described by the
# {QRESYNC}[https://www.rfc-editor.org/rfc/rfc7162.html] extension.
# [{RFC7162 §3.2.10}[https://www.rfc-editor.org/rfc/rfc7162.html#section-3.2.10]].
#
# +VANISHED+ responses replace +EXPUNGE+ responses when either the
# {QRESYNC}[https://www.rfc-editor.org/rfc/rfc7162.html] or the
# {UIDONLY}[https://www.rfc-editor.org/rfc/rfc9586.html] extension has been
# enabled.
#
# source://net-imap//lib/net/imap/vanished_data.rb#15
class Net::IMAP::VanishedData < ::Net::IMAP::DataLite
  # Returns a new VanishedData object.
  #
  # * +uids+ will be converted by SequenceSet.[].
  # * +earlier+ will be converted to +true+ or +false+
  #
  # @return [VanishedData] a new instance of VanishedData
  #
  # source://net-imap//lib/net/imap/vanished_data.rb#21
  def initialize(uids:, earlier:); end

  # Yields each UID in #uids and returns +self+.  Returns an Enumerator when
  # no block is given.
  #
  # See SequenceSet#each_number.
  #
  # source://net-imap//lib/net/imap/vanished_data.rb#58
  def each(&_arg0); end

  # rdoc doesn't handle attr aliases nicely. :(
  #
  # source://net-imap//lib/net/imap/vanished_data.rb#43
  def earlier?; end

  # Returns an Array of all of the UIDs in #uids.
  #
  # See SequenceSet#numbers.
  #
  # source://net-imap//lib/net/imap/vanished_data.rb#52
  def to_a; end
end

# source://net-imap//lib/net/imap/authenticators.rb#35
Net::IMAP::XOauth2Authenticator = Net::IMAP::SASL::XOAuth2Authenticator
