# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `activestorage` gem.
# Please instead update this file by running `bin/tapioca gem activestorage`.


class ActiveRecord::Base
  include ::ActiveModel::ForbiddenAttributesProtection
  include ::ActiveModel::AttributeAssignment
  include ::ActiveModel::Access
  include ::ActiveModel::Serialization
end

# :markup: markdown
# :include: ../README.md
#
# source://activestorage//lib/active_storage/gem_version.rb#3
module ActiveStorage
  extend ::ActiveSupport::Autoload

  # source://activestorage//lib/active_storage.rb#55
  def analyzers; end

  # source://activestorage//lib/active_storage.rb#55
  def analyzers=(val); end

  # source://activestorage//lib/active_storage.rb#61
  def binary_content_type; end

  # source://activestorage//lib/active_storage.rb#61
  def binary_content_type=(val); end

  # source://activestorage//lib/active_storage.rb#63
  def content_types_allowed_inline; end

  # source://activestorage//lib/active_storage.rb#63
  def content_types_allowed_inline=(val); end

  # source://activestorage//lib/active_storage.rb#62
  def content_types_to_serve_as_binary; end

  # source://activestorage//lib/active_storage.rb#62
  def content_types_to_serve_as_binary=(val); end

  # source://activestorage//lib/active_storage.rb#361
  def draw_routes; end

  # source://activestorage//lib/active_storage.rb#361
  def draw_routes=(val); end

  # source://activestorage//lib/active_storage.rb#48
  def logger; end

  # source://activestorage//lib/active_storage.rb#48
  def logger=(val); end

  # source://activestorage//lib/active_storage.rb#57
  def paths; end

  # source://activestorage//lib/active_storage.rb#57
  def paths=(val); end

  # source://activestorage//lib/active_storage.rb#54
  def previewers; end

  # source://activestorage//lib/active_storage.rb#54
  def previewers=(val); end

  # source://activestorage//lib/active_storage.rb#52
  def queues; end

  # source://activestorage//lib/active_storage.rb#52
  def queues=(val); end

  # source://activestorage//lib/active_storage.rb#362
  def resolve_model_to_route; end

  # source://activestorage//lib/active_storage.rb#362
  def resolve_model_to_route=(val); end

  # source://activestorage//lib/active_storage.rb#360
  def routes_prefix; end

  # source://activestorage//lib/active_storage.rb#360
  def routes_prefix=(val); end

  # source://activestorage//lib/active_storage.rb#356
  def service_urls_expire_in; end

  # source://activestorage//lib/active_storage.rb#356
  def service_urls_expire_in=(val); end

  # source://activestorage//lib/active_storage.rb#65
  def supported_image_processing_methods; end

  # source://activestorage//lib/active_storage.rb#65
  def supported_image_processing_methods=(val); end

  # source://activestorage//lib/active_storage.rb#357
  def touch_attachment_records; end

  # source://activestorage//lib/active_storage.rb#357
  def touch_attachment_records=(val); end

  # source://activestorage//lib/active_storage.rb#364
  def track_variants; end

  # source://activestorage//lib/active_storage.rb#364
  def track_variants=(val); end

  # source://activestorage//lib/active_storage.rb#354
  def unsupported_image_processing_arguments; end

  # source://activestorage//lib/active_storage.rb#354
  def unsupported_image_processing_arguments=(val); end

  # source://activestorage//lib/active_storage.rb#358
  def urls_expire_in; end

  # source://activestorage//lib/active_storage.rb#358
  def urls_expire_in=(val); end

  # source://activestorage//lib/active_storage.rb#59
  def variable_content_types; end

  # source://activestorage//lib/active_storage.rb#59
  def variable_content_types=(val); end

  # source://activestorage//lib/active_storage.rb#50
  def variant_processor; end

  # source://activestorage//lib/active_storage.rb#50
  def variant_processor=(val); end

  # source://activestorage//lib/active_storage.rb#49
  def verifier; end

  # source://activestorage//lib/active_storage.rb#49
  def verifier=(val); end

  # source://activestorage//lib/active_storage.rb#366
  def video_preview_arguments; end

  # source://activestorage//lib/active_storage.rb#366
  def video_preview_arguments=(val); end

  # source://activestorage//lib/active_storage.rb#60
  def web_image_content_types; end

  # source://activestorage//lib/active_storage.rb#60
  def web_image_content_types=(val); end

  class << self
    # source://activestorage//lib/active_storage.rb#55
    def analyzers; end

    # source://activestorage//lib/active_storage.rb#55
    def analyzers=(val); end

    # source://activestorage//lib/active_storage.rb#61
    def binary_content_type; end

    # source://activestorage//lib/active_storage.rb#61
    def binary_content_type=(val); end

    # source://activestorage//lib/active_storage.rb#63
    def content_types_allowed_inline; end

    # source://activestorage//lib/active_storage.rb#63
    def content_types_allowed_inline=(val); end

    # source://activestorage//lib/active_storage.rb#62
    def content_types_to_serve_as_binary; end

    # source://activestorage//lib/active_storage.rb#62
    def content_types_to_serve_as_binary=(val); end

    # source://activestorage//lib/active_storage/deprecator.rb#4
    def deprecator; end

    # source://activestorage//lib/active_storage.rb#361
    def draw_routes; end

    # source://activestorage//lib/active_storage.rb#361
    def draw_routes=(val); end

    # Returns the currently loaded version of Active Storage as a +Gem::Version+.
    #
    # source://activestorage//lib/active_storage/gem_version.rb#5
    def gem_version; end

    # source://activestorage//lib/active_storage.rb#48
    def logger; end

    # source://activestorage//lib/active_storage.rb#48
    def logger=(val); end

    # source://activestorage//lib/active_storage.rb#57
    def paths; end

    # source://activestorage//lib/active_storage.rb#57
    def paths=(val); end

    # source://activestorage//lib/active_storage.rb#54
    def previewers; end

    # source://activestorage//lib/active_storage.rb#54
    def previewers=(val); end

    # source://activestorage//lib/active_storage.rb#52
    def queues; end

    # source://activestorage//lib/active_storage.rb#52
    def queues=(val); end

    # source://activestorage//lib/active_storage/engine.rb#26
    def railtie_helpers_paths; end

    # source://activestorage//lib/active_storage/engine.rb#26
    def railtie_namespace; end

    # source://activestorage//lib/active_storage/engine.rb#26
    def railtie_routes_url_helpers(include_path_helpers = T.unsafe(nil)); end

    # source://activestorage//lib/active_storage.rb#362
    def resolve_model_to_route; end

    # source://activestorage//lib/active_storage.rb#362
    def resolve_model_to_route=(val); end

    # source://activestorage//lib/active_storage.rb#360
    def routes_prefix; end

    # source://activestorage//lib/active_storage.rb#360
    def routes_prefix=(val); end

    # source://activestorage//lib/active_storage.rb#356
    def service_urls_expire_in; end

    # source://activestorage//lib/active_storage.rb#356
    def service_urls_expire_in=(val); end

    # source://activestorage//lib/active_storage.rb#65
    def supported_image_processing_methods; end

    # source://activestorage//lib/active_storage.rb#65
    def supported_image_processing_methods=(val); end

    # source://activestorage//lib/active_storage/engine.rb#26
    def table_name_prefix; end

    # source://activestorage//lib/active_storage.rb#357
    def touch_attachment_records; end

    # source://activestorage//lib/active_storage.rb#357
    def touch_attachment_records=(val); end

    # source://activestorage//lib/active_storage.rb#364
    def track_variants; end

    # source://activestorage//lib/active_storage.rb#364
    def track_variants=(val); end

    # source://activestorage//lib/active_storage.rb#354
    def unsupported_image_processing_arguments; end

    # source://activestorage//lib/active_storage.rb#354
    def unsupported_image_processing_arguments=(val); end

    # source://activestorage//lib/active_storage.rb#358
    def urls_expire_in; end

    # source://activestorage//lib/active_storage.rb#358
    def urls_expire_in=(val); end

    # source://activestorage//lib/active_storage/engine.rb#26
    def use_relative_model_naming?; end

    # source://activestorage//lib/active_storage.rb#59
    def variable_content_types; end

    # source://activestorage//lib/active_storage.rb#59
    def variable_content_types=(val); end

    # source://activestorage//lib/active_storage.rb#50
    def variant_processor; end

    # source://activestorage//lib/active_storage.rb#50
    def variant_processor=(val); end

    # source://activestorage//lib/active_storage.rb#49
    def verifier; end

    # source://activestorage//lib/active_storage.rb#49
    def verifier=(val); end

    # Returns the currently loaded version of Active Storage as a +Gem::Version+.
    #
    # source://activestorage//lib/active_storage/version.rb#7
    def version; end

    # source://activestorage//lib/active_storage.rb#366
    def video_preview_arguments; end

    # source://activestorage//lib/active_storage.rb#366
    def video_preview_arguments=(val); end

    # source://activestorage//lib/active_storage.rb#60
    def web_image_content_types; end

    # source://activestorage//lib/active_storage.rb#60
    def web_image_content_types=(val); end
  end
end

class ActiveStorage::AnalyzeJob < ::ActiveStorage::BaseJob
  def perform(blob); end

  class << self
    private

    def __class_attr_queue_name; end
    def __class_attr_queue_name=(new_value); end
    def __class_attr_rescue_handlers; end
    def __class_attr_rescue_handlers=(new_value); end
  end
end

# = Active Storage \Analyzer
#
# This is an abstract base class for analyzers, which extract metadata from blobs. See
# ActiveStorage::Analyzer::VideoAnalyzer for an example of a concrete subclass.
#
# source://activestorage//lib/active_storage/analyzer.rb#8
class ActiveStorage::Analyzer
  # @return [Analyzer] a new instance of Analyzer
  #
  # source://activestorage//lib/active_storage/analyzer.rb#23
  def initialize(blob); end

  # Returns the value of attribute blob.
  #
  # source://activestorage//lib/active_storage/analyzer.rb#9
  def blob; end

  # Override this method in a concrete subclass. Have it return a Hash of metadata.
  #
  # @raise [NotImplementedError]
  #
  # source://activestorage//lib/active_storage/analyzer.rb#28
  def metadata; end

  private

  # Downloads the blob to a tempfile on disk. Yields the tempfile.
  #
  # source://activestorage//lib/active_storage/analyzer.rb#34
  def download_blob_to_tempfile(&block); end

  # source://activestorage//lib/active_storage/analyzer.rb#46
  def instrument(analyzer, &block); end

  # source://activestorage//lib/active_storage/analyzer.rb#38
  def logger; end

  # source://activestorage//lib/active_storage/analyzer.rb#42
  def tmpdir; end

  class << self
    # Implement this method in a concrete subclass. Have it return true when given a blob from which
    # the analyzer can extract metadata.
    #
    # @return [Boolean]
    #
    # source://activestorage//lib/active_storage/analyzer.rb#13
    def accept?(blob); end

    # Implement this method in concrete subclasses. It will determine if blob analysis
    # should be done in a job or performed inline. By default, analysis is enqueued in a job.
    #
    # @return [Boolean]
    #
    # source://activestorage//lib/active_storage/analyzer.rb#19
    def analyze_later?; end
  end
end

# source://activestorage//lib/active_storage/analyzer/audio_analyzer.rb#14
class ActiveStorage::Analyzer::AudioAnalyzer < ::ActiveStorage::Analyzer
  # source://activestorage//lib/active_storage/analyzer/audio_analyzer.rb#19
  def metadata; end

  private

  # source://activestorage//lib/active_storage/analyzer/audio_analyzer.rb#44
  def audio_stream; end

  # source://activestorage//lib/active_storage/analyzer/audio_analyzer.rb#29
  def bit_rate; end

  # source://activestorage//lib/active_storage/analyzer/audio_analyzer.rb#24
  def duration; end

  # source://activestorage//lib/active_storage/analyzer/audio_analyzer.rb#73
  def ffprobe_path; end

  # source://activestorage//lib/active_storage/analyzer/audio_analyzer.rb#52
  def probe; end

  # source://activestorage//lib/active_storage/analyzer/audio_analyzer.rb#56
  def probe_from(file); end

  # source://activestorage//lib/active_storage/analyzer/audio_analyzer.rb#34
  def sample_rate; end

  # source://activestorage//lib/active_storage/analyzer/audio_analyzer.rb#48
  def streams; end

  # source://activestorage//lib/active_storage/analyzer/audio_analyzer.rb#39
  def tags; end

  class << self
    # source://activestorage//lib/active_storage/analyzer/audio_analyzer.rb#15
    def accept?(blob); end
  end
end

# source://activestorage//lib/active_storage/analyzer/image_analyzer.rb#14
class ActiveStorage::Analyzer::ImageAnalyzer < ::ActiveStorage::Analyzer
  # source://activestorage//lib/active_storage/analyzer/image_analyzer.rb#19
  def metadata; end

  class << self
    # source://activestorage//lib/active_storage/analyzer/image_analyzer.rb#15
    def accept?(blob); end
  end
end

# source://activestorage//lib/active_storage/analyzer/image_analyzer/image_magick.rb#6
class ActiveStorage::Analyzer::ImageAnalyzer::ImageMagick < ::ActiveStorage::Analyzer::ImageAnalyzer
  private

  # source://activestorage//lib/active_storage/analyzer/image_analyzer/image_magick.rb#12
  def read_image; end

  # source://activestorage//lib/active_storage/analyzer/image_analyzer/image_magick.rb#37
  def rotated_image?(image); end

  class << self
    # source://activestorage//lib/active_storage/analyzer/image_analyzer/image_magick.rb#7
    def accept?(blob); end
  end
end

# source://activestorage//lib/active_storage/analyzer/image_analyzer/vips.rb#6
class ActiveStorage::Analyzer::ImageAnalyzer::Vips < ::ActiveStorage::Analyzer::ImageAnalyzer
  private

  # source://activestorage//lib/active_storage/analyzer/image_analyzer/vips.rb#12
  def read_image; end

  # source://activestorage//lib/active_storage/analyzer/image_analyzer/vips.rb#41
  def rotated_image?(image); end

  class << self
    # source://activestorage//lib/active_storage/analyzer/image_analyzer/vips.rb#7
    def accept?(blob); end
  end
end

# source://activestorage//lib/active_storage/analyzer/image_analyzer/vips.rb#40
ActiveStorage::Analyzer::ImageAnalyzer::Vips::ROTATIONS = T.let(T.unsafe(nil), Regexp)

# source://activestorage//lib/active_storage/analyzer/null_analyzer.rb#4
class ActiveStorage::Analyzer::NullAnalyzer < ::ActiveStorage::Analyzer
  # source://activestorage//lib/active_storage/analyzer/null_analyzer.rb#13
  def metadata; end

  class << self
    # source://activestorage//lib/active_storage/analyzer/null_analyzer.rb#5
    def accept?(blob); end

    # source://activestorage//lib/active_storage/analyzer/null_analyzer.rb#9
    def analyze_later?; end
  end
end

# source://activestorage//lib/active_storage/analyzer/video_analyzer.rb#24
class ActiveStorage::Analyzer::VideoAnalyzer < ::ActiveStorage::Analyzer
  # source://activestorage//lib/active_storage/analyzer/video_analyzer.rb#29
  def metadata; end

  private

  # source://activestorage//lib/active_storage/analyzer/video_analyzer.rb#55
  def angle; end

  # source://activestorage//lib/active_storage/analyzer/video_analyzer.rb#82
  def audio?; end

  # source://activestorage//lib/active_storage/analyzer/video_analyzer.rb#120
  def audio_stream; end

  # source://activestorage//lib/active_storage/analyzer/video_analyzer.rb#90
  def computed_height; end

  # source://activestorage//lib/active_storage/analyzer/video_analyzer.rb#128
  def container; end

  # source://activestorage//lib/active_storage/analyzer/video_analyzer.rb#67
  def display_aspect_ratio; end

  # source://activestorage//lib/active_storage/analyzer/video_analyzer.rb#104
  def display_height_scale; end

  # source://activestorage//lib/active_storage/analyzer/video_analyzer.rb#63
  def display_matrix; end

  # source://activestorage//lib/active_storage/analyzer/video_analyzer.rb#50
  def duration; end

  # source://activestorage//lib/active_storage/analyzer/video_analyzer.rb#100
  def encoded_height; end

  # source://activestorage//lib/active_storage/analyzer/video_analyzer.rb#96
  def encoded_width; end

  # source://activestorage//lib/active_storage/analyzer/video_analyzer.rb#153
  def ffprobe_path; end

  # source://activestorage//lib/active_storage/analyzer/video_analyzer.rb#42
  def height; end

  # source://activestorage//lib/active_storage/analyzer/video_analyzer.rb#132
  def probe; end

  # source://activestorage//lib/active_storage/analyzer/video_analyzer.rb#136
  def probe_from(file); end

  # source://activestorage//lib/active_storage/analyzer/video_analyzer.rb#78
  def rotated?; end

  # source://activestorage//lib/active_storage/analyzer/video_analyzer.rb#112
  def side_data; end

  # source://activestorage//lib/active_storage/analyzer/video_analyzer.rb#124
  def streams; end

  # source://activestorage//lib/active_storage/analyzer/video_analyzer.rb#108
  def tags; end

  # source://activestorage//lib/active_storage/analyzer/video_analyzer.rb#86
  def video?; end

  # source://activestorage//lib/active_storage/analyzer/video_analyzer.rb#116
  def video_stream; end

  # source://activestorage//lib/active_storage/analyzer/video_analyzer.rb#34
  def width; end

  class << self
    # source://activestorage//lib/active_storage/analyzer/video_analyzer.rb#25
    def accept?(blob); end
  end
end

# = Active Storage \Attached
#
# Abstract base class for the concrete ActiveStorage::Attached::One and ActiveStorage::Attached::Many
# classes that both provide proxy access to the blob association for a record.
#
# source://activestorage//lib/active_storage/attached.rb#10
class ActiveStorage::Attached
  # @return [Attached] a new instance of Attached
  #
  # source://activestorage//lib/active_storage/attached.rb#13
  def initialize(name, record); end

  # Returns the value of attribute name.
  #
  # source://activestorage//lib/active_storage/attached.rb#11
  def name; end

  # Returns the value of attribute record.
  #
  # source://activestorage//lib/active_storage/attached.rb#11
  def record; end

  private

  # source://activestorage//lib/active_storage/attached.rb#18
  def change; end
end

# source://activestorage//lib/active_storage/attached/changes.rb#4
module ActiveStorage::Attached::Changes
  extend ::ActiveSupport::Autoload
end

# source://activestorage//lib/active_storage/attached/changes/create_many.rb#4
class ActiveStorage::Attached::Changes::CreateMany
  # source://activestorage//lib/active_storage/attached/changes/create_many.rb#7
  def initialize(name, record, attachables, pending_uploads: T.unsafe(nil)); end

  # source://activestorage//lib/active_storage/attached/changes/create_many.rb#5
  def attachables; end

  # source://activestorage//lib/active_storage/attached/changes/create_many.rb#14
  def attachments; end

  # source://activestorage//lib/active_storage/attached/changes/create_many.rb#18
  def blobs; end

  # source://activestorage//lib/active_storage/attached/changes/create_many.rb#5
  def name; end

  # source://activestorage//lib/active_storage/attached/changes/create_many.rb#5
  def pending_uploads; end

  # source://activestorage//lib/active_storage/attached/changes/create_many.rb#5
  def record; end

  # source://activestorage//lib/active_storage/attached/changes/create_many.rb#26
  def save; end

  # source://activestorage//lib/active_storage/attached/changes/create_many.rb#22
  def upload; end

  private

  # source://activestorage//lib/active_storage/attached/changes/create_many.rb#44
  def assign_associated_attachments; end

  # source://activestorage//lib/active_storage/attached/changes/create_many.rb#36
  def build_subchange_from(attachable); end

  # source://activestorage//lib/active_storage/attached/changes/create_many.rb#52
  def persisted_or_new_attachments; end

  # source://activestorage//lib/active_storage/attached/changes/create_many.rb#48
  def reset_associated_blobs; end

  # source://activestorage//lib/active_storage/attached/changes/create_many.rb#32
  def subchanges; end

  # source://activestorage//lib/active_storage/attached/changes/create_many.rb#40
  def subchanges_without_blobs; end
end

# source://activestorage//lib/active_storage/attached/changes/create_one.rb#7
class ActiveStorage::Attached::Changes::CreateOne
  # source://activestorage//lib/active_storage/attached/changes/create_one.rb#10
  def initialize(name, record, attachable); end

  # source://activestorage//lib/active_storage/attached/changes/create_one.rb#8
  def attachable; end

  # source://activestorage//lib/active_storage/attached/changes/create_one.rb#15
  def attachment; end

  # source://activestorage//lib/active_storage/attached/changes/create_one.rb#19
  def blob; end

  # source://activestorage//lib/active_storage/attached/changes/create_one.rb#8
  def name; end

  # source://activestorage//lib/active_storage/attached/changes/create_one.rb#8
  def record; end

  # source://activestorage//lib/active_storage/attached/changes/create_one.rb#48
  def save; end

  # source://activestorage//lib/active_storage/attached/changes/create_one.rb#23
  def upload; end

  private

  # source://activestorage//lib/active_storage/attached/changes/create_one.rb#120
  def attachment_service_name; end

  # source://activestorage//lib/active_storage/attached/changes/create_one.rb#64
  def build_attachment; end

  # source://activestorage//lib/active_storage/attached/changes/create_one.rb#58
  def find_attachment; end

  # source://activestorage//lib/active_storage/attached/changes/create_one.rb#54
  def find_or_build_attachment; end

  # source://activestorage//lib/active_storage/attached/changes/create_one.rb#68
  def find_or_build_blob; end
end

# source://activestorage//lib/active_storage/attached/changes/create_one_of_many.rb#4
class ActiveStorage::Attached::Changes::CreateOneOfMany < ::ActiveStorage::Attached::Changes::CreateOne
  private

  # source://activestorage//lib/active_storage/attached/changes/create_one_of_many.rb#6
  def find_attachment; end
end

# source://activestorage//lib/active_storage/attached/changes/delete_many.rb#4
class ActiveStorage::Attached::Changes::DeleteMany
  # source://activestorage//lib/active_storage/attached/changes/delete_many.rb#7
  def initialize(name, record); end

  # source://activestorage//lib/active_storage/attached/changes/delete_many.rb#11
  def attachables; end

  # source://activestorage//lib/active_storage/attached/changes/delete_many.rb#15
  def attachments; end

  # source://activestorage//lib/active_storage/attached/changes/delete_many.rb#19
  def blobs; end

  # source://activestorage//lib/active_storage/attached/changes/delete_many.rb#5
  def name; end

  # source://activestorage//lib/active_storage/attached/changes/delete_many.rb#5
  def record; end

  # source://activestorage//lib/active_storage/attached/changes/delete_many.rb#23
  def save; end
end

# source://activestorage//lib/active_storage/attached/changes/delete_one.rb#4
class ActiveStorage::Attached::Changes::DeleteOne
  # source://activestorage//lib/active_storage/attached/changes/delete_one.rb#7
  def initialize(name, record); end

  # source://activestorage//lib/active_storage/attached/changes/delete_one.rb#11
  def attachment; end

  # source://activestorage//lib/active_storage/attached/changes/delete_one.rb#5
  def name; end

  # source://activestorage//lib/active_storage/attached/changes/delete_one.rb#5
  def record; end

  # source://activestorage//lib/active_storage/attached/changes/delete_one.rb#15
  def save; end
end

# source://activestorage//lib/active_storage/attached/changes/detach_many.rb#4
class ActiveStorage::Attached::Changes::DetachMany
  # source://activestorage//lib/active_storage/attached/changes/detach_many.rb#7
  def initialize(name, record, attachments); end

  # source://activestorage//lib/active_storage/attached/changes/detach_many.rb#5
  def attachments; end

  # source://activestorage//lib/active_storage/attached/changes/detach_many.rb#11
  def detach; end

  # source://activestorage//lib/active_storage/attached/changes/detach_many.rb#5
  def name; end

  # source://activestorage//lib/active_storage/attached/changes/detach_many.rb#5
  def record; end
end

# source://activestorage//lib/active_storage/attached/changes/detach_one.rb#4
class ActiveStorage::Attached::Changes::DetachOne
  # source://activestorage//lib/active_storage/attached/changes/detach_one.rb#7
  def initialize(name, record, attachment); end

  # source://activestorage//lib/active_storage/attached/changes/detach_one.rb#5
  def attachment; end

  # source://activestorage//lib/active_storage/attached/changes/detach_one.rb#11
  def detach; end

  # source://activestorage//lib/active_storage/attached/changes/detach_one.rb#5
  def name; end

  # source://activestorage//lib/active_storage/attached/changes/detach_one.rb#5
  def record; end

  private

  # source://activestorage//lib/active_storage/attached/changes/detach_one.rb#19
  def reset; end
end

# source://activestorage//lib/active_storage/attached/changes/purge_many.rb#4
class ActiveStorage::Attached::Changes::PurgeMany
  # source://activestorage//lib/active_storage/attached/changes/purge_many.rb#7
  def initialize(name, record, attachments); end

  # source://activestorage//lib/active_storage/attached/changes/purge_many.rb#5
  def attachments; end

  # source://activestorage//lib/active_storage/attached/changes/purge_many.rb#5
  def name; end

  # source://activestorage//lib/active_storage/attached/changes/purge_many.rb#11
  def purge; end

  # source://activestorage//lib/active_storage/attached/changes/purge_many.rb#16
  def purge_later; end

  # source://activestorage//lib/active_storage/attached/changes/purge_many.rb#5
  def record; end

  private

  # source://activestorage//lib/active_storage/attached/changes/purge_many.rb#22
  def reset; end
end

# source://activestorage//lib/active_storage/attached/changes/purge_one.rb#4
class ActiveStorage::Attached::Changes::PurgeOne
  # source://activestorage//lib/active_storage/attached/changes/purge_one.rb#7
  def initialize(name, record, attachment); end

  # source://activestorage//lib/active_storage/attached/changes/purge_one.rb#5
  def attachment; end

  # source://activestorage//lib/active_storage/attached/changes/purge_one.rb#5
  def name; end

  # source://activestorage//lib/active_storage/attached/changes/purge_one.rb#11
  def purge; end

  # source://activestorage//lib/active_storage/attached/changes/purge_one.rb#16
  def purge_later; end

  # source://activestorage//lib/active_storage/attached/changes/purge_one.rb#5
  def record; end

  private

  # source://activestorage//lib/active_storage/attached/changes/purge_one.rb#22
  def reset; end
end

# source://activestorage//lib/active_storage/attached/many.rb#7
class ActiveStorage::Attached::Many < ::ActiveStorage::Attached
  # source://activestorage//lib/active_storage/attached/many.rb#51
  def attach(*attachables); end

  # source://activestorage//lib/active_storage/attached/many.rb#66
  def attached?; end

  # source://activestorage//lib/active_storage/attached/many.rb#32
  def attachments; end

  # source://activestorage//lib/active_storage/attached/many.rb#37
  def blobs; end

  # source://activestorage//lib/active_storage/attached/many.rb#25
  def detach(*_arg0, **_arg1, &_arg2); end

  # source://activestorage//lib/active_storage/attached/many.rb#27
  def method_missing(method, *_arg1, **_arg2, &_arg3); end

  # source://activestorage//lib/active_storage/attached/many.rb#13
  def purge(*_arg0, **_arg1, &_arg2); end

  # source://activestorage//lib/active_storage/attached/many.rb#19
  def purge_later(*_arg0, **_arg1, &_arg2); end

  private

  # source://activestorage//lib/active_storage/attached/many.rb#75
  def detach_many; end

  # source://activestorage//lib/active_storage/attached/many.rb#71
  def purge_many; end

  # source://activestorage//lib/active_storage/attached/many.rb#27
  def respond_to_missing?(name, include_private = T.unsafe(nil)); end
end

# source://activestorage//lib/active_storage/attached/model.rb#9
module ActiveStorage::Attached::Model
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::ActiveStorage::Attached::Model::ClassMethods

  # source://activestorage//lib/active_storage/attached/model.rb#281
  def attachment_changes; end

  # source://activestorage//lib/active_storage/attached/model.rb#285
  def changed_for_autosave?; end

  # source://activestorage//lib/active_storage/attached/model.rb#295
  def reload(*_arg0); end

  private

  # source://activestorage//lib/active_storage/attached/model.rb#289
  def initialize_dup(*_arg0); end

  class << self
    # source://activestorage//lib/active_storage/attached/model.rb#263
    def validate_service_configuration(service_name, model_class, association_name); end

    private

    # source://activestorage//lib/active_storage/attached/model.rb#274
    def validate_global_service_configuration(model_class); end
  end
end

# source://activestorage//lib/active_storage/attached/model.rb#54
module ActiveStorage::Attached::Model::ClassMethods
  # source://activestorage//lib/active_storage/attached/model.rb#210
  def has_many_attached(name, dependent: T.unsafe(nil), service: T.unsafe(nil), strict_loading: T.unsafe(nil)); end

  # source://activestorage//lib/active_storage/attached/model.rb#108
  def has_one_attached(name, dependent: T.unsafe(nil), service: T.unsafe(nil), strict_loading: T.unsafe(nil)); end
end

# source://activestorage//lib/active_storage/attached/one.rb#7
class ActiveStorage::Attached::One < ::ActiveStorage::Attached
  # source://activestorage//lib/active_storage/attached/one.rb#58
  def attach(attachable); end

  # source://activestorage//lib/active_storage/attached/one.rb#73
  def attached?; end

  # source://activestorage//lib/active_storage/attached/one.rb#33
  def attachment; end

  # source://activestorage//lib/active_storage/attached/one.rb#44
  def blank?; end

  # source://activestorage//lib/active_storage/attached/one.rb#25
  def detach(*_arg0, **_arg1, &_arg2); end

  # source://activestorage//lib/active_storage/attached/one.rb#27
  def method_missing(method, *_arg1, **_arg2, &_arg3); end

  # source://activestorage//lib/active_storage/attached/one.rb#13
  def purge(*_arg0, **_arg1, &_arg2); end

  # source://activestorage//lib/active_storage/attached/one.rb#19
  def purge_later(*_arg0, **_arg1, &_arg2); end

  private

  # source://activestorage//lib/active_storage/attached/one.rb#82
  def detach_one; end

  # source://activestorage//lib/active_storage/attached/one.rb#78
  def purge_one; end

  # source://activestorage//lib/active_storage/attached/one.rb#27
  def respond_to_missing?(name, include_private = T.unsafe(nil)); end
end

class ActiveStorage::Attachment < ::ActiveStorage::Record
  include ::ActiveStorage::Attachment::GeneratedAttributeMethods
  include ::ActiveStorage::Attachment::GeneratedAssociationMethods

  def autosave_associated_records_for_blob(*args); end
  def autosave_associated_records_for_record(*args); end
  def method_missing(method, *_arg1, **_arg2, &_arg3); end
  def preview(transformations); end
  def purge; end
  def purge_later; end
  def representation(transformations); end
  def signed_id(*_arg0, **_arg1, &_arg2); end
  def validate_associated_records_for_blob(*args); end
  def variant(transformations); end

  private

  def analyze_blob_later; end
  def dependent; end
  def mirror_blob_later; end
  def named_variants; end
  def purge_dependent_blob_later; end
  def respond_to_missing?(name, include_private = T.unsafe(nil)); end
  def transform_variants_later; end
  def transformations_by_name(transformations); end

  class << self
    def with_all_variant_records(*args, **_arg1); end

    private

    def __class_attr___callbacks; end
    def __class_attr___callbacks=(new_value); end
    def __class_attr__reflections; end
    def __class_attr__reflections=(new_value); end
    def __class_attr__validators; end
    def __class_attr__validators=(new_value); end
    def __class_attr_defined_enums; end
    def __class_attr_defined_enums=(new_value); end
  end
end

module ActiveStorage::Attachment::GeneratedAssociationMethods
  def blob; end
  def blob=(value); end
  def blob_changed?; end
  def blob_previously_changed?; end
  def build_blob(*args, &block); end
  def create_blob(*args, &block); end
  def create_blob!(*args, &block); end
  def record; end
  def record=(value); end
  def record_changed?; end
  def record_previously_changed?; end
  def reload_blob; end
  def reload_record; end
  def reset_blob; end
  def reset_record; end
end

module ActiveStorage::Attachment::GeneratedAttributeMethods; end

class ActiveStorage::BaseController < ::ActionController::Base
  include ::ActiveStorage::SetCurrent

  private

  def _layout(lookup_context, formats, keys); end

  class << self
    private

    def __class_attr___callbacks; end
    def __class_attr___callbacks=(new_value); end
    def __class_attr_etag_with_template_digest; end
    def __class_attr_etag_with_template_digest=(new_value); end
    def __class_attr_middleware_stack; end
    def __class_attr_middleware_stack=(new_value); end
  end
end

class ActiveStorage::BaseJob < ::ActiveJob::Base; end
module ActiveStorage::Blobs; end

class ActiveStorage::Blobs::ProxyController < ::ActiveStorage::BaseController
  include ::ActiveStorage::SetBlob
  include ::ActionController::Live
  include ::ActiveStorage::Streaming
  include ::ActiveStorage::DisableSession
  extend ::ActionController::Live::ClassMethods

  def show; end

  private

  def _layout(lookup_context, formats, keys); end

  class << self
    private

    def __class_attr___callbacks; end
    def __class_attr___callbacks=(new_value); end
    def __class_attr_middleware_stack; end
    def __class_attr_middleware_stack=(new_value); end
  end
end

class ActiveStorage::Blobs::RedirectController < ::ActiveStorage::BaseController
  include ::ActiveStorage::SetBlob

  def show; end

  private

  def _layout(lookup_context, formats, keys); end

  class << self
    private

    def __class_attr___callbacks; end
    def __class_attr___callbacks=(new_value); end
    def __class_attr_middleware_stack; end
    def __class_attr_middleware_stack=(new_value); end
  end
end

class ActiveStorage::Current < ::ActiveSupport::CurrentAttributes
  class << self
    def url_options; end
    def url_options=(value); end

    private

    def __class_attr_defaults; end
    def __class_attr_defaults=(new_value); end
  end
end

class ActiveStorage::DirectUploadsController < ::ActiveStorage::BaseController
  def create; end

  private

  def _layout(lookup_context, formats, keys); end
  def blob_args; end
  def direct_upload_json(blob); end

  class << self
    private

    def __class_attr_middleware_stack; end
    def __class_attr_middleware_stack=(new_value); end
  end
end

module ActiveStorage::DisableSession
  extend ::ActiveSupport::Concern
end

class ActiveStorage::DiskController < ::ActiveStorage::BaseController
  include ::ActiveStorage::FileServer

  def show; end
  def update; end

  private

  def _layout(lookup_context, formats, keys); end
  def acceptable_content?(token); end
  def decode_verified_key; end
  def decode_verified_token; end
  def named_disk_service(name); end

  class << self
    private

    def __class_attr___callbacks; end
    def __class_attr___callbacks=(new_value); end
    def __class_attr_middleware_stack; end
    def __class_attr_middleware_stack=(new_value); end
  end
end

# source://activestorage//lib/active_storage/downloader.rb#4
class ActiveStorage::Downloader
  # @return [Downloader] a new instance of Downloader
  #
  # source://activestorage//lib/active_storage/downloader.rb#7
  def initialize(service); end

  # source://activestorage//lib/active_storage/downloader.rb#11
  def open(key, checksum: T.unsafe(nil), verify: T.unsafe(nil), name: T.unsafe(nil), tmpdir: T.unsafe(nil)); end

  # Returns the value of attribute service.
  #
  # source://activestorage//lib/active_storage/downloader.rb#5
  def service; end

  private

  # source://activestorage//lib/active_storage/downloader.rb#30
  def download(key, file); end

  # source://activestorage//lib/active_storage/downloader.rb#20
  def open_tempfile(name, tmpdir = T.unsafe(nil)); end

  # source://activestorage//lib/active_storage/downloader.rb#37
  def verify_integrity_of(file, checksum:); end
end

# source://activestorage//lib/active_storage/engine.rb#25
class ActiveStorage::Engine < ::Rails::Engine; end

# Generic base class for all Active Storage exceptions.
#
# source://activestorage//lib/active_storage/errors.rb#5
class ActiveStorage::Error < ::StandardError; end

# Raised when ActiveStorage::Blob#download is called on a blob where the
# backing file is no longer present in its service.
#
# source://activestorage//lib/active_storage/errors.rb#25
class ActiveStorage::FileNotFoundError < ::ActiveStorage::Error; end

module ActiveStorage::FileServer
  private

  def serve_file(path, content_type:, disposition:); end
end

class ActiveStorage::Filename
  include ::Comparable

  def initialize(filename); end

  def <=>(other); end
  def as_json(*_arg0); end
  def base; end
  def extension; end
  def extension_with_delimiter; end
  def extension_without_delimiter; end
  def sanitized; end
  def to_s; end

  class << self
    def wrap(filename); end
  end
end

# = Active Storage \FixtureSet
#
# Fixtures are a way of organizing data that you want to test against; in
# short, sample data.
#
# To learn more about fixtures, read the ActiveRecord::FixtureSet documentation.
#
# === YAML
#
# Like other Active Record-backed models, ActiveStorage::Attachment and
# ActiveStorage::Blob records inherit from ActiveRecord::Base instances and
# therefore can be populated by fixtures.
#
# Consider a hypothetical <tt>Article</tt> model class, its related
# fixture data, as well as fixture data for related ActiveStorage::Attachment
# and ActiveStorage::Blob records:
#
#   # app/models/article.rb
#   class Article < ApplicationRecord
#     has_one_attached :thumbnail
#   end
#
# <code></code>
#
#   # fixtures/active_storage/blobs.yml
#   first_thumbnail_blob: <%= ActiveStorage::FixtureSet.blob filename: "first.png" %>
#
# <code></code>
#
#   # fixtures/active_storage/attachments.yml
#   first_thumbnail_attachment:
#     name: thumbnail
#     record: first (Article)
#     blob: first_thumbnail_blob
#
# When processed, Active Record will insert database records for each fixture
# entry and will ensure the Active Storage relationship is intact.
#
# source://activestorage//lib/active_storage/fixture_set.rb#44
class ActiveStorage::FixtureSet
  include ::ActiveSupport::Testing::FileFixtures
  include ::ActiveRecord::SecureToken
  extend ::ActiveRecord::SecureToken::ClassMethods

  # source://activestorage//lib/active_storage/fixture_set.rb#45
  def file_fixture_path; end

  # source://activestorage//lib/active_storage/fixture_set.rb#45
  def file_fixture_path?; end

  # source://activestorage//lib/active_storage/fixture_set.rb#70
  def prepare(instance, **attributes); end

  class << self
    # Generate a YAML-encoded representation of an ActiveStorage::Blob
    # instance's attributes, resolve the file relative to the directory mentioned
    # by ActiveSupport::Testing::FileFixtures.file_fixture, and upload
    # the file to the Service
    #
    # === Examples
    #
    #   # tests/fixtures/active_storage/blobs.yml
    #   second_thumbnail_blob: <%= ActiveStorage::FixtureSet.blob(
    #     filename: "second.svg",
    #   ) %>
    #
    #   third_thumbnail_blob: <%= ActiveStorage::FixtureSet.blob(
    #     filename: "third.svg",
    #     content_type: "image/svg+xml",
    #     service_name: "public"
    #   ) %>
    #
    # source://activestorage//lib/active_storage/fixture_set.rb#66
    def blob(filename:, **attributes); end

    # source://activestorage//lib/active_storage/fixture_set.rb#45
    def file_fixture_path; end

    # source://activestorage//lib/active_storage/fixture_set.rb#45
    def file_fixture_path=(value); end

    # source://activestorage//lib/active_storage/fixture_set.rb#45
    def file_fixture_path?; end

    private

    # source://activestorage//lib/active_storage/fixture_set.rb#45
    def __class_attr_file_fixture_path; end

    # source://activestorage//lib/active_storage/fixture_set.rb#45
    def __class_attr_file_fixture_path=(new_value); end
  end
end

# Raised when uploaded or downloaded data does not match a precomputed checksum.
# Indicates that a network error or a software bug caused data corruption.
#
# source://activestorage//lib/active_storage/errors.rb#21
class ActiveStorage::IntegrityError < ::ActiveStorage::Error; end

# Raised when ActiveStorage::Blob#variant is called on a blob that isn't variable.
# Use ActiveStorage::Blob#variable? to determine whether a blob is variable.
#
# source://activestorage//lib/active_storage/errors.rb#9
class ActiveStorage::InvariableError < ::ActiveStorage::Error; end

# source://activestorage//lib/active_storage/log_subscriber.rb#6
class ActiveStorage::LogSubscriber < ::ActiveSupport::LogSubscriber
  # source://activestorage//lib/active_storage/log_subscriber.rb#53
  def logger; end

  # source://activestorage//lib/active_storage/log_subscriber.rb#21
  def preview(event); end

  # source://activestorage//lib/active_storage/log_subscriber.rb#26
  def service_delete(event); end

  # source://activestorage//lib/active_storage/log_subscriber.rb#31
  def service_delete_prefixed(event); end

  # source://activestorage//lib/active_storage/log_subscriber.rb#14
  def service_download(event); end

  # source://activestorage//lib/active_storage/log_subscriber.rb#36
  def service_exist(event); end

  # source://activestorage//lib/active_storage/log_subscriber.rb#46
  def service_mirror(event); end

  # source://activestorage//lib/active_storage/log_subscriber.rb#19
  def service_streaming_download(event); end

  # source://activestorage//lib/active_storage/log_subscriber.rb#7
  def service_upload(event); end

  # source://activestorage//lib/active_storage/log_subscriber.rb#41
  def service_url(event); end

  private

  # source://activestorage//lib/active_storage/log_subscriber.rb#62
  def debug(event, colored_message); end

  # source://activestorage//lib/active_storage/log_subscriber.rb#58
  def info(event, colored_message); end

  # source://activestorage//lib/active_storage/log_subscriber.rb#70
  def key_in(event); end

  # source://activestorage//lib/active_storage/log_subscriber.rb#66
  def log_prefix_for_service(event); end

  class << self
    private

    # source://activestorage//lib/active_storage/log_subscriber.rb#12
    def __class_attr_log_levels; end

    # source://activestorage//lib/active_storage/log_subscriber.rb#12
    def __class_attr_log_levels=(new_value); end
  end
end

class ActiveStorage::MirrorJob < ::ActiveStorage::BaseJob
  def perform(key, checksum:); end

  class << self
    private

    def __class_attr_queue_name; end
    def __class_attr_queue_name=(new_value); end
    def __class_attr_rescue_handlers; end
    def __class_attr_rescue_handlers=(new_value); end
  end
end

class ActiveStorage::NamedVariant
  def initialize(transformations); end

  def preprocessed; end
  def preprocessed?(record); end
  def transformations; end
end

# Raised when a Previewer is unable to generate a preview image.
#
# source://activestorage//lib/active_storage/errors.rb#28
class ActiveStorage::PreviewError < ::ActiveStorage::Error; end

class ActiveStorage::PreviewImageJob < ::ActiveStorage::BaseJob
  def perform(blob, variations); end

  class << self
    private

    def __class_attr_queue_name; end
    def __class_attr_queue_name=(new_value); end
    def __class_attr_rescue_handlers; end
    def __class_attr_rescue_handlers=(new_value); end
  end
end

# = Active Storage \Previewer
#
# This is an abstract base class for previewers, which generate images from blobs. See
# ActiveStorage::Previewer::MuPDFPreviewer and ActiveStorage::Previewer::VideoPreviewer for
# examples of concrete subclasses.
#
# source://activestorage//lib/active_storage/previewer.rb#9
class ActiveStorage::Previewer
  # @return [Previewer] a new instance of Previewer
  #
  # source://activestorage//lib/active_storage/previewer.rb#18
  def initialize(blob); end

  # Returns the value of attribute blob.
  #
  # source://activestorage//lib/active_storage/previewer.rb#10
  def blob; end

  # Override this method in a concrete subclass. Have it yield an attachable preview image (i.e.
  # anything accepted by ActiveStorage::Attached::One#attach). Pass the additional options to
  # the underlying blob that is created.
  #
  # @raise [NotImplementedError]
  #
  # source://activestorage//lib/active_storage/previewer.rb#25
  def preview(**options); end

  private

  # source://activestorage//lib/active_storage/previewer.rb#78
  def capture(*argv, to:); end

  # Downloads the blob to a tempfile on disk. Yields the tempfile.
  #
  # source://activestorage//lib/active_storage/previewer.rb#31
  def download_blob_to_tempfile(&block); end

  # Executes a system command, capturing its binary output in a tempfile. Yields the tempfile.
  #
  # Use this method to shell out to a system library (e.g. muPDF or FFmpeg) for preview image
  # generation. The resulting tempfile can be used as the +:io+ value in an attachable Hash:
  #
  #   def preview
  #     download_blob_to_tempfile do |input|
  #       draw "my-drawing-command", input.path, "--format", "png", "-" do |output|
  #         yield io: output, filename: "#{blob.filename.base}.png", content_type: "image/png"
  #       end
  #     end
  #   end
  #
  # The output tempfile is opened in the directory returned by #tmpdir.
  #
  # source://activestorage//lib/active_storage/previewer.rb#49
  def draw(*argv); end

  # source://activestorage//lib/active_storage/previewer.rb#69
  def instrument(operation, payload = T.unsafe(nil), &block); end

  # source://activestorage//lib/active_storage/previewer.rb#93
  def logger; end

  # source://activestorage//lib/active_storage/previewer.rb#59
  def open_tempfile; end

  # source://activestorage//lib/active_storage/previewer.rb#73
  def service_name; end

  # source://activestorage//lib/active_storage/previewer.rb#97
  def tmpdir; end

  class << self
    # Implement this method in a concrete subclass. Have it return true when given a blob from which
    # the previewer can generate an image.
    #
    # @return [Boolean]
    #
    # source://activestorage//lib/active_storage/previewer.rb#14
    def accept?(blob); end
  end
end

# source://activestorage//lib/active_storage/previewer/mupdf_previewer.rb#4
class ActiveStorage::Previewer::MuPDFPreviewer < ::ActiveStorage::Previewer
  # source://activestorage//lib/active_storage/previewer/mupdf_previewer.rb#27
  def preview(**options); end

  private

  # source://activestorage//lib/active_storage/previewer/mupdf_previewer.rb#36
  def draw_first_page_from(file, &block); end

  class << self
    # source://activestorage//lib/active_storage/previewer/mupdf_previewer.rb#6
    def accept?(blob); end

    # source://activestorage//lib/active_storage/previewer/mupdf_previewer.rb#18
    def mutool_exists?; end

    # source://activestorage//lib/active_storage/previewer/mupdf_previewer.rb#14
    def mutool_path; end

    # source://activestorage//lib/active_storage/previewer/mupdf_previewer.rb#10
    def pdf?(content_type); end
  end
end

# source://activestorage//lib/active_storage/previewer/poppler_pdf_previewer.rb#4
class ActiveStorage::Previewer::PopplerPDFPreviewer < ::ActiveStorage::Previewer
  # source://activestorage//lib/active_storage/previewer/poppler_pdf_previewer.rb#25
  def preview(**options); end

  private

  # source://activestorage//lib/active_storage/previewer/poppler_pdf_previewer.rb#34
  def draw_first_page_from(file, &block); end

  class << self
    # source://activestorage//lib/active_storage/previewer/poppler_pdf_previewer.rb#6
    def accept?(blob); end

    # source://activestorage//lib/active_storage/previewer/poppler_pdf_previewer.rb#10
    def pdf?(content_type); end

    # source://activestorage//lib/active_storage/previewer/poppler_pdf_previewer.rb#18
    def pdftoppm_exists?; end

    # source://activestorage//lib/active_storage/previewer/poppler_pdf_previewer.rb#14
    def pdftoppm_path; end
  end
end

# source://activestorage//lib/active_storage/previewer/video_previewer.rb#6
class ActiveStorage::Previewer::VideoPreviewer < ::ActiveStorage::Previewer
  # source://activestorage//lib/active_storage/previewer/video_previewer.rb#23
  def preview(**options); end

  private

  # source://activestorage//lib/active_storage/previewer/video_previewer.rb#32
  def draw_relevant_frame_from(file, &block); end

  class << self
    # source://activestorage//lib/active_storage/previewer/video_previewer.rb#8
    def accept?(blob); end

    # source://activestorage//lib/active_storage/previewer/video_previewer.rb#12
    def ffmpeg_exists?; end

    # source://activestorage//lib/active_storage/previewer/video_previewer.rb#18
    def ffmpeg_path; end
  end
end

class ActiveStorage::PurgeJob < ::ActiveStorage::BaseJob
  def perform(blob); end

  class << self
    private

    def __class_attr_queue_name; end
    def __class_attr_queue_name=(new_value); end
    def __class_attr_rescue_handlers; end
    def __class_attr_rescue_handlers=(new_value); end
  end
end

class ActiveStorage::Record < ::ActiveRecord::Base
  include ::ActiveStorage::Record::GeneratedAttributeMethods
  include ::ActiveStorage::Record::GeneratedAssociationMethods

  class << self
    private

    def __class_attr__validators; end
    def __class_attr__validators=(new_value); end
    def __class_attr_defined_enums; end
    def __class_attr_defined_enums=(new_value); end
  end
end

module ActiveStorage::Record::GeneratedAssociationMethods; end
module ActiveStorage::Record::GeneratedAttributeMethods; end

# source://activestorage//lib/active_storage/reflection.rb#4
module ActiveStorage::Reflection; end

# source://activestorage//lib/active_storage/reflection.rb#49
module ActiveStorage::Reflection::ActiveRecordExtensions
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::ActiveStorage::Reflection::ActiveRecordExtensions::ClassMethods

  module GeneratedClassMethods
    def attachment_reflections; end
    def attachment_reflections=(value); end
    def attachment_reflections?; end
  end

  module GeneratedInstanceMethods
    def attachment_reflections; end
    def attachment_reflections?; end
  end
end

# source://activestorage//lib/active_storage/reflection.rb#56
module ActiveStorage::Reflection::ActiveRecordExtensions::ClassMethods
  # Returns an array of reflection objects for all the attachments in the
  # class.
  #
  # source://activestorage//lib/active_storage/reflection.rb#59
  def reflect_on_all_attachments; end

  # Returns the reflection object for the named +attachment+.
  #
  #    User.reflect_on_attachment(:avatar)
  #    # => the avatar reflection
  #
  # source://activestorage//lib/active_storage/reflection.rb#68
  def reflect_on_attachment(attachment); end
end

# source://activestorage//lib/active_storage/reflection.rb#5
class ActiveStorage::Reflection::HasAttachedReflection < ::ActiveRecord::Reflection::MacroReflection
  # source://activestorage//lib/active_storage/reflection.rb#10
  def named_variants; end

  # source://activestorage//lib/active_storage/reflection.rb#6
  def variant(name, transformations); end
end

# Holds all the metadata about a has_many_attached attachment as it was
# specified in the Active Record class.
#
# source://activestorage//lib/active_storage/reflection.rb#25
class ActiveStorage::Reflection::HasManyAttachedReflection < ::ActiveStorage::Reflection::HasAttachedReflection
  # source://activestorage//lib/active_storage/reflection.rb#26
  def macro; end
end

# Holds all the metadata about a has_one_attached attachment as it was
# specified in the Active Record class.
#
# source://activestorage//lib/active_storage/reflection.rb#17
class ActiveStorage::Reflection::HasOneAttachedReflection < ::ActiveStorage::Reflection::HasAttachedReflection
  # source://activestorage//lib/active_storage/reflection.rb#18
  def macro; end
end

# source://activestorage//lib/active_storage/reflection.rb#31
module ActiveStorage::Reflection::ReflectionExtension
  # source://activestorage//lib/active_storage/reflection.rb#32
  def add_attachment_reflection(model, name, reflection); end

  private

  # source://activestorage//lib/active_storage/reflection.rb#37
  def reflection_class_for(macro); end
end

module ActiveStorage::Representations; end

class ActiveStorage::Representations::BaseController < ::ActiveStorage::BaseController
  include ::ActiveStorage::SetBlob

  private

  def _layout(lookup_context, formats, keys); end
  def blob_scope; end
  def set_representation; end

  class << self
    private

    def __class_attr___callbacks; end
    def __class_attr___callbacks=(new_value); end
    def __class_attr_middleware_stack; end
    def __class_attr_middleware_stack=(new_value); end
  end
end

class ActiveStorage::Representations::ProxyController < ::ActiveStorage::Representations::BaseController
  include ::ActionController::Live
  include ::ActiveStorage::Streaming
  include ::ActiveStorage::DisableSession
  extend ::ActionController::Live::ClassMethods

  def show; end

  private

  def _layout(lookup_context, formats, keys); end

  class << self
    private

    def __class_attr___callbacks; end
    def __class_attr___callbacks=(new_value); end
    def __class_attr_middleware_stack; end
    def __class_attr_middleware_stack=(new_value); end
  end
end

class ActiveStorage::Representations::RedirectController < ::ActiveStorage::Representations::BaseController
  def show; end

  private

  def _layout(lookup_context, formats, keys); end

  class << self
    private

    def __class_attr_middleware_stack; end
    def __class_attr_middleware_stack=(new_value); end
  end
end

# = Active Storage \Service
#
# Abstract class serving as an interface for concrete services.
#
# The available services are:
#
# * +Disk+, to manage attachments saved directly on the hard drive.
# * +GCS+, to manage attachments through Google Cloud Storage.
# * +S3+, to manage attachments through Amazon S3.
# * +AzureStorage+, to manage attachments through Microsoft Azure Storage.
# * +Mirror+, to be able to use several services to manage attachments.
#
# Inside a \Rails application, you can set-up your services through the
# generated <tt>config/storage.yml</tt> file and reference one
# of the aforementioned constant under the +service+ key. For example:
#
#   local:
#     service: Disk
#     root: <%= Rails.root.join("storage") %>
#
# You can checkout the service's constructor to know which keys are required.
#
# Then, in your application's configuration, you can specify the service to
# use like this:
#
#   config.active_storage.service = :local
#
# If you are using Active Storage outside of a Ruby on \Rails application, you
# can configure the service to use like this:
#
#   ActiveStorage::Blob.service = ActiveStorage::Service.configure(
#     :local,
#     { local: {service: "Disk",  root: Pathname("/tmp/foo/storage") } }
#   )
#
# source://activestorage//lib/active_storage/service.rb#43
class ActiveStorage::Service
  extend ::ActiveSupport::Autoload

  # Concatenate multiple files into a single "composed" file.
  #
  # @raise [NotImplementedError]
  #
  # source://activestorage//lib/active_storage/service.rb#96
  def compose(source_keys, destination_key, filename: T.unsafe(nil), content_type: T.unsafe(nil), disposition: T.unsafe(nil), custom_metadata: T.unsafe(nil)); end

  # Delete the file at the +key+.
  #
  # @raise [NotImplementedError]
  #
  # source://activestorage//lib/active_storage/service.rb#101
  def delete(key); end

  # Delete files at keys starting with the +prefix+.
  #
  # @raise [NotImplementedError]
  #
  # source://activestorage//lib/active_storage/service.rb#106
  def delete_prefixed(prefix); end

  # Return the content of the file at the +key+.
  #
  # @raise [NotImplementedError]
  #
  # source://activestorage//lib/active_storage/service.rb#82
  def download(key); end

  # Return the partial content in the byte +range+ of the file at the +key+.
  #
  # @raise [NotImplementedError]
  #
  # source://activestorage//lib/active_storage/service.rb#87
  def download_chunk(key, range); end

  # Return +true+ if a file exists at the +key+.
  #
  # @raise [NotImplementedError]
  # @return [Boolean]
  #
  # source://activestorage//lib/active_storage/service.rb#111
  def exist?(key); end

  # Returns a Hash of headers for +url_for_direct_upload+ requests.
  #
  # source://activestorage//lib/active_storage/service.rb#143
  def headers_for_direct_upload(key, filename:, content_type:, content_length:, checksum:, custom_metadata: T.unsafe(nil)); end

  # Returns the value of attribute name.
  #
  # source://activestorage//lib/active_storage/service.rb#46
  def name; end

  # Sets the attribute name
  #
  # @param value the value to set the attribute name to.
  #
  # source://activestorage//lib/active_storage/service.rb#46
  def name=(_arg0); end

  # source://activestorage//lib/active_storage/service.rb#91
  def open(*args, **options, &block); end

  # @return [Boolean]
  #
  # source://activestorage//lib/active_storage/service.rb#147
  def public?; end

  # Update metadata for the file identified by +key+ in the service.
  # Override in subclasses only if the service needs to store specific
  # metadata that has to be updated upon identification.
  #
  # source://activestorage//lib/active_storage/service.rb#78
  def update_metadata(key, **metadata); end

  # Upload the +io+ to the +key+ specified. If a +checksum+ is provided, the service will
  # ensure a match when the upload has completed or raise an ActiveStorage::IntegrityError.
  #
  # @raise [NotImplementedError]
  #
  # source://activestorage//lib/active_storage/service.rb#71
  def upload(key, io, checksum: T.unsafe(nil), **options); end

  # Returns the URL for the file at the +key+. This returns a permanent URL for public files, and returns a
  # short-lived URL for private files. For private files you can provide the +disposition+ (+:inline+ or +:attachment+),
  # +filename+, and +content_type+ that you wish the file to be served with on request. Additionally, you can also provide
  # the amount of seconds the URL will be valid for, specified in +expires_in+.
  #
  # source://activestorage//lib/active_storage/service.rb#119
  def url(key, **options); end

  # Returns a signed, temporary URL that a direct upload file can be PUT to on the +key+.
  # The URL will be valid for the amount of seconds specified in +expires_in+.
  # You must also provide the +content_type+, +content_length+, and +checksum+ of the file
  # that will be uploaded. All these attributes will be validated by the service upon upload.
  #
  # @raise [NotImplementedError]
  #
  # source://activestorage//lib/active_storage/service.rb#138
  def url_for_direct_upload(key, expires_in:, content_type:, content_length:, checksum:, custom_metadata: T.unsafe(nil)); end

  private

  # source://activestorage//lib/active_storage/service.rb#175
  def content_disposition_with(filename:, type: T.unsafe(nil)); end

  # @raise [NotImplementedError]
  #
  # source://activestorage//lib/active_storage/service.rb#160
  def custom_metadata_headers(metadata); end

  # source://activestorage//lib/active_storage/service.rb#164
  def instrument(operation, payload = T.unsafe(nil), &block); end

  # @raise [NotImplementedError]
  #
  # source://activestorage//lib/active_storage/service.rb#152
  def private_url(key, expires_in:, filename:, disposition:, content_type:, **_arg5); end

  # @raise [NotImplementedError]
  #
  # source://activestorage//lib/active_storage/service.rb#156
  def public_url(key, **_arg1); end

  # source://activestorage//lib/active_storage/service.rb#170
  def service_name; end

  class << self
    # Override in subclasses that stitch together multiple services and hence
    # need to build additional services using the configurator.
    #
    # Passes the configurator and all of the service's config as keyword args.
    #
    # See MirrorService for an example.
    #
    # source://activestorage//lib/active_storage/service.rb#62
    def build(configurator:, name:, service: T.unsafe(nil), **service_config); end

    # Configure an Active Storage service by name from a set of configurations,
    # typically loaded from a YAML file. The Active Storage engine uses this
    # to set the global Active Storage service when the app boots.
    #
    # source://activestorage//lib/active_storage/service.rb#52
    def configure(service_name, configurations); end
  end
end

# source://activestorage//lib/active_storage/service/configurator.rb#4
class ActiveStorage::Service::Configurator
  # source://activestorage//lib/active_storage/service/configurator.rb#11
  def initialize(configurations); end

  # source://activestorage//lib/active_storage/service/configurator.rb#15
  def build(service_name); end

  # source://activestorage//lib/active_storage/service/configurator.rb#5
  def configurations; end

  private

  # source://activestorage//lib/active_storage/service/configurator.rb#23
  def config_for(name); end

  # source://activestorage//lib/active_storage/service/configurator.rb#29
  def resolve(class_name); end

  class << self
    # source://activestorage//lib/active_storage/service/configurator.rb#7
    def build(service_name, configurations); end
  end
end

# source://activestorage//lib/active_storage/service/registry.rb#4
class ActiveStorage::Service::Registry
  # source://activestorage//lib/active_storage/service/registry.rb#5
  def initialize(configurations); end

  # source://activestorage//lib/active_storage/service/registry.rb#10
  def fetch(name); end

  private

  # source://activestorage//lib/active_storage/service/registry.rb#26
  def configurations; end

  # source://activestorage//lib/active_storage/service/registry.rb#28
  def configurator; end

  # source://activestorage//lib/active_storage/service/registry.rb#26
  def services; end
end

module ActiveStorage::SetBlob
  extend ::ActiveSupport::Concern

  private

  def blob_scope; end
  def set_blob; end
end

module ActiveStorage::SetCurrent
  extend ::ActiveSupport::Concern
end

module ActiveStorage::Streaming
  extend ::ActiveSupport::Concern
  include ::ActionController::Rendering
  include ::ActionController::DataStreaming
  include ::ActionController::Live

  mixes_in_class_methods ::ActionController::Rendering::ClassMethods
  mixes_in_class_methods ::ActionController::Live::ClassMethods

  private

  def send_blob_byte_range_data(blob, range_header, disposition: T.unsafe(nil)); end
  def send_blob_stream(blob, disposition: T.unsafe(nil)); end
end

ActiveStorage::Streaming::DEFAULT_BLOB_STREAMING_DISPOSITION = T.let(T.unsafe(nil), String)

class ActiveStorage::TransformJob < ::ActiveStorage::BaseJob
  def perform(blob, transformations); end

  class << self
    private

    def __class_attr_queue_name; end
    def __class_attr_queue_name=(new_value); end
    def __class_attr_rescue_handlers; end
    def __class_attr_rescue_handlers=(new_value); end
  end
end

# source://activestorage//lib/active_storage.rb#368
module ActiveStorage::Transformers
  extend ::ActiveSupport::Autoload
end

# = Active Storage \Transformers \Transformer
#
# A Transformer applies a set of transformations to an image.
#
# The following concrete subclasses are included in Active Storage:
#
# * ActiveStorage::Transformers::ImageProcessingTransformer:
#   backed by ImageProcessing, a common interface for MiniMagick and ruby-vips
#
# source://activestorage//lib/active_storage/transformers/transformer.rb#13
class ActiveStorage::Transformers::Transformer
  # @return [Transformer] a new instance of Transformer
  #
  # source://activestorage//lib/active_storage/transformers/transformer.rb#16
  def initialize(transformations); end

  # Applies the transformations to the source image in +file+, producing a target image in the
  # specified +format+. Yields an open Tempfile containing the target image. Closes and unlinks
  # the output tempfile after yielding to the given block. Returns the result of the block.
  #
  # source://activestorage//lib/active_storage/transformers/transformer.rb#23
  def transform(file, format:); end

  # Returns the value of attribute transformations.
  #
  # source://activestorage//lib/active_storage/transformers/transformer.rb#14
  def transformations; end

  private

  # Returns an open Tempfile containing a transformed image in the given +format+.
  # All subclasses implement this method.
  #
  # @raise [NotImplementedError]
  #
  # source://activestorage//lib/active_storage/transformers/transformer.rb#36
  def process(file, format:); end
end

# Raised when ActiveStorage::Blob#preview is called on a blob that isn't previewable.
# Use ActiveStorage::Blob#previewable? to determine whether a blob is previewable.
#
# source://activestorage//lib/active_storage/errors.rb#13
class ActiveStorage::UnpreviewableError < ::ActiveStorage::Error; end

# Raised when ActiveStorage::Blob#representation is called on a blob that isn't representable.
# Use ActiveStorage::Blob#representable? to determine whether a blob is representable.
#
# source://activestorage//lib/active_storage/errors.rb#17
class ActiveStorage::UnrepresentableError < ::ActiveStorage::Error; end

# source://activestorage//lib/active_storage/gem_version.rb#9
module ActiveStorage::VERSION; end

# source://activestorage//lib/active_storage/gem_version.rb#10
ActiveStorage::VERSION::MAJOR = T.let(T.unsafe(nil), Integer)

# source://activestorage//lib/active_storage/gem_version.rb#11
ActiveStorage::VERSION::MINOR = T.let(T.unsafe(nil), Integer)

# source://activestorage//lib/active_storage/gem_version.rb#13
ActiveStorage::VERSION::PRE = T.let(T.unsafe(nil), T.untyped)

# source://activestorage//lib/active_storage/gem_version.rb#15
ActiveStorage::VERSION::STRING = T.let(T.unsafe(nil), String)

# source://activestorage//lib/active_storage/gem_version.rb#12
ActiveStorage::VERSION::TINY = T.let(T.unsafe(nil), Integer)

class ActiveStorage::VariantRecord < ::ActiveStorage::Record
  include ::ActiveStorage::VariantRecord::GeneratedAttributeMethods
  include ::ActiveStorage::VariantRecord::GeneratedAssociationMethods

  def autosave_associated_records_for_blob(*args); end
  def autosave_associated_records_for_image_attachment(*args); end
  def autosave_associated_records_for_image_blob(*args); end

  class << self
    def with_attached_image(*args, **_arg1); end

    private

    def __class_attr___callbacks; end
    def __class_attr___callbacks=(new_value); end
    def __class_attr__reflections; end
    def __class_attr__reflections=(new_value); end
    def __class_attr__validators; end
    def __class_attr__validators=(new_value); end
    def __class_attr_attachment_reflections; end
    def __class_attr_attachment_reflections=(new_value); end
    def __class_attr_defined_enums; end
    def __class_attr_defined_enums=(new_value); end
  end
end

module ActiveStorage::VariantRecord::GeneratedAssociationMethods
  def blob; end
  def blob=(value); end
  def blob_changed?; end
  def blob_previously_changed?; end
  def build_blob(*args, &block); end
  def build_image_attachment(*args, &block); end
  def build_image_blob(*args, &block); end
  def create_blob(*args, &block); end
  def create_blob!(*args, &block); end
  def create_image_attachment(*args, &block); end
  def create_image_attachment!(*args, &block); end
  def create_image_blob(*args, &block); end
  def create_image_blob!(*args, &block); end
  def image; end
  def image=(attachable); end
  def image_attachment; end
  def image_attachment=(value); end
  def image_blob; end
  def image_blob=(value); end
  def reload_blob; end
  def reload_image_attachment; end
  def reload_image_blob; end
  def reset_blob; end
  def reset_image_attachment; end
  def reset_image_blob; end
end

module ActiveStorage::VariantRecord::GeneratedAttributeMethods; end

class ActiveStorage::Variation
  def initialize(transformations); end

  def content_type; end
  def default_to(defaults); end
  def digest; end
  def format; end
  def key; end
  def transform(file, &block); end
  def transformations; end

  private

  def transformer; end

  class << self
    def decode(key); end
    def encode(transformations); end
    def wrap(variator); end
  end
end
