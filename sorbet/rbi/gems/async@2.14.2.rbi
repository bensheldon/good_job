# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `async` gem.
# Please instead update this file by running `bin/tapioca gem async`.


# Asynchronous programming framework.
#
# source://async//lib/async/version.rb#6
module Async; end

# A general purpose synchronisation primitive, which allows one task to wait for a number of other tasks to complete. It can be used in conjunction with {Semaphore}.
#
# source://async//lib/async/barrier.rb#13
class Async::Barrier
  # Initialize the barrier.
  #
  # @return [Barrier] a new instance of Barrier
  #
  # source://async//lib/async/barrier.rb#17
  def initialize(parent: T.unsafe(nil)); end

  # Execute a child task and add it to the barrier.
  #
  # source://async//lib/async/barrier.rb#43
  def async(*arguments, parent: T.unsafe(nil), **options, &block); end

  # Whether there are any tasks being held by the barrier.
  #
  # @return [Boolean]
  #
  # source://async//lib/async/barrier.rb#53
  def empty?; end

  # Number of tasks being held by the barrier.
  #
  # source://async//lib/async/barrier.rb#34
  def size; end

  # Stop all tasks held by the barrier.
  #
  # source://async//lib/async/barrier.rb#72
  def stop; end

  # All tasks which have been invoked into the barrier.
  #
  # source://async//lib/async/barrier.rb#39
  def tasks; end

  # Wait for all tasks to complete by invoking {Task#wait} on each waiting task, which may raise an error. As long as the task has completed, it will be removed from the barrier.
  #
  # source://async//lib/async/barrier.rb#59
  def wait; end
end

# source://async//lib/async/barrier.rb#23
class Async::Barrier::TaskNode < ::Async::List::Node
  # @return [TaskNode] a new instance of TaskNode
  #
  # source://async//lib/async/barrier.rb#24
  def initialize(task); end

  # Returns the value of attribute task.
  #
  # source://async//lib/async/barrier.rb#28
  def task; end
end

# A list of children tasks.
#
# source://async//lib/async/node.rb#14
class Async::Children < ::Async::List
  # Create an empty list of children tasks.
  #
  # @return [Children] a new instance of Children
  #
  # source://async//lib/async/node.rb#16
  def initialize; end

  # Whether all children are considered finished. Ignores transient children.
  #
  # @return [Boolean]
  #
  # source://async//lib/async/node.rb#28
  def finished?; end

  # Whether the children is empty, preserved for compatibility.
  #
  # @return [Boolean]
  #
  # source://async//lib/async/node.rb#33
  def nil?; end

  # Some children may be marked as transient. Transient children do not prevent the parent from finishing.
  #
  # @return [Boolean]
  #
  # source://async//lib/async/node.rb#23
  def transients?; end

  private

  # source://async//lib/async/node.rb#39
  def added(node); end

  # source://async//lib/async/node.rb#47
  def removed(node); end
end

# A convenient wrapper around the internal monotonic clock.
#
# source://async//lib/async/clock.rb#9
class Async::Clock
  # Create a new clock with the initial total time.
  #
  # @return [Clock] a new instance of Clock
  #
  # source://async//lib/async/clock.rb#34
  def initialize(total = T.unsafe(nil)); end

  # Start measuring a duration.
  #
  # source://async//lib/async/clock.rb#40
  def start!; end

  # Stop measuring a duration and append the duration to the current total.
  #
  # source://async//lib/async/clock.rb#45
  def stop!; end

  # The total elapsed time including any current duration.
  #
  # source://async//lib/async/clock.rb#55
  def total; end

  class << self
    # Measure the execution of a block of code.
    #
    # source://async//lib/async/clock.rb#18
    def measure; end

    # Get the current elapsed monotonic time.
    #
    # source://async//lib/async/clock.rb#11
    def now; end

    # Start measuring elapsed time from now.
    #
    # source://async//lib/async/clock.rb#28
    def start; end
  end
end

# A synchronization primitive, which allows fibers to wait until a particular condition is (edge) triggered.
#
# source://async//lib/async/condition.rb#13
class Async::Condition
  # Create a new condition.
  #
  # @return [Condition] a new instance of Condition
  #
  # source://async//lib/async/condition.rb#15
  def initialize; end

  # @deprecated Replaced by {#waiting?}
  # @return [Boolean]
  #
  # source://async//lib/async/condition.rb#44
  def empty?; end

  # Signal to a given task that it should resume operations.
  #
  # source://async//lib/async/condition.rb#55
  def signal(value = T.unsafe(nil)); end

  # Queue up the current fiber and wait on yielding the task.
  #
  # source://async//lib/async/condition.rb#37
  def wait; end

  # @return [Boolean]
  #
  # source://async//lib/async/condition.rb#49
  def waiting?; end

  protected

  # source://async//lib/async/condition.rb#69
  def exchange; end
end

# source://async//lib/async/condition.rb#19
class Async::Condition::FiberNode < ::Async::List::Node
  # @return [FiberNode] a new instance of FiberNode
  #
  # source://async//lib/async/condition.rb#20
  def initialize(fiber); end

  # @return [Boolean]
  #
  # source://async//lib/async/condition.rb#28
  def alive?; end

  # source://async//lib/async/condition.rb#24
  def transfer(*arguments); end
end

# A queue which limits the number of items that can be enqueued.
#
# source://async//lib/async/queue.rb#97
class Async::LimitedQueue < ::Async::Queue
  # Create a new limited queue.
  #
  # @return [LimitedQueue] a new instance of LimitedQueue
  #
  # source://async//lib/async/queue.rb#102
  def initialize(limit = T.unsafe(nil), full: T.unsafe(nil), **options); end

  # Add an item to the queue.
  #
  # If the queue is full, this method will block until there is space available.
  #
  # source://async//lib/async/queue.rb#122
  def <<(item); end

  # Remove and return the next item from the queue.
  #
  # If the queue is empty, this method will block until an item is available.
  #
  # source://async//lib/async/queue.rb#153
  def dequeue; end

  # Add multiple items to the queue.
  #
  # If the queue is full, this method will block until there is space available.
  #
  # source://async//lib/async/queue.rb#135
  def enqueue(*items); end

  # Returns the value of attribute limit.
  #
  # source://async//lib/async/queue.rb#110
  def limit; end

  # @return [Boolean]
  #
  # source://async//lib/async/queue.rb#113
  def limited?; end
end

# A general doublely linked list. This is used internally by {Async::Barrier} and {Async::Condition} to manage child tasks.
#
# source://async//lib/async/list.rb#8
class Async::List
  # Initialize a new, empty, list.
  #
  # @return [List] a new instance of List
  #
  # source://async//lib/async/list.rb#10
  def initialize; end

  # A callback that is invoked when an item is added to the list.
  #
  # source://async//lib/async/list.rb#49
  def added(node); end

  # Append a node to the end of the list.
  #
  # source://async//lib/async/list.rb#55
  def append(node); end

  # Iterate over each node in the linked list. It is generally safe to remove the current node, any previous node or any future node during iteration.
  #
  # source://async//lib/async/list.rb#175
  def each(&block); end

  # @return [Boolean]
  #
  # source://async//lib/async/list.rb#138
  def empty?; end

  # source://async//lib/async/list.rb#196
  def first; end

  # Returns the value of attribute head.
  #
  # source://async//lib/async/list.rb#40
  def head; end

  # Sets the attribute head
  #
  # @param value the value to set the attribute head to.
  #
  # source://async//lib/async/list.rb#40
  def head=(_arg0); end

  # Determine whether the given node is included in the list.
  #
  # @return [Boolean]
  #
  # source://async//lib/async/list.rb#187
  def include?(needle); end

  # source://async//lib/async/list.rb#17
  def inspect; end

  # source://async//lib/async/list.rb#213
  def last; end

  # Prepend a node to the start of the list.
  #
  # source://async//lib/async/list.rb#69
  def prepend(node); end

  # Remove the node. If it was already removed, this will raise an error.
  #
  # You should be careful to only remove nodes that are part of this list.
  #
  # source://async//lib/async/list.rb#117
  def remove(node); end

  # Remove the node if it is in a list.
  #
  # You should be careful to only remove nodes that are part of this list.
  #
  # @return [Boolean]
  #
  # source://async//lib/async/list.rb#103
  def remove?(node); end

  # A callback that is invoked when an item is removed from the list.
  #
  # source://async//lib/async/list.rb#93
  def removed(node); end

  # Shift the first node off the list, if it is not empty.
  #
  # source://async//lib/async/list.rb#230
  def shift; end

  # Returns the value of attribute size.
  #
  # source://async//lib/async/list.rb#46
  def size; end

  # Add the node, yield, and the remove the node.
  #
  # source://async//lib/async/list.rb#85
  def stack(node, &block); end

  # Returns the value of attribute tail.
  #
  # source://async//lib/async/list.rb#43
  def tail; end

  # Sets the attribute tail
  #
  # @param value the value to set the attribute tail to.
  #
  # source://async//lib/async/list.rb#43
  def tail=(_arg0); end

  # Fast, safe, unbounded accumulation of children.
  #
  # source://async//lib/async/list.rb#24
  def to_a; end

  # source://async//lib/async/list.rb#17
  def to_s; end

  private

  # source://async//lib/async/list.rb#126
  def remove!(node); end
end

# source://async//lib/async/list.rb#244
class Async::List::Iterator < ::Async::List::Node
  # @return [Iterator] a new instance of Iterator
  #
  # source://async//lib/async/list.rb#245
  def initialize(list); end

  # source://async//lib/async/list.rb#288
  def each; end

  # source://async//lib/async/list.rb#273
  def move_current; end

  # source://async//lib/async/list.rb#263
  def move_next; end

  # source://async//lib/async/list.rb#255
  def remove!; end

  class << self
    # source://async//lib/async/list.rb#298
    def each(list, &block); end
  end
end

# A linked list Node.
#
# source://async//lib/async/list.rb#237
class Async::List::Node
  # Returns the value of attribute head.
  #
  # source://async//lib/async/list.rb#238
  def head; end

  # Sets the attribute head
  #
  # @param value the value to set the attribute head to.
  #
  # source://async//lib/async/list.rb#238
  def head=(_arg0); end

  def inspect; end

  # Returns the value of attribute tail.
  #
  # source://async//lib/async/list.rb#239
  def tail; end

  # Sets the attribute tail
  #
  # @param value the value to set the attribute tail to.
  #
  # source://async//lib/async/list.rb#239
  def tail=(_arg0); end
end

# A node in a tree, used for implementing the task hierarchy.
#
# source://async//lib/async/node.rb#57
class Async::Node
  # Create a new node in the tree.
  #
  # @return [Node] a new instance of Node
  #
  # source://async//lib/async/node.rb#60
  def initialize(parent = T.unsafe(nil), annotation: T.unsafe(nil), transient: T.unsafe(nil)); end

  # Annotate the node with a description.
  #
  # source://async//lib/async/node.rb#116
  def annotate(annotation); end

  # Returns the value of attribute annotation.
  #
  # source://async//lib/async/node.rb#95
  def annotation; end

  # Provides a backtrace for nodes that have an active execution context.
  #
  # source://async//lib/async/node.rb#148
  def backtrace(*arguments); end

  # Returns the value of attribute children.
  #
  # source://async//lib/async/node.rb#92
  def children; end

  # Whether this node has any children.
  #
  # @return [Boolean]
  #
  # source://async//lib/async/node.rb#99
  def children?; end

  # If the node has a parent, and is {finished?}, then remove this node from
  # the parent.
  #
  # source://async//lib/async/node.rb#202
  def consume; end

  # A description of the node, including the annotation and object name.
  #
  # source://async//lib/async/node.rb#133
  def description; end

  # Whether the node can be consumed (deleted) safely. By default, checks if the children set is empty.
  #
  # @return [Boolean]
  #
  # source://async//lib/async/node.rb#196
  def finished?; end

  # @private
  #
  # source://async//lib/async/node.rb#83
  def head; end

  # @private
  #
  # source://async//lib/async/node.rb#83
  def head=(_arg0); end

  # source://async//lib/async/node.rb#153
  def inspect; end

  # Returns the value of attribute parent.
  #
  # source://async//lib/async/node.rb#89
  def parent; end

  # Change the parent of this node.
  #
  # source://async//lib/async/node.rb#163
  def parent=(parent); end

  # Print the hierarchy of the task tree from the given node.
  #
  # source://async//lib/async/node.rb#278
  def print_hierarchy(out = T.unsafe(nil), backtrace: T.unsafe(nil)); end

  # source://async//lib/async/node.rb#78
  def root; end

  # Attempt to stop the current node immediately, including all non-transient children. Invokes {#stop_children} to stop all children.
  #
  # source://async//lib/async/node.rb#257
  def stop(later = T.unsafe(nil)); end

  # Whether the node has been stopped.
  #
  # @return [Boolean]
  #
  # source://async//lib/async/node.rb#270
  def stopped?; end

  # @private
  #
  # source://async//lib/async/node.rb#86
  def tail; end

  # @private
  #
  # source://async//lib/async/node.rb#86
  def tail=(_arg0); end

  # Immediately terminate all children tasks, including transient tasks. Internally invokes `stop(false)` on all children. This should be considered a last ditch effort and is used when closing the scheduler.
  #
  # source://async//lib/async/node.rb#242
  def terminate; end

  # source://async//lib/async/node.rb#153
  def to_s; end

  # Represents whether a node is transient. Transient nodes are not considered
  # when determining if a node is finished. This is useful for tasks which are
  # internal to an object rather than explicit user concurrency. For example,
  # a child task which is pruning a connection pool is transient, because it
  # is not directly related to the parent task, and should not prevent the
  # parent task from finishing.
  #
  # @return [Boolean]
  #
  # source://async//lib/async/node.rb#109
  def transient?; end

  # Traverse the task tree.
  #
  # source://async//lib/async/node.rb#227
  def traverse(&block); end

  protected

  # source://async//lib/async/node.rb#182
  def add_child(child); end

  # source://async//lib/async/node.rb#188
  def remove_child(child); end

  # source://async//lib/async/node.rb#178
  def set_parent(parent); end

  # @yield [_self, level]
  # @yieldparam _self [Async::Node] the object that the method was called on
  #
  # source://async//lib/async/node.rb#233
  def traverse_recurse(level = T.unsafe(nil), &block); end

  private

  # source://async//lib/async/node.rb#290
  def print_backtrace(out, indent, node); end

  # Attempt to stop all non-transient children.
  #
  # source://async//lib/async/node.rb#263
  def stop_children(later = T.unsafe(nil)); end
end

# A synchronization primitive, which allows fibers to wait until a notification is received. Does not block the task which signals the notification. Waiting tasks are resumed on next iteration of the reactor.
#
# source://async//lib/async/notification.rb#11
class Async::Notification < ::Async::Condition
  # Signal to a given task that it should resume operations.
  #
  # source://async//lib/async/notification.rb#13
  def signal(value = T.unsafe(nil), task: T.unsafe(nil)); end
end

# source://async//lib/async/notification.rb#21
class Async::Notification::Signal < ::Struct
  # @return [Boolean]
  #
  # source://async//lib/async/notification.rb#22
  def alive?; end

  # source://async//lib/async/notification.rb#26
  def transfer; end

  # Returns the value of attribute value
  #
  # @return [Object] the current value of value
  def value; end

  # Sets the attribute value
  #
  # @param value [Object] the value to set the attribute value to.
  # @return [Object] the newly set value
  def value=(_); end

  # Returns the value of attribute waiting
  #
  # @return [Object] the current value of waiting
  def waiting; end

  # Sets the attribute waiting
  #
  # @param value [Object] the value to set the attribute waiting to.
  # @return [Object] the newly set value
  def waiting=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# A queue which allows items to be processed in order.
#
# It has a compatible interface with {Notification} and {Condition}, except that it's multi-value.
#
# source://async//lib/async/queue.rb#16
class Async::Queue
  # Create a new queue.
  #
  # @return [Queue] a new instance of Queue
  #
  # source://async//lib/async/queue.rb#21
  def initialize(parent: T.unsafe(nil), available: T.unsafe(nil)); end

  # Add an item to the queue.
  #
  # source://async//lib/async/queue.rb#41
  def <<(item); end

  # Process each item in the queue.
  #
  # source://async//lib/async/queue.rb#71
  def async(parent: T.unsafe(nil), **options, &block); end

  # Remove and return the next item from the queue.
  #
  # source://async//lib/async/queue.rb#55
  def dequeue; end

  # Enumerate each item in the queue.
  #
  # source://async//lib/async/queue.rb#78
  def each; end

  # @return [Boolean]
  #
  # source://async//lib/async/queue.rb#36
  def empty?; end

  # Add multiple items to the queue.
  #
  # source://async//lib/async/queue.rb#48
  def enqueue(*items); end

  # Returns the value of attribute items.
  #
  # source://async//lib/async/queue.rb#28
  def items; end

  # Signal the queue with a value, the same as {#enqueue}.
  #
  # source://async//lib/async/queue.rb#85
  def signal(value); end

  # source://async//lib/async/queue.rb#31
  def size; end

  # Wait for an item to be available, the same as {#dequeue}.
  #
  # source://async//lib/async/queue.rb#90
  def wait; end
end

# A wrapper around the the scheduler which binds it to the current thread automatically.
#
# source://async//lib/async/reactor.rb#12
class Async::Reactor < ::Async::Scheduler
  # Initialize the reactor and assign it to the current Fiber scheduler.
  #
  # @return [Reactor] a new instance of Reactor
  #
  # source://async//lib/async/reactor.rb#19
  def initialize(*_arg0, **_arg1, &_arg2); end

  # Close the reactor and remove it from the current Fiber scheduler.
  #
  # source://async//lib/async/reactor.rb#26
  def scheduler_close; end

  def sleep(*_arg0); end

  class << self
    # @deprecated Replaced by {Kernel::Async}.
    #
    # source://async//lib/async/reactor.rb#14
    def run(*_arg0, **_arg1, &_arg2); end
  end
end

# Handles scheduling of fibers. Implements the fiber scheduler interface.
#
# source://async//lib/async/scheduler.rb#18
class Async::Scheduler < ::Async::Node
  # Create a new scheduler.
  #
  # @return [Scheduler] a new instance of Scheduler
  #
  # source://async//lib/async/scheduler.rb#40
  def initialize(parent = T.unsafe(nil), selector: T.unsafe(nil)); end

  # source://async//lib/async/scheduler.rb#215
  def address_resolve(hostname); end

  # Start an asynchronous task within the specified reactor. The task will be
  # executed until the first blocking call, at which point it will yield and
  # and this method will return.
  #
  # This is the main entry point for scheduling asynchronus tasks.
  #
  # @deprecated With no replacement.
  #
  # source://async//lib/async/scheduler.rb#411
  def async(*arguments, **options, &block); end

  # Invoked when a fiber tries to perform a blocking operation which cannot continue. A corresponding call {unblock} must be performed to allow this fiber to continue.
  #
  # source://async//lib/async/scheduler.rb#172
  def block(blocker, timeout); end

  # Terminate all child tasks and close the scheduler.
  #
  # source://async//lib/async/scheduler.rb#96
  def close; end

  # @return [Boolean]
  #
  # source://async//lib/async/scheduler.rb#120
  def closed?; end

  # source://async//lib/async/scheduler.rb#429
  def fiber(*_arg0, **_arg1, &_arg2); end

  # Interrupt the event loop and cause it to exit.
  #
  # source://async//lib/async/scheduler.rb#131
  def interrupt; end

  # source://async//lib/async/scheduler.rb#255
  def io_read(io, buffer, length, offset = T.unsafe(nil)); end

  # source://async//lib/async/scheduler.rb#234
  def io_wait(io, events, timeout = T.unsafe(nil)); end

  # source://async//lib/async/scheduler.rb#270
  def io_write(io, buffer, length, offset = T.unsafe(nil)); end

  # source://async//lib/async/scheduler.rb#206
  def kernel_sleep(duration = T.unsafe(nil)); end

  # Compute the scheduler load according to the busy and idle times that are updated by the run loop.
  #
  # source://async//lib/async/scheduler.rb#56
  def load; end

  # Wait for the specified process ID to exit.
  #
  # source://async//lib/async/scheduler.rb#291
  def process_wait(pid, flags); end

  # Schedule a fiber (or equivalent object) to be resumed on the next loop through the reactor.
  #
  # source://async//lib/async/scheduler.rb#148
  def push(fiber); end

  # Raise an exception on a specified fiber with the given arguments.
  #
  # This internally schedules the current fiber to be ready, before raising the exception, so that it will later resume execution.
  #
  # source://async//lib/async/scheduler.rb#158
  def raise(*_arg0, **_arg1, &_arg2); end

  # Resume execution of the specified fiber.
  #
  # source://async//lib/async/scheduler.rb#166
  def resume(fiber, *arguments); end

  # Run the reactor until all tasks are finished. Proxies arguments to {#async} immediately before entering the loop, if a block is provided.
  #
  # source://async//lib/async/scheduler.rb#369
  def run(*_arg0, **_arg1, &_arg2); end

  # Run one iteration of the event loop.
  # Does not handle interrupts.
  #
  # source://async//lib/async/scheduler.rb#299
  def run_once(timeout = T.unsafe(nil)); end

  # Invoked when the fiber scheduler is being closed.
  #
  # Executes the run loop until all tasks are finished, then closes the scheduler.
  #
  # source://async//lib/async/scheduler.rb#78
  def scheduler_close; end

  # Terminate the scheduler. We deliberately ignore interrupts here, as this code can be called from an interrupt, and we don't want to be interrupted while cleaning up.
  #
  # source://async//lib/async/scheduler.rb#88
  def terminate; end

  # source://async//lib/async/scheduler.rb#449
  def timeout_after(duration, exception, message, &block); end

  # source://async//lib/async/scheduler.rb#125
  def to_s; end

  # Transfer from the calling fiber to the event loop.
  #
  # source://async//lib/async/scheduler.rb#137
  def transfer; end

  # source://async//lib/async/scheduler.rb#195
  def unblock(blocker, fiber); end

  # Invoke the block, but after the specified timeout, raise {TimeoutError} in any currenly blocking operation. If the block runs to completion before the timeout occurs or there are no non-blocking operations after the timeout expires, the code will complete without any exception.
  #
  # source://async//lib/async/scheduler.rb#435
  def with_timeout(duration, exception = T.unsafe(nil), message = T.unsafe(nil), &block); end

  # Yield the current fiber and resume it on the next iteration of the event loop.
  #
  # source://async//lib/async/scheduler.rb#142
  def yield; end

  private

  # source://async//lib/async/scheduler.rb#224
  def get_timeout(io); end

  # Checks and clears the interrupted state of the scheduler.
  #
  # @return [Boolean]
  #
  # source://async//lib/async/scheduler.rb#355
  def interrupted?; end

  # Run one iteration of the event loop.
  #
  # When terminating the event loop, we already know we are finished. So we don't need to check the task tree. This is a logical requirement because `run_once` ignores transient tasks. For example, a single top level transient task is not enough to keep the reactor running, but during termination we must still process it in order to terminate child tasks.
  #
  # source://async//lib/async/scheduler.rb#316
  def run_once!(timeout = T.unsafe(nil)); end

  class << self
    # Whether the fiber scheduler is supported.
    #
    # @return [Boolean]
    #
    # source://async//lib/async/scheduler.rb#31
    def supported?; end
  end
end

# Raised when an operation is attempted on a closed scheduler.
#
# source://async//lib/async/scheduler.rb#20
class Async::Scheduler::ClosedError < ::RuntimeError
  # Create a new error.
  #
  # @return [ClosedError] a new instance of ClosedError
  #
  # source://async//lib/async/scheduler.rb#24
  def initialize(message = T.unsafe(nil)); end
end

# A synchronization primitive, which limits access to a given resource.
#
# source://async//lib/async/semaphore.rb#11
class Async::Semaphore
  # @return [Semaphore] a new instance of Semaphore
  #
  # source://async//lib/async/semaphore.rb#14
  def initialize(limit = T.unsafe(nil), parent: T.unsafe(nil)); end

  # Acquire the semaphore, block if we are at the limit.
  # If no block is provided, you must call release manually.
  #
  # source://async//lib/async/semaphore.rb#79
  def acquire; end

  # Run an async task. Will wait until the semaphore is ready until spawning and running the task.
  #
  # source://async//lib/async/semaphore.rb#61
  def async(*arguments, parent: T.unsafe(nil), **options); end

  # Whether trying to acquire this semaphore would block.
  #
  # @return [Boolean]
  #
  # source://async//lib/async/semaphore.rb#56
  def blocking?; end

  # The current number of tasks that have acquired the semaphore.
  #
  # source://async//lib/async/semaphore.rb#23
  def count; end

  # Is the semaphore currently acquired?
  #
  # @return [Boolean]
  #
  # source://async//lib/async/semaphore.rb#51
  def empty?; end

  # The maximum number of tasks that can acquire the semaphore.
  #
  # source://async//lib/async/semaphore.rb#26
  def limit; end

  # Allow setting the limit. This is useful for cases where the semaphore is used to limit the number of concurrent tasks, but the number of tasks is not known in advance or needs to be modified.
  #
  # On increasing the limit, some tasks may be immediately resumed. On decreasing the limit, some tasks may execute until the count is < than the limit.
  #
  # source://async//lib/async/semaphore.rb#36
  def limit=(limit); end

  # Release the semaphore. Must match up with a corresponding call to `acquire`. Will release waiting fibers in FIFO order.
  #
  # source://async//lib/async/semaphore.rb#94
  def release; end

  # The tasks waiting on this semaphore.
  #
  # source://async//lib/async/semaphore.rb#29
  def waiting; end

  private

  # Wait until the semaphore becomes available.
  #
  # source://async//lib/async/semaphore.rb#119
  def wait; end
end

# source://async//lib/async/semaphore.rb#104
class Async::Semaphore::FiberNode < ::Async::List::Node
  # @return [FiberNode] a new instance of FiberNode
  #
  # source://async//lib/async/semaphore.rb#105
  def initialize(fiber); end

  # source://async//lib/async/semaphore.rb#109
  def resume; end
end

# Raised when a task is explicitly stopped.
#
# source://async//lib/async/task.rb#20
class Async::Stop < ::Exception; end

# Used to defer stopping the current task until later.
#
# source://async//lib/async/task.rb#22
class Async::Stop::Later
  # Create a new stop later operation.
  #
  # @return [Later] a new instance of Later
  #
  # source://async//lib/async/task.rb#26
  def initialize(task); end

  # @return [Boolean]
  #
  # source://async//lib/async/task.rb#31
  def alive?; end

  # Transfer control to the operation - this will stop the task.
  #
  # source://async//lib/async/task.rb#36
  def transfer; end
end

# source://async//lib/async/task.rb#54
class Async::Task < ::Async::Node
  # Create a new task.
  #
  # @return [Task] a new instance of Task
  #
  # source://async//lib/async/task.rb#73
  def initialize(parent = T.unsafe(nil), finished: T.unsafe(nil), **options, &block); end

  # @return [Boolean]
  #
  # source://async//lib/async/task.rb#146
  def alive?; end

  # Annotate the task with a description.
  #
  # This will internally try to annotate the fiber if it is running, otherwise it will annotate the task itself.
  #
  # source://async//lib/async/task.rb#105
  def annotate(annotation, &block); end

  # source://async//lib/async/task.rb#114
  def annotation; end

  # Run an asynchronous task as a child of the current task.
  #
  # @raise [FinishedError]
  #
  # source://async//lib/async/task.rb#210
  def async(*arguments, **options, &block); end

  # source://async//lib/async/task.rb#96
  def backtrace(*arguments); end

  # @return [Boolean]
  #
  # source://async//lib/async/task.rb#173
  def complete?; end

  # @return [Boolean]
  #
  # source://async//lib/async/task.rb#173
  def completed?; end

  # @return [Boolean]
  #
  # source://async//lib/async/task.rb#340
  def current?; end

  # Defer the handling of stop. During the execution of the given block, if a stop is requested, it will be deferred until the block exits. This is useful for ensuring graceful shutdown of servers and other long-running tasks. You should wrap the response handling code in a defer_stop block to ensure that the task is stopped when the response is complete but not before.
  #
  # You can nest calls to defer_stop, but the stop will only be deferred until the outermost block exits.
  #
  # If stop is invoked a second time, it will be immediately executed.
  #
  # source://async//lib/async/task.rb#298
  def defer_stop; end

  # @return [Boolean]
  #
  # source://async//lib/async/task.rb#163
  def failed?; end

  # Returns the value of attribute fiber.
  #
  # source://async//lib/async/task.rb#143
  def fiber; end

  # Whether we can remove this node from the reactor graph.
  #
  # @return [Boolean]
  #
  # source://async//lib/async/task.rb#152
  def finished?; end

  # source://async//lib/async/task.rb#91
  def reactor; end

  # Access the result of the task without waiting. May be nil if the task is not completed. Does not raise exceptions.
  #
  # source://async//lib/async/task.rb#243
  def result; end

  # Begin the execution of the task.
  #
  # source://async//lib/async/task.rb#185
  def run(*arguments); end

  # @return [Boolean]
  #
  # source://async//lib/async/task.rb#158
  def running?; end

  # @deprecated Prefer {Kernel#sleep} except when compatibility with `stable-v1` is required.
  #
  # source://async//lib/async/task.rb#128
  def sleep(duration = T.unsafe(nil)); end

  # Returns the value of attribute status.
  #
  # source://async//lib/async/task.rb#180
  def status; end

  # Stop the task and all of its children.
  #
  # If `later` is false, it means that `stop` has been invoked directly. When `later` is true, it means that `stop` is invoked by `stop_children` or some other indirect mechanism. In that case, if we encounter the "current" fiber, we can't stop it right away, as it's currently performing `#stop`. Stopping it immediately would interrupt the current stop traversal, so we need to schedule the stop to occur later.
  #
  # source://async//lib/async/task.rb#250
  def stop(later = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://async//lib/async/task.rb#168
  def stopped?; end

  # source://async//lib/async/task.rb#123
  def to_s; end

  # Retrieve the current result of the task. Will cause the caller to wait until result is available. If the task resulted in an unhandled error (derived from `StandardError`), this will be raised. If the task was stopped, this will return `nil`.
  #
  # Conceptually speaking, waiting on a task should return a result, and if it throws an exception, this is certainly an exceptional case that should represent a failure in your program, not an expected outcome. In other words, you should not design your programs to expect exceptions from `#wait` as a normal flow control, and prefer to catch known exceptions within the task itself and return a result that captures the intention of the failure, e.g. a `TimeoutError` might simply return `nil` or `false` to indicate that the operation did not generate a valid result (as a timeout was an expected outcome of the internal operation in this case).
  #
  # source://async//lib/async/task.rb#226
  def wait; end

  # Execute the given block of code, raising the specified exception if it exceeds the given duration during a non-blocking operation.
  #
  # source://async//lib/async/task.rb#133
  def with_timeout(duration, exception = T.unsafe(nil), message = T.unsafe(nil), &block); end

  # Yield back to the reactor and allow other fibers to execute.
  #
  # source://async//lib/async/task.rb#138
  def yield; end

  private

  # State transition into the completed state.
  #
  # source://async//lib/async/task.rb#363
  def completed!(result); end

  # State transition into the failed state.
  #
  # source://async//lib/async/task.rb#369
  def failed!(exception = T.unsafe(nil)); end

  # Finish the current task, moving any children to the parent.
  #
  # source://async//lib/async/task.rb#347
  def finish!; end

  # source://async//lib/async/task.rb#400
  def schedule(&block); end

  # source://async//lib/async/task.rb#394
  def stop!; end

  # source://async//lib/async/task.rb#374
  def stopped!; end

  class << self
    # Lookup the {Task} for the current fiber. Raise `RuntimeError` if none is available.
    # @raises[RuntimeError] If task was not {set!} for the current fiber.
    #
    # source://async//lib/async/task.rb#329
    def current; end

    # Check if there is a task defined for the current fiber.
    #
    # @return [Boolean]
    #
    # source://async//lib/async/task.rb#335
    def current?; end

    # @deprecated With no replacement.
    #
    # source://async//lib/async/task.rb#66
    def yield; end
  end
end

# Raised when a child task is created within a task that has finished execution.
#
# source://async//lib/async/task.rb#56
class Async::Task::FinishedError < ::RuntimeError
  # Create a new finished error.
  #
  # @return [FinishedError] a new instance of FinishedError
  #
  # source://async//lib/async/task.rb#60
  def initialize(message = T.unsafe(nil)); end
end

# Raised if a timeout occurs on a specific Fiber. Handled gracefully by `Task`.
#
# source://async//lib/async/task.rb#44
class Async::TimeoutError < ::StandardError
  # Create a new timeout error.
  #
  # @return [TimeoutError] a new instance of TimeoutError
  #
  # source://async//lib/async/task.rb#48
  def initialize(message = T.unsafe(nil)); end
end

# source://async//lib/async/version.rb#7
Async::VERSION = T.let(T.unsafe(nil), String)

# Extensions to all Ruby objects.
#
# source://async//lib/kernel/async.rb#8
module Kernel
  # Run the given block of code in a task, asynchronously, creating a reactor if necessary.
  #
  # The preferred method to invoke asynchronous behavior at the top level.
  #
  # - When invoked within an existing reactor task, it will run the given block
  # asynchronously. Will return the task once it has been scheduled.
  # - When invoked at the top level, will create and run a reactor, and invoke
  # the block as an asynchronous task. Will block until the reactor finishes
  # running.
  #
  # source://async//lib/kernel/async.rb#24
  def Async(*_arg0, **_arg1, &_arg2); end

  # Run the given block of code synchronously, but within a reactor if not already in one.
  #
  # source://async//lib/kernel/sync.rb#18
  def Sync(&block); end
end
