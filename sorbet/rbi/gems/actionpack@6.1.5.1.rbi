# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `actionpack` gem.
# Please instead update this file by running `bin/tapioca gem actionpack`.

module AbstractController
  extend ::ActiveSupport::Autoload

  class << self
    def eager_load!; end
  end
end

# Raised when a non-existing controller action is triggered.
class AbstractController::ActionNotFound < ::StandardError
  include ::DidYouMean::Correctable

  # @return [ActionNotFound] a new instance of ActionNotFound
  def initialize(message = T.unsafe(nil), controller = T.unsafe(nil), action = T.unsafe(nil)); end

  # Returns the value of attribute action.
  def action; end

  # Returns the value of attribute controller.
  def controller; end
end

class AbstractController::ActionNotFound::Correction
  # @return [Correction] a new instance of Correction
  def initialize(error); end

  def corrections; end
end

module AbstractController::AssetPaths
  extend ::ActiveSupport::Concern
end

# AbstractController::Base is a low-level API. Nobody should be
# using it directly, and subclasses (like ActionController::Base) are
# expected to provide their own +render+ method, since rendering means
# different things depending on the context.
#
# @abstract It cannont be directly instantiated. Subclasses must implement the `abstract` methods below.
class AbstractController::Base
  include ::ActiveSupport::Configurable
  extend ::ActiveSupport::Configurable::ClassMethods
  extend ::ActiveSupport::DescendantsTracker

  # Delegates to the class' ::action_methods
  def action_methods; end

  # Returns the name of the action this controller is processing.
  def action_name; end

  def action_name=(_arg0); end

  # Returns true if a method for the action is available and
  # can be dispatched, false otherwise.
  #
  # Notice that <tt>action_methods.include?("foo")</tt> may return
  # false and <tt>available_action?("foo")</tt> returns true because
  # this method considers actions that are also available
  # through other means, for example, implicit render ones.
  #
  # ==== Parameters
  # * <tt>action_name</tt> - The name of an action to be tested
  #
  # @return [Boolean]
  def available_action?(action_name); end

  # Delegates to the class' ::controller_path
  def controller_path; end

  # Returns the formats that can be processed by the controller.
  def formats; end

  def formats=(_arg0); end
  def inspect; end

  # Tests if a response body is set. Used to determine if the
  # +process_action+ callback needs to be terminated in
  # +AbstractController::Callbacks+.
  #
  # @return [Boolean]
  def performed?; end

  # Calls the action going through the entire action dispatch stack.
  #
  # The actual method that is called is determined by calling
  # #method_for_action. If no method can handle the action, then an
  # AbstractController::ActionNotFound error is raised.
  #
  # ==== Returns
  # * <tt>self</tt>
  def process(action, *args); end

  # Returns the body of the HTTP response sent by the controller.
  def response_body; end

  def response_body=(_arg0); end

  # Actually call the method associated with the action. Override
  # this method if you wish to change how action methods are called,
  # not to add additional behavior around it. For example, you would
  # override #send_action if you want to inject arguments into the
  # method.
  def send_action(*_arg0); end

  private

  # Takes an action name and returns the name of the method that will
  # handle the action.
  #
  # It checks if the action name is valid and returns false otherwise.
  #
  # See method_for_action for more information.
  #
  # ==== Parameters
  # * <tt>action_name</tt> - An action name to find a method name for
  #
  # ==== Returns
  # * <tt>string</tt> - The name of the method that handles the action
  # * false           - No valid method name could be found.
  # Raise +AbstractController::ActionNotFound+.
  def _find_action_name(action_name); end

  # If the action name was not found, but a method called "action_missing"
  # was found, #method_for_action will return "_handle_action_missing".
  # This method calls #action_missing with the current action name.
  def _handle_action_missing(*args); end

  # Checks if the action name is valid and returns false otherwise.
  #
  # @return [Boolean]
  def _valid_action_name?(action_name); end

  # Returns true if the name can be considered an action because
  # it has a method defined in the controller.
  #
  # ==== Parameters
  # * <tt>name</tt> - The name of an action to be tested
  #
  # @return [Boolean]
  def action_method?(name); end

  # Takes an action name and returns the name of the method that will
  # handle the action. In normal cases, this method returns the same
  # name as it receives. By default, if #method_for_action receives
  # a name that is not an action, it will look for an #action_missing
  # method and return "_handle_action_missing" if one is found.
  #
  # Subclasses may override this method to add additional conditions
  # that should be considered an action. For instance, an HTTP controller
  # with a template matching the action name is considered to exist.
  #
  # If you override this method to handle additional cases, you may
  # also provide a method (like +_handle_method_missing+) to handle
  # the case.
  #
  # If none of these conditions are true, and +method_for_action+
  # returns +nil+, an +AbstractController::ActionNotFound+ exception will be raised.
  #
  # ==== Parameters
  # * <tt>action_name</tt> - An action name to find a method name for
  #
  # ==== Returns
  # * <tt>string</tt> - The name of the method that handles the action
  # * <tt>nil</tt>    - No method name could be found.
  def method_for_action(action_name); end

  # Call the action. Override this in a subclass to modify the
  # behavior around processing an action. This, and not #process,
  # is the intended way to override action dispatching.
  #
  # Notice that the first argument is the method to be dispatched
  # which is *not* necessarily the same as the action name.
  def process_action(method_name, *args); end

  class << self
    # Returns the value of attribute abstract.
    def abstract; end

    # Define a controller as abstract. See internal_methods for more
    # details.
    def abstract!; end

    # Returns the value of attribute abstract.
    def abstract?; end

    # A list of method names that should be considered actions. This
    # includes all public instance methods on a controller, less
    # any internal methods (see internal_methods), adding back in
    # any methods that are internal, but still exist on the class
    # itself.
    #
    # ==== Returns
    # * <tt>Set</tt> - A set of all methods that should be considered actions.
    def action_methods; end

    # action_methods are cached and there is sometimes a need to refresh
    # them. ::clear_action_methods! allows you to do that, so next time
    # you run action_methods, they will be recalculated.
    def clear_action_methods!; end

    # Returns the full controller name, underscored, without the ending Controller.
    #
    #   class MyApp::MyPostsController < AbstractController::Base
    #
    #   end
    #
    #   MyApp::MyPostsController.controller_path # => "my_app/my_posts"
    #
    # ==== Returns
    # * <tt>String</tt>
    def controller_path; end

    def inherited(klass); end

    # A list of all internal methods for a controller. This finds the first
    # abstract superclass of a controller, and gets a list of all public
    # instance methods on that abstract class. Public instance methods of
    # a controller would normally be considered action methods, so methods
    # declared on abstract classes are being removed.
    # (<tt>ActionController::Metal</tt> and ActionController::Base are defined as abstract)
    def internal_methods; end

    # Refresh the cached action_methods when a new action_method is added.
    def method_added(name); end

    # Returns true if the given controller is capable of rendering
    # a path. A subclass of +AbstractController::Base+
    # may return false. An Email controller for example does not
    # support paths, only full URLs.
    #
    # @return [Boolean]
    def supports_path?; end
  end
end

module AbstractController::Caching
  include ::AbstractController::Caching::ConfigMethods
  extend ::ActiveSupport::Concern
  extend ::ActiveSupport::Autoload
  include GeneratedInstanceMethods
  include ::AbstractController::Caching::Fragments

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::AbstractController::Caching::Fragments::ClassMethods
  mixes_in_class_methods ::AbstractController::Caching::ClassMethods
  mixes_in_class_methods ::AbstractController::Caching::ConfigMethods

  def view_cache_dependencies; end

  private

  # Convenience accessor.
  def cache(key, options = T.unsafe(nil), &block); end

  module GeneratedClassMethods
    def _view_cache_dependencies; end
    def _view_cache_dependencies=(value); end
    def _view_cache_dependencies?; end
    def fragment_cache_keys; end
    def fragment_cache_keys=(value); end
    def fragment_cache_keys?; end
  end

  module GeneratedInstanceMethods
    def _view_cache_dependencies; end
    def _view_cache_dependencies=(value); end
    def _view_cache_dependencies?; end
    def fragment_cache_keys; end
    def fragment_cache_keys=(value); end
    def fragment_cache_keys?; end
  end
end

module AbstractController::Caching::ClassMethods
  def view_cache_dependency(&dependency); end
end

module AbstractController::Caching::ConfigMethods
  def cache_store; end
  def cache_store=(store); end

  private

  # @return [Boolean]
  def cache_configured?; end
end

# Fragment caching is used for caching various blocks within
# views without caching the entire action as a whole. This is
# useful when certain elements of an action change frequently or
# depend on complicated state while other parts rarely change or
# can be shared amongst multiple parties. The caching is done using
# the +cache+ helper available in the Action View. See
# ActionView::Helpers::CacheHelper for more information.
#
# While it's strongly recommended that you use key-based cache
# expiration (see links in CacheHelper for more information),
# it is also possible to manually expire caches. For example:
#
#   expire_fragment('name_of_cache')
module AbstractController::Caching::Fragments
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::AbstractController::Caching::Fragments::ClassMethods

  # Given a key (as described in +expire_fragment+), returns
  # a key array suitable for use in reading, writing, or expiring a
  # cached fragment. All keys begin with <tt>:views</tt>,
  # followed by <tt>ENV["RAILS_CACHE_ID"]</tt> or <tt>ENV["RAILS_APP_VERSION"]</tt> if set,
  # followed by any controller-wide key prefix values, ending
  # with the specified +key+ value.
  def combined_fragment_cache_key(key); end

  # Removes fragments from the cache.
  #
  # +key+ can take one of three forms:
  #
  # * String - This would normally take the form of a path, like
  #   <tt>pages/45/notes</tt>.
  # * Hash - Treated as an implicit call to +url_for+, like
  #   <tt>{ controller: 'pages', action: 'notes', id: 45}</tt>
  # * Regexp - Will remove any fragment that matches, so
  #   <tt>%r{pages/\d*/notes}</tt> might remove all notes. Make sure you
  #   don't use anchors in the regex (<tt>^</tt> or <tt>$</tt>) because
  #   the actual filename matched looks like
  #   <tt>./cache/filename/path.cache</tt>. Note: Regexp expiration is
  #   only supported on caches that can iterate over all keys (unlike
  #   memcached).
  #
  # +options+ is passed through to the cache store's +delete+
  # method (or <tt>delete_matched</tt>, for Regexp keys).
  def expire_fragment(key, options = T.unsafe(nil)); end

  # Check if a cached fragment from the location signified by
  # +key+ exists (see +expire_fragment+ for acceptable formats).
  #
  # @return [Boolean]
  def fragment_exist?(key, options = T.unsafe(nil)); end

  def instrument_fragment_cache(name, key); end

  # Reads a cached fragment from the location signified by +key+
  # (see +expire_fragment+ for acceptable formats).
  def read_fragment(key, options = T.unsafe(nil)); end

  # Writes +content+ to the location signified by
  # +key+ (see +expire_fragment+ for acceptable formats).
  def write_fragment(key, content, options = T.unsafe(nil)); end

  module GeneratedClassMethods
    def fragment_cache_keys; end
    def fragment_cache_keys=(value); end
    def fragment_cache_keys?; end
  end

  module GeneratedInstanceMethods
    def fragment_cache_keys; end
    def fragment_cache_keys=(value); end
    def fragment_cache_keys?; end
  end
end

module AbstractController::Caching::Fragments::ClassMethods
  # Allows you to specify controller-wide key prefixes for
  # cache fragments. Pass either a constant +value+, or a block
  # which computes a value each time a cache key is generated.
  #
  # For example, you may want to prefix all fragment cache keys
  # with a global version identifier, so you can easily
  # invalidate all caches.
  #
  #   class ApplicationController
  #     fragment_cache_key "v1"
  #   end
  #
  # When it's time to invalidate all fragments, simply change
  # the string constant. Or, progressively roll out the cache
  # invalidation using a computed value:
  #
  #   class ApplicationController
  #     fragment_cache_key do
  #       @account.id.odd? ? "v1" : "v2"
  #     end
  #   end
  def fragment_cache_key(value = T.unsafe(nil), &key); end
end

# = Abstract Controller Callbacks
#
# Abstract Controller provides hooks during the life cycle of a controller action.
# Callbacks allow you to trigger logic during this cycle. Available callbacks are:
#
# * <tt>after_action</tt>
# * <tt>append_after_action</tt>
# * <tt>append_around_action</tt>
# * <tt>append_before_action</tt>
# * <tt>around_action</tt>
# * <tt>before_action</tt>
# * <tt>prepend_after_action</tt>
# * <tt>prepend_around_action</tt>
# * <tt>prepend_before_action</tt>
# * <tt>skip_after_action</tt>
# * <tt>skip_around_action</tt>
# * <tt>skip_before_action</tt>
#
# NOTE: Calling the same callback multiple times will overwrite previous callback definitions.
module AbstractController::Callbacks
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods
  include ::ActiveSupport::Callbacks

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::ActiveSupport::Callbacks::ClassMethods
  mixes_in_class_methods ::ActiveSupport::DescendantsTracker
  mixes_in_class_methods ::AbstractController::Callbacks::ClassMethods

  # Override <tt>AbstractController::Base#process_action</tt> to run the
  # <tt>process_action</tt> callbacks around the normal behavior.
  def process_action(*_arg0); end

  module GeneratedClassMethods
    def __callbacks; end
    def __callbacks=(value); end
    def __callbacks?; end
  end

  module GeneratedInstanceMethods
    def __callbacks; end
    def __callbacks?; end
  end
end

module AbstractController::Callbacks::ClassMethods
  # Take callback names and an optional callback proc, normalize them,
  # then call the block with each callback. This allows us to abstract
  # the normalization across several methods that use it.
  #
  # ==== Parameters
  # * <tt>callbacks</tt> - An array of callbacks, with an optional
  #   options hash as the last parameter.
  # * <tt>block</tt>    - A proc that should be added to the callbacks.
  #
  # ==== Block Parameters
  # * <tt>name</tt>     - The callback to be added.
  # * <tt>options</tt>  - A hash of options to be used when adding the callback.
  def _insert_callbacks(callbacks, block = T.unsafe(nil)); end

  def _normalize_callback_option(options, from, to); end

  # If +:only+ or +:except+ are used, convert the options into the
  # +:if+ and +:unless+ options of ActiveSupport::Callbacks.
  #
  # The basic idea is that <tt>:only => :index</tt> gets converted to
  # <tt>:if => proc {|c| c.action_name == "index" }</tt>.
  #
  # Note that <tt>:only</tt> has priority over <tt>:if</tt> in case they
  # are used together.
  #
  #   only: :index, if: -> { true } # the :if option will be ignored.
  #
  # Note that <tt>:if</tt> has priority over <tt>:except</tt> in case they
  # are used together.
  #
  #   except: :index, if: -> { true } # the :except option will be ignored.
  #
  # ==== Options
  # * <tt>only</tt>   - The callback should be run only for this action.
  # * <tt>except</tt>  - The callback should be run for all actions except this action.
  def _normalize_callback_options(options); end

  def after_action(*names, &blk); end
  def append_after_action(*names, &blk); end
  def append_around_action(*names, &blk); end
  def append_before_action(*names, &blk); end
  def around_action(*names, &blk); end
  def before_action(*names, &blk); end
  def prepend_after_action(*names, &blk); end
  def prepend_around_action(*names, &blk); end
  def prepend_before_action(*names, &blk); end
  def skip_after_action(*names); end
  def skip_around_action(*names); end
  def skip_before_action(*names); end
end

module AbstractController::Collector
  def atom(*args, &block); end
  def bmp(*args, &block); end
  def css(*args, &block); end
  def csv(*args, &block); end
  def gif(*args, &block); end
  def gzip(*args, &block); end
  def html(*args, &block); end
  def ics(*args, &block); end
  def jpeg(*args, &block); end
  def js(*args, &block); end
  def json(*args, &block); end
  def m4a(*args, &block); end
  def mp3(*args, &block); end
  def mp4(*args, &block); end
  def mpeg(*args, &block); end
  def multipart_form(*args, &block); end
  def ogg(*args, &block); end
  def otf(*args, &block); end
  def pdf(*args, &block); end
  def png(*args, &block); end
  def rss(*args, &block); end
  def svg(*args, &block); end
  def text(*args, &block); end
  def tiff(*args, &block); end
  def ttf(*args, &block); end
  def url_encoded_form(*args, &block); end
  def vcf(*args, &block); end
  def vtt(*args, &block); end
  def webm(*args, &block); end
  def woff(*args, &block); end
  def woff2(*args, &block); end
  def xml(*args, &block); end
  def yaml(*args, &block); end
  def zip(*args, &block); end

  private

  def method_missing(symbol, *args, &block); end

  class << self
    def generate_method_for_mime(mime); end
  end
end

class AbstractController::DoubleRenderError < ::AbstractController::Error
  # @return [DoubleRenderError] a new instance of DoubleRenderError
  def initialize(message = T.unsafe(nil)); end
end

AbstractController::DoubleRenderError::DEFAULT_MESSAGE = T.let(T.unsafe(nil), String)
class AbstractController::Error < ::StandardError; end

module AbstractController::Helpers
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::AbstractController::Helpers::ClassMethods

  def _helpers; end

  module GeneratedClassMethods
    def _helper_methods; end
    def _helper_methods=(value); end
    def _helper_methods?; end
  end

  module GeneratedInstanceMethods
    def _helper_methods; end
    def _helper_methods=(value); end
    def _helper_methods?; end
  end
end

module AbstractController::Helpers::ClassMethods
  # Sets the attribute _helpers
  #
  # @param value the value to set the attribute _helpers to.
  def _helpers=(_arg0); end

  def _helpers_for_modification; end

  # Clears up all existing helpers in this class, only keeping the helper
  # with the same name as this class.
  def clear_helpers; end

  # Includes the given modules in the template class.
  #
  # Modules can be specified in different ways. All of the following calls
  # include +FooHelper+:
  #
  #   # Module, recommended.
  #   helper FooHelper
  #
  #   # String/symbol without the "helper" suffix, camel or snake case.
  #   helper "Foo"
  #   helper :Foo
  #   helper "foo"
  #   helper :foo
  #
  # The last two assume that <tt>"foo".camelize</tt> returns "Foo".
  #
  # When strings or symbols are passed, the method finds the actual module
  # object using +String#constantize+. Therefore, if the module has not been
  # yet loaded, it has to be autoloadable, which is normally the case.
  #
  # Namespaces are supported. The following calls include +Foo::BarHelper+:
  #
  #   # Module, recommended.
  #   helper Foo::BarHelper
  #
  #   # String/symbol without the "helper" suffix, camel or snake case.
  #   helper "Foo::Bar"
  #   helper :"Foo::Bar"
  #   helper "foo/bar"
  #   helper :"foo/bar"
  #
  # The last two assume that <tt>"foo/bar".camelize</tt> returns "Foo::Bar".
  #
  # The method accepts a block too. If present, the block is evaluated in
  # the context of the controller helper module. This simple call makes the
  # +wadus+ method available in templates of the enclosing controller:
  #
  #   helper do
  #     def wadus
  #       "wadus"
  #     end
  #   end
  #
  # Furthermore, all the above styles can be mixed together:
  #
  #   helper FooHelper, "woo", "bar/baz" do
  #     def wadus
  #       "wadus"
  #     end
  #   end
  def helper(*args, &block); end

  # Declare a controller method as a helper. For example, the following
  # makes the +current_user+ and +logged_in?+ controller methods available
  # to the view:
  #   class ApplicationController < ActionController::Base
  #     helper_method :current_user, :logged_in?
  #
  #     def current_user
  #       @current_user ||= User.find_by(id: session[:user])
  #     end
  #
  #     def logged_in?
  #       current_user != nil
  #     end
  #   end
  #
  # In a view:
  #  <% if logged_in? -%>Welcome, <%= current_user.name %><% end -%>
  #
  # ==== Parameters
  # * <tt>method[, method]</tt> - A name or names of a method on the controller
  #   to be made available on the view.
  def helper_method(*methods); end

  # When a class is inherited, wrap its helper module in a new module.
  # This ensures that the parent class's module can be changed
  # independently of the child class's.
  def inherited(klass); end

  # Given an array of values like the ones accepted by +helper+, this method
  # returns an array with the corresponding modules, in the same order.
  def modules_for_helpers(modules_or_helper_prefixes); end

  private

  def default_helper_module!; end
  def define_helpers_module(klass, helpers = T.unsafe(nil)); end
end

class AbstractController::Helpers::MissingHelperError < ::LoadError
  # @return [MissingHelperError] a new instance of MissingHelperError
  def initialize(error, path); end
end

module AbstractController::Logger
  extend ::ActiveSupport::Concern
  include ::ActiveSupport::Benchmarkable
end

module AbstractController::Rendering
  extend ::ActiveSupport::Concern
  include ::ActionView::ViewPaths

  mixes_in_class_methods ::ActionView::ViewPaths::ClassMethods

  # Normalizes arguments, options and then delegates render_to_body and
  # sticks the result in <tt>self.response_body</tt>.
  def render(*args, &block); end

  # Performs the actual template rendering.
  def render_to_body(options = T.unsafe(nil)); end

  # Raw rendering of a template to a string.
  #
  # It is similar to render, except that it does not
  # set the +response_body+ and it should be guaranteed
  # to always return a string.
  #
  # If a component extends the semantics of +response_body+
  # (as ActionController extends it to be anything that
  # responds to the method each), this method needs to be
  # overridden in order to still return a string.
  def render_to_string(*args, &block); end

  # Returns Content-Type of rendered content.
  def rendered_format; end

  # This method should return a hash with assigns.
  # You can overwrite this configuration per controller.
  def view_assigns; end

  private

  # Normalize args by converting <tt>render "foo"</tt> to
  # <tt>render :action => "foo"</tt> and <tt>render "foo/bar"</tt> to
  # <tt>render :file => "foo/bar"</tt>.
  def _normalize_args(action = T.unsafe(nil), options = T.unsafe(nil)); end

  # Normalize options.
  def _normalize_options(options); end

  # Normalize args and options.
  def _normalize_render(*args, &block); end

  # Process the rendered format.
  def _process_format(format); end

  # Process extra options.
  def _process_options(options); end

  def _process_variant(options); end
  def _protected_ivars; end
  def _set_html_content_type; end
  def _set_rendered_content_type(format); end
  def _set_vary_header; end
end

AbstractController::Rendering::DEFAULT_PROTECTED_INSTANCE_VARIABLES = T.let(T.unsafe(nil), Array)

module AbstractController::Translation
  # Delegates to <tt>I18n.localize</tt>. Also aliased as <tt>l</tt>.
  def l(object, **options); end

  # Delegates to <tt>I18n.localize</tt>. Also aliased as <tt>l</tt>.
  def localize(object, **options); end

  def raise_on_missing_translations; end
  def raise_on_missing_translations=(val); end

  # Delegates to <tt>I18n.translate</tt>. Also aliased as <tt>t</tt>.
  #
  # When the given key starts with a period, it will be scoped by the current
  # controller and action. So if you call <tt>translate(".foo")</tt> from
  # <tt>PeopleController#index</tt>, it will convert the call to
  # <tt>I18n.translate("people.index.foo")</tt>. This makes it less repetitive
  # to translate many keys within the same controller / action and gives you a
  # simple framework for scoping them consistently.
  def t(key, **options); end

  # Delegates to <tt>I18n.translate</tt>. Also aliased as <tt>t</tt>.
  #
  # When the given key starts with a period, it will be scoped by the current
  # controller and action. So if you call <tt>translate(".foo")</tt> from
  # <tt>PeopleController#index</tt>, it will convert the call to
  # <tt>I18n.translate("people.index.foo")</tt>. This makes it less repetitive
  # to translate many keys within the same controller / action and gives you a
  # simple framework for scoping them consistently.
  def translate(key, **options); end

  class << self
    def raise_on_missing_translations; end
    def raise_on_missing_translations=(val); end
  end
end

# Includes +url_for+ into the host class (e.g. an abstract controller or mailer). The class
# has to provide a +RouteSet+ by implementing the <tt>_routes</tt> methods. Otherwise, an
# exception will be raised.
#
# Note that this module is completely decoupled from HTTP - the only requirement is a valid
# <tt>_routes</tt> implementation.
module AbstractController::UrlFor
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods
  include ::ActionDispatch::Routing::UrlFor

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::AbstractController::UrlFor::ClassMethods

  def _routes; end

  module GeneratedClassMethods
    def default_url_options; end
    def default_url_options=(value); end
    def default_url_options?; end
  end

  module GeneratedInstanceMethods
    def default_url_options; end
    def default_url_options=(value); end
    def default_url_options?; end
  end
end

module AbstractController::UrlFor::ClassMethods
  def _routes; end
  def action_methods; end
end

module ActionController
  extend ::ActiveSupport::Autoload

  class << self
    # See <tt>Renderers.add</tt>
    def add_renderer(key, &block); end

    # See <tt>Renderers.remove</tt>
    def remove_renderer(key); end
  end
end

# API Controller is a lightweight version of <tt>ActionController::Base</tt>,
# created for applications that don't require all functionalities that a complete
# \Rails controller provides, allowing you to create controllers with just the
# features that you need for API only applications.
#
# An API Controller is different from a normal controller in the sense that
# by default it doesn't include a number of features that are usually required
# by browser access only: layouts and templates rendering,
# flash, assets, and so on. This makes the entire controller stack thinner,
# suitable for API applications. It doesn't mean you won't have such
# features if you need them: they're all available for you to include in
# your application, they're just not part of the default API controller stack.
#
# Normally, +ApplicationController+ is the only controller that inherits from
# <tt>ActionController::API</tt>. All other controllers in turn inherit from
# +ApplicationController+.
#
# A sample controller could look like this:
#
#   class PostsController < ApplicationController
#     def index
#       posts = Post.all
#       render json: posts
#     end
#   end
#
# Request, response, and parameters objects all work the exact same way as
# <tt>ActionController::Base</tt>.
#
# == Renders
#
# The default API Controller stack includes all renderers, which means you
# can use <tt>render :json</tt> and brothers freely in your controllers. Keep
# in mind that templates are not going to be rendered, so you need to ensure
# your controller is calling either <tt>render</tt> or <tt>redirect_to</tt> in
# all actions, otherwise it will return 204 No Content.
#
#   def show
#     post = Post.find(params[:id])
#     render json: post
#   end
#
# == Redirects
#
# Redirects are used to move from one action to another. You can use the
# <tt>redirect_to</tt> method in your controllers in the same way as in
# <tt>ActionController::Base</tt>. For example:
#
#   def create
#     redirect_to root_url and return if not_authorized?
#     # do stuff here
#   end
#
# == Adding New Behavior
#
# In some scenarios you may want to add back some functionality provided by
# <tt>ActionController::Base</tt> that is not present by default in
# <tt>ActionController::API</tt>, for instance <tt>MimeResponds</tt>. This
# module gives you the <tt>respond_to</tt> method. Adding it is quite simple,
# you just need to include the module in a specific controller or in
# +ApplicationController+ in case you want it available in your entire
# application:
#
#   class ApplicationController < ActionController::API
#     include ActionController::MimeResponds
#   end
#
#   class PostsController < ApplicationController
#     def index
#       posts = Post.all
#
#       respond_to do |format|
#         format.json { render json: posts }
#         format.xml  { render xml: posts }
#       end
#     end
#   end
#
# Make sure to check the modules included in <tt>ActionController::Base</tt>
# if you want to use any other functionality that is not provided
# by <tt>ActionController::API</tt> out of the box.
#
# @abstract It cannont be directly instantiated. Subclasses must implement the `abstract` methods below.
class ActionController::API < ::ActionController::Metal
  include ::ActionView::ViewPaths
  include ::AbstractController::Rendering
  include ::ActionDispatch::Routing::PolymorphicRoutes
  include ::ActionDispatch::Routing::UrlFor
  include ::AbstractController::UrlFor
  include ::ActionController::UrlFor
  include ::AbstractController::Logger
  include ::ActiveSupport::Benchmarkable
  include ::ActionController::Redirecting
  include ::ActionController::ApiRendering
  include ::ActionController::Rendering
  include ::ActionController::Renderers
  include ::ActionController::Renderers::All
  include ::ActionController::Head
  include ::ActionController::ConditionalGet
  include ::ActionController::BasicImplicitRender
  include ::ActionController::StrongParameters
  include ::ActionController::DataStreaming
  include ::ActionController::DefaultHeaders
  include ::ActionController::Logging
  include ::ActiveSupport::Callbacks
  include ::AbstractController::Callbacks
  include ::ActiveSupport::Rescuable
  include ::ActionController::Rescue
  include ::ActionController::Instrumentation
  include ::ActionController::ParamsWrapper
  extend ::ActionView::ViewPaths::ClassMethods
  extend ::AbstractController::UrlFor::ClassMethods
  extend ::ActionController::Rendering::ClassMethods
  extend ::ActionController::Renderers::ClassMethods
  extend ::ActionController::ConditionalGet::ClassMethods
  extend ::ActionController::DefaultHeaders::ClassMethods
  extend ::ActionController::Logging::ClassMethods
  extend ::ActiveSupport::Callbacks::ClassMethods
  extend ::AbstractController::Callbacks::ClassMethods
  extend ::ActiveSupport::Rescuable::ClassMethods
  extend ::ActionController::Instrumentation::ClassMethods
  extend ::ActionController::ParamsWrapper::ClassMethods

  def __callbacks; end
  def __callbacks?; end
  def _process_action_callbacks; end
  def _renderers; end
  def _renderers=(_arg0); end
  def _renderers?; end
  def _run_process_action_callbacks(&block); end
  def _wrapper_options; end
  def _wrapper_options=(_arg0); end
  def _wrapper_options?; end
  def default_url_options; end
  def default_url_options=(_arg0); end
  def default_url_options?; end
  def etaggers; end
  def etaggers=(_arg0); end
  def etaggers?; end
  def logger; end
  def logger=(value); end
  def rescue_handlers; end
  def rescue_handlers=(_arg0); end
  def rescue_handlers?; end

  class << self
    def __callbacks; end
    def __callbacks=(value); end
    def __callbacks?; end
    def _process_action_callbacks; end
    def _process_action_callbacks=(value); end
    def _renderers; end
    def _renderers=(value); end
    def _renderers?; end
    def _wrapper_options; end
    def _wrapper_options=(value); end
    def _wrapper_options?; end
    def default_url_options; end
    def default_url_options=(value); end
    def default_url_options?; end
    def etaggers; end
    def etaggers=(value); end
    def etaggers?; end
    def logger; end
    def logger=(value); end
    def middleware_stack; end
    def rescue_handlers; end
    def rescue_handlers=(value); end
    def rescue_handlers?; end

    # Shortcut helper that returns all the ActionController::API modules except
    # the ones passed as arguments:
    #
    #   class MyAPIBaseController < ActionController::Metal
    #     ActionController::API.without_modules(:UrlFor).each do |left|
    #       include left
    #     end
    #   end
    #
    # This gives better control over what you want to exclude and makes it easier
    # to create an API controller class, instead of listing the modules required
    # manually.
    def without_modules(*modules); end
  end
end

ActionController::API::MODULES = T.let(T.unsafe(nil), Array)
class ActionController::ActionControllerError < ::StandardError; end

module ActionController::ApiRendering
  extend ::ActiveSupport::Concern
  include ::ActionController::Rendering

  mixes_in_class_methods ::ActionController::Rendering::ClassMethods

  def render_to_body(options = T.unsafe(nil)); end
end

class ActionController::BadRequest < ::ActionController::ActionControllerError
  # @return [BadRequest] a new instance of BadRequest
  def initialize(msg = T.unsafe(nil)); end
end

# Action Controllers are the core of a web request in \Rails. They are made up of one or more actions that are executed
# on request and then either it renders a template or redirects to another action. An action is defined as a public method
# on the controller, which will automatically be made accessible to the web-server through \Rails Routes.
#
# By default, only the ApplicationController in a \Rails application inherits from <tt>ActionController::Base</tt>. All other
# controllers inherit from ApplicationController. This gives you one class to configure things such as
# request forgery protection and filtering of sensitive request parameters.
#
# A sample controller could look like this:
#
#   class PostsController < ApplicationController
#     def index
#       @posts = Post.all
#     end
#
#     def create
#       @post = Post.create params[:post]
#       redirect_to posts_path
#     end
#   end
#
# Actions, by default, render a template in the <tt>app/views</tt> directory corresponding to the name of the controller and action
# after executing code in the action. For example, the +index+ action of the PostsController would render the
# template <tt>app/views/posts/index.html.erb</tt> by default after populating the <tt>@posts</tt> instance variable.
#
# Unlike index, the create action will not render a template. After performing its main purpose (creating a
# new post), it initiates a redirect instead. This redirect works by returning an external
# <tt>302 Moved</tt> HTTP response that takes the user to the index action.
#
# These two methods represent the two basic action archetypes used in Action Controllers: Get-and-show and do-and-redirect.
# Most actions are variations on these themes.
#
# == Requests
#
# For every request, the router determines the value of the +controller+ and +action+ keys. These determine which controller
# and action are called. The remaining request parameters, the session (if one is available), and the full request with
# all the HTTP headers are made available to the action through accessor methods. Then the action is performed.
#
# The full request object is available via the request accessor and is primarily used to query for HTTP headers:
#
#   def server_ip
#     location = request.env["REMOTE_ADDR"]
#     render plain: "This server hosted at #{location}"
#   end
#
# == Parameters
#
# All request parameters, whether they come from a query string in the URL or form data submitted through a POST request are
# available through the <tt>params</tt> method which returns a hash. For example, an action that was performed through
# <tt>/posts?category=All&limit=5</tt> will include <tt>{ "category" => "All", "limit" => "5" }</tt> in <tt>params</tt>.
#
# It's also possible to construct multi-dimensional parameter hashes by specifying keys using brackets, such as:
#
#   <input type="text" name="post[name]" value="david">
#   <input type="text" name="post[address]" value="hyacintvej">
#
# A request coming from a form holding these inputs will include <tt>{ "post" => { "name" => "david", "address" => "hyacintvej" } }</tt>.
# If the address input had been named <tt>post[address][street]</tt>, the <tt>params</tt> would have included
# <tt>{ "post" => { "address" => { "street" => "hyacintvej" } } }</tt>. There's no limit to the depth of the nesting.
#
# == Sessions
#
# Sessions allow you to store objects in between requests. This is useful for objects that are not yet ready to be persisted,
# such as a Signup object constructed in a multi-paged process, or objects that don't change much and are needed all the time, such
# as a User object for a system that requires login. The session should not be used, however, as a cache for objects where it's likely
# they could be changed unknowingly. It's usually too much work to keep it all synchronized -- something databases already excel at.
#
# You can place objects in the session by using the <tt>session</tt> method, which accesses a hash:
#
#   session[:person] = Person.authenticate(user_name, password)
#
# You can retrieve it again through the same hash:
#
#   "Hello #{session[:person]}"
#
# For removing objects from the session, you can either assign a single key to +nil+:
#
#   # removes :person from session
#   session[:person] = nil
#
# or you can remove the entire session with +reset_session+.
#
# Sessions are stored by default in a browser cookie that's cryptographically signed, but unencrypted.
# This prevents the user from tampering with the session but also allows them to see its contents.
#
# Do not put secret information in cookie-based sessions!
#
# == Responses
#
# Each action results in a response, which holds the headers and document to be sent to the user's browser. The actual response
# object is generated automatically through the use of renders and redirects and requires no user intervention.
#
# == Renders
#
# Action Controller sends content to the user by using one of five rendering methods. The most versatile and common is the rendering
# of a template. Included in the Action Pack is the Action View, which enables rendering of ERB templates. It's automatically configured.
# The controller passes objects to the view by assigning instance variables:
#
#   def show
#     @post = Post.find(params[:id])
#   end
#
# Which are then automatically available to the view:
#
#   Title: <%= @post.title %>
#
# You don't have to rely on the automated rendering. For example, actions that could result in the rendering of different templates
# will use the manual rendering methods:
#
#   def search
#     @results = Search.find(params[:query])
#     case @results.count
#       when 0 then render action: "no_results"
#       when 1 then render action: "show"
#       when 2..10 then render action: "show_many"
#     end
#   end
#
# Read more about writing ERB and Builder templates in ActionView::Base.
#
# == Redirects
#
# Redirects are used to move from one action to another. For example, after a <tt>create</tt> action, which stores a blog entry to the
# database, we might like to show the user the new entry. Because we're following good DRY principles (Don't Repeat Yourself), we're
# going to reuse (and redirect to) a <tt>show</tt> action that we'll assume has already been created. The code might look like this:
#
#   def create
#     @entry = Entry.new(params[:entry])
#     if @entry.save
#       # The entry was saved correctly, redirect to show
#       redirect_to action: 'show', id: @entry.id
#     else
#       # things didn't go so well, do something else
#     end
#   end
#
# In this case, after saving our new entry to the database, the user is redirected to the <tt>show</tt> method, which is then executed.
# Note that this is an external HTTP-level redirection which will cause the browser to make a second request (a GET to the show action),
# and not some internal re-routing which calls both "create" and then "show" within one request.
#
# Learn more about <tt>redirect_to</tt> and what options you have in ActionController::Redirecting.
#
# == Calling multiple redirects or renders
#
# An action may contain only a single render or a single redirect. Attempting to try to do either again will result in a DoubleRenderError:
#
#   def do_something
#     redirect_to action: "elsewhere"
#     render action: "overthere" # raises DoubleRenderError
#   end
#
# If you need to redirect on the condition of something, then be sure to add "and return" to halt execution.
#
#   def do_something
#     redirect_to(action: "elsewhere") and return if monkeys.nil?
#     render action: "overthere" # won't be called if monkeys is nil
#   end
#
# @abstract It cannont be directly instantiated. Subclasses must implement the `abstract` methods below.
class ActionController::Base < ::ActionController::Metal
  include ::ActionView::ViewPaths
  include ::AbstractController::Rendering
  include ::AbstractController::Translation
  include ::AbstractController::AssetPaths
  include ::AbstractController::Helpers
  include ::ActionController::Helpers
  include ::ActionDispatch::Routing::PolymorphicRoutes
  include ::ActionDispatch::Routing::UrlFor
  include ::AbstractController::UrlFor
  include ::ActionController::UrlFor
  include ::AbstractController::Logger
  include ::ActiveSupport::Benchmarkable
  include ::ActionController::Redirecting
  include ::ActionView::Rendering
  include ::ActionView::Layouts
  include ::ActionController::Rendering
  include ::ActionController::Renderers
  include ::ActionController::Renderers::All
  include ::ActionController::Head
  include ::ActionController::ConditionalGet
  include ::ActionController::EtagWithTemplateDigest
  include ::ActionController::EtagWithFlash
  include ::ActionController::Caching
  include ::AbstractController::Caching::Fragments
  include ::AbstractController::Caching::ConfigMethods
  include ::AbstractController::Caching
  include ::ActionController::MimeResponds
  include ::ActionController::BasicImplicitRender
  include ::ActionController::ImplicitRender
  include ::ActionController::StrongParameters
  include ::ActionController::ParameterEncoding
  include ::ActionController::Cookies
  include ::ActionController::Flash
  include ::ActionController::FormBuilder
  include ::ActiveSupport::Callbacks
  include ::AbstractController::Callbacks
  include ::ActionController::RequestForgeryProtection
  include ::ActionController::ContentSecurityPolicy
  include ::ActionController::PermissionsPolicy
  include ::ActionController::Streaming
  include ::ActionController::DataStreaming
  include ::ActionController::HttpAuthentication::Basic::ControllerMethods
  include ::ActionController::HttpAuthentication::Digest::ControllerMethods
  include ::ActionController::HttpAuthentication::Token::ControllerMethods
  include ::ActionController::DefaultHeaders
  include ::ActionController::Logging
  include ::ActiveSupport::Rescuable
  include ::ActionController::Rescue
  include ::ActionController::Instrumentation
  include ::ActionController::ParamsWrapper
  extend ::ActionView::ViewPaths::ClassMethods
  extend ::AbstractController::Helpers::ClassMethods
  extend ::ActionController::Helpers::ClassMethods
  extend ::AbstractController::UrlFor::ClassMethods
  extend ::ActionView::Rendering::ClassMethods
  extend ::ActionView::Layouts::ClassMethods
  extend ::ActionController::Rendering::ClassMethods
  extend ::ActionController::Renderers::ClassMethods
  extend ::ActionController::ConditionalGet::ClassMethods
  extend ::AbstractController::Caching::Fragments::ClassMethods
  extend ::AbstractController::Caching::ClassMethods
  extend ::AbstractController::Caching::ConfigMethods
  extend ::ActionController::ParameterEncoding::ClassMethods
  extend ::ActionController::Flash::ClassMethods
  extend ::ActionController::FormBuilder::ClassMethods
  extend ::ActiveSupport::Callbacks::ClassMethods
  extend ::AbstractController::Callbacks::ClassMethods
  extend ::ActionController::RequestForgeryProtection::ClassMethods
  extend ::ActionController::ContentSecurityPolicy::ClassMethods
  extend ::ActionController::PermissionsPolicy::ClassMethods
  extend ::ActionController::HttpAuthentication::Basic::ControllerMethods::ClassMethods
  extend ::ActionController::DefaultHeaders::ClassMethods
  extend ::ActionController::Logging::ClassMethods
  extend ::ActiveSupport::Rescuable::ClassMethods
  extend ::ActionController::Instrumentation::ClassMethods
  extend ::ActionController::ParamsWrapper::ClassMethods

  def __callbacks; end
  def __callbacks?; end
  def _helper_methods; end
  def _helper_methods=(_arg0); end
  def _helper_methods?; end
  def _process_action_callbacks; end
  def _renderers; end
  def _renderers=(_arg0); end
  def _renderers?; end
  def _run_process_action_callbacks(&block); end
  def _view_cache_dependencies; end
  def _view_cache_dependencies=(_arg0); end
  def _view_cache_dependencies?; end
  def _wrapper_options; end
  def _wrapper_options=(_arg0); end
  def _wrapper_options?; end
  def alert; end
  def allow_forgery_protection; end
  def allow_forgery_protection=(value); end
  def asset_host; end
  def asset_host=(value); end
  def assets_dir; end
  def assets_dir=(value); end
  def default_asset_host_protocol; end
  def default_asset_host_protocol=(value); end
  def default_protect_from_forgery; end
  def default_protect_from_forgery=(value); end
  def default_static_extension; end
  def default_static_extension=(value); end
  def default_url_options; end
  def default_url_options=(_arg0); end
  def default_url_options?; end
  def enable_fragment_cache_logging; end
  def enable_fragment_cache_logging=(value); end
  def etag_with_template_digest; end
  def etag_with_template_digest=(_arg0); end
  def etag_with_template_digest?; end
  def etaggers; end
  def etaggers=(_arg0); end
  def etaggers?; end
  def flash(*_arg0, &_arg1); end
  def forgery_protection_origin_check; end
  def forgery_protection_origin_check=(value); end
  def forgery_protection_strategy; end
  def forgery_protection_strategy=(value); end
  def fragment_cache_keys; end
  def fragment_cache_keys=(_arg0); end
  def fragment_cache_keys?; end
  def helpers_path; end
  def helpers_path=(_arg0); end
  def helpers_path?; end
  def include_all_helpers; end
  def include_all_helpers=(_arg0); end
  def include_all_helpers?; end
  def javascripts_dir; end
  def javascripts_dir=(value); end
  def log_warning_on_csrf_failure; end
  def log_warning_on_csrf_failure=(value); end
  def logger; end
  def logger=(value); end
  def notice; end
  def per_form_csrf_tokens; end
  def per_form_csrf_tokens=(value); end
  def perform_caching; end
  def perform_caching=(value); end
  def relative_url_root; end
  def relative_url_root=(value); end
  def request_forgery_protection_token; end
  def request_forgery_protection_token=(value); end
  def rescue_handlers; end
  def rescue_handlers=(_arg0); end
  def rescue_handlers?; end
  def stylesheets_dir; end
  def stylesheets_dir=(value); end
  def urlsafe_csrf_tokens; end

  private

  def _layout(lookup_context, formats); end
  def _protected_ivars; end

  class << self
    def __callbacks; end
    def __callbacks=(value); end
    def __callbacks?; end
    def _default_form_builder; end
    def _default_form_builder=(value); end
    def _default_form_builder?; end
    def _flash_types; end
    def _flash_types=(value); end
    def _flash_types?; end
    def _helper_methods; end
    def _helper_methods=(value); end
    def _helper_methods?; end
    def _helpers; end
    def _layout; end
    def _layout=(value); end
    def _layout?; end
    def _layout_conditions; end
    def _layout_conditions=(value); end
    def _layout_conditions?; end
    def _process_action_callbacks; end
    def _process_action_callbacks=(value); end
    def _renderers; end
    def _renderers=(value); end
    def _renderers?; end
    def _view_cache_dependencies; end
    def _view_cache_dependencies=(value); end
    def _view_cache_dependencies?; end
    def _wrapper_options; end
    def _wrapper_options=(value); end
    def _wrapper_options?; end
    def allow_forgery_protection; end
    def allow_forgery_protection=(value); end
    def asset_host; end
    def asset_host=(value); end
    def assets_dir; end
    def assets_dir=(value); end
    def default_asset_host_protocol; end
    def default_asset_host_protocol=(value); end
    def default_protect_from_forgery; end
    def default_protect_from_forgery=(value); end
    def default_static_extension; end
    def default_static_extension=(value); end
    def default_url_options; end
    def default_url_options=(value); end
    def default_url_options?; end
    def enable_fragment_cache_logging; end
    def enable_fragment_cache_logging=(value); end
    def etag_with_template_digest; end
    def etag_with_template_digest=(value); end
    def etag_with_template_digest?; end
    def etaggers; end
    def etaggers=(value); end
    def etaggers?; end
    def forgery_protection_origin_check; end
    def forgery_protection_origin_check=(value); end
    def forgery_protection_strategy; end
    def forgery_protection_strategy=(value); end
    def fragment_cache_keys; end
    def fragment_cache_keys=(value); end
    def fragment_cache_keys?; end
    def helpers_path; end
    def helpers_path=(value); end
    def helpers_path?; end
    def include_all_helpers; end
    def include_all_helpers=(value); end
    def include_all_helpers?; end
    def javascripts_dir; end
    def javascripts_dir=(value); end
    def log_warning_on_csrf_failure; end
    def log_warning_on_csrf_failure=(value); end
    def logger; end
    def logger=(value); end
    def middleware_stack; end
    def per_form_csrf_tokens; end
    def per_form_csrf_tokens=(value); end
    def perform_caching; end
    def perform_caching=(value); end
    def relative_url_root; end
    def relative_url_root=(value); end
    def request_forgery_protection_token; end
    def request_forgery_protection_token=(value); end
    def rescue_handlers; end
    def rescue_handlers=(value); end
    def rescue_handlers?; end
    def stylesheets_dir; end
    def stylesheets_dir=(value); end
    def urlsafe_csrf_tokens; end
    def urlsafe_csrf_tokens=(value); end

    # Shortcut helper that returns all the modules included in
    # ActionController::Base except the ones passed as arguments:
    #
    #   class MyBaseController < ActionController::Metal
    #     ActionController::Base.without_modules(:ParamsWrapper, :Streaming).each do |left|
    #       include left
    #     end
    #   end
    #
    # This gives better control over what you want to exclude and makes it
    # easier to create a bare controller class, instead of listing the modules
    # required manually.
    def without_modules(*modules); end
  end
end

module ActionController::Base::HelperMethods
  def alert(*args, &block); end
  def combined_fragment_cache_key(*args, &block); end
  def content_security_policy?(*args, &block); end
  def content_security_policy_nonce(*args, &block); end
  def cookies(*args, &block); end
  def form_authenticity_token(*args, &block); end
  def notice(*args, &block); end
  def protect_against_forgery?(*args, &block); end
  def view_cache_dependencies(*args, &block); end
end

ActionController::Base::MODULES = T.let(T.unsafe(nil), Array)

# Define some internal variables that should not be propagated to the view.
ActionController::Base::PROTECTED_IVARS = T.let(T.unsafe(nil), Array)

module ActionController::BasicImplicitRender
  def default_render; end
  def send_action(method, *args); end
end

# \Caching is a cheap way of speeding up slow applications by keeping the result of
# calculations, renderings, and database calls around for subsequent requests.
#
# You can read more about each approach by clicking the modules below.
#
# Note: To turn off all caching provided by Action Controller, set
#   config.action_controller.perform_caching = false
#
# == \Caching stores
#
# All the caching stores from ActiveSupport::Cache are available to be used as backends
# for Action Controller caching.
#
# Configuration examples (FileStore is the default):
#
#   config.action_controller.cache_store = :memory_store
#   config.action_controller.cache_store = :file_store, '/path/to/cache/directory'
#   config.action_controller.cache_store = :mem_cache_store, 'localhost'
#   config.action_controller.cache_store = :mem_cache_store, Memcached::Rails.new('localhost:11211')
#   config.action_controller.cache_store = MyOwnStore.new('parameter')
module ActionController::Caching
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods
  include ::AbstractController::Caching::Fragments
  include ::AbstractController::Caching

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::AbstractController::Caching::Fragments::ClassMethods
  mixes_in_class_methods ::AbstractController::Caching::ClassMethods
  mixes_in_class_methods ::AbstractController::Caching::ConfigMethods

  private

  def instrument_name; end
  def instrument_payload(key); end

  module GeneratedClassMethods
    def _view_cache_dependencies; end
    def _view_cache_dependencies=(value); end
    def _view_cache_dependencies?; end
    def fragment_cache_keys; end
    def fragment_cache_keys=(value); end
    def fragment_cache_keys?; end
  end

  module GeneratedInstanceMethods
    def _view_cache_dependencies; end
    def _view_cache_dependencies=(value); end
    def _view_cache_dependencies?; end
    def fragment_cache_keys; end
    def fragment_cache_keys=(value); end
    def fragment_cache_keys?; end
  end
end

module ActionController::ConditionalGet
  include ::ActionController::Head
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::ActionController::ConditionalGet::ClassMethods

  # Sets an HTTP 1.1 Cache-Control header. Defaults to issuing a +private+
  # instruction, so that intermediate caches must not cache the response.
  #
  #   expires_in 20.minutes
  #   expires_in 3.hours, public: true
  #   expires_in 3.hours, public: true, must_revalidate: true
  #
  # This method will overwrite an existing Cache-Control header.
  # See https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html for more possibilities.
  #
  # HTTP Cache-Control Extensions for Stale Content. See https://tools.ietf.org/html/rfc5861
  # It helps to cache an asset and serve it while is being revalidated and/or returning with an error.
  #
  #   expires_in 3.hours, public: true, stale_while_revalidate: 60.seconds
  #   expires_in 3.hours, public: true, stale_while_revalidate: 60.seconds, stale_if_error: 5.minutes
  #
  # HTTP Cache-Control Extensions other values: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control
  # Any additional key-value pairs are concatenated onto the `Cache-Control` header in the response:
  #
  #   expires_in 3.hours, public: true, "s-maxage": 3.hours, "no-transform": true
  #
  # The method will also ensure an HTTP Date header for client compatibility.
  def expires_in(seconds, options = T.unsafe(nil)); end

  # Sets an HTTP 1.1 Cache-Control header of <tt>no-cache</tt>. This means the
  # resource will be marked as stale, so clients must always revalidate.
  # Intermediate/browser caches may still store the asset.
  def expires_now; end

  # Sets the +etag+, +last_modified+, or both on the response and renders a
  # <tt>304 Not Modified</tt> response if the request is already fresh.
  #
  # === Parameters:
  #
  # * <tt>:etag</tt> Sets a "weak" ETag validator on the response. See the
  #   +:weak_etag+ option.
  # * <tt>:weak_etag</tt> Sets a "weak" ETag validator on the response.
  #   Requests that set If-None-Match header may return a 304 Not Modified
  #   response if it matches the ETag exactly. A weak ETag indicates semantic
  #   equivalence, not byte-for-byte equality, so they're good for caching
  #   HTML pages in browser caches. They can't be used for responses that
  #   must be byte-identical, like serving Range requests within a PDF file.
  # * <tt>:strong_etag</tt> Sets a "strong" ETag validator on the response.
  #   Requests that set If-None-Match header may return a 304 Not Modified
  #   response if it matches the ETag exactly. A strong ETag implies exact
  #   equality: the response must match byte for byte. This is necessary for
  #   doing Range requests within a large video or PDF file, for example, or
  #   for compatibility with some CDNs that don't support weak ETags.
  # * <tt>:last_modified</tt> Sets a "weak" last-update validator on the
  #   response. Subsequent requests that set If-Modified-Since may return a
  #   304 Not Modified response if last_modified <= If-Modified-Since.
  # * <tt>:public</tt> By default the Cache-Control header is private, set this to
  #   +true+ if you want your application to be cacheable by other devices (proxy caches).
  # * <tt>:template</tt> By default, the template digest for the current
  #   controller/action is included in ETags. If the action renders a
  #   different template, you can include its digest instead. If the action
  #   doesn't render a template at all, you can pass <tt>template: false</tt>
  #   to skip any attempt to check for a template digest.
  #
  # === Example:
  #
  #   def show
  #     @article = Article.find(params[:id])
  #     fresh_when(etag: @article, last_modified: @article.updated_at, public: true)
  #   end
  #
  # This will render the show template if the request isn't sending a matching ETag or
  # If-Modified-Since header and just a <tt>304 Not Modified</tt> response if there's a match.
  #
  # You can also just pass a record. In this case +last_modified+ will be set
  # by calling +updated_at+ and +etag+ by passing the object itself.
  #
  #   def show
  #     @article = Article.find(params[:id])
  #     fresh_when(@article)
  #   end
  #
  # You can also pass an object that responds to +maximum+, such as a
  # collection of active records. In this case +last_modified+ will be set by
  # calling <tt>maximum(:updated_at)</tt> on the collection (the timestamp of the
  # most recently updated record) and the +etag+ by passing the object itself.
  #
  #   def index
  #     @articles = Article.all
  #     fresh_when(@articles)
  #   end
  #
  # When passing a record or a collection, you can still set the public header:
  #
  #   def show
  #     @article = Article.find(params[:id])
  #     fresh_when(@article, public: true)
  #   end
  #
  # When rendering a different template than the default controller/action
  # style, you can indicate which digest to include in the ETag:
  #
  #   before_action { fresh_when @article, template: 'widgets/show' }
  def fresh_when(object = T.unsafe(nil), etag: T.unsafe(nil), weak_etag: T.unsafe(nil), strong_etag: T.unsafe(nil), last_modified: T.unsafe(nil), public: T.unsafe(nil), template: T.unsafe(nil)); end

  # Cache or yield the block. The cache is supposed to never expire.
  #
  # You can use this method when you have an HTTP response that never changes,
  # and the browser and proxies should cache it indefinitely.
  #
  # * +public+: By default, HTTP responses are private, cached only on the
  #   user's web browser. To allow proxies to cache the response, set +true+ to
  #   indicate that they can serve the cached response to all users.
  def http_cache_forever(public: T.unsafe(nil)); end

  # Sets the +etag+ and/or +last_modified+ on the response and checks it against
  # the client request. If the request doesn't match the options provided, the
  # request is considered stale and should be generated from scratch. Otherwise,
  # it's fresh and we don't need to generate anything and a reply of <tt>304 Not Modified</tt> is sent.
  #
  # === Parameters:
  #
  # * <tt>:etag</tt> Sets a "weak" ETag validator on the response. See the
  #   +:weak_etag+ option.
  # * <tt>:weak_etag</tt> Sets a "weak" ETag validator on the response.
  #   Requests that set If-None-Match header may return a 304 Not Modified
  #   response if it matches the ETag exactly. A weak ETag indicates semantic
  #   equivalence, not byte-for-byte equality, so they're good for caching
  #   HTML pages in browser caches. They can't be used for responses that
  #   must be byte-identical, like serving Range requests within a PDF file.
  # * <tt>:strong_etag</tt> Sets a "strong" ETag validator on the response.
  #   Requests that set If-None-Match header may return a 304 Not Modified
  #   response if it matches the ETag exactly. A strong ETag implies exact
  #   equality: the response must match byte for byte. This is necessary for
  #   doing Range requests within a large video or PDF file, for example, or
  #   for compatibility with some CDNs that don't support weak ETags.
  # * <tt>:last_modified</tt> Sets a "weak" last-update validator on the
  #   response. Subsequent requests that set If-Modified-Since may return a
  #   304 Not Modified response if last_modified <= If-Modified-Since.
  # * <tt>:public</tt> By default the Cache-Control header is private, set this to
  #   +true+ if you want your application to be cacheable by other devices (proxy caches).
  # * <tt>:template</tt> By default, the template digest for the current
  #   controller/action is included in ETags. If the action renders a
  #   different template, you can include its digest instead. If the action
  #   doesn't render a template at all, you can pass <tt>template: false</tt>
  #   to skip any attempt to check for a template digest.
  #
  # === Example:
  #
  #   def show
  #     @article = Article.find(params[:id])
  #
  #     if stale?(etag: @article, last_modified: @article.updated_at)
  #       @statistics = @article.really_expensive_call
  #       respond_to do |format|
  #         # all the supported formats
  #       end
  #     end
  #   end
  #
  # You can also just pass a record. In this case +last_modified+ will be set
  # by calling +updated_at+ and +etag+ by passing the object itself.
  #
  #   def show
  #     @article = Article.find(params[:id])
  #
  #     if stale?(@article)
  #       @statistics = @article.really_expensive_call
  #       respond_to do |format|
  #         # all the supported formats
  #       end
  #     end
  #   end
  #
  # You can also pass an object that responds to +maximum+, such as a
  # collection of active records. In this case +last_modified+ will be set by
  # calling <tt>maximum(:updated_at)</tt> on the collection (the timestamp of the
  # most recently updated record) and the +etag+ by passing the object itself.
  #
  #   def index
  #     @articles = Article.all
  #
  #     if stale?(@articles)
  #       @statistics = @articles.really_expensive_call
  #       respond_to do |format|
  #         # all the supported formats
  #       end
  #     end
  #   end
  #
  # When passing a record or a collection, you can still set the public header:
  #
  #   def show
  #     @article = Article.find(params[:id])
  #
  #     if stale?(@article, public: true)
  #       @statistics = @article.really_expensive_call
  #       respond_to do |format|
  #         # all the supported formats
  #       end
  #     end
  #   end
  #
  # When rendering a different template than the default controller/action
  # style, you can indicate which digest to include in the ETag:
  #
  #   def show
  #     super if stale? @article, template: 'widgets/show'
  #   end
  #
  # @return [Boolean]
  def stale?(object = T.unsafe(nil), **freshness_kwargs); end

  private

  def combine_etags(validator, options); end

  module GeneratedClassMethods
    def etaggers; end
    def etaggers=(value); end
    def etaggers?; end
  end

  module GeneratedInstanceMethods
    def etaggers; end
    def etaggers=(value); end
    def etaggers?; end
  end
end

module ActionController::ConditionalGet::ClassMethods
  # Allows you to consider additional controller-wide information when generating an ETag.
  # For example, if you serve pages tailored depending on who's logged in at the moment, you
  # may want to add the current user id to be part of the ETag to prevent unauthorized displaying
  # of cached pages.
  #
  #   class InvoicesController < ApplicationController
  #     etag { current_user&.id }
  #
  #     def show
  #       # Etag will differ even for the same invoice when it's viewed by a different current_user
  #       @invoice = Invoice.find(params[:id])
  #       fresh_when etag: @invoice
  #     end
  #   end
  def etag(&etagger); end
end

module ActionController::ContentSecurityPolicy
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods
  include ::AbstractController::Helpers
  include ::ActiveSupport::Callbacks
  include ::AbstractController::Callbacks

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::AbstractController::Helpers::ClassMethods
  mixes_in_class_methods ::ActiveSupport::Callbacks::ClassMethods
  mixes_in_class_methods ::ActiveSupport::DescendantsTracker
  mixes_in_class_methods ::AbstractController::Callbacks::ClassMethods
  mixes_in_class_methods ::ActionController::ContentSecurityPolicy::ClassMethods

  private

  # @return [Boolean]
  def content_security_policy?; end

  def content_security_policy_nonce; end
  def current_content_security_policy; end

  module GeneratedClassMethods
    def __callbacks; end
    def __callbacks=(value); end
    def __callbacks?; end
    def _helper_methods; end
    def _helper_methods=(value); end
    def _helper_methods?; end
  end

  module GeneratedInstanceMethods
    def __callbacks; end
    def __callbacks?; end
    def _helper_methods; end
    def _helper_methods=(value); end
    def _helper_methods?; end
  end
end

module ActionController::ContentSecurityPolicy::ClassMethods
  def content_security_policy(enabled = T.unsafe(nil), **options, &block); end
  def content_security_policy_report_only(report_only = T.unsafe(nil), **options); end
end

module ActionController::Cookies
  extend ::ActiveSupport::Concern

  private

  # The cookies for the current request. See ActionDispatch::Cookies for
  # more information.
  def cookies; end
end

# Methods for sending arbitrary data and for streaming files to the browser,
# instead of rendering.
module ActionController::DataStreaming
  extend ::ActiveSupport::Concern
  include ::ActionController::Rendering

  mixes_in_class_methods ::ActionController::Rendering::ClassMethods

  private

  # Sends the given binary data to the browser. This method is similar to
  # <tt>render plain: data</tt>, but also allows you to specify whether
  # the browser should display the response as a file attachment (i.e. in a
  # download dialog) or as inline data. You may also set the content type,
  # the file name, and other things.
  #
  # Options:
  # * <tt>:filename</tt> - suggests a filename for the browser to use.
  # * <tt>:type</tt> - specifies an HTTP content type. Defaults to 'application/octet-stream'.
  #   You can specify either a string or a symbol for a registered type with <tt>Mime::Type.register</tt>, for example :json.
  #   If omitted, type will be inferred from the file extension specified in <tt>:filename</tt>.
  #   If no content type is registered for the extension, the default type 'application/octet-stream' will be used.
  # * <tt>:disposition</tt> - specifies whether the file will be shown inline or downloaded.
  #   Valid values are 'inline' and 'attachment' (default).
  # * <tt>:status</tt> - specifies the status code to send with the response. Defaults to 200.
  #
  # Generic data download:
  #
  #   send_data buffer
  #
  # Download a dynamically-generated tarball:
  #
  #   send_data generate_tgz('dir'), filename: 'dir.tgz'
  #
  # Display an image Active Record in the browser:
  #
  #   send_data image.data, type: image.content_type, disposition: 'inline'
  #
  # See +send_file+ for more information on HTTP Content-* headers and caching.
  def send_data(data, options = T.unsafe(nil)); end

  # Sends the file. This uses a server-appropriate method (such as X-Sendfile)
  # via the Rack::Sendfile middleware. The header to use is set via
  # +config.action_dispatch.x_sendfile_header+.
  # Your server can also configure this for you by setting the X-Sendfile-Type header.
  #
  # Be careful to sanitize the path parameter if it is coming from a web
  # page. <tt>send_file(params[:path])</tt> allows a malicious user to
  # download any file on your server.
  #
  # Options:
  # * <tt>:filename</tt> - suggests a filename for the browser to use.
  #   Defaults to <tt>File.basename(path)</tt>.
  # * <tt>:type</tt> - specifies an HTTP content type.
  #   You can specify either a string or a symbol for a registered type with <tt>Mime::Type.register</tt>, for example :json.
  #   If omitted, the type will be inferred from the file extension specified in <tt>:filename</tt>.
  #   If no content type is registered for the extension, the default type 'application/octet-stream' will be used.
  # * <tt>:disposition</tt> - specifies whether the file will be shown inline or downloaded.
  #   Valid values are 'inline' and 'attachment' (default).
  # * <tt>:status</tt> - specifies the status code to send with the response. Defaults to 200.
  # * <tt>:url_based_filename</tt> - set to +true+ if you want the browser to guess the filename from
  #   the URL, which is necessary for i18n filenames on certain browsers
  #   (setting <tt>:filename</tt> overrides this option).
  #
  # The default Content-Type and Content-Disposition headers are
  # set to download arbitrary binary files in as many browsers as
  # possible. IE versions 4, 5, 5.5, and 6 are all known to have
  # a variety of quirks (especially when downloading over SSL).
  #
  # Simple download:
  #
  #   send_file '/path/to.zip'
  #
  # Show a JPEG in the browser:
  #
  #   send_file '/path/to.jpeg', type: 'image/jpeg', disposition: 'inline'
  #
  # Show a 404 page in the browser:
  #
  #   send_file '/path/to/404.html', type: 'text/html; charset=utf-8', disposition: 'inline', status: 404
  #
  # Read about the other Content-* HTTP headers if you'd like to
  # provide the user with more information (such as Content-Description) in
  # https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.11.
  #
  # Also be aware that the document may be cached by proxies and browsers.
  # The Pragma and Cache-Control headers declare how the file may be cached
  # by intermediaries. They default to require clients to validate with
  # the server before releasing cached responses. See
  # https://www.mnot.net/cache_docs/ for an overview of web caching and
  # https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.9
  # for the Cache-Control header spec.
  #
  # @raise [MissingFile]
  def send_file(path, options = T.unsafe(nil)); end

  # @raise [ArgumentError]
  def send_file_headers!(options); end
end

ActionController::DataStreaming::DEFAULT_SEND_FILE_DISPOSITION = T.let(T.unsafe(nil), String)
ActionController::DataStreaming::DEFAULT_SEND_FILE_TYPE = T.let(T.unsafe(nil), String)

# Allows configuring default headers that will be automatically merged into
# each response.
module ActionController::DefaultHeaders
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::ActionController::DefaultHeaders::ClassMethods
end

module ActionController::DefaultHeaders::ClassMethods
  def make_response!(request); end
end

# When you're using the flash, it's generally used as a conditional on the view.
# This means the content of the view depends on the flash. Which in turn means
# that the ETag for a response should be computed with the content of the flash
# in mind. This does that by including the content of the flash as a component
# in the ETag that's generated for a response.
module ActionController::EtagWithFlash
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods
  include ::ActionController::ConditionalGet

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::ActionController::ConditionalGet::ClassMethods

  module GeneratedClassMethods
    def etaggers; end
    def etaggers=(value); end
    def etaggers?; end
  end

  module GeneratedInstanceMethods
    def etaggers; end
    def etaggers=(value); end
    def etaggers?; end
  end
end

# When our views change, they should bubble up into HTTP cache freshness
# and bust browser caches. So the template digest for the current action
# is automatically included in the ETag.
#
# Enabled by default for apps that use Action View. Disable by setting
#
#   config.action_controller.etag_with_template_digest = false
#
# Override the template to digest by passing +:template+ to +fresh_when+
# and +stale?+ calls. For example:
#
#   # We're going to render widgets/show, not posts/show
#   fresh_when @post, template: 'widgets/show'
#
#   # We're not going to render a template, so omit it from the ETag.
#   fresh_when @post, template: false
module ActionController::EtagWithTemplateDigest
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods
  include ::ActionController::ConditionalGet

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::ActionController::ConditionalGet::ClassMethods

  private

  def determine_template_etag(options); end
  def lookup_and_digest_template(template); end

  # Pick the template digest to include in the ETag. If the +:template+ option
  # is present, use the named template. If +:template+ is +nil+ or absent, use
  # the default controller/action template. If +:template+ is false, omit the
  # template digest from the ETag.
  def pick_template_for_etag(options); end

  module GeneratedClassMethods
    def etag_with_template_digest; end
    def etag_with_template_digest=(value); end
    def etag_with_template_digest?; end
    def etaggers; end
    def etaggers=(value); end
    def etaggers?; end
  end

  module GeneratedInstanceMethods
    def etag_with_template_digest; end
    def etag_with_template_digest=(value); end
    def etag_with_template_digest?; end
    def etaggers; end
    def etaggers=(value); end
    def etaggers?; end
  end
end

module ActionController::Flash
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::ActionController::Flash::ClassMethods

  private

  def redirect_to(options = T.unsafe(nil), response_options_and_flash = T.unsafe(nil)); end

  module GeneratedClassMethods
    def _flash_types; end
    def _flash_types=(value); end
    def _flash_types?; end
  end

  module GeneratedInstanceMethods; end
end

module ActionController::Flash::ClassMethods
  # Creates new flash types. You can pass as many types as you want to create
  # flash types other than the default <tt>alert</tt> and <tt>notice</tt> in
  # your controllers and views. For instance:
  #
  #   # in application_controller.rb
  #   class ApplicationController < ActionController::Base
  #     add_flash_types :warning
  #   end
  #
  #   # in your controller
  #   redirect_to user_path(@user), warning: "Incomplete profile"
  #
  #   # in your view
  #   <%= warning %>
  #
  # This method will automatically define a new method for each of the given
  # names, and it will be available in your views.
  def add_flash_types(*types); end
end

# Override the default form builder for all views rendered by this
# controller and any of its descendants. Accepts a subclass of
# +ActionView::Helpers::FormBuilder+.
#
# For example, given a form builder:
#
#   class AdminFormBuilder < ActionView::Helpers::FormBuilder
#     def special_field(name)
#     end
#   end
#
# The controller specifies a form builder as its default:
#
#   class AdminAreaController < ApplicationController
#     default_form_builder AdminFormBuilder
#   end
#
# Then in the view any form using +form_for+ will be an instance of the
# specified form builder:
#
#   <%= form_for(@instance) do |builder| %>
#     <%= builder.special_field(:name) %>
#   <% end %>
module ActionController::FormBuilder
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::ActionController::FormBuilder::ClassMethods

  # Default form builder for the controller
  def default_form_builder; end

  module GeneratedClassMethods
    def _default_form_builder; end
    def _default_form_builder=(value); end
    def _default_form_builder?; end
  end

  module GeneratedInstanceMethods; end
end

module ActionController::FormBuilder::ClassMethods
  # Set the form builder to be used as the default for all forms
  # in the views rendered by this controller and its subclasses.
  #
  # ==== Parameters
  # * <tt>builder</tt> - Default form builder, an instance of +ActionView::Helpers::FormBuilder+
  def default_form_builder(builder); end
end

module ActionController::Head
  # Returns a response that has no content (merely headers). The options
  # argument is interpreted to be a hash of header names and values.
  # This allows you to easily return a response that consists only of
  # significant headers:
  #
  #   head :created, location: person_path(@person)
  #
  #   head :created, location: @person
  #
  # It can also be used to return exceptional conditions:
  #
  #   return head(:method_not_allowed) unless request.post?
  #   return head(:bad_request) unless valid_request?
  #   render
  #
  # See Rack::Utils::SYMBOL_TO_STATUS_CODE for a full list of valid +status+ symbols.
  def head(status, options = T.unsafe(nil)); end

  private

  # @return [Boolean]
  def include_content?(status); end
end

# The \Rails framework provides a large number of helpers for working with assets, dates, forms,
# numbers and model objects, to name a few. These helpers are available to all templates
# by default.
#
# In addition to using the standard template helpers provided, creating custom helpers to
# extract complicated logic or reusable functionality is strongly encouraged. By default, each controller
# will include all helpers. These helpers are only accessible on the controller through <tt>#helpers</tt>
#
# In previous versions of \Rails the controller will include a helper which
# matches the name of the controller, e.g., <tt>MyController</tt> will automatically
# include <tt>MyHelper</tt>. You can revert to the old behavior with the following:
#
#    # config/application.rb
#    class Application < Rails::Application
#      config.action_controller.include_all_helpers = false
#    end
#
# Additional helpers can be specified using the +helper+ class method in ActionController::Base or any
# controller which inherits from it.
#
# The +to_s+ method from the \Time class can be wrapped in a helper method to display a custom message if
# a \Time object is blank:
#
#   module FormattedTimeHelper
#     def format_time(time, format=:long, blank_message="&nbsp;")
#       time.blank? ? blank_message : time.to_s(format)
#     end
#   end
#
# FormattedTimeHelper can now be included in a controller, using the +helper+ class method:
#
#   class EventsController < ActionController::Base
#     helper FormattedTimeHelper
#     def index
#       @events = Event.all
#     end
#   end
#
# Then, in any view rendered by <tt>EventsController</tt>, the <tt>format_time</tt> method can be called:
#
#   <% @events.each do |event| -%>
#     <p>
#       <%= format_time(event.time, :short, "N/A") %> | <%= event.name %>
#     </p>
#   <% end -%>
#
# Finally, assuming we have two event instances, one which has a time and one which does not,
# the output might look like this:
#
#   23 Aug 11:30 | Carolina Railhawks Soccer Match
#   N/A | Carolina Railhawks Training Workshop
module ActionController::Helpers
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods
  include ::AbstractController::Helpers

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::AbstractController::Helpers::ClassMethods
  mixes_in_class_methods ::ActionController::Helpers::ClassMethods

  # Provides a proxy to access helper methods from outside the view.
  def helpers; end

  class << self
    # Returns the value of attribute helpers_path.
    def helpers_path; end

    # Sets the attribute helpers_path
    #
    # @param value the value to set the attribute helpers_path to.
    def helpers_path=(_arg0); end
  end

  module GeneratedClassMethods
    def _helper_methods; end
    def _helper_methods=(value); end
    def _helper_methods?; end
    def helpers_path; end
    def helpers_path=(value); end
    def helpers_path?; end
    def include_all_helpers; end
    def include_all_helpers=(value); end
    def include_all_helpers?; end
  end

  module GeneratedInstanceMethods
    def _helper_methods; end
    def _helper_methods=(value); end
    def _helper_methods?; end
    def helpers_path; end
    def helpers_path=(value); end
    def helpers_path?; end
    def include_all_helpers; end
    def include_all_helpers=(value); end
    def include_all_helpers?; end
  end
end

module ActionController::Helpers::ClassMethods
  # Returns a list of helper names in a given path.
  #
  #   ActionController::Base.all_helpers_from_path 'app/helpers'
  #   # => ["application", "chart", "rubygems"]
  def all_helpers_from_path(path); end

  # Declares helper accessors for controller attributes. For example, the
  # following adds new +name+ and <tt>name=</tt> instance methods to a
  # controller and makes them available to the view:
  #   attr_accessor :name
  #   helper_attr :name
  #
  # ==== Parameters
  # * <tt>attrs</tt> - Names of attributes to be converted into helpers.
  def helper_attr(*attrs); end

  # Provides a proxy to access helper methods from outside the view.
  #
  # Note that the proxy is rendered under a different view context.
  # This may cause incorrect behaviour with capture methods. Consider
  # using {helper}[rdoc-ref:AbstractController::Helpers::ClassMethods#helper]
  # instead when using +capture+.
  def helpers; end

  # Overwrite modules_for_helpers to accept :all as argument, which loads
  # all helpers in helpers_path.
  #
  # ==== Parameters
  # * <tt>args</tt> - A list of helpers
  #
  # ==== Returns
  # * <tt>array</tt> - A normalized list of modules for the list of helpers provided.
  def modules_for_helpers(args); end

  private

  # Extract helper names from files in <tt>app/helpers/**/*_helper.rb</tt>
  def all_application_helpers; end
end

# Makes it dead easy to do HTTP Basic, Digest and Token authentication.
module ActionController::HttpAuthentication; end

# Makes it dead easy to do HTTP \Basic authentication.
#
# === Simple \Basic example
#
#   class PostsController < ApplicationController
#     http_basic_authenticate_with name: "dhh", password: "secret", except: :index
#
#     def index
#       render plain: "Everyone can see me!"
#     end
#
#     def edit
#       render plain: "I'm only accessible if you know the password"
#     end
#  end
#
# === Advanced \Basic example
#
# Here is a more advanced \Basic example where only Atom feeds and the XML API is protected by HTTP authentication,
# the regular HTML interface is protected by a session approach:
#
#   class ApplicationController < ActionController::Base
#     before_action :set_account, :authenticate
#
#     private
#       def set_account
#         @account = Account.find_by(url_name: request.subdomains.first)
#       end
#
#       def authenticate
#         case request.format
#         when Mime[:xml], Mime[:atom]
#           if user = authenticate_with_http_basic { |u, p| @account.users.authenticate(u, p) }
#             @current_user = user
#           else
#             request_http_basic_authentication
#           end
#         else
#           if session_authenticated?
#             @current_user = @account.users.find(session[:authenticated][:user_id])
#           else
#             redirect_to(login_url) and return false
#           end
#         end
#       end
#   end
#
# In your integration tests, you can do something like this:
#
#   def test_access_granted_from_xml
#     authorization = ActionController::HttpAuthentication::Basic.encode_credentials(users(:dhh).name, users(:dhh).password)
#
#     get "/notes/1.xml", headers: { 'HTTP_AUTHORIZATION' => authorization }
#
#     assert_equal 200, status
#   end
module ActionController::HttpAuthentication::Basic
  extend ::ActionController::HttpAuthentication::Basic

  def auth_param(request); end
  def auth_scheme(request); end
  def authenticate(request, &login_procedure); end
  def authentication_request(controller, realm, message); end
  def decode_credentials(request); end
  def encode_credentials(user_name, password); end

  # @return [Boolean]
  def has_basic_credentials?(request); end

  def user_name_and_password(request); end
end

module ActionController::HttpAuthentication::Basic::ControllerMethods
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::ActionController::HttpAuthentication::Basic::ControllerMethods::ClassMethods

  def authenticate_or_request_with_http_basic(realm = T.unsafe(nil), message = T.unsafe(nil), &login_procedure); end
  def authenticate_with_http_basic(&login_procedure); end
  def http_basic_authenticate_or_request_with(name:, password:, realm: T.unsafe(nil), message: T.unsafe(nil)); end
  def request_http_basic_authentication(realm = T.unsafe(nil), message = T.unsafe(nil)); end
end

module ActionController::HttpAuthentication::Basic::ControllerMethods::ClassMethods
  def http_basic_authenticate_with(name:, password:, realm: T.unsafe(nil), **options); end
end

# Makes it dead easy to do HTTP \Digest authentication.
#
# === Simple \Digest example
#
#   require "digest/md5"
#   class PostsController < ApplicationController
#     REALM = "SuperSecret"
#     USERS = {"dhh" => "secret", #plain text password
#              "dap" => Digest::MD5.hexdigest(["dap",REALM,"secret"].join(":"))}  #ha1 digest password
#
#     before_action :authenticate, except: [:index]
#
#     def index
#       render plain: "Everyone can see me!"
#     end
#
#     def edit
#       render plain: "I'm only accessible if you know the password"
#     end
#
#     private
#       def authenticate
#         authenticate_or_request_with_http_digest(REALM) do |username|
#           USERS[username]
#         end
#       end
#   end
#
# === Notes
#
# The +authenticate_or_request_with_http_digest+ block must return the user's password
# or the ha1 digest hash so the framework can appropriately hash to check the user's
# credentials. Returning +nil+ will cause authentication to fail.
#
# Storing the ha1 hash: MD5(username:realm:password), is better than storing a plain password. If
# the password file or database is compromised, the attacker would be able to use the ha1 hash to
# authenticate as the user at this +realm+, but would not have the user's password to try using at
# other sites.
#
# In rare instances, web servers or front proxies strip authorization headers before
# they reach your application. You can debug this situation by logging all environment
# variables, and check for HTTP_AUTHORIZATION, amongst others.
module ActionController::HttpAuthentication::Digest
  extend ::ActionController::HttpAuthentication::Digest

  # Returns false on a valid response, true otherwise
  def authenticate(request, realm, &password_procedure); end

  def authentication_header(controller, realm); end
  def authentication_request(controller, realm, message = T.unsafe(nil)); end
  def decode_credentials(header); end
  def decode_credentials_header(request); end
  def encode_credentials(http_method, credentials, password, password_is_ha1); end

  # Returns the expected response for a request of +http_method+ to +uri+ with the decoded +credentials+ and the expected +password+
  # Optional parameter +password_is_ha1+ is set to +true+ by default, since best practice is to store ha1 digest instead
  # of a plain-text password.
  def expected_response(http_method, uri, credentials, password, password_is_ha1 = T.unsafe(nil)); end

  def ha1(credentials, password); end

  # Uses an MD5 digest based on time to generate a value to be used only once.
  #
  # A server-specified data string which should be uniquely generated each time a 401 response is made.
  # It is recommended that this string be base64 or hexadecimal data.
  # Specifically, since the string is passed in the header lines as a quoted string, the double-quote character is not allowed.
  #
  # The contents of the nonce are implementation dependent.
  # The quality of the implementation depends on a good choice.
  # A nonce might, for example, be constructed as the base 64 encoding of
  #
  #   time-stamp H(time-stamp ":" ETag ":" private-key)
  #
  # where time-stamp is a server-generated time or other non-repeating value,
  # ETag is the value of the HTTP ETag header associated with the requested entity,
  # and private-key is data known only to the server.
  # With a nonce of this form a server would recalculate the hash portion after receiving the client authentication header and
  # reject the request if it did not match the nonce from that header or
  # if the time-stamp value is not recent enough. In this way the server can limit the time of the nonce's validity.
  # The inclusion of the ETag prevents a replay request for an updated version of the resource.
  # (Note: including the IP address of the client in the nonce would appear to offer the server the ability
  # to limit the reuse of the nonce to the same client that originally got it.
  # However, that would break proxy farms, where requests from a single user often go through different proxies in the farm.
  # Also, IP address spoofing is not that hard.)
  #
  # An implementation might choose not to accept a previously used nonce or a previously used digest, in order to
  # protect against a replay attack. Or, an implementation might choose to use one-time nonces or digests for
  # POST, PUT, or PATCH requests and a time-stamp for GET requests. For more details on the issues involved see Section 4
  # of this document.
  #
  # The nonce is opaque to the client. Composed of Time, and hash of Time with secret
  # key from the Rails session secret generated upon creation of project. Ensures
  # the time cannot be modified by client.
  def nonce(secret_key, time = T.unsafe(nil)); end

  # Opaque based on digest of secret key
  def opaque(secret_key); end

  def secret_token(request); end

  # Returns false unless the request credentials response value matches the expected value.
  # First try the password as a ha1 digest password. If this fails, then try it as a plain
  # text password.
  def validate_digest_response(request, realm, &password_procedure); end

  # Might want a shorter timeout depending on whether the request
  # is a PATCH, PUT, or POST, and if the client is a browser or web service.
  # Can be much shorter if the Stale directive is implemented. This would
  # allow a user to use new nonce without prompting the user again for their
  # username and password.
  def validate_nonce(secret_key, request, value, seconds_to_timeout = T.unsafe(nil)); end
end

module ActionController::HttpAuthentication::Digest::ControllerMethods
  def authenticate_or_request_with_http_digest(realm = T.unsafe(nil), message = T.unsafe(nil), &password_procedure); end

  # Authenticate with HTTP Digest, returns true or false
  def authenticate_with_http_digest(realm = T.unsafe(nil), &password_procedure); end

  # Render output including the HTTP Digest authentication header
  def request_http_digest_authentication(realm = T.unsafe(nil), message = T.unsafe(nil)); end
end

# Makes it dead easy to do HTTP Token authentication.
#
# Simple Token example:
#
#   class PostsController < ApplicationController
#     TOKEN = "secret"
#
#     before_action :authenticate, except: [ :index ]
#
#     def index
#       render plain: "Everyone can see me!"
#     end
#
#     def edit
#       render plain: "I'm only accessible if you know the password"
#     end
#
#     private
#       def authenticate
#         authenticate_or_request_with_http_token do |token, options|
#           # Compare the tokens in a time-constant manner, to mitigate
#           # timing attacks.
#           ActiveSupport::SecurityUtils.secure_compare(token, TOKEN)
#         end
#       end
#   end
#
#
# Here is a more advanced Token example where only Atom feeds and the XML API is protected by HTTP token authentication,
# the regular HTML interface is protected by a session approach:
#
#   class ApplicationController < ActionController::Base
#     before_action :set_account, :authenticate
#
#     private
#       def set_account
#         @account = Account.find_by(url_name: request.subdomains.first)
#       end
#
#       def authenticate
#         case request.format
#         when Mime[:xml], Mime[:atom]
#           if user = authenticate_with_http_token { |t, o| @account.users.authenticate(t, o) }
#             @current_user = user
#           else
#             request_http_token_authentication
#           end
#         else
#           if session_authenticated?
#             @current_user = @account.users.find(session[:authenticated][:user_id])
#           else
#             redirect_to(login_url) and return false
#           end
#         end
#       end
#   end
#
#
# In your integration tests, you can do something like this:
#
#   def test_access_granted_from_xml
#     authorization = ActionController::HttpAuthentication::Token.encode_credentials(users(:dhh).token)
#
#     get "/notes/1.xml", headers: { 'HTTP_AUTHORIZATION' => authorization }
#
#     assert_equal 200, status
#   end
#
#
# On shared hosts, Apache sometimes doesn't pass authentication headers to
# FCGI instances. If your environment matches this description and you cannot
# authenticate, try this rule in your Apache setup:
#
#   RewriteRule ^(.*)$ dispatch.fcgi [E=X-HTTP_AUTHORIZATION:%{HTTP:Authorization},QSA,L]
module ActionController::HttpAuthentication::Token
  extend ::ActionController::HttpAuthentication::Token

  # If token Authorization header is present, call the login
  # procedure with the present token and options.
  #
  # [controller]
  #   ActionController::Base instance for the current request.
  #
  # [login_procedure]
  #   Proc to call if a token is present. The Proc should take two arguments:
  #
  #     authenticate(controller) { |token, options| ... }
  #
  # Returns the return value of <tt>login_procedure</tt> if a
  # token is found. Returns <tt>nil</tt> if no token is found.
  def authenticate(controller, &login_procedure); end

  # Sets a WWW-Authenticate header to let the client know a token is desired.
  #
  # controller - ActionController::Base instance for the outgoing response.
  # realm      - String realm to use in the header.
  #
  # Returns nothing.
  def authentication_request(controller, realm, message = T.unsafe(nil)); end

  # Encodes the given token and options into an Authorization header value.
  #
  # token   - String token.
  # options - optional Hash of the options.
  #
  # Returns String.
  def encode_credentials(token, options = T.unsafe(nil)); end

  # Takes raw_params and turns it into an array of parameters
  def params_array_from(raw_params); end

  # This method takes an authorization body and splits up the key-value
  # pairs by the standardized <tt>:</tt>, <tt>;</tt>, or <tt>\t</tt>
  # delimiters defined in +AUTHN_PAIR_DELIMITERS+.
  def raw_params(auth); end

  # This removes the <tt>"</tt> characters wrapping the value.
  def rewrite_param_values(array_params); end

  # Parses the token and options out of the token Authorization header.
  # The value for the Authorization header is expected to have the prefix
  # <tt>"Token"</tt> or <tt>"Bearer"</tt>. If the header looks like this:
  #   Authorization: Token token="abc", nonce="def"
  # Then the returned token is <tt>"abc"</tt>, and the options are
  # <tt>{nonce: "def"}</tt>
  #
  # request - ActionDispatch::Request instance with the current headers.
  #
  # Returns an +Array+ of <tt>[String, Hash]</tt> if a token is present.
  # Returns +nil+ if no token is found.
  def token_and_options(request); end

  def token_params_from(auth); end
end

ActionController::HttpAuthentication::Token::AUTHN_PAIR_DELIMITERS = T.let(T.unsafe(nil), Regexp)

module ActionController::HttpAuthentication::Token::ControllerMethods
  def authenticate_or_request_with_http_token(realm = T.unsafe(nil), message = T.unsafe(nil), &login_procedure); end
  def authenticate_with_http_token(&login_procedure); end
  def request_http_token_authentication(realm = T.unsafe(nil), message = T.unsafe(nil)); end
end

ActionController::HttpAuthentication::Token::TOKEN_KEY = T.let(T.unsafe(nil), String)
ActionController::HttpAuthentication::Token::TOKEN_REGEX = T.let(T.unsafe(nil), Regexp)

# Handles implicit rendering for a controller action that does not
# explicitly respond with +render+, +respond_to+, +redirect+, or +head+.
#
# For API controllers, the implicit response is always <tt>204 No Content</tt>.
#
# For all other controllers, we use these heuristics to decide whether to
# render a template, raise an error for a missing template, or respond with
# <tt>204 No Content</tt>:
#
# First, if we DO find a template, it's rendered. Template lookup accounts
# for the action name, locales, format, variant, template handlers, and more
# (see +render+ for details).
#
# Second, if we DON'T find a template but the controller action does have
# templates for other formats, variants, etc., then we trust that you meant
# to provide a template for this response, too, and we raise
# <tt>ActionController::UnknownFormat</tt> with an explanation.
#
# Third, if we DON'T find a template AND the request is a page load in a web
# browser (technically, a non-XHR GET request for an HTML response) where
# you reasonably expect to have rendered a template, then we raise
# <tt>ActionController::MissingExactTemplate</tt> with an explanation.
#
# Finally, if we DON'T find a template AND the request isn't a browser page
# load, then we implicitly respond with <tt>204 No Content</tt>.
module ActionController::ImplicitRender
  include ::ActionController::BasicImplicitRender

  def default_render; end
  def method_for_action(action_name); end

  private

  # @return [Boolean]
  def interactive_browser_request?; end
end

# Adds instrumentation to several ends in ActionController::Base. It also provides
# some hooks related with process_action. This allows an ORM like Active Record
# and/or DataMapper to plug in ActionController and show related information.
#
# Check ActiveRecord::Railties::ControllerRuntime for an example.
module ActionController::Instrumentation
  extend ::ActiveSupport::Concern
  include ::ActiveSupport::Benchmarkable
  include ::AbstractController::Logger

  mixes_in_class_methods ::ActionController::Instrumentation::ClassMethods

  def process_action(*_arg0); end
  def redirect_to(*_arg0); end
  def render(*_arg0); end
  def send_data(data, options = T.unsafe(nil)); end
  def send_file(path, options = T.unsafe(nil)); end
  def view_runtime; end
  def view_runtime=(_arg0); end

  private

  # Every time after an action is processed, this method is invoked
  # with the payload, so you can add more information.
  def append_info_to_payload(payload); end

  # A hook which allows you to clean up any time, wrongly taken into account in
  # views, like database querying time.
  #
  #   def cleanup_view_runtime
  #     super - time_taken_in_something_expensive
  #   end
  def cleanup_view_runtime; end

  # A hook invoked every time a before callback is halted.
  def halted_callback_hook(filter, _); end
end

module ActionController::Instrumentation::ClassMethods
  # A hook which allows other frameworks to log what happened during
  # controller process action. This method should return an array
  # with the messages to be added.
  def log_process_action(payload); end
end

class ActionController::InvalidAuthenticityToken < ::ActionController::ActionControllerError; end
class ActionController::InvalidCrossOriginRequest < ::ActionController::ActionControllerError; end

# Mix this module into your controller, and all actions in that controller
# will be able to stream data to the client as it's written.
#
#   class MyController < ActionController::Base
#     include ActionController::Live
#
#     def stream
#       response.headers['Content-Type'] = 'text/event-stream'
#       100.times {
#         response.stream.write "hello world\n"
#         sleep 1
#       }
#     ensure
#       response.stream.close
#     end
#   end
#
# There are a few caveats with this module. You *cannot* write headers after the
# response has been committed (Response#committed? will return truthy).
# Calling +write+ or +close+ on the response stream will cause the response
# object to be committed. Make sure all headers are set before calling write
# or close on your stream.
#
# You *must* call close on your stream when you're finished, otherwise the
# socket may be left open forever.
#
# The final caveat is that your actions are executed in a separate thread than
# the main thread. Make sure your actions are thread safe, and this shouldn't
# be a problem (don't share state across threads, etc).
module ActionController::Live
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::ActionController::Live::ClassMethods

  def new_controller_thread; end
  def process(name); end
  def response_body=(body); end

  private

  def log_error(exception); end
end

class ActionController::Live::Buffer < ::ActionDispatch::Response::Buffer
  include ::MonitorMixin

  # @return [Buffer] a new instance of Buffer
  def initialize(response); end

  # Inform the producer/writing thread that the client has
  # disconnected; the reading thread is no longer interested in
  # anything that's being written.
  #
  # See also #close.
  def abort; end

  def call_on_error; end

  # Write a 'close' event to the buffer; the producer/writing thread
  # uses this to notify us that it's finished supplying content.
  #
  # See also #abort.
  def close; end

  # Is the client still connected and waiting for content?
  #
  # The result of calling `write` when this is `false` is determined
  # by `ignore_disconnect`.
  #
  # @return [Boolean]
  def connected?; end

  # Ignore that the client has disconnected.
  #
  # If this value is `true`, calling `write` after the client
  # disconnects will result in the written content being silently
  # discarded. If this value is `false` (the default), a
  # ClientDisconnected exception will be raised.
  def ignore_disconnect; end

  # Ignore that the client has disconnected.
  #
  # If this value is `true`, calling `write` after the client
  # disconnects will result in the written content being silently
  # discarded. If this value is `false` (the default), a
  # ClientDisconnected exception will be raised.
  def ignore_disconnect=(_arg0); end

  def on_error(&block); end
  def write(string); end

  private

  def build_queue(queue_size); end
  def each_chunk(&block); end

  class << self
    # Returns the value of attribute queue_size.
    def queue_size; end

    # Sets the attribute queue_size
    #
    # @param value the value to set the attribute queue_size to.
    def queue_size=(_arg0); end
  end
end

module ActionController::Live::ClassMethods
  def make_response!(request); end
end

class ActionController::Live::ClientDisconnected < ::RuntimeError; end

class ActionController::Live::Response < ::ActionDispatch::Response
  private

  def before_committed; end
  def build_buffer(response, body); end
end

# This class provides the ability to write an SSE (Server Sent Event)
# to an IO stream. The class is initialized with a stream and can be used
# to either write a JSON string or an object which can be converted to JSON.
#
# Writing an object will convert it into standard SSE format with whatever
# options you have configured. You may choose to set the following options:
#
#   1) Event. If specified, an event with this name will be dispatched on
#   the browser.
#   2) Retry. The reconnection time in milliseconds used when attempting
#   to send the event.
#   3) Id. If the connection dies while sending an SSE to the browser, then
#   the server will receive a +Last-Event-ID+ header with value equal to +id+.
#
# After setting an option in the constructor of the SSE object, all future
# SSEs sent across the stream will use those options unless overridden.
#
# Example Usage:
#
#   class MyController < ActionController::Base
#     include ActionController::Live
#
#     def index
#       response.headers['Content-Type'] = 'text/event-stream'
#       sse = SSE.new(response.stream, retry: 300, event: "event-name")
#       sse.write({ name: 'John'})
#       sse.write({ name: 'John'}, id: 10)
#       sse.write({ name: 'John'}, id: 10, event: "other-event")
#       sse.write({ name: 'John'}, id: 10, event: "other-event", retry: 500)
#     ensure
#       sse.close
#     end
#   end
#
# Note: SSEs are not currently supported by IE. However, they are supported
# by Chrome, Firefox, Opera, and Safari.
class ActionController::Live::SSE
  # @return [SSE] a new instance of SSE
  def initialize(stream, options = T.unsafe(nil)); end

  def close; end
  def write(object, options = T.unsafe(nil)); end

  private

  def perform_write(json, options); end
end

ActionController::Live::SSE::PERMITTED_OPTIONS = T.let(T.unsafe(nil), Array)

class ActionController::LiveTestResponse < ::ActionController::Live::Response
  # Was there a server-side error?
  def error?; end

  # Was the URL not found?
  def missing?; end

  # Was the response successful?
  def success?; end
end

class ActionController::LogSubscriber < ::ActiveSupport::LogSubscriber
  def exist_fragment?(event); end
  def expire_fragment(event); end
  def expire_page(event); end
  def halted_callback(event); end
  def logger; end
  def process_action(event); end
  def read_fragment(event); end
  def redirect_to(event); end
  def send_data(event); end
  def send_file(event); end
  def start_processing(event); end
  def unpermitted_parameters(event); end
  def write_fragment(event); end
  def write_page(event); end
end

ActionController::LogSubscriber::INTERNAL_PARAMS = T.let(T.unsafe(nil), Array)

module ActionController::Logging
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::ActionController::Logging::ClassMethods
end

module ActionController::Logging::ClassMethods
  # Set a different log level per request.
  #
  #   # Use the debug log level if a particular cookie is set.
  #   class ApplicationController < ActionController::Base
  #     log_at :debug, if: -> { cookies[:debug] }
  #   end
  def log_at(level, **options); end
end

# <tt>ActionController::Metal</tt> is the simplest possible controller, providing a
# valid Rack interface without the additional niceties provided by
# <tt>ActionController::Base</tt>.
#
# A sample metal controller might look like this:
#
#   class HelloController < ActionController::Metal
#     def index
#       self.response_body = "Hello World!"
#     end
#   end
#
# And then to route requests to your metal controller, you would add
# something like this to <tt>config/routes.rb</tt>:
#
#   get 'hello', to: HelloController.action(:index)
#
# The +action+ method returns a valid Rack application for the \Rails
# router to dispatch to.
#
# == Rendering Helpers
#
# <tt>ActionController::Metal</tt> by default provides no utilities for rendering
# views, partials, or other responses aside from explicitly calling of
# <tt>response_body=</tt>, <tt>content_type=</tt>, and <tt>status=</tt>. To
# add the render helpers you're used to having in a normal controller, you
# can do the following:
#
#   class HelloController < ActionController::Metal
#     include AbstractController::Rendering
#     include ActionView::Layouts
#     append_view_path "#{Rails.root}/app/views"
#
#     def index
#       render "hello/index"
#     end
#   end
#
# == Redirection Helpers
#
# To add redirection helpers to your metal controller, do the following:
#
#   class HelloController < ActionController::Metal
#     include ActionController::Redirecting
#     include Rails.application.routes.url_helpers
#
#     def index
#       redirect_to root_url
#     end
#   end
#
# == Other Helpers
#
# You can refer to the modules included in <tt>ActionController::Base</tt> to see
# other features you can bring into your metal controller.
#
# @abstract It cannont be directly instantiated. Subclasses must implement the `abstract` methods below.
class ActionController::Metal < ::AbstractController::Base
  include ::ActionController::Testing::Functional

  # @return [Metal] a new instance of Metal
  def initialize; end

  def content_type(*_arg0, &_arg1); end
  def content_type=(arg); end

  # Delegates to the class' <tt>controller_name</tt>.
  def controller_name; end

  def dispatch(name, request, response); end
  def headers(*_arg0, &_arg1); end
  def location(*_arg0, &_arg1); end
  def location=(arg); end
  def media_type(*_arg0, &_arg1); end
  def middleware_stack; end
  def middleware_stack=(_arg0); end
  def middleware_stack?; end
  def params; end
  def params=(val); end

  # Tests if render or redirect has already happened.
  #
  # @return [Boolean]
  def performed?; end

  def request; end
  def request=(_arg0); end
  def reset_session; end
  def response; end
  def response=(_arg0); end
  def response_body=(body); end
  def response_code(*_arg0, &_arg1); end
  def session(*_arg0, &_arg1); end
  def set_request!(request); end
  def set_response!(response); end
  def status(*_arg0, &_arg1); end
  def status=(arg); end
  def to_a; end

  # Basic url_for that can be overridden for more robust functionality.
  def url_for(string); end

  class << self
    # Returns a Rack endpoint for the given action name.
    def action(name); end

    def action_encoding_template(action); end

    # Returns the last part of the controller's name, underscored, without the ending
    # <tt>Controller</tt>. For instance, PostsController returns <tt>posts</tt>.
    # Namespaces are left out, so Admin::PostsController returns <tt>posts</tt> as well.
    #
    # ==== Returns
    # * <tt>string</tt>
    def controller_name; end

    # Direct dispatch to the controller. Instantiates the controller, then
    # executes the action named +name+.
    def dispatch(name, req, res); end

    def inherited(base); end
    def make_response!(request); end

    # Alias for +middleware_stack+.
    def middleware; end

    def middleware_stack; end
    def middleware_stack=(value); end
    def middleware_stack?; end

    # Pushes the given Rack middleware and its arguments to the bottom of the
    # middleware stack.
    def use(*args, &block); end
  end
end

class ActionController::MethodNotAllowed < ::ActionController::ActionControllerError
  # @return [MethodNotAllowed] a new instance of MethodNotAllowed
  def initialize(*allowed_methods); end
end

# Extend ActionDispatch middleware stack to make it aware of options
# allowing the following syntax in controllers:
#
#   class PostsController < ApplicationController
#     use AuthenticationMiddleware, except: [:index, :show]
#   end
class ActionController::MiddlewareStack < ::ActionDispatch::MiddlewareStack
  def build(action, app = T.unsafe(nil), &block); end

  private

  def build_middleware(klass, args, block); end
end

ActionController::MiddlewareStack::EXCLUDE = T.let(T.unsafe(nil), Proc)
ActionController::MiddlewareStack::INCLUDE = T.let(T.unsafe(nil), Proc)

class ActionController::MiddlewareStack::Middleware < ::ActionDispatch::MiddlewareStack::Middleware
  # @return [Middleware] a new instance of Middleware
  def initialize(klass, args, actions, strategy, block); end

  # @return [Boolean]
  def valid?(action); end
end

ActionController::MiddlewareStack::NULL = T.let(T.unsafe(nil), Proc)

module ActionController::MimeResponds
  # Without web-service support, an action which collects the data for displaying a list of people
  # might look something like this:
  #
  #   def index
  #     @people = Person.all
  #   end
  #
  # That action implicitly responds to all formats, but formats can also be explicitly enumerated:
  #
  #   def index
  #     @people = Person.all
  #     respond_to :html, :js
  #   end
  #
  # Here's the same action, with web-service support baked in:
  #
  #   def index
  #     @people = Person.all
  #
  #     respond_to do |format|
  #       format.html
  #       format.js
  #       format.xml { render xml: @people }
  #     end
  #   end
  #
  # What that says is, "if the client wants HTML or JS in response to this action, just respond as we
  # would have before, but if the client wants XML, return them the list of people in XML format."
  # (Rails determines the desired response format from the HTTP Accept header submitted by the client.)
  #
  # Supposing you have an action that adds a new person, optionally creating their company
  # (by name) if it does not already exist, without web-services, it might look like this:
  #
  #   def create
  #     @company = Company.find_or_create_by(name: params[:company][:name])
  #     @person  = @company.people.create(params[:person])
  #
  #     redirect_to(person_list_url)
  #   end
  #
  # Here's the same action, with web-service support baked in:
  #
  #   def create
  #     company  = params[:person].delete(:company)
  #     @company = Company.find_or_create_by(name: company[:name])
  #     @person  = @company.people.create(params[:person])
  #
  #     respond_to do |format|
  #       format.html { redirect_to(person_list_url) }
  #       format.js
  #       format.xml  { render xml: @person.to_xml(include: @company) }
  #     end
  #   end
  #
  # If the client wants HTML, we just redirect them back to the person list. If they want JavaScript,
  # then it is an Ajax request and we render the JavaScript template associated with this action.
  # Lastly, if the client wants XML, we render the created person as XML, but with a twist: we also
  # include the person's company in the rendered XML, so you get something like this:
  #
  #   <person>
  #     <id>...</id>
  #     ...
  #     <company>
  #       <id>...</id>
  #       <name>...</name>
  #       ...
  #     </company>
  #   </person>
  #
  # Note, however, the extra bit at the top of that action:
  #
  #   company  = params[:person].delete(:company)
  #   @company = Company.find_or_create_by(name: company[:name])
  #
  # This is because the incoming XML document (if a web-service request is in process) can only contain a
  # single root-node. So, we have to rearrange things so that the request looks like this (url-encoded):
  #
  #   person[name]=...&person[company][name]=...&...
  #
  # And, like this (xml-encoded):
  #
  #   <person>
  #     <name>...</name>
  #     <company>
  #       <name>...</name>
  #     </company>
  #   </person>
  #
  # In other words, we make the request so that it operates on a single entity's person. Then, in the action,
  # we extract the company data from the request, find or create the company, and then create the new person
  # with the remaining data.
  #
  # Note that you can define your own XML parameter parser which would allow you to describe multiple entities
  # in a single request (i.e., by wrapping them all in a single root node), but if you just go with the flow
  # and accept Rails' defaults, life will be much easier.
  #
  # If you need to use a MIME type which isn't supported by default, you can register your own handlers in
  # +config/initializers/mime_types.rb+ as follows.
  #
  #   Mime::Type.register "image/jpg", :jpg
  #
  # +respond_to+ also allows you to specify a common block for different formats by using +any+:
  #
  #   def index
  #     @people = Person.all
  #
  #     respond_to do |format|
  #       format.html
  #       format.any(:xml, :json) { render request.format.to_sym => @people }
  #     end
  #   end
  #
  # In the example above, if the format is xml, it will render:
  #
  #   render xml: @people
  #
  # Or if the format is json:
  #
  #   render json: @people
  #
  # +any+ can also be used with no arguments, in which case it will be used for any format requested by
  # the user:
  #
  #   respond_to do |format|
  #     format.html
  #     format.any { redirect_to support_path }
  #   end
  #
  # Formats can have different variants.
  #
  # The request variant is a specialization of the request format, like <tt>:tablet</tt>,
  # <tt>:phone</tt>, or <tt>:desktop</tt>.
  #
  # We often want to render different html/json/xml templates for phones,
  # tablets, and desktop browsers. Variants make it easy.
  #
  # You can set the variant in a +before_action+:
  #
  #   request.variant = :tablet if /iPad/.match?(request.user_agent)
  #
  # Respond to variants in the action just like you respond to formats:
  #
  #   respond_to do |format|
  #     format.html do |variant|
  #       variant.tablet # renders app/views/projects/show.html+tablet.erb
  #       variant.phone { extra_setup; render ... }
  #       variant.none  { special_setup } # executed only if there is no variant set
  #     end
  #   end
  #
  # Provide separate templates for each format and variant:
  #
  #   app/views/projects/show.html.erb
  #   app/views/projects/show.html+tablet.erb
  #   app/views/projects/show.html+phone.erb
  #
  # When you're not sharing any code within the format, you can simplify defining variants
  # using the inline syntax:
  #
  #   respond_to do |format|
  #     format.js         { render "trash" }
  #     format.html.phone { redirect_to progress_path }
  #     format.html.none  { render "trash" }
  #   end
  #
  # Variants also support common +any+/+all+ block that formats have.
  #
  # It works for both inline:
  #
  #   respond_to do |format|
  #     format.html.any   { render html: "any"   }
  #     format.html.phone { render html: "phone" }
  #   end
  #
  # and block syntax:
  #
  #   respond_to do |format|
  #     format.html do |variant|
  #       variant.any(:tablet, :phablet){ render html: "any" }
  #       variant.phone { render html: "phone" }
  #     end
  #   end
  #
  # You can also set an array of variants:
  #
  #   request.variant = [:tablet, :phone]
  #
  # This will work similarly to formats and MIME types negotiation. If there
  # is no +:tablet+ variant declared, the +:phone+ variant will be used:
  #
  #   respond_to do |format|
  #     format.html.none
  #     format.html.phone # this gets rendered
  #   end
  #
  # @raise [ArgumentError]
  # @yield [collector]
  def respond_to(*mimes); end
end

# A container for responses available from the current controller for
# requests for different mime-types sent to a particular action.
#
# The public controller methods +respond_to+ may be called with a block
# that is used to define responses to different mime-types, e.g.
# for +respond_to+ :
#
#   respond_to do |format|
#     format.html
#     format.xml { render xml: @people }
#   end
#
# In this usage, the argument passed to the block (+format+ above) is an
# instance of the ActionController::MimeResponds::Collector class. This
# object serves as a container in which available responses can be stored by
# calling any of the dynamically generated, mime-type-specific methods such
# as +html+, +xml+ etc on the Collector. Each response is represented by a
# corresponding block if present.
#
# A subsequent call to #negotiate_format(request) will enable the Collector
# to determine which specific mime-type it should respond with for the current
# request, with this response then being accessible by calling #response.
class ActionController::MimeResponds::Collector
  include ::AbstractController::Collector

  # @return [Collector] a new instance of Collector
  def initialize(mimes, variant = T.unsafe(nil)); end

  def all(*args, &block); end
  def any(*args, &block); end

  # @return [Boolean]
  def any_response?; end

  def custom(mime_type, &block); end

  # Returns the value of attribute format.
  def format; end

  # Sets the attribute format
  #
  # @param value the value to set the attribute format to.
  def format=(_arg0); end

  def negotiate_format(request); end
  def response; end
end

class ActionController::MimeResponds::Collector::VariantCollector
  # @return [VariantCollector] a new instance of VariantCollector
  def initialize(variant = T.unsafe(nil)); end

  def all(*args, &block); end
  def any(*args, &block); end
  def method_missing(name, *args, &block); end
  def variant; end

  private

  def variant_key; end
end

class ActionController::MissingExactTemplate < ::ActionController::UnknownFormat; end
class ActionController::MissingFile < ::ActionController::ActionControllerError; end

# See <tt>Responder#api_behavior</tt>
class ActionController::MissingRenderer < ::LoadError
  # @return [MissingRenderer] a new instance of MissingRenderer
  def initialize(format); end
end

class ActionController::NotImplemented < ::ActionController::MethodNotAllowed; end

# Specify binary encoding for parameters for a given action.
module ActionController::ParameterEncoding
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::ActionController::ParameterEncoding::ClassMethods
end

module ActionController::ParameterEncoding::ClassMethods
  def action_encoding_template(action); end
  def inherited(klass); end

  # Specify the encoding for a parameter on an action.
  # If not specified the default is UTF-8.
  #
  # You can specify a binary (ASCII_8BIT) parameter with:
  #
  #   class RepositoryController < ActionController::Base
  #     # This specifies that file_path is not UTF-8 and is instead ASCII_8BIT
  #     param_encoding :show, :file_path, Encoding::ASCII_8BIT
  #
  #     def show
  #       @repo = Repository.find_by_filesystem_path params[:file_path]
  #
  #       # params[:repo_name] remains UTF-8 encoded
  #       @repo_name = params[:repo_name]
  #     end
  #
  #     def index
  #       @repositories = Repository.all
  #     end
  #   end
  #
  # The file_path parameter on the show action would be encoded as ASCII-8BIT,
  # but all other arguments will remain UTF-8 encoded.
  # This is useful in the case where an application must handle data
  # but encoding of the data is unknown, like file system data.
  def param_encoding(action, param, encoding); end

  def setup_param_encode; end

  # Specify that a given action's parameters should all be encoded as
  # ASCII-8BIT (it "skips" the encoding default of UTF-8).
  #
  # For example, a controller would use it like this:
  #
  #   class RepositoryController < ActionController::Base
  #     skip_parameter_encoding :show
  #
  #     def show
  #       @repo = Repository.find_by_filesystem_path params[:file_path]
  #
  #       # `repo_name` is guaranteed to be UTF-8, but was ASCII-8BIT, so
  #       # tag it as such
  #       @repo_name = params[:repo_name].force_encoding 'UTF-8'
  #     end
  #
  #     def index
  #       @repositories = Repository.all
  #     end
  #   end
  #
  # The show action in the above controller would have all parameter values
  # encoded as ASCII-8BIT. This is useful in the case where an application
  # must handle data but encoding of the data is unknown, like file system data.
  def skip_parameter_encoding(action); end
end

# Raised when a required parameter is missing.
#
#   params = ActionController::Parameters.new(a: {})
#   params.fetch(:b)
#   # => ActionController::ParameterMissing: param is missing or the value is empty: b
#   params.require(:a)
#   # => ActionController::ParameterMissing: param is missing or the value is empty: a
class ActionController::ParameterMissing < ::KeyError
  # @return [ParameterMissing] a new instance of ParameterMissing
  def initialize(param, keys = T.unsafe(nil)); end

  def keys; end
  def param; end
end

class ActionController::ParameterMissing::Correction
  # @return [Correction] a new instance of Correction
  def initialize(error); end

  def corrections; end
end

# == Action Controller \Parameters
#
# Allows you to choose which attributes should be permitted for mass updating
# and thus prevent accidentally exposing that which shouldn't be exposed.
# Provides two methods for this purpose: #require and #permit. The former is
# used to mark parameters as required. The latter is used to set the parameter
# as permitted and limit which attributes should be allowed for mass updating.
#
#   params = ActionController::Parameters.new({
#     person: {
#       name: "Francesco",
#       age:  22,
#       role: "admin"
#     }
#   })
#
#   permitted = params.require(:person).permit(:name, :age)
#   permitted            # => <ActionController::Parameters {"name"=>"Francesco", "age"=>22} permitted: true>
#   permitted.permitted? # => true
#
#   Person.first.update!(permitted)
#   # => #<Person id: 1, name: "Francesco", age: 22, role: "user">
#
# It provides two options that controls the top-level behavior of new instances:
#
# * +permit_all_parameters+ - If it's +true+, all the parameters will be
#   permitted by default. The default is +false+.
# * +action_on_unpermitted_parameters+ - Allow to control the behavior when parameters
#   that are not explicitly permitted are found. The values can be +false+ to just filter them
#   out, <tt>:log</tt> to additionally write a message on the logger, or <tt>:raise</tt> to raise
#   ActionController::UnpermittedParameters exception. The default value is <tt>:log</tt>
#   in test and development environments, +false+ otherwise.
#
# Examples:
#
#   params = ActionController::Parameters.new
#   params.permitted? # => false
#
#   ActionController::Parameters.permit_all_parameters = true
#
#   params = ActionController::Parameters.new
#   params.permitted? # => true
#
#   params = ActionController::Parameters.new(a: "123", b: "456")
#   params.permit(:c)
#   # => <ActionController::Parameters {} permitted: true>
#
#   ActionController::Parameters.action_on_unpermitted_parameters = :raise
#
#   params = ActionController::Parameters.new(a: "123", b: "456")
#   params.permit(:c)
#   # => ActionController::UnpermittedParameters: found unpermitted keys: a, b
#
# Please note that these options *are not thread-safe*. In a multi-threaded
# environment they should only be set once at boot-time and never mutated at
# runtime.
#
# You can fetch values of <tt>ActionController::Parameters</tt> using either
# <tt>:key</tt> or <tt>"key"</tt>.
#
#   params = ActionController::Parameters.new(key: "value")
#   params[:key]  # => "value"
#   params["key"] # => "value"
class ActionController::Parameters
  # Returns a new instance of <tt>ActionController::Parameters</tt>.
  # Also, sets the +permitted+ attribute to the default value of
  # <tt>ActionController::Parameters.permit_all_parameters</tt>.
  #
  #   class Person < ActiveRecord::Base
  #   end
  #
  #   params = ActionController::Parameters.new(name: "Francesco")
  #   params.permitted?  # => false
  #   Person.new(params) # => ActiveModel::ForbiddenAttributesError
  #
  #   ActionController::Parameters.permit_all_parameters = true
  #
  #   params = ActionController::Parameters.new(name: "Francesco")
  #   params.permitted?  # => true
  #   Person.new(params) # => #<Person id: nil, name: "Francesco">
  #
  # @return [Parameters] a new instance of Parameters
  def initialize(parameters = T.unsafe(nil)); end

  # Returns true if another +Parameters+ object contains the same content and
  # permitted flag.
  def ==(other); end

  # Returns a parameter for the given +key+. If not found,
  # returns +nil+.
  #
  #   params = ActionController::Parameters.new(person: { name: "Francesco" })
  #   params[:person] # => <ActionController::Parameters {"name"=>"Francesco"} permitted: false>
  #   params[:none]   # => nil
  def [](key); end

  # Assigns a value to a given +key+. The given key may still get filtered out
  # when +permit+ is called.
  def []=(key, value); end

  def always_permitted_parameters; end
  def always_permitted_parameters=(val); end
  def as_json(*_arg0, &_arg1); end

  # Returns a new instance of <tt>ActionController::Parameters</tt> with +nil+ values removed.
  def compact; end

  # Removes all +nil+ values in place and returns +self+, or +nil+ if no changes were made.
  def compact!; end

  # Returns a new instance of <tt>ActionController::Parameters</tt> without the blank values.
  # Uses Object#blank? for determining if a value is blank.
  def compact_blank; end

  # Removes all blank values in place and returns self.
  # Uses Object#blank? for determining if a value is blank.
  def compact_blank!; end

  # Attribute that keeps track of converted arrays, if any, to avoid double
  # looping in the common use case permit + mass-assignment. Defined in a
  # method to instantiate it only if needed.
  #
  # Testing membership still loops, but it's going to be faster than our own
  # loop that converts values. Also, we are not going to build a new array
  # object per fetch.
  def converted_arrays; end

  # Returns duplicate of object including all parameters.
  def deep_dup; end

  # Returns a new <tt>ActionController::Parameters</tt> instance with the
  # results of running +block+ once for every key. This includes the keys
  # from the root hash and from all nested hashes and arrays. The values are unchanged.
  def deep_transform_keys(&block); end

  # Returns the <tt>ActionController::Parameters</tt> instance changing its keys.
  # This includes the keys from the root hash and from all nested hashes and arrays.
  # The values are unchanged.
  def deep_transform_keys!(&block); end

  # Deletes a key-value pair from +Parameters+ and returns the value. If
  # +key+ is not found, returns +nil+ (or, with optional code block, yields
  # +key+ and returns the result). Cf. +#extract!+, which returns the
  # corresponding +ActionController::Parameters+ object.
  def delete(key, &block); end

  # Removes items that the block evaluates to true and returns self.
  def delete_if(&block); end

  # Extracts the nested parameter from the given +keys+ by calling +dig+
  # at each step. Returns +nil+ if any intermediate step is +nil+.
  #
  #   params = ActionController::Parameters.new(foo: { bar: { baz: 1 } })
  #   params.dig(:foo, :bar, :baz) # => 1
  #   params.dig(:foo, :zot, :xyz) # => nil
  #
  #   params2 = ActionController::Parameters.new(foo: [10, 11, 12])
  #   params2.dig(:foo, 1) # => 11
  def dig(*keys); end

  # Convert all hashes in values into parameters, then yield each pair in
  # the same way as <tt>Hash#each_pair</tt>.
  def each(&block); end

  def each_key(*_arg0, &_arg1); end

  # Convert all hashes in values into parameters, then yield each pair in
  # the same way as <tt>Hash#each_pair</tt>.
  def each_pair(&block); end

  # Convert all hashes in values into parameters, then yield each value in
  # the same way as <tt>Hash#each_value</tt>.
  def each_value(&block); end

  def empty?(*_arg0, &_arg1); end

  # Returns true if another +Parameters+ object contains the same content and
  # permitted flag.
  def eql?(other); end

  # Returns a new <tt>ActionController::Parameters</tt> instance that
  # filters out the given +keys+.
  #
  #   params = ActionController::Parameters.new(a: 1, b: 2, c: 3)
  #   params.except(:a, :b) # => <ActionController::Parameters {"c"=>3} permitted: false>
  #   params.except(:d)     # => <ActionController::Parameters {"a"=>1, "b"=>2, "c"=>3} permitted: false>
  def except(*keys); end

  # Removes and returns the key/value pairs matching the given keys.
  #
  #   params = ActionController::Parameters.new(a: 1, b: 2, c: 3)
  #   params.extract!(:a, :b) # => <ActionController::Parameters {"a"=>1, "b"=>2} permitted: false>
  #   params                  # => <ActionController::Parameters {"c"=>3} permitted: false>
  def extract!(*keys); end

  # Returns a parameter for the given +key+. If the +key+
  # can't be found, there are several options: With no other arguments,
  # it will raise an <tt>ActionController::ParameterMissing</tt> error;
  # if a second argument is given, then that is returned (converted to an
  # instance of ActionController::Parameters if possible); if a block
  # is given, then that will be run and its result returned.
  #
  #   params = ActionController::Parameters.new(person: { name: "Francesco" })
  #   params.fetch(:person)               # => <ActionController::Parameters {"name"=>"Francesco"} permitted: false>
  #   params.fetch(:none)                 # => ActionController::ParameterMissing: param is missing or the value is empty: none
  #   params.fetch(:none, {})             # => <ActionController::Parameters {} permitted: false>
  #   params.fetch(:none, "Francesco")    # => "Francesco"
  #   params.fetch(:none) { "Francesco" } # => "Francesco"
  def fetch(key, *args); end

  def has_key?(*_arg0, &_arg1); end
  def has_value?(*_arg0, &_arg1); end
  def hash; end
  def include?(*_arg0, &_arg1); end
  def init_with(coder); end
  def inspect; end

  # Equivalent to Hash#keep_if, but returns +nil+ if no changes were made.
  def keep_if(&block); end

  def key?(*_arg0, &_arg1); end

  # :method: values
  #
  # :call-seq:
  #   values()
  #
  # Returns a new array of the values of the parameters.
  def keys(*_arg0, &_arg1); end

  def member?(*_arg0, &_arg1); end

  # Returns a new <tt>ActionController::Parameters</tt> with all keys from
  # +other_hash+ merged into current hash.
  def merge(other_hash); end

  # Returns current <tt>ActionController::Parameters</tt> instance with
  # +other_hash+ merged into current hash.
  def merge!(other_hash); end

  # Returns a new <tt>ActionController::Parameters</tt> instance that
  # includes only the given +filters+ and sets the +permitted+ attribute
  # for the object to +true+. This is useful for limiting which attributes
  # should be allowed for mass updating.
  #
  #   params = ActionController::Parameters.new(user: { name: "Francesco", age: 22, role: "admin" })
  #   permitted = params.require(:user).permit(:name, :age)
  #   permitted.permitted?      # => true
  #   permitted.has_key?(:name) # => true
  #   permitted.has_key?(:age)  # => true
  #   permitted.has_key?(:role) # => false
  #
  # Only permitted scalars pass the filter. For example, given
  #
  #   params.permit(:name)
  #
  # +:name+ passes if it is a key of +params+ whose associated value is of type
  # +String+, +Symbol+, +NilClass+, +Numeric+, +TrueClass+, +FalseClass+,
  # +Date+, +Time+, +DateTime+, +StringIO+, +IO+,
  # +ActionDispatch::Http::UploadedFile+ or +Rack::Test::UploadedFile+.
  # Otherwise, the key +:name+ is filtered out.
  #
  # You may declare that the parameter should be an array of permitted scalars
  # by mapping it to an empty array:
  #
  #   params = ActionController::Parameters.new(tags: ["rails", "parameters"])
  #   params.permit(tags: [])
  #
  # Sometimes it is not possible or convenient to declare the valid keys of
  # a hash parameter or its internal structure. Just map to an empty hash:
  #
  #   params.permit(preferences: {})
  #
  # Be careful because this opens the door to arbitrary input. In this
  # case, +permit+ ensures values in the returned structure are permitted
  # scalars and filters out anything else.
  #
  # You can also use +permit+ on nested parameters, like:
  #
  #   params = ActionController::Parameters.new({
  #     person: {
  #       name: "Francesco",
  #       age:  22,
  #       pets: [{
  #         name: "Purplish",
  #         category: "dogs"
  #       }]
  #     }
  #   })
  #
  #   permitted = params.permit(person: [ :name, { pets: :name } ])
  #   permitted.permitted?                    # => true
  #   permitted[:person][:name]               # => "Francesco"
  #   permitted[:person][:age]                # => nil
  #   permitted[:person][:pets][0][:name]     # => "Purplish"
  #   permitted[:person][:pets][0][:category] # => nil
  #
  # Note that if you use +permit+ in a key that points to a hash,
  # it won't allow all the hash. You also need to specify which
  # attributes inside the hash should be permitted.
  #
  #   params = ActionController::Parameters.new({
  #     person: {
  #       contact: {
  #         email: "none@test.com",
  #         phone: "555-1234"
  #       }
  #     }
  #   })
  #
  #   params.require(:person).permit(:contact)
  #   # => <ActionController::Parameters {} permitted: true>
  #
  #   params.require(:person).permit(contact: :phone)
  #   # => <ActionController::Parameters {"contact"=><ActionController::Parameters {"phone"=>"555-1234"} permitted: true>} permitted: true>
  #
  #   params.require(:person).permit(contact: [ :email, :phone ])
  #   # => <ActionController::Parameters {"contact"=><ActionController::Parameters {"email"=>"none@test.com", "phone"=>"555-1234"} permitted: true>} permitted: true>
  def permit(*filters); end

  # Sets the +permitted+ attribute to +true+. This can be used to pass
  # mass assignment. Returns +self+.
  #
  #   class Person < ActiveRecord::Base
  #   end
  #
  #   params = ActionController::Parameters.new(name: "Francesco")
  #   params.permitted?  # => false
  #   Person.new(params) # => ActiveModel::ForbiddenAttributesError
  #   params.permit!
  #   params.permitted?  # => true
  #   Person.new(params) # => #<Person id: nil, name: "Francesco">
  def permit!; end

  # Returns +true+ if the parameter is permitted, +false+ otherwise.
  #
  #   params = ActionController::Parameters.new
  #   params.permitted? # => false
  #   params.permit!
  #   params.permitted? # => true
  #
  # @return [Boolean]
  def permitted?; end

  # Returns a new instance of <tt>ActionController::Parameters</tt> with items
  # that the block evaluates to true removed.
  def reject(&block); end

  # Removes items that the block evaluates to true and returns self.
  def reject!(&block); end

  # This method accepts both a single key and an array of keys.
  #
  # When passed a single key, if it exists and its associated value is
  # either present or the singleton +false+, returns said value:
  #
  #   ActionController::Parameters.new(person: { name: "Francesco" }).require(:person)
  #   # => <ActionController::Parameters {"name"=>"Francesco"} permitted: false>
  #
  # Otherwise raises <tt>ActionController::ParameterMissing</tt>:
  #
  #   ActionController::Parameters.new.require(:person)
  #   # ActionController::ParameterMissing: param is missing or the value is empty: person
  #
  #   ActionController::Parameters.new(person: nil).require(:person)
  #   # ActionController::ParameterMissing: param is missing or the value is empty: person
  #
  #   ActionController::Parameters.new(person: "\t").require(:person)
  #   # ActionController::ParameterMissing: param is missing or the value is empty: person
  #
  #   ActionController::Parameters.new(person: {}).require(:person)
  #   # ActionController::ParameterMissing: param is missing or the value is empty: person
  #
  # When given an array of keys, the method tries to require each one of them
  # in order. If it succeeds, an array with the respective return values is
  # returned:
  #
  #   params = ActionController::Parameters.new(user: { ... }, profile: { ... })
  #   user_params, profile_params = params.require([:user, :profile])
  #
  # Otherwise, the method re-raises the first exception found:
  #
  #   params = ActionController::Parameters.new(user: {}, profile: {})
  #   user_params, profile_params = params.require([:user, :profile])
  #   # ActionController::ParameterMissing: param is missing or the value is empty: user
  #
  # Technically this method can be used to fetch terminal values:
  #
  #   # CAREFUL
  #   params = ActionController::Parameters.new(person: { name: "Finn" })
  #   name = params.require(:person).require(:name) # CAREFUL
  #
  # but take into account that at some point those ones have to be permitted:
  #
  #   def person_params
  #     params.require(:person).permit(:name).tap do |person_params|
  #       person_params.require(:name) # SAFER
  #     end
  #   end
  #
  # for example.
  def require(key); end

  # This method accepts both a single key and an array of keys.
  #
  # When passed a single key, if it exists and its associated value is
  # either present or the singleton +false+, returns said value:
  #
  #   ActionController::Parameters.new(person: { name: "Francesco" }).require(:person)
  #   # => <ActionController::Parameters {"name"=>"Francesco"} permitted: false>
  #
  # Otherwise raises <tt>ActionController::ParameterMissing</tt>:
  #
  #   ActionController::Parameters.new.require(:person)
  #   # ActionController::ParameterMissing: param is missing or the value is empty: person
  #
  #   ActionController::Parameters.new(person: nil).require(:person)
  #   # ActionController::ParameterMissing: param is missing or the value is empty: person
  #
  #   ActionController::Parameters.new(person: "\t").require(:person)
  #   # ActionController::ParameterMissing: param is missing or the value is empty: person
  #
  #   ActionController::Parameters.new(person: {}).require(:person)
  #   # ActionController::ParameterMissing: param is missing or the value is empty: person
  #
  # When given an array of keys, the method tries to require each one of them
  # in order. If it succeeds, an array with the respective return values is
  # returned:
  #
  #   params = ActionController::Parameters.new(user: { ... }, profile: { ... })
  #   user_params, profile_params = params.require([:user, :profile])
  #
  # Otherwise, the method re-raises the first exception found:
  #
  #   params = ActionController::Parameters.new(user: {}, profile: {})
  #   user_params, profile_params = params.require([:user, :profile])
  #   # ActionController::ParameterMissing: param is missing or the value is empty: user
  #
  # Technically this method can be used to fetch terminal values:
  #
  #   # CAREFUL
  #   params = ActionController::Parameters.new(person: { name: "Finn" })
  #   name = params.require(:person).require(:name) # CAREFUL
  #
  # but take into account that at some point those ones have to be permitted:
  #
  #   def person_params
  #     params.require(:person).permit(:name).tap do |person_params|
  #       person_params.require(:name) # SAFER
  #     end
  #   end
  #
  # for example.
  # Alias of #require.
  def required(key); end

  # Returns a new <tt>ActionController::Parameters</tt> with all keys from
  # current hash merged into +other_hash+.
  def reverse_merge(other_hash); end

  # Returns current <tt>ActionController::Parameters</tt> instance with
  # current hash merged into +other_hash+.
  def reverse_merge!(other_hash); end

  # Returns a new instance of <tt>ActionController::Parameters</tt> with only
  # items that the block evaluates to true.
  def select(&block); end

  # Equivalent to Hash#keep_if, but returns +nil+ if no changes were made.
  def select!(&block); end

  # Returns a new <tt>ActionController::Parameters</tt> instance that
  # includes only the given +keys+. If the given +keys+
  # don't exist, returns an empty hash.
  #
  #   params = ActionController::Parameters.new(a: 1, b: 2, c: 3)
  #   params.slice(:a, :b) # => <ActionController::Parameters {"a"=>1, "b"=>2} permitted: false>
  #   params.slice(:d)     # => <ActionController::Parameters {} permitted: false>
  def slice(*keys); end

  # Returns current <tt>ActionController::Parameters</tt> instance which
  # contains only the given +keys+.
  def slice!(*keys); end

  # This is required by ActiveModel attribute assignment, so that user can
  # pass +Parameters+ to a mass assignment methods in a model. It should not
  # matter as we are using +HashWithIndifferentAccess+ internally.
  def stringify_keys; end

  # Returns a safe <tt>ActiveSupport::HashWithIndifferentAccess</tt>
  # representation of the parameters with all unpermitted keys removed.
  #
  #   params = ActionController::Parameters.new({
  #     name: "Senjougahara Hitagi",
  #     oddity: "Heavy stone crab"
  #   })
  #   params.to_h
  #   # => ActionController::UnfilteredParameters: unable to convert unpermitted parameters to hash
  #
  #   safe_params = params.permit(:name)
  #   safe_params.to_h # => {"name"=>"Senjougahara Hitagi"}
  def to_h; end

  # Returns a safe <tt>Hash</tt> representation of the parameters
  # with all unpermitted keys removed.
  #
  #   params = ActionController::Parameters.new({
  #     name: "Senjougahara Hitagi",
  #     oddity: "Heavy stone crab"
  #   })
  #   params.to_hash
  #   # => ActionController::UnfilteredParameters: unable to convert unpermitted parameters to hash
  #
  #   safe_params = params.permit(:name)
  #   safe_params.to_hash # => {"name"=>"Senjougahara Hitagi"}
  def to_hash; end

  # Returns a string representation of the receiver suitable for use as a URL
  # query string:
  #
  #   params = ActionController::Parameters.new({
  #     name: "David",
  #     nationality: "Danish"
  #   })
  #   params.to_query
  #   # => ActionController::UnfilteredParameters: unable to convert unpermitted parameters to hash
  #
  #   safe_params = params.permit(:name, :nationality)
  #   safe_params.to_query
  #   # => "name=David&nationality=Danish"
  #
  # An optional namespace can be passed to enclose key names:
  #
  #   params = ActionController::Parameters.new({
  #     name: "David",
  #     nationality: "Danish"
  #   })
  #   safe_params = params.permit(:name, :nationality)
  #   safe_params.to_query("user")
  #   # => "user%5Bname%5D=David&user%5Bnationality%5D=Danish"
  #
  # The string pairs "key=value" that conform the query string
  # are sorted lexicographically in ascending order.
  #
  # This method is also aliased as +to_param+.
  def to_param(*args); end

  # Returns a string representation of the receiver suitable for use as a URL
  # query string:
  #
  #   params = ActionController::Parameters.new({
  #     name: "David",
  #     nationality: "Danish"
  #   })
  #   params.to_query
  #   # => ActionController::UnfilteredParameters: unable to convert unpermitted parameters to hash
  #
  #   safe_params = params.permit(:name, :nationality)
  #   safe_params.to_query
  #   # => "name=David&nationality=Danish"
  #
  # An optional namespace can be passed to enclose key names:
  #
  #   params = ActionController::Parameters.new({
  #     name: "David",
  #     nationality: "Danish"
  #   })
  #   safe_params = params.permit(:name, :nationality)
  #   safe_params.to_query("user")
  #   # => "user%5Bname%5D=David&user%5Bnationality%5D=Danish"
  #
  # The string pairs "key=value" that conform the query string
  # are sorted lexicographically in ascending order.
  #
  # This method is also aliased as +to_param+.
  def to_query(*args); end

  def to_s(*_arg0, &_arg1); end

  # Returns an unsafe, unfiltered
  # <tt>ActiveSupport::HashWithIndifferentAccess</tt> representation of the
  # parameters.
  #
  #   params = ActionController::Parameters.new({
  #     name: "Senjougahara Hitagi",
  #     oddity: "Heavy stone crab"
  #   })
  #   params.to_unsafe_h
  #   # => {"name"=>"Senjougahara Hitagi", "oddity" => "Heavy stone crab"}
  def to_unsafe_h; end

  # Returns an unsafe, unfiltered
  # <tt>ActiveSupport::HashWithIndifferentAccess</tt> representation of the
  # parameters.
  #
  #   params = ActionController::Parameters.new({
  #     name: "Senjougahara Hitagi",
  #     oddity: "Heavy stone crab"
  #   })
  #   params.to_unsafe_h
  #   # => {"name"=>"Senjougahara Hitagi", "oddity" => "Heavy stone crab"}
  def to_unsafe_hash; end

  # Returns a new <tt>ActionController::Parameters</tt> instance with the
  # results of running +block+ once for every key. The values are unchanged.
  def transform_keys(&block); end

  # Performs keys transformation and returns the altered
  # <tt>ActionController::Parameters</tt> instance.
  def transform_keys!(&block); end

  # Returns a new <tt>ActionController::Parameters</tt> with the results of
  # running +block+ once for every value. The keys are unchanged.
  #
  #   params = ActionController::Parameters.new(a: 1, b: 2, c: 3)
  #   params.transform_values { |x| x * 2 }
  #   # => <ActionController::Parameters {"a"=>2, "b"=>4, "c"=>6} permitted: false>
  def transform_values; end

  # Performs values transformation and returns the altered
  # <tt>ActionController::Parameters</tt> instance.
  def transform_values!; end

  def value?(*_arg0, &_arg1); end
  def values(*_arg0, &_arg1); end

  # Returns values that were assigned to the given +keys+. Note that all the
  # +Hash+ objects will be converted to <tt>ActionController::Parameters</tt>.
  def values_at(*keys); end

  # Returns a new <tt>ActionController::Parameters</tt> with all keys from
  # current hash merged into +other_hash+.
  def with_defaults(other_hash); end

  # Returns current <tt>ActionController::Parameters</tt> instance with
  # current hash merged into +other_hash+.
  def with_defaults!(other_hash); end

  protected

  def each_nested_attribute; end

  # @return [Boolean]
  def nested_attributes?; end

  # Returns the value of attribute parameters.
  def parameters; end

  # Sets the attribute permitted
  #
  # @param value the value to set the attribute permitted to.
  def permitted=(_arg0); end

  private

  # @return [Boolean]
  def array_of_permitted_scalars?(value); end

  def convert_hashes_to_parameters(key, value); end
  def convert_parameters_to_hashes(value, using); end
  def convert_value_to_parameters(value); end
  def each_element(object, &block); end
  def hash_filter(params, filter); end
  def initialize_copy(source); end
  def new_instance_with_inherited_permitted_status(hash); end

  # @return [Boolean]
  def non_scalar?(value); end

  def permit_any_in_array(array); end
  def permit_any_in_parameters(params); end

  # @return [Boolean]
  def permitted_scalar?(value); end

  # Adds existing keys to the params if their values are scalar.
  #
  # For example:
  #
  #   puts self.keys #=> ["zipcode(90210i)"]
  #   params = {}
  #
  #   permitted_scalar_filter(params, "zipcode")
  #
  #   puts params.keys # => ["zipcode"]
  def permitted_scalar_filter(params, permitted_key); end

  def unpermitted_keys(params); end
  def unpermitted_parameters!(params); end

  class << self
    def action_on_unpermitted_parameters; end
    def action_on_unpermitted_parameters=(val); end
    def always_permitted_parameters; end
    def always_permitted_parameters=(val); end
    def hook_into_yaml_loading; end

    # @return [Boolean]
    def nested_attribute?(key, value); end

    def permit_all_parameters; end
    def permit_all_parameters=(val); end
  end
end

ActionController::Parameters::EMPTY_ARRAY = T.let(T.unsafe(nil), Array)
ActionController::Parameters::EMPTY_HASH = T.let(T.unsafe(nil), Hash)

# This is a list of permitted scalar types that includes the ones
# supported in XML and JSON requests.
#
# This list is in particular used to filter ordinary requests, String goes
# as first element to quickly short-circuit the common case.
#
# If you modify this collection please update the API of +permit+ above.
ActionController::Parameters::PERMITTED_SCALAR_TYPES = T.let(T.unsafe(nil), Array)

# Wraps the parameters hash into a nested hash. This will allow clients to
# submit requests without having to specify any root elements.
#
# This functionality is enabled in +config/initializers/wrap_parameters.rb+
# and can be customized.
#
# You could also turn it on per controller by setting the format array to
# a non-empty array:
#
#     class UsersController < ApplicationController
#       wrap_parameters format: [:json, :xml, :url_encoded_form, :multipart_form]
#     end
#
# If you enable +ParamsWrapper+ for +:json+ format, instead of having to
# send JSON parameters like this:
#
#     {"user": {"name": "Konata"}}
#
# You can send parameters like this:
#
#     {"name": "Konata"}
#
# And it will be wrapped into a nested hash with the key name matching the
# controller's name. For example, if you're posting to +UsersController+,
# your new +params+ hash will look like this:
#
#     {"name" => "Konata", "user" => {"name" => "Konata"}}
#
# You can also specify the key in which the parameters should be wrapped to,
# and also the list of attributes it should wrap by using either +:include+ or
# +:exclude+ options like this:
#
#     class UsersController < ApplicationController
#       wrap_parameters :person, include: [:username, :password]
#     end
#
# On Active Record models with no +:include+ or +:exclude+ option set,
# it will only wrap the parameters returned by the class method
# <tt>attribute_names</tt>.
#
# If you're going to pass the parameters to an +ActiveModel+ object (such as
# <tt>User.new(params[:user])</tt>), you might consider passing the model class to
# the method instead. The +ParamsWrapper+ will actually try to determine the
# list of attribute names from the model and only wrap those attributes:
#
#     class UsersController < ApplicationController
#       wrap_parameters Person
#     end
#
# You still could pass +:include+ and +:exclude+ to set the list of attributes
# you want to wrap.
#
# By default, if you don't specify the key in which the parameters would be
# wrapped to, +ParamsWrapper+ will actually try to determine if there's
# a model related to it or not. This controller, for example:
#
#     class Admin::UsersController < ApplicationController
#     end
#
# will try to check if <tt>Admin::User</tt> or +User+ model exists, and use it to
# determine the wrapper key respectively. If both models don't exist,
# it will then fallback to use +user+ as the key.
module ActionController::ParamsWrapper
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::ActionController::ParamsWrapper::ClassMethods

  # Performs parameters wrapping upon the request. Called automatically
  # by the metal call stack.
  def process_action(*_arg0); end

  private

  def _extract_parameters(parameters); end
  def _perform_parameter_wrapping; end

  # Returns the list of parameters which will be selected for wrapped.
  def _wrap_parameters(parameters); end

  # Checks if we should perform parameters wrapping.
  #
  # @return [Boolean]
  def _wrapper_enabled?; end

  # Returns the list of enabled formats.
  def _wrapper_formats; end

  # Returns the wrapper key which will be used to store wrapped parameters.
  def _wrapper_key; end

  module GeneratedClassMethods
    def _wrapper_options; end
    def _wrapper_options=(value); end
    def _wrapper_options?; end
  end

  module GeneratedInstanceMethods
    def _wrapper_options; end
    def _wrapper_options=(value); end
    def _wrapper_options?; end
  end
end

module ActionController::ParamsWrapper::ClassMethods
  def _set_wrapper_options(options); end

  # Sets the default wrapper key or model which will be used to determine
  # wrapper key and attribute names. Called automatically when the
  # module is inherited.
  def inherited(klass); end

  # Sets the name of the wrapper key, or the model which +ParamsWrapper+
  # would use to determine the attribute names from.
  #
  # ==== Examples
  #   wrap_parameters format: :xml
  #     # enables the parameter wrapper for XML format
  #
  #   wrap_parameters :person
  #     # wraps parameters into +params[:person]+ hash
  #
  #   wrap_parameters Person
  #     # wraps parameters by determining the wrapper key from Person class
  #     # (+person+, in this case) and the list of attribute names
  #
  #   wrap_parameters include: [:username, :title]
  #     # wraps only +:username+ and +:title+ attributes from parameters.
  #
  #   wrap_parameters false
  #     # disables parameters wrapping for this controller altogether.
  #
  # ==== Options
  # * <tt>:format</tt> - The list of formats in which the parameters wrapper
  #   will be enabled.
  # * <tt>:include</tt> - The list of attribute names which parameters wrapper
  #   will wrap into a nested hash.
  # * <tt>:exclude</tt> - The list of attribute names which parameters wrapper
  #   will exclude from a nested hash.
  def wrap_parameters(name_or_model_or_options, options = T.unsafe(nil)); end
end

ActionController::ParamsWrapper::EXCLUDE_PARAMETERS = T.let(T.unsafe(nil), Array)

class ActionController::ParamsWrapper::Options < ::Struct
  include ::Mutex_m

  # @return [Options] a new instance of Options
  def initialize(name, format, include, exclude, klass, model); end

  # Returns the value of attribute include
  #
  # @return [Object] the current value of include
  def include; end

  def lock; end
  def locked?; end

  # Returns the value of attribute model
  #
  # @return [Object] the current value of model
  def model; end

  # Returns the value of attribute name
  #
  # @return [Object] the current value of name
  def name; end

  def synchronize(&block); end
  def try_lock; end
  def unlock; end

  private

  # Determine the wrapper model from the controller's name. By convention,
  # this could be done by trying to find the defined model that has the
  # same singular name as the controller. For example, +UsersController+
  # will try to find if the +User+ model exists.
  #
  # This method also does namespace lookup. Foo::Bar::UsersController will
  # try to find Foo::Bar::User, Foo::User and finally User.
  def _default_wrap_model; end

  class << self
    def from_hash(hash); end
  end
end

# HTTP Permissions Policy is a web standard for defining a mechanism to
# allow and deny the use of browser permissions in its own context, and
# in content within any <iframe> elements in the document.
#
# Full details of HTTP Permissions Policy specification and guidelines can
# be found at MDN:
#
# https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Feature-Policy
#
# Examples of usage:
#
#   # Global policy
#   Rails.application.config.permissions_policy do |f|
#     f.camera      :none
#     f.gyroscope   :none
#     f.microphone  :none
#     f.usb         :none
#     f.fullscreen  :self
#     f.payment     :self, "https://secure.example.com"
#   end
#
#   # Controller level policy
#   class PagesController < ApplicationController
#     permissions_policy do |p|
#       p.geolocation "https://example.com"
#     end
#   end
module ActionController::PermissionsPolicy
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::ActionController::PermissionsPolicy::ClassMethods
end

module ActionController::PermissionsPolicy::ClassMethods
  def permissions_policy(**options, &block); end
end

module ActionController::Redirecting
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods
  include ::ActiveSupport::Benchmarkable
  include ::AbstractController::Logger
  include ::ActionDispatch::Routing::UrlFor
  include ::AbstractController::UrlFor
  include ::ActionController::UrlFor

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::AbstractController::UrlFor::ClassMethods

  def _compute_redirect_to_location(request, options); end

  # Redirects the browser to the page that issued the request (the referrer)
  # if possible, otherwise redirects to the provided default fallback
  # location.
  #
  # The referrer information is pulled from the HTTP +Referer+ (sic) header on
  # the request. This is an optional header and its presence on the request is
  # subject to browser security settings and user preferences. If the request
  # is missing this header, the <tt>fallback_location</tt> will be used.
  #
  #   redirect_back fallback_location: { action: "show", id: 5 }
  #   redirect_back fallback_location: @post
  #   redirect_back fallback_location: "http://www.rubyonrails.org"
  #   redirect_back fallback_location: "/images/screenshot.jpg"
  #   redirect_back fallback_location: posts_url
  #   redirect_back fallback_location: proc { edit_post_url(@post) }
  #   redirect_back fallback_location: '/', allow_other_host: false
  #
  # ==== Options
  # * <tt>:fallback_location</tt> - The default fallback location that will be used on missing +Referer+ header.
  # * <tt>:allow_other_host</tt> - Allow or disallow redirection to the host that is different to the current host, defaults to true.
  #
  # All other options that can be passed to #redirect_to are accepted as
  # options and the behavior is identical.
  def redirect_back(fallback_location:, allow_other_host: T.unsafe(nil), **args); end

  # Redirects the browser to the target specified in +options+. This parameter can be any one of:
  #
  # * <tt>Hash</tt> - The URL will be generated by calling url_for with the +options+.
  # * <tt>Record</tt> - The URL will be generated by calling url_for with the +options+, which will reference a named URL for that record.
  # * <tt>String</tt> starting with <tt>protocol://</tt> (like <tt>http://</tt>) or a protocol relative reference (like <tt>//</tt>) - Is passed straight through as the target for redirection.
  # * <tt>String</tt> not containing a protocol - The current protocol and host is prepended to the string.
  # * <tt>Proc</tt> - A block that will be executed in the controller's context. Should return any option accepted by +redirect_to+.
  #
  # === Examples:
  #
  #   redirect_to action: "show", id: 5
  #   redirect_to @post
  #   redirect_to "http://www.rubyonrails.org"
  #   redirect_to "/images/screenshot.jpg"
  #   redirect_to posts_url
  #   redirect_to proc { edit_post_url(@post) }
  #
  # The redirection happens as a <tt>302 Found</tt> header unless otherwise specified using the <tt>:status</tt> option:
  #
  #   redirect_to post_url(@post), status: :found
  #   redirect_to action: 'atom', status: :moved_permanently
  #   redirect_to post_url(@post), status: 301
  #   redirect_to action: 'atom', status: 302
  #
  # The status code can either be a standard {HTTP Status code}[https://www.iana.org/assignments/http-status-codes] as an
  # integer, or a symbol representing the downcased, underscored and symbolized description.
  # Note that the status code must be a 3xx HTTP code, or redirection will not occur.
  #
  # If you are using XHR requests other than GET or POST and redirecting after the
  # request then some browsers will follow the redirect using the original request
  # method. This may lead to undesirable behavior such as a double DELETE. To work
  # around this you can return a <tt>303 See Other</tt> status code which will be
  # followed using a GET request.
  #
  #   redirect_to posts_url, status: :see_other
  #   redirect_to action: 'index', status: 303
  #
  # It is also possible to assign a flash message as part of the redirection. There are two special accessors for the commonly used flash names
  # +alert+ and +notice+ as well as a general purpose +flash+ bucket.
  #
  #   redirect_to post_url(@post), alert: "Watch it, mister!"
  #   redirect_to post_url(@post), status: :found, notice: "Pay attention to the road"
  #   redirect_to post_url(@post), status: 301, flash: { updated_post_id: @post.id }
  #   redirect_to({ action: 'atom' }, alert: "Something serious happened")
  #
  # Statements after +redirect_to+ in our controller get executed, so +redirect_to+ doesn't stop the execution of the function.
  # To terminate the execution of the function immediately after the +redirect_to+, use return.
  #   redirect_to post_url(@post) and return
  #
  # @raise [ActionControllerError]
  def redirect_to(options = T.unsafe(nil), response_options = T.unsafe(nil)); end

  private

  def _extract_redirect_to_status(options, response_options); end

  # @return [Boolean]
  def _url_host_allowed?(url); end

  class << self
    def _compute_redirect_to_location(request, options); end
  end

  module GeneratedClassMethods
    def default_url_options; end
    def default_url_options=(value); end
    def default_url_options?; end
  end

  module GeneratedInstanceMethods
    def default_url_options; end
    def default_url_options=(value); end
    def default_url_options?; end
  end
end

class ActionController::RenderError < ::ActionController::ActionControllerError; end

# ActionController::Renderer allows you to render arbitrary templates
# without requirement of being in controller actions.
#
# You get a concrete renderer class by invoking ActionController::Base#renderer.
# For example:
#
#   ApplicationController.renderer
#
# It allows you to call method #render directly.
#
#   ApplicationController.renderer.render template: '...'
#
# You can use this shortcut in a controller, instead of the previous example:
#
#   ApplicationController.render template: '...'
#
# #render allows you to use the same options that you can use when rendering in a controller.
# For example:
#
#   FooController.render :action, locals: { ... }, assigns: { ... }
#
# The template will be rendered in a Rack environment which is accessible through
# ActionController::Renderer#env. You can set it up in two ways:
#
# *  by changing renderer defaults, like
#
#       ApplicationController.renderer.defaults # => hash with default Rack environment
#
# *  by initializing an instance of renderer by passing it a custom environment.
#
#       ApplicationController.renderer.new(method: 'post', https: true)
class ActionController::Renderer
  # Accepts a custom Rack environment to render templates in.
  # It will be merged with the default Rack environment defined by
  # +ActionController::Renderer::DEFAULTS+.
  #
  # @return [Renderer] a new instance of Renderer
  def initialize(controller, env, defaults); end

  # Returns the value of attribute controller.
  def controller; end

  # Returns the value of attribute defaults.
  def defaults; end

  # Create a new renderer for the same controller but with a new env.
  def new(env = T.unsafe(nil)); end

  # Render templates with any options from ActionController::Base#render_to_string.
  #
  # The primary options are:
  # * <tt>:partial</tt> - See <tt>ActionView::PartialRenderer</tt> for details.
  # * <tt>:file</tt> - Renders an explicit template file. Add <tt>:locals</tt> to pass in, if so desired.
  #   It shouldn’t be used directly with unsanitized user input due to lack of validation.
  # * <tt>:inline</tt> - Renders an ERB template string.
  # * <tt>:plain</tt> - Renders provided text and sets the content type as <tt>text/plain</tt>.
  # * <tt>:html</tt> - Renders the provided HTML safe string, otherwise
  #   performs HTML escape on the string first. Sets the content type as <tt>text/html</tt>.
  # * <tt>:json</tt> - Renders the provided hash or object in JSON. You don't
  #   need to call <tt>.to_json</tt> on the object you want to render.
  # * <tt>:body</tt> - Renders provided text and sets content type of <tt>text/plain</tt>.
  #
  # If no <tt>options</tt> hash is passed or if <tt>:update</tt> is specified, then:
  #
  # If an object responding to +render_in+ is passed, +render_in+ is called on the object,
  # passing in the current view context.
  #
  # Otherwise, a partial is rendered using the second parameter as the locals hash.
  def render(*args); end

  # Render templates with any options from ActionController::Base#render_to_string.
  #
  # The primary options are:
  # * <tt>:partial</tt> - See <tt>ActionView::PartialRenderer</tt> for details.
  # * <tt>:file</tt> - Renders an explicit template file. Add <tt>:locals</tt> to pass in, if so desired.
  #   It shouldn’t be used directly with unsanitized user input due to lack of validation.
  # * <tt>:inline</tt> - Renders an ERB template string.
  # * <tt>:plain</tt> - Renders provided text and sets the content type as <tt>text/plain</tt>.
  # * <tt>:html</tt> - Renders the provided HTML safe string, otherwise
  #   performs HTML escape on the string first. Sets the content type as <tt>text/html</tt>.
  # * <tt>:json</tt> - Renders the provided hash or object in JSON. You don't
  #   need to call <tt>.to_json</tt> on the object you want to render.
  # * <tt>:body</tt> - Renders provided text and sets content type of <tt>text/plain</tt>.
  #
  # If no <tt>options</tt> hash is passed or if <tt>:update</tt> is specified, then:
  #
  # If an object responding to +render_in+ is passed, +render_in+ is called on the object,
  # passing in the current view context.
  #
  # Otherwise, a partial is rendered using the second parameter as the locals hash.
  def render_to_string(*args); end

  # Create a new renderer for the same controller but with new defaults.
  def with_defaults(defaults); end

  private

  def normalize_keys(defaults, env); end
  def rack_key_for(key); end
  def rack_value_for(key, value); end

  class << self
    # Create a new renderer instance for a specific controller class.
    def for(controller, env = T.unsafe(nil), defaults = T.unsafe(nil)); end
  end
end

ActionController::Renderer::DEFAULTS = T.let(T.unsafe(nil), Hash)
ActionController::Renderer::RACK_KEY_TRANSLATION = T.let(T.unsafe(nil), Hash)

module ActionController::Renderers
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::ActionController::Renderers::ClassMethods

  def _render_to_body_with_renderer(options); end
  def _render_with_renderer_js(js, options); end
  def _render_with_renderer_json(json, options); end
  def _render_with_renderer_xml(xml, options); end

  # Called by +render+ in <tt>AbstractController::Rendering</tt>
  # which sets the return value as the +response_body+.
  #
  # If no renderer is found, +super+ returns control to
  # <tt>ActionView::Rendering.render_to_body</tt>, if present.
  def render_to_body(options); end

  class << self
    def _render_with_renderer_method_name(key); end

    # Adds a new renderer to call within controller actions.
    # A renderer is invoked by passing its name as an option to
    # <tt>AbstractController::Rendering#render</tt>. To create a renderer
    # pass it a name and a block. The block takes two arguments, the first
    # is the value paired with its key and the second is the remaining
    # hash of options passed to +render+.
    #
    # Create a csv renderer:
    #
    #   ActionController::Renderers.add :csv do |obj, options|
    #     filename = options[:filename] || 'data'
    #     str = obj.respond_to?(:to_csv) ? obj.to_csv : obj.to_s
    #     send_data str, type: Mime[:csv],
    #       disposition: "attachment; filename=#{filename}.csv"
    #   end
    #
    # Note that we used Mime[:csv] for the csv mime type as it comes with Rails.
    # For a custom renderer, you'll need to register a mime type with
    # <tt>Mime::Type.register</tt>.
    #
    # To use the csv renderer in a controller action:
    #
    #   def show
    #     @csvable = Csvable.find(params[:id])
    #     respond_to do |format|
    #       format.html
    #       format.csv { render csv: @csvable, filename: @csvable.name }
    #     end
    #   end
    def add(key, &block); end

    # This method is the opposite of add method.
    #
    # To remove a csv renderer:
    #
    #   ActionController::Renderers.remove(:csv)
    def remove(key); end
  end

  module GeneratedClassMethods
    def _renderers; end
    def _renderers=(value); end
    def _renderers?; end
  end

  module GeneratedInstanceMethods
    def _renderers; end
    def _renderers=(value); end
    def _renderers?; end
  end
end

# Used in <tt>ActionController::Base</tt>
# and <tt>ActionController::API</tt> to include all
# renderers by default.
module ActionController::Renderers::All
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods
  include ::ActionController::Renderers

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::ActionController::Renderers::ClassMethods

  module GeneratedClassMethods
    def _renderers; end
    def _renderers=(value); end
    def _renderers?; end
  end

  module GeneratedInstanceMethods
    def _renderers; end
    def _renderers=(value); end
    def _renderers?; end
  end
end

module ActionController::Renderers::ClassMethods
  # Adds, by name, a renderer or renderers to the +_renderers+ available
  # to call within controller actions.
  #
  # It is useful when rendering from an <tt>ActionController::Metal</tt> controller or
  # otherwise to add an available renderer proc to a specific controller.
  #
  # Both <tt>ActionController::Base</tt> and <tt>ActionController::API</tt>
  # include <tt>ActionController::Renderers::All</tt>, making all renderers
  # available in the controller. See <tt>Renderers::RENDERERS</tt> and <tt>Renderers.add</tt>.
  #
  # Since <tt>ActionController::Metal</tt> controllers cannot render, the controller
  # must include <tt>AbstractController::Rendering</tt>, <tt>ActionController::Rendering</tt>,
  # and <tt>ActionController::Renderers</tt>, and have at least one renderer.
  #
  # Rather than including <tt>ActionController::Renderers::All</tt> and including all renderers,
  # you may specify which renderers to include by passing the renderer name or names to
  # +use_renderers+. For example, a controller that includes only the <tt>:json</tt> renderer
  # (+_render_with_renderer_json+) might look like:
  #
  #   class MetalRenderingController < ActionController::Metal
  #     include AbstractController::Rendering
  #     include ActionController::Rendering
  #     include ActionController::Renderers
  #
  #     use_renderers :json
  #
  #     def show
  #       render json: record
  #     end
  #   end
  #
  # You must specify a +use_renderer+, else the +controller.renderer+ and
  # +controller._renderers+ will be <tt>nil</tt>, and the action will fail.
  def use_renderer(*args); end

  # Adds, by name, a renderer or renderers to the +_renderers+ available
  # to call within controller actions.
  #
  # It is useful when rendering from an <tt>ActionController::Metal</tt> controller or
  # otherwise to add an available renderer proc to a specific controller.
  #
  # Both <tt>ActionController::Base</tt> and <tt>ActionController::API</tt>
  # include <tt>ActionController::Renderers::All</tt>, making all renderers
  # available in the controller. See <tt>Renderers::RENDERERS</tt> and <tt>Renderers.add</tt>.
  #
  # Since <tt>ActionController::Metal</tt> controllers cannot render, the controller
  # must include <tt>AbstractController::Rendering</tt>, <tt>ActionController::Rendering</tt>,
  # and <tt>ActionController::Renderers</tt>, and have at least one renderer.
  #
  # Rather than including <tt>ActionController::Renderers::All</tt> and including all renderers,
  # you may specify which renderers to include by passing the renderer name or names to
  # +use_renderers+. For example, a controller that includes only the <tt>:json</tt> renderer
  # (+_render_with_renderer_json+) might look like:
  #
  #   class MetalRenderingController < ActionController::Metal
  #     include AbstractController::Rendering
  #     include ActionController::Rendering
  #     include ActionController::Renderers
  #
  #     use_renderers :json
  #
  #     def show
  #       render json: record
  #     end
  #   end
  #
  # You must specify a +use_renderer+, else the +controller.renderer+ and
  # +controller._renderers+ will be <tt>nil</tt>, and the action will fail.
  def use_renderers(*args); end
end

# A Set containing renderer names that correspond to available renderer procs.
# Default values are <tt>:json</tt>, <tt>:js</tt>, <tt>:xml</tt>.
ActionController::Renderers::RENDERERS = T.let(T.unsafe(nil), Set)

module ActionController::Rendering
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::ActionController::Rendering::ClassMethods

  # Before processing, set the request formats in current controller formats.
  def process_action(*_arg0); end

  # Check for double render errors and set the content_type after rendering.
  #
  # @raise [::AbstractController::DoubleRenderError]
  def render(*args); end

  def render_to_body(options = T.unsafe(nil)); end

  # Overwrite render_to_string because body can now be set to a Rack body.
  def render_to_string(*_arg0); end

  private

  # Normalize arguments by catching blocks and setting them on :update.
  def _normalize_args(action = T.unsafe(nil), options = T.unsafe(nil), &blk); end

  # Normalize both text and status options.
  def _normalize_options(options); end

  def _normalize_text(options); end

  # Process controller specific options, as status, content-type and location.
  def _process_options(options); end

  def _process_variant(options); end
  def _render_in_priorities(options); end
  def _set_html_content_type; end
  def _set_rendered_content_type(format); end
  def _set_vary_header; end
end

module ActionController::Rendering::ClassMethods
  def inherited(klass); end
  def render(*_arg0, &_arg1); end

  # Returns a renderer instance (inherited from ActionController::Renderer)
  # for the controller.
  def renderer; end

  def setup_renderer!; end
end

ActionController::Rendering::RENDER_FORMATS_IN_PRIORITY = T.let(T.unsafe(nil), Array)

# Controller actions are protected from Cross-Site Request Forgery (CSRF) attacks
# by including a token in the rendered HTML for your application. This token is
# stored as a random string in the session, to which an attacker does not have
# access. When a request reaches your application, \Rails verifies the received
# token with the token in the session. All requests are checked except GET requests
# as these should be idempotent. Keep in mind that all session-oriented requests
# are CSRF protected by default, including JavaScript and HTML requests.
#
# Since HTML and JavaScript requests are typically made from the browser, we
# need to ensure to verify request authenticity for the web browser. We can
# use session-oriented authentication for these types of requests, by using
# the <tt>protect_from_forgery</tt> method in our controllers.
#
# GET requests are not protected since they don't have side effects like writing
# to the database and don't leak sensitive information. JavaScript requests are
# an exception: a third-party site can use a <script> tag to reference a JavaScript
# URL on your site. When your JavaScript response loads on their site, it executes.
# With carefully crafted JavaScript on their end, sensitive data in your JavaScript
# response may be extracted. To prevent this, only XmlHttpRequest (known as XHR or
# Ajax) requests are allowed to make requests for JavaScript responses.
#
# Subclasses of <tt>ActionController::Base</tt> are protected by default with the
# <tt>:exception</tt> strategy, which raises an
# <tt>ActionController::InvalidAuthenticityToken</tt> error on unverified requests.
#
# APIs may want to disable this behavior since they are typically designed to be
# state-less: that is, the request API client handles the session instead of Rails.
# One way to achieve this is to use the <tt>:null_session</tt> strategy instead,
# which allows unverified requests to be handled, but with an empty session:
#
#   class ApplicationController < ActionController::Base
#     protect_from_forgery with: :null_session
#   end
#
# Note that API only applications don't include this module or a session middleware
# by default, and so don't require CSRF protection to be configured.
#
# The token parameter is named <tt>authenticity_token</tt> by default. The name and
# value of this token must be added to every layout that renders forms by including
# <tt>csrf_meta_tags</tt> in the HTML +head+.
#
# Learn more about CSRF attacks and securing your application in the
# {Ruby on Rails Security Guide}[https://guides.rubyonrails.org/security.html].
module ActionController::RequestForgeryProtection
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods
  include ::AbstractController::Helpers
  include ::ActiveSupport::Callbacks
  include ::AbstractController::Callbacks

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::AbstractController::Helpers::ClassMethods
  mixes_in_class_methods ::ActiveSupport::Callbacks::ClassMethods
  mixes_in_class_methods ::ActiveSupport::DescendantsTracker
  mixes_in_class_methods ::AbstractController::Callbacks::ClassMethods
  mixes_in_class_methods ::ActionController::RequestForgeryProtection::ClassMethods

  private

  # Checks if any of the authenticity tokens from the request are valid.
  #
  # @return [Boolean]
  def any_authenticity_token_valid?; end

  def compare_with_global_token(token, session); end
  def compare_with_real_token(token, session); end
  def csrf_token_hmac(session, identifier); end
  def decode_csrf_token(encoded_csrf_token); end
  def encode_csrf_token(csrf_token); end

  # The form's authenticity parameter. Override to provide your own.
  def form_authenticity_param; end

  # Sets the token value for the current session.
  def form_authenticity_token(form_options: T.unsafe(nil)); end

  def generate_csrf_token; end
  def global_csrf_token(session); end
  def handle_unverified_request; end

  # GET requests are checked for cross-origin JavaScript after rendering.
  def mark_for_same_origin_verification!; end

  # If the +verify_authenticity_token+ before_action ran, verify that
  # JavaScript responses are only served to same-origin GET requests.
  #
  # @return [Boolean]
  def marked_for_same_origin_verification?; end

  def mask_token(raw_token); end

  # Creates a masked version of the authenticity token that varies
  # on each request. The masking is used to mitigate SSL attacks
  # like BREACH.
  def masked_authenticity_token(session, form_options: T.unsafe(nil)); end

  # Check for cross-origin JavaScript responses.
  #
  # @return [Boolean]
  def non_xhr_javascript_response?; end

  def normalize_action_path(action_path); end
  def per_form_csrf_token(session, action_path, method); end

  # Checks if the controller allows forgery protection.
  #
  # @return [Boolean]
  def protect_against_forgery?; end

  def real_csrf_token(session); end

  # Possible authenticity tokens sent in the request.
  def request_authenticity_tokens; end

  def unmask_token(masked_token); end

  # Checks the client's masked token to see if it matches the
  # session token. Essentially the inverse of
  # +masked_authenticity_token+.
  #
  # @return [Boolean]
  def valid_authenticity_token?(session, encoded_masked_token); end

  # @return [Boolean]
  def valid_per_form_csrf_token?(token, session); end

  # Checks if the request originated from the same origin by looking at the
  # Origin header.
  #
  # @return [Boolean]
  def valid_request_origin?; end

  # Returns true or false if a request is verified. Checks:
  #
  # * Is it a GET or HEAD request? GETs should be safe and idempotent
  # * Does the form_authenticity_token match the given token value from the params?
  # * Does the X-CSRF-Token header match the form_authenticity_token?
  #
  # @return [Boolean]
  def verified_request?; end

  # The actual before_action that is used to verify the CSRF token.
  # Don't override this directly. Provide your own forgery protection
  # strategy instead. If you override, you'll disable same-origin
  # <tt><script></tt> verification.
  #
  # Lean on the protect_from_forgery declaration to mark which actions are
  # due for same-origin request verification. If protect_from_forgery is
  # enabled on an action, this before_action flags its after_action to
  # verify that JavaScript responses are for XHR requests, ensuring they
  # follow the browser's same-origin policy.
  def verify_authenticity_token; end

  # If +verify_authenticity_token+ was run (indicating that we have
  # forgery protection enabled for this request) then also verify that
  # we aren't serving an unauthorized cross-origin response.
  def verify_same_origin_request; end

  def xor_byte_strings(s1, s2); end

  module GeneratedClassMethods
    def __callbacks; end
    def __callbacks=(value); end
    def __callbacks?; end
    def _helper_methods; end
    def _helper_methods=(value); end
    def _helper_methods?; end
  end

  module GeneratedInstanceMethods
    def __callbacks; end
    def __callbacks?; end
    def _helper_methods; end
    def _helper_methods=(value); end
    def _helper_methods?; end
  end
end

ActionController::RequestForgeryProtection::AUTHENTICITY_TOKEN_LENGTH = T.let(T.unsafe(nil), Integer)
ActionController::RequestForgeryProtection::CROSS_ORIGIN_JAVASCRIPT_WARNING = T.let(T.unsafe(nil), String)

module ActionController::RequestForgeryProtection::ClassMethods
  # Turn on request forgery protection. Bear in mind that GET and HEAD requests are not checked.
  #
  #   class ApplicationController < ActionController::Base
  #     protect_from_forgery
  #   end
  #
  #   class FooController < ApplicationController
  #     protect_from_forgery except: :index
  #   end
  #
  # You can disable forgery protection on controller by skipping the verification before_action:
  #
  #   skip_before_action :verify_authenticity_token
  #
  # Valid Options:
  #
  # * <tt>:only/:except</tt> - Only apply forgery protection to a subset of actions. For example <tt>only: [ :create, :create_all ]</tt>.
  # * <tt>:if/:unless</tt> - Turn off the forgery protection entirely depending on the passed Proc or method reference.
  # * <tt>:prepend</tt> - By default, the verification of the authentication token will be added at the position of the
  #   protect_from_forgery call in your application. This means any callbacks added before are run first. This is useful
  #   when you want your forgery protection to depend on other callbacks, like authentication methods (Oauth vs Cookie auth).
  #
  #   If you need to add verification to the beginning of the callback chain, use <tt>prepend: true</tt>.
  # * <tt>:with</tt> - Set the method to handle unverified request.
  #
  # Valid unverified request handling methods are:
  # * <tt>:exception</tt> - Raises ActionController::InvalidAuthenticityToken exception.
  # * <tt>:reset_session</tt> - Resets the session.
  # * <tt>:null_session</tt> - Provides an empty session during request but doesn't reset it completely. Used as default if <tt>:with</tt> option is not specified.
  def protect_from_forgery(options = T.unsafe(nil)); end

  # Turn off request forgery protection. This is a wrapper for:
  #
  #   skip_before_action :verify_authenticity_token
  #
  # See +skip_before_action+ for allowed options.
  def skip_forgery_protection(options = T.unsafe(nil)); end

  private

  def protection_method_class(name); end
end

ActionController::RequestForgeryProtection::GLOBAL_CSRF_TOKEN_IDENTIFIER = T.let(T.unsafe(nil), String)
ActionController::RequestForgeryProtection::NULL_ORIGIN_MESSAGE = T.let(T.unsafe(nil), String)
module ActionController::RequestForgeryProtection::ProtectionMethods; end

class ActionController::RequestForgeryProtection::ProtectionMethods::Exception
  # @return [Exception] a new instance of Exception
  def initialize(controller); end

  # @raise [ActionController::InvalidAuthenticityToken]
  def handle_unverified_request; end
end

class ActionController::RequestForgeryProtection::ProtectionMethods::NullSession
  # @return [NullSession] a new instance of NullSession
  def initialize(controller); end

  # This is the method that defines the application behavior when a request is found to be unverified.
  def handle_unverified_request; end
end

class ActionController::RequestForgeryProtection::ProtectionMethods::NullSession::NullCookieJar < ::ActionDispatch::Cookies::CookieJar
  def write(*_arg0); end
end

class ActionController::RequestForgeryProtection::ProtectionMethods::NullSession::NullSessionHash < ::Rack::Session::Abstract::SessionHash
  # @return [NullSessionHash] a new instance of NullSessionHash
  def initialize(req); end

  # no-op
  def destroy; end

  # @return [Boolean]
  def exists?; end
end

class ActionController::RequestForgeryProtection::ProtectionMethods::ResetSession
  # @return [ResetSession] a new instance of ResetSession
  def initialize(controller); end

  def handle_unverified_request; end
end

# This module is responsible for providing +rescue_from+ helpers
# to controllers and configuring when detailed exceptions must be
# shown.
module ActionController::Rescue
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods
  include ::ActiveSupport::Rescuable

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::ActiveSupport::Rescuable::ClassMethods

  # Override this method if you want to customize when detailed
  # exceptions must be shown. This method is only called when
  # +consider_all_requests_local+ is +false+. By default, it returns
  # +false+, but someone may set it to <tt>request.local?</tt> so local
  # requests in production still show the detailed exception pages.
  #
  # @return [Boolean]
  def show_detailed_exceptions?; end

  private

  def process_action(*_arg0); end

  module GeneratedClassMethods
    def rescue_handlers; end
    def rescue_handlers=(value); end
    def rescue_handlers?; end
  end

  module GeneratedInstanceMethods
    def rescue_handlers; end
    def rescue_handlers=(value); end
    def rescue_handlers?; end
  end
end

# Raised when a nested respond_to is triggered and the content types of each
# are incompatible. For example:
#
#  respond_to do |outer_type|
#    outer_type.js do
#      respond_to do |inner_type|
#        inner_type.html { render body: "HTML" }
#      end
#    end
#  end
class ActionController::RespondToMismatchError < ::ActionController::ActionControllerError
  # @return [RespondToMismatchError] a new instance of RespondToMismatchError
  def initialize(message = T.unsafe(nil)); end
end

ActionController::RespondToMismatchError::DEFAULT_MESSAGE = T.let(T.unsafe(nil), String)

class ActionController::RoutingError < ::ActionController::ActionControllerError
  # @return [RoutingError] a new instance of RoutingError
  def initialize(message, failures = T.unsafe(nil)); end

  # Returns the value of attribute failures.
  def failures; end
end

class ActionController::SessionOverflowError < ::ActionController::ActionControllerError
  # @return [SessionOverflowError] a new instance of SessionOverflowError
  def initialize(message = T.unsafe(nil)); end
end

ActionController::SessionOverflowError::DEFAULT_MESSAGE = T.let(T.unsafe(nil), String)

# Allows views to be streamed back to the client as they are rendered.
#
# By default, Rails renders views by first rendering the template
# and then the layout. The response is sent to the client after the whole
# template is rendered, all queries are made, and the layout is processed.
#
# Streaming inverts the rendering flow by rendering the layout first and
# streaming each part of the layout as they are processed. This allows the
# header of the HTML (which is usually in the layout) to be streamed back
# to client very quickly, allowing JavaScripts and stylesheets to be loaded
# earlier than usual.
#
# This approach was introduced in Rails 3.1 and is still improving. Several
# Rack middlewares may not work and you need to be careful when streaming.
# Those points are going to be addressed soon.
#
# In order to use streaming, you will need to use a Ruby version that
# supports fibers (fibers are supported since version 1.9.2 of the main
# Ruby implementation).
#
# Streaming can be added to a given template easily, all you need to do is
# to pass the :stream option.
#
#   class PostsController
#     def index
#       @posts = Post.all
#       render stream: true
#     end
#   end
#
# == When to use streaming
#
# Streaming may be considered to be overkill for lightweight actions like
# +new+ or +edit+. The real benefit of streaming is on expensive actions
# that, for example, do a lot of queries on the database.
#
# In such actions, you want to delay queries execution as much as you can.
# For example, imagine the following +dashboard+ action:
#
#   def dashboard
#     @posts = Post.all
#     @pages = Page.all
#     @articles = Article.all
#   end
#
# Most of the queries here are happening in the controller. In order to benefit
# from streaming you would want to rewrite it as:
#
#   def dashboard
#     # Allow lazy execution of the queries
#     @posts = Post.all
#     @pages = Page.all
#     @articles = Article.all
#     render stream: true
#   end
#
# Notice that :stream only works with templates. Rendering :json
# or :xml with :stream won't work.
#
# == Communication between layout and template
#
# When streaming, rendering happens top-down instead of inside-out.
# Rails starts with the layout, and the template is rendered later,
# when its +yield+ is reached.
#
# This means that, if your application currently relies on instance
# variables set in the template to be used in the layout, they won't
# work once you move to streaming. The proper way to communicate
# between layout and template, regardless of whether you use streaming
# or not, is by using +content_for+, +provide+ and +yield+.
#
# Take a simple example where the layout expects the template to tell
# which title to use:
#
#   <html>
#     <head><title><%= yield :title %></title></head>
#     <body><%= yield %></body>
#   </html>
#
# You would use +content_for+ in your template to specify the title:
#
#   <%= content_for :title, "Main" %>
#   Hello
#
# And the final result would be:
#
#   <html>
#     <head><title>Main</title></head>
#     <body>Hello</body>
#   </html>
#
# However, if +content_for+ is called several times, the final result
# would have all calls concatenated. For instance, if we have the following
# template:
#
#   <%= content_for :title, "Main" %>
#   Hello
#   <%= content_for :title, " page" %>
#
# The final result would be:
#
#   <html>
#     <head><title>Main page</title></head>
#     <body>Hello</body>
#   </html>
#
# This means that, if you have <code>yield :title</code> in your layout
# and you want to use streaming, you would have to render the whole template
# (and eventually trigger all queries) before streaming the title and all
# assets, which kills the purpose of streaming. For this purpose, you can use
# a helper called +provide+ that does the same as +content_for+ but tells the
# layout to stop searching for other entries and continue rendering.
#
# For instance, the template above using +provide+ would be:
#
#   <%= provide :title, "Main" %>
#   Hello
#   <%= content_for :title, " page" %>
#
# Giving:
#
#   <html>
#     <head><title>Main</title></head>
#     <body>Hello</body>
#   </html>
#
# That said, when streaming, you need to properly check your templates
# and choose when to use +provide+ and +content_for+.
#
# == Headers, cookies, session and flash
#
# When streaming, the HTTP headers are sent to the client right before
# it renders the first line. This means that, modifying headers, cookies,
# session or flash after the template starts rendering will not propagate
# to the client.
#
# == Middlewares
#
# Middlewares that need to manipulate the body won't work with streaming.
# You should disable those middlewares whenever streaming in development
# or production. For instance, <tt>Rack::Bug</tt> won't work when streaming as it
# needs to inject contents in the HTML body.
#
# Also <tt>Rack::Cache</tt> won't work with streaming as it does not support
# streaming bodies yet. Whenever streaming Cache-Control is automatically
# set to "no-cache".
#
# == Errors
#
# When it comes to streaming, exceptions get a bit more complicated. This
# happens because part of the template was already rendered and streamed to
# the client, making it impossible to render a whole exception page.
#
# Currently, when an exception happens in development or production, Rails
# will automatically stream to the client:
#
#   "><script>window.location = "/500.html"</script></html>
#
# The first two characters (">) are required in case the exception happens
# while rendering attributes for a given tag. You can check the real cause
# for the exception in your logger.
#
# == Web server support
#
# Not all web servers support streaming out-of-the-box. You need to check
# the instructions for each of them.
#
# ==== Unicorn
#
# Unicorn supports streaming but it needs to be configured. For this, you
# need to create a config file as follow:
#
#   # unicorn.config.rb
#   listen 3000, tcp_nopush: false
#
# And use it on initialization:
#
#   unicorn_rails --config-file unicorn.config.rb
#
# You may also want to configure other parameters like <tt>:tcp_nodelay</tt>.
# Please check its documentation for more information: https://bogomips.org/unicorn/Unicorn/Configurator.html#method-i-listen
#
# If you are using Unicorn with NGINX, you may need to tweak NGINX.
# Streaming should work out of the box on Rainbows.
#
# ==== Passenger
#
# To be described.
module ActionController::Streaming
  extend ::ActiveSupport::Concern

  private

  # Set proper cache control and transfer encoding when streaming
  def _process_options(options); end

  # Call render_body if we are streaming instead of usual +render+.
  def _render_template(options); end
end

# == Strong \Parameters
#
# It provides an interface for protecting attributes from end-user
# assignment. This makes Action Controller parameters forbidden
# to be used in Active Model mass assignment until they have been explicitly
# enumerated.
#
# In addition, parameters can be marked as required and flow through a
# predefined raise/rescue flow to end up as a <tt>400 Bad Request</tt> with no
# effort.
#
#   class PeopleController < ActionController::Base
#     # Using "Person.create(params[:person])" would raise an
#     # ActiveModel::ForbiddenAttributesError exception because it'd
#     # be using mass assignment without an explicit permit step.
#     # This is the recommended form:
#     def create
#       Person.create(person_params)
#     end
#
#     # This will pass with flying colors as long as there's a person key in the
#     # parameters, otherwise it'll raise an ActionController::ParameterMissing
#     # exception, which will get caught by ActionController::Base and turned
#     # into a 400 Bad Request reply.
#     def update
#       redirect_to current_account.people.find(params[:id]).tap { |person|
#         person.update!(person_params)
#       }
#     end
#
#     private
#       # Using a private method to encapsulate the permissible parameters is
#       # a good pattern since you'll be able to reuse the same permit
#       # list between create and update. Also, you can specialize this method
#       # with per-user checking of permissible attributes.
#       def person_params
#         params.require(:person).permit(:name, :age)
#       end
#   end
#
# In order to use <tt>accepts_nested_attributes_for</tt> with Strong \Parameters, you
# will need to specify which nested attributes should be permitted. You might want
# to allow +:id+ and +:_destroy+, see ActiveRecord::NestedAttributes for more information.
#
#   class Person
#     has_many :pets
#     accepts_nested_attributes_for :pets
#   end
#
#   class PeopleController < ActionController::Base
#     def create
#       Person.create(person_params)
#     end
#
#     ...
#
#     private
#
#       def person_params
#         # It's mandatory to specify the nested attributes that should be permitted.
#         # If you use `permit` with just the key that points to the nested attributes hash,
#         # it will return an empty hash.
#         params.require(:person).permit(:name, :age, pets_attributes: [ :id, :name, :category ])
#       end
#   end
#
# See ActionController::Parameters.require and ActionController::Parameters.permit
# for more information.
module ActionController::StrongParameters
  # Returns a new ActionController::Parameters object that
  # has been instantiated with the <tt>request.parameters</tt>.
  def params; end

  # Assigns the given +value+ to the +params+ hash. If +value+
  # is a Hash, this will create an ActionController::Parameters
  # object that has been instantiated with the given +value+ hash.
  def params=(value); end
end

module ActionController::TemplateAssertions
  # @raise [NoMethodError]
  def assert_template(options = T.unsafe(nil), message = T.unsafe(nil)); end
end

# Superclass for ActionController functional tests. Functional tests allow you to
# test a single controller action per test method.
#
# == Use integration style controller tests over functional style controller tests.
#
# Rails discourages the use of functional tests in favor of integration tests
# (use ActionDispatch::IntegrationTest).
#
# New Rails applications no longer generate functional style controller tests and they should
# only be used for backward compatibility. Integration style controller tests perform actual
# requests, whereas functional style controller tests merely simulate a request. Besides,
# integration tests are as fast as functional tests and provide lot of helpers such as +as+,
# +parsed_body+ for effective testing of controller actions including even API endpoints.
#
# == Basic example
#
# Functional tests are written as follows:
# 1. First, one uses the +get+, +post+, +patch+, +put+, +delete+ or +head+ method to simulate
#    an HTTP request.
# 2. Then, one asserts whether the current state is as expected. "State" can be anything:
#    the controller's HTTP response, the database contents, etc.
#
# For example:
#
#   class BooksControllerTest < ActionController::TestCase
#     def test_create
#       # Simulate a POST response with the given HTTP parameters.
#       post(:create, params: { book: { title: "Love Hina" }})
#
#       # Asserts that the controller tried to redirect us to
#       # the created book's URI.
#       assert_response :found
#
#       # Asserts that the controller really put the book in the database.
#       assert_not_nil Book.find_by(title: "Love Hina")
#     end
#   end
#
# You can also send a real document in the simulated HTTP request.
#
#   def test_create
#     json = {book: { title: "Love Hina" }}.to_json
#     post :create, body: json
#   end
#
# == Special instance variables
#
# ActionController::TestCase will also automatically provide the following instance
# variables for use in the tests:
#
# <b>@controller</b>::
#      The controller instance that will be tested.
# <b>@request</b>::
#      An ActionController::TestRequest, representing the current HTTP
#      request. You can modify this object before sending the HTTP request. For example,
#      you might want to set some session properties before sending a GET request.
# <b>@response</b>::
#      An ActionDispatch::TestResponse object, representing the response
#      of the last HTTP response. In the above example, <tt>@response</tt> becomes valid
#      after calling +post+. If the various assert methods are not sufficient, then you
#      may use this object to inspect the HTTP response in detail.
#
# == Controller is automatically inferred
#
# ActionController::TestCase will automatically infer the controller under test
# from the test class name. If the controller cannot be inferred from the test
# class name, you can explicitly set it with +tests+.
#
#   class SpecialEdgeCaseWidgetsControllerTest < ActionController::TestCase
#     tests WidgetController
#   end
#
# == \Testing controller internals
#
# In addition to these specific assertions, you also have easy access to various collections that the regular test/unit assertions
# can be used against. These collections are:
#
# * session: Objects being saved in the session.
# * flash: The flash objects currently in the session.
# * cookies: \Cookies being sent to the user on this request.
#
# These collections can be used just like any other hash:
#
#   assert_equal "Dave", cookies[:name] # makes sure that a cookie called :name was set as "Dave"
#   assert flash.empty? # makes sure that there's nothing in the flash
#
# On top of the collections, you have the complete URL that a given action redirected to available in <tt>redirect_to_url</tt>.
#
# For redirects within the same controller, you can even call follow_redirect and the redirect will be followed, triggering another
# action call which can then be asserted against.
#
# == Manipulating session and cookie variables
#
# Sometimes you need to set up the session and cookie variables for a test.
# To do this just assign a value to the session or cookie collection:
#
#   session[:key] = "value"
#   cookies[:key] = "value"
#
# To clear the cookies for a test just clear the cookie collection:
#
#   cookies.clear
#
# == \Testing named routes
#
# If you're using named routes, they can be easily tested using the original named routes' methods straight in the test case.
#
#  assert_redirected_to page_url(title: 'foo')
class ActionController::TestCase < ::ActiveSupport::TestCase
  include ::ActiveSupport::Testing::ConstantLookup
  include ::Rails::Dom::Testing::Assertions::DomAssertions
  include ::Rails::Dom::Testing::Assertions::SelectorAssertions::CountDescribable
  include ::Rails::Dom::Testing::Assertions::SelectorAssertions
  include ::Rails::Dom::Testing::Assertions
  include ::ActionDispatch::TestProcess::FixtureFile
  include ::ActionDispatch::TestProcess
  include ::ActionController::TestCase::Behavior
  include ::ActionController::TemplateAssertions
  include ::ActionDispatch::Assertions::ResponseAssertions
  include ::ActionDispatch::Assertions::RoutingAssertions
  include ::ActionDispatch::Assertions
  extend ::ActiveSupport::Testing::ConstantLookup::ClassMethods
  extend ::ActionController::TestCase::Behavior::ClassMethods

  def _controller_class; end
  def _controller_class=(_arg0); end
  def _controller_class?; end

  class << self
    def __callbacks; end
    def _controller_class; end
    def _controller_class=(value); end
    def _controller_class?; end
  end
end

module ActionController::TestCase::Behavior
  include ::ActionDispatch::TestProcess::FixtureFile
  include ::ActionDispatch::TestProcess
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods
  include ::ActiveSupport::Testing::ConstantLookup
  include ::Rails::Dom::Testing::Assertions
  include ::ActionController::TemplateAssertions
  include ::ActionDispatch::Assertions

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::ActiveSupport::Testing::ConstantLookup::ClassMethods
  mixes_in_class_methods ::ActionController::TestCase::Behavior::ClassMethods

  def build_response(klass); end
  def controller_class_name; end

  # Simulate a DELETE request with the given parameters and set/volley the response.
  # See +get+ for more details.
  def delete(action, **args); end

  def generated_path(generated_extras); end

  # Simulate a GET request with the given parameters.
  #
  # - +action+: The controller action to call.
  # - +params+: The hash with HTTP parameters that you want to pass. This may be +nil+.
  # - +body+: The request body with a string that is appropriately encoded
  #   (<tt>application/x-www-form-urlencoded</tt> or <tt>multipart/form-data</tt>).
  # - +session+: A hash of parameters to store in the session. This may be +nil+.
  # - +flash+: A hash of parameters to store in the flash. This may be +nil+.
  #
  # You can also simulate POST, PATCH, PUT, DELETE, and HEAD requests with
  # +post+, +patch+, +put+, +delete+, and +head+.
  # Example sending parameters, session and setting a flash message:
  #
  #   get :show,
  #     params: { id: 7 },
  #     session: { user_id: 1 },
  #     flash: { notice: 'This is flash message' }
  #
  # Note that the request method is not verified. The different methods are
  # available to make the tests more expressive.
  def get(action, **args); end

  # Simulate a HEAD request with the given parameters and set/volley the response.
  # See +get+ for more details.
  def head(action, **args); end

  # Simulate a PATCH request with the given parameters and set/volley the response.
  # See +get+ for more details.
  def patch(action, **args); end

  # Simulate a POST request with the given parameters and set/volley the response.
  # See +get+ for more details.
  def post(action, **args); end

  # Simulate an HTTP request to +action+ by specifying request method,
  # parameters and set/volley the response.
  #
  # - +action+: The controller action to call.
  # - +method+: Request method used to send the HTTP request. Possible values
  #   are +GET+, +POST+, +PATCH+, +PUT+, +DELETE+, +HEAD+. Defaults to +GET+. Can be a symbol.
  # - +params+: The hash with HTTP parameters that you want to pass. This may be +nil+.
  # - +body+: The request body with a string that is appropriately encoded
  #   (<tt>application/x-www-form-urlencoded</tt> or <tt>multipart/form-data</tt>).
  # - +session+: A hash of parameters to store in the session. This may be +nil+.
  # - +flash+: A hash of parameters to store in the flash. This may be +nil+.
  # - +format+: Request format. Defaults to +nil+. Can be string or symbol.
  # - +as+: Content type. Defaults to +nil+. Must be a symbol that corresponds
  #   to a mime type.
  #
  # Example calling +create+ action and sending two params:
  #
  #   process :create,
  #     method: 'POST',
  #     params: {
  #       user: { name: 'Gaurish Sharma', email: 'user@example.com' }
  #     },
  #     session: { user_id: 1 },
  #     flash: { notice: 'This is flash message' }
  #
  # To simulate +GET+, +POST+, +PATCH+, +PUT+, +DELETE+ and +HEAD+ requests
  # prefer using #get, #post, #patch, #put, #delete and #head methods
  # respectively which will make tests more expressive.
  #
  # Note that the request method is not verified.
  def process(action, method: T.unsafe(nil), params: T.unsafe(nil), session: T.unsafe(nil), body: T.unsafe(nil), flash: T.unsafe(nil), format: T.unsafe(nil), xhr: T.unsafe(nil), as: T.unsafe(nil)); end

  # Simulate a PUT request with the given parameters and set/volley the response.
  # See +get+ for more details.
  def put(action, **args); end

  def query_parameter_names(generated_extras); end

  # Returns the value of attribute request.
  def request; end

  # Returns the value of attribute response.
  def response; end

  def setup_controller_request_and_response; end

  private

  def check_required_ivars; end
  def document_root_element; end
  def process_controller_response(action, cookies, xhr); end
  def scrub_env!(env); end
  def setup_request(controller_class_name, action, parameters, session, flash, xhr); end

  module GeneratedClassMethods
    def _controller_class; end
    def _controller_class=(value); end
    def _controller_class?; end
  end

  module GeneratedInstanceMethods
    def _controller_class; end
    def _controller_class=(value); end
    def _controller_class?; end
  end
end

module ActionController::TestCase::Behavior::ClassMethods
  def controller_class; end
  def controller_class=(new_class); end
  def determine_default_controller_class(name); end

  # Sets the controller class name. Useful if the name can't be inferred from test class.
  # Normalizes +controller_class+ before using.
  #
  #   tests WidgetController
  #   tests :widget
  #   tests 'widget'
  def tests(controller_class); end
end

# ActionController::TestCase will be deprecated and moved to a gem in the future.
# Please use ActionDispatch::IntegrationTest going forward.
class ActionController::TestRequest < ::ActionDispatch::TestRequest
  # @return [TestRequest] a new instance of TestRequest
  def initialize(env, session, controller_class); end

  def assign_parameters(routes, controller_path, action, parameters, generated_path, query_string_keys); end
  def content_type=(type); end

  # Returns the value of attribute controller_class.
  def controller_class; end

  def query_string=(string); end

  private

  def params_parsers; end

  class << self
    # Create a new test request with default `env` values.
    def create(controller_class); end

    def new_session; end

    private

    def default_env; end
  end
end

ActionController::TestRequest::DEFAULT_ENV = T.let(T.unsafe(nil), Hash)
ActionController::TestRequest::ENCODER = T.let(T.unsafe(nil), T.untyped)

# Methods #destroy and #load! are overridden to avoid calling methods on the
class ActionController::TestSession < ::Rack::Session::Abstract::PersistedSecure::SecureSessionHash
  # @return [TestSession] a new instance of TestSession
  def initialize(session = T.unsafe(nil)); end

  def destroy; end
  def dig(*keys); end

  # @return [Boolean]
  def exists?; end

  def fetch(key, *args, &block); end
  def keys; end
  def values; end

  private

  def load!; end
end

ActionController::TestSession::DEFAULT_OPTIONS = T.let(T.unsafe(nil), Hash)

module ActionController::Testing
  extend ::ActiveSupport::Concern
end

# Behavior specific to functional tests
module ActionController::Testing::Functional
  def recycle!; end
end

# Raised when a Parameters instance is not marked as permitted and
# an operation to transform it to hash is called.
#
#   params = ActionController::Parameters.new(a: "123", b: "456")
#   params.to_h
#   # => ActionController::UnfilteredParameters: unable to convert unpermitted parameters to hash
class ActionController::UnfilteredParameters < ::ArgumentError
  # @return [UnfilteredParameters] a new instance of UnfilteredParameters
  def initialize; end
end

class ActionController::UnknownFormat < ::ActionController::ActionControllerError; end
class ActionController::UnknownHttpMethod < ::ActionController::ActionControllerError; end

# Raised when a supplied parameter is not expected and
# ActionController::Parameters.action_on_unpermitted_parameters
# is set to <tt>:raise</tt>.
#
#   params = ActionController::Parameters.new(a: "123", b: "456")
#   params.permit(:c)
#   # => ActionController::UnpermittedParameters: found unpermitted parameters: :a, :b
class ActionController::UnpermittedParameters < ::IndexError
  # @return [UnpermittedParameters] a new instance of UnpermittedParameters
  def initialize(params); end

  def params; end
end

# Includes +url_for+ into the host class. The class has to provide a +RouteSet+ by implementing
# the <tt>_routes</tt> method. Otherwise, an exception will be raised.
#
# In addition to <tt>AbstractController::UrlFor</tt>, this module accesses the HTTP layer to define
# URL options like the +host+. In order to do so, this module requires the host class
# to implement +env+ which needs to be Rack-compatible and +request+
# which is either an instance of +ActionDispatch::Request+ or an object
# that responds to the +host+, +optional_port+, +protocol+ and
# +symbolized_path_parameter+ methods.
#
#   class RootUrl
#     include ActionController::UrlFor
#     include Rails.application.routes.url_helpers
#
#     delegate :env, :request, to: :controller
#
#     def initialize(controller)
#       @controller = controller
#       @url        = root_path # named route from the application.
#     end
#   end
module ActionController::UrlFor
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods
  include ::ActionDispatch::Routing::UrlFor
  include ::AbstractController::UrlFor

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::AbstractController::UrlFor::ClassMethods

  def url_options; end

  module GeneratedClassMethods
    def default_url_options; end
    def default_url_options=(value); end
    def default_url_options?; end
  end

  module GeneratedInstanceMethods
    def default_url_options; end
    def default_url_options=(value); end
    def default_url_options?; end
  end
end

class ActionController::UrlGenerationError < ::ActionController::ActionControllerError
  include ::DidYouMean::Correctable

  # @return [UrlGenerationError] a new instance of UrlGenerationError
  def initialize(message, routes = T.unsafe(nil), route_name = T.unsafe(nil), method_name = T.unsafe(nil)); end

  # Returns the value of attribute method_name.
  def method_name; end

  # Returns the value of attribute route_name.
  def route_name; end

  # Returns the value of attribute routes.
  def routes; end
end

class ActionController::UrlGenerationError::Correction
  # @return [Correction] a new instance of Correction
  def initialize(error); end

  def corrections; end
end

module ActionDispatch
  extend ::ActiveSupport::Autoload

  def test_app; end
  def test_app=(val); end

  class << self
    def test_app; end
    def test_app=(val); end
  end
end

class ActionDispatch::ActionableExceptions
  # @return [ActionableExceptions] a new instance of ActionableExceptions
  def initialize(app); end

  def call(env); end
  def endpoint; end
  def endpoint=(val); end

  private

  # @return [Boolean]
  def actionable_request?(request); end

  def redirect_to(location); end

  class << self
    def endpoint; end
    def endpoint=(val); end
  end
end

# This is a class that abstracts away an asserted response. It purposely
# does not inherit from Response because it doesn't need it. That means it
# does not have headers or a body.
class ActionDispatch::AssertionResponse
  # Accepts a specific response status code as an Integer (404) or String
  # ('404') or a response status range as a Symbol pseudo-code (:success,
  # indicating any 200-299 status code).
  #
  # @raise [ArgumentError]
  # @return [AssertionResponse] a new instance of AssertionResponse
  def initialize(code_or_name); end

  # Returns the value of attribute code.
  def code; end

  def code_and_name; end

  # Returns the value of attribute name.
  def name; end

  private

  def code_from_name(name); end
  def name_from_code(code); end
end

ActionDispatch::AssertionResponse::GENERIC_RESPONSE_CODES = T.let(T.unsafe(nil), Hash)

module ActionDispatch::Assertions
  include ::ActionDispatch::Assertions::ResponseAssertions
  include ::ActionDispatch::Assertions::RoutingAssertions
  extend ::ActiveSupport::Concern
  include ::Rails::Dom::Testing::Assertions

  def html_document; end
end

# A small suite of assertions that test responses from \Rails applications.
module ActionDispatch::Assertions::ResponseAssertions
  # Asserts that the response is a redirect to a URL matching the given options.
  #
  #   # Asserts that the redirection was to the "index" action on the WeblogController
  #   assert_redirected_to controller: "weblog", action: "index"
  #
  #   # Asserts that the redirection was to the named route login_url
  #   assert_redirected_to login_url
  #
  #   # Asserts that the redirection was to the URL for @customer
  #   assert_redirected_to @customer
  #
  #   # Asserts that the redirection matches the regular expression
  #   assert_redirected_to %r(\Ahttp://example.org)
  def assert_redirected_to(options = T.unsafe(nil), message = T.unsafe(nil)); end

  # Asserts that the response is one of the following types:
  #
  # * <tt>:success</tt>   - Status code was in the 200-299 range
  # * <tt>:redirect</tt>  - Status code was in the 300-399 range
  # * <tt>:missing</tt>   - Status code was 404
  # * <tt>:error</tt>     - Status code was in the 500-599 range
  #
  # You can also pass an explicit status number like <tt>assert_response(501)</tt>
  # or its symbolic equivalent <tt>assert_response(:not_implemented)</tt>.
  # See Rack::Utils::SYMBOL_TO_STATUS_CODE for a full list.
  #
  #   # Asserts that the response was a redirection
  #   assert_response :redirect
  #
  #   # Asserts that the response code was status code 401 (unauthorized)
  #   assert_response 401
  def assert_response(type, message = T.unsafe(nil)); end

  private

  def code_with_name(code_or_name); end
  def generate_response_message(expected, actual = T.unsafe(nil)); end
  def location_if_redirected; end
  def normalize_argument_to_redirection(fragment); end

  # Proxy to to_param if the object will respond to it.
  def parameterize(value); end

  def response_body_if_short; end
end

ActionDispatch::Assertions::ResponseAssertions::RESPONSE_PREDICATES = T.let(T.unsafe(nil), Hash)

# Suite of assertions to test routes generated by \Rails and the handling of requests made to them.
module ActionDispatch::Assertions::RoutingAssertions
  # Asserts that the provided options can be used to generate the provided path. This is the inverse of +assert_recognizes+.
  # The +extras+ parameter is used to tell the request the names and values of additional request parameters that would be in
  # a query string. The +message+ parameter allows you to specify a custom error message for assertion failures.
  #
  # The +defaults+ parameter is unused.
  #
  #   # Asserts that the default action is generated for a route with no action
  #   assert_generates "/items", controller: "items", action: "index"
  #
  #   # Tests that the list action is properly routed
  #   assert_generates "/items/list", controller: "items", action: "list"
  #
  #   # Tests the generation of a route with a parameter
  #   assert_generates "/items/list/1", { controller: "items", action: "list", id: "1" }
  #
  #   # Asserts that the generated route gives us our custom route
  #   assert_generates "changesets/12", { controller: 'scm', action: 'show_diff', revision: "12" }
  def assert_generates(expected_path, options, defaults = T.unsafe(nil), extras = T.unsafe(nil), message = T.unsafe(nil)); end

  # Asserts that the routing of the given +path+ was handled correctly and that the parsed options (given in the +expected_options+ hash)
  # match +path+. Basically, it asserts that \Rails recognizes the route given by +expected_options+.
  #
  # Pass a hash in the second argument (+path+) to specify the request method. This is useful for routes
  # requiring a specific HTTP method. The hash should contain a :path with the incoming request path
  # and a :method containing the required HTTP verb.
  #
  #   # Asserts that POSTing to /items will call the create action on ItemsController
  #   assert_recognizes({controller: 'items', action: 'create'}, {path: 'items', method: :post})
  #
  # You can also pass in +extras+ with a hash containing URL parameters that would normally be in the query string. This can be used
  # to assert that values in the query string will end up in the params hash correctly. To test query strings you must use the extras
  # argument because appending the query string on the path directly will not work. For example:
  #
  #   # Asserts that a path of '/items/list/1?view=print' returns the correct options
  #   assert_recognizes({controller: 'items', action: 'list', id: '1', view: 'print'}, 'items/list/1', { view: "print" })
  #
  # The +message+ parameter allows you to pass in an error message that is displayed upon failure.
  #
  #   # Check the default route (i.e., the index action)
  #   assert_recognizes({controller: 'items', action: 'index'}, 'items')
  #
  #   # Test a specific action
  #   assert_recognizes({controller: 'items', action: 'list'}, 'items/list')
  #
  #   # Test an action with a parameter
  #   assert_recognizes({controller: 'items', action: 'destroy', id: '1'}, 'items/destroy/1')
  #
  #   # Test a custom route
  #   assert_recognizes({controller: 'items', action: 'show', id: '1'}, 'view/item1')
  def assert_recognizes(expected_options, path, extras = T.unsafe(nil), msg = T.unsafe(nil)); end

  # Asserts that path and options match both ways; in other words, it verifies that <tt>path</tt> generates
  # <tt>options</tt> and then that <tt>options</tt> generates <tt>path</tt>. This essentially combines +assert_recognizes+
  # and +assert_generates+ into one step.
  #
  # The +extras+ hash allows you to specify options that would normally be provided as a query string to the action. The
  # +message+ parameter allows you to specify a custom error message to display upon failure.
  #
  #  # Asserts a basic route: a controller with the default action (index)
  #  assert_routing '/home', controller: 'home', action: 'index'
  #
  #  # Test a route generated with a specific controller, action, and parameter (id)
  #  assert_routing '/entries/show/23', controller: 'entries', action: 'show', id: 23
  #
  #  # Asserts a basic route (controller + default action), with an error message if it fails
  #  assert_routing '/store', { controller: 'store', action: 'index' }, {}, {}, 'Route for store index not generated properly'
  #
  #  # Tests a route, providing a defaults hash
  #  assert_routing 'controller/action/9', {id: "9", item: "square"}, {controller: "controller", action: "action"}, {}, {item: "square"}
  #
  #  # Tests a route with an HTTP method
  #  assert_routing({ method: 'put', path: '/product/321' }, { controller: "product", action: "update", id: "321" })
  def assert_routing(path, options, defaults = T.unsafe(nil), extras = T.unsafe(nil), message = T.unsafe(nil)); end

  # ROUTES TODO: These assertions should really work in an integration context
  def method_missing(selector, *args, &block); end

  def setup; end

  # A helper to make it easier to test different route configurations.
  # This method temporarily replaces @routes with a new RouteSet instance.
  #
  # The new instance is yielded to the passed block. Typically the block
  # will create some routes using <tt>set.draw { match ... }</tt>:
  #
  #   with_routing do |set|
  #     set.draw do
  #       resources :users
  #     end
  #     assert_equal "/users", users_path
  #   end
  def with_routing; end

  private

  def fail_on(exception_class, message); end

  # Recognizes the route for a given path.
  def recognized_request_for(path, extras = T.unsafe(nil), msg); end
end

# Provides callbacks to be executed before and after dispatching the request.
class ActionDispatch::Callbacks
  include ::ActiveSupport::Callbacks
  extend ::ActiveSupport::Callbacks::ClassMethods
  extend ::ActiveSupport::DescendantsTracker

  # @return [Callbacks] a new instance of Callbacks
  def initialize(app); end

  def __callbacks; end
  def __callbacks?; end
  def _call_callbacks; end
  def _run_call_callbacks(&block); end
  def call(env); end

  class << self
    def __callbacks; end
    def __callbacks=(value); end
    def __callbacks?; end
    def _call_callbacks; end
    def _call_callbacks=(value); end
    def after(*args, &block); end
    def before(*args, &block); end
  end
end

class ActionDispatch::ContentSecurityPolicy
  # @return [ContentSecurityPolicy] a new instance of ContentSecurityPolicy
  # @yield [_self]
  # @yieldparam _self [ActionDispatch::ContentSecurityPolicy] the object that the method was called on
  def initialize; end

  def base_uri(*sources); end
  def block_all_mixed_content(enabled = T.unsafe(nil)); end
  def build(context = T.unsafe(nil), nonce = T.unsafe(nil), nonce_directives = T.unsafe(nil)); end
  def child_src(*sources); end
  def connect_src(*sources); end
  def default_src(*sources); end

  # Returns the value of attribute directives.
  def directives; end

  def font_src(*sources); end
  def form_action(*sources); end
  def frame_ancestors(*sources); end
  def frame_src(*sources); end
  def img_src(*sources); end
  def manifest_src(*sources); end
  def media_src(*sources); end
  def object_src(*sources); end
  def plugin_types(*types); end
  def prefetch_src(*sources); end
  def report_uri(uri); end
  def require_sri_for(*types); end
  def sandbox(*values); end
  def script_src(*sources); end
  def script_src_attr(*sources); end
  def script_src_elem(*sources); end
  def style_src(*sources); end
  def style_src_attr(*sources); end
  def style_src_elem(*sources); end
  def upgrade_insecure_requests(enabled = T.unsafe(nil)); end
  def worker_src(*sources); end

  private

  def apply_mapping(source); end
  def apply_mappings(sources); end
  def build_directive(sources, context); end
  def build_directives(context, nonce, nonce_directives); end
  def initialize_copy(other); end

  # @return [Boolean]
  def nonce_directive?(directive, nonce_directives); end

  def resolve_source(source, context); end
end

ActionDispatch::ContentSecurityPolicy::DEFAULT_NONCE_DIRECTIVES = T.let(T.unsafe(nil), Array)
ActionDispatch::ContentSecurityPolicy::DIRECTIVES = T.let(T.unsafe(nil), Hash)
ActionDispatch::ContentSecurityPolicy::MAPPINGS = T.let(T.unsafe(nil), Hash)

class ActionDispatch::ContentSecurityPolicy::Middleware
  # @return [Middleware] a new instance of Middleware
  def initialize(app); end

  def call(env); end

  private

  def header_name(request); end

  # @return [Boolean]
  def policy_present?(headers); end
end

ActionDispatch::ContentSecurityPolicy::Middleware::CONTENT_TYPE = T.let(T.unsafe(nil), String)
ActionDispatch::ContentSecurityPolicy::Middleware::POLICY = T.let(T.unsafe(nil), String)
ActionDispatch::ContentSecurityPolicy::Middleware::POLICY_REPORT_ONLY = T.let(T.unsafe(nil), String)

module ActionDispatch::ContentSecurityPolicy::Request
  def content_security_policy; end
  def content_security_policy=(policy); end
  def content_security_policy_nonce; end
  def content_security_policy_nonce_directives; end
  def content_security_policy_nonce_directives=(generator); end
  def content_security_policy_nonce_generator; end
  def content_security_policy_nonce_generator=(generator); end
  def content_security_policy_report_only; end
  def content_security_policy_report_only=(value); end

  private

  def generate_content_security_policy_nonce; end
end

ActionDispatch::ContentSecurityPolicy::Request::NONCE = T.let(T.unsafe(nil), String)
ActionDispatch::ContentSecurityPolicy::Request::NONCE_DIRECTIVES = T.let(T.unsafe(nil), String)
ActionDispatch::ContentSecurityPolicy::Request::NONCE_GENERATOR = T.let(T.unsafe(nil), String)
ActionDispatch::ContentSecurityPolicy::Request::POLICY = T.let(T.unsafe(nil), String)
ActionDispatch::ContentSecurityPolicy::Request::POLICY_REPORT_ONLY = T.let(T.unsafe(nil), String)

# Read and write data to cookies through ActionController#cookies.
#
# When reading cookie data, the data is read from the HTTP request header, Cookie.
# When writing cookie data, the data is sent out in the HTTP response header, Set-Cookie.
#
# Examples of writing:
#
#   # Sets a simple session cookie.
#   # This cookie will be deleted when the user's browser is closed.
#   cookies[:user_name] = "david"
#
#   # Cookie values are String based. Other data types need to be serialized.
#   cookies[:lat_lon] = JSON.generate([47.68, -122.37])
#
#   # Sets a cookie that expires in 1 hour.
#   cookies[:login] = { value: "XJ-122", expires: 1.hour }
#
#   # Sets a cookie that expires at a specific time.
#   cookies[:login] = { value: "XJ-122", expires: Time.utc(2020, 10, 15, 5) }
#
#   # Sets a signed cookie, which prevents users from tampering with its value.
#   # It can be read using the signed method `cookies.signed[:name]`
#   cookies.signed[:user_id] = current_user.id
#
#   # Sets an encrypted cookie value before sending it to the client which
#   # prevent users from reading and tampering with its value.
#   # It can be read using the encrypted method `cookies.encrypted[:name]`
#   cookies.encrypted[:discount] = 45
#
#   # Sets a "permanent" cookie (which expires in 20 years from now).
#   cookies.permanent[:login] = "XJ-122"
#
#   # You can also chain these methods:
#   cookies.signed.permanent[:login] = "XJ-122"
#
# Examples of reading:
#
#   cookies[:user_name]           # => "david"
#   cookies.size                  # => 2
#   JSON.parse(cookies[:lat_lon]) # => [47.68, -122.37]
#   cookies.signed[:login]        # => "XJ-122"
#   cookies.encrypted[:discount]  # => 45
#
# Example for deleting:
#
#   cookies.delete :user_name
#
# Please note that if you specify a :domain when setting a cookie, you must also specify the domain when deleting the cookie:
#
#  cookies[:name] = {
#    value: 'a yummy cookie',
#    expires: 1.year,
#    domain: 'domain.com'
#  }
#
#  cookies.delete(:name, domain: 'domain.com')
#
# The option symbols for setting cookies are:
#
# * <tt>:value</tt> - The cookie's value.
# * <tt>:path</tt> - The path for which this cookie applies. Defaults to the root
#   of the application.
# * <tt>:domain</tt> - The domain for which this cookie applies so you can
#   restrict to the domain level. If you use a schema like www.example.com
#   and want to share session with user.example.com set <tt>:domain</tt>
#   to <tt>:all</tt>. To support multiple domains, provide an array, and
#   the first domain matching <tt>request.host</tt> will be used. Make
#   sure to specify the <tt>:domain</tt> option with <tt>:all</tt> or
#   <tt>Array</tt> again when deleting cookies.
#
#     domain: nil  # Does not set cookie domain. (default)
#     domain: :all # Allow the cookie for the top most level
#                  # domain and subdomains.
#     domain: %w(.example.com .example.org) # Allow the cookie
#                                           # for concrete domain names.
#
# * <tt>:tld_length</tt> - When using <tt>:domain => :all</tt>, this option can be used to explicitly
#   set the TLD length when using a short (<= 3 character) domain that is being interpreted as part of a TLD.
#   For example, to share cookies between user1.lvh.me and user2.lvh.me, set <tt>:tld_length</tt> to 2.
# * <tt>:expires</tt> - The time at which this cookie expires, as a \Time or ActiveSupport::Duration object.
# * <tt>:secure</tt> - Whether this cookie is only transmitted to HTTPS servers.
#   Default is +false+.
# * <tt>:httponly</tt> - Whether this cookie is accessible via scripting or
#   only HTTP. Defaults to +false+.
class ActionDispatch::Cookies
  # @return [Cookies] a new instance of Cookies
  def initialize(app); end

  def call(env); end
end

ActionDispatch::Cookies::AUTHENTICATED_ENCRYPTED_COOKIE_SALT = T.let(T.unsafe(nil), String)

class ActionDispatch::Cookies::AbstractCookieJar
  include ::ActionDispatch::Cookies::ChainedCookieJars

  # @return [AbstractCookieJar] a new instance of AbstractCookieJar
  def initialize(parent_jar); end

  def [](name); end
  def []=(name, options); end

  protected

  def request; end

  private

  def commit(name, options); end
  def cookie_metadata(name, options); end
  def expiry_options(options); end
  def parse(name, data, purpose: T.unsafe(nil)); end
end

ActionDispatch::Cookies::COOKIES_DIGEST = T.let(T.unsafe(nil), String)
ActionDispatch::Cookies::COOKIES_ROTATIONS = T.let(T.unsafe(nil), String)
ActionDispatch::Cookies::COOKIES_SAME_SITE_PROTECTION = T.let(T.unsafe(nil), String)
ActionDispatch::Cookies::COOKIES_SERIALIZER = T.let(T.unsafe(nil), String)

# Include in a cookie jar to allow chaining, e.g. cookies.permanent.signed.
module ActionDispatch::Cookies::ChainedCookieJars
  # Returns a jar that'll automatically encrypt cookie values before sending them to the client and will decrypt them for read.
  # If the cookie was tampered with by the user (or a 3rd party), +nil+ will be returned.
  #
  # If +config.action_dispatch.encrypted_cookie_salt+ and +config.action_dispatch.encrypted_signed_cookie_salt+
  # are both set, legacy cookies encrypted with HMAC AES-256-CBC will be transparently upgraded.
  #
  # This jar requires that you set a suitable secret for the verification on your app's +secret_key_base+.
  #
  # Example:
  #
  #   cookies.encrypted[:discount] = 45
  #   # => Set-Cookie: discount=DIQ7fw==--K3n//8vvnSbGq9dA--7Xh91HfLpwzbj1czhBiwOg==; path=/
  #
  #   cookies.encrypted[:discount] # => 45
  def encrypted; end

  # Returns a jar that'll automatically set the assigned cookies to have an expiration date 20 years from now. Example:
  #
  #   cookies.permanent[:prefers_open_id] = true
  #   # => Set-Cookie: prefers_open_id=true; path=/; expires=Sun, 16-Dec-2029 03:24:16 GMT
  #
  # This jar is only meant for writing. You'll read permanent cookies through the regular accessor.
  #
  # This jar allows chaining with the signed jar as well, so you can set permanent, signed cookies. Examples:
  #
  #   cookies.permanent.signed[:remember_me] = current_user.id
  #   # => Set-Cookie: remember_me=BAhU--848956038e692d7046deab32b7131856ab20e14e; path=/; expires=Sun, 16-Dec-2029 03:24:16 GMT
  def permanent; end

  # Returns a jar that'll automatically generate a signed representation of cookie value and verify it when reading from
  # the cookie again. This is useful for creating cookies with values that the user is not supposed to change. If a signed
  # cookie was tampered with by the user (or a 3rd party), +nil+ will be returned.
  #
  # This jar requires that you set a suitable secret for the verification on your app's +secret_key_base+.
  #
  # Example:
  #
  #   cookies.signed[:discount] = 45
  #   # => Set-Cookie: discount=BAhpMg==--2c1c6906c90a3bc4fd54a51ffb41dffa4bf6b5f7; path=/
  #
  #   cookies.signed[:discount] # => 45
  def signed; end

  # Returns the +signed+ or +encrypted+ jar, preferring +encrypted+ if +secret_key_base+ is set.
  # Used by ActionDispatch::Session::CookieStore to avoid the need to introduce new cookie stores.
  def signed_or_encrypted; end

  private

  def encrypted_cookie_cipher; end

  # @return [Boolean]
  def prepare_upgrade_legacy_hmac_aes_cbc_cookies?; end

  def signed_cookie_digest; end

  # @return [Boolean]
  def upgrade_legacy_hmac_aes_cbc_cookies?; end
end

class ActionDispatch::Cookies::CookieJar
  include ::ActionDispatch::Cookies::ChainedCookieJars
  include ::Enumerable

  # @return [CookieJar] a new instance of CookieJar
  def initialize(request); end

  # Returns the value of the cookie by +name+, or +nil+ if no such cookie exists.
  def [](name); end

  # Sets the cookie named +name+. The second argument may be the cookie's
  # value or a hash of options as documented above.
  def []=(name, options); end

  def always_write_cookie; end
  def always_write_cookie=(val); end

  # Removes all cookies on the client machine by calling <tt>delete</tt> for each cookie.
  def clear(options = T.unsafe(nil)); end

  def commit!; end

  # @return [Boolean]
  def committed?; end

  # Removes the cookie on the client machine by setting the value to an empty string
  # and the expiration date in the past. Like <tt>[]=</tt>, you can pass in
  # an options hash to delete cookies with extra data such as a <tt>:path</tt>.
  def delete(name, options = T.unsafe(nil)); end

  # Whether the given cookie is to be deleted by this CookieJar.
  # Like <tt>[]=</tt>, you can pass in an options hash to test if a
  # deletion applies to a specific <tt>:path</tt>, <tt>:domain</tt> etc.
  #
  # @return [Boolean]
  def deleted?(name, options = T.unsafe(nil)); end

  def each(&block); end
  def fetch(name, *args, &block); end

  # @return [Boolean]
  def has_key?(name); end

  # @return [Boolean]
  def key?(name); end

  # Returns the value of attribute request.
  def request; end

  # Returns the cookies as Hash.
  def to_hash(*_arg0); end

  def to_header; end
  def update(other_hash); end
  def update_cookies_from_jar; end
  def write(headers); end

  private

  def escape(string); end
  def handle_options(options); end
  def make_set_cookie_header(header); end

  # @return [Boolean]
  def write_cookie?(cookie); end

  class << self
    def always_write_cookie; end
    def always_write_cookie=(val); end
    def build(req, cookies); end
  end
end

# This regular expression is used to split the levels of a domain.
# The top level domain can be any string without a period or
# **.**, ***.** style TLDs like co.uk or com.au
#
# www.example.co.uk gives:
# $& => example.co.uk
#
# example.com gives:
# $& => example.com
#
# lots.of.subdomains.example.local gives:
# $& => example.local
ActionDispatch::Cookies::CookieJar::DOMAIN_REGEXP = T.let(T.unsafe(nil), Regexp)

# Raised when storing more than 4K of session data.
class ActionDispatch::Cookies::CookieOverflow < ::StandardError; end

ActionDispatch::Cookies::ENCRYPTED_COOKIE_CIPHER = T.let(T.unsafe(nil), String)
ActionDispatch::Cookies::ENCRYPTED_COOKIE_SALT = T.let(T.unsafe(nil), String)
ActionDispatch::Cookies::ENCRYPTED_SIGNED_COOKIE_SALT = T.let(T.unsafe(nil), String)

class ActionDispatch::Cookies::EncryptedKeyRotatingCookieJar < ::ActionDispatch::Cookies::AbstractCookieJar
  include ::ActionDispatch::Cookies::SerializedCookieJars

  # @return [EncryptedKeyRotatingCookieJar] a new instance of EncryptedKeyRotatingCookieJar
  def initialize(parent_jar); end

  private

  # @raise [CookieOverflow]
  def commit(name, options); end

  def parse(name, encrypted_message, purpose: T.unsafe(nil)); end
end

ActionDispatch::Cookies::GENERATOR_KEY = T.let(T.unsafe(nil), String)
ActionDispatch::Cookies::HTTP_HEADER = T.let(T.unsafe(nil), String)

class ActionDispatch::Cookies::JsonSerializer
  class << self
    def dump(value); end
    def load(value); end
  end
end

# Cookies can typically store 4096 bytes.
ActionDispatch::Cookies::MAX_COOKIE_SIZE = T.let(T.unsafe(nil), Integer)

class ActionDispatch::Cookies::MarshalWithJsonFallback
  class << self
    def dump(value); end
    def load(value); end
  end
end

class ActionDispatch::Cookies::PermanentCookieJar < ::ActionDispatch::Cookies::AbstractCookieJar
  private

  def commit(name, options); end
end

ActionDispatch::Cookies::SECRET_KEY_BASE = T.let(T.unsafe(nil), String)
ActionDispatch::Cookies::SIGNED_COOKIE_DIGEST = T.let(T.unsafe(nil), String)
ActionDispatch::Cookies::SIGNED_COOKIE_SALT = T.let(T.unsafe(nil), String)

module ActionDispatch::Cookies::SerializedCookieJars
  protected

  def deserialize(name); end
  def digest; end

  # @return [Boolean]
  def needs_migration?(value); end

  def serialize(value); end
  def serializer; end
end

ActionDispatch::Cookies::SerializedCookieJars::MARSHAL_SIGNATURE = T.let(T.unsafe(nil), String)
ActionDispatch::Cookies::SerializedCookieJars::SERIALIZER = ActiveSupport::MessageEncryptor::NullSerializer

class ActionDispatch::Cookies::SignedKeyRotatingCookieJar < ::ActionDispatch::Cookies::AbstractCookieJar
  include ::ActionDispatch::Cookies::SerializedCookieJars

  # @return [SignedKeyRotatingCookieJar] a new instance of SignedKeyRotatingCookieJar
  def initialize(parent_jar); end

  private

  # @raise [CookieOverflow]
  def commit(name, options); end

  def parse(name, signed_message, purpose: T.unsafe(nil)); end
end

ActionDispatch::Cookies::USE_AUTHENTICATED_COOKIE_ENCRYPTION = T.let(T.unsafe(nil), String)
ActionDispatch::Cookies::USE_COOKIES_WITH_METADATA = T.let(T.unsafe(nil), String)

# This middleware is responsible for logging exceptions and
# showing a debugging page in case the request is local.
class ActionDispatch::DebugExceptions
  # @return [DebugExceptions] a new instance of DebugExceptions
  def initialize(app, routes_app = T.unsafe(nil), response_format = T.unsafe(nil), interceptors = T.unsafe(nil)); end

  def call(env); end

  private

  # @return [Boolean]
  def api_request?(content_type); end

  def create_template(request, wrapper); end
  def invoke_interceptors(request, exception); end
  def log_array(logger, array); end
  def log_error(request, wrapper); end
  def logger(request); end
  def render(status, body, format); end
  def render_exception(request, exception); end
  def render_for_api_request(content_type, wrapper); end
  def render_for_browser_request(request, wrapper); end
  def routes_inspector(exception); end
  def stderr_logger; end

  class << self
    def interceptors; end
    def register_interceptor(object = T.unsafe(nil), &block); end
  end
end

# This middleware can be used to diagnose deadlocks in the autoload interlock.
#
# To use it, insert it near the top of the middleware stack, using
# <tt>config/application.rb</tt>:
#
#     config.middleware.insert_before Rack::Sendfile, ActionDispatch::DebugLocks
#
# After restarting the application and re-triggering the deadlock condition,
# <tt>/rails/locks</tt> will show a summary of all threads currently known to
# the interlock, which lock level they are holding or awaiting, and their
# current backtrace.
#
# Generally a deadlock will be caused by the interlock conflicting with some
# other external lock or blocking I/O call. These cannot be automatically
# identified, but should be visible in the displayed backtraces.
#
# NOTE: The formatting and content of this middleware's output is intended for
# human consumption, and should be expected to change between releases.
#
# This middleware exposes operational details of the server, with no access
# control. It should only be enabled when in use, and removed thereafter.
class ActionDispatch::DebugLocks
  # @return [DebugLocks] a new instance of DebugLocks
  def initialize(app, path = T.unsafe(nil)); end

  def call(env); end

  private

  # @return [Boolean]
  def blocked_by?(victim, blocker, all_threads); end

  def render_details(req); end
end

class ActionDispatch::DebugView < ::ActionView::Base
  # @return [DebugView] a new instance of DebugView
  def initialize(assigns); end

  def compiled_method_container; end
  def debug_hash(object); end
  def debug_headers(headers); end
  def debug_params(params); end

  # @return [Boolean]
  def params_valid?; end

  # @return [Boolean]
  def protect_against_forgery?; end

  def render(*_arg0); end
end

ActionDispatch::DebugView::RESCUES_TEMPLATE_PATH = T.let(T.unsafe(nil), String)

class ActionDispatch::ExceptionWrapper
  # @return [ExceptionWrapper] a new instance of ExceptionWrapper
  def initialize(backtrace_cleaner, exception); end

  def application_trace; end

  # Returns the value of attribute backtrace_cleaner.
  def backtrace_cleaner; end

  # Returns the value of attribute exception.
  def exception; end

  def exception_trace; end

  # Returns the value of attribute file.
  def file; end

  def framework_trace; end
  def full_trace; end

  # Returns the value of attribute line_number.
  def line_number; end

  def rescue_responses; end
  def rescue_responses=(val); end
  def rescue_template; end
  def rescue_templates; end
  def rescue_templates=(val); end
  def silent_exceptions; end
  def silent_exceptions=(val); end
  def source_extracts; end
  def source_to_show_id; end
  def status_code; end
  def trace_to_show; end
  def traces; end
  def unwrapped_exception; end

  # Returns the value of attribute wrapped_causes.
  def wrapped_causes; end

  def wrapper_exceptions; end
  def wrapper_exceptions=(val); end

  private

  def backtrace; end
  def causes_for(exception); end
  def clean_backtrace(*args); end
  def expand_backtrace; end
  def extract_file_and_line_number(trace); end
  def source_fragment(path, line); end
  def wrapped_causes_for(exception, backtrace_cleaner); end

  class << self
    def rescue_responses; end
    def rescue_responses=(val); end
    def rescue_templates; end
    def rescue_templates=(val); end
    def silent_exceptions; end
    def silent_exceptions=(val); end
    def status_code_for_exception(class_name); end
    def wrapper_exceptions; end
    def wrapper_exceptions=(val); end
  end
end

class ActionDispatch::Executor
  # @return [Executor] a new instance of Executor
  def initialize(app, executor); end

  def call(env); end
end

# This endpoint serves static files from disk using Rack::File.
#
# URL paths are matched with static files according to expected
# conventions: +path+, +path+.html, +path+/index.html.
#
# Precompressed versions of these files are checked first. Brotli (.br)
# and gzip (.gz) files are supported. If +path+.br exists, this
# endpoint returns that file with a <tt>Content-Encoding: br</tt> header.
#
# If no matching file is found, this endpoint responds 404 Not Found.
#
# Pass the +root+ directory to search for matching files, an optional
# <tt>index: "index"</tt> to change the default +path+/index.html, and optional
# additional response headers.
class ActionDispatch::FileHandler
  # @return [FileHandler] a new instance of FileHandler
  def initialize(root, index: T.unsafe(nil), headers: T.unsafe(nil), precompressed: T.unsafe(nil), compressible_content_types: T.unsafe(nil)); end

  def attempt(env); end
  def call(env); end

  private

  def clean_path(path_info); end

  # @return [Boolean]
  def compressible?(content_type); end

  # @yield [path, content_type || "text/plain"]
  def each_candidate_filepath(path_info); end

  def each_precompressed_filepath(filepath); end

  # @return [Boolean]
  def file_readable?(path); end

  # Match a URI path to a static file to be served.
  #
  # Used by the +Static+ class to negotiate a servable file in the
  # +public/+ directory (see Static#call).
  #
  # Checks for +path+, +path+.html, and +path+/index.html files,
  # in that order, including .br and .gzip compressed extensions.
  #
  # If a matching file is found, the path and necessary response headers
  # (Content-Type, Content-Encoding) are returned.
  def find_file(path_info, accept_encoding:); end

  def serve(request, filepath, content_headers); end
  def try_files(filepath, content_type, accept_encoding:); end
  def try_precompressed_files(filepath, headers, accept_encoding:); end
end

# Accept-Encoding value -> file extension
ActionDispatch::FileHandler::PRECOMPRESSED = T.let(T.unsafe(nil), Hash)

# The flash provides a way to pass temporary primitive-types (String, Array, Hash) between actions. Anything you place in the flash will be exposed
# to the very next action and then cleared out. This is a great way of doing notices and alerts, such as a create
# action that sets <tt>flash[:notice] = "Post successfully created"</tt> before redirecting to a display action that can
# then expose the flash to its template. Actually, that exposure is automatically done.
#
#   class PostsController < ActionController::Base
#     def create
#       # save post
#       flash[:notice] = "Post successfully created"
#       redirect_to @post
#     end
#
#     def show
#       # doesn't need to assign the flash notice to the template, that's done automatically
#     end
#   end
#
#   show.html.erb
#     <% if flash[:notice] %>
#       <div class="notice"><%= flash[:notice] %></div>
#     <% end %>
#
# Since the +notice+ and +alert+ keys are a common idiom, convenience accessors are available:
#
#   flash.alert = "You must be logged in"
#   flash.notice = "Post successfully created"
#
# This example places a string in the flash. And of course, you can put as many as you like at a time too. If you want to pass
# non-primitive types, you will have to handle that in your application. Example: To show messages with links, you will have to
# use sanitize helper.
#
# Just remember: They'll be gone by the time the next action has been performed.
#
# See docs on the FlashHash class for more details about the flash.
class ActionDispatch::Flash
  class << self
    def new(app); end
  end
end

class ActionDispatch::Flash::FlashHash
  include ::Enumerable

  # @return [FlashHash] a new instance of FlashHash
  def initialize(flashes = T.unsafe(nil), discard = T.unsafe(nil)); end

  def [](k); end
  def []=(k, v); end

  # Convenience accessor for <tt>flash[:alert]</tt>.
  def alert; end

  # Convenience accessor for <tt>flash[:alert]=</tt>.
  def alert=(message); end

  def clear; end
  def delete(key); end

  # Marks the entire flash or a single flash entry to be discarded by the end of the current action:
  #
  #     flash.discard              # discard the entire flash at the end of the current action
  #     flash.discard(:warning)    # discard only the "warning" entry at the end of the current action
  def discard(k = T.unsafe(nil)); end

  def each(&block); end

  # @return [Boolean]
  def empty?; end

  # Keeps either the entire current flash or a specific flash entry available for the next action:
  #
  #    flash.keep            # keeps the entire flash
  #    flash.keep(:notice)   # keeps only the "notice" entry, the rest of the flash is discarded
  def keep(k = T.unsafe(nil)); end

  # @return [Boolean]
  def key?(name); end

  def keys; end
  def merge!(h); end

  # Convenience accessor for <tt>flash[:notice]</tt>.
  def notice; end

  # Convenience accessor for <tt>flash[:notice]=</tt>.
  def notice=(message); end

  # Sets a flash that will not be available to the next action, only to the current.
  #
  #     flash.now[:message] = "Hello current action"
  #
  # This method enables you to use the flash as a central messaging system in your app.
  # When you need to pass an object to the next action, you use the standard flash assign (<tt>[]=</tt>).
  # When you need to pass an object to the current action, you use <tt>now</tt>, and your object will
  # vanish when the current action is done.
  #
  # Entries set via <tt>now</tt> are accessed the same way as standard entries: <tt>flash['my-key']</tt>.
  #
  # Also, brings two convenience accessors:
  #
  #   flash.now.alert = "Beware now!"
  #   # Equivalent to flash.now[:alert] = "Beware now!"
  #
  #   flash.now.notice = "Good luck now!"
  #   # Equivalent to flash.now[:notice] = "Good luck now!"
  def now; end

  def replace(h); end

  # Mark for removal entries that were kept, and delete unkept ones.
  #
  # This method is called automatically by filters, so you generally don't need to care about it.
  def sweep; end

  def to_hash; end

  # Builds a hash containing the flashes to keep for the next request.
  # If there are none to keep, returns +nil+.
  def to_session_value; end

  def update(h); end

  protected

  # @return [Boolean]
  def now_is_loaded?; end

  private

  def initialize_copy(other); end
  def stringify_array(array); end

  class << self
    def from_session_value(value); end
  end
end

class ActionDispatch::Flash::FlashNow
  # @return [FlashNow] a new instance of FlashNow
  def initialize(flash); end

  def [](k); end
  def []=(k, v); end

  # Convenience accessor for <tt>flash.now[:alert]=</tt>.
  def alert=(message); end

  # Returns the value of attribute flash.
  def flash; end

  # Sets the attribute flash
  #
  # @param value the value to set the attribute flash to.
  def flash=(_arg0); end

  # Convenience accessor for <tt>flash.now[:notice]=</tt>.
  def notice=(message); end
end

ActionDispatch::Flash::KEY = T.let(T.unsafe(nil), String)

module ActionDispatch::Flash::RequestMethods
  def commit_flash; end

  # Access the contents of the flash. Use <tt>flash["notice"]</tt> to
  # read a notice you put there or <tt>flash["notice"] = "hello"</tt>
  # to put a new one.
  def flash; end

  def flash=(flash); end
  def flash_hash; end
  def reset_session; end
end

# This middleware guards from DNS rebinding attacks by explicitly permitting
# the hosts a request can be sent to, and is passed the options set in
# +config.host_authorization+.
#
# Requests can opt-out of Host Authorization with +exclude+:
#
#    config.host_authorization = { exclude: ->(request) { request.path =~ /healthcheck/ } }
#
# When a request comes to an unauthorized host, the +response_app+
# application will be executed and rendered. If no +response_app+ is given, a
# default one will run.
# The default response app logs blocked host info with level 'error' and
# responds with <tt>403 Forbidden</tt>. The body of the response contains debug info
# if +config.consider_all_requests_local+ is set to true, otherwise the body is empty.
class ActionDispatch::HostAuthorization
  # @return [HostAuthorization] a new instance of HostAuthorization
  def initialize(app, hosts, deprecated_response_app = T.unsafe(nil), exclude: T.unsafe(nil), response_app: T.unsafe(nil)); end

  def call(env); end

  private

  # @return [Boolean]
  def authorized?(request); end

  # @return [Boolean]
  def excluded?(request); end

  def mark_as_authorized(request); end
end

ActionDispatch::HostAuthorization::ALLOWED_HOSTS_IN_DEVELOPMENT = T.let(T.unsafe(nil), Array)

class ActionDispatch::HostAuthorization::DefaultResponseApp
  def call(env); end

  private

  def available_logger(request); end
  def log_error(request); end
  def response(format, body); end
  def response_body(request); end
end

ActionDispatch::HostAuthorization::DefaultResponseApp::RESPONSE_STATUS = T.let(T.unsafe(nil), Integer)
ActionDispatch::HostAuthorization::IPV4_HOSTNAME = T.let(T.unsafe(nil), Regexp)
ActionDispatch::HostAuthorization::IPV6_HOSTNAME = T.let(T.unsafe(nil), Regexp)
ActionDispatch::HostAuthorization::IPV6_HOSTNAME_WITH_PORT = T.let(T.unsafe(nil), Regexp)
ActionDispatch::HostAuthorization::PORT_REGEX = T.let(T.unsafe(nil), Regexp)

class ActionDispatch::HostAuthorization::Permissions
  # @return [Permissions] a new instance of Permissions
  def initialize(hosts); end

  # @return [Boolean]
  def allows?(host); end

  # @return [Boolean]
  def empty?; end

  private

  def extract_hostname(host); end
  def sanitize_hosts(hosts); end
  def sanitize_regexp(host); end
  def sanitize_string(host); end
end

ActionDispatch::HostAuthorization::VALID_IP_HOSTNAME = T.let(T.unsafe(nil), Regexp)

module ActionDispatch::Http
  extend ::ActiveSupport::Autoload
end

module ActionDispatch::Http::Cache; end

module ActionDispatch::Http::Cache::Request
  # @return [Boolean]
  def etag_matches?(etag); end

  # Check response freshness (Last-Modified and ETag) against request
  # If-Modified-Since and If-None-Match conditions. If both headers are
  # supplied, both must match, or the request is not considered fresh.
  #
  # @return [Boolean]
  def fresh?(response); end

  def if_modified_since; end
  def if_none_match; end
  def if_none_match_etags; end

  # @return [Boolean]
  def not_modified?(modified_at); end
end

ActionDispatch::Http::Cache::Request::HTTP_IF_MODIFIED_SINCE = T.let(T.unsafe(nil), String)
ActionDispatch::Http::Cache::Request::HTTP_IF_NONE_MATCH = T.let(T.unsafe(nil), String)

module ActionDispatch::Http::Cache::Response
  # Returns the value of attribute cache_control.
  def cache_control; end

  def date; end
  def date=(utc_time); end

  # @return [Boolean]
  def date?; end

  # This method sets a weak ETag validator on the response so browsers
  # and proxies may cache the response, keyed on the ETag. On subsequent
  # requests, the If-None-Match header is set to the cached ETag. If it
  # matches the current ETag, we can return a 304 Not Modified response
  # with no body, letting the browser or proxy know that their cache is
  # current. Big savings in request time and network bandwidth.
  #
  # Weak ETags are considered to be semantically equivalent but not
  # byte-for-byte identical. This is perfect for browser caching of HTML
  # pages where we don't care about exact equality, just what the user
  # is viewing.
  #
  # Strong ETags are considered byte-for-byte identical. They allow a
  # browser or proxy cache to support Range requests, useful for paging
  # through a PDF file or scrubbing through a video. Some CDNs only
  # support strong ETags and will ignore weak ETags entirely.
  #
  # Weak ETags are what we almost always need, so they're the default.
  # Check out #strong_etag= to provide a strong ETag validator.
  def etag=(weak_validators); end

  # @return [Boolean]
  def etag?; end

  def last_modified; end
  def last_modified=(utc_time); end

  # @return [Boolean]
  def last_modified?; end

  def strong_etag=(strong_validators); end

  # True if an ETag is set and it isn't a weak validator (not preceded with W/)
  #
  # @return [Boolean]
  def strong_etag?; end

  def weak_etag=(weak_validators); end

  # True if an ETag is set and it's a weak validator (preceded with W/)
  #
  # @return [Boolean]
  def weak_etag?; end

  private

  def cache_control_headers; end
  def cache_control_segments; end
  def generate_strong_etag(validators); end
  def generate_weak_etag(validators); end
  def handle_conditional_get!; end
  def merge_and_normalize_cache_control!(cache_control); end
  def prepare_cache_control!; end
end

ActionDispatch::Http::Cache::Response::DATE = T.let(T.unsafe(nil), String)
ActionDispatch::Http::Cache::Response::DEFAULT_CACHE_CONTROL = T.let(T.unsafe(nil), String)
ActionDispatch::Http::Cache::Response::LAST_MODIFIED = T.let(T.unsafe(nil), String)
ActionDispatch::Http::Cache::Response::MUST_REVALIDATE = T.let(T.unsafe(nil), String)
ActionDispatch::Http::Cache::Response::NO_CACHE = T.let(T.unsafe(nil), String)
ActionDispatch::Http::Cache::Response::NO_STORE = T.let(T.unsafe(nil), String)
ActionDispatch::Http::Cache::Response::PRIVATE = T.let(T.unsafe(nil), String)
ActionDispatch::Http::Cache::Response::PUBLIC = T.let(T.unsafe(nil), String)
ActionDispatch::Http::Cache::Response::SPECIAL_KEYS = T.let(T.unsafe(nil), Set)

class ActionDispatch::Http::ContentDisposition
  # @return [ContentDisposition] a new instance of ContentDisposition
  def initialize(disposition:, filename:); end

  def ascii_filename; end

  # Returns the value of attribute disposition.
  def disposition; end

  # Returns the value of attribute filename.
  def filename; end

  def to_s; end
  def utf8_filename; end

  private

  def percent_escape(string, pattern); end

  class << self
    def format(disposition:, filename:); end
  end
end

ActionDispatch::Http::ContentDisposition::RFC_5987_ESCAPED_CHAR = T.let(T.unsafe(nil), Regexp)
ActionDispatch::Http::ContentDisposition::TRADITIONAL_ESCAPED_CHAR = T.let(T.unsafe(nil), Regexp)

# Allows you to specify sensitive parameters which will be replaced from
# the request log by looking in the query string of the request and all
# sub-hashes of the params hash to filter. Filtering only certain sub-keys
# from a hash is possible by using the dot notation: 'credit_card.number'.
# If a block is given, each key and value of the params hash and all
# sub-hashes are passed to it, where the value or the key can be replaced using
# String#replace or similar methods.
#
#   env["action_dispatch.parameter_filter"] = [:password]
#   => replaces the value to all keys matching /password/i with "[FILTERED]"
#
#   env["action_dispatch.parameter_filter"] = [:foo, "bar"]
#   => replaces the value to all keys matching /foo|bar/i with "[FILTERED]"
#
#   env["action_dispatch.parameter_filter"] = [ "credit_card.code" ]
#   => replaces { credit_card: {code: "xxxx"} } with "[FILTERED]", does not
#   change { file: { code: "xxxx"} }
#
#   env["action_dispatch.parameter_filter"] = -> (k, v) do
#     v.reverse! if k.match?(/secret/i)
#   end
#   => reverses the value to all keys matching /secret/i
module ActionDispatch::Http::FilterParameters
  def initialize; end

  # Returns a hash of request.env with all sensitive data replaced.
  def filtered_env; end

  # Returns a hash of parameters with all sensitive data replaced.
  def filtered_parameters; end

  # Reconstructs a path with all sensitive GET parameters replaced.
  def filtered_path; end

  private

  def env_filter; end
  def filtered_query_string; end
  def parameter_filter; end
  def parameter_filter_for(filters); end
end

ActionDispatch::Http::FilterParameters::ENV_MATCH = T.let(T.unsafe(nil), Array)
ActionDispatch::Http::FilterParameters::KV_RE = T.let(T.unsafe(nil), String)
ActionDispatch::Http::FilterParameters::NULL_ENV_FILTER = T.let(T.unsafe(nil), ActiveSupport::ParameterFilter)
ActionDispatch::Http::FilterParameters::NULL_PARAM_FILTER = T.let(T.unsafe(nil), ActiveSupport::ParameterFilter)
ActionDispatch::Http::FilterParameters::PAIR_RE = T.let(T.unsafe(nil), Regexp)

module ActionDispatch::Http::FilterRedirect
  def filtered_location; end

  private

  # @return [Boolean]
  def location_filter_match?; end

  def location_filters; end
end

ActionDispatch::Http::FilterRedirect::FILTERED = T.let(T.unsafe(nil), String)

# Provides access to the request's HTTP headers from the environment.
#
#   env     = { "CONTENT_TYPE" => "text/plain", "HTTP_USER_AGENT" => "curl/7.43.0" }
#   headers = ActionDispatch::Http::Headers.from_hash(env)
#   headers["Content-Type"] # => "text/plain"
#   headers["User-Agent"] # => "curl/7.43.0"
#
# Also note that when headers are mapped to CGI-like variables by the Rack
# server, both dashes and underscores are converted to underscores. This
# ambiguity cannot be resolved at this stage anymore. Both underscores and
# dashes have to be interpreted as if they were originally sent as dashes.
#
#   # GET / HTTP/1.1
#   # ...
#   # User-Agent: curl/7.43.0
#   # X_Custom_Header: token
#
#   headers["X_Custom_Header"] # => nil
#   headers["X-Custom-Header"] # => "token"
class ActionDispatch::Http::Headers
  include ::Enumerable

  # @return [Headers] a new instance of Headers
  def initialize(request); end

  # Returns the value for the given key mapped to @env.
  def [](key); end

  # Sets the given value for the key mapped to @env.
  def []=(key, value); end

  # Add a value to a multivalued header like Vary or Accept-Encoding.
  def add(key, value); end

  def each(&block); end
  def env; end

  # Returns the value for the given key mapped to @env.
  #
  # If the key is not found and an optional code block is not provided,
  # raises a <tt>KeyError</tt> exception.
  #
  # If the code block is provided, then it will be run and
  # its result returned.
  def fetch(key, default = T.unsafe(nil)); end

  # @return [Boolean]
  def include?(key); end

  # @return [Boolean]
  def key?(key); end

  # Returns a new Http::Headers instance containing the contents of
  # <tt>headers_or_env</tt> and the original instance.
  def merge(headers_or_env); end

  # Adds the contents of <tt>headers_or_env</tt> to original instance
  # entries; duplicate keys are overwritten with the values from
  # <tt>headers_or_env</tt>.
  def merge!(headers_or_env); end

  private

  # Converts an HTTP header name to an environment variable name if it is
  # not contained within the headers hash.
  def env_name(key); end

  class << self
    def from_hash(hash); end
  end
end

ActionDispatch::Http::Headers::CGI_VARIABLES = T.let(T.unsafe(nil), Set)
ActionDispatch::Http::Headers::DEFAULT = T.let(T.unsafe(nil), Object)
ActionDispatch::Http::Headers::HTTP_HEADER = T.let(T.unsafe(nil), Regexp)

module ActionDispatch::Http::MimeNegotiation
  extend ::ActiveSupport::Concern

  # Returns the accepted MIME type for the request.
  def accepts; end

  # The MIME type of the HTTP request, such as Mime[:xml].
  def content_mime_type; end

  def content_type; end

  # Returns the MIME type for the \format used in the request.
  #
  #   GET /posts/5.xml   | request.format => Mime[:xml]
  #   GET /posts/5.xhtml | request.format => Mime[:html]
  #   GET /posts/5       | request.format => Mime[:html] or Mime[:js], or request.accepts.first
  def format(view_path = T.unsafe(nil)); end

  # Sets the \format by string extension, which can be used to force custom formats
  # that are not controlled by the extension.
  #
  #   class ApplicationController < ActionController::Base
  #     before_action :adjust_format_for_iphone
  #
  #     private
  #       def adjust_format_for_iphone
  #         request.format = :iphone if request.env["HTTP_USER_AGENT"][/iPhone/]
  #       end
  #   end
  def format=(extension); end

  def formats; end

  # Sets the \formats by string extensions. This differs from #format= by allowing you
  # to set multiple, ordered formats, which is useful when you want to have a fallback.
  #
  # In this example, the :iphone format will be used if it's available, otherwise it'll fallback
  # to the :html format.
  #
  #   class ApplicationController < ActionController::Base
  #     before_action :adjust_format_for_iphone_with_html_fallback
  #
  #     private
  #       def adjust_format_for_iphone_with_html_fallback
  #         request.formats = [ :iphone, :html ] if request.env["HTTP_USER_AGENT"][/iPhone/]
  #       end
  #   end
  def formats=(extensions); end

  # @return [Boolean]
  def has_content_type?; end

  # Returns the first MIME type that matches the provided array of MIME types.
  def negotiate_mime(order); end

  # @return [Boolean]
  def should_apply_vary_header?; end

  def variant; end

  # Sets the \variant for template.
  def variant=(variant); end

  private

  def format_from_path_extension; end

  # @return [Boolean]
  def params_readable?; end

  def use_accept_header; end
  def valid_accept_header; end
end

# We use normal content negotiation unless you include */* in your list,
# in which case we assume you're a browser and send HTML.
ActionDispatch::Http::MimeNegotiation::BROWSER_LIKE_ACCEPTS = T.let(T.unsafe(nil), Regexp)

class ActionDispatch::Http::MimeNegotiation::InvalidType < ::Mime::Type::InvalidMimeType; end
ActionDispatch::Http::MimeNegotiation::RESCUABLE_MIME_FORMAT_ERRORS = T.let(T.unsafe(nil), Array)

module ActionDispatch::Http::Parameters
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::ActionDispatch::Http::Parameters::ClassMethods

  # Returns both GET and POST \parameters in a single hash.
  def parameters; end

  # Returns both GET and POST \parameters in a single hash.
  def params; end

  # Returns a hash with the \parameters used to form the \path of the request.
  # Returned hash keys are strings:
  #
  #   {'action' => 'my_action', 'controller' => 'my_controller'}
  def path_parameters; end

  def path_parameters=(parameters); end

  private

  def log_parse_error_once; end
  def params_parsers; end
  def parse_formatted_parameters(parsers); end
end

module ActionDispatch::Http::Parameters::ClassMethods
  # Configure the parameter parser for a given MIME type.
  #
  # It accepts a hash where the key is the symbol of the MIME type
  # and the value is a proc.
  #
  #     original_parsers = ActionDispatch::Request.parameter_parsers
  #     xml_parser = -> (raw_post) { Hash.from_xml(raw_post) || {} }
  #     new_parsers = original_parsers.merge(xml: xml_parser)
  #     ActionDispatch::Request.parameter_parsers = new_parsers
  def parameter_parsers=(parsers); end
end

ActionDispatch::Http::Parameters::DEFAULT_PARSERS = T.let(T.unsafe(nil), Hash)
ActionDispatch::Http::Parameters::PARAMETERS_KEY = T.let(T.unsafe(nil), String)

# Raised when raw data from the request cannot be parsed by the parser
# defined for request's content MIME type.
class ActionDispatch::Http::Parameters::ParseError < ::StandardError
  # @return [ParseError] a new instance of ParseError
  def initialize; end
end

module ActionDispatch::Http::URL
  def initialize; end

  # Returns the \domain part of a \host, such as "rubyonrails.org" in "www.rubyonrails.org". You can specify
  # a different <tt>tld_length</tt>, such as 2 to catch rubyonrails.co.uk in "www.rubyonrails.co.uk".
  def domain(tld_length = T.unsafe(nil)); end

  # Returns the host for this request, such as "example.com".
  #
  #   req = ActionDispatch::Request.new 'HTTP_HOST' => 'example.com:8080'
  #   req.host # => "example.com"
  def host; end

  # Returns a \host:\port string for this request, such as "example.com" or
  # "example.com:8080". Port is only included if it is not a default port
  # (80 or 443)
  #
  #   req = ActionDispatch::Request.new 'HTTP_HOST' => 'example.com'
  #   req.host_with_port # => "example.com"
  #
  #   req = ActionDispatch::Request.new 'HTTP_HOST' => 'example.com:80'
  #   req.host_with_port # => "example.com"
  #
  #   req = ActionDispatch::Request.new 'HTTP_HOST' => 'example.com:8080'
  #   req.host_with_port # => "example.com:8080"
  def host_with_port; end

  # Returns a number \port suffix like 8080 if the \port number of this request
  # is not the default HTTP \port 80 or HTTPS \port 443.
  #
  #   req = ActionDispatch::Request.new 'HTTP_HOST' => 'example.com:80'
  #   req.optional_port # => nil
  #
  #   req = ActionDispatch::Request.new 'HTTP_HOST' => 'example.com:8080'
  #   req.optional_port # => 8080
  def optional_port; end

  # Returns the port number of this request as an integer.
  #
  #   req = ActionDispatch::Request.new 'HTTP_HOST' => 'example.com'
  #   req.port # => 80
  #
  #   req = ActionDispatch::Request.new 'HTTP_HOST' => 'example.com:8080'
  #   req.port # => 8080
  def port; end

  # Returns a string \port suffix, including colon, like ":8080" if the \port
  # number of this request is not the default HTTP \port 80 or HTTPS \port 443.
  #
  #   req = ActionDispatch::Request.new 'HTTP_HOST' => 'example.com:80'
  #   req.port_string # => ""
  #
  #   req = ActionDispatch::Request.new 'HTTP_HOST' => 'example.com:8080'
  #   req.port_string # => ":8080"
  def port_string; end

  # Returns 'https://' if this is an SSL request and 'http://' otherwise.
  #
  #   req = ActionDispatch::Request.new 'HTTP_HOST' => 'example.com'
  #   req.protocol # => "http://"
  #
  #   req = ActionDispatch::Request.new 'HTTP_HOST' => 'example.com', 'HTTPS' => 'on'
  #   req.protocol # => "https://"
  def protocol; end

  # Returns the \host and port for this request, such as "example.com:8080".
  #
  #   req = ActionDispatch::Request.new 'HTTP_HOST' => 'example.com'
  #   req.raw_host_with_port # => "example.com"
  #
  #   req = ActionDispatch::Request.new 'HTTP_HOST' => 'example.com:80'
  #   req.raw_host_with_port # => "example.com:80"
  #
  #   req = ActionDispatch::Request.new 'HTTP_HOST' => 'example.com:8080'
  #   req.raw_host_with_port # => "example.com:8080"
  def raw_host_with_port; end

  def secure_protocol; end
  def secure_protocol=(val); end

  # Returns the requested port, such as 8080, based on SERVER_PORT
  #
  #   req = ActionDispatch::Request.new 'SERVER_PORT' => '80'
  #   req.server_port # => 80
  #
  #   req = ActionDispatch::Request.new 'SERVER_PORT' => '8080'
  #   req.server_port # => 8080
  def server_port; end

  # Returns the standard \port number for this request's protocol.
  #
  #   req = ActionDispatch::Request.new 'HTTP_HOST' => 'example.com:8080'
  #   req.standard_port # => 80
  def standard_port; end

  # Returns whether this request is using the standard port
  #
  #   req = ActionDispatch::Request.new 'HTTP_HOST' => 'example.com:80'
  #   req.standard_port? # => true
  #
  #   req = ActionDispatch::Request.new 'HTTP_HOST' => 'example.com:8080'
  #   req.standard_port? # => false
  #
  # @return [Boolean]
  def standard_port?; end

  # Returns all the \subdomains as a string, so <tt>"dev.www"</tt> would be
  # returned for "dev.www.rubyonrails.org". You can specify a different <tt>tld_length</tt>,
  # such as 2 to catch <tt>"www"</tt> instead of <tt>"www.rubyonrails"</tt>
  # in "www.rubyonrails.co.uk".
  def subdomain(tld_length = T.unsafe(nil)); end

  # Returns all the \subdomains as an array, so <tt>["dev", "www"]</tt> would be
  # returned for "dev.www.rubyonrails.org". You can specify a different <tt>tld_length</tt>,
  # such as 2 to catch <tt>["www"]</tt> instead of <tt>["www", "rubyonrails"]</tt>
  # in "www.rubyonrails.co.uk".
  def subdomains(tld_length = T.unsafe(nil)); end

  def tld_length; end
  def tld_length=(val); end

  # Returns the complete URL used for this request.
  #
  #   req = ActionDispatch::Request.new 'HTTP_HOST' => 'example.com'
  #   req.url # => "http://example.com"
  def url; end

  class << self
    # Returns the domain part of a host given the domain level.
    #
    #    # Top-level domain example
    #    extract_domain('www.example.com', 1) # => "example.com"
    #    # Second-level domain example
    #    extract_domain('dev.www.example.co.uk', 2) # => "example.co.uk"
    def extract_domain(host, tld_length); end

    # Returns the subdomains of a host as a String given the domain level.
    #
    #    # Top-level domain example
    #    extract_subdomain('www.example.com', 1) # => "www"
    #    # Second-level domain example
    #    extract_subdomain('dev.www.example.co.uk', 2) # => "dev.www"
    def extract_subdomain(host, tld_length); end

    # Returns the subdomains of a host as an Array given the domain level.
    #
    #    # Top-level domain example
    #    extract_subdomains('www.example.com', 1) # => ["www"]
    #    # Second-level domain example
    #    extract_subdomains('dev.www.example.co.uk', 2) # => ["dev", "www"]
    def extract_subdomains(host, tld_length); end

    def full_url_for(options); end
    def path_for(options); end
    def secure_protocol; end
    def secure_protocol=(val); end
    def tld_length; end
    def tld_length=(val); end
    def url_for(options); end

    private

    def add_anchor(path, anchor); end
    def add_params(path, params); end
    def add_trailing_slash(path); end
    def build_host_url(host, port, protocol, options, path); end
    def extract_domain_from(host, tld_length); end
    def extract_subdomains_from(host, tld_length); end

    # @return [Boolean]
    def named_host?(host); end

    def normalize_host(_host, options); end
    def normalize_port(port, protocol); end
    def normalize_protocol(protocol); end
  end
end

ActionDispatch::Http::URL::HOST_REGEXP = T.let(T.unsafe(nil), Regexp)
ActionDispatch::Http::URL::IP_HOST_REGEXP = T.let(T.unsafe(nil), Regexp)
ActionDispatch::Http::URL::PROTOCOL_REGEXP = T.let(T.unsafe(nil), Regexp)

# Models uploaded files.
#
# The actual file is accessible via the +tempfile+ accessor, though some
# of its interface is available directly for convenience.
#
# Uploaded files are temporary files whose lifespan is one request. When
# the object is finalized Ruby unlinks the file, so there is no need to
# clean them with a separate maintenance task.
class ActionDispatch::Http::UploadedFile
  # @raise [ArgumentError]
  # @return [UploadedFile] a new instance of UploadedFile
  def initialize(hash); end

  # Shortcut for +tempfile.close+.
  def close(unlink_now = T.unsafe(nil)); end

  # A string with the MIME type of the file.
  def content_type; end

  # A string with the MIME type of the file.
  def content_type=(_arg0); end

  # Shortcut for +tempfile.eof?+.
  #
  # @return [Boolean]
  def eof?; end

  # A string with the headers of the multipart request.
  def headers; end

  # A string with the headers of the multipart request.
  def headers=(_arg0); end

  # Shortcut for +tempfile.open+.
  def open; end

  # The basename of the file in the client.
  def original_filename; end

  # The basename of the file in the client.
  def original_filename=(_arg0); end

  # Shortcut for +tempfile.path+.
  def path; end

  # Shortcut for +tempfile.read+.
  def read(length = T.unsafe(nil), buffer = T.unsafe(nil)); end

  # Shortcut for +tempfile.rewind+.
  def rewind; end

  # Shortcut for +tempfile.size+.
  def size; end

  # A +Tempfile+ object with the actual uploaded file. Note that some of
  # its interface is available directly.
  def tempfile; end

  # A +Tempfile+ object with the actual uploaded file. Note that some of
  # its interface is available directly.
  def tempfile=(_arg0); end

  def to_io; end

  # Shortcut for +tempfile.to_path+.
  def to_path; end
end

class ActionDispatch::IllegalStateError < ::StandardError; end
module ActionDispatch::Integration; end

module ActionDispatch::Integration::RequestHelpers
  # Performs a DELETE request with the given parameters. See ActionDispatch::Integration::Session#process
  # for more details.
  def delete(path, **args); end

  # Follow a single redirect response. If the last response was not a
  # redirect, an exception will be raised. Otherwise, the redirect is
  # performed on the location header. If the redirection is a 307 or 308 redirect,
  # the same HTTP verb will be used when redirecting, otherwise a GET request
  # will be performed. Any arguments are passed to the
  # underlying request.
  def follow_redirect!(**args); end

  # Performs a GET request with the given parameters. See ActionDispatch::Integration::Session#process
  # for more details.
  def get(path, **args); end

  # Performs a HEAD request with the given parameters. See ActionDispatch::Integration::Session#process
  # for more details.
  def head(path, **args); end

  # Performs an OPTIONS request with the given parameters. See ActionDispatch::Integration::Session#process
  # for more details.
  def options(path, **args); end

  # Performs a PATCH request with the given parameters. See ActionDispatch::Integration::Session#process
  # for more details.
  def patch(path, **args); end

  # Performs a POST request with the given parameters. See ActionDispatch::Integration::Session#process
  # for more details.
  def post(path, **args); end

  # Performs a PUT request with the given parameters. See ActionDispatch::Integration::Session#process
  # for more details.
  def put(path, **args); end
end

module ActionDispatch::Integration::Runner
  include ::Rails::Dom::Testing::Assertions::DomAssertions
  include ::Rails::Dom::Testing::Assertions::SelectorAssertions::CountDescribable
  include ::Rails::Dom::Testing::Assertions::SelectorAssertions
  include ::Rails::Dom::Testing::Assertions
  include ::ActionDispatch::Assertions::ResponseAssertions
  include ::ActionDispatch::Assertions::RoutingAssertions
  include ::ActionDispatch::Assertions

  def initialize(*args, &blk); end

  # Returns the value of attribute app.
  def app; end

  def assertions; end
  def assertions=(assertions); end
  def assigns(*_arg0, &_arg1); end
  def before_setup; end
  def cookies(*_arg0, &_arg1); end

  # Copy the instance variables from the current session instance into the
  # test instance.
  def copy_session_variables!; end

  def create_session(app); end
  def default_url_options; end
  def default_url_options=(options); end
  def delete(*_arg0, &_arg1); end
  def follow_redirect!(*_arg0, &_arg1); end
  def get(*_arg0, &_arg1); end
  def head(*_arg0, &_arg1); end
  def integration_session; end

  # Open a new session instance. If a block is given, the new session is
  # yielded to the block before being returned.
  #
  #   session = open_session do |sess|
  #     sess.extend(CustomAssertions)
  #   end
  #
  # By default, a single session is automatically created for you, but you
  # can use this method to open multiple sessions that ought to be tested
  # simultaneously.
  def open_session; end

  def patch(*_arg0, &_arg1); end
  def post(*_arg0, &_arg1); end
  def put(*_arg0, &_arg1); end
  def remove!; end

  # Reset the current session. This is useful for testing multiple sessions
  # in a single test case.
  def reset!; end

  def root_session; end
  def root_session=(_arg0); end

  private

  # Delegate unhandled messages to the current session instance.
  def method_missing(method, *args, &block); end

  # @return [Boolean]
  def respond_to_missing?(method, _); end
end

ActionDispatch::Integration::Runner::APP_SESSIONS = T.let(T.unsafe(nil), Hash)

# An instance of this class represents a set of requests and responses
# performed sequentially by a test process. Because you can instantiate
# multiple sessions and run them side-by-side, you can also mimic (to some
# limited extent) multiple simultaneous users interacting with your system.
#
# Typically, you will instantiate a new session using
# IntegrationTest#open_session, rather than instantiating
# Integration::Session directly.
class ActionDispatch::Integration::Session
  include ::Minitest::Assertions
  include ::Rails::Dom::Testing::Assertions::DomAssertions
  include ::Rails::Dom::Testing::Assertions::SelectorAssertions::CountDescribable
  include ::Rails::Dom::Testing::Assertions::SelectorAssertions
  include ::Rails::Dom::Testing::Assertions
  include ::ActionDispatch::Assertions::ResponseAssertions
  include ::ActionDispatch::Assertions::RoutingAssertions
  include ::ActionDispatch::Assertions
  include ::ActionDispatch::Integration::RequestHelpers
  include ::ActionDispatch::TestProcess::FixtureFile
  include ::ActionDispatch::TestProcess
  include ::ActionDispatch::Routing::PolymorphicRoutes
  include ::ActionDispatch::Routing::UrlFor

  # Create and initialize a new Session instance.
  #
  # @return [Session] a new instance of Session
  def initialize(app); end

  # The Accept header to send.
  def accept; end

  # The Accept header to send.
  def accept=(_arg0); end

  def body(*_arg0, &_arg1); end

  # A reference to the controller instance used by the last request.
  def controller; end

  # A map of the cookies returned by the last response, and which will be
  # sent with the next request.
  def cookies; end

  def default_url_options; end
  def default_url_options=(_arg0); end
  def default_url_options?; end
  def headers(*_arg0, &_arg1); end

  # The hostname used in the last request.
  def host; end

  # Sets the attribute host
  # Set the host name to use in the next request.
  #
  #   session.host! "www.example.com"
  #
  # @param value the value to set the attribute host to.
  def host!(_arg0); end

  # Sets the attribute host
  #
  # @param value the value to set the attribute host to.
  def host=(_arg0); end

  # Specify whether or not the session should mimic a secure HTTPS request.
  #
  #   session.https!
  #   session.https!(false)
  def https!(flag = T.unsafe(nil)); end

  # Returns +true+ if the session is mimicking a secure HTTPS request.
  #
  #   if session.https?
  #     ...
  #   end
  #
  # @return [Boolean]
  def https?; end

  def path(*_arg0, &_arg1); end

  # Performs the actual request.
  #
  # - +method+: The HTTP method (GET, POST, PATCH, PUT, DELETE, HEAD, OPTIONS)
  #   as a symbol.
  # - +path+: The URI (as a String) on which you want to perform the
  #   request.
  # - +params+: The HTTP parameters that you want to pass. This may
  #   be +nil+,
  #   a Hash, or a String that is appropriately encoded
  #   (<tt>application/x-www-form-urlencoded</tt> or
  #   <tt>multipart/form-data</tt>).
  # - +headers+: Additional headers to pass, as a Hash. The headers will be
  #   merged into the Rack env hash.
  # - +env+: Additional env to pass, as a Hash. The headers will be
  #   merged into the Rack env hash.
  # - +xhr+: Set to +true+ if you want to make and Ajax request.
  #   Adds request headers characteristic of XMLHttpRequest e.g. HTTP_X_REQUESTED_WITH.
  #   The headers will be merged into the Rack env hash.
  # - +as+: Used for encoding the request with different content type.
  #   Supports +:json+ by default and will set the appropriate request headers.
  #   The headers will be merged into the Rack env hash.
  #
  # This method is rarely used directly. Use +#get+, +#post+, or other standard
  # HTTP methods in integration tests. +#process+ is only required when using a
  # request method that doesn't have a method defined in the integration tests.
  #
  # This method returns the response status, after performing the request.
  # Furthermore, if this method was called from an ActionDispatch::IntegrationTest object,
  # then that object's <tt>@response</tt> instance variable will point to a Response object
  # which one can use to inspect the details of the response.
  #
  # Example:
  #   process :get, '/author', params: { since: 201501011400 }
  def process(method, path, params: T.unsafe(nil), headers: T.unsafe(nil), env: T.unsafe(nil), xhr: T.unsafe(nil), as: T.unsafe(nil)); end

  def redirect?(*_arg0, &_arg1); end

  # The remote_addr used in the last request.
  def remote_addr; end

  # The remote_addr used in the last request.
  def remote_addr=(_arg0); end

  # A reference to the request instance used by the last request.
  def request; end

  # A running counter of the number of requests processed.
  def request_count; end

  # A running counter of the number of requests processed.
  def request_count=(_arg0); end

  # Resets the instance. This can be used to reset the state information
  # in an existing session instance, so it can be used from a clean-slate
  # condition.
  #
  #   session.reset!
  def reset!; end

  # A reference to the response instance used by the last request.
  def response; end

  def status(*_arg0, &_arg1); end
  def status_message(*_arg0, &_arg1); end
  def url_options; end

  private

  def _mock_session; end

  # @yield [location]
  def build_expanded_path(path); end

  def build_full_uri(path, env); end

  class << self
    def default_url_options; end
    def default_url_options=(value); end
    def default_url_options?; end
  end
end

ActionDispatch::Integration::Session::DEFAULT_HOST = T.let(T.unsafe(nil), String)

# An integration test spans multiple controllers and actions,
# tying them all together to ensure they work together as expected. It tests
# more completely than either unit or functional tests do, exercising the
# entire stack, from the dispatcher to the database.
#
# At its simplest, you simply extend <tt>IntegrationTest</tt> and write your tests
# using the get/post methods:
#
#   require "test_helper"
#
#   class ExampleTest < ActionDispatch::IntegrationTest
#     fixtures :people
#
#     def test_login
#       # get the login page
#       get "/login"
#       assert_equal 200, status
#
#       # post the login and follow through to the home page
#       post "/login", params: { username: people(:jamis).username,
#         password: people(:jamis).password }
#       follow_redirect!
#       assert_equal 200, status
#       assert_equal "/home", path
#     end
#   end
#
# However, you can also have multiple session instances open per test, and
# even extend those instances with assertions and methods to create a very
# powerful testing DSL that is specific for your application. You can even
# reference any named routes you happen to have defined.
#
#   require "test_helper"
#
#   class AdvancedTest < ActionDispatch::IntegrationTest
#     fixtures :people, :rooms
#
#     def test_login_and_speak
#       jamis, david = login(:jamis), login(:david)
#       room = rooms(:office)
#
#       jamis.enter(room)
#       jamis.speak(room, "anybody home?")
#
#       david.enter(room)
#       david.speak(room, "hello!")
#     end
#
#     private
#
#       module CustomAssertions
#         def enter(room)
#           # reference a named route, for maximum internal consistency!
#           get(room_url(id: room.id))
#           assert(...)
#           ...
#         end
#
#         def speak(room, message)
#           post "/say/#{room.id}", xhr: true, params: { message: message }
#           assert(...)
#           ...
#         end
#       end
#
#       def login(who)
#         open_session do |sess|
#           sess.extend(CustomAssertions)
#           who = people(who)
#           sess.post "/login", params: { username: who.username,
#             password: who.password }
#           assert(...)
#         end
#       end
#   end
#
# Another longer example would be:
#
# A simple integration test that exercises multiple controllers:
#
#   require "test_helper"
#
#   class UserFlowsTest < ActionDispatch::IntegrationTest
#     test "login and browse site" do
#       # login via https
#       https!
#       get "/login"
#       assert_response :success
#
#       post "/login", params: { username: users(:david).username, password: users(:david).password }
#       follow_redirect!
#       assert_equal '/welcome', path
#       assert_equal 'Welcome david!', flash[:notice]
#
#       https!(false)
#       get "/articles/all"
#       assert_response :success
#       assert_select 'h1', 'Articles'
#     end
#   end
#
# As you can see the integration test involves multiple controllers and
# exercises the entire stack from database to dispatcher. In addition you can
# have multiple session instances open simultaneously in a test and extend
# those instances with assertion methods to create a very powerful testing
# DSL (domain-specific language) just for your application.
#
# Here's an example of multiple sessions and custom DSL in an integration test
#
#   require "test_helper"
#
#   class UserFlowsTest < ActionDispatch::IntegrationTest
#     test "login and browse site" do
#       # User david logs in
#       david = login(:david)
#       # User guest logs in
#       guest = login(:guest)
#
#       # Both are now available in different sessions
#       assert_equal 'Welcome david!', david.flash[:notice]
#       assert_equal 'Welcome guest!', guest.flash[:notice]
#
#       # User david can browse site
#       david.browses_site
#       # User guest can browse site as well
#       guest.browses_site
#
#       # Continue with other assertions
#     end
#
#     private
#
#       module CustomDsl
#         def browses_site
#           get "/products/all"
#           assert_response :success
#           assert_select 'h1', 'Products'
#         end
#       end
#
#       def login(user)
#         open_session do |sess|
#           sess.extend(CustomDsl)
#           u = users(user)
#           sess.https!
#           sess.post "/login", params: { username: u.username, password: u.password }
#           assert_equal '/welcome', sess.path
#           sess.https!(false)
#         end
#       end
#   end
#
# See the {request helpers documentation}[rdoc-ref:ActionDispatch::Integration::RequestHelpers] for help on how to
# use +get+, etc.
#
# === Changing the request encoding
#
# You can also test your JSON API easily by setting what the request should
# be encoded as:
#
#   require "test_helper"
#
#   class ApiTest < ActionDispatch::IntegrationTest
#     test "creates articles" do
#       assert_difference -> { Article.count } do
#         post articles_path, params: { article: { title: "Ahoy!" } }, as: :json
#       end
#
#       assert_response :success
#       assert_equal({ id: Article.last.id, title: "Ahoy!" }, response.parsed_body)
#     end
#   end
#
# The +as+ option passes an "application/json" Accept header (thereby setting
# the request format to JSON unless overridden), sets the content type to
# "application/json" and encodes the parameters as JSON.
#
# Calling +parsed_body+ on the response parses the response body based on the
# last response MIME type.
#
# Out of the box, only <tt>:json</tt> is supported. But for any custom MIME
# types you've registered, you can add your own encoders with:
#
#   ActionDispatch::IntegrationTest.register_encoder :wibble,
#     param_encoder: -> params { params.to_wibble },
#     response_parser: -> body { body }
#
# Where +param_encoder+ defines how the params should be encoded and
# +response_parser+ defines how the response body should be parsed through
# +parsed_body+.
#
# Consult the Rails Testing Guide for more.
class ActionDispatch::IntegrationTest < ::ActiveSupport::TestCase
  include ::ActionDispatch::TestProcess::FixtureFile
  include ::Rails::Dom::Testing::Assertions::DomAssertions
  include ::Rails::Dom::Testing::Assertions::SelectorAssertions::CountDescribable
  include ::Rails::Dom::Testing::Assertions::SelectorAssertions
  include ::Rails::Dom::Testing::Assertions
  include ::ActionDispatch::Assertions::ResponseAssertions
  include ::ActionDispatch::Assertions::RoutingAssertions
  include ::ActionDispatch::Assertions
  include ::ActionDispatch::Integration::Runner
  include ::ActionController::TemplateAssertions
  include ::ActionDispatch::IntegrationTest::Behavior
  include ::ActionDispatch::Routing::PolymorphicRoutes
  include ::ActionDispatch::Routing::UrlFor
  include ::ActionDispatch::IntegrationTest::UrlOptions
  extend ::ActionDispatch::IntegrationTest::Behavior::ClassMethods
end

module ActionDispatch::IntegrationTest::Behavior
  include ::Rails::Dom::Testing::Assertions::DomAssertions
  include ::Rails::Dom::Testing::Assertions::SelectorAssertions::CountDescribable
  include ::Rails::Dom::Testing::Assertions::SelectorAssertions
  include ::Rails::Dom::Testing::Assertions
  include ::ActionDispatch::Assertions::ResponseAssertions
  include ::ActionDispatch::Assertions::RoutingAssertions
  include ::ActionDispatch::Assertions
  include ::ActionDispatch::Integration::Runner
  include ::ActionController::TemplateAssertions
  extend ::ActiveSupport::Concern
  include ::ActionDispatch::Routing::UrlFor
  include ::ActionDispatch::IntegrationTest::UrlOptions

  mixes_in_class_methods ::ActionDispatch::IntegrationTest::Behavior::ClassMethods

  def app; end
  def document_root_element; end
end

module ActionDispatch::IntegrationTest::Behavior::ClassMethods
  def app; end
  def app=(app); end
  def register_encoder(*args, **options); end
end

module ActionDispatch::IntegrationTest::UrlOptions
  extend ::ActiveSupport::Concern

  def url_options; end
end

# :stopdoc:
module ActionDispatch::Journey; end

class ActionDispatch::Journey::Format
  # @return [Format] a new instance of Format
  def initialize(parts); end

  def evaluate(hash); end

  class << self
    def required_path(symbol); end
    def required_segment(symbol); end
  end
end

ActionDispatch::Journey::Format::ESCAPE_PATH = T.let(T.unsafe(nil), Proc)
ActionDispatch::Journey::Format::ESCAPE_SEGMENT = T.let(T.unsafe(nil), Proc)

class ActionDispatch::Journey::Format::Parameter < ::Struct
  def escape(value); end

  # Returns the value of attribute escaper
  #
  # @return [Object] the current value of escaper
  def escaper; end

  # Sets the attribute escaper
  #
  # @param value [Object] the value to set the attribute escaper to.
  # @return [Object] the newly set value
  def escaper=(_); end

  # Returns the value of attribute name
  #
  # @return [Object] the current value of name
  def name; end

  # Sets the attribute name
  #
  # @param value [Object] the value to set the attribute name to.
  # @return [Object] the newly set value
  def name=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def members; end
    def new(*_arg0); end
  end
end

# The Formatter class is used for formatting URLs. For example, parameters
# passed to +url_for+ in Rails will eventually call Formatter#generate.
class ActionDispatch::Journey::Formatter
  # @return [Formatter] a new instance of Formatter
  def initialize(routes); end

  def clear; end
  def generate(name, options, path_parameters); end

  # Returns the value of attribute routes.
  def routes; end

  private

  def build_cache; end
  def cache; end
  def extract_parameterized_parts(route, options, recall); end
  def match_route(name, options); end

  # Returns an array populated with missing keys if any are present.
  def missing_keys(route, parts); end

  def named_routes; end
  def non_recursive(cache, options); end
  def possibles(cache, options, depth = T.unsafe(nil)); end
end

class ActionDispatch::Journey::Formatter::MissingRoute
  # @return [MissingRoute] a new instance of MissingRoute
  def initialize(constraints, missing_keys, unmatched_keys, routes, name); end

  # Returns the value of attribute constraints.
  def constraints; end

  def message; end

  # Returns the value of attribute missing_keys.
  def missing_keys; end

  # Returns the value of attribute name.
  def name; end

  def params; end

  # @raise [ActionController::UrlGenerationError]
  def path(method_name); end

  # Returns the value of attribute routes.
  def routes; end

  # Returns the value of attribute unmatched_keys.
  def unmatched_keys; end
end

class ActionDispatch::Journey::Formatter::RouteWithParams
  # @return [RouteWithParams] a new instance of RouteWithParams
  def initialize(route, parameterized_parts, params); end

  # Returns the value of attribute params.
  def params; end

  def path(_); end
end

module ActionDispatch::Journey::GTG; end

class ActionDispatch::Journey::GTG::Builder
  # @return [Builder] a new instance of Builder
  def initialize(root); end

  # Returns the value of attribute ast.
  def ast; end

  # Returns the value of attribute endpoints.
  def endpoints; end

  def firstpos(node); end
  def lastpos(node); end

  # @return [Boolean]
  def nullable?(node); end

  # Returns the value of attribute root.
  def root; end

  def transition_table; end

  private

  def build_followpos; end
  def symbol(edge); end
end

ActionDispatch::Journey::GTG::Builder::DUMMY = T.let(T.unsafe(nil), ActionDispatch::Journey::Nodes::Dummy)

class ActionDispatch::Journey::GTG::MatchData
  # @return [MatchData] a new instance of MatchData
  def initialize(memos); end

  # Returns the value of attribute memos.
  def memos; end
end

class ActionDispatch::Journey::GTG::Simulator
  # @return [Simulator] a new instance of Simulator
  def initialize(transition_table); end

  def memos(string); end

  # Returns the value of attribute tt.
  def tt; end
end

ActionDispatch::Journey::GTG::Simulator::INITIAL_STATE = T.let(T.unsafe(nil), Array)

class ActionDispatch::Journey::GTG::TransitionTable
  include ::ActionDispatch::Journey::NFA::Dot

  # @return [TransitionTable] a new instance of TransitionTable
  def initialize; end

  def []=(from, to, sym); end

  # @return [Boolean]
  def accepting?(state); end

  def accepting_states; end
  def add_accepting(state); end
  def add_memo(idx, memo); end
  def as_json(options = T.unsafe(nil)); end
  def eclosure(t); end
  def memo(idx); end

  # Returns the value of attribute memos.
  def memos; end

  def move(t, a); end
  def states; end
  def to_svg; end
  def transitions; end
  def visualizer(paths, title = T.unsafe(nil)); end

  private

  def states_hash_for(sym); end
end

module ActionDispatch::Journey::NFA; end

module ActionDispatch::Journey::NFA::Dot
  def to_dot; end
end

module ActionDispatch::Journey::Nodes; end

class ActionDispatch::Journey::Nodes::Binary < ::ActionDispatch::Journey::Nodes::Node
  # @return [Binary] a new instance of Binary
  def initialize(left, right); end

  def children; end

  # Returns the value of attribute right.
  def right; end

  # Sets the attribute right
  #
  # @param value the value to set the attribute right to.
  def right=(_arg0); end
end

class ActionDispatch::Journey::Nodes::Cat < ::ActionDispatch::Journey::Nodes::Binary
  # @return [Boolean]
  def cat?; end

  def type; end
end

class ActionDispatch::Journey::Nodes::Dot < ::ActionDispatch::Journey::Nodes::Terminal
  def type; end
end

class ActionDispatch::Journey::Nodes::Dummy < ::ActionDispatch::Journey::Nodes::Literal
  # @return [Dummy] a new instance of Dummy
  def initialize(x = T.unsafe(nil)); end

  # @return [Boolean]
  def literal?; end
end

class ActionDispatch::Journey::Nodes::Group < ::ActionDispatch::Journey::Nodes::Unary
  # @return [Boolean]
  def group?; end

  def type; end
end

class ActionDispatch::Journey::Nodes::Literal < ::ActionDispatch::Journey::Nodes::Terminal
  # @return [Boolean]
  def literal?; end

  def type; end
end

class ActionDispatch::Journey::Nodes::Node
  include ::Enumerable

  # @return [Node] a new instance of Node
  def initialize(left); end

  # @return [Boolean]
  def cat?; end

  def each(&block); end

  # @return [Boolean]
  def group?; end

  # Returns the value of attribute left.
  def left; end

  # Sets the attribute left
  #
  # @param value the value to set the attribute left to.
  def left=(_arg0); end

  # @return [Boolean]
  def literal?; end

  # Returns the value of attribute memo.
  def memo; end

  # Sets the attribute memo
  #
  # @param value the value to set the attribute memo to.
  def memo=(_arg0); end

  def name; end

  # @return [Boolean]
  def star?; end

  # @return [Boolean]
  def symbol?; end

  # @return [Boolean]
  def terminal?; end

  def to_dot; end
  def to_s; end
  def to_sym; end

  # @raise [NotImplementedError]
  def type; end
end

class ActionDispatch::Journey::Nodes::Or < ::ActionDispatch::Journey::Nodes::Node
  # @return [Or] a new instance of Or
  def initialize(children); end

  # Returns the value of attribute children.
  def children; end

  def type; end
end

class ActionDispatch::Journey::Nodes::Slash < ::ActionDispatch::Journey::Nodes::Terminal
  def type; end
end

class ActionDispatch::Journey::Nodes::Star < ::ActionDispatch::Journey::Nodes::Unary
  def name; end

  # @return [Boolean]
  def star?; end

  def type; end
end

class ActionDispatch::Journey::Nodes::Symbol < ::ActionDispatch::Journey::Nodes::Terminal
  # @return [Symbol] a new instance of Symbol
  def initialize(left, regexp = T.unsafe(nil)); end

  # @return [Boolean]
  def default_regexp?; end

  # Returns the value of attribute name.
  def name; end

  # Returns the value of attribute regexp.
  def regexp; end

  # Sets the attribute regexp
  #
  # @param value the value to set the attribute regexp to.
  def regexp=(_arg0); end

  # Returns the value of attribute regexp.
  def symbol; end

  # @return [Boolean]
  def symbol?; end

  def type; end
end

ActionDispatch::Journey::Nodes::Symbol::DEFAULT_EXP = T.let(T.unsafe(nil), Regexp)
ActionDispatch::Journey::Nodes::Symbol::GREEDY_EXP = T.let(T.unsafe(nil), Regexp)

class ActionDispatch::Journey::Nodes::Terminal < ::ActionDispatch::Journey::Nodes::Node
  def symbol; end

  # @return [Boolean]
  def terminal?; end
end

class ActionDispatch::Journey::Nodes::Unary < ::ActionDispatch::Journey::Nodes::Node
  def children; end
end

class ActionDispatch::Journey::Parser < ::Racc::Parser
  include ::ActionDispatch::Journey::Nodes

  # @return [Parser] a new instance of Parser
  def initialize; end

  # reduce 0 omitted
  def _reduce_1(val, _values); end

  def _reduce_10(val, _values); end

  # reduce 14 omitted
  def _reduce_15(val, _values); end

  def _reduce_16(val, _values); end
  def _reduce_17(val, _values); end
  def _reduce_18(val, _values); end
  def _reduce_2(val, _values); end

  # reduce 6 omitted
  def _reduce_7(val, _values); end

  def _reduce_8(val, _values); end
  def _reduce_9(val, _values); end
  def _reduce_none(val, _values); end
  def next_token; end
  def parse(string); end

  class << self
    def parse(string); end
  end
end

ActionDispatch::Journey::Parser::Racc_arg = T.let(T.unsafe(nil), Array)
ActionDispatch::Journey::Parser::Racc_token_to_s_table = T.let(T.unsafe(nil), Array)
module ActionDispatch::Journey::Path; end

class ActionDispatch::Journey::Path::Pattern
  # @return [Pattern] a new instance of Pattern
  def initialize(ast, requirements, separators, anchored); end

  def =~(other); end

  # Returns the value of attribute anchored.
  def anchored; end

  def ast; end
  def build_formatter; end
  def eager_load!; end
  def match(other); end

  # @return [Boolean]
  def match?(other); end

  def names; end
  def optional_names; end
  def required_names; end

  # Returns the value of attribute requirements.
  def requirements; end

  def requirements_for_missing_keys_check; end
  def source; end

  # Returns the value of attribute spec.
  def spec; end

  def to_regexp; end

  private

  def offsets; end
  def regexp_visitor; end
end

class ActionDispatch::Journey::Path::Pattern::AnchoredRegexp < ::ActionDispatch::Journey::Visitors::Visitor
  # @return [AnchoredRegexp] a new instance of AnchoredRegexp
  def initialize(separator, matchers); end

  def accept(node); end
  def visit_CAT(node); end
  def visit_DOT(node); end
  def visit_GROUP(node); end
  def visit_LITERAL(node); end
  def visit_OR(node); end
  def visit_SLASH(node); end
  def visit_STAR(node); end
  def visit_SYMBOL(node); end
end

class ActionDispatch::Journey::Path::Pattern::MatchData
  # @return [MatchData] a new instance of MatchData
  def initialize(names, offsets, match); end

  def [](x); end
  def captures; end
  def length; end
  def named_captures; end

  # Returns the value of attribute names.
  def names; end

  def post_match; end
  def to_s; end
end

class ActionDispatch::Journey::Path::Pattern::UnanchoredRegexp < ::ActionDispatch::Journey::Path::Pattern::AnchoredRegexp
  def accept(node); end
end

class ActionDispatch::Journey::Route
  # +path+ is a path constraint.
  # +constraints+ is a hash of constraints to be applied to this route.
  #
  # @return [Route] a new instance of Route
  def initialize(name:, path:, app: T.unsafe(nil), constraints: T.unsafe(nil), required_defaults: T.unsafe(nil), defaults: T.unsafe(nil), request_method_match: T.unsafe(nil), precedence: T.unsafe(nil), scope_options: T.unsafe(nil), internal: T.unsafe(nil)); end

  # Returns the value of attribute app.
  def app; end

  def ast; end

  # Returns the value of attribute constraints.
  def conditions; end

  # Returns the value of attribute constraints.
  def constraints; end

  # Returns the value of attribute defaults.
  def defaults; end

  # @return [Boolean]
  def dispatcher?; end

  def eager_load!; end
  def format(path_options); end

  # @return [Boolean]
  def glob?; end

  # Returns the value of attribute internal.
  def internal; end

  def ip; end

  # @return [Boolean]
  def matches?(request); end

  # Returns the value of attribute name.
  def name; end

  def parts; end

  # Returns the value of attribute path.
  def path; end

  # Returns the value of attribute precedence.
  def precedence; end

  # @return [Boolean]
  def required_default?(key); end

  def required_defaults; end
  def required_keys; end
  def required_parts; end

  # Needed for `bin/rails routes`. Picks up succinctly defined requirements
  # for a route, for example route
  #
  #   get 'photo/:id', :controller => 'photos', :action => 'show',
  #     :id => /[A-Z]\d{5}/
  #
  # will have {:controller=>"photos", :action=>"show", :id=>/[A-Z]\d{5}/}
  # as requirements.
  def requirements; end

  # @return [Boolean]
  def requires_matching_verb?; end

  # Returns the value of attribute scope_options.
  def scope_options; end

  def score(supplied_keys); end
  def segment_keys; end
  def segments; end
  def verb; end

  private

  def match_verb(request); end
  def verbs; end

  class << self
    def verb_matcher(verb); end
  end
end

module ActionDispatch::Journey::Route::VerbMatchers; end

class ActionDispatch::Journey::Route::VerbMatchers::All
  class << self
    def call(_); end
    def verb; end
  end
end

class ActionDispatch::Journey::Route::VerbMatchers::DELETE
  class << self
    def call(req); end
    def verb; end
  end
end

class ActionDispatch::Journey::Route::VerbMatchers::GET
  class << self
    def call(req); end
    def verb; end
  end
end

class ActionDispatch::Journey::Route::VerbMatchers::HEAD
  class << self
    def call(req); end
    def verb; end
  end
end

class ActionDispatch::Journey::Route::VerbMatchers::LINK
  class << self
    def call(req); end
    def verb; end
  end
end

class ActionDispatch::Journey::Route::VerbMatchers::OPTIONS
  class << self
    def call(req); end
    def verb; end
  end
end

class ActionDispatch::Journey::Route::VerbMatchers::PATCH
  class << self
    def call(req); end
    def verb; end
  end
end

class ActionDispatch::Journey::Route::VerbMatchers::POST
  class << self
    def call(req); end
    def verb; end
  end
end

class ActionDispatch::Journey::Route::VerbMatchers::PUT
  class << self
    def call(req); end
    def verb; end
  end
end

class ActionDispatch::Journey::Route::VerbMatchers::TRACE
  class << self
    def call(req); end
    def verb; end
  end
end

class ActionDispatch::Journey::Route::VerbMatchers::UNLINK
  class << self
    def call(req); end
    def verb; end
  end
end

class ActionDispatch::Journey::Route::VerbMatchers::Unknown
  # @return [Unknown] a new instance of Unknown
  def initialize(verb); end

  def call(request); end

  # Returns the value of attribute verb.
  def verb; end
end

ActionDispatch::Journey::Route::VerbMatchers::VERBS = T.let(T.unsafe(nil), Array)
ActionDispatch::Journey::Route::VerbMatchers::VERB_TO_CLASS = T.let(T.unsafe(nil), Hash)

class ActionDispatch::Journey::Router
  # @return [Router] a new instance of Router
  def initialize(routes); end

  def eager_load!; end
  def recognize(rails_req); end

  # Returns the value of attribute routes.
  def routes; end

  # Sets the attribute routes
  #
  # @param value the value to set the attribute routes to.
  def routes=(_arg0); end

  def serve(req); end
  def visualizer; end

  private

  def ast; end
  def custom_routes; end
  def filter_routes(path); end
  def find_routes(req); end
  def match_head_routes(routes, req); end
  def partitioned_routes; end
  def simulator; end
end

class ActionDispatch::Journey::Router::Utils
  class << self
    def escape_fragment(fragment); end
    def escape_path(path); end
    def escape_segment(segment); end

    # Normalizes URI path.
    #
    # Strips off trailing slash and ensures there is a leading slash.
    # Also converts downcase URL encoded string to uppercase.
    #
    #   normalize_path("/foo")  # => "/foo"
    #   normalize_path("/foo/") # => "/foo"
    #   normalize_path("foo")   # => "/foo"
    #   normalize_path("")      # => "/"
    #   normalize_path("/%ab")  # => "/%AB"
    def normalize_path(path); end

    # Replaces any escaped sequences with their unescaped representations.
    #
    #   uri = "/topics?title=Ruby%20on%20Rails"
    #   unescape_uri(uri)  #=> "/topics?title=Ruby on Rails"
    def unescape_uri(uri); end
  end
end

ActionDispatch::Journey::Router::Utils::ENCODER = T.let(T.unsafe(nil), ActionDispatch::Journey::Router::Utils::UriEncoder)

# URI path and fragment escaping
# https://tools.ietf.org/html/rfc3986
class ActionDispatch::Journey::Router::Utils::UriEncoder
  def escape_fragment(fragment); end
  def escape_path(path); end
  def escape_segment(segment); end
  def unescape_uri(uri); end

  private

  def escape(component, pattern); end
  def percent_encode(unsafe); end
end

ActionDispatch::Journey::Router::Utils::UriEncoder::ALPHA = T.let(T.unsafe(nil), String)
ActionDispatch::Journey::Router::Utils::UriEncoder::DEC2HEX = T.let(T.unsafe(nil), Array)
ActionDispatch::Journey::Router::Utils::UriEncoder::DIGIT = T.let(T.unsafe(nil), String)
ActionDispatch::Journey::Router::Utils::UriEncoder::EMPTY = T.let(T.unsafe(nil), String)
ActionDispatch::Journey::Router::Utils::UriEncoder::ENCODE = T.let(T.unsafe(nil), String)
ActionDispatch::Journey::Router::Utils::UriEncoder::ESCAPED = T.let(T.unsafe(nil), Regexp)
ActionDispatch::Journey::Router::Utils::UriEncoder::FRAGMENT = T.let(T.unsafe(nil), Regexp)
ActionDispatch::Journey::Router::Utils::UriEncoder::PATH = T.let(T.unsafe(nil), Regexp)
ActionDispatch::Journey::Router::Utils::UriEncoder::SEGMENT = T.let(T.unsafe(nil), Regexp)
ActionDispatch::Journey::Router::Utils::UriEncoder::SUB_DELIMS = T.let(T.unsafe(nil), String)
ActionDispatch::Journey::Router::Utils::UriEncoder::UNRESERVED = T.let(T.unsafe(nil), String)
ActionDispatch::Journey::Router::Utils::UriEncoder::US_ASCII = T.let(T.unsafe(nil), Encoding)
ActionDispatch::Journey::Router::Utils::UriEncoder::UTF_8 = T.let(T.unsafe(nil), Encoding)

# The Routing table. Contains all routes for a system. Routes can be
# added to the table by calling Routes#add_route.
class ActionDispatch::Journey::Routes
  include ::Enumerable

  # @return [Routes] a new instance of Routes
  def initialize; end

  def add_route(name, mapping); end

  # Returns the value of attribute anchored_routes.
  def anchored_routes; end

  def ast; end
  def clear; end

  # Returns the value of attribute custom_routes.
  def custom_routes; end

  def each(&block); end

  # @return [Boolean]
  def empty?; end

  def last; end
  def length; end
  def partition_route(route); end

  # Returns the value of attribute routes.
  def routes; end

  def simulator; end
  def size; end

  private

  def clear_cache!; end
end

class ActionDispatch::Journey::Scanner
  # @return [Scanner] a new instance of Scanner
  def initialize; end

  # @return [Boolean]
  def eos?; end

  def next_token; end
  def pos; end
  def pre_match; end
  def scan_setup(str); end

  private

  # takes advantage of String @- deduping capabilities in Ruby 2.5 upwards
  # see: https://bugs.ruby-lang.org/issues/13077
  def dedup_scan(regex); end

  def scan; end
end

module ActionDispatch::Journey::Visitors; end

class ActionDispatch::Journey::Visitors::Dot < ::ActionDispatch::Journey::Visitors::FunctionalVisitor
  # @return [Dot] a new instance of Dot
  def initialize; end

  def accept(node, seed = T.unsafe(nil)); end

  private

  def binary(node, seed); end
  def nary(node, seed); end
  def terminal(node, seed); end
  def unary(node, seed); end
  def visit_CAT(node, seed); end
  def visit_GROUP(node, seed); end
  def visit_OR(node, seed); end
  def visit_STAR(node, seed); end
end

ActionDispatch::Journey::Visitors::Dot::INSTANCE = T.let(T.unsafe(nil), ActionDispatch::Journey::Visitors::Dot)

# Loop through the requirements AST.
class ActionDispatch::Journey::Visitors::Each < ::ActionDispatch::Journey::Visitors::FunctionalVisitor
  def visit(node, block); end
end

ActionDispatch::Journey::Visitors::Each::INSTANCE = T.let(T.unsafe(nil), ActionDispatch::Journey::Visitors::Each)

class ActionDispatch::Journey::Visitors::FormatBuilder < ::ActionDispatch::Journey::Visitors::Visitor
  def accept(node); end
  def binary(node); end
  def terminal(node); end
  def visit_GROUP(n); end
  def visit_STAR(n); end
  def visit_SYMBOL(n); end
end

class ActionDispatch::Journey::Visitors::FunctionalVisitor
  def accept(node, seed); end
  def binary(node, seed); end
  def nary(node, seed); end
  def terminal(node, seed); end
  def unary(node, seed); end
  def visit(node, seed); end
  def visit_CAT(n, seed); end
  def visit_DOT(n, seed); end
  def visit_GROUP(n, seed); end
  def visit_LITERAL(n, seed); end
  def visit_OR(n, seed); end
  def visit_SLASH(n, seed); end
  def visit_STAR(n, seed); end
  def visit_SYMBOL(n, seed); end
end

ActionDispatch::Journey::Visitors::FunctionalVisitor::DISPATCH_CACHE = T.let(T.unsafe(nil), Hash)

class ActionDispatch::Journey::Visitors::String < ::ActionDispatch::Journey::Visitors::FunctionalVisitor
  private

  def binary(node, seed); end
  def nary(node, seed); end
  def terminal(node, seed); end
  def visit_GROUP(node, seed); end
end

ActionDispatch::Journey::Visitors::String::INSTANCE = T.let(T.unsafe(nil), ActionDispatch::Journey::Visitors::String)

class ActionDispatch::Journey::Visitors::Visitor
  def accept(node); end

  private

  def binary(node); end
  def nary(node); end
  def terminal(node); end
  def unary(node); end
  def visit(node); end
  def visit_CAT(n); end
  def visit_DOT(n); end
  def visit_GROUP(n); end
  def visit_LITERAL(n); end
  def visit_OR(n); end
  def visit_SLASH(n); end
  def visit_STAR(n); end
  def visit_SYMBOL(n); end
end

ActionDispatch::Journey::Visitors::Visitor::DISPATCH_CACHE = T.let(T.unsafe(nil), Hash)

class ActionDispatch::MiddlewareStack
  include ::Enumerable

  # @return [MiddlewareStack] a new instance of MiddlewareStack
  # @yield [_self]
  # @yieldparam _self [ActionDispatch::MiddlewareStack] the object that the method was called on
  def initialize(*args); end

  def [](i); end
  def build(app = T.unsafe(nil), &block); end
  def delete(target); end
  def each; end
  def insert(index, klass, *args, &block); end
  def insert_after(index, *args, &block); end
  def insert_before(index, klass, *args, &block); end
  def last; end

  # Returns the value of attribute middlewares.
  def middlewares; end

  # Sets the attribute middlewares
  #
  # @param value the value to set the attribute middlewares to.
  def middlewares=(_arg0); end

  def move(target, source); end
  def move_after(target, source); end
  def move_before(target, source); end
  def size; end
  def swap(target, *args, &block); end
  def unshift(klass, *args, &block); end
  def use(klass, *args, &block); end

  private

  def assert_index(index, where); end
  def build_middleware(klass, args, block); end
  def initialize_copy(other); end
end

# This class is used to instrument the execution of a single middleware.
# It proxies the +call+ method transparently and instruments the method
# call.
class ActionDispatch::MiddlewareStack::InstrumentationProxy
  # @return [InstrumentationProxy] a new instance of InstrumentationProxy
  def initialize(middleware, class_name); end

  def call(env); end
end

ActionDispatch::MiddlewareStack::InstrumentationProxy::EVENT_NAME = T.let(T.unsafe(nil), String)

class ActionDispatch::MiddlewareStack::Middleware
  # @return [Middleware] a new instance of Middleware
  def initialize(klass, args, block); end

  def ==(middleware); end

  # Returns the value of attribute args.
  def args; end

  # Returns the value of attribute block.
  def block; end

  def build(app); end
  def build_instrumented(app); end
  def inspect; end

  # Returns the value of attribute klass.
  def klass; end

  def name; end
end

class ActionDispatch::MissingController < ::NameError; end

class ActionDispatch::PermissionsPolicy
  # @return [PermissionsPolicy] a new instance of PermissionsPolicy
  # @yield [_self]
  # @yieldparam _self [ActionDispatch::PermissionsPolicy] the object that the method was called on
  def initialize; end

  def accelerometer(*sources); end
  def ambient_light_sensor(*sources); end
  def autoplay(*sources); end
  def build(context = T.unsafe(nil)); end
  def camera(*sources); end

  # Returns the value of attribute directives.
  def directives; end

  def encrypted_media(*sources); end
  def fullscreen(*sources); end
  def geolocation(*sources); end
  def gyroscope(*sources); end
  def magnetometer(*sources); end
  def microphone(*sources); end
  def midi(*sources); end
  def payment(*sources); end
  def picture_in_picture(*sources); end
  def speaker(*sources); end
  def usb(*sources); end
  def vibrate(*sources); end
  def vr(*sources); end

  private

  def apply_mapping(source); end
  def apply_mappings(sources); end
  def build_directive(sources, context); end
  def build_directives(context); end
  def initialize_copy(other); end
  def resolve_source(source, context); end
end

# List of available permissions can be found at
# https://github.com/w3c/webappsec-permissions-policy/blob/master/features.md#policy-controlled-features
ActionDispatch::PermissionsPolicy::DIRECTIVES = T.let(T.unsafe(nil), Hash)

ActionDispatch::PermissionsPolicy::MAPPINGS = T.let(T.unsafe(nil), Hash)

class ActionDispatch::PermissionsPolicy::Middleware
  # @return [Middleware] a new instance of Middleware
  def initialize(app); end

  def call(env); end

  private

  # @return [Boolean]
  def html_response?(headers); end

  # @return [Boolean]
  def policy_empty?(policy); end

  # @return [Boolean]
  def policy_present?(headers); end
end

ActionDispatch::PermissionsPolicy::Middleware::CONTENT_TYPE = T.let(T.unsafe(nil), String)

# The Feature-Policy header has been renamed to Permissions-Policy.
# The Permissions-Policy requires a different implementation and isn't
# yet supported by all browsers. To avoid having to rename this
# middleware in the future we use the new name for the middleware but
# keep the old header name and implementation for now.
ActionDispatch::PermissionsPolicy::Middleware::POLICY = T.let(T.unsafe(nil), String)

module ActionDispatch::PermissionsPolicy::Request
  def permissions_policy; end
  def permissions_policy=(policy); end
end

ActionDispatch::PermissionsPolicy::Request::POLICY = T.let(T.unsafe(nil), String)

# When called, this middleware renders an error page. By default if an HTML
# response is expected it will render static error pages from the <tt>/public</tt>
# directory. For example when this middleware receives a 500 response it will
# render the template found in <tt>/public/500.html</tt>.
# If an internationalized locale is set, this middleware will attempt to render
# the template in <tt>/public/500.<locale>.html</tt>. If an internationalized template
# is not found it will fall back on <tt>/public/500.html</tt>.
#
# When a request with a content type other than HTML is made, this middleware
# will attempt to convert error information into the appropriate response type.
class ActionDispatch::PublicExceptions
  # @return [PublicExceptions] a new instance of PublicExceptions
  def initialize(public_path); end

  def call(env); end

  # Returns the value of attribute public_path.
  def public_path; end

  # Sets the attribute public_path
  #
  # @param value the value to set the attribute public_path to.
  def public_path=(_arg0); end

  private

  def render(status, content_type, body); end
  def render_format(status, content_type, body); end
  def render_html(status); end
end

class ActionDispatch::Railtie < ::Rails::Railtie; end

# ActionDispatch::Reloader wraps the request with callbacks provided by ActiveSupport::Reloader
# callbacks, intended to assist with code reloading during development.
#
# By default, ActionDispatch::Reloader is included in the middleware stack
# only in the development environment; specifically, when +config.cache_classes+
# is false.
class ActionDispatch::Reloader < ::ActionDispatch::Executor; end

# This middleware calculates the IP address of the remote client that is
# making the request. It does this by checking various headers that could
# contain the address, and then picking the last-set address that is not
# on the list of trusted IPs. This follows the precedent set by e.g.
# {the Tomcat server}[https://issues.apache.org/bugzilla/show_bug.cgi?id=50453],
# with {reasoning explained at length}[https://blog.gingerlime.com/2012/rails-ip-spoofing-vulnerabilities-and-protection]
# by @gingerlime. A more detailed explanation of the algorithm is given
# at GetIp#calculate_ip.
#
# Some Rack servers concatenate repeated headers, like {HTTP RFC 2616}[https://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.2]
# requires. Some Rack servers simply drop preceding headers, and only report
# the value that was {given in the last header}[https://andre.arko.net/2011/12/26/repeated-headers-and-ruby-web-servers].
# If you are behind multiple proxy servers (like NGINX to HAProxy to Unicorn)
# then you should test your Rack server to make sure your data is good.
#
# IF YOU DON'T USE A PROXY, THIS MAKES YOU VULNERABLE TO IP SPOOFING.
# This middleware assumes that there is at least one proxy sitting around
# and setting headers with the client's remote IP address. If you don't use
# a proxy, because you are hosted on e.g. Heroku without SSL, any client can
# claim to have any IP address by setting the X-Forwarded-For header. If you
# care about that, then you need to explicitly drop or ignore those headers
# sometime before this middleware runs.
class ActionDispatch::RemoteIp
  # Create a new +RemoteIp+ middleware instance.
  #
  # The +ip_spoofing_check+ option is on by default. When on, an exception
  # is raised if it looks like the client is trying to lie about its own IP
  # address. It makes sense to turn off this check on sites aimed at non-IP
  # clients (like WAP devices), or behind proxies that set headers in an
  # incorrect or confusing way (like AWS ELB).
  #
  # The +custom_proxies+ argument can take an Array of string, IPAddr, or
  # Regexp objects which will be used instead of +TRUSTED_PROXIES+. If a
  # single string, IPAddr, or Regexp object is provided, it will be used in
  # addition to +TRUSTED_PROXIES+. Any proxy setup will put the value you
  # want in the middle (or at the beginning) of the X-Forwarded-For list,
  # with your proxy servers after it. If your proxies aren't removed, pass
  # them in via the +custom_proxies+ parameter. That way, the middleware will
  # ignore those IP addresses, and return the one that you want.
  #
  # @return [RemoteIp] a new instance of RemoteIp
  def initialize(app, ip_spoofing_check = T.unsafe(nil), custom_proxies = T.unsafe(nil)); end

  # Since the IP address may not be needed, we store the object here
  # without calculating the IP to keep from slowing down the majority of
  # requests. For those requests that do need to know the IP, the
  # GetIp#calculate_ip method will calculate the memoized client IP address.
  def call(env); end

  # Returns the value of attribute check_ip.
  def check_ip; end

  # Returns the value of attribute proxies.
  def proxies; end
end

# The GetIp class exists as a way to defer processing of the request data
# into an actual IP address. If the ActionDispatch::Request#remote_ip method
# is called, this class will calculate the value and then memoize it.
class ActionDispatch::RemoteIp::GetIp
  # @return [GetIp] a new instance of GetIp
  def initialize(req, check_ip, proxies); end

  # Sort through the various IP address headers, looking for the IP most
  # likely to be the address of the actual remote client making this
  # request.
  #
  # REMOTE_ADDR will be correct if the request is made directly against the
  # Ruby process, on e.g. Heroku. When the request is proxied by another
  # server like HAProxy or NGINX, the IP address that made the original
  # request will be put in an X-Forwarded-For header. If there are multiple
  # proxies, that header may contain a list of IPs. Other proxy services
  # set the Client-Ip header instead, so we check that too.
  #
  # As discussed in {this post about Rails IP Spoofing}[https://blog.gingerlime.com/2012/rails-ip-spoofing-vulnerabilities-and-protection/],
  # while the first IP in the list is likely to be the "originating" IP,
  # it could also have been set by the client maliciously.
  #
  # In order to find the first address that is (probably) accurate, we
  # take the list of IPs, remove known and trusted proxies, and then take
  # the last address left, which was presumably set by one of those proxies.
  def calculate_ip; end

  # Memoizes the value returned by #calculate_ip and returns it for
  # ActionDispatch::Request to use.
  def to_s; end

  private

  def filter_proxies(ips); end
  def ips_from(header); end
end

class ActionDispatch::RemoteIp::IpSpoofAttackError < ::StandardError; end

# The default trusted IPs list simply includes IP addresses that are
# guaranteed by the IP specification to be private addresses. Those will
# not be the ultimate client IP in production, and so are discarded. See
# https://en.wikipedia.org/wiki/Private_network for details.
ActionDispatch::RemoteIp::TRUSTED_PROXIES = T.let(T.unsafe(nil), Array)

class ActionDispatch::Request
  include ::ActionDispatch::Flash::RequestMethods
  include ::Rack::Request::Helpers
  include ::ActionDispatch::Http::Cache::Request
  include ::ActionDispatch::Http::MimeNegotiation
  include ::ActionDispatch::Http::Parameters
  include ::ActionDispatch::Http::FilterParameters
  include ::ActionDispatch::Http::URL
  include ::ActionDispatch::ContentSecurityPolicy::Request
  include ::ActionDispatch::PermissionsPolicy::Request
  include ::Rack::Request::Env
  extend ::ActionDispatch::Http::Parameters::ClassMethods

  # @return [Request] a new instance of Request
  def initialize(env); end

  # Override Rack's GET method to support indifferent access.
  def GET; end

  # Override Rack's POST method to support indifferent access.
  def POST; end

  def accept; end
  def accept_charset; end
  def accept_encoding; end
  def accept_language; end
  def auth_type; end
  def authenticated_encrypted_cookie_salt; end

  # Returns the authorization header regardless of whether it was specified directly or through one of the
  # proxy alternatives.
  def authorization; end

  # The request body is an IO input stream. If the RAW_POST_DATA environment
  # variable is already set, wrap it in a StringIO.
  def body; end

  def body_stream; end
  def cache_control; end
  def client_ip; end
  def commit_cookie_jar!; end
  def commit_flash; end

  # Returns the content length of the request as an integer.
  def content_length; end

  def controller_class; end
  def controller_class_for(name); end
  def controller_instance; end
  def controller_instance=(controller); end
  def cookie_jar; end
  def cookie_jar=(jar); end
  def cookies_digest; end
  def cookies_rotations; end
  def cookies_same_site_protection; end
  def cookies_serializer; end
  def encrypted_cookie_cipher; end
  def encrypted_cookie_salt; end
  def encrypted_signed_cookie_salt; end
  def engine_script_name(_routes); end
  def engine_script_name=(name); end

  # Determine whether the request body contains form-data by checking
  # the request Content-Type for one of the media-types:
  # "application/x-www-form-urlencoded" or "multipart/form-data". The
  # list of form-data media types can be modified through the
  # +FORM_DATA_MEDIA_TYPES+ array.
  #
  # A request body is not assumed to contain form-data when no
  # Content-Type header is provided and the request_method is POST.
  #
  # @return [Boolean]
  def form_data?; end

  def from; end

  # Returns the +String+ full path including params of the last URL requested.
  #
  #    # get "/articles"
  #    request.fullpath # => "/articles"
  #
  #    # get "/articles?page=2"
  #    request.fullpath # => "/articles?page=2"
  def fullpath; end

  def gateway_interface; end

  # @return [Boolean]
  def have_cookie_jar?; end

  # Provides access to the request's HTTP headers, for example:
  #
  #   request.headers["Content-Type"] # => "text/plain"
  def headers; end

  def http_auth_salt; end
  def ignore_accept_header; end
  def ignore_accept_header=(val); end
  def inspect; end

  # Returns the IP address of client as a +String+.
  def ip; end

  # Returns true if the request has a header matching the given key parameter.
  #
  #    request.key? :ip_spoofing_check # => true
  #
  # @return [Boolean]
  def key?(key); end

  def key_generator; end

  # True if the request came from localhost, 127.0.0.1, or ::1.
  #
  # @return [Boolean]
  def local?; end

  def logger; end

  # The +String+ MIME type of the request.
  #
  #    # get "/articles"
  #    request.media_type # => "application/x-www-form-urlencoded"
  def media_type; end

  # Returns the original value of the environment's REQUEST_METHOD,
  # even if it was overridden by middleware. See #request_method for
  # more information.
  def method; end

  # Returns a symbol form of the #method.
  def method_symbol; end

  def negotiate; end
  def origin; end

  # Returns a +String+ with the last requested path including their params.
  #
  #    # get '/foo'
  #    request.original_fullpath # => '/foo'
  #
  #    # get '/foo?bar'
  #    request.original_fullpath # => '/foo?bar'
  def original_fullpath; end

  def original_script_name; end

  # Returns the original request URL as a +String+.
  #
  #    # get "/articles?page=2"
  #    request.original_url # => "http://www.example.com/articles?page=2"
  def original_url; end

  def path_translated; end
  def pragma; end

  # Override Rack's GET method to support indifferent access.
  def query_parameters; end

  # Read the request \body. This is useful for web services that need to
  # work with raw requests directly.
  def raw_post; end

  def raw_request_method; end
  def remote_addr; end
  def remote_host; end
  def remote_ident; end

  # Returns the IP address of client as a +String+,
  # usually set by the RemoteIp middleware.
  def remote_ip; end

  def remote_ip=(remote_ip); end
  def remote_user; end

  # Returns the unique request id, which is based on either the X-Request-Id header that can
  # be generated by a firewall, load balancer, or web server or by the RequestId middleware
  # (which sets the action_dispatch.request_id environment variable).
  #
  # This unique ID is useful for tracing a request from end-to-end as part of logging or debugging.
  # This relies on the Rack variable set by the ActionDispatch::RequestId middleware.
  def request_id; end

  def request_id=(id); end

  # Returns the HTTP \method that the application should see.
  # In the case where the \method was overridden by a middleware
  # (for instance, if a HEAD request was converted to a GET,
  # or if a _method parameter was used to determine the \method
  # the application should use), this \method returns the overridden
  # value, not the original.
  def request_method; end

  def request_method=(request_method); end

  # Returns a symbol form of the #request_method.
  def request_method_symbol; end

  # Override Rack's POST method to support indifferent access.
  def request_parameters; end

  def request_parameters=(params); end

  # TODO This should be broken apart into AD::Request::Session and probably
  # be included by the session middleware.
  def reset_session; end

  def routes; end
  def routes=(routes); end
  def secret_key_base; end

  # Early Hints is an HTTP/2 status code that indicates hints to help a client start
  # making preparations for processing the final response.
  #
  # If the env contains +rack.early_hints+ then the server accepts HTTP2 push for Link headers.
  #
  # The +send_early_hints+ method accepts a hash of links as follows:
  #
  #   send_early_hints("Link" => "</style.css>; rel=preload; as=style\n</script.js>; rel=preload")
  #
  # If you are using +javascript_include_tag+ or +stylesheet_link_tag+ the
  # Early Hints headers are included by default if supported.
  def send_early_hints(links); end

  def server_addr; end
  def server_name; end
  def server_protocol; end

  # Returns the lowercase name of the HTTP server software.
  def server_software; end

  def session=(session); end
  def session_options=(options); end

  # @return [Boolean]
  def show_exceptions?; end

  def signed_cookie_digest; end
  def signed_cookie_salt; end

  # @return [Boolean]
  def ssl?; end

  def use_authenticated_cookie_encryption; end
  def use_cookies_with_metadata; end

  # Returns the unique request id, which is based on either the X-Request-Id header that can
  # be generated by a firewall, load balancer, or web server or by the RequestId middleware
  # (which sets the action_dispatch.request_id environment variable).
  #
  # This unique ID is useful for tracing a request from end-to-end as part of logging or debugging.
  # This relies on the Rack variable set by the ActionDispatch::RequestId middleware.
  def uuid; end

  def version; end
  def x_csrf_token; end
  def x_forwarded_for; end
  def x_forwarded_host; end
  def x_request_id; end

  # Returns true if the "X-Requested-With" header contains "XMLHttpRequest"
  # (case-insensitive), which may need to be manually added depending on the
  # choice of JavaScript libraries and frameworks.
  #
  # @return [Boolean]
  def xhr?; end

  # Returns true if the "X-Requested-With" header contains "XMLHttpRequest"
  # (case-insensitive), which may need to be manually added depending on the
  # choice of JavaScript libraries and frameworks.
  #
  # @return [Boolean]
  def xml_http_request?; end

  private

  def check_method(name); end

  class << self
    def empty; end
    def ignore_accept_header; end
    def ignore_accept_header=(val); end
    def parameter_parsers; end
  end
end

ActionDispatch::Request::ACTION_DISPATCH_REQUEST_ID = T.let(T.unsafe(nil), String)
ActionDispatch::Request::ENV_METHODS = T.let(T.unsafe(nil), Array)
ActionDispatch::Request::HTTP_METHODS = T.let(T.unsafe(nil), Array)
ActionDispatch::Request::HTTP_METHOD_LOOKUP = T.let(T.unsafe(nil), Hash)
ActionDispatch::Request::LOCALHOST = T.let(T.unsafe(nil), Regexp)

class ActionDispatch::Request::PASS_NOT_FOUND
  class << self
    def action(_); end
    def action_encoding_template(action); end
    def call(_); end
  end
end

ActionDispatch::Request::RFC2518 = T.let(T.unsafe(nil), Array)

# List of HTTP request methods from the following RFCs:
# Hypertext Transfer Protocol -- HTTP/1.1 (https://www.ietf.org/rfc/rfc2616.txt)
# HTTP Extensions for Distributed Authoring -- WEBDAV (https://www.ietf.org/rfc/rfc2518.txt)
# Versioning Extensions to WebDAV (https://www.ietf.org/rfc/rfc3253.txt)
# Ordered Collections Protocol (WebDAV) (https://www.ietf.org/rfc/rfc3648.txt)
# Web Distributed Authoring and Versioning (WebDAV) Access Control Protocol (https://www.ietf.org/rfc/rfc3744.txt)
# Web Distributed Authoring and Versioning (WebDAV) SEARCH (https://www.ietf.org/rfc/rfc5323.txt)
# Calendar Extensions to WebDAV (https://www.ietf.org/rfc/rfc4791.txt)
# PATCH Method for HTTP (https://www.ietf.org/rfc/rfc5789.txt)
ActionDispatch::Request::RFC2616 = T.let(T.unsafe(nil), Array)

ActionDispatch::Request::RFC3253 = T.let(T.unsafe(nil), Array)
ActionDispatch::Request::RFC3648 = T.let(T.unsafe(nil), Array)
ActionDispatch::Request::RFC3744 = T.let(T.unsafe(nil), Array)
ActionDispatch::Request::RFC4791 = T.let(T.unsafe(nil), Array)
ActionDispatch::Request::RFC5323 = T.let(T.unsafe(nil), Array)
ActionDispatch::Request::RFC5789 = T.let(T.unsafe(nil), Array)

# Session is responsible for lazily loading the session from store.
class ActionDispatch::Request::Session
  # @return [Session] a new instance of Session
  def initialize(by, req); end

  # Returns value of the key stored in the session or
  # +nil+ if the given key is not found in the session.
  def [](key); end

  # Writes given value to given key of the session.
  def []=(key, value); end

  # Clears the session.
  def clear; end

  # Deletes given key from the session.
  def delete(key); end

  def destroy; end

  # Returns the nested value specified by the sequence of keys, returning
  # +nil+ if any intermediate step is +nil+.
  def dig(*keys); end

  def each(&block); end

  # @return [Boolean]
  def empty?; end

  # @return [Boolean]
  def exists?; end

  # Returns value of the given key from the session, or raises +KeyError+
  # if can't find the given key and no default value is set.
  # Returns default value if specified.
  #
  #   session.fetch(:foo)
  #   # => KeyError: key not found: "foo"
  #
  #   session.fetch(:foo, :bar)
  #   # => :bar
  #
  #   session.fetch(:foo) do
  #     :bar
  #   end
  #   # => :bar
  def fetch(key, default = T.unsafe(nil), &block); end

  # Returns true if the session has the given key or false.
  #
  # @return [Boolean]
  def has_key?(key); end

  def id; end

  # Returns true if the session has the given key or false.
  #
  # @return [Boolean]
  def include?(key); end

  def inspect; end

  # Returns true if the session has the given key or false.
  #
  # @return [Boolean]
  def key?(key); end

  # Returns keys of the session as Array.
  def keys; end

  # @return [Boolean]
  def loaded?; end

  def merge!(other); end
  def options; end

  # Returns the session as Hash.
  def to_h; end

  # Returns the session as Hash.
  def to_hash; end

  # Updates the session with given Hash.
  #
  #   session.to_hash
  #   # => {"session_id"=>"e29b9ea315edf98aad94cc78c34cc9b2"}
  #
  #   session.update({ "foo" => "bar" })
  #   # => {"session_id"=>"e29b9ea315edf98aad94cc78c34cc9b2", "foo" => "bar"}
  #
  #   session.to_hash
  #   # => {"session_id"=>"e29b9ea315edf98aad94cc78c34cc9b2", "foo" => "bar"}
  def update(hash); end

  # Returns values of the session as Array.
  def values; end

  private

  def load!; end
  def load_for_read!; end
  def load_for_write!; end

  class << self
    # Creates a session hash, merging the properties of the previous session if any.
    def create(store, req, default_options); end

    def find(req); end
    def set(req, session); end
  end
end

ActionDispatch::Request::Session::ENV_SESSION_KEY = T.let(T.unsafe(nil), String)
ActionDispatch::Request::Session::ENV_SESSION_OPTIONS_KEY = T.let(T.unsafe(nil), String)

class ActionDispatch::Request::Session::Options
  # @return [Options] a new instance of Options
  def initialize(by, default_options); end

  def [](key); end
  def []=(k, v); end
  def id(req); end
  def to_hash; end
  def values_at(*args); end

  class << self
    def find(req); end
    def set(req, options); end
  end
end

# Singleton object used to determine if an optional param wasn't specified.
ActionDispatch::Request::Session::Unspecified = T.let(T.unsafe(nil), Object)

class ActionDispatch::Request::Utils
  def perform_deep_munge; end
  def perform_deep_munge=(val); end

  class << self
    def check_param_encoding(params); end
    def each_param_value(params, &block); end
    def normalize_encode_params(params); end
    def perform_deep_munge; end
    def perform_deep_munge=(val); end
    def set_binary_encoding(request, params, controller, action); end
  end
end

class ActionDispatch::Request::Utils::CustomParamEncoder
  class << self
    def action_encoding_template(request, controller, action); end
    def encode(request, params, controller, action); end
  end
end

# Remove nils from the params hash.
class ActionDispatch::Request::Utils::NoNilParamEncoder < ::ActionDispatch::Request::Utils::ParamEncoder
  class << self
    def handle_array(params); end
  end
end

class ActionDispatch::Request::Utils::ParamEncoder
  class << self
    def handle_array(params); end

    # Convert nested Hash to HashWithIndifferentAccess.
    def normalize_encode_params(params); end
  end
end

class ActionDispatch::RequestEncoder
  # @return [RequestEncoder] a new instance of RequestEncoder
  def initialize(mime_name, param_encoder, response_parser); end

  def accept_header; end
  def content_type; end
  def encode_params(params); end

  # Returns the value of attribute response_parser.
  def response_parser; end

  class << self
    def encoder(name); end
    def parser(content_type); end
    def register_encoder(mime_name, param_encoder: T.unsafe(nil), response_parser: T.unsafe(nil)); end
  end
end

class ActionDispatch::RequestEncoder::IdentityEncoder
  def accept_header; end
  def content_type; end
  def encode_params(params); end
  def response_parser; end
end

# Makes a unique request id available to the +action_dispatch.request_id+ env variable (which is then accessible
# through <tt>ActionDispatch::Request#request_id</tt> or the alias <tt>ActionDispatch::Request#uuid</tt>) and sends
# the same id to the client via the X-Request-Id header.
#
# The unique request id is either based on the X-Request-Id header in the request, which would typically be generated
# by a firewall, load balancer, or the web server, or, if this header is not available, a random uuid. If the
# header is accepted from the outside world, we sanitize it to a max of 255 chars and alphanumeric and dashes only.
#
# The unique request id can be used to trace a request end-to-end and would typically end up being part of log files
# from multiple pieces of the stack.
class ActionDispatch::RequestId
  # @return [RequestId] a new instance of RequestId
  def initialize(app, header:); end

  def call(env); end

  private

  def internal_request_id; end
  def make_request_id(request_id); end
end

# Represents an HTTP response generated by a controller action. Use it to
# retrieve the current state of the response, or customize the response. It can
# either represent a real HTTP response (i.e. one that is meant to be sent
# back to the web browser) or a TestResponse (i.e. one that is generated
# from integration tests).
#
# \Response is mostly a Ruby on \Rails framework implementation detail, and
# should never be used directly in controllers. Controllers should use the
# methods defined in ActionController::Base instead. For example, if you want
# to set the HTTP response's content MIME type, then use
# ActionControllerBase#headers instead of Response#headers.
#
# Nevertheless, integration tests may want to inspect controller responses in
# more detail, and that's when \Response can be useful for application
# developers. Integration test methods such as
# ActionDispatch::Integration::Session#get and
# ActionDispatch::Integration::Session#post return objects of type
# TestResponse (which are of course also of type \Response).
#
# For example, the following demo integration test prints the body of the
# controller response to the console:
#
#  class DemoControllerTest < ActionDispatch::IntegrationTest
#    def test_print_root_path_to_console
#      get('/')
#      puts response.body
#    end
#  end
class ActionDispatch::Response
  include ::Rack::Response::Helpers
  include ::ActionDispatch::Http::FilterRedirect
  include ::ActionDispatch::Http::Cache::Response
  include ::MonitorMixin

  # @return [Response] a new instance of Response
  # @yield [_self]
  # @yieldparam _self [ActionDispatch::Response] the object that the method was called on
  def initialize(status = T.unsafe(nil), header = T.unsafe(nil), body = T.unsafe(nil)); end

  def [](*_arg0, &_arg1); end
  def []=(*_arg0, &_arg1); end

  # Aliasing these off because AD::Http::Cache::Response defines them.
  def _cache_control; end

  def _cache_control=(v); end
  def abort; end
  def await_commit; end
  def await_sent; end

  # Returns the content of the response as a string. This contains the contents
  # of any calls to <tt>render</tt>.
  def body; end

  # Allows you to manually set or override the response body.
  def body=(body); end

  def body_parts; end

  # The charset of the response. HTML wants to know the encoding of the
  # content you're giving them, so we need to send that along.
  def charset; end

  # Sets the HTTP character set. In case of +nil+ parameter
  # it sets the charset to +default_charset+.
  #
  #   response.charset = 'utf-16' # => 'utf-16'
  #   response.charset = nil      # => 'utf-8'
  def charset=(charset); end

  def close; end

  # Returns a string to ensure compatibility with <tt>Net::HTTPResponse</tt>.
  def code; end

  def commit!; end

  # @return [Boolean]
  def committed?; end

  # Content type of response.
  def content_type; end

  # Sets the HTTP response's content MIME type. For example, in the controller
  # you could write this:
  #
  #  response.content_type = "text/plain"
  #
  # If a character set has been defined for this response (see charset=) then
  # the character set information will also be included in the content type
  # information.
  def content_type=(content_type); end

  # Returns the response cookies, converted to a Hash of (name => value) pairs
  #
  #   assert_equal 'AuthorOfNewPage', r.cookies['author']
  def cookies; end

  def default_charset; end
  def default_charset=(val); end
  def default_headers; end
  def default_headers=(val); end
  def delete_header(key); end
  def each(&block); end
  def get_header(key); end

  # @return [Boolean]
  def has_header?(key); end

  # Get headers for this response.
  def header; end

  # Get headers for this response.
  def headers; end

  # Media type of response.
  def media_type; end

  # Returns the corresponding message for the current HTTP status code:
  #
  #   response.status = 200
  #   response.message # => "OK"
  #
  #   response.status = 404
  #   response.message # => "Not Found"
  def message; end

  # Turns the Response into a Rack-compatible array of the status, headers,
  # and body. Allows explicit splatting:
  #
  #   status, headers, body = *response
  def prepare!; end

  # The location header we'll be responding with.
  def redirect_url; end

  # The request that the response is responding to.
  def request; end

  # The request that the response is responding to.
  def request=(_arg0); end

  def reset_body!; end

  # The response code of the request.
  def response_code; end

  # Send the file stored at +path+ as the response body.
  def send_file(path); end

  def sending!; end

  # @return [Boolean]
  def sending?; end

  def sending_file=(v); end
  def sent!; end

  # @return [Boolean]
  def sent?; end

  def set_header(key, v); end

  # The HTTP status code.
  def status; end

  # Sets the HTTP status code.
  def status=(status); end

  # Returns the corresponding message for the current HTTP status code:
  #
  #   response.status = 200
  #   response.message # => "OK"
  #
  #   response.status = 404
  #   response.message # => "Not Found"
  def status_message; end

  # The underlying body, as a streamable object.
  def stream; end

  # Turns the Response into a Rack-compatible array of the status, headers,
  # and body. Allows explicit splatting:
  #
  #   status, headers, body = *response
  def to_a; end

  def write(string); end

  private

  def assign_default_content_type_and_charset!; end
  def before_committed; end
  def before_sending; end
  def build_buffer(response, body); end
  def handle_no_content!; end
  def munge_body_object(body); end
  def parse_content_type(content_type); end

  # Small internal convenience method to get the parsed version of the current
  # content type header.
  def parsed_content_type_header; end

  def rack_response(status, header); end
  def set_content_type(content_type, charset); end

  class << self
    def create(status = T.unsafe(nil), header = T.unsafe(nil), body = T.unsafe(nil), default_headers: T.unsafe(nil)); end
    def default_charset; end
    def default_charset=(val); end
    def default_headers; end
    def default_headers=(val); end
    def merge_default_headers(original, default); end
    def return_only_media_type_on_content_type; end
    def return_only_media_type_on_content_type=(*_arg0); end
  end
end

class ActionDispatch::Response::Buffer
  # @return [Buffer] a new instance of Buffer
  def initialize(response, buf); end

  def abort; end
  def body; end
  def close; end

  # @return [Boolean]
  def closed?; end

  def each(&block); end

  # @raise [IOError]
  def write(string); end

  private

  def each_chunk(&block); end
end

ActionDispatch::Response::CONTENT_TYPE = T.let(T.unsafe(nil), String)
ActionDispatch::Response::CONTENT_TYPE_PARSER = T.let(T.unsafe(nil), Regexp)

class ActionDispatch::Response::ContentTypeHeader < ::Struct
  # Returns the value of attribute charset
  #
  # @return [Object] the current value of charset
  def charset; end

  # Sets the attribute charset
  #
  # @param value [Object] the value to set the attribute charset to.
  # @return [Object] the newly set value
  def charset=(_); end

  # Returns the value of attribute mime_type
  #
  # @return [Object] the current value of mime_type
  def mime_type; end

  # Sets the attribute mime_type
  #
  # @param value [Object] the value to set the attribute mime_type to.
  # @return [Object] the newly set value
  def mime_type=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def members; end
    def new(*_arg0); end
  end
end

# Avoid having to pass an open file handle as the response body.
# Rack::Sendfile will usually intercept the response and uses
# the path directly, so there is no reason to open the file.
class ActionDispatch::Response::FileBody
  # @return [FileBody] a new instance of FileBody
  def initialize(path); end

  def body; end

  # Stream the file's contents if Rack::Sendfile isn't present.
  def each; end

  def to_path; end
end

class ActionDispatch::Response::Header
  # @return [Header] a new instance of Header
  def initialize(response, header); end

  def []=(k, v); end
  def merge(other); end
  def to_hash; end
end

ActionDispatch::Response::LOCATION = T.let(T.unsafe(nil), String)
ActionDispatch::Response::NO_CONTENT_CODES = T.let(T.unsafe(nil), Array)
ActionDispatch::Response::NullContentTypeHeader = T.let(T.unsafe(nil), ActionDispatch::Response::ContentTypeHeader)

class ActionDispatch::Response::RackBody
  # @return [RackBody] a new instance of RackBody
  def initialize(response); end

  def body; end
  def close; end
  def each(*args, &block); end

  # @return [Boolean]
  def respond_to?(method, include_private = T.unsafe(nil)); end

  def to_ary; end
  def to_path; end
end

ActionDispatch::Response::SET_COOKIE = T.let(T.unsafe(nil), String)

# The routing module provides URL rewriting in native Ruby. It's a way to
# redirect incoming requests to controllers and actions. This replaces
# mod_rewrite rules. Best of all, Rails' \Routing works with any web server.
# Routes are defined in <tt>config/routes.rb</tt>.
#
# Think of creating routes as drawing a map for your requests. The map tells
# them where to go based on some predefined pattern:
#
#   Rails.application.routes.draw do
#     Pattern 1 tells some request to go to one place
#     Pattern 2 tell them to go to another
#     ...
#   end
#
# The following symbols are special:
#
#   :controller maps to your controller name
#   :action     maps to an action with your controllers
#
# Other names simply map to a parameter as in the case of <tt>:id</tt>.
#
# == Resources
#
# Resource routing allows you to quickly declare all of the common routes
# for a given resourceful controller. Instead of declaring separate routes
# for your +index+, +show+, +new+, +edit+, +create+, +update+ and +destroy+
# actions, a resourceful route declares them in a single line of code:
#
#  resources :photos
#
# Sometimes, you have a resource that clients always look up without
# referencing an ID. A common example, /profile always shows the profile of
# the currently logged in user. In this case, you can use a singular resource
# to map /profile (rather than /profile/:id) to the show action.
#
#  resource :profile
#
# It's common to have resources that are logically children of other
# resources:
#
#   resources :magazines do
#     resources :ads
#   end
#
# You may wish to organize groups of controllers under a namespace. Most
# commonly, you might group a number of administrative controllers under
# an +admin+ namespace. You would place these controllers under the
# <tt>app/controllers/admin</tt> directory, and you can group them together
# in your router:
#
#   namespace "admin" do
#     resources :posts, :comments
#   end
#
# Alternatively, you can add prefixes to your path without using a separate
# directory by using +scope+. +scope+ takes additional options which
# apply to all enclosed routes.
#
#   scope path: "/cpanel", as: 'admin' do
#     resources :posts, :comments
#   end
#
# For more, see <tt>Routing::Mapper::Resources#resources</tt>,
# <tt>Routing::Mapper::Scoping#namespace</tt>, and
# <tt>Routing::Mapper::Scoping#scope</tt>.
#
# == Non-resourceful routes
#
# For routes that don't fit the <tt>resources</tt> mold, you can use the HTTP helper
# methods <tt>get</tt>, <tt>post</tt>, <tt>patch</tt>, <tt>put</tt> and <tt>delete</tt>.
#
#   get 'post/:id', to: 'posts#show'
#   post 'post/:id', to: 'posts#create_comment'
#
# Now, if you POST to <tt>/posts/:id</tt>, it will route to the <tt>create_comment</tt> action. A GET on the same
# URL will route to the <tt>show</tt> action.
#
# If your route needs to respond to more than one HTTP method (or all methods) then using the
# <tt>:via</tt> option on <tt>match</tt> is preferable.
#
#   match 'post/:id', to: 'posts#show', via: [:get, :post]
#
# == Named routes
#
# Routes can be named by passing an <tt>:as</tt> option,
# allowing for easy reference within your source as +name_of_route_url+
# for the full URL and +name_of_route_path+ for the URI path.
#
# Example:
#
#   # In config/routes.rb
#   get '/login', to: 'accounts#login', as: 'login'
#
#   # With render, redirect_to, tests, etc.
#   redirect_to login_url
#
# Arguments can be passed as well.
#
#   redirect_to show_item_path(id: 25)
#
# Use <tt>root</tt> as a shorthand to name a route for the root path "/".
#
#   # In config/routes.rb
#   root to: 'blogs#index'
#
#   # would recognize http://www.example.com/ as
#   params = { controller: 'blogs', action: 'index' }
#
#   # and provide these named routes
#   root_url   # => 'http://www.example.com/'
#   root_path  # => '/'
#
# Note: when using +controller+, the route is simply named after the
# method you call on the block parameter rather than map.
#
#   # In config/routes.rb
#   controller :blog do
#     get 'blog/show',    to: :list
#     get 'blog/delete',  to: :delete
#     get 'blog/edit',    to: :edit
#   end
#
#   # provides named routes for show, delete, and edit
#   link_to @article.title, blog_show_path(id: @article.id)
#
# == Pretty URLs
#
# Routes can generate pretty URLs. For example:
#
#   get '/articles/:year/:month/:day', to: 'articles#find_by_id', constraints: {
#     year:       /\d{4}/,
#     month:      /\d{1,2}/,
#     day:        /\d{1,2}/
#   }
#
# Using the route above, the URL "http://localhost:3000/articles/2005/11/06"
# maps to
#
#   params = {year: '2005', month: '11', day: '06'}
#
# == Regular Expressions and parameters
# You can specify a regular expression to define a format for a parameter.
#
#   controller 'geocode' do
#     get 'geocode/:postalcode', to: :show, constraints: {
#       postalcode: /\d{5}(-\d{4})?/
#     }
#   end
#
# Constraints can include the 'ignorecase' and 'extended syntax' regular
# expression modifiers:
#
#   controller 'geocode' do
#     get 'geocode/:postalcode', to: :show, constraints: {
#       postalcode: /hx\d\d\s\d[a-z]{2}/i
#     }
#   end
#
#   controller 'geocode' do
#     get 'geocode/:postalcode', to: :show, constraints: {
#       postalcode: /# Postalcode format
#          \d{5} #Prefix
#          (-\d{4})? #Suffix
#          /x
#     }
#   end
#
# Using the multiline modifier will raise an +ArgumentError+.
# Encoding regular expression modifiers are silently ignored. The
# match will always use the default encoding or ASCII.
#
# == External redirects
#
# You can redirect any path to another path using the redirect helper in your router:
#
#   get "/stories", to: redirect("/posts")
#
# == Unicode character routes
#
# You can specify unicode character routes in your router:
#
#   get "こんにちは", to: "welcome#index"
#
# == Routing to Rack Applications
#
# Instead of a String, like <tt>posts#index</tt>, which corresponds to the
# index action in the PostsController, you can specify any Rack application
# as the endpoint for a matcher:
#
#   get "/application.js", to: Sprockets
#
# == Reloading routes
#
# You can reload routes if you feel you must:
#
#   Rails.application.reload_routes!
#
# This will clear all named routes and reload config/routes.rb if the file has been modified from
# last load. To absolutely force reloading, use <tt>reload!</tt>.
#
# == Testing Routes
#
# The two main methods for testing your routes:
#
# === +assert_routing+
#
#   def test_movie_route_properly_splits
#     opts = {controller: "plugin", action: "checkout", id: "2"}
#     assert_routing "plugin/checkout/2", opts
#   end
#
# +assert_routing+ lets you test whether or not the route properly resolves into options.
#
# === +assert_recognizes+
#
#   def test_route_has_options
#     opts = {controller: "plugin", action: "show", id: "12"}
#     assert_recognizes opts, "/plugins/show/12"
#   end
#
# Note the subtle difference between the two: +assert_routing+ tests that
# a URL fits options while +assert_recognizes+ tests that a URL
# breaks into parameters properly.
#
# In tests you can simply pass the URL or named route to +get+ or +post+.
#
#   def send_to_jail
#     get '/jail'
#     assert_response :success
#   end
#
#   def goes_to_login
#     get login_url
#     #...
#   end
#
# == View a list of all your routes
#
#   rails routes
#
# Target a specific controller with <tt>-c</tt>, or grep routes
# using <tt>-g</tt>. Useful in conjunction with <tt>--expanded</tt>
# which displays routes vertically.
module ActionDispatch::Routing
  extend ::ActiveSupport::Autoload
end

module ActionDispatch::Routing::ConsoleFormatter; end

class ActionDispatch::Routing::ConsoleFormatter::Base
  # @return [Base] a new instance of Base
  def initialize; end

  def header(routes); end
  def no_routes(routes, filter); end
  def result; end
  def section(routes); end
  def section_title(title); end
end

class ActionDispatch::Routing::ConsoleFormatter::Expanded < ::ActionDispatch::Routing::ConsoleFormatter::Base
  # @return [Expanded] a new instance of Expanded
  def initialize(width: T.unsafe(nil)); end

  def section(routes); end
  def section_title(title); end

  private

  def draw_expanded_section(routes); end
  def route_header(index:); end
end

class ActionDispatch::Routing::ConsoleFormatter::Sheet < ::ActionDispatch::Routing::ConsoleFormatter::Base
  def header(routes); end
  def section(routes); end
  def section_title(title); end

  private

  def draw_header(routes); end
  def draw_section(routes); end
  def widths(routes); end
end

class ActionDispatch::Routing::Endpoint
  def app; end

  # @return [Boolean]
  def dispatcher?; end

  # @return [Boolean]
  def engine?; end

  # @return [Boolean]
  def matches?(req); end

  def rack_app; end

  # @return [Boolean]
  def redirect?; end
end

ActionDispatch::Routing::HTTP_METHODS = T.let(T.unsafe(nil), Array)

class ActionDispatch::Routing::HtmlTableFormatter
  # @return [HtmlTableFormatter] a new instance of HtmlTableFormatter
  def initialize(view); end

  # The header is part of the HTML page, so we don't construct it here.
  def header(routes); end

  def no_routes(*_arg0); end
  def result; end
  def section(routes); end
  def section_title(title); end
end

class ActionDispatch::Routing::Mapper
  include ::ActionDispatch::Routing::Mapper::Base
  include ::ActionDispatch::Routing::Mapper::HttpHelpers
  include ::ActionDispatch::Routing::Redirection
  include ::ActionDispatch::Routing::Mapper::Scoping
  include ::ActionDispatch::Routing::Mapper::Concerns
  include ::ActionDispatch::Routing::Mapper::Resources
  include ::ActionDispatch::Routing::Mapper::CustomUrls

  # @return [Mapper] a new instance of Mapper
  def initialize(set); end

  class << self
    def normalize_name(name); end

    # Invokes Journey::Router::Utils.normalize_path, then ensures that
    # /(:locale) becomes (/:locale). Except for root cases, where the
    # former is the correct one.
    def normalize_path(path); end
  end
end

module ActionDispatch::Routing::Mapper::Base
  def default_url_options(options); end
  def default_url_options=(options); end

  # Query if the following named route was already defined.
  #
  # @return [Boolean]
  def has_named_route?(name); end

  # Matches a URL pattern to one or more routes.
  #
  # You should not use the +match+ method in your router
  # without specifying an HTTP method.
  #
  # If you want to expose your action to both GET and POST, use:
  #
  #   # sets :controller, :action and :id in params
  #   match ':controller/:action/:id', via: [:get, :post]
  #
  # Note that +:controller+, +:action+ and +:id+ are interpreted as URL
  # query parameters and thus available through +params+ in an action.
  #
  # If you want to expose your action to GET, use +get+ in the router:
  #
  # Instead of:
  #
  #   match ":controller/:action/:id"
  #
  # Do:
  #
  #   get ":controller/:action/:id"
  #
  # Two of these symbols are special, +:controller+ maps to the controller
  # and +:action+ to the controller's action. A pattern can also map
  # wildcard segments (globs) to params:
  #
  #   get 'songs/*category/:title', to: 'songs#show'
  #
  #   # 'songs/rock/classic/stairway-to-heaven' sets
  #   #  params[:category] = 'rock/classic'
  #   #  params[:title] = 'stairway-to-heaven'
  #
  # To match a wildcard parameter, it must have a name assigned to it.
  # Without a variable name to attach the glob parameter to, the route
  # can't be parsed.
  #
  # When a pattern points to an internal route, the route's +:action+ and
  # +:controller+ should be set in options or hash shorthand. Examples:
  #
  #   match 'photos/:id' => 'photos#show', via: :get
  #   match 'photos/:id', to: 'photos#show', via: :get
  #   match 'photos/:id', controller: 'photos', action: 'show', via: :get
  #
  # A pattern can also point to a +Rack+ endpoint i.e. anything that
  # responds to +call+:
  #
  #   match 'photos/:id', to: -> (hash) { [200, {}, ["Coming soon"]] }, via: :get
  #   match 'photos/:id', to: PhotoRackApp, via: :get
  #   # Yes, controller actions are just rack endpoints
  #   match 'photos/:id', to: PhotosController.action(:show), via: :get
  #
  # Because requesting various HTTP verbs with a single action has security
  # implications, you must either specify the actions in
  # the via options or use one of the HttpHelpers[rdoc-ref:HttpHelpers]
  # instead +match+
  #
  # === Options
  #
  # Any options not seen here are passed on as params with the URL.
  #
  # [:controller]
  #   The route's controller.
  #
  # [:action]
  #   The route's action.
  #
  # [:param]
  #   Overrides the default resource identifier +:id+ (name of the
  #   dynamic segment used to generate the routes).
  #   You can access that segment from your controller using
  #   <tt>params[<:param>]</tt>.
  #   In your router:
  #
  #      resources :users, param: :name
  #
  #   The +users+ resource here will have the following routes generated for it:
  #
  #      GET       /users(.:format)
  #      POST      /users(.:format)
  #      GET       /users/new(.:format)
  #      GET       /users/:name/edit(.:format)
  #      GET       /users/:name(.:format)
  #      PATCH/PUT /users/:name(.:format)
  #      DELETE    /users/:name(.:format)
  #
  #   You can override <tt>ActiveRecord::Base#to_param</tt> of a related
  #   model to construct a URL:
  #
  #      class User < ActiveRecord::Base
  #        def to_param
  #          name
  #        end
  #      end
  #
  #      user = User.find_by(name: 'Phusion')
  #      user_path(user)  # => "/users/Phusion"
  #
  # [:path]
  #   The path prefix for the routes.
  #
  # [:module]
  #   The namespace for :controller.
  #
  #     match 'path', to: 'c#a', module: 'sekret', controller: 'posts', via: :get
  #     # => Sekret::PostsController
  #
  #   See <tt>Scoping#namespace</tt> for its scope equivalent.
  #
  # [:as]
  #   The name used to generate routing helpers.
  #
  # [:via]
  #   Allowed HTTP verb(s) for route.
  #
  #      match 'path', to: 'c#a', via: :get
  #      match 'path', to: 'c#a', via: [:get, :post]
  #      match 'path', to: 'c#a', via: :all
  #
  # [:to]
  #   Points to a +Rack+ endpoint. Can be an object that responds to
  #   +call+ or a string representing a controller's action.
  #
  #      match 'path', to: 'controller#action', via: :get
  #      match 'path', to: -> (env) { [200, {}, ["Success!"]] }, via: :get
  #      match 'path', to: RackApp, via: :get
  #
  # [:on]
  #   Shorthand for wrapping routes in a specific RESTful context. Valid
  #   values are +:member+, +:collection+, and +:new+. Only use within
  #   <tt>resource(s)</tt> block. For example:
  #
  #      resource :bar do
  #        match 'foo', to: 'c#a', on: :member, via: [:get, :post]
  #      end
  #
  #   Is equivalent to:
  #
  #      resource :bar do
  #        member do
  #          match 'foo', to: 'c#a', via: [:get, :post]
  #        end
  #      end
  #
  # [:constraints]
  #   Constrains parameters with a hash of regular expressions
  #   or an object that responds to <tt>matches?</tt>. In addition, constraints
  #   other than path can also be specified with any object
  #   that responds to <tt>===</tt> (e.g. String, Array, Range, etc.).
  #
  #     match 'path/:id', constraints: { id: /[A-Z]\d{5}/ }, via: :get
  #
  #     match 'json_only', constraints: { format: 'json' }, via: :get
  #
  #     class PermitList
  #       def matches?(request) request.remote_ip == '1.2.3.4' end
  #     end
  #     match 'path', to: 'c#a', constraints: PermitList.new, via: :get
  #
  #   See <tt>Scoping#constraints</tt> for more examples with its scope
  #   equivalent.
  #
  # [:defaults]
  #   Sets defaults for parameters
  #
  #     # Sets params[:format] to 'jpg' by default
  #     match 'path', to: 'c#a', defaults: { format: 'jpg' }, via: :get
  #
  #   See <tt>Scoping#defaults</tt> for its scope equivalent.
  #
  # [:anchor]
  #   Boolean to anchor a <tt>match</tt> pattern. Default is true. When set to
  #   false, the pattern matches any request prefixed with the given path.
  #
  #     # Matches any request starting with 'path'
  #     match 'path', to: 'c#a', anchor: false, via: :get
  #
  # [:format]
  #   Allows you to specify the default value for optional +format+
  #   segment or disable it by supplying +false+.
  def match(path, options = T.unsafe(nil)); end

  # Mount a Rack-based application to be used within the application.
  #
  #   mount SomeRackApp, at: "some_route"
  #
  # Alternatively:
  #
  #   mount(SomeRackApp => "some_route")
  #
  # For options, see +match+, as +mount+ uses it internally.
  #
  # All mounted applications come with routing helpers to access them.
  # These are named after the class specified, so for the above example
  # the helper is either +some_rack_app_path+ or +some_rack_app_url+.
  # To customize this helper's name, use the +:as+ option:
  #
  #   mount(SomeRackApp => "some_route", as: "exciting")
  #
  # This will generate the +exciting_path+ and +exciting_url+ helpers
  # which can be used to navigate to this mounted app.
  #
  # @raise [ArgumentError]
  def mount(app, options = T.unsafe(nil)); end

  def with_default_scope(scope, &block); end

  private

  def app_name(app, rails_app); end
  def define_generate_prefix(app, name); end

  # @return [Boolean]
  def rails_app?(app); end
end

# Routing Concerns allow you to declare common routes that can be reused
# inside others resources and routes.
#
#   concern :commentable do
#     resources :comments
#   end
#
#   concern :image_attachable do
#     resources :images, only: :index
#   end
#
# These concerns are used in Resources routing:
#
#   resources :messages, concerns: [:commentable, :image_attachable]
#
# or in a scope or namespace:
#
#   namespace :posts do
#     concerns :commentable
#   end
module ActionDispatch::Routing::Mapper::Concerns
  # Define a routing concern using a name.
  #
  # Concerns may be defined inline, using a block, or handled by
  # another object, by passing that object as the second parameter.
  #
  # The concern object, if supplied, should respond to <tt>call</tt>,
  # which will receive two parameters:
  #
  #   * The current mapper
  #   * A hash of options which the concern object may use
  #
  # Options may also be used by concerns defined in a block by accepting
  # a block parameter. So, using a block, you might do something as
  # simple as limit the actions available on certain resources, passing
  # standard resource options through the concern:
  #
  #   concern :commentable do |options|
  #     resources :comments, options
  #   end
  #
  #   resources :posts, concerns: :commentable
  #   resources :archived_posts do
  #     # Don't allow comments on archived posts
  #     concerns :commentable, only: [:index, :show]
  #   end
  #
  # Or, using a callable object, you might implement something more
  # specific to your application, which would be out of place in your
  # routes file.
  #
  #   # purchasable.rb
  #   class Purchasable
  #     def initialize(defaults = {})
  #       @defaults = defaults
  #     end
  #
  #     def call(mapper, options = {})
  #       options = @defaults.merge(options)
  #       mapper.resources :purchases
  #       mapper.resources :receipts
  #       mapper.resources :returns if options[:returnable]
  #     end
  #   end
  #
  #   # routes.rb
  #   concern :purchasable, Purchasable.new(returnable: true)
  #
  #   resources :toys, concerns: :purchasable
  #   resources :electronics, concerns: :purchasable
  #   resources :pets do
  #     concerns :purchasable, returnable: false
  #   end
  #
  # Any routing helpers can be used inside a concern. If using a
  # callable, they're accessible from the Mapper that's passed to
  # <tt>call</tt>.
  def concern(name, callable = T.unsafe(nil), &block); end

  # Use the named concerns
  #
  #   resources :posts do
  #     concerns :commentable
  #   end
  #
  # Concerns also work in any routes helper that you want to use:
  #
  #   namespace :posts do
  #     concerns :commentable
  #   end
  def concerns(*args); end
end

class ActionDispatch::Routing::Mapper::Constraints < ::ActionDispatch::Routing::Endpoint
  # @return [Constraints] a new instance of Constraints
  def initialize(app, constraints, strategy); end

  # Returns the value of attribute app.
  def app; end

  # Returns the value of attribute constraints.
  def constraints; end

  # @return [Boolean]
  def dispatcher?; end

  # @return [Boolean]
  def matches?(req); end

  def serve(req); end

  private

  def constraint_args(constraint, request); end
end

ActionDispatch::Routing::Mapper::Constraints::CALL = T.let(T.unsafe(nil), Proc)
ActionDispatch::Routing::Mapper::Constraints::SERVE = T.let(T.unsafe(nil), Proc)

module ActionDispatch::Routing::Mapper::CustomUrls
  # Define custom URL helpers that will be added to the application's
  # routes. This allows you to override and/or replace the default behavior
  # of routing helpers, e.g:
  #
  #   direct :homepage do
  #     "https://rubyonrails.org"
  #   end
  #
  #   direct :commentable do |model|
  #     [ model, anchor: model.dom_id ]
  #   end
  #
  #   direct :main do
  #     { controller: "pages", action: "index", subdomain: "www" }
  #   end
  #
  # The return value from the block passed to +direct+ must be a valid set of
  # arguments for +url_for+ which will actually build the URL string. This can
  # be one of the following:
  #
  # * A string, which is treated as a generated URL
  # * A hash, e.g. <tt>{ controller: "pages", action: "index" }</tt>
  # * An array, which is passed to +polymorphic_url+
  # * An Active Model instance
  # * An Active Model class
  #
  # NOTE: Other URL helpers can be called in the block but be careful not to invoke
  # your custom URL helper again otherwise it will result in a stack overflow error.
  #
  # You can also specify default options that will be passed through to
  # your URL helper definition, e.g:
  #
  #   direct :browse, page: 1, size: 10 do |options|
  #     [ :products, options.merge(params.permit(:page, :size).to_h.symbolize_keys) ]
  #   end
  #
  # In this instance the +params+ object comes from the context in which the
  # block is executed, e.g. generating a URL inside a controller action or a view.
  # If the block is executed where there isn't a +params+ object such as this:
  #
  #   Rails.application.routes.url_helpers.browse_path
  #
  # then it will raise a +NameError+. Because of this you need to be aware of the
  # context in which you will use your custom URL helper when defining it.
  #
  # NOTE: The +direct+ method can't be used inside of a scope block such as
  # +namespace+ or +scope+ and will raise an error if it detects that it is.
  def direct(name, options = T.unsafe(nil), &block); end

  # Define custom polymorphic mappings of models to URLs. This alters the
  # behavior of +polymorphic_url+ and consequently the behavior of
  # +link_to+ and +form_for+ when passed a model instance, e.g:
  #
  #   resource :basket
  #
  #   resolve "Basket" do
  #     [:basket]
  #   end
  #
  # This will now generate "/basket" when a +Basket+ instance is passed to
  # +link_to+ or +form_for+ instead of the standard "/baskets/:id".
  #
  # NOTE: This custom behavior only applies to simple polymorphic URLs where
  # a single model instance is passed and not more complicated forms, e.g:
  #
  #   # config/routes.rb
  #   resource :profile
  #   namespace :admin do
  #     resources :users
  #   end
  #
  #   resolve("User") { [:profile] }
  #
  #   # app/views/application/_menu.html.erb
  #   link_to "Profile", @current_user
  #   link_to "Profile", [:admin, @current_user]
  #
  # The first +link_to+ will generate "/profile" but the second will generate
  # the standard polymorphic URL of "/admin/users/1".
  #
  # You can pass options to a polymorphic mapping - the arity for the block
  # needs to be two as the instance is passed as the first argument, e.g:
  #
  #   resolve "Basket", anchor: "items" do |basket, options|
  #     [:basket, options]
  #   end
  #
  # This generates the URL "/basket#items" because when the last item in an
  # array passed to +polymorphic_url+ is a hash then it's treated as options
  # to the URL helper that gets called.
  #
  # NOTE: The +resolve+ method can't be used inside of a scope block such as
  # +namespace+ or +scope+ and will raise an error if it detects that it is.
  def resolve(*args, &block); end
end

module ActionDispatch::Routing::Mapper::HttpHelpers
  # Define a route that only recognizes HTTP DELETE.
  # For supported arguments, see match[rdoc-ref:Base#match]
  #
  #   delete 'broccoli', to: 'food#broccoli'
  def delete(*args, &block); end

  # Define a route that only recognizes HTTP GET.
  # For supported arguments, see match[rdoc-ref:Base#match]
  #
  #   get 'bacon', to: 'food#bacon'
  def get(*args, &block); end

  # Define a route that only recognizes HTTP OPTIONS.
  # For supported arguments, see match[rdoc-ref:Base#match]
  #
  #   options 'carrots', to: 'food#carrots'
  def options(*args, &block); end

  # Define a route that only recognizes HTTP PATCH.
  # For supported arguments, see match[rdoc-ref:Base#match]
  #
  #   patch 'bacon', to: 'food#bacon'
  def patch(*args, &block); end

  # Define a route that only recognizes HTTP POST.
  # For supported arguments, see match[rdoc-ref:Base#match]
  #
  #   post 'bacon', to: 'food#bacon'
  def post(*args, &block); end

  # Define a route that only recognizes HTTP PUT.
  # For supported arguments, see match[rdoc-ref:Base#match]
  #
  #   put 'bacon', to: 'food#bacon'
  def put(*args, &block); end

  private

  def map_method(method, args, &block); end
end

class ActionDispatch::Routing::Mapper::Mapping
  # @return [Mapping] a new instance of Mapping
  def initialize(set:, ast:, controller:, default_action:, to:, formatted:, via:, options_constraints:, anchor:, scope_params:, options:); end

  def application; end

  # Returns the value of attribute ast.
  def ast; end

  def conditions; end

  # Returns the value of attribute default_action.
  def default_action; end

  # Returns the value of attribute default_controller.
  def default_controller; end

  # Returns the value of attribute defaults.
  def defaults; end

  def make_route(name, precedence); end
  def path; end

  # Returns the value of attribute required_defaults.
  def required_defaults; end

  # Returns the value of attribute requirements.
  def requirements; end

  # Returns the value of attribute scope_options.
  def scope_options; end

  # Returns the value of attribute to.
  def to; end

  private

  def add_controller_module(controller, modyoule); end

  # Find all the symbol nodes that are adjacent to literal nodes and alter
  # the regexp so that Journey will partition them into custom routes.
  def alter_regex_for_custom_routes(node); end

  def app(blocks); end
  def blocks(callable_constraint); end
  def build_conditions(current_conditions, request_class); end
  def check_controller_and_action(path_params, controller, action); end
  def check_part(name, part, path_params, hash); end
  def constraints(options, path_params); end
  def dispatcher(raise_on_name_error); end
  def intern(object); end
  def normalize_defaults(options); end
  def normalize_format(formatted); end
  def normalize_options!(options, path_params, modyoule); end
  def request_method; end
  def split_constraints(path_params, constraints); end
  def split_to(to); end
  def translate_controller(controller); end
  def verify_regexp_requirements(requirements); end

  class << self
    def build(scope, set, ast, controller, default_action, to, via, formatted, options_constraints, anchor, options); end
    def check_via(via); end
    def normalize_path(path, format); end

    # @return [Boolean]
    def optional_format?(path, format); end
  end
end

ActionDispatch::Routing::Mapper::Mapping::ANCHOR_CHARACTERS_REGEX = T.let(T.unsafe(nil), Regexp)
ActionDispatch::Routing::Mapper::Mapping::JOINED_SEPARATORS = T.let(T.unsafe(nil), String)
ActionDispatch::Routing::Mapper::Mapping::OPTIONAL_FORMAT_REGEX = T.let(T.unsafe(nil), Regexp)

# Resource routing allows you to quickly declare all of the common routes
# for a given resourceful controller. Instead of declaring separate routes
# for your +index+, +show+, +new+, +edit+, +create+, +update+ and +destroy+
# actions, a resourceful route declares them in a single line of code:
#
#  resources :photos
#
# Sometimes, you have a resource that clients always look up without
# referencing an ID. A common example, /profile always shows the profile of
# the currently logged in user. In this case, you can use a singular resource
# to map /profile (rather than /profile/:id) to the show action.
#
#  resource :profile
#
# It's common to have resources that are logically children of other
# resources:
#
#   resources :magazines do
#     resources :ads
#   end
#
# You may wish to organize groups of controllers under a namespace. Most
# commonly, you might group a number of administrative controllers under
# an +admin+ namespace. You would place these controllers under the
# <tt>app/controllers/admin</tt> directory, and you can group them together
# in your router:
#
#   namespace "admin" do
#     resources :posts, :comments
#   end
#
# By default the +:id+ parameter doesn't accept dots. If you need to
# use dots as part of the +:id+ parameter add a constraint which
# overrides this restriction, e.g:
#
#   resources :articles, id: /[^\/]+/
#
# This allows any character other than a slash as part of your +:id+.
module ActionDispatch::Routing::Mapper::Resources
  # To add a route to the collection:
  #
  #   resources :photos do
  #     collection do
  #       get 'search'
  #     end
  #   end
  #
  # This will enable Rails to recognize paths such as <tt>/photos/search</tt>
  # with GET, and route to the search action of +PhotosController+. It will also
  # create the <tt>search_photos_url</tt> and <tt>search_photos_path</tt>
  # route helpers.
  def collection; end

  def draw(name); end

  # Matches a URL pattern to one or more routes.
  # For more information, see match[rdoc-ref:Base#match].
  #
  #   match 'path' => 'controller#action', via: :patch
  #   match 'path', to: 'controller#action', via: :post
  #   match 'path', 'otherpath', on: :member, via: :get
  def match(path, *rest, &block); end

  # To add a member route, add a member block into the resource block:
  #
  #   resources :photos do
  #     member do
  #       get 'preview'
  #     end
  #   end
  #
  # This will recognize <tt>/photos/1/preview</tt> with GET, and route to the
  # preview action of +PhotosController+. It will also create the
  # <tt>preview_photo_url</tt> and <tt>preview_photo_path</tt> helpers.
  def member; end

  # See ActionDispatch::Routing::Mapper::Scoping#namespace.
  def namespace(path, options = T.unsafe(nil)); end

  def nested; end
  def new; end

  # Sometimes, you have a resource that clients always look up without
  # referencing an ID. A common example, /profile always shows the
  # profile of the currently logged in user. In this case, you can use
  # a singular resource to map /profile (rather than /profile/:id) to
  # the show action:
  #
  #   resource :profile
  #
  # This creates six different routes in your application, all mapping to
  # the +Profiles+ controller (note that the controller is named after
  # the plural):
  #
  #   GET       /profile/new
  #   GET       /profile
  #   GET       /profile/edit
  #   PATCH/PUT /profile
  #   DELETE    /profile
  #   POST      /profile
  #
  # === Options
  # Takes same options as resources[rdoc-ref:#resources]
  def resource(*resources, &block); end

  # In Rails, a resourceful route provides a mapping between HTTP verbs
  # and URLs and controller actions. By convention, each action also maps
  # to particular CRUD operations in a database. A single entry in the
  # routing file, such as
  #
  #   resources :photos
  #
  # creates seven different routes in your application, all mapping to
  # the +Photos+ controller:
  #
  #   GET       /photos
  #   GET       /photos/new
  #   POST      /photos
  #   GET       /photos/:id
  #   GET       /photos/:id/edit
  #   PATCH/PUT /photos/:id
  #   DELETE    /photos/:id
  #
  # Resources can also be nested infinitely by using this block syntax:
  #
  #   resources :photos do
  #     resources :comments
  #   end
  #
  # This generates the following comments routes:
  #
  #   GET       /photos/:photo_id/comments
  #   GET       /photos/:photo_id/comments/new
  #   POST      /photos/:photo_id/comments
  #   GET       /photos/:photo_id/comments/:id
  #   GET       /photos/:photo_id/comments/:id/edit
  #   PATCH/PUT /photos/:photo_id/comments/:id
  #   DELETE    /photos/:photo_id/comments/:id
  #
  # === Options
  # Takes same options as match[rdoc-ref:Base#match] as well as:
  #
  # [:path_names]
  #   Allows you to change the segment component of the +edit+ and +new+ actions.
  #   Actions not specified are not changed.
  #
  #     resources :posts, path_names: { new: "brand_new" }
  #
  #   The above example will now change /posts/new to /posts/brand_new.
  #
  # [:path]
  #   Allows you to change the path prefix for the resource.
  #
  #     resources :posts, path: 'postings'
  #
  #   The resource and all segments will now route to /postings instead of /posts.
  #
  # [:only]
  #   Only generate routes for the given actions.
  #
  #     resources :cows, only: :show
  #     resources :cows, only: [:show, :index]
  #
  # [:except]
  #   Generate all routes except for the given actions.
  #
  #     resources :cows, except: :show
  #     resources :cows, except: [:show, :index]
  #
  # [:shallow]
  #   Generates shallow routes for nested resource(s). When placed on a parent resource,
  #   generates shallow routes for all nested resources.
  #
  #     resources :posts, shallow: true do
  #       resources :comments
  #     end
  #
  #   Is the same as:
  #
  #     resources :posts do
  #       resources :comments, except: [:show, :edit, :update, :destroy]
  #     end
  #     resources :comments, only: [:show, :edit, :update, :destroy]
  #
  #   This allows URLs for resources that otherwise would be deeply nested such
  #   as a comment on a blog post like <tt>/posts/a-long-permalink/comments/1234</tt>
  #   to be shortened to just <tt>/comments/1234</tt>.
  #
  #   Set <tt>shallow: false</tt> on a child resource to ignore a parent's shallow parameter.
  #
  # [:shallow_path]
  #   Prefixes nested shallow routes with the specified path.
  #
  #     scope shallow_path: "sekret" do
  #       resources :posts do
  #         resources :comments, shallow: true
  #       end
  #     end
  #
  #   The +comments+ resource here will have the following routes generated for it:
  #
  #     post_comments    GET       /posts/:post_id/comments(.:format)
  #     post_comments    POST      /posts/:post_id/comments(.:format)
  #     new_post_comment GET       /posts/:post_id/comments/new(.:format)
  #     edit_comment     GET       /sekret/comments/:id/edit(.:format)
  #     comment          GET       /sekret/comments/:id(.:format)
  #     comment          PATCH/PUT /sekret/comments/:id(.:format)
  #     comment          DELETE    /sekret/comments/:id(.:format)
  #
  # [:shallow_prefix]
  #   Prefixes nested shallow route names with specified prefix.
  #
  #     scope shallow_prefix: "sekret" do
  #       resources :posts do
  #         resources :comments, shallow: true
  #       end
  #     end
  #
  #   The +comments+ resource here will have the following routes generated for it:
  #
  #     post_comments           GET       /posts/:post_id/comments(.:format)
  #     post_comments           POST      /posts/:post_id/comments(.:format)
  #     new_post_comment        GET       /posts/:post_id/comments/new(.:format)
  #     edit_sekret_comment     GET       /comments/:id/edit(.:format)
  #     sekret_comment          GET       /comments/:id(.:format)
  #     sekret_comment          PATCH/PUT /comments/:id(.:format)
  #     sekret_comment          DELETE    /comments/:id(.:format)
  #
  # [:format]
  #   Allows you to specify the default value for optional +format+
  #   segment or disable it by supplying +false+.
  #
  # [:param]
  #   Allows you to override the default param name of +:id+ in the URL.
  #
  # === Examples
  #
  #   # routes call <tt>Admin::PostsController</tt>
  #   resources :posts, module: "admin"
  #
  #   # resource actions are at /admin/posts.
  #   resources :posts, path: "admin/posts"
  def resources(*resources, &block); end

  def resources_path_names(options); end

  # You can specify what Rails should route "/" to with the root method:
  #
  #   root to: 'pages#main'
  #
  # For options, see +match+, as +root+ uses it internally.
  #
  # You can also pass a string which will expand
  #
  #   root 'pages#main'
  #
  # You should put the root route at the top of <tt>config/routes.rb</tt>,
  # because this means it will be matched first. As this is the most popular route
  # of most Rails applications, this is beneficial.
  def root(path, options = T.unsafe(nil)); end

  def shallow; end

  # @return [Boolean]
  def shallow?; end

  private

  # @return [Boolean]
  def action_options?(options); end

  def action_path(name); end

  # @raise [ArgumentError]
  def add_route(action, controller, options, _path, to, via, formatted, anchor, options_constraints); end

  # @return [Boolean]
  def api_only?; end

  def apply_action_options(options); end
  def apply_common_behavior_for(method, resources, options, &block); end

  # @return [Boolean]
  def canonical_action?(action); end

  def decomposed_match(path, controller, options, _path, to, via, formatted, anchor, options_constraints); end
  def get_to_from_path(path, to, action); end
  def map_match(paths, options); end
  def match_root_route(options); end
  def name_for_action(as, action); end
  def nested_options; end

  # @return [Boolean]
  def nested_scope?; end

  def param_constraint; end

  # @return [Boolean]
  def param_constraint?; end

  def parent_resource; end
  def path_for_action(action, path); end
  def path_scope(path); end
  def prefix_name_for_action(as, action); end

  # @return [Boolean]
  def resource_method_scope?; end

  def resource_scope(resource); end

  # @return [Boolean]
  def resource_scope?; end

  def scope_action_options; end
  def set_member_mappings_for_resource; end
  def shallow_nesting_depth; end
  def shallow_scope; end

  # @return [Boolean]
  def using_match_shorthand?(path); end

  def with_scope_level(kind); end
end

ActionDispatch::Routing::Mapper::Resources::CANONICAL_ACTIONS = T.let(T.unsafe(nil), Array)
ActionDispatch::Routing::Mapper::Resources::RESOURCE_OPTIONS = T.let(T.unsafe(nil), Array)

class ActionDispatch::Routing::Mapper::Resources::Resource
  # @return [Resource] a new instance of Resource
  def initialize(entities, api_only, shallow, options = T.unsafe(nil)); end

  def actions; end
  def available_actions; end

  # Checks for uncountable plurals, and appends "_index" if the plural
  # and singular form are the same.
  def collection_name; end

  # Returns the value of attribute path.
  def collection_scope; end

  # Returns the value of attribute controller.
  def controller; end

  def default_actions; end
  def member_name; end
  def member_scope; end
  def name; end
  def nested_param; end
  def nested_scope; end
  def new_scope(new_path); end

  # Returns the value of attribute param.
  def param; end

  # Returns the value of attribute path.
  def path; end

  def plural; end
  def resource_scope; end

  # @return [Boolean]
  def shallow?; end

  def shallow_scope; end

  # @return [Boolean]
  def singleton?; end

  def singular; end
end

class ActionDispatch::Routing::Mapper::Resources::SingletonResource < ::ActionDispatch::Routing::Mapper::Resources::Resource
  # @return [SingletonResource] a new instance of SingletonResource
  def initialize(entities, api_only, shallow, options); end

  def collection_name; end
  def default_actions; end
  def member_name; end
  def member_scope; end
  def nested_scope; end
  def plural; end

  # @return [Boolean]
  def singleton?; end

  def singular; end
end

# CANONICAL_ACTIONS holds all actions that does not need a prefix or
# a path appended since they fit properly in their scope level.
ActionDispatch::Routing::Mapper::Resources::VALID_ON_OPTIONS = T.let(T.unsafe(nil), Array)

class ActionDispatch::Routing::Mapper::Scope
  include ::Enumerable

  # @return [Scope] a new instance of Scope
  def initialize(hash, parent = T.unsafe(nil), scope_level = T.unsafe(nil)); end

  def [](key); end
  def action_name(name_prefix, prefix, collection_name, member_name); end
  def each; end
  def frame; end

  # @return [Boolean]
  def nested?; end

  def new(hash); end
  def new_level(level); end

  # @return [Boolean]
  def null?; end

  def options; end

  # Returns the value of attribute parent.
  def parent; end

  # @return [Boolean]
  def resource_method_scope?; end

  # @return [Boolean]
  def resource_scope?; end

  # @return [Boolean]
  def resources?; end

  # @return [Boolean]
  def root?; end

  # Returns the value of attribute scope_level.
  def scope_level; end
end

ActionDispatch::Routing::Mapper::Scope::NULL = T.let(T.unsafe(nil), ActionDispatch::Routing::Mapper::Scope)
ActionDispatch::Routing::Mapper::Scope::OPTIONS = T.let(T.unsafe(nil), Array)
ActionDispatch::Routing::Mapper::Scope::RESOURCE_METHOD_SCOPES = T.let(T.unsafe(nil), Array)
ActionDispatch::Routing::Mapper::Scope::RESOURCE_SCOPES = T.let(T.unsafe(nil), Array)

# You may wish to organize groups of controllers under a namespace.
# Most commonly, you might group a number of administrative controllers
# under an +admin+ namespace. You would place these controllers under
# the <tt>app/controllers/admin</tt> directory, and you can group them
# together in your router:
#
#   namespace "admin" do
#     resources :posts, :comments
#   end
#
# This will create a number of routes for each of the posts and comments
# controller. For <tt>Admin::PostsController</tt>, Rails will create:
#
#   GET       /admin/posts
#   GET       /admin/posts/new
#   POST      /admin/posts
#   GET       /admin/posts/1
#   GET       /admin/posts/1/edit
#   PATCH/PUT /admin/posts/1
#   DELETE    /admin/posts/1
#
# If you want to route /posts (without the prefix /admin) to
# <tt>Admin::PostsController</tt>, you could use
#
#   scope module: "admin" do
#     resources :posts
#   end
#
# or, for a single case
#
#   resources :posts, module: "admin"
#
# If you want to route /admin/posts to +PostsController+
# (without the <tt>Admin::</tt> module prefix), you could use
#
#   scope "/admin" do
#     resources :posts
#   end
#
# or, for a single case
#
#   resources :posts, path: "/admin/posts"
#
# In each of these cases, the named routes remain the same as if you did
# not use scope. In the last case, the following paths map to
# +PostsController+:
#
#   GET       /admin/posts
#   GET       /admin/posts/new
#   POST      /admin/posts
#   GET       /admin/posts/1
#   GET       /admin/posts/1/edit
#   PATCH/PUT /admin/posts/1
#   DELETE    /admin/posts/1
module ActionDispatch::Routing::Mapper::Scoping
  # === Parameter Restriction
  # Allows you to constrain the nested routes based on a set of rules.
  # For instance, in order to change the routes to allow for a dot character in the +id+ parameter:
  #
  #   constraints(id: /\d+\.\d+/) do
  #     resources :posts
  #   end
  #
  # Now routes such as +/posts/1+ will no longer be valid, but +/posts/1.1+ will be.
  # The +id+ parameter must match the constraint passed in for this example.
  #
  # You may use this to also restrict other parameters:
  #
  #   resources :posts do
  #     constraints(post_id: /\d+\.\d+/) do
  #       resources :comments
  #     end
  #   end
  #
  # === Restricting based on IP
  #
  # Routes can also be constrained to an IP or a certain range of IP addresses:
  #
  #   constraints(ip: /192\.168\.\d+\.\d+/) do
  #     resources :posts
  #   end
  #
  # Any user connecting from the 192.168.* range will be able to see this resource,
  # where as any user connecting outside of this range will be told there is no such route.
  #
  # === Dynamic request matching
  #
  # Requests to routes can be constrained based on specific criteria:
  #
  #    constraints(-> (req) { /iPhone/.match?(req.env["HTTP_USER_AGENT"]) }) do
  #      resources :iphones
  #    end
  #
  # You are able to move this logic out into a class if it is too complex for routes.
  # This class must have a +matches?+ method defined on it which either returns +true+
  # if the user should be given access to that route, or +false+ if the user should not.
  #
  #    class Iphone
  #      def self.matches?(request)
  #        /iPhone/.match?(request.env["HTTP_USER_AGENT"])
  #      end
  #    end
  #
  # An expected place for this code would be +lib/constraints+.
  #
  # This class is then used like this:
  #
  #    constraints(Iphone) do
  #      resources :iphones
  #    end
  def constraints(constraints = T.unsafe(nil)); end

  # Scopes routes to a specific controller
  #
  #   controller "food" do
  #     match "bacon", action: :bacon, via: :get
  #   end
  def controller(controller); end

  # Allows you to set default parameters for a route, such as this:
  #   defaults id: 'home' do
  #     match 'scoped_pages/(:id)', to: 'pages#show'
  #   end
  # Using this, the +:id+ parameter here will default to 'home'.
  def defaults(defaults = T.unsafe(nil)); end

  # Scopes routes to a specific namespace. For example:
  #
  #   namespace :admin do
  #     resources :posts
  #   end
  #
  # This generates the following routes:
  #
  #       admin_posts GET       /admin/posts(.:format)          admin/posts#index
  #       admin_posts POST      /admin/posts(.:format)          admin/posts#create
  #    new_admin_post GET       /admin/posts/new(.:format)      admin/posts#new
  #   edit_admin_post GET       /admin/posts/:id/edit(.:format) admin/posts#edit
  #        admin_post GET       /admin/posts/:id(.:format)      admin/posts#show
  #        admin_post PATCH/PUT /admin/posts/:id(.:format)      admin/posts#update
  #        admin_post DELETE    /admin/posts/:id(.:format)      admin/posts#destroy
  #
  # === Options
  #
  # The +:path+, +:as+, +:module+, +:shallow_path+ and +:shallow_prefix+
  # options all default to the name of the namespace.
  #
  # For options, see <tt>Base#match</tt>. For +:shallow_path+ option, see
  # <tt>Resources#resources</tt>.
  #
  #   # accessible through /sekret/posts rather than /admin/posts
  #   namespace :admin, path: "sekret" do
  #     resources :posts
  #   end
  #
  #   # maps to <tt>Sekret::PostsController</tt> rather than <tt>Admin::PostsController</tt>
  #   namespace :admin, module: "sekret" do
  #     resources :posts
  #   end
  #
  #   # generates +sekret_posts_path+ rather than +admin_posts_path+
  #   namespace :admin, as: "sekret" do
  #     resources :posts
  #   end
  def namespace(path, options = T.unsafe(nil)); end

  # Scopes a set of routes to the given default options.
  #
  # Take the following route definition as an example:
  #
  #   scope path: ":account_id", as: "account" do
  #     resources :projects
  #   end
  #
  # This generates helpers such as +account_projects_path+, just like +resources+ does.
  # The difference here being that the routes generated are like /:account_id/projects,
  # rather than /accounts/:account_id/projects.
  #
  # === Options
  #
  # Takes same options as <tt>Base#match</tt> and <tt>Resources#resources</tt>.
  #
  #   # route /posts (without the prefix /admin) to <tt>Admin::PostsController</tt>
  #   scope module: "admin" do
  #     resources :posts
  #   end
  #
  #   # prefix the posts resource's requests with '/admin'
  #   scope path: "/admin" do
  #     resources :posts
  #   end
  #
  #   # prefix the routing helper name: +sekret_posts_path+ instead of +posts_path+
  #   scope as: "sekret" do
  #     resources :posts
  #   end
  def scope(*args); end

  private

  def merge_action_scope(parent, child); end
  def merge_as_scope(parent, child); end
  def merge_blocks_scope(parent, child); end
  def merge_constraints_scope(parent, child); end
  def merge_controller_scope(parent, child); end
  def merge_defaults_scope(parent, child); end
  def merge_format_scope(parent, child); end
  def merge_module_scope(parent, child); end
  def merge_options_scope(parent, child); end
  def merge_path_names_scope(parent, child); end
  def merge_path_scope(parent, child); end
  def merge_shallow_path_scope(parent, child); end
  def merge_shallow_prefix_scope(parent, child); end
  def merge_shallow_scope(parent, child); end
  def merge_to_scope(parent, child); end
  def merge_via_scope(parent, child); end
end

ActionDispatch::Routing::Mapper::Scoping::POISON = T.let(T.unsafe(nil), Object)
ActionDispatch::Routing::Mapper::URL_OPTIONS = T.let(T.unsafe(nil), Array)

class ActionDispatch::Routing::OptionRedirect < ::ActionDispatch::Routing::Redirect
  def inspect; end
  def options; end
  def path(params, request); end
end

class ActionDispatch::Routing::PathRedirect < ::ActionDispatch::Routing::Redirect
  def inspect; end
  def path(params, request); end

  private

  # @return [Boolean]
  def interpolation_required?(string, params); end
end

ActionDispatch::Routing::PathRedirect::URL_PARTS = T.let(T.unsafe(nil), Regexp)

# Polymorphic URL helpers are methods for smart resolution to a named route call when
# given an Active Record model instance. They are to be used in combination with
# ActionController::Resources.
#
# These methods are useful when you want to generate the correct URL or path to a RESTful
# resource without having to know the exact type of the record in question.
#
# Nested resources and/or namespaces are also supported, as illustrated in the example:
#
#   polymorphic_url([:admin, @article, @comment])
#
# results in:
#
#   admin_article_comment_url(@article, @comment)
#
# == Usage within the framework
#
# Polymorphic URL helpers are used in a number of places throughout the \Rails framework:
#
# * <tt>url_for</tt>, so you can use it with a record as the argument, e.g.
#   <tt>url_for(@article)</tt>;
# * ActionView::Helpers::FormHelper uses <tt>polymorphic_path</tt>, so you can write
#   <tt>form_for(@article)</tt> without having to specify <tt>:url</tt> parameter for the form
#   action;
# * <tt>redirect_to</tt> (which, in fact, uses <tt>url_for</tt>) so you can write
#   <tt>redirect_to(post)</tt> in your controllers;
# * ActionView::Helpers::AtomFeedHelper, so you don't have to explicitly specify URLs
#   for feed entries.
#
# == Prefixed polymorphic helpers
#
# In addition to <tt>polymorphic_url</tt> and <tt>polymorphic_path</tt> methods, a
# number of prefixed helpers are available as a shorthand to <tt>action: "..."</tt>
# in options. Those are:
#
# * <tt>edit_polymorphic_url</tt>, <tt>edit_polymorphic_path</tt>
# * <tt>new_polymorphic_url</tt>, <tt>new_polymorphic_path</tt>
#
# Example usage:
#
#   edit_polymorphic_path(@post)           # => "/posts/1/edit"
#   polymorphic_path(@post, format: :pdf)  # => "/posts/1.pdf"
#
# == Usage with mounted engines
#
# If you are using a mounted engine and you need to use a polymorphic_url
# pointing at the engine's routes, pass in the engine's route proxy as the first
# argument to the method. For example:
#
#   polymorphic_url([blog, @post])  # calls blog.post_path(@post)
#   form_for([blog, @post])         # => "/blog/posts/1"
module ActionDispatch::Routing::PolymorphicRoutes
  def edit_polymorphic_path(record_or_hash, options = T.unsafe(nil)); end
  def edit_polymorphic_url(record_or_hash, options = T.unsafe(nil)); end
  def new_polymorphic_path(record_or_hash, options = T.unsafe(nil)); end
  def new_polymorphic_url(record_or_hash, options = T.unsafe(nil)); end

  # Returns the path component of a URL for the given record.
  def polymorphic_path(record_or_hash_or_array, options = T.unsafe(nil)); end

  # Constructs a call to a named RESTful route for the given record and returns the
  # resulting URL string. For example:
  #
  #   # calls post_url(post)
  #   polymorphic_url(post) # => "http://example.com/posts/1"
  #   polymorphic_url([blog, post]) # => "http://example.com/blogs/1/posts/1"
  #   polymorphic_url([:admin, blog, post]) # => "http://example.com/admin/blogs/1/posts/1"
  #   polymorphic_url([user, :blog, post]) # => "http://example.com/users/1/blog/posts/1"
  #   polymorphic_url(Comment) # => "http://example.com/comments"
  #
  # ==== Options
  #
  # * <tt>:action</tt> - Specifies the action prefix for the named route:
  #   <tt>:new</tt> or <tt>:edit</tt>. Default is no prefix.
  # * <tt>:routing_type</tt> - Allowed values are <tt>:path</tt> or <tt>:url</tt>.
  #   Default is <tt>:url</tt>.
  #
  # Also includes all the options from <tt>url_for</tt>. These include such
  # things as <tt>:anchor</tt> or <tt>:trailing_slash</tt>. Example usage
  # is given below:
  #
  #   polymorphic_url([blog, post], anchor: 'my_anchor')
  #     # => "http://example.com/blogs/1/posts/1#my_anchor"
  #   polymorphic_url([blog, post], anchor: 'my_anchor', script_name: "/my_app")
  #     # => "http://example.com/my_app/blogs/1/posts/1#my_anchor"
  #
  # For all of these options, see the documentation for {url_for}[rdoc-ref:ActionDispatch::Routing::UrlFor].
  #
  # ==== Functionality
  #
  #   # an Article record
  #   polymorphic_url(record)  # same as article_url(record)
  #
  #   # a Comment record
  #   polymorphic_url(record)  # same as comment_url(record)
  #
  #   # it recognizes new records and maps to the collection
  #   record = Comment.new
  #   polymorphic_url(record)  # same as comments_url()
  #
  #   # the class of a record will also map to the collection
  #   polymorphic_url(Comment) # same as comments_url()
  def polymorphic_url(record_or_hash_or_array, options = T.unsafe(nil)); end

  private

  def polymorphic_mapping(record); end
  def polymorphic_path_for_action(action, record_or_hash, options); end
  def polymorphic_url_for_action(action, record_or_hash, options); end
end

class ActionDispatch::Routing::PolymorphicRoutes::HelperMethodBuilder
  # @return [HelperMethodBuilder] a new instance of HelperMethodBuilder
  def initialize(key_strategy, prefix, suffix); end

  def handle_class(klass); end
  def handle_class_call(target, klass); end
  def handle_list(list); end
  def handle_model(record); end
  def handle_model_call(target, record); end
  def handle_string(record); end
  def handle_string_call(target, str); end

  # Returns the value of attribute prefix.
  def prefix; end

  # Returns the value of attribute suffix.
  def suffix; end

  private

  def get_method_for_class(klass); end
  def get_method_for_string(str); end
  def polymorphic_mapping(target, record); end

  class << self
    def build(action, type); end
    def get(action, type); end
    def path; end
    def plural(prefix, suffix); end
    def polymorphic_method(recipient, record_or_hash_or_array, action, type, options); end
    def singular(prefix, suffix); end
    def url; end
  end
end

ActionDispatch::Routing::PolymorphicRoutes::HelperMethodBuilder::CACHE = T.let(T.unsafe(nil), Hash)

class ActionDispatch::Routing::Redirect < ::ActionDispatch::Routing::Endpoint
  # @return [Redirect] a new instance of Redirect
  def initialize(status, block); end

  # Returns the value of attribute block.
  def block; end

  def call(env); end
  def inspect; end
  def path(params, request); end

  # @return [Boolean]
  def redirect?; end

  def serve(req); end

  # Returns the value of attribute status.
  def status; end

  private

  def escape(params); end
  def escape_fragment(params); end
  def escape_path(params); end

  # @return [Boolean]
  def relative_path?(path); end
end

module ActionDispatch::Routing::Redirection
  # Redirect any path to another path:
  #
  #   get "/stories" => redirect("/posts")
  #
  # This will redirect the user, while ignoring certain parts of the request, including query string, etc.
  # <tt>/stories</tt>, <tt>/stories?foo=bar</tt>, etc all redirect to <tt>/posts</tt>.
  #
  # You can also use interpolation in the supplied redirect argument:
  #
  #   get 'docs/:article', to: redirect('/wiki/%{article}')
  #
  # Note that if you return a path without a leading slash then the URL is prefixed with the
  # current SCRIPT_NAME environment variable. This is typically '/' but may be different in
  # a mounted engine or where the application is deployed to a subdirectory of a website.
  #
  # Alternatively you can use one of the other syntaxes:
  #
  # The block version of redirect allows for the easy encapsulation of any logic associated with
  # the redirect in question. Either the params and request are supplied as arguments, or just
  # params, depending of how many arguments your block accepts. A string is required as a
  # return value.
  #
  #   get 'jokes/:number', to: redirect { |params, request|
  #     path = (params[:number].to_i.even? ? "wheres-the-beef" : "i-love-lamp")
  #     "http://#{request.host_with_port}/#{path}"
  #   }
  #
  # Note that the <tt>do end</tt> syntax for the redirect block wouldn't work, as Ruby would pass
  # the block to +get+ instead of +redirect+. Use <tt>{ ... }</tt> instead.
  #
  # The options version of redirect allows you to supply only the parts of the URL which need
  # to change, it also supports interpolation of the path similar to the first example.
  #
  #   get 'stores/:name',       to: redirect(subdomain: 'stores', path: '/%{name}')
  #   get 'stores/:name(*all)', to: redirect(subdomain: 'stores', path: '/%{name}%{all}')
  #   get '/stories', to: redirect(path: '/posts')
  #
  # This will redirect the user, while changing only the specified parts of the request,
  # for example the +path+ option in the last example.
  # <tt>/stories</tt>, <tt>/stories?foo=bar</tt>, redirect to <tt>/posts</tt> and <tt>/posts?foo=bar</tt> respectively.
  #
  # Finally, an object which responds to call can be supplied to redirect, allowing you to reuse
  # common redirect routes. The call method must accept two arguments, params and request, and return
  # a string.
  #
  #   get 'accounts/:name' => redirect(SubdomainRedirector.new('api'))
  #
  # @raise [ArgumentError]
  def redirect(*args, &block); end
end

# :stopdoc:
class ActionDispatch::Routing::RouteSet
  # @return [RouteSet] a new instance of RouteSet
  def initialize(config = T.unsafe(nil)); end

  def add_polymorphic_mapping(klass, options, &block); end

  # @raise [ArgumentError]
  def add_route(mapping, name); end

  def add_url_helper(name, options, &block); end

  # @return [Boolean]
  def api_only?; end

  def append(&block); end
  def call(env); end
  def clear!; end

  # Returns the value of attribute default_scope.
  def default_scope; end

  # Sets the attribute default_scope
  #
  # @param value the value to set the attribute default_scope to.
  def default_scope=(_arg0); end

  # Returns the value of attribute default_url_options.
  def default_url_options; end

  # Sets the attribute default_url_options
  #
  # @param value the value to set the attribute default_url_options to.
  def default_url_options=(_arg0); end

  def define_mounted_helper(name, script_namer = T.unsafe(nil)); end

  # Returns the value of attribute disable_clear_and_finalize.
  def disable_clear_and_finalize; end

  # Sets the attribute disable_clear_and_finalize
  #
  # @param value the value to set the attribute disable_clear_and_finalize to.
  def disable_clear_and_finalize=(_arg0); end

  def draw(&block); end

  # Returns the value of attribute draw_paths.
  def draw_paths; end

  # Sets the attribute draw_paths
  #
  # @param value the value to set the attribute draw_paths to.
  def draw_paths=(_arg0); end

  def eager_load!; end

  # @return [Boolean]
  def empty?; end

  # Returns the value of attribute env_key.
  def env_key; end

  # Generate the path indicated by the arguments, and return an array of
  # the keys that were not used to generate it.
  def extra_keys(options, recall = T.unsafe(nil)); end

  def finalize!; end
  def find_relative_url_root(options); end
  def find_script_name(options); end

  # Returns the value of attribute formatter.
  def formatter; end

  # Sets the attribute formatter
  #
  # @param value the value to set the attribute formatter to.
  def formatter=(_arg0); end

  def generate_extras(options, recall = T.unsafe(nil)); end
  def generate_url_helpers(supports_path); end

  # Since the router holds references to many parts of the system
  # like engines, controllers and the application itself, inspecting
  # the route set can actually be really slow, therefore we default
  # alias inspect to to_s.
  def inspect; end

  # Contains all the mounted helpers across different
  # engines and the `main_app` helper for the application.
  # You can include this in your classes if you want to
  # access routes for other engines.
  def mounted_helpers; end

  # Returns the value of attribute named_routes.
  def named_routes; end

  # Sets the attribute named_routes
  #
  # @param value the value to set the attribute named_routes to.
  def named_routes=(_arg0); end

  # @return [Boolean]
  def optimize_routes_generation?; end

  def path_for(options, route_name = T.unsafe(nil), reserved = T.unsafe(nil)); end

  # Returns the value of attribute polymorphic_mappings.
  def polymorphic_mappings; end

  def prepend(&block); end
  def recognize_path(path, environment = T.unsafe(nil)); end
  def recognize_path_with_request(req, path, extras, raise_on_missing: T.unsafe(nil)); end
  def relative_url_root; end
  def request_class; end

  # Returns the value of attribute resources_path_names.
  def resources_path_names; end

  # Sets the attribute resources_path_names
  #
  # @param value the value to set the attribute resources_path_names to.
  def resources_path_names=(_arg0); end

  # Returns the value of attribute router.
  def router; end

  # Sets the attribute router
  #
  # @param value the value to set the attribute router to.
  def router=(_arg0); end

  # Returns the value of attribute set.
  def routes; end

  # Returns the value of attribute set.
  def set; end

  # Sets the attribute set
  #
  # @param value the value to set the attribute set to.
  def set=(_arg0); end

  # The +options+ argument must be a hash whose keys are *symbols*.
  def url_for(options, route_name = T.unsafe(nil), url_strategy = T.unsafe(nil), method_name = T.unsafe(nil), reserved = T.unsafe(nil)); end

  def url_helpers(supports_path = T.unsafe(nil)); end

  private

  def eval_block(block); end
  def generate(route_name, options, recall = T.unsafe(nil), method_name = T.unsafe(nil)); end
  def make_request(env); end

  class << self
    def default_resources_path_names; end
    def new_with_config(config); end
  end
end

class ActionDispatch::Routing::RouteSet::Config < ::Struct
  # Returns the value of attribute api_only
  #
  # @return [Object] the current value of api_only
  def api_only; end

  # Sets the attribute api_only
  #
  # @param value [Object] the value to set the attribute api_only to.
  # @return [Object] the newly set value
  def api_only=(_); end

  # Returns the value of attribute relative_url_root
  #
  # @return [Object] the current value of relative_url_root
  def relative_url_root; end

  # Sets the attribute relative_url_root
  #
  # @param value [Object] the value to set the attribute relative_url_root to.
  # @return [Object] the newly set value
  def relative_url_root=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def members; end
    def new(*_arg0); end
  end
end

class ActionDispatch::Routing::RouteSet::CustomUrlHelper
  # @return [CustomUrlHelper] a new instance of CustomUrlHelper
  def initialize(name, defaults, &block); end

  # Returns the value of attribute block.
  def block; end

  def call(t, args, only_path = T.unsafe(nil)); end

  # Returns the value of attribute defaults.
  def defaults; end

  # Returns the value of attribute name.
  def name; end

  private

  def eval_block(t, args, options); end
  def merge_defaults(options); end
end

ActionDispatch::Routing::RouteSet::DEFAULT_CONFIG = T.let(T.unsafe(nil), ActionDispatch::Routing::RouteSet::Config)

class ActionDispatch::Routing::RouteSet::Dispatcher < ::ActionDispatch::Routing::Endpoint
  # @return [Dispatcher] a new instance of Dispatcher
  def initialize(raise_on_name_error); end

  # @return [Boolean]
  def dispatcher?; end

  def serve(req); end

  private

  def controller(req); end
  def dispatch(controller, action, req, res); end
end

class ActionDispatch::Routing::RouteSet::Generator
  # @return [Generator] a new instance of Generator
  def initialize(named_route, options, recall, set); end

  def controller; end
  def current_controller; end

  # @return [Boolean]
  def different_controller?; end

  # Generates a path from routes, returns a RouteWithParams or MissingRoute.
  # MissingRoute will raise ActionController::UrlGenerationError.
  def generate; end

  # Returns the value of attribute named_route.
  def named_route; end

  # Remove leading slashes from controllers
  def normalize_controller!; end

  # This pulls :controller, :action, and :id out of the recall.
  # The recall key is only used if there is no key in the options
  # or if the key in the options is identical. If any of
  # :controller, :action or :id is not found, don't pull any
  # more keys from the recall.
  def normalize_controller_action_id!; end

  def normalize_options!; end

  # Returns the value of attribute options.
  def options; end

  # Returns the value of attribute recall.
  def recall; end

  # Returns the value of attribute set.
  def set; end

  def use_recall_for(key); end

  # if the current controller is "foo/bar/baz" and controller: "baz/bat"
  # is specified, the controller becomes "foo/baz/bat"
  def use_relative_controller!; end

  private

  # @return [Boolean]
  def named_route_exists?; end

  def segment_keys; end
end

module ActionDispatch::Routing::RouteSet::MountedHelpers
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods
  include ::ActionDispatch::Routing::UrlFor

  mixes_in_class_methods GeneratedClassMethods

  module GeneratedClassMethods
    def default_url_options; end
    def default_url_options=(value); end
    def default_url_options?; end
  end

  module GeneratedInstanceMethods
    def default_url_options; end
    def default_url_options=(value); end
    def default_url_options?; end
  end
end

# A NamedRouteCollection instance is a collection of named routes, and also
# maintains an anonymous module that can be used to install helpers for the
# named routes.
class ActionDispatch::Routing::RouteSet::NamedRouteCollection
  include ::Enumerable

  # @return [NamedRouteCollection] a new instance of NamedRouteCollection
  def initialize; end

  def [](name); end
  def []=(name, route); end
  def add(name, route); end

  # Given a +name+, defines name_path and name_url helpers.
  # Used by 'direct', 'resolve', and 'polymorphic' route helpers.
  def add_url_helper(name, defaults, &block); end

  def clear; end
  def clear!; end
  def each; end
  def get(name); end
  def helper_names; end

  # @return [Boolean]
  def key?(name); end

  def length; end
  def names; end

  # Returns the value of attribute path_helpers_module.
  def path_helpers_module; end

  # @return [Boolean]
  def route_defined?(name); end

  # Returns the value of attribute url_helpers_module.
  def url_helpers_module; end

  private

  # Create a URL helper allowing ordered parameters to be associated
  # with corresponding dynamic segments, so you can do:
  #
  #   foo_url(bar, baz, bang)
  #
  # Instead of:
  #
  #   foo_url(bar: bar, baz: baz, bang: bang)
  #
  # Also allow options hash, so you can do:
  #
  #   foo_url(bar, baz, bang, sort_by: 'baz')
  def define_url_helper(mod, name, helper, url_strategy); end

  # Returns the value of attribute routes.
  def routes; end
end

class ActionDispatch::Routing::RouteSet::NamedRouteCollection::UrlHelper
  # @return [UrlHelper] a new instance of UrlHelper
  def initialize(route, options, route_name); end

  def call(t, method_name, args, inner_options, url_strategy); end
  def handle_positional_args(controller_options, inner_options, args, result, path_params); end

  # Returns the value of attribute route_name.
  def route_name; end

  class << self
    def create(route, options, route_name); end

    # @return [Boolean]
    def optimize_helper?(route); end
  end
end

class ActionDispatch::Routing::RouteSet::NamedRouteCollection::UrlHelper::OptimizedUrlHelper < ::ActionDispatch::Routing::RouteSet::NamedRouteCollection::UrlHelper
  # @return [OptimizedUrlHelper] a new instance of OptimizedUrlHelper
  def initialize(route, options, route_name); end

  # Returns the value of attribute arg_size.
  def arg_size; end

  def call(t, method_name, args, inner_options, url_strategy); end

  private

  # @return [Boolean]
  def optimize_routes_generation?(t); end

  def optimized_helper(args); end
  def parameterize_args(args); end

  # @raise [ActionController::UrlGenerationError]
  def raise_generation_error(args); end
end

# strategy for building URLs to send to the client
ActionDispatch::Routing::RouteSet::PATH = T.let(T.unsafe(nil), Proc)

ActionDispatch::Routing::RouteSet::RESERVED_OPTIONS = T.let(T.unsafe(nil), Array)

class ActionDispatch::Routing::RouteSet::StaticDispatcher < ::ActionDispatch::Routing::RouteSet::Dispatcher
  # @return [StaticDispatcher] a new instance of StaticDispatcher
  def initialize(controller_class); end

  private

  def controller(_); end
end

ActionDispatch::Routing::RouteSet::UNKNOWN = T.let(T.unsafe(nil), Proc)

class ActionDispatch::Routing::RouteWrapper < ::SimpleDelegator
  def action; end
  def constraints; end
  def controller; end
  def endpoint; end

  # @return [Boolean]
  def engine?; end

  # @return [Boolean]
  def internal?; end

  def name; end
  def path; end
  def rack_app; end
  def reqs; end
end

# This class is just used for displaying route information when someone
# executes `bin/rails routes` or looks at the RoutingError page.
# People should not use this class.
class ActionDispatch::Routing::RoutesInspector
  # @return [RoutesInspector] a new instance of RoutesInspector
  def initialize(routes); end

  def format(formatter, filter = T.unsafe(nil)); end

  private

  def collect_engine_routes(route); end
  def collect_routes(routes); end
  def filter_routes(filter); end
  def normalize_filter(filter); end
end

class ActionDispatch::Routing::RoutesProxy
  include ::ActionDispatch::Routing::PolymorphicRoutes
  include ::ActionDispatch::Routing::UrlFor

  # @return [RoutesProxy] a new instance of RoutesProxy
  def initialize(routes, scope, helpers, script_namer = T.unsafe(nil)); end

  # Returns the value of attribute routes.
  def _routes; end

  def default_url_options; end
  def default_url_options=(_arg0); end
  def default_url_options?; end

  # Returns the value of attribute routes.
  def routes; end

  # Sets the attribute routes
  #
  # @param value the value to set the attribute routes to.
  def routes=(_arg0); end

  # Returns the value of attribute scope.
  def scope; end

  # Sets the attribute scope
  #
  # @param value the value to set the attribute scope to.
  def scope=(_arg0); end

  def url_options; end

  private

  # Keeps the part of the script name provided by the global
  # context via ENV["SCRIPT_NAME"], which `mount` doesn't know
  # about since it depends on the specific request, but use our
  # script name resolver for the mount point dependent part.
  def merge_script_names(previous_script_name, new_script_name); end

  def method_missing(method, *args); end

  # @return [Boolean]
  def respond_to_missing?(method, _); end

  class << self
    def default_url_options; end
    def default_url_options=(value); end
    def default_url_options?; end
  end
end

ActionDispatch::Routing::SEPARATORS = T.let(T.unsafe(nil), Array)

# In <tt>config/routes.rb</tt> you define URL-to-controller mappings, but the reverse
# is also possible: a URL can be generated from one of your routing definitions.
# URL generation functionality is centralized in this module.
#
# See ActionDispatch::Routing for general information about routing and routes.rb.
#
# <b>Tip:</b> If you need to generate URLs from your models or some other place,
# then ActionController::UrlFor is what you're looking for. Read on for
# an introduction. In general, this module should not be included on its own,
# as it is usually included by url_helpers (as in Rails.application.routes.url_helpers).
#
# == URL generation from parameters
#
# As you may know, some functions, such as ActionController::Base#url_for
# and ActionView::Helpers::UrlHelper#link_to, can generate URLs given a set
# of parameters. For example, you've probably had the chance to write code
# like this in one of your views:
#
#   <%= link_to('Click here', controller: 'users',
#           action: 'new', message: 'Welcome!') %>
#   # => <a href="/users/new?message=Welcome%21">Click here</a>
#
# link_to, and all other functions that require URL generation functionality,
# actually use ActionController::UrlFor under the hood. And in particular,
# they use the ActionController::UrlFor#url_for method. One can generate
# the same path as the above example by using the following code:
#
#   include UrlFor
#   url_for(controller: 'users',
#           action: 'new',
#           message: 'Welcome!',
#           only_path: true)
#   # => "/users/new?message=Welcome%21"
#
# Notice the <tt>only_path: true</tt> part. This is because UrlFor has no
# information about the website hostname that your Rails app is serving. So if you
# want to include the hostname as well, then you must also pass the <tt>:host</tt>
# argument:
#
#   include UrlFor
#   url_for(controller: 'users',
#           action: 'new',
#           message: 'Welcome!',
#           host: 'www.example.com')
#   # => "http://www.example.com/users/new?message=Welcome%21"
#
# By default, all controllers and views have access to a special version of url_for,
# that already knows what the current hostname is. So if you use url_for in your
# controllers or your views, then you don't need to explicitly pass the <tt>:host</tt>
# argument.
#
# For convenience reasons, mailers provide a shortcut for ActionController::UrlFor#url_for.
# So within mailers, you only have to type +url_for+ instead of 'ActionController::UrlFor#url_for'
# in full. However, mailers don't have hostname information, and you still have to provide
# the +:host+ argument or set the default host that will be used in all mailers using the
# configuration option +config.action_mailer.default_url_options+. For more information on
# url_for in mailers read the ActionMailer#Base documentation.
#
#
# == URL generation for named routes
#
# UrlFor also allows one to access methods that have been auto-generated from
# named routes. For example, suppose that you have a 'users' resource in your
# <tt>config/routes.rb</tt>:
#
#   resources :users
#
# This generates, among other things, the method <tt>users_path</tt>. By default,
# this method is accessible from your controllers, views and mailers. If you need
# to access this auto-generated method from other places (such as a model), then
# you can do that by including Rails.application.routes.url_helpers in your class:
#
#   class User < ActiveRecord::Base
#     include Rails.application.routes.url_helpers
#
#     def base_uri
#       user_path(self)
#     end
#   end
#
#   User.find(1).base_uri # => "/users/1"
module ActionDispatch::Routing::UrlFor
  include ::ActionDispatch::Routing::PolymorphicRoutes
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods

  mixes_in_class_methods GeneratedClassMethods

  def initialize(*_arg0); end

  def full_url_for(options = T.unsafe(nil)); end

  # Allows calling direct or regular named route.
  #
  #   resources :buckets
  #
  #   direct :recordable do |recording|
  #     route_for(:bucket, recording.bucket)
  #   end
  #
  #   direct :threadable do |threadable|
  #     route_for(:recordable, threadable.parent)
  #   end
  #
  # This maintains the context of the original caller on
  # whether to return a path or full URL, e.g:
  #
  #   threadable_path(threadable)  # => "/buckets/1"
  #   threadable_url(threadable)   # => "http://example.com/buckets/1"
  def route_for(name, *args); end

  # Generate a URL based on the options provided, default_url_options and the
  # routes defined in routes.rb. The following options are supported:
  #
  # * <tt>:only_path</tt> - If true, the relative URL is returned. Defaults to +false+.
  # * <tt>:protocol</tt> - The protocol to connect to. Defaults to 'http'.
  # * <tt>:host</tt> - Specifies the host the link should be targeted at.
  #   If <tt>:only_path</tt> is false, this option must be
  #   provided either explicitly, or via +default_url_options+.
  # * <tt>:subdomain</tt> - Specifies the subdomain of the link, using the +tld_length+
  #   to split the subdomain from the host.
  #   If false, removes all subdomains from the host part of the link.
  # * <tt>:domain</tt> - Specifies the domain of the link, using the +tld_length+
  #   to split the domain from the host.
  # * <tt>:tld_length</tt> - Number of labels the TLD id composed of, only used if
  #   <tt>:subdomain</tt> or <tt>:domain</tt> are supplied. Defaults to
  #   <tt>ActionDispatch::Http::URL.tld_length</tt>, which in turn defaults to 1.
  # * <tt>:port</tt> - Optionally specify the port to connect to.
  # * <tt>:anchor</tt> - An anchor name to be appended to the path.
  # * <tt>:params</tt> - The query parameters to be appended to the path.
  # * <tt>:trailing_slash</tt> - If true, adds a trailing slash, as in "/archive/2009/"
  # * <tt>:script_name</tt> - Specifies application path relative to domain root. If provided, prepends application path.
  #
  # Any other key (<tt>:controller</tt>, <tt>:action</tt>, etc.) given to
  # +url_for+ is forwarded to the Routes module.
  #
  #    url_for controller: 'tasks', action: 'testing', host: 'somehost.org', port: '8080'
  #    # => 'http://somehost.org:8080/tasks/testing'
  #    url_for controller: 'tasks', action: 'testing', host: 'somehost.org', anchor: 'ok', only_path: true
  #    # => '/tasks/testing#ok'
  #    url_for controller: 'tasks', action: 'testing', trailing_slash: true
  #    # => 'http://somehost.org/tasks/testing/'
  #    url_for controller: 'tasks', action: 'testing', host: 'somehost.org', number: '33'
  #    # => 'http://somehost.org/tasks/testing?number=33'
  #    url_for controller: 'tasks', action: 'testing', host: 'somehost.org', script_name: "/myapp"
  #    # => 'http://somehost.org/myapp/tasks/testing'
  #    url_for controller: 'tasks', action: 'testing', host: 'somehost.org', script_name: "/myapp", only_path: true
  #    # => '/myapp/tasks/testing'
  #
  # Missing routes keys may be filled in from the current request's parameters
  # (e.g. +:controller+, +:action+, +:id+ and any other parameters that are
  # placed in the path). Given that the current action has been reached
  # through <tt>GET /users/1</tt>:
  #
  #   url_for(only_path: true)                        # => '/users/1'
  #   url_for(only_path: true, action: 'edit')        # => '/users/1/edit'
  #   url_for(only_path: true, action: 'edit', id: 2) # => '/users/2/edit'
  #
  # Notice that no +:id+ parameter was provided to the first +url_for+ call
  # and the helper used the one from the route's path. Any path parameter
  # implicitly used by +url_for+ can always be overwritten like shown on the
  # last +url_for+ calls.
  def url_for(options = T.unsafe(nil)); end

  # Hook overridden in controller to add request information
  # with +default_url_options+. Application logic should not
  # go into url_options.
  def url_options; end

  protected

  # @return [Boolean]
  def optimize_routes_generation?; end

  private

  def _routes_context; end
  def _with_routes(routes); end

  module GeneratedClassMethods
    def default_url_options; end
    def default_url_options=(value); end
    def default_url_options?; end
  end

  module GeneratedInstanceMethods
    def default_url_options; end
    def default_url_options=(value); end
    def default_url_options?; end
  end
end

# This middleware is added to the stack when <tt>config.force_ssl = true</tt>, and is passed
# the options set in +config.ssl_options+. It does three jobs to enforce secure HTTP
# requests:
#
# 1. <b>TLS redirect</b>: Permanently redirects +http://+ requests to +https://+
#    with the same URL host, path, etc. Enabled by default. Set +config.ssl_options+
#    to modify the destination URL
#    (e.g. <tt>redirect: { host: "secure.widgets.com", port: 8080 }</tt>), or set
#    <tt>redirect: false</tt> to disable this feature.
#
#    Requests can opt-out of redirection with +exclude+:
#
#      config.ssl_options = { redirect: { exclude: -> request { /healthcheck/.match?(request.path) } } }
#
#    Cookies will not be flagged as secure for excluded requests.
#
# 2. <b>Secure cookies</b>: Sets the +secure+ flag on cookies to tell browsers they
#    must not be sent along with +http://+ requests. Enabled by default. Set
#    +config.ssl_options+ with <tt>secure_cookies: false</tt> to disable this feature.
#
# 3. <b>HTTP Strict Transport Security (HSTS)</b>: Tells the browser to remember
#    this site as TLS-only and automatically redirect non-TLS requests.
#    Enabled by default. Configure +config.ssl_options+ with <tt>hsts: false</tt> to disable.
#
#    Set +config.ssl_options+ with <tt>hsts: { ... }</tt> to configure HSTS:
#
#    * +expires+: How long, in seconds, these settings will stick. The minimum
#      required to qualify for browser preload lists is 1 year. Defaults to
#      2 years (recommended).
#
#    * +subdomains+: Set to +true+ to tell the browser to apply these settings
#      to all subdomains. This protects your cookies from interception by a
#      vulnerable site on a subdomain. Defaults to +true+.
#
#    * +preload+: Advertise that this site may be included in browsers'
#      preloaded HSTS lists. HSTS protects your site on every visit <i>except the
#      first visit</i> since it hasn't seen your HSTS header yet. To close this
#      gap, browser vendors include a baked-in list of HSTS-enabled sites.
#      Go to https://hstspreload.org to submit your site for inclusion.
#      Defaults to +false+.
#
#    To turn off HSTS, omitting the header is not enough. Browsers will remember the
#    original HSTS directive until it expires. Instead, use the header to tell browsers to
#    expire HSTS immediately. Setting <tt>hsts: false</tt> is a shortcut for
#    <tt>hsts: { expires: 0 }</tt>.
class ActionDispatch::SSL
  # @return [SSL] a new instance of SSL
  def initialize(app, redirect: T.unsafe(nil), hsts: T.unsafe(nil), secure_cookies: T.unsafe(nil), ssl_default_redirect_status: T.unsafe(nil)); end

  def call(env); end

  private

  # https://tools.ietf.org/html/rfc6797#section-6.1
  def build_hsts_header(hsts); end

  def flag_cookies_as_secure!(headers); end
  def https_location_for(request); end
  def normalize_hsts_options(options); end
  def redirect_to_https(request); end
  def redirection_status(request); end
  def set_hsts_header!(headers); end

  class << self
    def default_hsts_options; end
  end
end

# Default to 2 years as recommended on hstspreload.org.
ActionDispatch::SSL::HSTS_EXPIRES_IN = T.let(T.unsafe(nil), Integer)

ActionDispatch::SSL::PERMANENT_REDIRECT_REQUEST_METHODS = T.let(T.unsafe(nil), Array)
module ActionDispatch::Session; end

class ActionDispatch::Session::AbstractSecureStore < ::Rack::Session::Abstract::PersistedSecure
  include ::ActionDispatch::Session::Compatibility
  include ::ActionDispatch::Session::StaleSessionCheck
  include ::ActionDispatch::Session::SessionObject

  def generate_sid; end

  private

  def set_cookie(request, response, cookie); end
end

class ActionDispatch::Session::AbstractStore < ::Rack::Session::Abstract::Persisted
  include ::ActionDispatch::Session::Compatibility
  include ::ActionDispatch::Session::StaleSessionCheck
  include ::ActionDispatch::Session::SessionObject

  private

  def set_cookie(request, response, cookie); end
end

# A session store that uses an ActiveSupport::Cache::Store to store the sessions. This store is most useful
# if you don't store critical data in your sessions and you don't need them to live for extended periods
# of time.
#
# ==== Options
# * <tt>cache</tt>         - The cache to use. If it is not specified, <tt>Rails.cache</tt> will be used.
# * <tt>expire_after</tt>  - The length of time a session will be stored before automatically expiring.
#   By default, the <tt>:expires_in</tt> option of the cache is used.
class ActionDispatch::Session::CacheStore < ::ActionDispatch::Session::AbstractSecureStore
  # @return [CacheStore] a new instance of CacheStore
  def initialize(app, options = T.unsafe(nil)); end

  # Remove a session from the cache.
  def delete_session(env, sid, options); end

  # Get a session from the cache.
  def find_session(env, sid); end

  # Set a session in the cache.
  def write_session(env, sid, session, options); end

  private

  # Turn the session id into a cache key.
  def cache_key(id); end

  def get_session_with_fallback(sid); end
end

module ActionDispatch::Session::Compatibility
  def initialize(app, options = T.unsafe(nil)); end

  def generate_sid; end

  private

  def initialize_sid; end
  def make_request(env); end
end

# This cookie-based session store is the Rails default. It is
# dramatically faster than the alternatives.
#
# Sessions typically contain at most a user_id and flash message; both fit
# within the 4096 bytes cookie size limit. A CookieOverflow exception is raised if
# you attempt to store more than 4096 bytes of data.
#
# The cookie jar used for storage is automatically configured to be the
# best possible option given your application's configuration.
#
# Your cookies will be encrypted using your apps secret_key_base. This
# goes a step further than signed cookies in that encrypted cookies cannot
# be altered or read by users. This is the default starting in Rails 4.
#
# Configure your session store in an initializer:
#
#   Rails.application.config.session_store :cookie_store, key: '_your_app_session'
#
# In the development and test environments your application's secret key base is
# generated by Rails and stored in a temporary file in <tt>tmp/development_secret.txt</tt>.
# In all other environments, it is stored encrypted in the
# <tt>config/credentials.yml.enc</tt> file.
#
# If your application was not updated to Rails 5.2 defaults, the secret_key_base
# will be found in the old <tt>config/secrets.yml</tt> file.
#
# Note that changing your secret_key_base will invalidate all existing session.
# Additionally, you should take care to make sure you are not relying on the
# ability to decode signed cookies generated by your app in external
# applications or JavaScript before changing it.
#
# Because CookieStore extends Rack::Session::Abstract::Persisted, many of the
# options described there can be used to customize the session cookie that
# is generated. For example:
#
#   Rails.application.config.session_store :cookie_store, expire_after: 14.days
#
# would set the session cookie to expire automatically 14 days after creation.
# Other useful options include <tt>:key</tt>, <tt>:secure</tt> and
# <tt>:httponly</tt>.
class ActionDispatch::Session::CookieStore < ::ActionDispatch::Session::AbstractSecureStore
  # @return [CookieStore] a new instance of CookieStore
  def initialize(app, options = T.unsafe(nil)); end

  def delete_session(req, session_id, options); end
  def load_session(req); end

  private

  def cookie_jar(request); end
  def extract_session_id(req); end
  def get_cookie(req); end
  def persistent_session_id!(data, sid = T.unsafe(nil)); end
  def set_cookie(request, session_id, cookie); end
  def unpacked_cookie_data(req); end
  def write_session(req, sid, session_data, options); end
end

class ActionDispatch::Session::CookieStore::SessionId
  # @return [SessionId] a new instance of SessionId
  def initialize(session_id, cookie_value = T.unsafe(nil)); end

  # Returns the value of attribute cookie_value.
  def cookie_value; end
end

module ActionDispatch::Session::SessionObject
  # @return [Boolean]
  def loaded_session?(session); end

  def prepare_session(req); end
end

class ActionDispatch::Session::SessionRestoreError < ::StandardError
  # @return [SessionRestoreError] a new instance of SessionRestoreError
  def initialize; end
end

module ActionDispatch::Session::StaleSessionCheck
  def extract_session_id(env); end
  def load_session(env); end
  def stale_session_check!; end
end

# This middleware rescues any exception returned by the application
# and calls an exceptions app that will wrap it in a format for the end user.
#
# The exceptions app should be passed as parameter on initialization
# of ShowExceptions. Every time there is an exception, ShowExceptions will
# store the exception in env["action_dispatch.exception"], rewrite the
# PATH_INFO to the exception status code and call the Rack app.
#
# If the application returns a "X-Cascade" pass response, this middleware
# will send an empty response as result with the correct status code.
# If any exception happens inside the exceptions app, this middleware
# catches the exceptions and returns a FAILSAFE_RESPONSE.
class ActionDispatch::ShowExceptions
  # @return [ShowExceptions] a new instance of ShowExceptions
  def initialize(app, exceptions_app); end

  def call(env); end

  private

  def fallback_to_html_format_if_invalid_mime_type(request); end
  def pass_response(status); end
  def render_exception(request, exception); end
end

ActionDispatch::ShowExceptions::FAILSAFE_RESPONSE = T.let(T.unsafe(nil), Array)

# This middleware serves static files from disk, if available.
# If no file is found, it hands off to the main app.
#
# In Rails apps, this middleware is configured to serve assets from
# the +public/+ directory.
#
# Only GET and HEAD requests are served. POST and other HTTP methods
# are handed off to the main app.
#
# Only files in the root directory are served; path traversal is denied.
class ActionDispatch::Static
  # @return [Static] a new instance of Static
  def initialize(app, path, index: T.unsafe(nil), headers: T.unsafe(nil)); end

  def call(env); end
end

# = System Testing
#
# System tests let you test applications in the browser. Because system
# tests use a real browser experience, you can test all of your JavaScript
# easily from your test suite.
#
# To create a system test in your application, extend your test class
# from <tt>ApplicationSystemTestCase</tt>. System tests use Capybara as a
# base and allow you to configure the settings through your
# <tt>application_system_test_case.rb</tt> file that is generated with a new
# application or scaffold.
#
# Here is an example system test:
#
#   require "application_system_test_case"
#
#   class Users::CreateTest < ApplicationSystemTestCase
#     test "adding a new user" do
#       visit users_path
#       click_on 'New User'
#
#       fill_in 'Name', with: 'Arya'
#       click_on 'Create User'
#
#       assert_text 'Arya'
#     end
#   end
#
# When generating an application or scaffold, an +application_system_test_case.rb+
# file will also be generated containing the base class for system testing.
# This is where you can change the driver, add Capybara settings, and other
# configuration for your system tests.
#
#   require "test_helper"
#
#   class ApplicationSystemTestCase < ActionDispatch::SystemTestCase
#     driven_by :selenium, using: :chrome, screen_size: [1400, 1400]
#   end
#
# By default, <tt>ActionDispatch::SystemTestCase</tt> is driven by the
# Selenium driver, with the Chrome browser, and a browser size of 1400x1400.
#
# Changing the driver configuration options is easy. Let's say you want to use
# the Firefox browser instead of Chrome. In your +application_system_test_case.rb+
# file add the following:
#
#   require "test_helper"
#
#   class ApplicationSystemTestCase < ActionDispatch::SystemTestCase
#     driven_by :selenium, using: :firefox
#   end
#
# +driven_by+ has a required argument for the driver name. The keyword
# arguments are +:using+ for the browser and +:screen_size+ to change the
# size of the browser screen. These two options are not applicable for
# headless drivers and will be silently ignored if passed.
#
# Headless browsers such as headless Chrome and headless Firefox are also supported.
# You can use these browsers by setting the +:using+ argument to +:headless_chrome+ or +:headless_firefox+.
#
# To use a headless driver, like Poltergeist, update your Gemfile to use
# Poltergeist instead of Selenium and then declare the driver name in the
# +application_system_test_case.rb+ file. In this case, you would leave out
# the +:using+ option because the driver is headless, but you can still use
# +:screen_size+ to change the size of the browser screen, also you can use
# +:options+ to pass options supported by the driver. Please refer to your
# driver documentation to learn about supported options.
#
#   require "test_helper"
#   require "capybara/poltergeist"
#
#   class ApplicationSystemTestCase < ActionDispatch::SystemTestCase
#     driven_by :poltergeist, screen_size: [1400, 1400], options:
#       { js_errors: true }
#   end
#
# Some drivers require browser capabilities to be passed as a block instead
# of through the +options+ hash.
#
# As an example, if you want to add mobile emulation on chrome, you'll have to
# create an instance of selenium's +Chrome::Options+ object and add
# capabilities with a block.
#
# The block will be passed an instance of <tt><Driver>::Options</tt> where you can
# define the capabilities you want. Please refer to your driver documentation
# to learn about supported options.
#
#   class ApplicationSystemTestCase < ActionDispatch::SystemTestCase
#     driven_by :selenium, using: :chrome, screen_size: [1024, 768] do |driver_option|
#       driver_option.add_emulation(device_name: 'iPhone 6')
#       driver_option.add_extension('path/to/chrome_extension.crx')
#     end
#   end
#
# Because <tt>ActionDispatch::SystemTestCase</tt> is a shim between Capybara
# and Rails, any driver that is supported by Capybara is supported by system
# tests as long as you include the required gems and files.
class ActionDispatch::SystemTestCase < ::ActiveSupport::TestCase
  include ::Capybara::DSL
  include ::Capybara::Minitest::Assertions
  include ::ActionDispatch::SystemTesting::TestHelpers::SetupAndTeardown
  include ::ActionDispatch::SystemTesting::TestHelpers::ScreenshotHelper

  # @return [SystemTestCase] a new instance of SystemTestCase
  def initialize(*_arg0); end

  private

  def method_missing(name, *args, &block); end

  # @return [Boolean]
  def respond_to_missing?(name, include_private = T.unsafe(nil)); end

  def url_helpers; end

  class << self
    # System Test configuration options
    #
    # The default settings are Selenium, using Chrome, with a screen size
    # of 1400x1400.
    #
    # Examples:
    #
    #   driven_by :poltergeist
    #
    #   driven_by :selenium, screen_size: [800, 800]
    #
    #   driven_by :selenium, using: :chrome
    #
    #   driven_by :selenium, using: :headless_chrome
    #
    #   driven_by :selenium, using: :firefox
    #
    #   driven_by :selenium, using: :headless_firefox
    def driven_by(driver, using: T.unsafe(nil), screen_size: T.unsafe(nil), options: T.unsafe(nil), &capabilities); end

    def driver; end
    def driver=(value); end
    def driver?; end
    def start_application; end
  end
end

ActionDispatch::SystemTestCase::DEFAULT_HOST = T.let(T.unsafe(nil), String)
module ActionDispatch::SystemTesting; end

class ActionDispatch::SystemTesting::Browser
  # @return [Browser] a new instance of Browser
  def initialize(name); end

  # @yield [options]
  def configure; end

  # Returns the value of attribute name.
  def name; end

  # Returns the value of attribute options.
  def options; end

  # driver_path can be configured as a proc. The webdrivers gem uses this
  # proc to update web drivers. Running this proc early allows us to only
  # update the webdriver once and avoid race conditions when using
  # parallel tests.
  def preload; end

  def type; end

  private

  def initialize_options; end
  def set_default_options; end
  def set_headless_chrome_browser_options; end
  def set_headless_firefox_browser_options; end
end

class ActionDispatch::SystemTesting::Driver
  # @return [Driver] a new instance of Driver
  def initialize(name, **options, &capabilities); end

  def use; end

  private

  def browser_options; end
  def register; end
  def register_poltergeist(app); end
  def register_selenium(app); end
  def register_webkit(app); end

  # @return [Boolean]
  def registerable?; end

  def setup; end
end

class ActionDispatch::SystemTesting::Server
  def run; end

  private

  def set_port; end
  def set_server; end
  def setup; end

  class << self
    # Returns the value of attribute silence_puma.
    def silence_puma; end

    # Sets the attribute silence_puma
    #
    # @param value the value to set the attribute silence_puma to.
    def silence_puma=(_arg0); end
  end
end

module ActionDispatch::SystemTesting::TestHelpers; end

# Screenshot helper for system testing.
module ActionDispatch::SystemTesting::TestHelpers::ScreenshotHelper
  # Takes a screenshot of the current page in the browser if the test
  # failed.
  #
  # +take_failed_screenshot+ is included in <tt>application_system_test_case.rb</tt>
  # that is generated with the application. To take screenshots when a test
  # fails add +take_failed_screenshot+ to the teardown block before clearing
  # sessions.
  def take_failed_screenshot; end

  # Takes a screenshot of the current page in the browser.
  #
  # +take_screenshot+ can be used at any point in your system tests to take
  # a screenshot of the current state. This can be useful for debugging or
  # automating visual testing. You can take multiple screenshots per test
  # to investigate changes at different points during your test. These will be
  # named with a sequential prefix (or 'failed' for failing tests)
  #
  # The screenshot will be displayed in your console, if supported.
  #
  # You can set the +RAILS_SYSTEM_TESTING_SCREENSHOT_HTML+ environment variable to
  # save the HTML from the page that is being screenhoted so you can investigate the
  # elements on the page at the time of the screenshot
  #
  # You can set the +RAILS_SYSTEM_TESTING_SCREENSHOT+ environment variable to
  # control the output. Possible values are:
  # * [+simple+ (default)]    Only displays the screenshot path.
  #                           This is the default value.
  # * [+inline+]              Display the screenshot in the terminal using the
  #                           iTerm image protocol (https://iterm2.com/documentation-images.html).
  # * [+artifact+]            Display the screenshot in the terminal, using the terminal
  #                           artifact format (https://buildkite.github.io/terminal-to-html/inline-images/).
  def take_screenshot; end

  private

  # Returns the value of attribute _screenshot_counter.
  def _screenshot_counter; end

  # Sets the attribute _screenshot_counter
  #
  # @param value the value to set the attribute _screenshot_counter to.
  def _screenshot_counter=(_arg0); end

  def absolute_html_path; end
  def absolute_image_path; end
  def absolute_path; end
  def display_image; end

  # @return [Boolean]
  def failed?; end

  def html_path; end
  def image_name; end
  def image_path; end
  def increment_unique; end
  def inline_base64(path); end
  def output_type; end
  def save_html; end

  # @return [Boolean]
  def save_html?; end

  def save_image; end

  # @return [Boolean]
  def supports_screenshot?; end

  def unique; end
end

module ActionDispatch::SystemTesting::TestHelpers::SetupAndTeardown
  def after_teardown; end
  def before_teardown; end
  def host!(host); end
end

module ActionDispatch::TestProcess
  include ::ActionDispatch::TestProcess::FixtureFile

  # @raise [NoMethodError]
  def assigns(key = T.unsafe(nil)); end

  def cookies; end
  def flash; end
  def redirect_to_url; end
  def session; end
end

module ActionDispatch::TestProcess::FixtureFile
  # Shortcut for <tt>Rack::Test::UploadedFile.new(File.join(ActionDispatch::IntegrationTest.file_fixture_path, path), type)</tt>:
  #
  #   post :change_avatar, params: { avatar: fixture_file_upload('spongebob.png', 'image/png') }
  #
  # Default fixture files location is <tt>test/fixtures/files</tt>.
  #
  # To upload binary files on Windows, pass <tt>:binary</tt> as the last parameter.
  # This will not affect other platforms:
  #
  #   post :change_avatar, params: { avatar: fixture_file_upload('spongebob.png', 'image/png', :binary) }
  def fixture_file_upload(path, mime_type = T.unsafe(nil), binary = T.unsafe(nil)); end
end

class ActionDispatch::TestRequest < ::ActionDispatch::Request
  def accept=(mime_types); end
  def action=(action_name); end
  def host=(host); end
  def if_modified_since=(last_modified); end
  def if_none_match=(etag); end
  def path=(path); end
  def port=(number); end
  def remote_addr=(addr); end
  def request_method=(method); end
  def request_uri=(uri); end
  def user_agent=(user_agent); end

  class << self
    # Create a new test request with default +env+ values.
    def create(env = T.unsafe(nil)); end

    private

    def default_env; end
  end
end

ActionDispatch::TestRequest::DEFAULT_ENV = T.let(T.unsafe(nil), Hash)

# Integration test methods such as ActionDispatch::Integration::Session#get
# and ActionDispatch::Integration::Session#post return objects of class
# TestResponse, which represent the HTTP response results of the requested
# controller actions.
#
# See Response for more information on controller response objects.
class ActionDispatch::TestResponse < ::ActionDispatch::Response
  def parsed_body; end
  def response_parser; end

  class << self
    def from_response(response); end
  end
end

module ActionPack
  class << self
    # Returns the version of the currently loaded Action Pack as a <tt>Gem::Version</tt>
    def gem_version; end

    # Returns the version of the currently loaded ActionPack as a <tt>Gem::Version</tt>
    def version; end
  end
end

module ActionPack::VERSION; end
ActionPack::VERSION::MAJOR = T.let(T.unsafe(nil), Integer)
ActionPack::VERSION::MINOR = T.let(T.unsafe(nil), Integer)
ActionPack::VERSION::PRE = T.let(T.unsafe(nil), String)
ActionPack::VERSION::STRING = T.let(T.unsafe(nil), String)
ActionPack::VERSION::TINY = T.let(T.unsafe(nil), Integer)

module Mime
  class << self
    def [](type); end
    def fetch(type); end
  end
end

# ALL isn't a real MIME type, so we don't register it for lookup with the
# other concrete types. It's a wildcard match that we use for +respond_to+
# negotiation internals.
Mime::ALL = T.let(T.unsafe(nil), Mime::AllType)

class Mime::AllType < ::Mime::Type
  include ::Singleton
  extend ::Singleton::SingletonClassMethods

  # @return [AllType] a new instance of AllType
  def initialize; end

  # @return [Boolean]
  def all?; end

  # @return [Boolean]
  def html?; end
end

Mime::EXTENSION_LOOKUP = T.let(T.unsafe(nil), Hash)
Mime::LOOKUP = T.let(T.unsafe(nil), Hash)

class Mime::Mimes
  include ::Enumerable

  # @return [Mimes] a new instance of Mimes
  def initialize; end

  def <<(type); end
  def delete_if; end
  def each; end

  # Returns the value of attribute symbols.
  def symbols; end
end

class Mime::NullType
  include ::Singleton
  extend ::Singleton::SingletonClassMethods

  # @return [Boolean]
  def nil?; end

  def ref; end
  def to_s; end

  private

  def method_missing(method, *args); end

  # @return [Boolean]
  def respond_to_missing?(method, _); end
end

Mime::SET = T.let(T.unsafe(nil), Mime::Mimes)

# Encapsulates the notion of a MIME type. Can be used at render time, for example, with:
#
#   class PostsController < ActionController::Base
#     def show
#       @post = Post.find(params[:id])
#
#       respond_to do |format|
#         format.html
#         format.ics { render body: @post.to_ics, mime_type: Mime::Type.lookup("text/calendar")  }
#         format.xml { render xml: @post }
#       end
#     end
#   end
class Mime::Type
  # @return [Type] a new instance of Type
  def initialize(string, symbol = T.unsafe(nil), synonyms = T.unsafe(nil)); end

  def ==(mime_type); end
  def ===(list); end
  def =~(mime_type); end

  # @return [Boolean]
  def all?; end

  # @return [Boolean]
  def eql?(other); end

  # Returns the value of attribute hash.
  def hash; end

  # @return [Boolean]
  def html?; end

  # @return [Boolean]
  def match?(mime_type); end

  def ref; end

  # Returns the value of attribute symbol.
  def symbol; end

  def to_s; end
  def to_str; end
  def to_sym; end

  protected

  # Returns the value of attribute string.
  def string; end

  # Returns the value of attribute synonyms.
  def synonyms; end

  private

  def method_missing(method, *args); end

  # @return [Boolean]
  def respond_to_missing?(method, include_private = T.unsafe(nil)); end

  def to_a; end
  def to_ary; end

  class << self
    def lookup(string); end
    def lookup_by_extension(extension); end
    def parse(accept_header); end

    # For an input of <tt>'text'</tt>, returns <tt>[Mime[:json], Mime[:xml], Mime[:ics],
    # Mime[:html], Mime[:css], Mime[:csv], Mime[:js], Mime[:yaml], Mime[:text]</tt>.
    #
    # For an input of <tt>'application'</tt>, returns <tt>[Mime[:html], Mime[:js],
    # Mime[:xml], Mime[:yaml], Mime[:atom], Mime[:json], Mime[:rss], Mime[:url_encoded_form]</tt>.
    def parse_data_with_trailing_star(type); end

    def parse_trailing_star(accept_header); end
    def register(string, symbol, mime_type_synonyms = T.unsafe(nil), extension_synonyms = T.unsafe(nil), skip_lookup = T.unsafe(nil)); end

    # Registers an alias that's not used on MIME type lookup, but can be referenced directly. Especially useful for
    # rendering different HTML versions depending on the user agent, like an iPhone.
    def register_alias(string, symbol, extension_synonyms = T.unsafe(nil)); end

    def register_callback(&block); end

    # This method is opposite of register method.
    #
    # To unregister a MIME type:
    #
    #   Mime::Type.unregister(:mobile)
    def unregister(symbol); end
  end
end

# A simple helper class used in parsing the accept header.
class Mime::Type::AcceptItem
  # @return [AcceptItem] a new instance of AcceptItem
  def initialize(index, name, q = T.unsafe(nil)); end

  def <=>(item); end
  def index; end
  def index=(_arg0); end
  def name; end
  def name=(_arg0); end
  def q; end
  def q=(_arg0); end
  def to_s; end
end

class Mime::Type::AcceptList
  class << self
    def find_item_by_name(array, name); end
    def sort!(list); end
  end
end

class Mime::Type::InvalidMimeType < ::StandardError; end
Mime::Type::MIME_NAME = T.let(T.unsafe(nil), String)
Mime::Type::MIME_PARAMETER = T.let(T.unsafe(nil), String)
Mime::Type::MIME_PARAMETER_KEY = T.let(T.unsafe(nil), String)
Mime::Type::MIME_PARAMETER_VALUE = T.let(T.unsafe(nil), String)
Mime::Type::MIME_REGEXP = T.let(T.unsafe(nil), Regexp)

module Rack
  class << self
    def release; end
    def version; end
  end
end

Rack::CACHE_CONTROL = T.let(T.unsafe(nil), String)
Rack::CONTENT_LENGTH = T.let(T.unsafe(nil), String)
Rack::CONTENT_TYPE = T.let(T.unsafe(nil), String)
Rack::DELETE = T.let(T.unsafe(nil), String)
Rack::ETAG = T.let(T.unsafe(nil), String)
Rack::EXPIRES = T.let(T.unsafe(nil), String)
Rack::File = Rack::Files
Rack::GET = T.let(T.unsafe(nil), String)
Rack::HEAD = T.let(T.unsafe(nil), String)
Rack::HTTPS = T.let(T.unsafe(nil), String)
Rack::HTTP_COOKIE = T.let(T.unsafe(nil), String)
Rack::HTTP_HOST = T.let(T.unsafe(nil), String)
Rack::HTTP_PORT = T.let(T.unsafe(nil), String)
Rack::HTTP_VERSION = T.let(T.unsafe(nil), String)
Rack::LINK = T.let(T.unsafe(nil), String)
Rack::OPTIONS = T.let(T.unsafe(nil), String)
Rack::PATCH = T.let(T.unsafe(nil), String)
Rack::PATH_INFO = T.let(T.unsafe(nil), String)
Rack::POST = T.let(T.unsafe(nil), String)
Rack::PUT = T.let(T.unsafe(nil), String)
Rack::QUERY_STRING = T.let(T.unsafe(nil), String)
Rack::RACK_ERRORS = T.let(T.unsafe(nil), String)
Rack::RACK_HIJACK = T.let(T.unsafe(nil), String)
Rack::RACK_HIJACK_IO = T.let(T.unsafe(nil), String)
Rack::RACK_INPUT = T.let(T.unsafe(nil), String)
Rack::RACK_IS_HIJACK = T.let(T.unsafe(nil), String)
Rack::RACK_LOGGER = T.let(T.unsafe(nil), String)
Rack::RACK_METHODOVERRIDE_ORIGINAL_METHOD = T.let(T.unsafe(nil), String)
Rack::RACK_MULTIPART_BUFFER_SIZE = T.let(T.unsafe(nil), String)
Rack::RACK_MULTIPART_TEMPFILE_FACTORY = T.let(T.unsafe(nil), String)
Rack::RACK_MULTIPROCESS = T.let(T.unsafe(nil), String)
Rack::RACK_MULTITHREAD = T.let(T.unsafe(nil), String)
Rack::RACK_RECURSIVE_INCLUDE = T.let(T.unsafe(nil), String)
Rack::RACK_REQUEST_COOKIE_HASH = T.let(T.unsafe(nil), String)
Rack::RACK_REQUEST_COOKIE_STRING = T.let(T.unsafe(nil), String)
Rack::RACK_REQUEST_FORM_HASH = T.let(T.unsafe(nil), String)
Rack::RACK_REQUEST_FORM_INPUT = T.let(T.unsafe(nil), String)
Rack::RACK_REQUEST_FORM_VARS = T.let(T.unsafe(nil), String)
Rack::RACK_REQUEST_QUERY_HASH = T.let(T.unsafe(nil), String)
Rack::RACK_REQUEST_QUERY_STRING = T.let(T.unsafe(nil), String)
Rack::RACK_RUNONCE = T.let(T.unsafe(nil), String)
Rack::RACK_SESSION = T.let(T.unsafe(nil), String)
Rack::RACK_SESSION_OPTIONS = T.let(T.unsafe(nil), String)
Rack::RACK_SESSION_UNPACKED_COOKIE_DATA = T.let(T.unsafe(nil), String)
Rack::RACK_SHOWSTATUS_DETAIL = T.let(T.unsafe(nil), String)
Rack::RACK_TEMPFILES = T.let(T.unsafe(nil), String)
Rack::RACK_URL_SCHEME = T.let(T.unsafe(nil), String)
Rack::RACK_VERSION = T.let(T.unsafe(nil), String)
Rack::RELEASE = T.let(T.unsafe(nil), String)
Rack::REQUEST_METHOD = T.let(T.unsafe(nil), String)
Rack::REQUEST_PATH = T.let(T.unsafe(nil), String)
Rack::SCRIPT_NAME = T.let(T.unsafe(nil), String)
Rack::SERVER_NAME = T.let(T.unsafe(nil), String)
Rack::SERVER_PORT = T.let(T.unsafe(nil), String)
Rack::SERVER_PROTOCOL = T.let(T.unsafe(nil), String)
Rack::SET_COOKIE = T.let(T.unsafe(nil), String)
Rack::TRACE = T.let(T.unsafe(nil), String)
Rack::TRANSFER_ENCODING = T.let(T.unsafe(nil), String)
Rack::UNLINK = T.let(T.unsafe(nil), String)
Rack::VERSION = T.let(T.unsafe(nil), Array)
