# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `async-http` gem.
# Please instead update this file by running `bin/tapioca gem async-http`.

# source://async-http//lib/async/http/body/writable.rb#9
module Async; end

# source://async-http//lib/async/http/body/writable.rb#10
module Async::HTTP; end

# source://async-http//lib/async/http/body/writable.rb#11
module Async::HTTP::Body
  include ::Protocol::HTTP::Body
end

# source://async-http//lib/async/http/body/pipe.rb#15
class Async::HTTP::Body::Pipe
  # If the input stream is closed first, it's likely the output stream will also be closed.
  #
  # @return [Pipe] a new instance of Pipe
  #
  # source://async-http//lib/async/http/body/pipe.rb#17
  def initialize(input, output = T.unsafe(nil), task: T.unsafe(nil)); end

  # source://async-http//lib/async/http/body/pipe.rb#37
  def close; end

  # source://async-http//lib/async/http/body/pipe.rb#33
  def to_io; end

  private

  # source://async-http//lib/async/http/body/pipe.rb#80
  def close_head; end

  # Read from the @input stream and write to the head of the pipe.
  #
  # source://async-http//lib/async/http/body/pipe.rb#47
  def reader(task); end

  # Read from the head of the pipe and write to the @output stream.
  # If the @tail is closed, this will cause chunk to be nil, which in turn will call `@output.close` and `@head.close`
  #
  # source://async-http//lib/async/http/body/pipe.rb#66
  def writer(task); end
end

# A dynamic body which you can write to and read from.
#
# source://async-http//lib/async/http/body/writable.rb#15
class Async::HTTP::Body::Writable < ::Protocol::HTTP::Body::Readable
  # @param length [Integer] The length of the response body if known.
  # @param queue [Async::Queue] Specify a different queue implementation, e.g. `Async::LimitedQueue.new(8)` to enable back-pressure streaming.
  # @return [Writable] a new instance of Writable
  #
  # source://async-http//lib/async/http/body/writable.rb#21
  def initialize(length = T.unsafe(nil), queue: T.unsafe(nil)); end

  # Write a single chunk to the body. Signal completion by calling `#finish`.
  #
  # source://async-http//lib/async/http/body/writable.rb#75
  def <<(chunk); end

  # Stop generating output; cause the next call to write to fail with the given error.
  #
  # source://async-http//lib/async/http/body/writable.rb#39
  def close(error = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://async-http//lib/async/http/body/writable.rb#50
  def closed?; end

  # Has the producer called #finish and has the reader consumed the nil token?
  #
  # @return [Boolean]
  #
  # source://async-http//lib/async/http/body/writable.rb#59
  def empty?; end

  # source://async-http//lib/async/http/body/writable.rb#88
  def inspect; end

  # source://async-http//lib/async/http/body/writable.rb#34
  def length; end

  # Read the next available chunk.
  #
  # source://async-http//lib/async/http/body/writable.rb#64
  def read; end

  # @return [Boolean]
  #
  # source://async-http//lib/async/http/body/writable.rb#54
  def ready?; end

  # Write a single chunk to the body. Signal completion by calling `#finish`.
  #
  # source://async-http//lib/async/http/body/writable.rb#75
  def write(chunk); end

  private

  # source://async-http//lib/async/http/body/writable.rb#94
  def status; end
end

# source://async-http//lib/async/http/body/writable.rb#16
class Async::HTTP::Body::Writable::Closed < ::StandardError; end

# source://async-http//lib/async/http/client.rb#24
class Async::HTTP::Client < ::Protocol::HTTP::Methods
  include ::Async::HTTP::Proxy::Client

  # Provides a robust interface to a server.
  # * If there are no connections, it will create one.
  # * If there are already connections, it will reuse it.
  # * If a request fails, it will retry it up to N times if it was idempotent.
  # The client object will never become unusable. It internally manages persistent connections (or non-persistent connections if that's required).
  #
  # @param endpoint [Endpoint] the endpoint to connnect to.
  # @param protocol [Protocol::HTTP1 | Protocol::HTTP2 | Protocol::HTTPS] the protocol to use.
  # @param scheme [String] The default scheme to set to requests.
  # @param authority [String] The default authority to set to requests.
  # @return [Client] a new instance of Client
  #
  # source://async-http//lib/async/http/client.rb#34
  def initialize(endpoint, protocol: T.unsafe(nil), scheme: T.unsafe(nil), authority: T.unsafe(nil), retries: T.unsafe(nil), connection_limit: T.unsafe(nil)); end

  # Returns the value of attribute authority.
  #
  # source://async-http//lib/async/http/client.rb#52
  def authority; end

  # source://async-http//lib/async/http/client.rb#79
  def call(request); end

  # source://async-http//lib/async/http/client.rb#70
  def close; end

  # Returns the value of attribute endpoint.
  #
  # source://async-http//lib/async/http/client.rb#45
  def endpoint; end

  # source://async-http//lib/async/http/client.rb#126
  def inspect; end

  # Returns the value of attribute pool.
  #
  # source://async-http//lib/async/http/client.rb#49
  def pool; end

  # Returns the value of attribute protocol.
  #
  # source://async-http//lib/async/http/client.rb#46
  def protocol; end

  # Returns the value of attribute retries.
  #
  # source://async-http//lib/async/http/client.rb#48
  def retries; end

  # Returns the value of attribute scheme.
  #
  # source://async-http//lib/async/http/client.rb#51
  def scheme; end

  # @return [Boolean]
  #
  # source://async-http//lib/async/http/client.rb#54
  def secure?; end

  protected

  # source://async-http//lib/async/http/client.rb#179
  def make_pool(connection_limit); end

  # source://async-http//lib/async/http/client.rb#168
  def make_response(request, connection); end

  class << self
    # source://async-http//lib/async/http/client.rb#58
    def open(*arguments, **options, &block); end
  end
end

# source://async-http//lib/async/http/client.rb#22
Async::HTTP::DEFAULT_CONNECTION_LIMIT = T.let(T.unsafe(nil), T.untyped)

# source://async-http//lib/async/http/client.rb#21
Async::HTTP::DEFAULT_RETRIES = T.let(T.unsafe(nil), Integer)

# Represents a way to connect to a remote HTTP server.
#
# source://async-http//lib/async/http/endpoint.rb#17
class Async::HTTP::Endpoint < ::Async::IO::Endpoint
  # @option hostname
  # @option scheme
  # @option port
  # @option ssl_context
  # @option alpn_protocols
  # @param hostname [Hash] a customizable set of options
  # @param scheme [Hash] a customizable set of options
  # @param port [Hash] a customizable set of options
  # @param ssl_context [Hash] a customizable set of options
  # @param alpn_protocols [Hash] a customizable set of options
  # @raise [ArgumentError]
  # @return [Endpoint] a new instance of Endpoint
  #
  # source://async-http//lib/async/http/endpoint.rb#40
  def initialize(url, endpoint = T.unsafe(nil), **options); end

  # source://async-http//lib/async/http/endpoint.rb#74
  def address; end

  # source://async-http//lib/async/http/endpoint.rb#132
  def alpn_protocols; end

  # source://async-http//lib/async/http/endpoint.rb#113
  def authority(ignore_default_port = T.unsafe(nil)); end

  # source://async-http//lib/async/http/endpoint.rb#184
  def bind(*arguments, &block); end

  # source://async-http//lib/async/http/endpoint.rb#161
  def build_endpoint(endpoint = T.unsafe(nil)); end

  # source://async-http//lib/async/http/endpoint.rb#188
  def connect(&block); end

  # source://async-http//lib/async/http/endpoint.rb#92
  def default_port; end

  # @return [Boolean]
  #
  # source://async-http//lib/async/http/endpoint.rb#96
  def default_port?; end

  # source://async-http//lib/async/http/endpoint.rb#192
  def each; end

  # source://async-http//lib/async/http/endpoint.rb#176
  def endpoint; end

  # source://async-http//lib/async/http/endpoint.rb#180
  def endpoint=(endpoint); end

  # @return [Boolean]
  #
  # source://async-http//lib/async/http/endpoint.rb#204
  def eql?(other); end

  # source://async-http//lib/async/http/endpoint.rb#208
  def hash; end

  # The hostname is the server we are connecting to:
  #
  # source://async-http//lib/async/http/endpoint.rb#105
  def hostname; end

  # source://async-http//lib/async/http/endpoint.rb#68
  def inspect; end

  # source://async-http//lib/async/http/endpoint.rb#200
  def key; end

  # @return [Boolean]
  #
  # source://async-http//lib/async/http/endpoint.rb#136
  def localhost?; end

  # Return the path and query components of the given URL.
  #
  # source://async-http//lib/async/http/endpoint.rb#122
  def path; end

  # source://async-http//lib/async/http/endpoint.rb#100
  def port; end

  # source://async-http//lib/async/http/endpoint.rb#82
  def protocol; end

  # source://async-http//lib/async/http/endpoint.rb#109
  def scheme; end

  # @return [Boolean]
  #
  # source://async-http//lib/async/http/endpoint.rb#78
  def secure?; end

  # source://async-http//lib/async/http/endpoint.rb#149
  def ssl_context; end

  # We don't try to validate peer certificates when talking to localhost because they would always be self-signed.
  #
  # source://async-http//lib/async/http/endpoint.rb#141
  def ssl_verify_mode; end

  # source://async-http//lib/async/http/endpoint.rb#64
  def to_s; end

  # source://async-http//lib/async/http/endpoint.rb#54
  def to_url; end

  # Returns the value of attribute url.
  #
  # source://async-http//lib/async/http/endpoint.rb#72
  def url; end

  protected

  # source://async-http//lib/async/http/endpoint.rb#227
  def tcp_endpoint; end

  # source://async-http//lib/async/http/endpoint.rb#214
  def tcp_options; end

  class << self
    # Construct an endpoint with a specified scheme, hostname, optional path, and options.
    #
    # source://async-http//lib/async/http/endpoint.rb#25
    def for(scheme, hostname, path = T.unsafe(nil), **options); end

    # source://async-http//lib/async/http/endpoint.rb#18
    def parse(string, endpoint = T.unsafe(nil), **options); end
  end
end

# A protocol specifies a way in which to communicate with a remote peer.
#
# source://async-http//lib/async/http/protocol/request.rb#13
module Async::HTTP::Protocol; end

# source://async-http//lib/async/http/protocol/http1/request.rb#11
module Async::HTTP::Protocol::HTTP1
  class << self
    # @return [Boolean]
    #
    # source://async-http//lib/async/http/protocol/http1.rb#15
    def bidirectional?; end

    # source://async-http//lib/async/http/protocol/http1.rb#23
    def client(peer); end

    # source://async-http//lib/async/http/protocol/http1.rb#35
    def names; end

    # source://async-http//lib/async/http/protocol/http1.rb#29
    def server(peer); end

    # @return [Boolean]
    #
    # source://async-http//lib/async/http/protocol/http1.rb#19
    def trailer?; end
  end
end

# source://async-http//lib/async/http/protocol/http10.rb#11
module Async::HTTP::Protocol::HTTP10
  class << self
    # @return [Boolean]
    #
    # source://async-http//lib/async/http/protocol/http10.rb#14
    def bidirectional?; end

    # source://async-http//lib/async/http/protocol/http10.rb#22
    def client(peer); end

    # source://async-http//lib/async/http/protocol/http10.rb#34
    def names; end

    # source://async-http//lib/async/http/protocol/http10.rb#28
    def server(peer); end

    # @return [Boolean]
    #
    # source://async-http//lib/async/http/protocol/http10.rb#18
    def trailer?; end
  end
end

# source://async-http//lib/async/http/protocol/http10.rb#12
Async::HTTP::Protocol::HTTP10::VERSION = T.let(T.unsafe(nil), String)

# source://async-http//lib/async/http/protocol/http11.rb#12
module Async::HTTP::Protocol::HTTP11
  class << self
    # @return [Boolean]
    #
    # source://async-http//lib/async/http/protocol/http11.rb#15
    def bidirectional?; end

    # source://async-http//lib/async/http/protocol/http11.rb#23
    def client(peer); end

    # source://async-http//lib/async/http/protocol/http11.rb#35
    def names; end

    # source://async-http//lib/async/http/protocol/http11.rb#29
    def server(peer); end

    # @return [Boolean]
    #
    # source://async-http//lib/async/http/protocol/http11.rb#19
    def trailer?; end
  end
end

# source://async-http//lib/async/http/protocol/http11.rb#13
Async::HTTP::Protocol::HTTP11::VERSION = T.let(T.unsafe(nil), String)

# source://async-http//lib/async/http/protocol/http1/client.rb#12
class Async::HTTP::Protocol::HTTP1::Client < ::Async::HTTP::Protocol::HTTP1::Connection
  # Used by the client to send requests to the remote server.
  #
  # source://async-http//lib/async/http/protocol/http1/client.rb#14
  def call(request, task: T.unsafe(nil)); end
end

# source://async-http//lib/async/http/protocol/http1/connection.rb#15
class Async::HTTP::Protocol::HTTP1::Connection < ::Protocol::HTTP1::Connection
  # @return [Connection] a new instance of Connection
  #
  # source://async-http//lib/async/http/protocol/http1/connection.rb#16
  def initialize(stream, version); end

  # source://async-http//lib/async/http/protocol/http1/connection.rb#47
  def concurrency; end

  # Returns the value of attribute count.
  #
  # source://async-http//lib/async/http/protocol/http1/connection.rb#45
  def count; end

  # @return [Boolean]
  #
  # source://async-http//lib/async/http/protocol/http1/connection.rb#25
  def http1?; end

  # @return [Boolean]
  #
  # source://async-http//lib/async/http/protocol/http1/connection.rb#29
  def http2?; end

  # source://async-http//lib/async/http/protocol/http1/connection.rb#41
  def peer; end

  # source://async-http//lib/async/http/protocol/http1/connection.rb#37
  def read_line; end

  # @return [Boolean]
  #
  # source://async-http//lib/async/http/protocol/http1/connection.rb#33
  def read_line?; end

  # @return [Boolean]
  #
  # source://async-http//lib/async/http/protocol/http1/connection.rb#56
  def reusable?; end

  # Returns the value of attribute version.
  #
  # source://async-http//lib/async/http/protocol/http1/connection.rb#23
  def version; end

  # Can we use this connection to make requests?
  #
  # @return [Boolean]
  #
  # source://async-http//lib/async/http/protocol/http1/connection.rb#52
  def viable?; end
end

# source://async-http//lib/async/http/protocol/http1/request.rb#12
class Async::HTTP::Protocol::HTTP1::Request < ::Async::HTTP::Protocol::Request
  # @return [Request] a new instance of Request
  #
  # source://async-http//lib/async/http/protocol/http1/request.rb#21
  def initialize(connection, authority, method, path, version, headers, body); end

  # source://async-http//lib/async/http/protocol/http1/request.rb#30
  def connection; end

  # source://async-http//lib/async/http/protocol/http1/request.rb#38
  def hijack!; end

  # @return [Boolean]
  #
  # source://async-http//lib/async/http/protocol/http1/request.rb#34
  def hijack?; end

  # source://async-http//lib/async/http/protocol/http1/request.rb#42
  def write_interim_response(response); end

  class << self
    # source://async-http//lib/async/http/protocol/http1/request.rb#13
    def read(connection); end
  end
end

# source://async-http//lib/async/http/protocol/http1/request.rb#19
Async::HTTP::Protocol::HTTP1::Request::UPGRADE = T.let(T.unsafe(nil), String)

# source://async-http//lib/async/http/protocol/http1/response.rb#12
class Async::HTTP::Protocol::HTTP1::Response < ::Async::HTTP::Protocol::Response
  # @return [Response] a new instance of Response
  #
  # source://async-http//lib/async/http/protocol/http1/response.rb#29
  def initialize(connection, version, status, reason, headers, body); end

  # source://async-http//lib/async/http/protocol/http1/response.rb#38
  def connection; end

  # source://async-http//lib/async/http/protocol/http1/response.rb#46
  def hijack!; end

  # @return [Boolean]
  #
  # source://async-http//lib/async/http/protocol/http1/response.rb#42
  def hijack?; end

  # Returns the value of attribute reason.
  #
  # source://async-http//lib/async/http/protocol/http1/response.rb#26
  def reason; end

  class << self
    # source://async-http//lib/async/http/protocol/http1/response.rb#13
    def read(connection, request); end
  end
end

# source://async-http//lib/async/http/protocol/http1/response.rb#23
Async::HTTP::Protocol::HTTP1::Response::UPGRADE = T.let(T.unsafe(nil), String)

# source://async-http//lib/async/http/protocol/http1/server.rb#14
class Async::HTTP::Protocol::HTTP1::Server < ::Async::HTTP::Protocol::HTTP1::Connection
  # Server loop.
  #
  # source://async-http//lib/async/http/protocol/http1/server.rb#46
  def each(task: T.unsafe(nil)); end

  # source://async-http//lib/async/http/protocol/http1/server.rb#15
  def fail_request(status); end

  # source://async-http//lib/async/http/protocol/http1/server.rb#23
  def next_request; end
end

# source://async-http//lib/async/http/protocol/http1.rb#13
Async::HTTP::Protocol::HTTP1::VERSION = T.let(T.unsafe(nil), String)

# source://async-http//lib/async/http/protocol/http2/input.rb#11
module Async::HTTP::Protocol::HTTP2
  class << self
    # @return [Boolean]
    #
    # source://async-http//lib/async/http/protocol/http2.rb#15
    def bidirectional?; end

    # source://async-http//lib/async/http/protocol/http2.rb#37
    def client(peer, settings = T.unsafe(nil)); end

    # source://async-http//lib/async/http/protocol/http2.rb#59
    def names; end

    # source://async-http//lib/async/http/protocol/http2.rb#48
    def server(peer, settings = T.unsafe(nil)); end

    # @return [Boolean]
    #
    # source://async-http//lib/async/http/protocol/http2.rb#19
    def trailer?; end
  end
end

# source://async-http//lib/async/http/protocol/http2/connection.rb#19
Async::HTTP::Protocol::HTTP2::AUTHORITY = T.let(T.unsafe(nil), String)

# source://async-http//lib/async/http/protocol/http2.rb#23
Async::HTTP::Protocol::HTTP2::CLIENT_SETTINGS = T.let(T.unsafe(nil), Hash)

# source://async-http//lib/async/http/protocol/http2/connection.rb#24
Async::HTTP::Protocol::HTTP2::CONNECTION = T.let(T.unsafe(nil), String)

# source://async-http//lib/async/http/protocol/http2/connection.rb#23
Async::HTTP::Protocol::HTTP2::CONTENT_LENGTH = T.let(T.unsafe(nil), String)

# source://async-http//lib/async/http/protocol/http2/client.rb#15
class Async::HTTP::Protocol::HTTP2::Client < ::Protocol::HTTP2::Client
  include ::Async::HTTP::Protocol::HTTP2::Connection

  # @return [Client] a new instance of Client
  #
  # source://async-http//lib/async/http/protocol/http2/client.rb#18
  def initialize(stream); end

  # Used by the client to send requests to the remote server.
  #
  # @raise [::Protocol::HTTP2::Error]
  #
  # source://async-http//lib/async/http/protocol/http2/client.rb#31
  def call(request); end

  # source://async-http//lib/async/http/protocol/http2/client.rb#26
  def create_response; end
end

# source://async-http//lib/async/http/protocol/http2/connection.rb#27
module Async::HTTP::Protocol::HTTP2::Connection
  # source://async-http//lib/async/http/protocol/http2/connection.rb#28
  def initialize(*_arg0); end

  # source://async-http//lib/async/http/protocol/http2/connection.rb#56
  def close(error = T.unsafe(nil)); end

  # source://async-http//lib/async/http/protocol/http2/connection.rb#123
  def concurrency; end

  # Returns the value of attribute count.
  #
  # source://async-http//lib/async/http/protocol/http2/connection.rb#121
  def count; end

  # @return [Boolean]
  #
  # source://async-http//lib/async/http/protocol/http2/connection.rb#44
  def http1?; end

  # @return [Boolean]
  #
  # source://async-http//lib/async/http/protocol/http2/connection.rb#48
  def http2?; end

  # source://async-http//lib/async/http/protocol/http2/connection.rb#117
  def peer; end

  # Returns the value of attribute promises.
  #
  # source://async-http//lib/async/http/protocol/http2/connection.rb#115
  def promises; end

  # @raise [RuntimeError]
  #
  # source://async-http//lib/async/http/protocol/http2/connection.rb#84
  def read_in_background(parent: T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://async-http//lib/async/http/protocol/http2/connection.rb#132
  def reusable?; end

  # source://async-http//lib/async/http/protocol/http2/connection.rb#52
  def start_connection; end

  # Returns the value of attribute stream.
  #
  # source://async-http//lib/async/http/protocol/http2/connection.rb#42
  def stream; end

  # source://async-http//lib/async/http/protocol/http2/connection.rb#38
  def to_s; end

  # source://async-http//lib/async/http/protocol/http2/connection.rb#136
  def version; end

  # Can we use this connection to make requests?
  #
  # @return [Boolean]
  #
  # source://async-http//lib/async/http/protocol/http2/connection.rb#128
  def viable?; end

  # source://async-http//lib/async/http/protocol/http2/connection.rb#67
  def write_frame(frame); end

  # source://async-http//lib/async/http/protocol/http2/connection.rb#76
  def write_frames(&block); end
end

# source://async-http//lib/async/http/protocol/http2/connection.rb#15
Async::HTTP::Protocol::HTTP2::HTTPS = T.let(T.unsafe(nil), String)

# A writable body which requests window updates when data is read from it.
#
# source://async-http//lib/async/http/protocol/http2/input.rb#13
class Async::HTTP::Protocol::HTTP2::Input < ::Async::HTTP::Body::Writable
  # @return [Input] a new instance of Input
  #
  # source://async-http//lib/async/http/protocol/http2/input.rb#14
  def initialize(stream, length); end

  # source://async-http//lib/async/http/protocol/http2/input.rb#21
  def read; end
end

# source://async-http//lib/async/http/protocol/http2/connection.rb#17
Async::HTTP::Protocol::HTTP2::METHOD = T.let(T.unsafe(nil), String)

# source://async-http//lib/async/http/protocol/http2/output.rb#12
class Async::HTTP::Protocol::HTTP2::Output
  # @return [Output] a new instance of Output
  #
  # source://async-http//lib/async/http/protocol/http2/output.rb#13
  def initialize(stream, body, trailer = T.unsafe(nil)); end

  # This method should only be called from within the context of the output task.
  #
  # source://async-http//lib/async/http/protocol/http2/output.rb#54
  def close(error = T.unsafe(nil)); end

  # source://async-http//lib/async/http/protocol/http2/output.rb#25
  def start(parent: T.unsafe(nil)); end

  # This method should only be called from within the context of the HTTP/2 stream.
  #
  # source://async-http//lib/async/http/protocol/http2/output.rb#62
  def stop(error); end

  # Returns the value of attribute trailer.
  #
  # source://async-http//lib/async/http/protocol/http2/output.rb#23
  def trailer; end

  # source://async-http//lib/async/http/protocol/http2/output.rb#35
  def window_updated(size); end

  # source://async-http//lib/async/http/protocol/http2/output.rb#39
  def write(chunk); end

  private

  # Reads chunks from the given body and writes them to the stream as fast as possible.
  #
  # source://async-http//lib/async/http/protocol/http2/output.rb#80
  def passthrough(task); end

  # Send `maximum_size` bytes of data using the specified `stream`. If the buffer has no more chunks, `END_STREAM` will be sent on the final chunk.
  #
  # @param maximum_size [Integer] send up to this many bytes of data.
  # @param stream [Stream] the stream to use for sending data frames.
  # @return [String, nil] any data that could not be written.
  #
  # source://async-http//lib/async/http/protocol/http2/output.rb#100
  def send_data(chunk, maximum_size); end

  # source://async-http//lib/async/http/protocol/http2/output.rb#69
  def stream(task); end
end

# source://async-http//lib/async/http/protocol/http2/connection.rb#18
Async::HTTP::Protocol::HTTP2::PATH = T.let(T.unsafe(nil), String)

# source://async-http//lib/async/http/protocol/http2/connection.rb#21
Async::HTTP::Protocol::HTTP2::PROTOCOL = T.let(T.unsafe(nil), String)

# Typically used on the server side to represent an incoming request, and write the response.
#
# source://async-http//lib/async/http/protocol/http2/request.rb#14
class Async::HTTP::Protocol::HTTP2::Request < ::Async::HTTP::Protocol::Request
  # @return [Request] a new instance of Request
  #
  # source://async-http//lib/async/http/protocol/http2/request.rb#87
  def initialize(stream); end

  # source://async-http//lib/async/http/protocol/http2/request.rb#95
  def connection; end

  # @return [Boolean]
  #
  # source://async-http//lib/async/http/protocol/http2/request.rb#103
  def hijack?; end

  # source://async-http//lib/async/http/protocol/http2/request.rb#111
  def send_response(response); end

  # Returns the value of attribute stream.
  #
  # source://async-http//lib/async/http/protocol/http2/request.rb#93
  def stream; end

  # @return [Boolean]
  #
  # source://async-http//lib/async/http/protocol/http2/request.rb#99
  def valid?; end

  # source://async-http//lib/async/http/protocol/http2/request.rb#145
  def write_interim_response(response); end
end

# source://async-http//lib/async/http/protocol/http2/request.rb#107
Async::HTTP::Protocol::HTTP2::Request::NO_RESPONSE = T.let(T.unsafe(nil), Array)

# source://async-http//lib/async/http/protocol/http2/request.rb#15
class Async::HTTP::Protocol::HTTP2::Request::Stream < ::Async::HTTP::Protocol::HTTP2::Stream
  # @return [Stream] a new instance of Stream
  #
  # source://async-http//lib/async/http/protocol/http2/request.rb#16
  def initialize(*_arg0); end

  # source://async-http//lib/async/http/protocol/http2/request.rb#80
  def closed(error); end

  # source://async-http//lib/async/http/protocol/http2/request.rb#25
  def receive_initial_headers(headers, end_stream); end

  # Returns the value of attribute request.
  #
  # source://async-http//lib/async/http/protocol/http2/request.rb#23
  def request; end
end

# Typically used on the client side for writing a request and reading the incoming response.
#
# source://async-http//lib/async/http/protocol/http2/response.rb#14
class Async::HTTP::Protocol::HTTP2::Response < ::Async::HTTP::Protocol::Response
  # @return [Response] a new instance of Response
  #
  # source://async-http//lib/async/http/protocol/http2/response.rb#108
  def initialize(stream); end

  # source://async-http//lib/async/http/protocol/http2/response.rb#134
  def build_request(headers); end

  # source://async-http//lib/async/http/protocol/http2/response.rb#118
  def connection; end

  # @return [Boolean]
  #
  # source://async-http//lib/async/http/protocol/http2/response.rb#126
  def head?; end

  # Returns the value of attribute request.
  #
  # source://async-http//lib/async/http/protocol/http2/response.rb#116
  def request; end

  # Send a request and read it into this response.
  #
  # source://async-http//lib/async/http/protocol/http2/response.rb#167
  def send_request(request); end

  # Returns the value of attribute stream.
  #
  # source://async-http//lib/async/http/protocol/http2/response.rb#115
  def stream; end

  # @return [Boolean]
  #
  # source://async-http//lib/async/http/protocol/http2/response.rb#130
  def valid?; end

  # source://async-http//lib/async/http/protocol/http2/response.rb#122
  def wait; end
end

# source://async-http//lib/async/http/protocol/http2/response.rb#15
class Async::HTTP::Protocol::HTTP2::Response::Stream < ::Async::HTTP::Protocol::HTTP2::Stream
  # @return [Stream] a new instance of Stream
  #
  # source://async-http//lib/async/http/protocol/http2/response.rb#16
  def initialize(*_arg0); end

  # @raise [ProtocolError]
  #
  # source://async-http//lib/async/http/protocol/http2/response.rb#35
  def accept_push_promise_stream(promised_stream_id, headers); end

  # source://async-http//lib/async/http/protocol/http2/response.rb#95
  def closed(error); end

  # Notify anyone waiting on the response headers to be received (or failure).
  #
  # source://async-http//lib/async/http/protocol/http2/response.rb#78
  def notify!; end

  # This should be invoked from the background reader, and notifies the task waiting for the headers that we are done.
  #
  # source://async-http//lib/async/http/protocol/http2/response.rb#40
  def receive_initial_headers(headers, end_stream); end

  # Returns the value of attribute response.
  #
  # source://async-http//lib/async/http/protocol/http2/response.rb#25
  def response; end

  # Wait for the headers to be received or for stream reset.
  #
  # source://async-http//lib/async/http/protocol/http2/response.rb#86
  def wait; end

  # source://async-http//lib/async/http/protocol/http2/response.rb#27
  def wait_for_input; end
end

# source://async-http//lib/async/http/protocol/http2/connection.rb#16
Async::HTTP::Protocol::HTTP2::SCHEME = T.let(T.unsafe(nil), String)

# source://async-http//lib/async/http/protocol/http2.rb#29
Async::HTTP::Protocol::HTTP2::SERVER_SETTINGS = T.let(T.unsafe(nil), Hash)

# source://async-http//lib/async/http/protocol/http2/connection.rb#20
Async::HTTP::Protocol::HTTP2::STATUS = T.let(T.unsafe(nil), String)

# source://async-http//lib/async/http/protocol/http2/server.rb#15
class Async::HTTP::Protocol::HTTP2::Server < ::Protocol::HTTP2::Server
  include ::Async::HTTP::Protocol::HTTP2::Connection

  # @return [Server] a new instance of Server
  #
  # source://async-http//lib/async/http/protocol/http2/server.rb#18
  def initialize(stream); end

  # source://async-http//lib/async/http/protocol/http2/server.rb#31
  def accept_stream(stream_id); end

  # source://async-http//lib/async/http/protocol/http2/server.rb#37
  def close(error = T.unsafe(nil)); end

  # source://async-http//lib/async/http/protocol/http2/server.rb#47
  def each(task: T.unsafe(nil)); end

  # Returns the value of attribute requests.
  #
  # source://async-http//lib/async/http/protocol/http2/server.rb#29
  def requests; end
end

# source://async-http//lib/async/http/protocol/http2/stream.rb#16
class Async::HTTP::Protocol::HTTP2::Stream < ::Protocol::HTTP2::Stream
  # @return [Stream] a new instance of Stream
  #
  # source://async-http//lib/async/http/protocol/http2/stream.rb#17
  def initialize(*_arg0); end

  # source://async-http//lib/async/http/protocol/http2/stream.rb#34
  def add_header(key, value); end

  # When the stream transitions to the closed state, this method is called. There are roughly two ways this can happen:
  # - A frame is received which causes this stream to enter the closed state. This method will be invoked from the background reader task.
  # - A frame is sent which causes this stream to enter the closed state. This method will be invoked from that task.
  # While the input stream is relatively straight forward, the output stream can trigger the second case above
  #
  # source://async-http//lib/async/http/protocol/http2/stream.rb#148
  def closed(error); end

  # Called when the output terminates normally.
  #
  # source://async-http//lib/async/http/protocol/http2/stream.rb#121
  def finish_output(error = T.unsafe(nil)); end

  # Returns the value of attribute headers.
  #
  # source://async-http//lib/async/http/protocol/http2/stream.rb#30
  def headers; end

  # Sets the attribute headers
  #
  # @param value the value to set the attribute headers to.
  #
  # source://async-http//lib/async/http/protocol/http2/stream.rb#30
  def headers=(_arg0); end

  # Returns the value of attribute input.
  #
  # source://async-http//lib/async/http/protocol/http2/stream.rb#32
  def input; end

  # Prepare the input stream which will be used for incoming data frames.
  #
  # @return [Input] the input body.
  #
  # source://async-http//lib/async/http/protocol/http2/stream.rb#77
  def prepare_input(length); end

  # source://async-http//lib/async/http/protocol/http2/stream.rb#92
  def process_data(frame); end

  # source://async-http//lib/async/http/protocol/http2/stream.rb#52
  def process_headers(frame); end

  # source://async-http//lib/async/http/protocol/http2/stream.rb#46
  def receive_trailing_headers(headers, end_stream); end

  # Set the body and begin sending it.
  #
  # source://async-http//lib/async/http/protocol/http2/stream.rb#114
  def send_body(body, trailer = T.unsafe(nil)); end

  # source://async-http//lib/async/http/protocol/http2/stream.rb#85
  def update_local_window(frame); end

  # source://async-http//lib/async/http/protocol/http2/stream.rb#71
  def wait_for_input; end

  # source://async-http//lib/async/http/protocol/http2/stream.rb#138
  def window_updated(size); end
end

# source://async-http//lib/async/http/protocol/http2/connection.rb#25
Async::HTTP::Protocol::HTTP2::TRAILER = T.let(T.unsafe(nil), String)

# source://async-http//lib/async/http/protocol/http2.rb#13
Async::HTTP::Protocol::HTTP2::VERSION = T.let(T.unsafe(nil), String)

# A server that supports both HTTP1.0 and HTTP1.1 semantics by detecting the version of the request.
#
# source://async-http//lib/async/http/protocol/https.rb#34
module Async::HTTP::Protocol::HTTPS
  class << self
    # source://async-http//lib/async/http/protocol/https.rb#55
    def client(peer); end

    # Supported Application Layer Protocol Negotiation names:
    #
    # source://async-http//lib/async/http/protocol/https.rb#64
    def names; end

    # source://async-http//lib/async/http/protocol/https.rb#42
    def protocol_for(peer); end

    # source://async-http//lib/async/http/protocol/https.rb#59
    def server(peer); end
  end
end

# source://async-http//lib/async/http/protocol/https.rb#35
Async::HTTP::Protocol::HTTPS::HANDLERS = T.let(T.unsafe(nil), Hash)

# This is generated by server protocols.
#
# source://async-http//lib/async/http/protocol/request.rb#19
class Async::HTTP::Protocol::Request < ::Protocol::HTTP::Request
  # source://async-http//lib/async/http/protocol/request.rb#20
  def connection; end

  # @return [Boolean]
  #
  # source://async-http//lib/async/http/protocol/request.rb#24
  def hijack?; end

  # source://async-http//lib/async/http/protocol/request.rb#31
  def peer; end

  # source://async-http//lib/async/http/protocol/request.rb#37
  def remote_address; end

  # source://async-http//lib/async/http/protocol/request.rb#41
  def remote_address=(value); end

  # source://async-http//lib/async/http/protocol/request.rb#28
  def write_interim_response(response); end
end

# Failed to send the request. The request body has NOT been consumed (i.e. #read) and you should retry the request.
#
# source://async-http//lib/async/http/protocol/request.rb#15
class Async::HTTP::Protocol::RequestFailed < ::StandardError; end

# This is generated by client protocols.
#
# source://async-http//lib/async/http/protocol/response.rb#14
class Async::HTTP::Protocol::Response < ::Protocol::HTTP::Response
  # source://async-http//lib/async/http/protocol/response.rb#15
  def connection; end

  # @return [Boolean]
  #
  # source://async-http//lib/async/http/protocol/response.rb#19
  def hijack?; end

  # source://async-http//lib/async/http/protocol/response.rb#23
  def peer; end

  # source://async-http//lib/async/http/protocol/response.rb#29
  def remote_address; end

  # source://async-http//lib/async/http/protocol/response.rb#33
  def remote_address=(value); end
end

# Wraps a client, address and headers required to initiate a connectio to a remote host using the CONNECT verb.
# Behaves like a TCP endpoint for the purposes of connecting to a remote host.
#
# source://async-http//lib/async/http/proxy.rb#15
class Async::HTTP::Proxy
  # @param client [Async::HTTP::Client] the client which will be used as a proxy server.
  # @param address [String] the address to connect to.
  # @param headers [Array] an optional list of headers to use when establishing the connection.
  # @return [Proxy] a new instance of Proxy
  #
  # source://async-http//lib/async/http/proxy.rb#67
  def initialize(client, address, headers = T.unsafe(nil)); end

  # Returns the value of attribute client.
  #
  # source://async-http//lib/async/http/proxy.rb#73
  def client; end

  # Close the underlying client connection.
  #
  # source://async-http//lib/async/http/proxy.rb#76
  def close; end

  # Establish a TCP connection to the specified host.
  #
  # @return [Socket] a connected bi-directional socket.
  #
  # source://async-http//lib/async/http/proxy.rb#82
  def connect(&block); end

  # @return [Async::HTTP::Endpoint] an endpoint that connects via the specified proxy.
  #
  # source://async-http//lib/async/http/proxy.rb#106
  def wrap_endpoint(endpoint); end

  class << self
    # Construct a endpoint that will use the given client as a proxy for HTTP requests.
    #
    # @param client [Async::HTTP::Client] the client which will be used as a proxy server.
    # @param endpoint [Async::HTTP::Endpoint] the endpoint to connect to.
    # @param headers [Array] an optional list of headers to use when establishing the connection.
    #
    # source://async-http//lib/async/http/proxy.rb#58
    def endpoint(client, endpoint, headers = T.unsafe(nil)); end

    # Prepare and endpoint which can establish a TCP connection to the remote system.
    #
    # @param client [Async::HTTP::Client] the client which will be used as a proxy server.
    # @param host [String] the hostname or address to connect to.
    # @param port [String] the port number to connect to.
    # @param headers [Array] an optional list of headers to use when establishing the connection.
    # @see Async::IO::Endpoint#tcp
    #
    # source://async-http//lib/async/http/proxy.rb#50
    def tcp(client, host, port, headers = T.unsafe(nil)); end
  end
end

# source://async-http//lib/async/http/proxy.rb#25
module Async::HTTP::Proxy::Client
  # Create a client that will proxy requests through the current client.
  #
  # source://async-http//lib/async/http/proxy.rb#31
  def proxied_client(endpoint, headers = T.unsafe(nil)); end

  # source://async-http//lib/async/http/proxy.rb#37
  def proxied_endpoint(endpoint, headers = T.unsafe(nil)); end

  # source://async-http//lib/async/http/proxy.rb#26
  def proxy(endpoint, headers = T.unsafe(nil)); end
end

# source://async-http//lib/async/http/proxy.rb#16
class Async::HTTP::Proxy::ConnectFailure < ::StandardError
  # @return [ConnectFailure] a new instance of ConnectFailure
  #
  # source://async-http//lib/async/http/proxy.rb#17
  def initialize(response); end

  # Returns the value of attribute response.
  #
  # source://async-http//lib/async/http/proxy.rb#22
  def response; end
end
