# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `rubyzip` gem.
# Please instead update this file by running `bin/tapioca gem rubyzip`.

module Zip
  extend ::Zip

  # Returns the value of attribute case_insensitive_match.
  def case_insensitive_match; end

  # Sets the attribute case_insensitive_match
  #
  # @param value the value to set the attribute case_insensitive_match to.
  def case_insensitive_match=(_arg0); end

  # Returns the value of attribute continue_on_exists_proc.
  def continue_on_exists_proc; end

  # Sets the attribute continue_on_exists_proc
  #
  # @param value the value to set the attribute continue_on_exists_proc to.
  def continue_on_exists_proc=(_arg0); end

  # Returns the value of attribute default_compression.
  def default_compression; end

  # Sets the attribute default_compression
  #
  # @param value the value to set the attribute default_compression to.
  def default_compression=(_arg0); end

  # Returns the value of attribute force_entry_names_encoding.
  def force_entry_names_encoding; end

  # Sets the attribute force_entry_names_encoding
  #
  # @param value the value to set the attribute force_entry_names_encoding to.
  def force_entry_names_encoding=(_arg0); end

  # Returns the value of attribute on_exists_proc.
  def on_exists_proc; end

  # Sets the attribute on_exists_proc
  #
  # @param value the value to set the attribute on_exists_proc to.
  def on_exists_proc=(_arg0); end

  def reset!; end

  # @yield [_self]
  # @yieldparam _self [Zip] the object that the method was called on
  def setup; end

  # Returns the value of attribute sort_entries.
  def sort_entries; end

  # Sets the attribute sort_entries
  #
  # @param value the value to set the attribute sort_entries to.
  def sort_entries=(_arg0); end

  # Returns the value of attribute unicode_names.
  def unicode_names; end

  # Sets the attribute unicode_names
  #
  # @param value the value to set the attribute unicode_names to.
  def unicode_names=(_arg0); end

  # Returns the value of attribute validate_entry_sizes.
  def validate_entry_sizes; end

  # Sets the attribute validate_entry_sizes
  #
  # @param value the value to set the attribute validate_entry_sizes to.
  def validate_entry_sizes=(_arg0); end

  # Returns the value of attribute warn_invalid_date.
  def warn_invalid_date; end

  # Sets the attribute warn_invalid_date
  #
  # @param value the value to set the attribute warn_invalid_date to.
  def warn_invalid_date=(_arg0); end

  # Returns the value of attribute write_zip64_support.
  def write_zip64_support; end

  # Sets the attribute write_zip64_support
  #
  # @param value the value to set the attribute write_zip64_support to.
  def write_zip64_support=(_arg0); end
end

Zip::CDIR_ENTRY_STATIC_HEADER_LENGTH = T.let(T.unsafe(nil), Integer)
Zip::CENTRAL_DIRECTORY_ENTRY_SIGNATURE = T.let(T.unsafe(nil), Integer)
Zip::COMPRESSION_METHODS = T.let(T.unsafe(nil), Hash)
Zip::COMPRESSION_METHOD_AES = T.let(T.unsafe(nil), Integer)

# RESERVED = 11
Zip::COMPRESSION_METHOD_BZIP2 = T.let(T.unsafe(nil), Integer)

# RESERVED = 7
Zip::COMPRESSION_METHOD_DEFLATE = T.let(T.unsafe(nil), Integer)

Zip::COMPRESSION_METHOD_DEFLATE_64 = T.let(T.unsafe(nil), Integer)

# RESERVED = 15
Zip::COMPRESSION_METHOD_IBM_CMPSC = T.let(T.unsafe(nil), Integer)

Zip::COMPRESSION_METHOD_IBM_LZ77 = T.let(T.unsafe(nil), Integer)

# RESERVED = 17
Zip::COMPRESSION_METHOD_IBM_TERSE = T.let(T.unsafe(nil), Integer)

Zip::COMPRESSION_METHOD_IMPLODE = T.let(T.unsafe(nil), Integer)
Zip::COMPRESSION_METHOD_JPEG = T.let(T.unsafe(nil), Integer)

# RESERVED = 13
Zip::COMPRESSION_METHOD_LZMA = T.let(T.unsafe(nil), Integer)

Zip::COMPRESSION_METHOD_PKWARE_DCLI = T.let(T.unsafe(nil), Integer)
Zip::COMPRESSION_METHOD_PPMD = T.let(T.unsafe(nil), Integer)
Zip::COMPRESSION_METHOD_REDUCE_1 = T.let(T.unsafe(nil), Integer)
Zip::COMPRESSION_METHOD_REDUCE_2 = T.let(T.unsafe(nil), Integer)
Zip::COMPRESSION_METHOD_REDUCE_3 = T.let(T.unsafe(nil), Integer)
Zip::COMPRESSION_METHOD_REDUCE_4 = T.let(T.unsafe(nil), Integer)
Zip::COMPRESSION_METHOD_SHRINK = T.let(T.unsafe(nil), Integer)
Zip::COMPRESSION_METHOD_STORE = T.let(T.unsafe(nil), Integer)
Zip::COMPRESSION_METHOD_WAVPACK = T.let(T.unsafe(nil), Integer)

class Zip::CentralDirectory
  include ::Enumerable

  # @return [CentralDirectory] a new instance of CentralDirectory
  def initialize(entries = T.unsafe(nil), comment = T.unsafe(nil)); end

  def ==(other); end

  # Returns the value of attribute comment.
  def comment; end

  # For iterating over the entries.
  def each(&a_proc); end

  # Returns an Enumerable containing the entries.
  def entries; end

  # @raise [Error]
  def get_64_e_o_c_d(buf); end

  # @raise [Error]
  def get_e_o_c_d(buf); end

  # @raise [Error]
  def read_64_e_o_c_d(buf); end

  def read_central_directory_entries(io); end

  # @raise [Error]
  def read_e_o_c_d(buf); end

  def read_from_stream(io); end

  # Returns the number of entries in the central directory (and
  # consequently in the zip archive).
  def size; end

  def start_buf(io); end
  def write_to_stream(io); end

  # @return [Boolean]
  def zip64_file?(buf); end

  private

  def write_64_e_o_c_d(io, offset, cdir_size); end
  def write_64_eocd_locator(io, zip64_eocd_offset); end
  def write_e_o_c_d(io, offset, cdir_size); end

  class << self
    def read_from_stream(io); end
  end
end

Zip::CentralDirectory::END_OF_CDS = T.let(T.unsafe(nil), Integer)
Zip::CentralDirectory::MAX_END_OF_CDS_SIZE = T.let(T.unsafe(nil), Integer)
Zip::CentralDirectory::STATIC_EOCD_SIZE = T.let(T.unsafe(nil), Integer)
Zip::CentralDirectory::ZIP64_END_OF_CDS = T.let(T.unsafe(nil), Integer)
Zip::CentralDirectory::ZIP64_EOCD_LOCATOR = T.let(T.unsafe(nil), Integer)
class Zip::CompressionMethodError < ::Zip::Error; end

class Zip::Compressor
  def finish; end
end

class Zip::DOSTime < ::Time
  # Dos time is only stored with two seconds accuracy
  def dos_equals(other); end

  def to_binary_dos_date; end

  # Register DX, the Date:
  # Bits 0-4 day (1-31)
  # bits 5-8 month (1-12)
  # bits 9-15 year (four digit year minus 1980)
  def to_binary_dos_time; end

  class << self
    # Create a DOSTime instance from a vanilla Time instance.
    def from_time(time); end

    def parse_binary_dos_format(bin_dos_date, bin_dos_time); end
  end
end

class Zip::DecompressionError < ::Zip::Error; end

class Zip::Decompressor
  # @return [Decompressor] a new instance of Decompressor
  def initialize(input_stream, decompressed_size = T.unsafe(nil)); end

  # Returns the value of attribute decompressed_size.
  def decompressed_size; end

  # Returns the value of attribute input_stream.
  def input_stream; end

  class << self
    def decompressor_classes; end
    def find_by_compression_method(compression_method); end
    def register(compression_method, decompressor_class); end
  end
end

Zip::Decompressor::CHUNK_SIZE = T.let(T.unsafe(nil), Integer)

class Zip::DecryptedIo
  # @return [DecryptedIo] a new instance of DecryptedIo
  def initialize(io, decrypter); end

  def read(length = T.unsafe(nil), outbuf = T.unsafe(nil)); end

  private

  def buffer; end
  def eof; end

  # @return [Boolean]
  def input_finished?; end

  def produce_input; end
end

Zip::DecryptedIo::CHUNK_SIZE = T.let(T.unsafe(nil), Integer)
class Zip::Decrypter; end

class Zip::Deflater < ::Zip::Compressor
  # @return [Deflater] a new instance of Deflater
  def initialize(output_stream, level = T.unsafe(nil), encrypter = T.unsafe(nil)); end

  def <<(data); end

  # Returns the value of attribute crc.
  def crc; end

  def finish; end

  # Returns the value of attribute size.
  def size; end
end

class Zip::DestinationFileExistsError < ::Zip::Error; end
class Zip::Encrypter; end

class Zip::Entry
  # @return [Entry] a new instance of Entry
  def initialize(*args); end

  def <=>(other); end
  def ==(other); end
  def calculate_local_header_size; end
  def cdir_header_size; end

  # @raise [::Zip::Error]
  def check_c_dir_entry_comment_size; end

  # @raise [Error]
  def check_c_dir_entry_signature; end

  # @raise [Error]
  def check_c_dir_entry_static_header_length(buf); end

  # @raise [::Zip::EntryNameError]
  def check_name(name); end

  def clean_up; end

  # Returns the value of attribute comment.
  def comment; end

  # Sets the attribute comment
  #
  # @param value the value to set the attribute comment to.
  def comment=(_arg0); end

  def comment_size; end

  # Returns the value of attribute compressed_size.
  def compressed_size; end

  # Sets the attribute compressed_size
  #
  # @param value the value to set the attribute compressed_size to.
  def compressed_size=(_arg0); end

  # Returns the value of attribute compression_method.
  def compression_method; end

  # Sets the attribute compression_method
  #
  # @param value the value to set the attribute compression_method to.
  def compression_method=(_arg0); end

  # Returns the value of attribute crc.
  def crc; end

  # Sets the attribute crc
  #
  # @param value the value to set the attribute crc to.
  def crc=(_arg0); end

  def directory?; end

  # Returns the value of attribute dirty.
  def dirty; end

  # Sets the attribute dirty
  #
  # @param value the value to set the attribute dirty to.
  def dirty=(_arg0); end

  # @return [Boolean]
  def encrypted?; end

  # Returns the value of attribute external_file_attributes.
  def external_file_attributes; end

  # Sets the attribute external_file_attributes
  #
  # @param value the value to set the attribute external_file_attributes to.
  def external_file_attributes=(_arg0); end

  # Returns the value of attribute extra.
  def extra; end

  # Sets the attribute extra
  #
  # @param value the value to set the attribute extra to.
  def extra=(_arg0); end

  def extra_size; end

  # Extracts entry to file dest_path (defaults to @name).
  # NB: The caller is responsible for making sure dest_path is safe, if it
  # is passed.
  def extract(dest_path = T.unsafe(nil), &block); end

  def file?; end
  def file_stat(path); end

  # @raise [InternalError]
  # @return [Boolean]
  def file_type_is?(type); end

  def filepath; end

  # Returns the value of attribute follow_symlinks.
  def follow_symlinks; end

  # Sets the attribute follow_symlinks
  #
  # @param value the value to set the attribute follow_symlinks to.
  def follow_symlinks=(_arg0); end

  # Returns the value of attribute fstype.
  def fstype; end

  # Sets the attribute fstype
  #
  # @param value the value to set the attribute fstype to.
  def fstype=(_arg0); end

  def ftype; end
  def gather_fileinfo_from_srcpath(src_path); end
  def get_extra_attributes_from_path(path); end

  # Returns an IO like object for the given ZipEntry.
  # Warning: may behave weird with symlinks.
  def get_input_stream(&block); end

  def get_raw_input_stream(&block); end

  # Returns the value of attribute gp_flags.
  def gp_flags; end

  # Sets the attribute gp_flags
  #
  # @param value the value to set the attribute gp_flags to.
  def gp_flags=(_arg0); end

  # Returns the value of attribute header_signature.
  def header_signature; end

  # Sets the attribute header_signature
  #
  # @param value the value to set the attribute header_signature to.
  def header_signature=(_arg0); end

  # @return [Boolean]
  def incomplete?; end

  # Returns the value of attribute internal_file_attributes.
  def internal_file_attributes; end

  # Sets the attribute internal_file_attributes
  #
  # @param value the value to set the attribute internal_file_attributes to.
  def internal_file_attributes=(_arg0); end

  def local_entry_offset; end

  # Returns the value of attribute local_header_offset.
  def local_header_offset; end

  # Sets the attribute local_header_offset
  #
  # @param value the value to set the attribute local_header_offset to.
  def local_header_offset=(_arg0); end

  def mtime; end

  # Returns the value of attribute name.
  def name; end

  # Sets the attribute name
  #
  # @param value the value to set the attribute name to.
  def name=(_arg0); end

  # @return [Boolean]
  def name_is_directory?; end

  # Is the name a relative path, free of `..` patterns that could lead to
  # path traversal attacks? This does NOT handle symlinks; if the path
  # contains symlinks, this check is NOT enough to guarantee safety.
  #
  # @return [Boolean]
  def name_safe?; end

  def name_size; end
  def next_header_offset; end
  def pack_c_dir_entry; end
  def pack_local_entry; end
  def parent_as_string; end
  def read_c_dir_entry(io); end
  def read_c_dir_extra_field(io); end
  def read_local_entry(io); end

  # Returns the value of attribute restore_ownership.
  def restore_ownership; end

  # Sets the attribute restore_ownership
  #
  # @param value the value to set the attribute restore_ownership to.
  def restore_ownership=(_arg0); end

  # Returns the value of attribute restore_permissions.
  def restore_permissions; end

  # Sets the attribute restore_permissions
  #
  # @param value the value to set the attribute restore_permissions to.
  def restore_permissions=(_arg0); end

  # Returns the value of attribute restore_times.
  def restore_times; end

  # Sets the attribute restore_times
  #
  # @param value the value to set the attribute restore_times to.
  def restore_times=(_arg0); end

  def set_default_vars_values; end
  def set_extra_attributes_on_path(dest_path); end
  def set_ftype_from_c_dir_entry; end
  def set_unix_attributes_on_path(dest_path); end

  # Returns the value of attribute size.
  def size; end

  # Sets the attribute size
  #
  # @param value the value to set the attribute size to.
  def size=(_arg0); end

  def symlink?; end
  def time; end
  def time=(value); end
  def to_s; end

  # Returns the value of attribute unix_gid.
  def unix_gid; end

  # Sets the attribute unix_gid
  #
  # @param value the value to set the attribute unix_gid to.
  def unix_gid=(_arg0); end

  # Returns the value of attribute unix_perms.
  def unix_perms; end

  # Sets the attribute unix_perms
  #
  # @param value the value to set the attribute unix_perms to.
  def unix_perms=(_arg0); end

  # Returns the value of attribute unix_uid.
  def unix_uid; end

  # Sets the attribute unix_uid
  #
  # @param value the value to set the attribute unix_uid to.
  def unix_uid=(_arg0); end

  def unpack_c_dir_entry(buf); end
  def unpack_local_entry(buf); end

  # check before rewriting an entry (after file sizes are known)
  # that we didn't change the header size (and thus clobber file data or something)
  #
  # @raise [Error]
  def verify_local_header_size!; end

  def write_c_dir_entry(io); end
  def write_local_entry(io, rewrite = T.unsafe(nil)); end
  def write_to_zip_output_stream(zip_output_stream); end

  # Returns the value of attribute zipfile.
  def zipfile; end

  # Sets the attribute zipfile
  #
  # @param value the value to set the attribute zipfile to.
  def zipfile=(_arg0); end

  private

  def create_directory(dest_path); end
  def create_file(dest_path, _continue_on_exists_proc = T.unsafe(nil)); end

  # BUG: create_symlink() does not use &block
  def create_symlink(dest_path); end

  def data_descriptor_size; end

  # apply missing data from the zip64 extra information field, if present
  # (required when file sizes exceed 2**32, but can be used for all files)
  def parse_zip64_extra(for_local_header); end

  # create a zip64 extra information field if we need one
  def prep_zip64_extra(for_local_header); end

  def set_time(binary_dos_date, binary_dos_time); end

  class << self
    def read_c_dir_entry(io); end
    def read_local_entry(io); end
    def read_zip_64_long(io); end
    def read_zip_long(io); end
    def read_zip_short(io); end
  end
end

Zip::Entry::DEFLATED = T.let(T.unsafe(nil), Integer)

# Language encoding flag (EFS) bit
Zip::Entry::EFS = T.let(T.unsafe(nil), Integer)

Zip::Entry::STORED = T.let(T.unsafe(nil), Integer)
class Zip::EntryExistsError < ::Zip::Error; end
class Zip::EntryNameError < ::Zip::Error; end

class Zip::EntrySet
  include ::Enumerable

  # @return [EntrySet] a new instance of EntrySet
  def initialize(an_enumerable = T.unsafe(nil)); end

  def <<(entry); end
  def ==(other); end
  def delete(entry); end

  # deep clone
  def dup; end

  def each; end
  def entries; end

  # Returns the value of attribute entry_order.
  def entry_order; end

  # Sets the attribute entry_order
  #
  # @param value the value to set the attribute entry_order to.
  def entry_order=(_arg0); end

  # Returns the value of attribute entry_set.
  def entry_set; end

  # Sets the attribute entry_set
  #
  # @param value the value to set the attribute entry_set to.
  def entry_set=(_arg0); end

  def find_entry(entry); end
  def glob(pattern, flags = T.unsafe(nil)); end

  # @return [Boolean]
  def include?(entry); end

  def length; end
  def parent(entry); end
  def push(entry); end
  def size; end

  protected

  def sorted_entries; end

  private

  def to_key(entry); end
end

class Zip::EntrySizeError < ::Zip::Error; end
class Zip::Error < ::StandardError; end

class Zip::ExtraField < ::Hash
  # @return [ExtraField] a new instance of ExtraField
  def initialize(binstr = T.unsafe(nil)); end

  def c_dir_size; end
  def create(name); end
  def create_unknown_item; end
  def extra_field_type_exist(binstr, id, len, index); end
  def extra_field_type_unknown(binstr, len, index); end
  def length; end
  def local_size; end
  def merge(binstr); end

  # place Unknown last, so "extra" data that is missing the proper signature/size
  # does not prevent known fields from being read back in
  def ordered_values; end

  def size; end
  def to_c_dir_bin; end
  def to_local_bin; end
  def to_s; end
end

class Zip::ExtraField::Generic
  def ==(other); end
  def initial_parse(binstr); end
  def to_c_dir_bin; end
  def to_local_bin; end

  class << self
    def name; end
    def register_map; end
  end
end

Zip::ExtraField::ID_MAP = T.let(T.unsafe(nil), Hash)

class Zip::ExtraField::IUnix < ::Zip::ExtraField::Generic
  def initialize(binstr = T.unsafe(nil)); end

  def ==(other); end
  def gid; end
  def gid=(_arg0); end
  def merge(binstr); end
  def pack_for_c_dir; end
  def pack_for_local; end
  def uid; end
  def uid=(_arg0); end
end

Zip::ExtraField::IUnix::HEADER_ID = T.let(T.unsafe(nil), String)

class Zip::ExtraField::NTFS < ::Zip::ExtraField::Generic
  def initialize(binstr = T.unsafe(nil)); end

  def ==(other); end
  def atime; end
  def atime=(_arg0); end
  def ctime; end
  def ctime=(_arg0); end
  def merge(binstr); end
  def mtime; end
  def mtime=(_arg0); end
  def pack_for_c_dir; end
  def pack_for_local; end

  private

  def from_ntfs_time(ntfs_time); end
  def parse_tags(content); end
  def to_ntfs_time(time); end
end

Zip::ExtraField::NTFS::HEADER_ID = T.let(T.unsafe(nil), String)
Zip::ExtraField::NTFS::SEC_TO_UNIX_EPOCH = T.let(T.unsafe(nil), Integer)
Zip::ExtraField::NTFS::WINDOWS_TICK = T.let(T.unsafe(nil), Float)

class Zip::ExtraField::OldUnix < ::Zip::ExtraField::Generic
  def initialize(binstr = T.unsafe(nil)); end

  def ==(other); end
  def atime; end
  def atime=(_arg0); end
  def gid; end
  def gid=(_arg0); end
  def merge(binstr); end
  def mtime; end
  def mtime=(_arg0); end
  def pack_for_c_dir; end
  def pack_for_local; end
  def uid; end
  def uid=(_arg0); end
end

Zip::ExtraField::OldUnix::HEADER_ID = T.let(T.unsafe(nil), String)

class Zip::ExtraField::UniversalTime < ::Zip::ExtraField::Generic
  def initialize(binstr = T.unsafe(nil)); end

  def ==(other); end
  def atime; end
  def atime=(time); end
  def ctime; end
  def ctime=(time); end
  def flag; end
  def merge(binstr); end
  def mtime; end
  def mtime=(time); end
  def pack_for_c_dir; end
  def pack_for_local; end
end

Zip::ExtraField::UniversalTime::ATIME_MASK = T.let(T.unsafe(nil), Integer)
Zip::ExtraField::UniversalTime::CTIME_MASK = T.let(T.unsafe(nil), Integer)
Zip::ExtraField::UniversalTime::HEADER_ID = T.let(T.unsafe(nil), String)
Zip::ExtraField::UniversalTime::MTIME_MASK = T.let(T.unsafe(nil), Integer)

class Zip::ExtraField::Zip64 < ::Zip::ExtraField::Generic
  def initialize(binstr = T.unsafe(nil)); end

  def ==(other); end
  def compressed_size; end
  def compressed_size=(_arg0); end
  def disk_start_number; end
  def disk_start_number=(_arg0); end
  def merge(binstr); end
  def original_size; end
  def original_size=(_arg0); end
  def pack_for_c_dir; end
  def pack_for_local; end
  def parse(original_size, compressed_size, relative_header_offset = T.unsafe(nil), disk_start_number = T.unsafe(nil)); end
  def relative_header_offset; end
  def relative_header_offset=(_arg0); end

  private

  def extract(size, format); end
end

Zip::ExtraField::Zip64::HEADER_ID = T.let(T.unsafe(nil), String)

class Zip::ExtraField::Zip64Placeholder < ::Zip::ExtraField::Generic
  def initialize(_binstr = T.unsafe(nil)); end

  def pack_for_local; end
end

Zip::ExtraField::Zip64Placeholder::HEADER_ID = T.let(T.unsafe(nil), String)
Zip::FILE_TYPE_DIR = T.let(T.unsafe(nil), Integer)
Zip::FILE_TYPE_FILE = T.let(T.unsafe(nil), Integer)
Zip::FILE_TYPE_SYMLINK = T.let(T.unsafe(nil), Integer)
Zip::FSTYPES = T.let(T.unsafe(nil), Hash)
Zip::FSTYPE_ACORN = T.let(T.unsafe(nil), Integer)
Zip::FSTYPE_AMIGA = T.let(T.unsafe(nil), Integer)
Zip::FSTYPE_ATARI = T.let(T.unsafe(nil), Integer)
Zip::FSTYPE_ATHEOS = T.let(T.unsafe(nil), Integer)
Zip::FSTYPE_BEOS = T.let(T.unsafe(nil), Integer)
Zip::FSTYPE_CPM = T.let(T.unsafe(nil), Integer)
Zip::FSTYPE_FAT = T.let(T.unsafe(nil), Integer)
Zip::FSTYPE_HPFS = T.let(T.unsafe(nil), Integer)
Zip::FSTYPE_MAC = T.let(T.unsafe(nil), Integer)
Zip::FSTYPE_MAC_OSX = T.let(T.unsafe(nil), Integer)
Zip::FSTYPE_MVS = T.let(T.unsafe(nil), Integer)
Zip::FSTYPE_NTFS = T.let(T.unsafe(nil), Integer)
Zip::FSTYPE_QDOS = T.let(T.unsafe(nil), Integer)
Zip::FSTYPE_TANDEM = T.let(T.unsafe(nil), Integer)
Zip::FSTYPE_THEOS = T.let(T.unsafe(nil), Integer)
Zip::FSTYPE_TOPS20 = T.let(T.unsafe(nil), Integer)
Zip::FSTYPE_UNIX = T.let(T.unsafe(nil), Integer)
Zip::FSTYPE_VFAT = T.let(T.unsafe(nil), Integer)
Zip::FSTYPE_VMS = T.let(T.unsafe(nil), Integer)
Zip::FSTYPE_VM_CMS = T.let(T.unsafe(nil), Integer)
Zip::FSTYPE_Z_SYSTEM = T.let(T.unsafe(nil), Integer)

# ZipFile is modeled after java.util.zip.ZipFile from the Java SDK.
# The most important methods are those inherited from
# ZipCentralDirectory for accessing information about the entries in
# the archive and methods such as get_input_stream and
# get_output_stream for reading from and writing entries to the
# archive. The class includes a few convenience methods such as
# #extract for extracting entries to the filesystem, and #remove,
# #replace, #rename and #mkdir for making simple modifications to
# the archive.
#
# Modifications to a zip archive are not committed until #commit or
# #close is called. The method #open accepts a block following
# the pattern from File.open offering a simple way to
# automatically close the archive when the block returns.
#
# The following example opens zip archive <code>my.zip</code>
# (creating it if it doesn't exist) and adds an entry
# <code>first.txt</code> and a directory entry <code>a_dir</code>
# to it.
#
#   require 'zip'
#
#   Zip::File.open("my.zip", Zip::File::CREATE) {
#    |zipfile|
#     zipfile.get_output_stream("first.txt") { |f| f.puts "Hello from ZipFile" }
#     zipfile.mkdir("a_dir")
#   }
#
# The next example reopens <code>my.zip</code> writes the contents of
# <code>first.txt</code> to standard out and deletes the entry from
# the archive.
#
#   require 'zip'
#
#   Zip::File.open("my.zip", Zip::File::CREATE) {
#     |zipfile|
#     puts zipfile.read("first.txt")
#     zipfile.remove("first.txt")
#   }
#
# ZipFileSystem offers an alternative API that emulates ruby's
# interface for accessing the filesystem, ie. the File and Dir classes.
class Zip::File < ::Zip::CentralDirectory
  # Opens a zip archive. Pass true as the second parameter to create
  # a new archive if it doesn't exist already.
  #
  # @return [File] a new instance of File
  def initialize(path_or_io, create = T.unsafe(nil), buffer = T.unsafe(nil), options = T.unsafe(nil)); end

  # Convenience method for adding the contents of a file to the archive
  def add(entry, src_path, &continue_on_exists_proc); end

  # Convenience method for adding the contents of a file to the archive
  # in Stored format (uncompressed)
  def add_stored(entry, src_path, &continue_on_exists_proc); end

  # Closes the zip file committing any changes that has been made.
  def close; end

  # Returns the zip files comment, if it has one
  def comment; end

  # Returns the zip files comment, if it has one
  def comment=(_arg0); end

  # Commits changes that has been made since the previous commit to
  # the zip archive.
  def commit; end

  # Returns true if any changes has been made to this archive since
  # the previous commit
  #
  # @return [Boolean]
  def commit_required?; end

  # Extracts entry to file dest_path.
  def extract(entry, dest_path, &block); end

  # Searches for entry with the specified name. Returns nil if
  # no entry is found. See also get_entry
  def find_entry(entry_name); end

  # Searches for an entry just as find_entry, but throws Errno::ENOENT
  # if no entry is found.
  #
  # @raise [Errno::ENOENT]
  def get_entry(entry); end

  # Returns an input stream to the specified entry. If a block is passed
  # the stream object is passed to the block and the stream is automatically
  # closed afterwards just as with ruby's builtin File.open method.
  def get_input_stream(entry, &a_proc); end

  # Returns an output stream to the specified entry. If entry is not an instance
  # of Zip::Entry, a new Zip::Entry will be initialized using the arguments
  # specified. If a block is passed the stream object is passed to the block and
  # the stream is automatically closed afterwards just as with ruby's builtin
  # File.open method.
  def get_output_stream(entry, permission_int = T.unsafe(nil), comment = T.unsafe(nil), extra = T.unsafe(nil), compressed_size = T.unsafe(nil), crc = T.unsafe(nil), compression_method = T.unsafe(nil), size = T.unsafe(nil), time = T.unsafe(nil), &a_proc); end

  # Searches for entries given a glob
  def glob(*args, &block); end

  # Creates a directory
  #
  # @raise [Errno::EEXIST]
  def mkdir(entry_name, permission = T.unsafe(nil)); end

  # Returns the value of attribute name.
  def name; end

  # Returns a string containing the contents of the specified entry
  def read(entry); end

  # Removes the specified entry.
  def remove(entry); end

  # Renames the specified entry.
  def rename(entry, new_name, &continue_on_exists_proc); end

  # Replaces the specified entry with the contents of src_path (from
  # the file system).
  def replace(entry, src_path); end

  # default -> false.
  def restore_ownership; end

  # default -> false.
  def restore_ownership=(_arg0); end

  # default -> false, but will be set to true in a future version.
  def restore_permissions; end

  # default -> false, but will be set to true in a future version.
  def restore_permissions=(_arg0); end

  # default -> false, but will be set to true in a future version.
  def restore_times; end

  # default -> false, but will be set to true in a future version.
  def restore_times=(_arg0); end

  # Returns the name of the zip archive
  def to_s; end

  # Write buffer write changes to buffer and return
  def write_buffer(io = T.unsafe(nil)); end

  private

  def check_entry_exists(entry_name, continue_on_exists_proc, proc_name); end

  # @raise [Errno::ENOENT]
  def check_file(path); end

  # @return [Boolean]
  def directory?(new_entry, src_path); end

  def on_success_replace; end

  class << self
    # Same as #open. But outputs data to a buffer instead of a file
    #
    # @yield [zf]
    def add_buffer; end

    # Iterates over the contents of the ZipFile. This is more efficient
    # than using a ZipInputStream since this methods simply iterates
    # through the entries in the central directory structure in the archive
    # whereas ZipInputStream jumps through the entire archive accessing the
    # local entry headers (which contain the same information as the
    # central directory).
    def foreach(zip_file_name, &block); end

    def get_partial_zip_file_name(zip_file_name, partial_zip_file_name); end
    def get_segment_count_for_split(zip_file_size, segment_size); end
    def get_segment_size_for_split(segment_size); end

    # Similar to ::new. If a block is passed the Zip::File object is passed
    # to the block and is automatically closed afterwards, just as with
    # ruby's builtin File::open method.
    def open(file_name, create = T.unsafe(nil), options = T.unsafe(nil)); end

    # Like #open, but reads zip archive contents from a String or open IO
    # stream, and outputs data to a buffer.
    # (This can be used to extract data from a
    # downloaded zip archive without first saving it to disk.)
    #
    # @yield [zf]
    def open_buffer(io, options = T.unsafe(nil)); end

    def put_split_signature(szip_file, segment_size); end

    # TODO: Make the code more understandable
    def save_splited_part(zip_file, partial_zip_file_name, zip_file_size, szip_file_index, segment_size, segment_count); end

    # Splits an archive into parts with segment size
    #
    # @raise [Error]
    def split(zip_file_name, segment_size = T.unsafe(nil), delete_zip_file = T.unsafe(nil), partial_zip_file_name = T.unsafe(nil)); end
  end
end

Zip::File::CREATE = T.let(T.unsafe(nil), TrueClass)
Zip::File::DATA_BUFFER_SIZE = T.let(T.unsafe(nil), Integer)
Zip::File::DEFAULT_OPTIONS = T.let(T.unsafe(nil), Hash)
Zip::File::IO_METHODS = T.let(T.unsafe(nil), Array)
Zip::File::MAX_SEGMENT_SIZE = T.let(T.unsafe(nil), Integer)
Zip::File::MIN_SEGMENT_SIZE = T.let(T.unsafe(nil), Integer)
Zip::File::SPLIT_SIGNATURE = T.let(T.unsafe(nil), Integer)
Zip::File::ZIP64_EOCD_SIGNATURE = T.let(T.unsafe(nil), Integer)
class Zip::GPFBit3Error < ::Zip::Error; end

module Zip::IOExtras
  class << self
    def copy_stream(ostream, istream); end
    def copy_stream_n(ostream, istream, nbytes); end
  end
end

# Implements many of the convenience methods of IO
# such as gets, getc, readline and readlines
# depends on: input_finished?, produce_input and read
module Zip::IOExtras::AbstractInputStream
  include ::Enumerable
  include ::Zip::IOExtras::FakeIO

  def initialize; end

  def each(a_sep_string = T.unsafe(nil)); end
  def each_line(a_sep_string = T.unsafe(nil)); end
  def eof; end
  def eof?; end
  def flush; end
  def gets(a_sep_string = T.unsafe(nil), number_of_bytes = T.unsafe(nil)); end

  # Returns the value of attribute lineno.
  def lineno; end

  # Sets the attribute lineno
  #
  # @param value the value to set the attribute lineno to.
  def lineno=(_arg0); end

  # Returns the value of attribute pos.
  def pos; end

  def read(number_of_bytes = T.unsafe(nil), buf = T.unsafe(nil)); end

  # @raise [EOFError]
  def readline(a_sep_string = T.unsafe(nil)); end

  def readlines(a_sep_string = T.unsafe(nil)); end
  def ungetc(byte); end
end

# Implements many of the output convenience methods of IO.
# relies on <<
module Zip::IOExtras::AbstractOutputStream
  include ::Zip::IOExtras::FakeIO

  def print(*params); end
  def printf(a_format_string, *params); end
  def putc(an_object); end
  def puts(*params); end
  def write(data); end
end

Zip::IOExtras::CHUNK_SIZE = T.let(T.unsafe(nil), Integer)

# Implements kind_of? in order to pretend to be an IO object
module Zip::IOExtras::FakeIO
  # @return [Boolean]
  def kind_of?(object); end
end

Zip::IOExtras::RANGE_ALL = T.let(T.unsafe(nil), Range)

class Zip::Inflater < ::Zip::Decompressor
  # @return [Inflater] a new instance of Inflater
  def initialize(*args); end

  def eof; end
  def eof?; end
  def read(length = T.unsafe(nil), outbuf = T.unsafe(nil)); end

  private

  # @return [Boolean]
  def input_finished?; end

  def produce_input; end
end

# InputStream is the basic class for reading zip entries in a
# zip file. It is possible to create a InputStream object directly,
# passing the zip file name to the constructor, but more often than not
# the InputStream will be obtained from a File (perhaps using the
# ZipFileSystem interface) object for a particular entry in the zip
# archive.
#
# A InputStream inherits IOExtras::AbstractInputStream in order
# to provide an IO-like interface for reading from a single zip
# entry. Beyond methods for mimicking an IO-object it contains
# the method get_next_entry for iterating through the entries of
# an archive. get_next_entry returns a Entry object that describes
# the zip entry the InputStream is currently reading from.
#
# Example that creates a zip archive with ZipOutputStream and reads it
# back again with a InputStream.
#
#   require 'zip'
#
#   Zip::OutputStream.open("my.zip") do |io|
#
#     io.put_next_entry("first_entry.txt")
#     io.write "Hello world!"
#
#     io.put_next_entry("adir/first_entry.txt")
#     io.write "Hello again!"
#   end
#
#
#   Zip::InputStream.open("my.zip") do |io|
#
#     while (entry = io.get_next_entry)
#       puts "Contents of #{entry.name}: '#{io.read}'"
#     end
#   end
#
# java.util.zip.ZipInputStream is the original inspiration for this
# class.
class Zip::InputStream
  include ::Enumerable
  include ::Zip::IOExtras::FakeIO
  include ::Zip::IOExtras::AbstractInputStream

  # Opens the indicated zip file. An exception is thrown
  # if the specified offset in the specified filename is
  # not a local zip entry header.
  #
  # @param context [String||IO||StringIO] file path or IO/StringIO object
  # @param offset [Integer] offset in the IO/StringIO
  # @return [InputStream] a new instance of InputStream
  def initialize(context, offset = T.unsafe(nil), decrypter = T.unsafe(nil)); end

  def close; end

  # Returns a Entry object. It is necessary to call this
  # method on a newly created InputStream before reading from
  # the first entry in the archive. Returns nil when there are
  # no more entries.
  def get_next_entry; end

  # Rewinds the stream to the beginning of the current entry
  def rewind; end

  # Modeled after IO.sysread
  def sysread(length = T.unsafe(nil), outbuf = T.unsafe(nil)); end

  protected

  def get_decompressor; end
  def get_decrypted_io; end
  def get_io(io_or_file, offset = T.unsafe(nil)); end

  # @return [Boolean]
  def input_finished?; end

  def open_entry; end
  def produce_input; end

  class << self
    # Same as #initialize but if a block is passed the opened
    # stream is passed to the block and closed when the block
    # returns.
    def open(filename_or_io, offset = T.unsafe(nil), decrypter = T.unsafe(nil)); end

    def open_buffer(filename_or_io, offset = T.unsafe(nil)); end
  end
end

Zip::InputStream::CHUNK_SIZE = T.let(T.unsafe(nil), Integer)
class Zip::InternalError < ::Zip::Error; end
Zip::LOCAL_ENTRY_SIGNATURE = T.let(T.unsafe(nil), Integer)
Zip::LOCAL_ENTRY_STATIC_HEADER_LENGTH = T.let(T.unsafe(nil), Integer)
Zip::LOCAL_ENTRY_TRAILING_DESCRIPTOR_LENGTH = T.let(T.unsafe(nil), Integer)

class Zip::NullCompressor < ::Zip::Compressor
  include ::Singleton
  extend ::Singleton::SingletonClassMethods

  # @raise [IOError]
  def <<(_data); end

  # Returns the value of attribute compressed_size.
  def compressed_size; end

  # Returns the value of attribute size.
  def size; end
end

module Zip::NullDecompressor
  private

  def eof; end
  def eof?; end
  def read(_length = T.unsafe(nil), _outbuf = T.unsafe(nil)); end

  class << self
    def eof; end
    def read(_length = T.unsafe(nil), _outbuf = T.unsafe(nil)); end
  end
end

class Zip::NullDecrypter < ::Zip::Decrypter
  include ::Zip::NullEncryption

  def decrypt(data); end
  def reset!(_header); end
end

class Zip::NullEncrypter < ::Zip::Encrypter
  include ::Zip::NullEncryption

  def data_descriptor(_crc32, _compressed_size, _uncomprssed_size); end
  def encrypt(data); end
  def header(_mtime); end
  def reset!; end
end

module Zip::NullEncryption
  def gp_flags; end
  def header_bytesize; end
end

module Zip::NullInputStream
  include ::Zip::NullDecompressor
  include ::Enumerable
  include ::Zip::IOExtras::FakeIO
  include ::Zip::IOExtras::AbstractInputStream
end

# ZipOutputStream is the basic class for writing zip files. It is
# possible to create a ZipOutputStream object directly, passing
# the zip file name to the constructor, but more often than not
# the ZipOutputStream will be obtained from a ZipFile (perhaps using the
# ZipFileSystem interface) object for a particular entry in the zip
# archive.
#
# A ZipOutputStream inherits IOExtras::AbstractOutputStream in order
# to provide an IO-like interface for writing to a single zip
# entry. Beyond methods for mimicking an IO-object it contains
# the method put_next_entry that closes the current entry
# and creates a new.
#
# Please refer to ZipInputStream for example code.
#
# java.util.zip.ZipOutputStream is the original inspiration for this
# class.
class Zip::OutputStream
  include ::Zip::IOExtras::FakeIO
  include ::Zip::IOExtras::AbstractOutputStream

  # Opens the indicated zip file. If a file with that name already
  # exists it will be overwritten.
  #
  # @return [OutputStream] a new instance of OutputStream
  def initialize(file_name, stream = T.unsafe(nil), encrypter = T.unsafe(nil)); end

  # Modeled after IO.<<
  def <<(data); end

  # Closes the stream and writes the central directory to the zip file
  def close; end

  # Closes the stream and writes the central directory to the zip file
  def close_buffer; end

  # Returns the value of attribute comment.
  def comment; end

  # Sets the attribute comment
  #
  # @param value the value to set the attribute comment to.
  def comment=(_arg0); end

  # @raise [Error]
  def copy_raw_entry(entry); end

  # Closes the current entry and opens a new for writing.
  # +entry+ can be a ZipEntry object or a string.
  #
  # @raise [Error]
  def put_next_entry(entry_name, comment = T.unsafe(nil), extra = T.unsafe(nil), compression_method = T.unsafe(nil), level = T.unsafe(nil)); end

  protected

  def finish; end

  private

  def finalize_current_entry; end
  def get_compressor(entry, level); end
  def init_next_entry(entry, level = T.unsafe(nil)); end
  def update_local_headers; end
  def write_central_directory; end

  class << self
    def open(file_name, encrypter = T.unsafe(nil)); end

    # Same as #open but writes to a filestream instead
    #
    # @yield [zos]
    def write_buffer(io = T.unsafe(nil), encrypter = T.unsafe(nil)); end
  end
end

class Zip::PassThruCompressor < ::Zip::Compressor
  # @return [PassThruCompressor] a new instance of PassThruCompressor
  def initialize(output_stream); end

  def <<(data); end

  # Returns the value of attribute crc.
  def crc; end

  # Returns the value of attribute size.
  def size; end
end

class Zip::PassThruDecompressor < ::Zip::Decompressor
  # @return [PassThruDecompressor] a new instance of PassThruDecompressor
  def initialize(*args); end

  def eof; end
  def eof?; end
  def read(length = T.unsafe(nil), outbuf = T.unsafe(nil)); end
end

class Zip::StreamableDirectory < ::Zip::Entry
  # @return [StreamableDirectory] a new instance of StreamableDirectory
  def initialize(zipfile, entry, src_path = T.unsafe(nil), permission = T.unsafe(nil)); end
end

class Zip::StreamableStream
  # @return [StreamableStream] a new instance of StreamableStream
  def initialize(entry); end

  def clean_up; end
  def get_input_stream; end
  def get_output_stream; end
  def write_to_zip_output_stream(output_stream); end
end

class Zip::TraditionalDecrypter < ::Zip::Decrypter
  include ::Zip::TraditionalEncryption

  def decrypt(data); end
  def reset!(header); end

  private

  def decode(num); end
end

class Zip::TraditionalEncrypter < ::Zip::Encrypter
  include ::Zip::TraditionalEncryption

  def data_descriptor(crc32, compressed_size, uncomprssed_size); end
  def encrypt(data); end
  def header(mtime); end
  def reset!; end

  private

  def encode(num); end
end

module Zip::TraditionalEncryption
  def initialize(password); end

  def gp_flags; end
  def header_bytesize; end

  protected

  def decrypt_byte; end
  def reset_keys!; end
  def update_keys(num); end
end

# this library's version
Zip::VERSION_MADE_BY = T.let(T.unsafe(nil), Integer)

Zip::VERSION_NEEDED_TO_EXTRACT = T.let(T.unsafe(nil), Integer)
Zip::VERSION_NEEDED_TO_EXTRACT_ZIP64 = T.let(T.unsafe(nil), Integer)
Zip::ZipCompressionMethodError = Zip::CompressionMethodError
Zip::ZipDestinationFileExistsError = Zip::DestinationFileExistsError
Zip::ZipEntryExistsError = Zip::EntryExistsError
Zip::ZipEntryNameError = Zip::EntryNameError

# Backwards compatibility with v1 (delete in v2)
Zip::ZipError = Zip::Error

Zip::ZipInternalError = Zip::InternalError
