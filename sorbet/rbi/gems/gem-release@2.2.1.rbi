# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `gem-release` gem.
# Please instead update this file by running `bin/tapioca sync`.

# typed: true

module Gem::Release
end

class Gem::Release::Abort < ::StandardError
end

module Gem::Release::Cmds
  class << self
    def [](cmd); end
  end
end

class Gem::Release::Cmds::Base < ::Struct
  include(::Gem::Release::Registry)
  include(::Gem::Release::Registry::InstanceMethods)
  include(::Gem::Release::Helper::String)
  include(::Gem::Release::Helper::Hash)
  include(::Gem::Release::Helper)
  extend(::Gem::Release::Registry::ClassMethods)
  extend(::Gem::Release::Helper::String)

  def initialize(context, args, opts); end

  def config; end
  def defaults; end
  def gem; end
  def in_dirs; end
  def in_gem_dirs; end
  def opts; end
  def pretend?; end
  def quiet?; end

  class << self
    def arg(name, summary); end
    def args; end
    def default(opt); end
    def descr(opt); end
    def description(description = T.unsafe(nil)); end
    def inherited(cmd); end
    def opt(*args, &block); end
    def opts; end
    def summary(summary = T.unsafe(nil)); end
    def usage(usage = T.unsafe(nil)); end
  end
end

Gem::Release::Cmds::Base::DEFAULTS = T.let(T.unsafe(nil), Hash)

class Gem::Release::Cmds::Bootstrap < ::Gem::Release::Cmds::Base
  def run; end

  private

  def create_repo; end
  def data; end
  def executable; end
  def files; end
  def init_git; end
  def license; end
  def normalize(opts); end
  def opts; end
  def remote; end
  def scaffold; end
  def write(file); end
end

Gem::Release::Cmds::Bootstrap::CMDS = T.let(T.unsafe(nil), Hash)

Gem::Release::Cmds::Bootstrap::DEFAULTS = T.let(T.unsafe(nil), Hash)

Gem::Release::Cmds::Bootstrap::DESCR = T.let(T.unsafe(nil), Hash)

Gem::Release::Cmds::Bootstrap::FILES = T.let(T.unsafe(nil), Array)

Gem::Release::Cmds::Bootstrap::MSGS = T.let(T.unsafe(nil), Hash)

class Gem::Release::Cmds::Bump < ::Gem::Release::Cmds::Base
  def run; end

  private

  def branch; end
  def bump; end
  def checkout; end
  def commit; end
  def message; end
  def push; end
  def push?; end
  def release(new_version); end
  def remote; end
  def reset; end
  def tag(new_version); end
  def validate; end
  def version; end
end

Gem::Release::Cmds::Bump::CMDS = T.let(T.unsafe(nil), Hash)

Gem::Release::Cmds::Bump::DEFAULTS = T.let(T.unsafe(nil), Hash)

Gem::Release::Cmds::Bump::DESCR = T.let(T.unsafe(nil), Hash)

Gem::Release::Cmds::Bump::MSGS = T.let(T.unsafe(nil), Hash)

class Gem::Release::Cmds::Gemspec < ::Gem::Release::Cmds::Base
  def run; end

  private

  def data; end
  def file; end
  def generate; end
  def templates; end
end

Gem::Release::Cmds::Gemspec::DEFAULTS = T.let(T.unsafe(nil), Hash)

Gem::Release::Cmds::Gemspec::DESCR = T.let(T.unsafe(nil), Hash)

Gem::Release::Cmds::Gemspec::MSGS = T.let(T.unsafe(nil), Hash)

class Gem::Release::Cmds::Github < ::Gem::Release::Cmds::Base
  def run; end

  private

  def data; end
  def descr; end
  def release; end
  def repo; end
  def repo_from(url); end
  def tag_name; end
  def tagged?; end
  def token; end
  def validate; end
end

Gem::Release::Cmds::Github::MSGS = T.let(T.unsafe(nil), Hash)

class Gem::Release::Cmds::Release < ::Gem::Release::Cmds::Base
  def run; end

  private

  def build; end
  def cleanup; end
  def github; end
  def push; end
  def push_args; end
  def release; end
  def tag; end
  def target_version; end
  def validate; end
end

Gem::Release::Cmds::Release::CMDS = T.let(T.unsafe(nil), Hash)

Gem::Release::Cmds::Release::DEFAULTS = T.let(T.unsafe(nil), Hash)

Gem::Release::Cmds::Release::DESCR = T.let(T.unsafe(nil), Hash)

Gem::Release::Cmds::Release::MSGS = T.let(T.unsafe(nil), Hash)

class Gem::Release::Cmds::Runner < ::Struct
  def run; end

  private

  def args; end
  def config; end
  def const; end
  def context; end
  def except(hash, *keys); end
  def opts; end
  def run_cmd; end
  def success; end
end

class Gem::Release::Cmds::Tag < ::Gem::Release::Cmds::Base
  def run; end

  private

  def exists?; end
  def push; end
  def push?; end
  def remote; end
  def tag; end
  def tag_and_push; end
  def tag_name; end
  def target_version; end
  def validate; end
end

Gem::Release::Cmds::Tag::CMDS = T.let(T.unsafe(nil), Hash)

Gem::Release::Cmds::Tag::DEFAULTS = T.let(T.unsafe(nil), Hash)

Gem::Release::Cmds::Tag::DESCR = T.let(T.unsafe(nil), Hash)

Gem::Release::Cmds::Tag::MSGS = T.let(T.unsafe(nil), Hash)

class Gem::Release::Config
  include(::Gem::Release::Helper::Hash)

  def initialize; end

  def [](key); end
  def common; end
  def for(key); end
  def opts; end

  private

  def load; end
  def sources; end
end

class Gem::Release::Config::Env
  include(::Gem::Release::Helper::Hash)

  def load; end

  private

  def cast(value); end
  def keys_for(key); end
  def to_hash(keys, value); end
  def vars; end
end

Gem::Release::Config::Env::FALSE = T.let(T.unsafe(nil), Regexp)

Gem::Release::Config::Env::PREFIX = T.let(T.unsafe(nil), String)

Gem::Release::Config::Env::TRUE = T.let(T.unsafe(nil), Regexp)

class Gem::Release::Config::Files
  include(::Gem::Release::Helper::Hash)

  def load; end

  private

  def path; end
  def paths; end
end

Gem::Release::Config::Files::PATHS = T.let(T.unsafe(nil), Array)

Gem::Release::Config::SOURCES = T.let(T.unsafe(nil), Array)

class Gem::Release::Context
  def initialize(*args); end

  def abort(str); end
  def config; end
  def config=(_arg0); end
  def gem; end
  def gem=(_arg0); end
  def gem_cmd(cmd, *args); end
  def git; end
  def git=(_arg0); end
  def in_dirs(args, opts, &block); end
  def in_gem_dirs(args, opts, &block); end
  def run(cmd); end
  def ui; end
  def ui=(_arg0); end
end

class Gem::Release::Context::Gem
  def initialize(name); end

  def filename; end
  def name; end
  def spec; end
  def spec_filename; end
  def version; end
end

class Gem::Release::Context::Gemspec < ::Struct
  def initialize(*_arg0); end

  def exists?; end
  def filename; end
  def gem_filename; end
  def gem_name; end
  def homepage; end
  def metadata; end
  def version; end

  private

  def filenames; end
  def gemspec; end
end

class Gem::Release::Context::Git
  def clean?; end
  def remotes; end
  def tags; end
  def user_email; end
  def user_login; end
  def user_name; end
end

class Gem::Release::Context::Github
  include(::Gem::Release::Helper::Http)

  def initialize(repo, data); end

  def data; end
  def release; end
  def repo; end

  private

  def body; end
  def headers; end
  def pre?(version); end
  def url; end
end

Gem::Release::Context::Github::MSGS = T.let(T.unsafe(nil), Hash)

Gem::Release::Context::Github::URL = T.let(T.unsafe(nil), String)

class Gem::Release::Context::Paths < ::Struct
end

class Gem::Release::Context::Paths::Base < ::Struct
  def current; end
  def cwd; end
  def in_dir(dir, &block); end
end

class Gem::Release::Context::Paths::ByGemspecs < ::Gem::Release::Context::Paths::Base
  def in_dirs(&block); end

  private

  def by_gemspecs; end
  def by_names; end
  def dirs; end
  def gemspec; end
  def gemspecs(recurse = T.unsafe(nil)); end
  def name_for(path); end
end

class Gem::Release::Context::Paths::ByNames < ::Gem::Release::Context::Paths::Base
  def in_dirs(&block); end

  private

  def dir; end
  def dirs; end
  def dirs_by_names; end
end

module Gem::Release::Context::Ui
  class << self
    def new(opts); end
  end
end

class Gem::Release::Context::Ui::Base < ::Struct
  def puts(*str); end
  def stdout; end
  def stdout=(_arg0); end
end

module Gem::Release::Context::Ui::Colors
  def colored(color, str); end
end

Gem::Release::Context::Ui::Colors::COLORS = T.let(T.unsafe(nil), Hash)

class Gem::Release::Context::Ui::Pipe < ::Gem::Release::Context::Ui::Base
  def announce(msg, args = T.unsafe(nil), _ = T.unsafe(nil)); end
  def cmd(*_arg0); end
  def error(msg, args = T.unsafe(nil), _ = T.unsafe(nil)); end
  def info(msg, args = T.unsafe(nil), _ = T.unsafe(nil)); end
  def notice(msg, args = T.unsafe(nil), _ = T.unsafe(nil)); end
  def success(*_arg0); end
  def warn(msg, args = T.unsafe(nil), _ = T.unsafe(nil)); end

  private

  def format_msg(msg, args); end
  def quote_spaced(str); end
end

class Gem::Release::Context::Ui::Quiet < ::Gem::Release::Context::Ui::Base
  def announce(*_arg0); end
  def cmd(*_arg0); end
  def error(*_arg0); end
  def info(*_arg0); end
  def notice(*_arg0); end
  def success(*_arg0); end
  def warn(*_arg0); end
end

class Gem::Release::Context::Ui::Tty < ::Gem::Release::Context::Ui::Base
  include(::Gem::Release::Context::Ui::Colors)

  def announce(msg, args = T.unsafe(nil), msgs = T.unsafe(nil)); end
  def cmd(msg); end
  def error(msg, args = T.unsafe(nil), msgs = T.unsafe(nil)); end
  def info(msg, args = T.unsafe(nil), msgs = T.unsafe(nil)); end
  def notice(msg, args = T.unsafe(nil), msgs = T.unsafe(nil)); end
  def success(msg); end
  def warn(msg, args = T.unsafe(nil), msgs = T.unsafe(nil)); end

  private

  def colored(color, str); end
  def format_msg(msg, args, msgs); end
  def with_spacing(str, space); end
end

class Gem::Release::Data < ::Struct
  include(::Gem::Release::Helper::String)

  def data; end

  private

  def bin_files; end
  def files; end
  def gem_name; end
  def gem_path; end
  def homepage; end
  def license; end
  def licenses; end
  def module_names; end
  def strategy; end
  def user_email; end
  def user_login; end
  def user_name; end
end

module Gem::Release::Files
end

class Gem::Release::Files::Template
  def initialize(source, target, data, opts); end

  def data; end
  def data=(_arg0); end
  def exists?; end
  def filename; end
  def opts; end
  def opts=(_arg0); end
  def source; end
  def source=(_arg0); end
  def target; end
  def target=(_arg0); end
  def write; end

  private

  def binding; end
  def context; end
  def render; end
  def template; end
end

class Gem::Release::Files::Template::Context < ::OpenStruct
  def define(type, &block); end
end

class Gem::Release::Files::Template::Context::Const < ::Struct
  def build(names, &block); end
  def define(&block); end
  def indent(str, level); end
end

Gem::Release::Files::Template::FILES = T.let(T.unsafe(nil), Hash)

Gem::Release::Files::Template::PATH = T.let(T.unsafe(nil), String)

class Gem::Release::Files::Templates < ::Struct
  def [](filename); end
  def all; end
  def builtin; end
  def custom; end
  def executable; end
  def license; end
  def templates_for(sources, files = T.unsafe(nil), opts = T.unsafe(nil)); end

  class << self
    def executable(target); end
    def license(name, data); end
  end
end

Gem::Release::Files::Templates::BUILTIN = T.let(T.unsafe(nil), Array)

Gem::Release::Files::Templates::CUSTOM = T.let(T.unsafe(nil), Array)

Gem::Release::Files::Templates::EXECUTABLE = T.let(T.unsafe(nil), Array)

class Gem::Release::Files::Templates::Group
  def initialize(groups, data, sources, files); end

  def all; end
  def data; end
  def files; end
  def groups; end
  def sources; end

  private

  def paths; end
  def paths_for(group); end
  def pattern; end
  def relative(file); end
end

Gem::Release::Files::Templates::LICENSE = T.let(T.unsafe(nil), Array)

class Gem::Release::Files::Version < ::Struct
  def bump; end
  def exists?; end
  def from; end
  def path; end
  def to; end
  def to_h; end

  private

  def bumped; end
  def content; end
  def name; end
  def not_found; end
  def number; end
  def path_to(path); end
  def paths; end
  def to_num(*args); end
end

Gem::Release::Files::Version::PRE_RELEASE = T.let(T.unsafe(nil), Regexp)

Gem::Release::Files::Version::RELEASE = T.let(T.unsafe(nil), Regexp)

Gem::Release::Files::Version::STAGES = T.let(T.unsafe(nil), Array)

Gem::Release::Files::Version::VERSION = T.let(T.unsafe(nil), Regexp)

module Gem::Release::Helper
  extend(::Forwardable)

  def abort(msg, *args); end
  def announce(msg, *args); end
  def cmd(cmd, *args); end
  def error(msg, *args); end
  def gem(*args, &block); end
  def gem_cmd(cmd, *args); end
  def git(*args, &block); end
  def info(msg, *args); end
  def notice(msg, *args); end
  def run(cmd); end
  def ui(*args, &block); end
  def warn(msg, *args); end
end

module Gem::Release::Helper::Hash
  def deep_merge(hash, other); end
  def except(hash, *keys); end
  def only(hash, *keys); end
  def symbolize_keys(hash); end
end

Gem::Release::Helper::Hash::MERGER = T.let(T.unsafe(nil), Proc)

module Gem::Release::Helper::Http
  def post(url, body = T.unsafe(nil), headers = T.unsafe(nil)); end
end

class Gem::Release::Helper::Http::Client < ::Struct
  def request; end

  private

  def client; end
  def const; end
  def uri; end
end

module Gem::Release::Helper::String
  def camelize(str); end
  def underscore(str); end
  def wrap(str, width); end
end

class Gem::Release::Helper::Wrapper < ::Struct
  def apply; end

  private

  def wrap_lines(str); end
  def wrap_paragraph(str); end
end

Gem::Release::Helper::Wrapper::MARKDOWN = T.let(T.unsafe(nil), Regexp)

module Gem::Release::Registry
  include(::Gem::Release::Registry::InstanceMethods)

  mixes_in_class_methods(::Gem::Release::Registry::ClassMethods)

  class << self
    def included(const); end
  end
end

module Gem::Release::Registry::ClassMethods
  def [](key); end
  def register(key); end
  def registry; end
  def registry_key; end
  def underscore(string); end
end

module Gem::Release::Registry::InstanceMethods
  def registry_key; end
end

class Gem::Release::Registry::Registry
  def [](key); end
  def []=(key, object); end
  def cmds; end
  def registry; end
end

Gem::Release::STRATEGIES = T.let(T.unsafe(nil), Hash)

Gem::Release::VERSION = T.let(T.unsafe(nil), String)

module Gem::Release::Version
end

class Gem::Release::Version::Number < ::Struct
  def bump; end
  def pre?; end

  private

  def fresh_pre_release?; end
  def from_pre_release?; end
  def from_release?; end
  def from_stage; end
  def major; end
  def matches; end
  def minor; end
  def num; end
  def parse; end
  def parts; end
  def patch; end
  def same_stage?; end
  def specific?; end
  def stage; end
  def stage_delim; end
  def target; end
  def to?(*targets); end
  def to_release?; end
  def validate_stage; end
end

Gem::Release::Version::Number::NUMBER = T.let(T.unsafe(nil), Regexp)

Gem::Release::Version::Number::PRE_RELEASE = T.let(T.unsafe(nil), Regexp)

Gem::Release::Version::Number::STAGES = T.let(T.unsafe(nil), Array)
