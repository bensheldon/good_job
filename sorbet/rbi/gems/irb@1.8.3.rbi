# typed: false

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `irb` gem.
# Please instead update this file by running `bin/tapioca gem irb`.

# source://irb//lib/irb.rb#1006
class Binding
  # Opens an IRB session where +binding.irb+ is called which allows for
  # interactive debugging. You can call any methods or variables available in
  # the current scope, and mutate state if you need to.
  #
  #
  # Given a Ruby file called +potato.rb+ containing the following code:
  #
  #     class Potato
  #       def initialize
  #         @cooked = false
  #         binding.irb
  #         puts "Cooked potato: #{@cooked}"
  #       end
  #     end
  #
  #     Potato.new
  #
  # Running <code>ruby potato.rb</code> will open an IRB session where
  # +binding.irb+ is called, and you will see the following:
  #
  #     $ ruby potato.rb
  #
  #     From: potato.rb @ line 4 :
  #
  #         1: class Potato
  #         2:   def initialize
  #         3:     @cooked = false
  #      => 4:     binding.irb
  #         5:     puts "Cooked potato: #{@cooked}"
  #         6:   end
  #         7: end
  #         8:
  #         9: Potato.new
  #
  #     irb(#<Potato:0x00007feea1916670>):001:0>
  #
  # You can type any valid Ruby code and it will be evaluated in the current
  # context. This allows you to debug without having to run your code repeatedly:
  #
  #     irb(#<Potato:0x00007feea1916670>):001:0> @cooked
  #     => false
  #     irb(#<Potato:0x00007feea1916670>):002:0> self.class
  #     => Potato
  #     irb(#<Potato:0x00007feea1916670>):003:0> caller.first
  #     => ".../2.5.1/lib/ruby/2.5.0/irb/workspace.rb:85:in `eval'"
  #     irb(#<Potato:0x00007feea1916670>):004:0> @cooked = true
  #     => true
  #
  # You can exit the IRB session with the +exit+ command. Note that exiting will
  # resume execution where +binding.irb+ had paused it, as you can see from the
  # output printed to standard output in this example:
  #
  #     irb(#<Potato:0x00007feea1916670>):005:0> exit
  #     Cooked potato: true
  #
  #
  # See IRB@Usage for more information.
  #
  # source://irb//lib/irb.rb#1064
  def irb(show_code: T.unsafe(nil)); end
end

# IRB stands for "interactive Ruby" and is a tool to interactively execute Ruby
# expressions read from the standard input.
#
# The +irb+ command from your shell will start the interpreter.
#
# == Usage
#
# Use of irb is easy if you know Ruby.
#
# When executing irb, prompts are displayed as follows. Then, enter the Ruby
# expression. An input is executed when it is syntactically complete.
#
#     $ irb
#     irb(main):001:0> 1+2
#     #=> 3
#     irb(main):002:0> class Foo
#     irb(main):003:1>  def foo
#     irb(main):004:2>    print 1
#     irb(main):005:2>  end
#     irb(main):006:1> end
#     #=> nil
#
# The singleline editor module or multiline editor module can be used with irb.
# Use of multiline editor is default if it's installed.
#
# == Command line options
#
#   :include: ./irb/lc/help-message
#
# == Commands
#
# The following commands are available on IRB.
#
# * cwws
#   * Show the current workspace.
# * cb, cws, chws
#   * Change the current workspace to an object.
# * bindings, workspaces
#   * Show workspaces.
# * pushb, pushws
#   * Push an object to the workspace stack.
# * popb, popws
#   * Pop a workspace from the workspace stack.
# * load
#   * Load a Ruby file.
# * require
#   * Require a Ruby file.
# * source
#   * Loads a given file in the current session.
# * irb
#   * Start a child IRB.
# * jobs
#   * List of current sessions.
# * fg
#   * Switches to the session of the given number.
# * kill
#   * Kills the session with the given number.
# * help
#   * Enter the mode to look up RI documents.
# * irb_info
#   * Show information about IRB.
# * ls
#   * Show methods, constants, and variables.
#     -g [query] or -G [query] allows you to filter out the output.
# * measure
#   * measure enables the mode to measure processing time. measure :off disables it.
# * $, show_source
#   * Show the source code of a given method or constant.
# * @, whereami
#   * Show the source code around binding.irb again.
# * debug
#   * Start the debugger of debug.gem.
# * break, delete, next, step, continue, finish, backtrace, info, catch
#   * Start the debugger of debug.gem and run the command on it.
#
# == Configuration
#
# IRB reads a personal initialization file when it's invoked.
# IRB searches a file in the following order and loads the first one found.
#
# * <tt>$IRBRC</tt> (if <tt>$IRBRC</tt> is set)
# * <tt>$XDG_CONFIG_HOME/irb/irbrc</tt> (if <tt>$XDG_CONFIG_HOME</tt> is set)
# * <tt>~/.irbrc</tt>
# * +.config/irb/irbrc+
# * +.irbrc+
# * +irb.rc+
# * +_irbrc+
# * <code>$irbrc</code>
#
# The following are alternatives to the command line options. To use them type
# as follows in an +irb+ session:
#
#     IRB.conf[:IRB_NAME]="irb"
#     IRB.conf[:INSPECT_MODE]=nil
#     IRB.conf[:IRB_RC] = nil
#     IRB.conf[:BACK_TRACE_LIMIT]=16
#     IRB.conf[:USE_LOADER] = false
#     IRB.conf[:USE_MULTILINE] = nil
#     IRB.conf[:USE_SINGLELINE] = nil
#     IRB.conf[:USE_COLORIZE] = true
#     IRB.conf[:USE_TRACER] = false
#     IRB.conf[:USE_AUTOCOMPLETE] = true
#     IRB.conf[:IGNORE_SIGINT] = true
#     IRB.conf[:IGNORE_EOF] = false
#     IRB.conf[:PROMPT_MODE] = :DEFAULT
#     IRB.conf[:PROMPT] = {...}
#
# === Auto indentation
#
# To disable auto-indent mode in irb, add the following to your +.irbrc+:
#
#     IRB.conf[:AUTO_INDENT] = false
#
# === Autocompletion
#
# To disable autocompletion for irb, add the following to your +.irbrc+:
#
#     IRB.conf[:USE_AUTOCOMPLETE] = false
#
# === History
#
# By default, irb will store the last 1000 commands you used in
# <code>IRB.conf[:HISTORY_FILE]</code> (<code>~/.irb_history</code> by default).
#
# If you want to disable history, add the following to your +.irbrc+:
#
#     IRB.conf[:SAVE_HISTORY] = nil
#
# See IRB::Context#save_history= for more information.
#
# The history of _results_ of commands evaluated is not stored by default,
# but can be turned on to be stored with this +.irbrc+ setting:
#
#     IRB.conf[:EVAL_HISTORY] = <number>
#
# See IRB::Context#eval_history= and EvalHistory class. The history of command
# results is not permanently saved in any file.
#
# == Customizing the IRB Prompt
#
# In order to customize the prompt, you can change the following Hash:
#
#     IRB.conf[:PROMPT]
#
# This example can be used in your +.irbrc+
#
#     IRB.conf[:PROMPT][:MY_PROMPT] = { # name of prompt mode
#       :AUTO_INDENT => false,          # disables auto-indent mode
#       :PROMPT_I =>  ">> ",		# simple prompt
#       :PROMPT_S => nil,		# prompt for continuated strings
#       :PROMPT_C => nil,		# prompt for continuated statement
#       :RETURN => "    ==>%s\n"	# format to return value
#     }
#
#     IRB.conf[:PROMPT_MODE] = :MY_PROMPT
#
# Or, invoke irb with the above prompt mode by:
#
#     irb --prompt my-prompt
#
# Constants +PROMPT_I+, +PROMPT_S+ and +PROMPT_C+ specify the format. In the
# prompt specification, some special strings are available:
#
#     %N    # command name which is running
#     %m    # to_s of main object (self)
#     %M    # inspect of main object (self)
#     %l    # type of string(", ', /, ]), `]' is inner %w[...]
#     %NNi  # indent level. NN is digits and means as same as printf("%NNd").
#           # It can be omitted
#     %NNn  # line number.
#     %%    # %
#
# For instance, the default prompt mode is defined as follows:
#
#     IRB.conf[:PROMPT_MODE][:DEFAULT] = {
#       :PROMPT_I => "%N(%m):%03n> ",
#       :PROMPT_S => "%N(%m):%03n%l ",
#       :PROMPT_C => "%N(%m):%03n* ",
#       :RETURN => "%s\n" # used to printf
#     }
#
# irb comes with a number of available modes:
#
#   # :NULL:
#   #   :PROMPT_I:
#   #   :PROMPT_S:
#   #   :PROMPT_C:
#   #   :RETURN: |
#   #     %s
#   # :DEFAULT:
#   #   :PROMPT_I: ! '%N(%m):%03n> '
#   #   :PROMPT_S: ! '%N(%m):%03n%l '
#   #   :PROMPT_C: ! '%N(%m):%03n* '
#   #   :RETURN: |
#   #     => %s
#   # :CLASSIC:
#   #   :PROMPT_I: ! '%N(%m):%03n:%i> '
#   #   :PROMPT_S: ! '%N(%m):%03n:%i%l '
#   #   :PROMPT_C: ! '%N(%m):%03n:%i* '
#   #   :RETURN: |
#   #     %s
#   # :SIMPLE:
#   #   :PROMPT_I: ! '>> '
#   #   :PROMPT_S:
#   #   :PROMPT_C: ! '?> '
#   #   :RETURN: |
#   #     => %s
#   # :INF_RUBY:
#   #   :PROMPT_I: ! '%N(%m):%03n> '
#   #   :PROMPT_S:
#   #   :PROMPT_C:
#   #   :RETURN: |
#   #     %s
#   #   :AUTO_INDENT: true
#   # :XMP:
#   #   :PROMPT_I:
#   #   :PROMPT_S:
#   #   :PROMPT_C:
#   #   :RETURN: |2
#   #         ==>%s
#
# == Restrictions
#
# Because irb evaluates input immediately after it is syntactically complete,
# the results may be slightly different than directly using Ruby.
#
# == IRB Sessions
#
# IRB has a special feature, that allows you to manage many sessions at once.
#
# You can create new sessions with Irb.irb, and get a list of current sessions
# with the +jobs+ command in the prompt.
#
# === Commands
#
# JobManager provides commands to handle the current sessions:
#
#   jobs    # List of current sessions
#   fg      # Switches to the session of the given number
#   kill    # Kills the session with the given number
#
# The +exit+ command, or ::irb_exit, will quit the current session and call any
# exit hooks with IRB.irb_at_exit.
#
# A few commands for loading files within the session are also available:
#
# +source+::
#   Loads a given file in the current session and displays the source lines,
#   see IrbLoader#source_file
# +irb_load+::
#   Loads the given file similarly to Kernel#load, see IrbLoader#irb_load
# +irb_require+::
#   Loads the given file similarly to Kernel#require
#
# === Configuration
#
# The command line options, or IRB.conf, specify the default behavior of
# Irb.irb.
#
# On the other hand, each conf in IRB@Command+line+options is used to
# individually configure IRB.irb.
#
# If a proc is set for <code>IRB.conf[:IRB_RC]</code>, its will be invoked after execution
# of that proc with the context of the current session as its argument. Each
# session can be configured using this mechanism.
#
# === Session variables
#
# There are a few variables in every Irb session that can come in handy:
#
# <code>_</code>::
#   The value command executed, as a local variable
# <code>__</code>::
#   The history of evaluated commands. Available only if
#   <code>IRB.conf[:EVAL_HISTORY]</code> is not +nil+ (which is the default).
#   See also IRB::Context#eval_history= and IRB::History.
# <code>__[line_no]</code>::
#   Returns the evaluation value at the given line number, +line_no+.
#   If +line_no+ is a negative, the return value +line_no+ many lines before
#   the most recent return value.
#
# === Example using IRB Sessions
#
#   # invoke a new session
#   irb(main):001:0> irb
#   # list open sessions
#   irb.1(main):001:0> jobs
#     #0->irb on main (#<Thread:0x400fb7e4> : stop)
#     #1->irb#1 on main (#<Thread:0x40125d64> : running)
#
#   # change the active session
#   irb.1(main):002:0> fg 0
#   # define class Foo in top-level session
#   irb(main):002:0> class Foo;end
#   # invoke a new session with the context of Foo
#   irb(main):003:0> irb Foo
#   # define Foo#foo
#   irb.2(Foo):001:0> def foo
#   irb.2(Foo):002:1>   print 1
#   irb.2(Foo):003:1> end
#
#   # change the active session
#   irb.2(Foo):004:0> fg 0
#   # list open sessions
#   irb(main):004:0> jobs
#     #0->irb on main (#<Thread:0x400fb7e4> : running)
#     #1->irb#1 on main (#<Thread:0x40125d64> : stop)
#     #2->irb#2 on Foo (#<Thread:0x4011d54c> : stop)
#   # check if Foo#foo is available
#   irb(main):005:0> Foo.instance_methods #=> [:foo, ...]
#
#   # change the active session
#   irb(main):006:0> fg 2
#   # define Foo#bar in the context of Foo
#   irb.2(Foo):005:0> def bar
#   irb.2(Foo):006:1>  print "bar"
#   irb.2(Foo):007:1> end
#   irb.2(Foo):010:0>  Foo.instance_methods #=> [:bar, :foo, ...]
#
#   # change the active session
#   irb.2(Foo):011:0> fg 0
#   irb(main):007:0> f = Foo.new  #=> #<Foo:0x4010af3c>
#   # invoke a new session with the context of f (instance of Foo)
#   irb(main):008:0> irb f
#   # list open sessions
#   irb.3(<Foo:0x4010af3c>):001:0> jobs
#     #0->irb on main (#<Thread:0x400fb7e4> : stop)
#     #1->irb#1 on main (#<Thread:0x40125d64> : stop)
#     #2->irb#2 on Foo (#<Thread:0x4011d54c> : stop)
#     #3->irb#3 on #<Foo:0x4010af3c> (#<Thread:0x4010a1e0> : running)
#   # evaluate f.foo
#   irb.3(<Foo:0x4010af3c>):002:0> foo #=> 1 => nil
#   # evaluate f.bar
#   irb.3(<Foo:0x4010af3c>):003:0> bar #=> bar => nil
#   # kill jobs 1, 2, and 3
#   irb.3(<Foo:0x4010af3c>):004:0> kill 1, 2, 3
#   # list open sessions, should only include main session
#   irb(main):009:0> jobs
#     #0->irb on main (#<Thread:0x400fb7e4> : running)
#   # quit irb
#   irb(main):010:0> exit
#
# source://irb//lib/irb/init.rb#7
module IRB
  class << self
    # The current IRB::Context of the session, see IRB.conf
    #
    #   irb
    #   irb(main):001:0> IRB.CurrentContext.irb_name = "foo"
    #   foo(main):002:0> IRB.conf[:MAIN_CONTEXT].irb_name #=> "foo"
    #
    # source://irb//lib/irb.rb#393
    def CurrentContext; end

    # Convenience method to create a new Inspector, using the given +inspect+
    # proc, and optional +init+ proc and passes them to Inspector.new
    #
    #     irb(main):001:0> ins = IRB::Inspector(proc{ |v| "omg! #{v}" })
    #     irb(main):001:0> IRB.CurrentContext.inspect_mode = ins # => omg! #<IRB::Inspector:0x007f46f7ba7d28>
    #     irb(main):001:0> "what?" #=> omg! what?
    #
    # source://irb//lib/irb/inspector.rb#17
    def Inspector(inspect, init = T.unsafe(nil)); end

    # Displays current configuration.
    #
    # Modifying the configuration is achieved by sending a message to IRB.conf.
    #
    # See IRB@Configuration for more information.
    #
    # source://irb//lib/irb.rb#376
    def conf; end

    # source://irb//lib/irb/init.rb#23
    def init_config(ap_path); end

    # source://irb//lib/irb/init.rb#206
    def init_error; end

    # Aborts then interrupts irb.
    #
    # Will raise an Abort exception, or the given +exception+.
    #
    # source://irb//lib/irb.rb#420
    def irb_abort(irb, exception = T.unsafe(nil)); end

    # Quits irb
    #
    # source://irb//lib/irb.rb#413
    def irb_exit(irb, ret); end

    # loading modules
    #
    # source://irb//lib/irb/init.rb#408
    def load_modules; end

    # option analyzing
    #
    # source://irb//lib/irb/init.rb#211
    def parse_opts(argv: T.unsafe(nil)); end

    # source://irb//lib/irb/init.rb#367
    def rc_file(ext = T.unsafe(nil)); end

    # enumerate possible rc-file base name generators
    #
    # @yield [proc{|rc| current_dir+"/.irb#{rc}"}]
    #
    # source://irb//lib/irb/init.rb#386
    def rc_file_generators; end

    # running config
    #
    # source://irb//lib/irb/init.rb#351
    def run_config; end

    # source://irb//lib/irb/init.rb#161
    def set_measure_callback(type = T.unsafe(nil), arg = T.unsafe(nil), &block); end

    # initialize config
    #
    # source://irb//lib/irb/init.rb#10
    def setup(ap_path, argv: T.unsafe(nil)); end

    # Initializes IRB and creates a new Irb.irb object at the +TOPLEVEL_BINDING+
    #
    # source://irb//lib/irb.rb#398
    def start(ap_path = T.unsafe(nil)); end

    # source://irb//lib/irb/init.rb#197
    def unset_measure_callback(type = T.unsafe(nil)); end

    # Returns the current version of IRB, including release version and last
    # updated date.
    #
    # source://irb//lib/irb.rb#382
    def version; end

    private

    # source://irb//lib/irb/easter-egg.rb#101
    def easter_egg(type = T.unsafe(nil)); end

    # source://irb//lib/irb/init.rb#420
    def set_encoding(extern, intern = T.unsafe(nil), override: T.unsafe(nil)); end
  end
end

# source://irb//lib/irb/completion.rb#11
class IRB::BaseCompletor
  # @raise [NotImplementedError]
  #
  # source://irb//lib/irb/completion.rb#12
  def completion_candidates(preposing, target, postposing, bind:); end

  # @raise [NotImplementedError]
  #
  # source://irb//lib/irb/completion.rb#16
  def doc_namespace(preposing, matched, postposing, bind:); end

  # source://irb//lib/irb/completion.rb#46
  def retrieve_files_to_require_from_load_path; end

  # source://irb//lib/irb/completion.rb#65
  def retrieve_files_to_require_relative_from_current_dir; end

  # source://irb//lib/irb/completion.rb#35
  def retrieve_gem_and_system_load_path; end
end

# source://irb//lib/irb/completion.rb#20
IRB::BaseCompletor::GEM_PATHS = T.let(T.unsafe(nil), Array)

# source://irb//lib/irb/color.rb#7
module IRB::Color
  class << self
    # source://irb//lib/irb/color.rb#114
    def clear(colorable: T.unsafe(nil)); end

    # @return [Boolean]
    #
    # source://irb//lib/irb/color.rb#81
    def colorable?; end

    # source://irb//lib/irb/color.rb#119
    def colorize(text, seq, colorable: T.unsafe(nil)); end

    # If `complete` is false (code is incomplete), this does not warn compile_error.
    # This option is needed to avoid warning a user when the compile_error is happening
    # because the input is not wrong but just incomplete.
    #
    # source://irb//lib/irb/color.rb#128
    def colorize_code(code, complete: T.unsafe(nil), ignore_error: T.unsafe(nil), colorable: T.unsafe(nil), local_variables: T.unsafe(nil)); end

    # @return [Boolean]
    #
    # source://irb//lib/irb/color.rb#93
    def inspect_colorable?(obj, seen: T.unsafe(nil)); end

    private

    # source://irb//lib/irb/color.rb#213
    def dispatch_seq(token, expr, str, in_symbol:); end

    # source://irb//lib/irb/color.rb#177
    def scan(code, allow_last_error:); end

    # source://irb//lib/irb/color.rb#169
    def without_circular_ref(obj, seen:, &block); end
  end
end

# A constant of all-bit 1 to match any Ripper's state in #dispatch_seq
#
# source://irb//lib/irb/color.rb#28
IRB::Color::ALL = T.let(T.unsafe(nil), Integer)

# source://irb//lib/irb/color.rb#12
IRB::Color::BLACK = T.let(T.unsafe(nil), Integer)

# source://irb//lib/irb/color.rb#16
IRB::Color::BLUE = T.let(T.unsafe(nil), Integer)

# source://irb//lib/irb/color.rb#9
IRB::Color::BOLD = T.let(T.unsafe(nil), Integer)

# source://irb//lib/irb/color.rb#8
IRB::Color::CLEAR = T.let(T.unsafe(nil), Integer)

# source://irb//lib/irb/color.rb#18
IRB::Color::CYAN = T.let(T.unsafe(nil), Integer)

# source://irb//lib/irb/color.rb#77
IRB::Color::ERROR_TOKENS = T.let(T.unsafe(nil), Array)

# source://irb//lib/irb/color.rb#14
IRB::Color::GREEN = T.let(T.unsafe(nil), Integer)

# source://irb//lib/irb/color.rb#17
IRB::Color::MAGENTA = T.let(T.unsafe(nil), Integer)

# source://irb//lib/irb/color.rb#13
IRB::Color::RED = T.let(T.unsafe(nil), Integer)

# source://irb//lib/irb/color.rb#11
IRB::Color::REVERSE = T.let(T.unsafe(nil), Integer)

# A class to manage a state to know whether the current token is for Symbol or not.
#
# source://irb//lib/irb/color.rb#229
class IRB::Color::SymbolState
  # @return [SymbolState] a new instance of SymbolState
  #
  # source://irb//lib/irb/color.rb#230
  def initialize; end

  # Return true if the token is a part of Symbol.
  #
  # source://irb//lib/irb/color.rb#236
  def scan_token(token); end
end

# source://irb//lib/irb/color.rb#21
IRB::Color::TOKEN_KEYWORDS = T.let(T.unsafe(nil), Hash)

# source://irb//lib/irb/color.rb#34
IRB::Color::TOKEN_SEQ_EXPRS = T.let(T.unsafe(nil), Hash)

# source://irb//lib/irb/color.rb#10
IRB::Color::UNDERLINE = T.let(T.unsafe(nil), Integer)

# source://irb//lib/irb/color.rb#19
IRB::Color::WHITE = T.let(T.unsafe(nil), Integer)

# source://irb//lib/irb/color.rb#15
IRB::Color::YELLOW = T.let(T.unsafe(nil), Integer)

# source://irb//lib/irb/context.rb#15
class IRB::Context
  # Creates a new IRB context.
  #
  # The optional +input_method+ argument:
  #
  # +nil+::     uses stdin or Reline or Readline
  # +String+::  uses a File
  # +other+::   uses this as InputMethod
  #
  # @return [Context] a new instance of Context
  #
  # source://irb//lib/irb/context.rb#23
  def initialize(irb, workspace = T.unsafe(nil), input_method = T.unsafe(nil)); end

  # A copy of the default <code>IRB.conf[:AP_NAME]</code>
  #
  # source://irb//lib/irb/context.rb#191
  def ap_name; end

  # A copy of the default <code>IRB.conf[:AP_NAME]</code>
  #
  # source://irb//lib/irb/context.rb#191
  def ap_name=(_arg0); end

  # Can be either the default <code>IRB.conf[:AUTO_INDENT]</code>, or the
  # mode set by #prompt_mode=
  #
  # To disable auto-indentation in irb:
  #
  #     IRB.conf[:AUTO_INDENT] = false
  #
  # or
  #
  #     irb_context.auto_indent_mode = false
  #
  # or
  #
  #     IRB.CurrentContext.auto_indent_mode = false
  #
  # See IRB@Configuration for more information.
  #
  # source://irb//lib/irb/context.rb#261
  def auto_indent_mode; end

  # Can be either the default <code>IRB.conf[:AUTO_INDENT]</code>, or the
  # mode set by #prompt_mode=
  #
  # To disable auto-indentation in irb:
  #
  #     IRB.conf[:AUTO_INDENT] = false
  #
  # or
  #
  #     irb_context.auto_indent_mode = false
  #
  # or
  #
  #     IRB.CurrentContext.auto_indent_mode = false
  #
  # See IRB@Configuration for more information.
  #
  # source://irb//lib/irb/context.rb#261
  def auto_indent_mode=(_arg0); end

  # The limit of backtrace lines displayed as top +n+ and tail +n+.
  #
  # The default value is 16.
  #
  # Can also be set using the +--back-trace-limit+ command line option.
  #
  # See IRB@Command+line+options for more command line options.
  #
  # source://irb//lib/irb/context.rb#354
  def back_trace_limit; end

  # The limit of backtrace lines displayed as top +n+ and tail +n+.
  #
  # The default value is 16.
  #
  # Can also be set using the +--back-trace-limit+ command line option.
  #
  # See IRB@Command+line+options for more command line options.
  #
  # source://irb//lib/irb/context.rb#354
  def back_trace_limit=(_arg0); end

  # User-defined IRB command aliases
  #
  # source://irb//lib/irb/context.rb#357
  def command_aliases; end

  # User-defined IRB command aliases
  #
  # source://irb//lib/irb/context.rb#357
  def command_aliases=(_arg0); end

  # Whether to echo the return value to output or not.
  #
  # Uses <code>IRB.conf[:ECHO]</code> if available, or defaults to +true+.
  #
  #     puts "hello"
  #     # hello
  #     #=> nil
  #     IRB.CurrentContext.echo = false
  #     puts "omg"
  #     # omg
  #
  # source://irb//lib/irb/context.rb#292
  def echo; end

  # Whether to echo the return value to output or not.
  #
  # Uses <code>IRB.conf[:ECHO]</code> if available, or defaults to +true+.
  #
  #     puts "hello"
  #     # hello
  #     #=> nil
  #     IRB.CurrentContext.echo = false
  #     puts "omg"
  #     # omg
  #
  # source://irb//lib/irb/context.rb#292
  def echo=(_arg0); end

  # Whether to echo the return value to output or not.
  #
  # Uses <code>IRB.conf[:ECHO]</code> if available, or defaults to +true+.
  #
  #     puts "hello"
  #     # hello
  #     #=> nil
  #     IRB.CurrentContext.echo = false
  #     puts "omg"
  #     # omg
  #
  # source://irb//lib/irb/context.rb#292
  def echo?; end

  # Whether to echo for assignment expressions.
  #
  # If set to +false+, the value of assignment will not be shown.
  #
  # If set to +true+, the value of assignment will be shown.
  #
  # If set to +:truncate+, the value of assignment will be shown and truncated.
  #
  # It defaults to +:truncate+.
  #
  #     a = "omg"
  #     #=> omg
  #
  #     a = "omg" * 10
  #     #=> omgomgomgomgomgomgomg...
  #
  #     IRB.CurrentContext.echo_on_assignment = false
  #     a = "omg"
  #
  #     IRB.CurrentContext.echo_on_assignment = true
  #     a = "omg" * 10
  #     #=> omgomgomgomgomgomgomgomgomgomg
  #
  # To set the behaviour of showing on assignment in irb:
  #
  #     IRB.conf[:ECHO_ON_ASSIGNMENT] = :truncate or true or false
  #
  # or
  #
  #     irb_context.echo_on_assignment = :truncate or true or false
  #
  # or
  #
  #     IRB.CurrentContext.echo_on_assignment = :truncate or true or false
  #
  # source://irb//lib/irb/context.rb#327
  def echo_on_assignment; end

  # Whether to echo for assignment expressions.
  #
  # If set to +false+, the value of assignment will not be shown.
  #
  # If set to +true+, the value of assignment will be shown.
  #
  # If set to +:truncate+, the value of assignment will be shown and truncated.
  #
  # It defaults to +:truncate+.
  #
  #     a = "omg"
  #     #=> omg
  #
  #     a = "omg" * 10
  #     #=> omgomgomgomgomgomgomg...
  #
  #     IRB.CurrentContext.echo_on_assignment = false
  #     a = "omg"
  #
  #     IRB.CurrentContext.echo_on_assignment = true
  #     a = "omg" * 10
  #     #=> omgomgomgomgomgomgomgomgomgomg
  #
  # To set the behaviour of showing on assignment in irb:
  #
  #     IRB.conf[:ECHO_ON_ASSIGNMENT] = :truncate or true or false
  #
  # or
  #
  #     irb_context.echo_on_assignment = :truncate or true or false
  #
  # or
  #
  #     IRB.CurrentContext.echo_on_assignment = :truncate or true or false
  #
  # source://irb//lib/irb/context.rb#327
  def echo_on_assignment=(_arg0); end

  # Whether to echo for assignment expressions.
  #
  # If set to +false+, the value of assignment will not be shown.
  #
  # If set to +true+, the value of assignment will be shown.
  #
  # If set to +:truncate+, the value of assignment will be shown and truncated.
  #
  # It defaults to +:truncate+.
  #
  #     a = "omg"
  #     #=> omg
  #
  #     a = "omg" * 10
  #     #=> omgomgomgomgomgomgomg...
  #
  #     IRB.CurrentContext.echo_on_assignment = false
  #     a = "omg"
  #
  #     IRB.CurrentContext.echo_on_assignment = true
  #     a = "omg" * 10
  #     #=> omgomgomgomgomgomgomgomgomgomg
  #
  # To set the behaviour of showing on assignment in irb:
  #
  #     IRB.conf[:ECHO_ON_ASSIGNMENT] = :truncate or true or false
  #
  # or
  #
  #     irb_context.echo_on_assignment = :truncate or true or false
  #
  # or
  #
  #     IRB.CurrentContext.echo_on_assignment = :truncate or true or false
  #
  # source://irb//lib/irb/context.rb#327
  def echo_on_assignment?; end

  # Sets command result history limit. Default value is set from
  # <code>IRB.conf[:EVAL_HISTORY]</code>.
  #
  # +no+ is an Integer or +nil+.
  #
  # Returns +no+ of history items if greater than 0.
  #
  # If +no+ is 0, the number of history items is unlimited.
  #
  # If +no+ is +nil+, execution result history isn't used (default).
  #
  # EvalHistory values are available via <code>__</code> variable, see
  # IRB::EvalHistory.
  #
  # source://irb//lib/irb/extend-command.rb#341
  def eval_history=(*opts, &b); end

  # source://irb//lib/irb/context.rb#504
  def evaluate(line, line_no); end

  # Exits the current session, see IRB.irb_exit
  #
  # source://irb//lib/irb/context.rb#537
  def exit(ret = T.unsafe(nil)); end

  # Specify the installation locations of the ri file to be displayed in the
  # document dialog.
  #
  # source://irb//lib/irb/context.rb#281
  def extra_doc_dirs; end

  # Specify the installation locations of the ri file to be displayed in the
  # document dialog.
  #
  # source://irb//lib/irb/context.rb#281
  def extra_doc_dirs=(_arg0); end

  # Whether #io uses a File for the +input_method+ passed when creating the
  # current context, see ::new
  #
  # @return [Boolean]
  #
  # source://irb//lib/irb/context.rb#444
  def file_input?; end

  # A copy of the default <code>IRB.conf[:HISTORY_FILE]</code>
  #
  # source://irb//lib/irb/context.rb#161
  def history_file; end

  # Set <code>IRB.conf[:HISTORY_FILE]</code> to the given +hist+.
  #
  # source://irb//lib/irb/context.rb#166
  def history_file=(hist); end

  # Whether <code>^D</code> (+control-d+) will be ignored or not.
  #
  # If set to +false+, <code>^D</code> will quit irb.
  #
  # source://irb//lib/irb/context.rb#278
  def ignore_eof; end

  # Whether <code>^D</code> (+control-d+) will be ignored or not.
  #
  # If set to +false+, <code>^D</code> will quit irb.
  #
  # source://irb//lib/irb/context.rb#278
  def ignore_eof=(_arg0); end

  # Whether <code>^D</code> (+control-d+) will be ignored or not.
  #
  # If set to +false+, <code>^D</code> will quit irb.
  #
  # source://irb//lib/irb/context.rb#278
  def ignore_eof?; end

  # Whether <code>^C</code> (+control-c+) will be ignored or not.
  #
  # If set to +false+, <code>^C</code> will quit irb.
  #
  # If set to +true+,
  #
  # * during input:   cancel input then return to top level.
  # * during execute: abandon current execution.
  #
  # source://irb//lib/irb/context.rb#274
  def ignore_sigint; end

  # Whether <code>^C</code> (+control-c+) will be ignored or not.
  #
  # If set to +false+, <code>^C</code> will quit irb.
  #
  # If set to +true+,
  #
  # * during input:   cancel input then return to top level.
  # * during execute: abandon current execution.
  #
  # source://irb//lib/irb/context.rb#274
  def ignore_sigint=(_arg0); end

  # Whether <code>^C</code> (+control-c+) will be ignored or not.
  #
  # If set to +false+, <code>^C</code> will quit irb.
  #
  # If set to +true+,
  #
  # * during input:   cancel input then return to top level.
  # * during execute: abandon current execution.
  #
  # source://irb//lib/irb/context.rb#274
  def ignore_sigint?; end

  # source://irb//lib/irb/context.rb#548
  def inspect; end

  # Whether #inspect_mode is set or not, see #inspect_mode= for more detail.
  #
  # @return [Boolean]
  #
  # source://irb//lib/irb/context.rb#438
  def inspect?; end

  # source://irb//lib/irb/context.rb#531
  def inspect_last_value; end

  # A copy of the default <code>IRB.conf[:INSPECT_MODE]</code>
  #
  # source://irb//lib/irb/context.rb#216
  def inspect_mode; end

  # Specifies the inspect mode with +opt+:
  #
  # +true+::  display +inspect+
  # +false+:: display +to_s+
  # +nil+::   inspect mode in non-math mode,
  #           non-inspect mode in math mode
  #
  # See IRB::Inspector for more information.
  #
  # Can also be set using the +--inspect+ and +--noinspect+ command line
  # options.
  #
  # See IRB@Command+line+options for more command line options.
  #
  # source://irb//lib/irb/context.rb#461
  def inspect_mode=(opt); end

  # The current input method.
  #
  # Can be either StdioInputMethod, ReadlineInputMethod,
  # RelineInputMethod, FileInputMethod or other specified when the
  # context is created. See ::new for more # information on +input_method+.
  #
  # source://irb//lib/irb/context.rb#186
  def io; end

  # The current input method.
  #
  # Can be either StdioInputMethod, ReadlineInputMethod,
  # RelineInputMethod, FileInputMethod or other specified when the
  # context is created. See ::new for more # information on +input_method+.
  #
  # source://irb//lib/irb/context.rb#186
  def io=(_arg0); end

  # Current irb session.
  #
  # source://irb//lib/irb/context.rb#189
  def irb; end

  # Current irb session.
  #
  # source://irb//lib/irb/context.rb#189
  def irb=(_arg0); end

  # Can be either name from <code>IRB.conf[:IRB_NAME]</code>, or the number of
  # the current job set by JobManager, such as <code>irb#2</code>
  #
  # source://irb//lib/irb/context.rb#198
  def irb_name; end

  # Can be either name from <code>IRB.conf[:IRB_NAME]</code>, or the number of
  # the current job set by JobManager, such as <code>irb#2</code>
  #
  # source://irb//lib/irb/context.rb#198
  def irb_name=(_arg0); end

  # Can be either the #irb_name surrounded by parenthesis, or the
  # +input_method+ passed to Context.new
  #
  # source://irb//lib/irb/context.rb#201
  def irb_path; end

  # Can be either the #irb_name surrounded by parenthesis, or the
  # +input_method+ passed to Context.new
  #
  # source://irb//lib/irb/context.rb#201
  def irb_path=(_arg0); end

  # The return value of the last statement evaluated.
  #
  # source://irb//lib/irb/context.rb#410
  def last_value; end

  # A copy of the default <code>IRB.conf[:LOAD_MODULES]</code>
  #
  # source://irb//lib/irb/context.rb#195
  def load_modules; end

  # A copy of the default <code>IRB.conf[:LOAD_MODULES]</code>
  #
  # source://irb//lib/irb/context.rb#195
  def load_modules=(_arg0); end

  # source://irb//lib/irb/context.rb#570
  def local_variables; end

  # The top-level workspace, see WorkSpace#main
  #
  # source://irb//lib/irb/context.rb#171
  def main; end

  # Whether a newline is put before multiline output.
  #
  # Uses <code>IRB.conf[:NEWLINE_BEFORE_MULTILINE_OUTPUT]</code> if available,
  # or defaults to +true+.
  #
  #     "abc\ndef"
  #     #=>
  #     abc
  #     def
  #     IRB.CurrentContext.newline_before_multiline_output = false
  #     "abc\ndef"
  #     #=> abc
  #     def
  #
  # source://irb//lib/irb/context.rb#341
  def newline_before_multiline_output; end

  # Whether a newline is put before multiline output.
  #
  # Uses <code>IRB.conf[:NEWLINE_BEFORE_MULTILINE_OUTPUT]</code> if available,
  # or defaults to +true+.
  #
  #     "abc\ndef"
  #     #=>
  #     abc
  #     def
  #     IRB.CurrentContext.newline_before_multiline_output = false
  #     "abc\ndef"
  #     #=> abc
  #     def
  #
  # source://irb//lib/irb/context.rb#341
  def newline_before_multiline_output=(_arg0); end

  # Whether a newline is put before multiline output.
  #
  # Uses <code>IRB.conf[:NEWLINE_BEFORE_MULTILINE_OUTPUT]</code> if available,
  # or defaults to +true+.
  #
  #     "abc\ndef"
  #     #=>
  #     abc
  #     def
  #     IRB.CurrentContext.newline_before_multiline_output = false
  #     "abc\ndef"
  #     #=> abc
  #     def
  #
  # source://irb//lib/irb/context.rb#341
  def newline_before_multiline_output?; end

  # IRB prompt for continuated statement. (e.g. immediately after an +if+)
  #
  # See IRB@Customizing+the+IRB+Prompt for more information.
  #
  # source://irb//lib/irb/context.rb#231
  def prompt_c; end

  # IRB prompt for continuated statement. (e.g. immediately after an +if+)
  #
  # See IRB@Customizing+the+IRB+Prompt for more information.
  #
  # source://irb//lib/irb/context.rb#231
  def prompt_c=(_arg0); end

  # Standard IRB prompt.
  #
  # See IRB@Customizing+the+IRB+Prompt for more information.
  #
  # source://irb//lib/irb/context.rb#223
  def prompt_i; end

  # Standard IRB prompt.
  #
  # See IRB@Customizing+the+IRB+Prompt for more information.
  #
  # source://irb//lib/irb/context.rb#223
  def prompt_i=(_arg0); end

  # A copy of the default <code>IRB.conf[:PROMPT_MODE]</code>
  #
  # source://irb//lib/irb/context.rb#219
  def prompt_mode; end

  # Sets the +mode+ of the prompt in this context.
  #
  # See IRB@Customizing+the+IRB+Prompt for more information.
  #
  # source://irb//lib/irb/context.rb#422
  def prompt_mode=(mode); end

  # TODO: Remove this when developing v2.0
  #
  # source://irb//lib/irb/context.rb#234
  def prompt_n; end

  # TODO: Remove this when developing v2.0
  #
  # source://irb//lib/irb/context.rb#240
  def prompt_n=(_); end

  # IRB prompt for continuated strings.
  #
  # See IRB@Customizing+the+IRB+Prompt for more information.
  #
  # source://irb//lib/irb/context.rb#227
  def prompt_s; end

  # IRB prompt for continuated strings.
  #
  # See IRB@Customizing+the+IRB+Prompt for more information.
  #
  # source://irb//lib/irb/context.rb#227
  def prompt_s=(_arg0); end

  # Whether #verbose? is +true+, and +input_method+ is either
  # StdioInputMethod or RelineInputMethod or ReadlineInputMethod, see #io
  # for more information.
  #
  # @return [Boolean]
  #
  # source://irb//lib/irb/context.rb#403
  def prompting?; end

  # A copy of the default <code>IRB.conf[:RC]</code>
  #
  # source://irb//lib/irb/context.rb#193
  def rc; end

  # A copy of the default <code>IRB.conf[:RC]</code>
  #
  # source://irb//lib/irb/context.rb#193
  def rc=(_arg0); end

  # A copy of the default <code>IRB.conf[:RC]</code>
  # Alias for #rc
  #
  # source://irb//lib/irb/context.rb#193
  def rc?; end

  # The format of the return statement, set by #prompt_mode= using the
  # +:RETURN+ of the +mode+ passed to set the current #prompt_mode.
  #
  # source://irb//lib/irb/context.rb#264
  def return_format; end

  # The format of the return statement, set by #prompt_mode= using the
  # +:RETURN+ of the +mode+ passed to set the current #prompt_mode.
  #
  # source://irb//lib/irb/context.rb#264
  def return_format=(_arg0); end

  # source://irb//lib/irb/context.rb#156
  def save_history; end

  # source://irb//lib/irb/context.rb#152
  def save_history=(val); end

  # Sets the return value from the last statement evaluated in this context
  # to #last_value.
  #
  # source://irb//lib/irb/context.rb#414
  def set_last_value(value); end

  # Return true if it's aliased from the argument and it's not an identifier.
  #
  # @return [Boolean]
  #
  # source://irb//lib/irb/context.rb#575
  def symbol_alias?(command); end

  # The current thread in this context.
  #
  # source://irb//lib/irb/context.rb#180
  def thread; end

  # source://irb//lib/irb/context.rb#548
  def to_s; end

  # Return true if the command supports transforming args
  #
  # @return [Boolean]
  #
  # source://irb//lib/irb/context.rb#581
  def transform_args?(command); end

  # Whether colorization is enabled or not.
  #
  # A copy of the default <code>IRB.conf[:USE_AUTOCOMPLETE]</code>
  #
  # source://irb//lib/irb/context.rb#214
  def use_autocomplete; end

  # Whether colorization is enabled or not.
  #
  # A copy of the default <code>IRB.conf[:USE_AUTOCOMPLETE]</code>
  # Alias for #use_autocomplete
  #
  # source://irb//lib/irb/context.rb#214
  def use_autocomplete?; end

  # Sets <code>IRB.conf[:USE_LOADER]</code>
  #
  # See #use_loader for more information.
  #
  # source://irb//lib/irb/extend-command.rb#341
  def use_loader=(*opts, &b); end

  # Whether multiline editor mode is enabled or not.
  #
  # A copy of the default <code>IRB.conf[:USE_MULTILINE]</code>
  #
  # source://irb//lib/irb/context.rb#206
  def use_multiline; end

  # Whether multiline editor mode is enabled or not.
  #
  # A copy of the default <code>IRB.conf[:USE_MULTILINE]</code>
  # Alias for #use_multiline
  #
  # source://irb//lib/irb/context.rb#206
  def use_multiline?; end

  # Whether singleline editor mode is enabled or not.
  #
  # A copy of the default <code>IRB.conf[:USE_SINGLELINE]</code>
  # backward compatibility
  #
  # source://irb//lib/irb/context.rb#210
  def use_readline; end

  # Whether singleline editor mode is enabled or not.
  #
  # A copy of the default <code>IRB.conf[:USE_SINGLELINE]</code>
  # backward compatibility
  #
  # source://irb//lib/irb/context.rb#210
  def use_readline?; end

  # Whether multiline editor mode is enabled or not.
  #
  # A copy of the default <code>IRB.conf[:USE_MULTILINE]</code>
  # backward compatibility
  #
  # source://irb//lib/irb/context.rb#206
  def use_reline; end

  # Whether multiline editor mode is enabled or not.
  #
  # A copy of the default <code>IRB.conf[:USE_MULTILINE]</code>
  # backward compatibility
  #
  # source://irb//lib/irb/context.rb#206
  def use_reline?; end

  # Whether singleline editor mode is enabled or not.
  #
  # A copy of the default <code>IRB.conf[:USE_SINGLELINE]</code>
  #
  # source://irb//lib/irb/context.rb#210
  def use_singleline; end

  # Whether singleline editor mode is enabled or not.
  #
  # A copy of the default <code>IRB.conf[:USE_SINGLELINE]</code>
  # Alias for #use_singleline
  #
  # source://irb//lib/irb/context.rb#210
  def use_singleline?; end

  # Sets whether or not to use the Tracer library when evaluating statements
  # in this context.
  #
  # See +lib/tracer.rb+ for more information.
  #
  # source://irb//lib/irb/extend-command.rb#341
  def use_tracer=(*opts, &b); end

  # Whether verbose messages are displayed or not.
  #
  # A copy of the default <code>IRB.conf[:VERBOSE]</code>
  #
  # source://irb//lib/irb/context.rb#345
  def verbose; end

  # Whether verbose messages are displayed or not.
  #
  # A copy of the default <code>IRB.conf[:VERBOSE]</code>
  #
  # source://irb//lib/irb/context.rb#345
  def verbose=(_arg0); end

  # Returns whether messages are displayed or not.
  #
  # @return [Boolean]
  #
  # source://irb//lib/irb/context.rb#384
  def verbose?; end

  # Returns the value of attribute with_debugger.
  #
  # source://irb//lib/irb/context.rb#359
  def with_debugger; end

  # Sets the attribute with_debugger
  #
  # @param value the value to set the attribute with_debugger to.
  #
  # source://irb//lib/irb/context.rb#359
  def with_debugger=(_arg0); end

  # WorkSpace in the current context.
  #
  # source://irb//lib/irb/context.rb#178
  def workspace; end

  # WorkSpace in the current context.
  #
  # source://irb//lib/irb/context.rb#178
  def workspace=(_arg0); end

  # The toplevel workspace, see #home_workspace
  #
  # source://irb//lib/irb/context.rb#176
  def workspace_home; end
end

# source://irb//lib/irb/context.rb#545
IRB::Context::IDNAME_IVARS = T.let(T.unsafe(nil), Array)

# source://irb//lib/irb/context.rb#543
IRB::Context::NOPRINTING_IVARS = T.let(T.unsafe(nil), Array)

# source://irb//lib/irb/context.rb#544
IRB::Context::NO_INSPECTING_IVARS = T.let(T.unsafe(nil), Array)

# Extends methods for the Context module
#
# source://irb//lib/irb/extend-command.rb#315
module IRB::ContextExtender
  class << self
    # Evaluate the given +command+ from the given +load_file+ on the Context
    # module.
    #
    # Will also define any given +aliases+ for the method.
    #
    # source://irb//lib/irb/extend-command.rb#339
    def def_extend_command(cmd_name, load_file, *aliases); end

    # Installs the default context extensions as irb commands:
    #
    # Context#eval_history=::   +irb/ext/history.rb+
    # Context#use_tracer=::     +irb/ext/tracer.rb+
    # Context#use_loader=::     +irb/ext/use-loader.rb+
    #
    # source://irb//lib/irb/extend-command.rb#329
    def install_extend_commands; end
  end
end

# source://irb//lib/irb/debug.rb#4
module IRB::Debug
  class << self
    # source://irb//lib/irb/debug.rb#8
    def insert_debug_break(pre_cmds: T.unsafe(nil), do_cmds: T.unsafe(nil)); end

    # source://irb//lib/irb/debug.rb#25
    def setup(irb); end

    private

    # source://irb//lib/irb/debug.rb#65
    def configure_irb_for_debugger(irb); end

    # This is used when debug.gem is not written in Gemfile. Even if it's not
    # installed by `bundle install`, debug.gem is installed by default because
    # it's a bundled gem. This method tries to activate and load that.
    #
    # source://irb//lib/irb/debug.rb#82
    def load_bundled_debug_gem; end
  end
end

# source://irb//lib/irb/debug.rb#5
IRB::Debug::IRB_DIR = T.let(T.unsafe(nil), String)

# Installs the default irb extensions command bundle.
#
# source://irb//lib/irb/extend-command.rb#9
module IRB::ExtendCommandBundle
  # Installs alias methods for the default irb commands, see
  # ::install_extend_commands.
  #
  # source://irb//lib/irb/extend-command.rb#276
  def install_alias_method(to, from, override = T.unsafe(nil)); end

  # source://irb//lib/irb/extend-command.rb#263
  def irb(*opts, **kwargs, &b); end

  # source://irb//lib/irb/extend-command.rb#263
  def irb_backtrace(*opts, **kwargs, &b); end

  # source://irb//lib/irb/extend-command.rb#263
  def irb_break(*opts, **kwargs, &b); end

  # source://irb//lib/irb/extend-command.rb#263
  def irb_catch(*opts, **kwargs, &b); end

  # source://irb//lib/irb/extend-command.rb#263
  def irb_change_workspace(*opts, **kwargs, &b); end

  # Displays current configuration.
  #
  # Modifying the configuration is achieved by sending a message to IRB.conf.
  #
  # source://irb//lib/irb/extend-command.rb#31
  def irb_context; end

  # source://irb//lib/irb/extend-command.rb#263
  def irb_continue(*opts, **kwargs, &b); end

  # source://irb//lib/irb/extend-command.rb#263
  def irb_current_working_workspace(*opts, **kwargs, &b); end

  # source://irb//lib/irb/extend-command.rb#263
  def irb_debug(*opts, **kwargs, &b); end

  # source://irb//lib/irb/extend-command.rb#263
  def irb_debug_info(*opts, **kwargs, &b); end

  # source://irb//lib/irb/extend-command.rb#263
  def irb_delete(*opts, **kwargs, &b); end

  # source://irb//lib/irb/extend-command.rb#263
  def irb_edit(*opts, **kwargs, &b); end

  # Quits the current irb context
  #
  # +ret+ is the optional signal or message to send to Context#exit
  #
  # Same as <code>IRB.CurrentContext.exit</code>.
  #
  # source://irb//lib/irb/extend-command.rb#24
  def irb_exit(ret = T.unsafe(nil)); end

  # source://irb//lib/irb/extend-command.rb#263
  def irb_fg(*opts, **kwargs, &b); end

  # source://irb//lib/irb/extend-command.rb#263
  def irb_finish(*opts, **kwargs, &b); end

  # source://irb//lib/irb/extend-command.rb#263
  def irb_help(*opts, **kwargs, &b); end

  # source://irb//lib/irb/extend-command.rb#263
  def irb_info(*opts, **kwargs, &b); end

  # source://irb//lib/irb/extend-command.rb#263
  def irb_jobs(*opts, **kwargs, &b); end

  # source://irb//lib/irb/extend-command.rb#263
  def irb_kill(*opts, **kwargs, &b); end

  # Loads the given file similarly to Kernel#load, see IrbLoader#irb_load
  #
  # source://irb//lib/irb/extend-command.rb#263
  def irb_load(*opts, **kwargs, &b); end

  # source://irb//lib/irb/extend-command.rb#263
  def irb_ls(*opts, **kwargs, &b); end

  # source://irb//lib/irb/extend-command.rb#263
  def irb_measure(*opts, **kwargs, &b); end

  # source://irb//lib/irb/extend-command.rb#263
  def irb_next(*opts, **kwargs, &b); end

  # source://irb//lib/irb/extend-command.rb#263
  def irb_pop_workspace(*opts, **kwargs, &b); end

  # source://irb//lib/irb/extend-command.rb#263
  def irb_push_workspace(*opts, **kwargs, &b); end

  # Loads the given file similarly to Kernel#require
  #
  # source://irb//lib/irb/extend-command.rb#263
  def irb_require(*opts, **kwargs, &b); end

  # source://irb//lib/irb/extend-command.rb#263
  def irb_show_cmds(*opts, **kwargs, &b); end

  # source://irb//lib/irb/extend-command.rb#263
  def irb_show_doc(*opts, **kwargs, &b); end

  # source://irb//lib/irb/extend-command.rb#263
  def irb_show_source(*opts, **kwargs, &b); end

  # source://irb//lib/irb/extend-command.rb#263
  def irb_source(*opts, **kwargs, &b); end

  # source://irb//lib/irb/extend-command.rb#263
  def irb_step(*opts, **kwargs, &b); end

  # source://irb//lib/irb/extend-command.rb#263
  def irb_whereami(*opts, **kwargs, &b); end

  # source://irb//lib/irb/extend-command.rb#263
  def irb_workspaces(*opts, **kwargs, &b); end

  class << self
    # source://irb//lib/irb/extend-command.rb#200
    def all_commands_info; end

    # Evaluate the given +cmd_name+ on the given +cmd_class+ Class.
    #
    # Will also define any given +aliases+ for the method.
    #
    # The optional +load_file+ parameter will be required within the method
    # definition.
    #
    # source://irb//lib/irb/extend-command.rb#253
    def def_extend_command(cmd_name, cmd_class, load_file, *aliases); end

    # Installs alias methods for the default irb commands on the given object
    # using #install_alias_method.
    #
    # source://irb//lib/irb/extend-command.rb#302
    def extend_object(obj); end

    # Installs the default irb commands.
    #
    # source://irb//lib/irb/extend-command.rb#241
    def install_extend_commands; end

    # source://irb//lib/irb/extend-command.rb#296
    def irb_original_method_name(method_name); end

    # Convert a command name to its implementation class if such command exists
    #
    # source://irb//lib/irb/extend-command.rb#227
    def load_command(command); end
  end
end

# source://irb//lib/irb/extend-command.rb#10
IRB::ExtendCommandBundle::EXCB = IRB::ExtendCommandBundle

# Use a File for IO with irb, see InputMethod
#
# source://irb//lib/irb/input-method.rb#115
class IRB::FileInputMethod < ::IRB::InputMethod
  # Creates a new input method object
  #
  # @return [FileInputMethod] a new instance of FileInputMethod
  #
  # source://irb//lib/irb/input-method.rb#128
  def initialize(file); end

  # source://irb//lib/irb/input-method.rb#159
  def close; end

  # The external encoding for standard input.
  #
  # source://irb//lib/irb/input-method.rb#150
  def encoding; end

  # Whether the end of this input method has been reached, returns +true+ if
  # there is no more data to read.
  #
  # See IO#eof? for more information.
  #
  # @return [Boolean]
  #
  # source://irb//lib/irb/input-method.rb#137
  def eof?; end

  # Reads the next line from this input method.
  #
  # See IO#gets for more information.
  #
  # source://irb//lib/irb/input-method.rb#144
  def gets; end

  # For debug message
  #
  # source://irb//lib/irb/input-method.rb#155
  def inspect; end

  class << self
    # source://irb//lib/irb/input-method.rb#117
    def open(file, &block); end
  end
end

# source://irb//lib/irb/history.rb#2
module IRB::HistorySavingAbility
  # source://irb//lib/irb/history.rb#11
  def load_history; end

  # source://irb//lib/irb/history.rb#7
  def reset_history_counter; end

  # source://irb//lib/irb/history.rb#35
  def save_history; end

  # @return [Boolean]
  #
  # source://irb//lib/irb/history.rb#3
  def support_history_saving?; end
end

# source://irb//lib/irb/init.rb#366
IRB::IRBRC_EXT = T.let(T.unsafe(nil), String)

# source://irb//lib/irb/completion.rb#419
module IRB::InputCompletor
  class << self
    # source://irb//lib/irb/completion.rb#425
    def retrieve_completion_data(input, bind: T.unsafe(nil), doc_namespace: T.unsafe(nil)); end

    private

    # source://irb//lib/irb/completion.rb#421
    def regexp_completor; end
  end
end

# source://irb//lib/irb/completion.rb#429
IRB::InputCompletor::CompletionProc = T.let(T.unsafe(nil), Proc)

# source://irb//lib/irb/input-method.rb#13
class IRB::InputMethod
  # Reads the next line from this input method.
  #
  # See IO#gets for more information.
  #
  # source://irb//lib/irb/input-method.rb#22
  def gets; end

  # For debug message
  #
  # source://irb//lib/irb/input-method.rb#48
  def inspect; end

  # The irb prompt associated with this input method
  #
  # source://irb//lib/irb/input-method.rb#17
  def prompt; end

  # The irb prompt associated with this input method
  #
  # source://irb//lib/irb/input-method.rb#17
  def prompt=(_arg0); end

  # Whether this input method is still readable when there is no more data to
  # read.
  #
  # See IO#eof for more information.
  #
  # @return [Boolean]
  #
  # source://irb//lib/irb/input-method.rb#39
  def readable_after_eof?; end

  # @return [Boolean]
  #
  # source://irb//lib/irb/input-method.rb#43
  def support_history_saving?; end

  # source://irb//lib/irb/input-method.rb#27
  def winsize; end
end

# source://irb//lib/irb/input-method.rb#14
IRB::InputMethod::BASIC_WORD_BREAK_CHARACTERS = T.let(T.unsafe(nil), String)

# An irb inspector
#
# In order to create your own custom inspector there are two things you
# should be aware of:
#
# Inspector uses #inspect_value, or +inspect_proc+, for output of return values.
#
# This also allows for an optional #init+, or +init_proc+, which is called
# when the inspector is activated.
#
# Knowing this, you can create a rudimentary inspector as follows:
#
#     irb(main):001:0> ins = IRB::Inspector.new(proc{ |v| "omg! #{v}" })
#     irb(main):001:0> IRB.CurrentContext.inspect_mode = ins # => omg! #<IRB::Inspector:0x007f46f7ba7d28>
#     irb(main):001:0> "what?" #=> omg! what?
#
# source://irb//lib/irb/inspector.rb#37
class IRB::Inspector
  # Creates a new inspector object, using the given +inspect_proc+ when
  # output return values in irb.
  #
  # @return [Inspector] a new instance of Inspector
  #
  # source://irb//lib/irb/inspector.rb#83
  def initialize(inspect_proc, init_proc = T.unsafe(nil)); end

  # Proc to call when the inspector is activated, good for requiring
  # dependent libraries.
  #
  # source://irb//lib/irb/inspector.rb#90
  def init; end

  # Proc to call when the input is evaluated and output in irb.
  #
  # source://irb//lib/irb/inspector.rb#95
  def inspect_value(v); end

  class << self
    # Example
    #
    #     Inspector.def_inspector(key, init_p=nil){|v| v.inspect}
    #     Inspector.def_inspector([key1,..], init_p=nil){|v| v.inspect}
    #     Inspector.def_inspector(key, inspector)
    #     Inspector.def_inspector([key1,...], inspector)
    #
    # source://irb//lib/irb/inspector.rb#58
    def def_inspector(key, arg = T.unsafe(nil), &block); end

    # Determines the inspector to use where +inspector+ is one of the keys passed
    # during inspector definition.
    #
    # source://irb//lib/irb/inspector.rb#48
    def keys_with_inspector(inspector); end
  end
end

# source://irb//lib/irb/inspector.rb#38
IRB::Inspector::KERNEL_INSPECT = T.let(T.unsafe(nil), UnboundMethod)

# source://irb//lib/irb.rb#424
class IRB::Irb
  # Creates a new irb session
  #
  # @return [Irb] a new instance of Irb
  #
  # source://irb//lib/irb.rb#435
  def initialize(workspace = T.unsafe(nil), input_method = T.unsafe(nil)); end

  # source://irb//lib/irb.rb#641
  def build_statement(code); end

  # source://irb//lib/irb.rb#662
  def configure_io; end

  # Returns the current context of this irb session
  #
  # source://irb//lib/irb.rb#513
  def context; end

  # source://irb//lib/irb.rb#714
  def convert_invalid_byte_sequence(str, enc); end

  # A hook point for `debug` command's breakpoint after :IRB_EXIT as well as its clean-up
  #
  # source://irb//lib/irb.rb#444
  def debug_break; end

  # source://irb//lib/irb.rb#454
  def debug_readline(binding); end

  # source://irb//lib/irb.rb#628
  def each_top_level_statement; end

  # source://irb//lib/irb.rb#721
  def encode_with_invalid_byte_sequence(str, enc); end

  # Evaluates input for this session.
  #
  # source://irb//lib/irb.rb#548
  def eval_input; end

  # source://irb//lib/irb.rb#743
  def handle_exception(exc); end

  # Outputs the local variables to this current session, including
  # #signal_status and #context, using IRB::Locale.
  #
  # source://irb//lib/irb.rb#967
  def inspect; end

  # source://irb//lib/irb.rb#929
  def output_value(omit = T.unsafe(nil)); end

  # source://irb//lib/irb.rb#580
  def read_input(prompt); end

  # source://irb//lib/irb.rb#599
  def readmultiline; end

  # source://irb//lib/irb.rb#486
  def run(conf = T.unsafe(nil)); end

  # The lexer used by this irb session
  #
  # source://irb//lib/irb.rb#515
  def scanner; end

  # The lexer used by this irb session
  #
  # source://irb//lib/irb.rb#515
  def scanner=(_arg0); end

  # Handler for the signal SIGINT, see Kernel#trap for more information.
  #
  # source://irb//lib/irb.rb#849
  def signal_handle; end

  # Evaluates the given block using the given +status+.
  #
  # source://irb//lib/irb.rb#871
  def signal_status(status); end

  # @return [Boolean]
  #
  # source://irb//lib/irb.rb#657
  def single_line_command?(code); end

  # Evaluates the given block using the given +context+ as the Context.
  #
  # source://irb//lib/irb.rb#839
  def suspend_context(context); end

  # Evaluates the given block using the given +input_method+ as the
  # Context#io.
  #
  # Used by the irb commands +source+ and +irb_load+, see IRB@IRB+Sessions
  # for more information.
  #
  # source://irb//lib/irb.rb#828
  def suspend_input_method(input_method); end

  # Evaluates the given block using the given +path+ as the Context#irb_path
  # and +name+ as the Context#irb_name.
  #
  # Used by the irb command +source+, see IRB@IRB+Sessions for more
  # information.
  #
  # source://irb//lib/irb.rb#798
  def suspend_name(path = T.unsafe(nil), name = T.unsafe(nil)); end

  # Evaluates the given block using the given +workspace+ as the
  # Context#workspace.
  #
  # Used by the irb command +irb_load+, see IRB@IRB+Sessions for more
  # information.
  #
  # source://irb//lib/irb.rb#814
  def suspend_workspace(workspace); end

  private

  # source://irb//lib/irb.rb#892
  def format_prompt(format, ltype, indent, line_no); end

  # source://irb//lib/irb.rb#517
  def generate_prompt(opens, continue, line_offset); end

  # source://irb//lib/irb.rb#883
  def truncate_prompt_main(str); end
end

# source://irb//lib/irb.rb#432
IRB::Irb::CONTROL_CHARACTERS_PATTERN = T.let(T.unsafe(nil), String)

# Note: instance and index assignment expressions could also be written like:
# "foo.bar=(1)" and "foo.[]=(1, bar)", when expressed that way, the former
# be parsed as :assign and echo will be suppressed, but the latter is
# parsed as a :method_add_arg and the output won't be suppressed
#
# source://irb//lib/irb.rb#430
IRB::Irb::PROMPT_MAIN_TRUNCATE_LENGTH = T.let(T.unsafe(nil), Integer)

# source://irb//lib/irb.rb#431
IRB::Irb::PROMPT_MAIN_TRUNCATE_OMISSION = T.let(T.unsafe(nil), String)

# source://irb//lib/irb/locale.rb#8
class IRB::Locale
  # @return [Locale] a new instance of Locale
  #
  # source://irb//lib/irb/locale.rb#25
  def initialize(locale = T.unsafe(nil)); end

  # source://irb//lib/irb/locale.rb#49
  def String(mes); end

  # source://irb//lib/irb/locale.rb#126
  def each_localized_path(dir, file); end

  # @yield [nil]
  #
  # source://irb//lib/irb/locale.rb#133
  def each_sublocale; end

  # source://irb//lib/irb/locale.rb#45
  def encoding; end

  # source://irb//lib/irb/locale.rb#97
  def find(file, paths = T.unsafe(nil)); end

  # source://irb//lib/irb/locale.rb#58
  def format(*opts); end

  # source://irb//lib/irb/locale.rb#62
  def gets(*rs); end

  # Returns the value of attribute lang.
  #
  # source://irb//lib/irb/locale.rb#43
  def lang; end

  # source://irb//lib/irb/locale.rb#85
  def load(file); end

  # Returns the value of attribute modifier.
  #
  # source://irb//lib/irb/locale.rb#43
  def modifier; end

  # source://irb//lib/irb/locale.rb#70
  def print(*opts); end

  # source://irb//lib/irb/locale.rb#75
  def printf(*opts); end

  # source://irb//lib/irb/locale.rb#80
  def puts(*opts); end

  # source://irb//lib/irb/locale.rb#66
  def readline(*rs); end

  # typically, for the parameters and a <path> in paths, it searches
  #   <path>/<dir>/<locale>/<file>
  #
  # @param paths load paths in which IRB find a localized file.
  # @param dir directory
  # @param file basename to be localized
  #
  # source://irb//lib/irb/locale.rb#115
  def search_file(lib_paths, dir, file); end

  # Returns the value of attribute territory.
  #
  # source://irb//lib/irb/locale.rb#43
  def territory; end
end

# source://irb//lib/irb/locale.rb#18
IRB::Locale::LEGACY_ENCODING_ALIAS_MAP = T.let(T.unsafe(nil), Hash)

# source://irb//lib/irb/locale.rb#16
IRB::Locale::LOCALE_DIR = T.let(T.unsafe(nil), String)

# source://irb//lib/irb/locale.rb#10
IRB::Locale::LOCALE_NAME_RE = T.let(T.unsafe(nil), Regexp)

# source://irb//lib/irb/nesting_parser.rb#3
module IRB::NestingParser
  class << self
    # source://irb//lib/irb/nesting_parser.rb#182
    def open_tokens(tokens); end

    # Calculates token information [line_tokens, prev_opens, next_opens, min_depth] for each line.
    # Example code
    #   ["hello
    #   world"+(
    # First line
    #   line_tokens: [[lbracket, '['], [tstring_beg, '"'], [tstring_content("hello\nworld"), "hello\n"]]
    #   prev_opens:  []
    #   next_tokens: [lbracket, tstring_beg]
    #   min_depth:   0 (minimum at beginning of line)
    # Second line
    #   line_tokens: [[tstring_content("hello\nworld"), "world"], [tstring_end, '"'], [op, '+'], [lparen, '(']]
    #   prev_opens:  [lbracket, tstring_beg]
    #   next_tokens: [lbracket, lparen]
    #   min_depth:   1 (minimum just after tstring_end)
    #
    # source://irb//lib/irb/nesting_parser.rb#201
    def parse_by_line(tokens); end

    # Scan each token and call the given block with array of token and other information for parsing
    #
    # source://irb//lib/irb/nesting_parser.rb#7
    def scan_opens(tokens); end
  end
end

# source://irb//lib/irb/nesting_parser.rb#4
IRB::NestingParser::IGNORE_TOKENS = T.let(T.unsafe(nil), Array)

# An output formatter used internally by the lexer.
#
# source://irb//lib/irb/notifier.rb#11
module IRB::Notifier
  private

  # Define a new Notifier output source, returning a new CompositeNotifier
  # with the given +prefix+ and +output_method+.
  #
  # The optional +prefix+ will be appended to all objects being inspected
  # during output, using the given +output_method+ as the output source. If
  # no +output_method+ is given, StdioOutputMethod will be used, and all
  # expressions will be sent directly to STDOUT without any additional
  # formatting.
  #
  # source://irb//lib/irb/notifier.rb#31
  def def_notifier(prefix = T.unsafe(nil), output_method = T.unsafe(nil)); end

  class << self
    # Define a new Notifier output source, returning a new CompositeNotifier
    # with the given +prefix+ and +output_method+.
    #
    # The optional +prefix+ will be appended to all objects being inspected
    # during output, using the given +output_method+ as the output source. If
    # no +output_method+ is given, StdioOutputMethod will be used, and all
    # expressions will be sent directly to STDOUT without any additional
    # formatting.
    #
    # source://irb//lib/irb/notifier.rb#31
    def def_notifier(prefix = T.unsafe(nil), output_method = T.unsafe(nil)); end
  end
end

# An abstract class, or superclass, for CompositeNotifier and
# LeveledNotifier to inherit. It provides several wrapper methods for the
# OutputMethod object used by the Notifier.
#
# source://irb//lib/irb/notifier.rb#39
class IRB::Notifier::AbstractNotifier
  # Creates a new Notifier object
  #
  # @return [AbstractNotifier] a new instance of AbstractNotifier
  #
  # source://irb//lib/irb/notifier.rb#41
  def initialize(prefix, base_notifier); end

  # Execute the given block if notifications are enabled.
  #
  # @yield [@base_notifier]
  #
  # source://irb//lib/irb/notifier.rb#99
  def exec_if; end

  # A wrapper method used to determine whether notifications are enabled.
  #
  # Defaults to +true+.
  #
  # @return [Boolean]
  #
  # source://irb//lib/irb/notifier.rb#53
  def notify?; end

  # Same as #ppx, except it uses the #prefix given during object
  # initialization.
  # See OutputMethod#ppx for more detail.
  #
  # source://irb//lib/irb/notifier.rb#82
  def pp(*objs); end

  # Same as #pp, except it concatenates the given +prefix+ with the #prefix
  # given during object initialization.
  #
  # See OutputMethod#ppx for more detail.
  #
  # source://irb//lib/irb/notifier.rb#92
  def ppx(prefix, *objs); end

  # The +prefix+ for this Notifier, which is appended to all objects being
  # inspected during output.
  #
  # source://irb//lib/irb/notifier.rb#48
  def prefix; end

  # See OutputMethod#print for more detail.
  #
  # source://irb//lib/irb/notifier.rb#58
  def print(*opts); end

  # See OutputMethod#printf for more detail.
  #
  # source://irb//lib/irb/notifier.rb#68
  def printf(format, *opts); end

  # See OutputMethod#printn for more detail.
  #
  # source://irb//lib/irb/notifier.rb#63
  def printn(*opts); end

  # See OutputMethod#puts for more detail.
  #
  # source://irb//lib/irb/notifier.rb#73
  def puts(*objs); end
end

# A class that can be used to create a group of notifier objects with the
# intent of representing a leveled notification system for irb.
#
# This class will allow you to generate other notifiers, and assign them
# the appropriate level for output.
#
# The Notifier class provides a class-method Notifier.def_notifier to
# create a new composite notifier. Using the first composite notifier
# object you create, sibling notifiers can be initialized with
# #def_notifier.
#
# source://irb//lib/irb/notifier.rb#114
class IRB::Notifier::CompositeNotifier < ::IRB::Notifier::AbstractNotifier
  # Create a new composite notifier object with the given +prefix+, and
  # +base_notifier+ to use for output.
  #
  # @return [CompositeNotifier] a new instance of CompositeNotifier
  #
  # source://irb//lib/irb/notifier.rb#117
  def initialize(prefix, base_notifier); end

  # Creates a new LeveledNotifier in the composite #notifiers group.
  #
  # The given +prefix+ will be assigned to the notifier, and +level+ will
  # be used as the index of the #notifiers Array.
  #
  # This method returns the newly created instance.
  #
  # source://irb//lib/irb/notifier.rb#133
  def def_notifier(level, prefix = T.unsafe(nil)); end

  # Returns the leveled notifier for this object
  #
  # source://irb//lib/irb/notifier.rb#140
  def level; end

  # Sets the leveled notifier for this object.
  #
  # When the given +value+ is an instance of AbstractNotifier,
  # #level_notifier is set to the given object.
  #
  # When an Integer is given, #level_notifier is set to the notifier at the
  # index +value+ in the #notifiers Array.
  #
  # If no notifier exists at the index +value+ in the #notifiers Array, an
  # ErrUndefinedNotifier exception is raised.
  #
  # An ErrUnrecognizedLevel exception is raised if the given +value+ is not
  # found in the existing #notifiers Array, or an instance of
  # AbstractNotifier
  #
  # source://irb//lib/irb/notifier.rb#157
  def level=(value); end

  # Returns the leveled notifier for this object
  #
  # source://irb//lib/irb/notifier.rb#140
  def level_notifier; end

  # Sets the leveled notifier for this object.
  #
  # When the given +value+ is an instance of AbstractNotifier,
  # #level_notifier is set to the given object.
  #
  # When an Integer is given, #level_notifier is set to the notifier at the
  # index +value+ in the #notifiers Array.
  #
  # If no notifier exists at the index +value+ in the #notifiers Array, an
  # ErrUndefinedNotifier exception is raised.
  #
  # An ErrUnrecognizedLevel exception is raised if the given +value+ is not
  # found in the existing #notifiers Array, or an instance of
  # AbstractNotifier
  #
  # source://irb//lib/irb/notifier.rb#157
  def level_notifier=(value); end

  # List of notifiers in the group
  #
  # source://irb//lib/irb/notifier.rb#125
  def notifiers; end
end

# source://irb//lib/irb/notifier.rb#12
class IRB::Notifier::ErrUndefinedNotifier < ::StandardError
  # @return [ErrUndefinedNotifier] a new instance of ErrUndefinedNotifier
  #
  # source://irb//lib/irb/notifier.rb#13
  def initialize(val); end
end

# source://irb//lib/irb/notifier.rb#17
class IRB::Notifier::ErrUnrecognizedLevel < ::StandardError
  # @return [ErrUnrecognizedLevel] a new instance of ErrUnrecognizedLevel
  #
  # source://irb//lib/irb/notifier.rb#18
  def initialize(val); end
end

# A leveled notifier is comparable to the composite group from
# CompositeNotifier#notifiers.
#
# source://irb//lib/irb/notifier.rb#175
class IRB::Notifier::LeveledNotifier < ::IRB::Notifier::AbstractNotifier
  include ::Comparable

  # Create a new leveled notifier with the given +base+, and +prefix+ to
  # send to AbstractNotifier.new
  #
  # The given +level+ is used to compare other leveled notifiers in the
  # CompositeNotifier group to determine whether or not to output
  # notifications.
  #
  # @return [LeveledNotifier] a new instance of LeveledNotifier
  #
  # source://irb//lib/irb/notifier.rb#184
  def initialize(base, level, prefix); end

  # Compares the level of this notifier object with the given +other+
  # notifier.
  #
  # See the Comparable module for more information.
  #
  # source://irb//lib/irb/notifier.rb#197
  def <=>(other); end

  # The current level of this notifier object
  #
  # source://irb//lib/irb/notifier.rb#191
  def level; end

  # Whether to output messages to the output method, depending on the level
  # of this notifier object.
  #
  # @return [Boolean]
  #
  # source://irb//lib/irb/notifier.rb#203
  def notify?; end
end

# NoMsgNotifier is a LeveledNotifier that's used as the default notifier
# when creating a new CompositeNotifier.
#
# This notifier is used as the +zero+ index, or level +0+, for
# CompositeNotifier#notifiers, and will not output messages of any sort.
#
# source://irb//lib/irb/notifier.rb#213
class IRB::Notifier::NoMsgNotifier < ::IRB::Notifier::LeveledNotifier
  # Creates a new notifier that should not be used to output messages.
  #
  # @return [NoMsgNotifier] a new instance of NoMsgNotifier
  #
  # source://irb//lib/irb/notifier.rb#215
  def initialize; end

  # Ensures notifications are ignored, see AbstractNotifier#notify? for
  # more information.
  #
  # @return [Boolean]
  #
  # source://irb//lib/irb/notifier.rb#223
  def notify?; end
end

# An abstract output class for IO in irb. This is mainly used internally by
# IRB::Notifier. You can define your own output method to use with Irb.new,
# or Context.new
#
# source://irb//lib/irb/output-method.rb#11
class IRB::OutputMethod
  # Returns an array of the given +format+ and +opts+ to be used by
  # Kernel#sprintf, if there was a successful Regexp match in the given
  # +format+ from #printf
  #
  #     %
  #     <flag>  [#0- +]
  #     <minimum field width> (\*|\*[1-9][0-9]*\$|[1-9][0-9]*)
  #     <precision>.(\*|\*[1-9][0-9]*\$|[1-9][0-9]*|)?
  #     #<length modifier>(hh|h|l|ll|L|q|j|z|t)
  #     <conversion specifier>[diouxXeEfgGcsb%]
  #
  # source://irb//lib/irb/output-method.rb#48
  def parse_printf_format(format, opts); end

  # Prints the given +objs+ calling Object#inspect on each.
  #
  # See #puts for more detail.
  #
  # source://irb//lib/irb/output-method.rb#64
  def pp(*objs); end

  # Prints the given +objs+ calling Object#inspect on each and appending the
  # given +prefix+.
  #
  # See #puts for more detail.
  #
  # source://irb//lib/irb/output-method.rb#72
  def ppx(prefix, *objs); end

  # Open this method to implement your own output method, raises a
  # NotImplementedError if you don't define #print in your own class.
  #
  # @raise [NotImplementedError]
  #
  # source://irb//lib/irb/output-method.rb#20
  def print(*opts); end

  # Extends IO#printf to format the given +opts+ for Kernel#sprintf using
  # #parse_printf_format
  #
  # source://irb//lib/irb/output-method.rb#31
  def printf(format, *opts); end

  # Prints the given +opts+, with a newline delimiter.
  #
  # source://irb//lib/irb/output-method.rb#25
  def printn(*opts); end

  # Calls #print on each element in the given +objs+, followed by a newline
  # character.
  #
  # source://irb//lib/irb/output-method.rb#54
  def puts(*objs); end
end

# source://irb//lib/irb/output-method.rb#12
class IRB::OutputMethod::NotImplementedError < ::StandardError
  # @return [NotImplementedError] a new instance of NotImplementedError
  #
  # source://irb//lib/irb/output-method.rb#13
  def initialize(val); end
end

# source://irb//lib/irb/input-method.rb#164
class IRB::ReadlineInputMethod < ::IRB::InputMethod
  include ::IRB::HistorySavingAbility

  # Creates a new input method object using Readline
  #
  # @return [ReadlineInputMethod] a new instance of ReadlineInputMethod
  #
  # source://irb//lib/irb/input-method.rb#175
  def initialize; end

  # Whether the end of this input method has been reached, returns +true+
  # if there is no more data to read.
  #
  # See IO#eof? for more information.
  #
  # @return [Boolean]
  #
  # source://irb//lib/irb/input-method.rb#215
  def eof?; end

  # Reads the next line from this input method.
  #
  # See IO#gets for more information.
  #
  # source://irb//lib/irb/input-method.rb#199
  def gets; end

  # For debug message
  #
  # source://irb//lib/irb/input-method.rb#220
  def inspect; end

  class << self
    # source://irb//lib/irb/input-method.rb#165
    def initialize_readline; end
  end
end

# source://irb//lib/irb/completion.rb#72
class IRB::RegexpCompletor < ::IRB::BaseCompletor
  # source://irb//lib/irb/completion.rb#120
  def complete_require_path(target, preposing, postposing); end

  # source://irb//lib/irb/completion.rb#153
  def completion_candidates(preposing, target, postposing, bind:); end

  # source://irb//lib/irb/completion.rb#161
  def doc_namespace(_preposing, matched, _postposing, bind:); end

  # source://irb//lib/irb/completion.rb#165
  def retrieve_completion_data(input, bind:, doc_namespace:); end

  # source://irb//lib/irb/completion.rb#406
  def select_message(receiver, message, candidates, sep = T.unsafe(nil)); end
end

# Set of available operators in Ruby
#
# source://irb//lib/irb/completion.rb#404
IRB::RegexpCompletor::Operators = T.let(T.unsafe(nil), Array)

# Set of reserved words used by Ruby, you should not use these for
# constants or variables
#
# source://irb//lib/irb/completion.rb#99
IRB::RegexpCompletor::ReservedWords = T.let(T.unsafe(nil), Array)

# source://irb//lib/irb/input-method.rb#455
class IRB::ReidlineInputMethod < ::IRB::RelineInputMethod
  # @return [ReidlineInputMethod] a new instance of ReidlineInputMethod
  #
  # source://irb//lib/irb/input-method.rb#456
  def initialize; end
end

# source://irb//lib/irb/input-method.rb#229
class IRB::RelineInputMethod < ::IRB::InputMethod
  include ::IRB::HistorySavingAbility

  # Creates a new input method object using Reline
  #
  # @return [RelineInputMethod] a new instance of RelineInputMethod
  #
  # source://irb//lib/irb/input-method.rb#233
  def initialize; end

  # source://irb//lib/irb/input-method.rb#281
  def auto_indent(&block); end

  # source://irb//lib/irb/input-method.rb#273
  def check_termination(&block); end

  # source://irb//lib/irb/input-method.rb#386
  def display_document(matched, driver: T.unsafe(nil)); end

  # source://irb//lib/irb/input-method.rb#277
  def dynamic_prompt(&block); end

  # Whether the end of this input method has been reached, returns +true+
  # if there is no more data to read.
  #
  # See IO#eof? for more information.
  #
  # @return [Boolean]
  #
  # source://irb//lib/irb/input-method.rb#441
  def eof?; end

  # Reads the next line from this input method.
  #
  # See IO#gets for more information.
  #
  # source://irb//lib/irb/input-method.rb#423
  def gets; end

  # For debug message
  #
  # source://irb//lib/irb/input-method.rb#446
  def inspect; end

  # source://irb//lib/irb/input-method.rb#285
  def show_doc_dialog_proc; end
end

# source://irb//lib/irb/input-method.rb#230
IRB::RelineInputMethod::HISTORY = T.let(T.unsafe(nil), Reline::History)

# :stopdoc:
#
# source://irb//lib/irb/ruby-lex.rb#13
class IRB::RubyLex
  # @return [Boolean]
  #
  # source://irb//lib/irb/ruby-lex.rb#156
  def assignment_expression?(code, local_variables:); end

  # source://irb//lib/irb/ruby-lex.rb#274
  def calc_indent_level(opens); end

  # source://irb//lib/irb/ruby-lex.rb#137
  def check_code_state(code, local_variables:); end

  # source://irb//lib/irb/ruby-lex.rb#198
  def check_code_syntax(code, local_variables:); end

  # source://irb//lib/irb/ruby-lex.rb#431
  def check_termination_in_prev_line(code, local_variables:); end

  # @return [Boolean]
  #
  # source://irb//lib/irb/ruby-lex.rb#143
  def code_terminated?(code, tokens, opens, local_variables:); end

  # @return [Boolean]
  #
  # source://irb//lib/irb/ruby-lex.rb#301
  def free_indent_token?(token); end

  # Calculates the difference of pasted code's indent and indent calculated from tokens
  #
  # source://irb//lib/irb/ruby-lex.rb#306
  def indent_difference(lines, line_results, line_index); end

  # source://irb//lib/irb/ruby-lex.rb#401
  def ltype_from_open_tokens(opens); end

  # source://irb//lib/irb/ruby-lex.rb#325
  def process_indent_level(tokens, lines, line_index, is_newline); end

  # @return [Boolean]
  #
  # source://irb//lib/irb/ruby-lex.rb#174
  def should_continue?(tokens); end

  class << self
    # source://irb//lib/irb/ruby-lex.rb#45
    def compile_with_errors_suppressed(code, line_no: T.unsafe(nil)); end

    # source://irb//lib/irb/ruby-lex.rb#71
    def generate_local_variables_assign_code(local_variables); end

    # Some part of the code is not included in Ripper's token.
    # Example: DATA part, token after heredoc_beg when heredoc has unclosed embexpr.
    # With interpolated tokens, tokens.map(&:tok).join will be equal to code.
    #
    # source://irb//lib/irb/ruby-lex.rb#78
    def interpolate_ripper_ignored_tokens(code, tokens); end

    # source://irb//lib/irb/ruby-lex.rb#107
    def ripper_lex_without_warning(code, local_variables: T.unsafe(nil)); end
  end
end

# source://irb//lib/irb/ruby-lex.rb#14
IRB::RubyLex::ASSIGNMENT_NODE_TYPES = T.let(T.unsafe(nil), Array)

# source://irb//lib/irb/ruby-lex.rb#62
IRB::RubyLex::ERROR_TOKENS = T.let(T.unsafe(nil), Array)

# source://irb//lib/irb/ruby-lex.rb#299
IRB::RubyLex::FREE_INDENT_TOKENS = T.let(T.unsafe(nil), Array)

# source://irb//lib/irb/ruby-lex.rb#394
IRB::RubyLex::LTYPE_TOKENS = T.let(T.unsafe(nil), Array)

# source://irb//lib/irb/ruby-lex.rb#39
class IRB::RubyLex::TerminateLineInput < ::StandardError
  # @return [TerminateLineInput] a new instance of TerminateLineInput
  #
  # source://irb//lib/irb/ruby-lex.rb#40
  def initialize; end
end

# source://irb//lib/irb/statement.rb#4
class IRB::Statement
  # Returns the value of attribute code.
  #
  # source://irb//lib/irb/statement.rb#5
  def code; end

  # @raise [NotImplementedError]
  #
  # source://irb//lib/irb/statement.rb#19
  def evaluable_code; end

  # @raise [NotImplementedError]
  # @return [Boolean]
  #
  # source://irb//lib/irb/statement.rb#7
  def is_assignment?; end

  # @raise [NotImplementedError]
  # @return [Boolean]
  #
  # source://irb//lib/irb/statement.rb#15
  def should_be_handled_by_debugger?; end

  # @raise [NotImplementedError]
  # @return [Boolean]
  #
  # source://irb//lib/irb/statement.rb#11
  def suppresses_echo?; end
end

# source://irb//lib/irb/statement.rb#46
class IRB::Statement::Command < ::IRB::Statement
  # @return [Command] a new instance of Command
  #
  # source://irb//lib/irb/statement.rb#47
  def initialize(code, command, arg, command_class); end

  # source://irb//lib/irb/statement.rb#68
  def evaluable_code; end

  # @return [Boolean]
  #
  # source://irb//lib/irb/statement.rb#54
  def is_assignment?; end

  # @return [Boolean]
  #
  # source://irb//lib/irb/statement.rb#62
  def should_be_handled_by_debugger?; end

  # @return [Boolean]
  #
  # source://irb//lib/irb/statement.rb#58
  def suppresses_echo?; end
end

# source://irb//lib/irb/statement.rb#23
class IRB::Statement::Expression < ::IRB::Statement
  # @return [Expression] a new instance of Expression
  #
  # source://irb//lib/irb/statement.rb#24
  def initialize(code, is_assignment); end

  # source://irb//lib/irb/statement.rb#41
  def evaluable_code; end

  # @return [Boolean]
  #
  # source://irb//lib/irb/statement.rb#37
  def is_assignment?; end

  # @return [Boolean]
  #
  # source://irb//lib/irb/statement.rb#33
  def should_be_handled_by_debugger?; end

  # @return [Boolean]
  #
  # source://irb//lib/irb/statement.rb#29
  def suppresses_echo?; end
end

# source://irb//lib/irb/input-method.rb#53
class IRB::StdioInputMethod < ::IRB::InputMethod
  # Creates a new input method object
  #
  # @return [StdioInputMethod] a new instance of StdioInputMethod
  #
  # source://irb//lib/irb/input-method.rb#55
  def initialize; end

  # The external encoding for standard input.
  #
  # source://irb//lib/irb/input-method.rb#104
  def encoding; end

  # Whether the end of this input method has been reached, returns +true+ if
  # there is no more data to read.
  #
  # See IO#eof? for more information.
  #
  # @return [Boolean]
  #
  # source://irb//lib/irb/input-method.rb#75
  def eof?; end

  # Reads the next line from this input method.
  #
  # See IO#gets for more information.
  #
  # source://irb//lib/irb/input-method.rb#65
  def gets; end

  # For debug message
  #
  # source://irb//lib/irb/input-method.rb#109
  def inspect; end

  # Returns the current line number for #io.
  #
  # #line counts the number of times #gets is called.
  #
  # See IO#lineno for more information.
  #
  # source://irb//lib/irb/input-method.rb#99
  def line(line_no); end

  # Whether this input method is still readable when there is no more data to
  # read.
  #
  # See IO#eof for more information.
  #
  # @return [Boolean]
  #
  # source://irb//lib/irb/input-method.rb#90
  def readable_after_eof?; end
end

# A standard output printer
#
# source://irb//lib/irb/output-method.rb#79
class IRB::StdioOutputMethod < ::IRB::OutputMethod
  # Prints the given +opts+ to standard output, see IO#print for more
  # information.
  #
  # source://irb//lib/irb/output-method.rb#82
  def print(*opts); end
end

# source://irb//lib/irb/workspace.rb#9
IRB::TOPLEVEL_BINDING = T.let(T.unsafe(nil), Binding)

# source://irb//lib/irb/version.rb#8
IRB::VERSION = T.let(T.unsafe(nil), String)

# source://irb//lib/irb/workspace.rb#11
class IRB::WorkSpace
  # Creates a new workspace.
  #
  # set self to main if specified, otherwise
  # inherit main from TOPLEVEL_BINDING.
  #
  # @return [WorkSpace] a new instance of WorkSpace
  #
  # source://irb//lib/irb/workspace.rb#16
  def initialize(*main); end

  # The Binding of this workspace
  #
  # source://irb//lib/irb/workspace.rb#106
  def binding; end

  # source://irb//lib/irb/workspace.rb#144
  def code_around_binding; end

  # Evaluate the given +statements+ within the  context of this workspace.
  #
  # source://irb//lib/irb/workspace.rb#116
  def evaluate(statements, file = T.unsafe(nil), line = T.unsafe(nil)); end

  # error message manipulator
  # WARN: Rails patches this method to filter its own backtrace. Be cautious when changing it.
  # See: https://github.com/rails/rails/blob/main/railties/lib/rails/commands/console/console_command.rb#L8:~:text=def,filter_backtrace
  #
  # source://irb//lib/irb/workspace.rb#131
  def filter_backtrace(bt); end

  # source://irb//lib/irb/workspace.rb#111
  def load_commands_to_main; end

  # source://irb//lib/irb/workspace.rb#124
  def local_variable_get(name); end

  # source://irb//lib/irb/workspace.rb#120
  def local_variable_set(name, value); end

  # The top-level workspace of this context, also available as
  # <code>IRB.conf[:__MAIN__]</code>
  #
  # source://irb//lib/irb/workspace.rb#109
  def main; end
end

# source://irb//lib/irb/ruby-lex.rb#473
RubyLex = IRB::RubyLex
