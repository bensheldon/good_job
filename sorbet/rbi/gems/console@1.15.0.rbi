# typed: false

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `console` gem.
# Please instead update this file by running `bin/tapioca gem console`.

module Console
  def logger; end
  def logger=(logger); end

  class << self
    # @private
    def extended(klass); end

    def logger; end
    def logger=(instance); end
  end
end

class Console::Buffer < ::StringIO
  # @return [Buffer] a new instance of Buffer
  def initialize(prefix = T.unsafe(nil)); end

  def <<(*args, prefix: T.unsafe(nil)); end
  def puts(*args, prefix: T.unsafe(nil)); end
end

module Console::Clock
  class << self
    def formatted_duration(duration); end

    # Get the current elapsed monotonic time.
    def now; end
  end
end

module Console::Event; end

class Console::Event::Enter < ::Console::Event::Generic
  # @return [Enter] a new instance of Enter
  def initialize(name); end

  def format(output, terminal, verbose); end
end

class Console::Event::Exit < ::Console::Event::Metric
  def value_string; end
end

class Console::Event::Failure < ::Console::Event::Generic
  # @return [Failure] a new instance of Failure
  def initialize(exception, root = T.unsafe(nil)); end

  # Returns the value of attribute exception.
  def exception; end

  def format(output, terminal, verbose); end
  def format_exception(exception, prefix, output, terminal, verbose); end

  # Returns the value of attribute root.
  def root; end

  def to_h; end

  class << self
    def current_working_directory; end
    def for(exception); end
    def register(terminal); end
  end
end

class Console::Event::Generic
  def format(buffer, terminal); end
  def to_h; end
  def to_json(*arguments); end

  class << self
    def register(terminal); end
  end
end

class Console::Event::Metric < ::Console::Event::Generic
  # @return [Metric] a new instance of Metric
  def initialize(name, value, **tags); end

  def format(output, terminal, verbose); end

  # Returns the value of attribute name.
  def name; end

  # Returns the value of attribute tags.
  def tags; end

  def to_h; end

  # Returns the value of attribute value.
  def value; end

  def value_string; end

  class << self
    def [](**parameters); end
  end
end

class Console::Event::Progress < ::Console::Event::Generic
  # @return [Progress] a new instance of Progress
  def initialize(current, total); end

  def bar(value = T.unsafe(nil), width = T.unsafe(nil)); end

  # Returns the value of attribute current.
  def current; end

  def format(output, terminal, verbose); end
  def to_h; end

  # Returns the value of attribute total.
  def total; end

  def value; end

  class << self
    def register(terminal); end
  end
end

Console::Event::Progress::BLOCK = T.let(T.unsafe(nil), Array)

class Console::Event::Spawn < ::Console::Event::Generic
  # @return [Spawn] a new instance of Spawn
  def initialize(environment, arguments, options); end

  # Returns the value of attribute arguments.
  def arguments; end

  def chdir_string(options); end

  # Returns the value of attribute environment.
  def environment; end

  def format(output, terminal, verbose); end

  # Returns the value of attribute options.
  def options; end

  def to_h; end

  class << self
    def for(*arguments, **options); end
    def register(terminal); end
  end
end

class Console::Filter
  # @return [Filter] a new instance of Filter
  def initialize(output, verbose: T.unsafe(nil), level: T.unsafe(nil), enabled: T.unsafe(nil), **options); end

  def all!; end
  def call(*arguments, **options, &block); end

  # Disable specific logging for the specific class.
  #
  # @param name [String, Class] The class to disable.
  def disable(subject); end

  # Enable specific log level for the given class.
  #
  # @param name [String, Class] The class to enable.
  def enable(subject, level = T.unsafe(nil)); end

  # You can enable and disable logging for classes. This function checks if logging for a given subject is enabled.
  #
  # @param subject [Object] the subject to check.
  # @return [Boolean]
  def enabled?(subject, level = T.unsafe(nil)); end

  # Returns the value of attribute level.
  def level; end

  def level=(level); end
  def off!; end

  # Returns the value of attribute options.
  def options; end

  # Sets the attribute options
  #
  # @param value the value to set the attribute options to.
  def options=(_arg0); end

  # Returns the value of attribute output.
  def output; end

  # Sets the attribute output
  #
  # @param value the value to set the attribute output to.
  def output=(_arg0); end

  # Returns the value of attribute subjects.
  def subjects; end

  # Returns the value of attribute verbose.
  def verbose; end

  def verbose!(value = T.unsafe(nil)); end
  def with(level: T.unsafe(nil), verbose: T.unsafe(nil), **options); end

  class << self
    def [](**levels); end
  end
end

class Console::Logger < ::Console::Filter
  extend ::Fiber::Local

  # @return [Logger] a new instance of Logger
  def initialize(output, **options); end

  def failure(subject, exception, *arguments, &block); end
  def measure(subject, name = T.unsafe(nil), **tags, &block); end
  def progress(subject, total, **options); end

  class << self
    # Set the default log level based on `$DEBUG` and `$VERBOSE`.
    # You can also specify CONSOLE_LEVEL=debug or CONSOLE_LEVEL=info in environment.
    # https://mislav.net/2011/06/ruby-verbose-mode/ has more details about how it all fits together.
    def default_log_level(env = T.unsafe(nil)); end

    def default_logger(output = T.unsafe(nil), env = T.unsafe(nil), **options); end
    def local; end

    # Controls verbose output using `$VERBOSE`.
    #
    # @return [Boolean]
    def verbose?(env = T.unsafe(nil)); end
  end
end

Console::Logger::DEFAULT_LEVEL = T.let(T.unsafe(nil), Integer)

class Console::Measure
  # @return [Measure] a new instance of Measure
  def initialize(output, subject, **tags); end

  # Measure the execution of a block of code.
  def duration(name, &block); end

  # Returns the value of attribute tags.
  def tags; end
end

module Console::Output
  class << self
    def new(output = T.unsafe(nil), env = T.unsafe(nil), **options); end
  end
end

module Console::Output::Default
  class << self
    def new(output, **options); end
  end
end

module Console::Output::JSON
  class << self
    def new(output, **options); end
  end
end

module Console::Output::Text
  class << self
    def new(output, **options); end
  end
end

module Console::Output::XTerm
  class << self
    def new(output, **options); end
  end
end

class Console::Progress
  # @return [Progress] a new instance of Progress
  def initialize(output, subject, total = T.unsafe(nil), minimum_output_duration: T.unsafe(nil)); end

  def average_duration; end

  # Returns the value of attribute current.
  def current; end

  def duration; end
  def estimated_remaining_time; end
  def increment(amount = T.unsafe(nil)); end
  def mark(*arguments); end
  def progress; end
  def remaining; end
  def resize(total); end

  # Returns the value of attribute subject.
  def subject; end

  def to_s; end

  # Returns the value of attribute total.
  def total; end

  private

  def duration_since_last_output; end

  # @return [Boolean]
  def output?; end

  class << self
    def now; end
  end
end

class Console::Resolver
  # @return [Resolver] a new instance of Resolver
  def initialize; end

  def bind(names, &block); end
  def resolve(trace_point); end

  # @return [Boolean]
  def waiting?; end

  class << self
    # You can change the log level for different classes using CONSOLE_<LEVEL> env vars.
    #
    # e.g. `CONSOLE_WARN=Acorn,Banana CONSOLE_DEBUG=Cat` will set the log level for the classes Acorn and Banana to `warn` and Cat to `debug`. This overrides the default log level.
    #
    # You can enable all log levels for a given class by using `CONSOLE_ON=MyClass`. Similarly you can disable all logging using `CONSOLE_OFF=MyClass`.
    def default_resolver(logger, env = T.unsafe(nil)); end
  end
end

module Console::Serialized; end

class Console::Serialized::Logger
  # @return [Logger] a new instance of Logger
  def initialize(io = T.unsafe(nil), format: T.unsafe(nil), verbose: T.unsafe(nil), **options); end

  def call(subject = T.unsafe(nil), *arguments, severity: T.unsafe(nil), **options, &block); end
  def dump(record); end

  # Returns the value of attribute format.
  def format; end

  # Returns the value of attribute io.
  def io; end

  # Returns the value of attribute start.
  def start; end

  def verbose!(value = T.unsafe(nil)); end

  private

  def find_exception(message); end
  def format_backtrace(exception, buffer); end
  def format_stack(exception); end
end

# Deprecated.
Console::Shell = Console::Event::Spawn

# Styled terminal output.
module Console::Terminal
  class << self
    def for(io); end

    # Exports CONSOLE_START which can be used to synchronize the start times of all child processes when they log using delta time.
    def start_at!(environment = T.unsafe(nil)); end
  end
end

# This, and all related methods, is considered private.
Console::Terminal::CONSOLE_START_AT = T.let(T.unsafe(nil), String)

class Console::Terminal::Logger
  # @return [Logger] a new instance of Logger
  def initialize(io = T.unsafe(nil), verbose: T.unsafe(nil), start_at: T.unsafe(nil), format: T.unsafe(nil), **options); end

  def call(subject = T.unsafe(nil), *arguments, name: T.unsafe(nil), severity: T.unsafe(nil), **options, &block); end

  # Returns the value of attribute io.
  def io; end

  def register_defaults(terminal); end

  # Returns the value of attribute start.
  def start; end

  # Returns the value of attribute terminal.
  def terminal; end

  # Returns the value of attribute verbose.
  def verbose; end

  def verbose!(value = T.unsafe(nil)); end

  # Sets the attribute verbose
  #
  # @param value the value to set the attribute verbose to.
  def verbose=(_arg0); end

  protected

  def build_prefix(name); end
  def default_suffix(object = T.unsafe(nil)); end
  def format_argument(argument, output); end
  def format_object_subject(severity, prefix, subject, output); end
  def format_options(options, output); end
  def format_string_subject(severity, prefix, subject, output); end
  def format_subject(severity, prefix, subject, buffer); end
  def format_value(value, output); end
  def time_offset_prefix; end
end

Console::Terminal::Logger::UNKNOWN = T.let(T.unsafe(nil), String)

class Console::Terminal::Text
  # @return [Text] a new instance of Text
  def initialize(output); end

  def [](key); end
  def []=(key, value); end

  # @return [Boolean]
  def colors?; end

  # Print out the given arguments.
  # When the argument is a symbol, look up the style and inject it into the output stream.
  # When the argument is a proc/lambda, call it with self as the argument.
  # When the argument is anything else, write it directly to the output.
  def print(*arguments); end

  # Print out the arguments as per {#print}, followed by the reset sequence and a newline.
  def print_line(*arguments); end

  def puts(*arguments, style: T.unsafe(nil)); end
  def reset; end
  def style(foreground, background = T.unsafe(nil), *attributes); end
  def write(*arguments, style: T.unsafe(nil)); end
end

class Console::Terminal::XTerm < ::Console::Terminal::Text
  # @return [Boolean]
  def colors?; end

  def reset; end
  def size; end
  def style(foreground, background = T.unsafe(nil), *attributes); end
end

Console::Terminal::XTerm::ATTRIBUTES = T.let(T.unsafe(nil), Hash)
Console::Terminal::XTerm::COLORS = T.let(T.unsafe(nil), Hash)
Console::UNKNOWN = T.let(T.unsafe(nil), String)
Console::VERSION = T.let(T.unsafe(nil), String)
