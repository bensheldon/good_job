# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `protocol-http` gem.
# Please instead update this file by running `bin/tapioca gem protocol-http`.

# source://protocol-http//lib/protocol/http/body/readable.rb#7
module Protocol; end

# source://protocol-http//lib/protocol/http/body/readable.rb#8
module Protocol::HTTP; end

# source://protocol-http//lib/protocol/http/body/readable.rb#9
module Protocol::HTTP::Body; end

# A body which buffers all it's contents.
#
# source://protocol-http//lib/protocol/http/body/buffered.rb#13
class Protocol::HTTP::Body::Buffered < ::Protocol::HTTP::Body::Readable
  # @return [Buffered] a new instance of Buffered
  #
  # source://protocol-http//lib/protocol/http/body/buffered.rb#38
  def initialize(chunks = T.unsafe(nil), length = T.unsafe(nil)); end

  # Returns the value of attribute chunks.
  #
  # source://protocol-http//lib/protocol/http/body/buffered.rb#45
  def chunks; end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/body/buffered.rb#55
  def empty?; end

  # source://protocol-http//lib/protocol/http/body/buffered.rb#47
  def finish; end

  # source://protocol-http//lib/protocol/http/body/buffered.rb#80
  def inspect; end

  # source://protocol-http//lib/protocol/http/body/buffered.rb#51
  def length; end

  # source://protocol-http//lib/protocol/http/body/buffered.rb#64
  def read; end

  # A buffered response is always ready.
  #
  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/body/buffered.rb#60
  def ready?; end

  # source://protocol-http//lib/protocol/http/body/buffered.rb#76
  def rewind; end

  # source://protocol-http//lib/protocol/http/body/buffered.rb#72
  def write(chunk); end

  class << self
    # source://protocol-http//lib/protocol/http/body/buffered.rb#28
    def for(body); end

    # Wraps an array into a buffered body.
    #
    # @return [Readable, nil] the wrapped body or nil if nil was given.
    #
    # source://protocol-http//lib/protocol/http/body/buffered.rb#16
    def wrap(body); end
  end
end

# Invokes a callback once the body has completed, either successfully or due to an error.
#
# source://protocol-http//lib/protocol/http/body/completable.rb#12
class Protocol::HTTP::Body::Completable < ::Protocol::HTTP::Body::Wrapper
  # @return [Completable] a new instance of Completable
  #
  # source://protocol-http//lib/protocol/http/body/completable.rb#21
  def initialize(body, callback); end

  # source://protocol-http//lib/protocol/http/body/completable.rb#39
  def close(error = T.unsafe(nil)); end

  # source://protocol-http//lib/protocol/http/body/completable.rb#27
  def finish; end

  class << self
    # source://protocol-http//lib/protocol/http/body/completable.rb#13
    def wrap(message, &block); end
  end
end

# source://protocol-http//lib/protocol/http/body/head.rb#11
class Protocol::HTTP::Body::Head < ::Protocol::HTTP::Body::Readable
  # @return [Head] a new instance of Head
  #
  # source://protocol-http//lib/protocol/http/body/head.rb#20
  def initialize(length); end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/body/head.rb#24
  def empty?; end

  # source://protocol-http//lib/protocol/http/body/head.rb#32
  def length; end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/body/head.rb#28
  def ready?; end

  class << self
    # source://protocol-http//lib/protocol/http/body/head.rb#12
    def for(body); end
  end
end

# def finish -> buffer the stream and close it.
# 	def close(error = nil) -> close the stream immediately.
# end
#
# source://protocol-http//lib/protocol/http/body/readable.rb#19
class Protocol::HTTP::Body::Readable
  # Write the body to the given stream.
  #
  # source://protocol-http//lib/protocol/http/body/readable.rb#54
  def call(stream); end

  # The consumer can call stop to signal that the stream output has terminated.
  #
  # source://protocol-http//lib/protocol/http/body/readable.rb#21
  def close(error = T.unsafe(nil)); end

  # Enumerate all chunks until finished, then invoke `#close`.
  #
  # source://protocol-http//lib/protocol/http/body/readable.rb#69
  def each; end

  # Optimistically determine whether read (may) return any data.
  # If this returns true, then calling read will definitely return nil.
  # If this returns false, then calling read may return nil.
  #
  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/body/readable.rb#27
  def empty?; end

  # Read all remaining chunks into a buffered body and close the underlying input.
  #
  # source://protocol-http//lib/protocol/http/body/readable.rb#63
  def finish; end

  # Read all remaining chunks into a single binary string using `#each`.
  #
  # source://protocol-http//lib/protocol/http/body/readable.rb#82
  def join; end

  # source://protocol-http//lib/protocol/http/body/readable.rb#38
  def length; end

  # Read the next available chunk.
  #
  # source://protocol-http//lib/protocol/http/body/readable.rb#43
  def read; end

  # Whether calling read will return a chunk of data without blocking.
  # We prefer pessimistic implementation, and thus default to `false`.
  #
  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/body/readable.rb#34
  def ready?; end

  # Should the internal mechanism prefer to use {call}?
  #
  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/body/readable.rb#49
  def stream?; end
end

# General operations for interacting with a request or response body.
#
# source://protocol-http//lib/protocol/http/body/reader.rb#11
module Protocol::HTTP::Body::Reader
  # Whether there is a body?
  #
  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/body/reader.rb#63
  def body?; end

  # Close the connection as quickly as possible. Discards body. May close the underlying connection if necessary to terminate the stream.
  #
  # source://protocol-http//lib/protocol/http/body/reader.rb#55
  def close(error = T.unsafe(nil)); end

  # Read chunks from the body.
  #
  # @yield [String] read chunks from the body.
  #
  # source://protocol-http//lib/protocol/http/body/reader.rb#14
  def each(&block); end

  # Gracefully finish reading the body. This will buffer the remainder of the body.
  #
  # @return [Buffered] buffers the entire body.
  #
  # source://protocol-http//lib/protocol/http/body/reader.rb#34
  def finish; end

  # Reads the entire request/response body.
  #
  # @return [String] the entire body as a string.
  #
  # source://protocol-http//lib/protocol/http/body/reader.rb#23
  def read; end

  # Write the body of the response to the given file path.
  #
  # source://protocol-http//lib/protocol/http/body/reader.rb#44
  def save(path, mode = T.unsafe(nil), **options); end
end

# The input stream is an IO-like object which contains the raw HTTP POST data. When applicable, its external encoding must be “ASCII-8BIT” and it must be opened in binary mode, for Ruby 1.9 compatibility. The input stream must respond to gets, each, read and rewind.
#
# source://protocol-http//lib/protocol/http/body/stream.rb#13
class Protocol::HTTP::Body::Stream
  include ::Protocol::HTTP::Body::Stream::Reader

  # @raise [ArgumentError]
  # @return [Stream] a new instance of Stream
  #
  # source://protocol-http//lib/protocol/http/body/stream.rb#14
  def initialize(input = T.unsafe(nil), output = T.unsafe(nil)); end

  # source://protocol-http//lib/protocol/http/body/stream.rb#143
  def <<(buffer); end

  # Close the input and output bodies.
  #
  # source://protocol-http//lib/protocol/http/body/stream.rb#165
  def close(error = T.unsafe(nil)); end

  # source://protocol-http//lib/protocol/http/body/stream.rb#150
  def close_read; end

  # close must never be called on the input stream. huh?
  #
  # source://protocol-http//lib/protocol/http/body/stream.rb#159
  def close_write; end

  # Whether the stream has been closed.
  #
  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/body/stream.rb#175
  def closed?; end

  # Whether there are any output chunks remaining?
  #
  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/body/stream.rb#180
  def empty?; end

  # source://protocol-http//lib/protocol/http/body/stream.rb#147
  def flush; end

  # Returns the value of attribute input.
  #
  # source://protocol-http//lib/protocol/http/body/stream.rb#26
  def input; end

  # Returns the value of attribute output.
  #
  # source://protocol-http//lib/protocol/http/body/stream.rb#27
  def output; end

  # source://protocol-http//lib/protocol/http/body/stream.rb#130
  def write(buffer); end

  # source://protocol-http//lib/protocol/http/body/stream.rb#139
  def write_nonblock(buffer); end

  private

  # source://protocol-http//lib/protocol/http/body/stream.rb#186
  def read_next; end
end

# This provides a read-only interface for data, which is surprisingly tricky to implement correctly.
#
# source://protocol-http//lib/protocol/http/body/stream.rb#30
module Protocol::HTTP::Body::Stream::Reader
  # read behaves like IO#read. Its signature is read([length, [buffer]]). If given, length must be a non-negative Integer (>= 0) or nil, and buffer must be a String and may not be nil. If length is given and not nil, then this method reads at most length bytes from the input stream. If length is not given or nil, then this method reads all data until EOF. When EOF is reached, this method returns nil if length is given and not nil, or “” if length is not given or is nil. If buffer is given, then the read data will be placed into buffer instead of a newly created String object.
  #
  # @param length [Integer] the amount of data to read
  # @param buffer [String] the buffer which will receive the data
  # @return a buffer containing the data
  #
  # source://protocol-http//lib/protocol/http/body/stream.rb#38
  def read(length = T.unsafe(nil), buffer = T.unsafe(nil)); end

  # source://protocol-http//lib/protocol/http/body/stream.rb#101
  def read_nonblock(length, buffer = T.unsafe(nil)); end

  # Read at most `length` bytes from the stream. Will avoid reading from the underlying stream if possible.
  #
  # source://protocol-http//lib/protocol/http/body/stream.rb#80
  def read_partial(length = T.unsafe(nil)); end
end

# Wrapping body instance. Typically you'd override `#read`.
#
# source://protocol-http//lib/protocol/http/body/wrapper.rb#12
class Protocol::HTTP::Body::Wrapper < ::Protocol::HTTP::Body::Readable
  # @return [Wrapper] a new instance of Wrapper
  #
  # source://protocol-http//lib/protocol/http/body/wrapper.rb#19
  def initialize(body); end

  # The wrapped body.
  #
  # source://protocol-http//lib/protocol/http/body/wrapper.rb#24
  def body; end

  # source://protocol-http//lib/protocol/http/body/wrapper.rb#62
  def call(stream); end

  # source://protocol-http//lib/protocol/http/body/wrapper.rb#31
  def close(error = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/body/wrapper.rb#37
  def empty?; end

  # Buffer any remaining body.
  #
  # source://protocol-http//lib/protocol/http/body/wrapper.rb#27
  def finish; end

  # source://protocol-http//lib/protocol/http/body/wrapper.rb#54
  def inspect; end

  # source://protocol-http//lib/protocol/http/body/wrapper.rb#45
  def length; end

  # Read the next available chunk.
  #
  # source://protocol-http//lib/protocol/http/body/wrapper.rb#50
  def read; end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/body/wrapper.rb#41
  def ready?; end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/body/wrapper.rb#58
  def stream?; end

  class << self
    # source://protocol-http//lib/protocol/http/body/wrapper.rb#13
    def wrap(message); end
  end
end

# Represents an individual cookie key-value pair.
#
# source://protocol-http//lib/protocol/http/cookie.rb#12
class Protocol::HTTP::Cookie
  # @return [Cookie] a new instance of Cookie
  #
  # source://protocol-http//lib/protocol/http/cookie.rb#13
  def initialize(name, value, directives); end

  # Returns the value of attribute directives.
  #
  # source://protocol-http//lib/protocol/http/cookie.rb#21
  def directives; end

  # source://protocol-http//lib/protocol/http/cookie.rb#23
  def encoded_name; end

  # source://protocol-http//lib/protocol/http/cookie.rb#27
  def encoded_value; end

  # Returns the value of attribute name.
  #
  # source://protocol-http//lib/protocol/http/cookie.rb#19
  def name; end

  # source://protocol-http//lib/protocol/http/cookie.rb#31
  def to_s; end

  # Returns the value of attribute value.
  #
  # source://protocol-http//lib/protocol/http/cookie.rb#20
  def value; end

  class << self
    # source://protocol-http//lib/protocol/http/cookie.rb#52
    def parse(string); end

    # source://protocol-http//lib/protocol/http/cookie.rb#65
    def parse_directives(strings); end
  end
end

# A generic, HTTP protocol error.
#
# source://protocol-http//lib/protocol/http/error.rb#9
class Protocol::HTTP::Error < ::StandardError; end

# source://protocol-http//lib/protocol/http/header/split.rb#8
module Protocol::HTTP::Header; end

# Used for basic authorization.
#
# ~~~ ruby
# headers.add('authorization', Authorization.basic("my_username", "my_password"))
# ~~~
#
# source://protocol-http//lib/protocol/http/header/authorization.rb#16
class Protocol::HTTP::Header::Authorization < ::String
  # Splits the header and
  #
  # @return [Tuple(String, String)]
  #
  # source://protocol-http//lib/protocol/http/header/authorization.rb#19
  def credentials; end

  class << self
    # source://protocol-http//lib/protocol/http/header/authorization.rb#23
    def basic(username, password); end
  end
end

# source://protocol-http//lib/protocol/http/header/cache_control.rb#12
class Protocol::HTTP::Header::CacheControl < ::Protocol::HTTP::Header::Split
  # @return [CacheControl] a new instance of CacheControl
  #
  # source://protocol-http//lib/protocol/http/header/cache_control.rb#27
  def initialize(value = T.unsafe(nil)); end

  # source://protocol-http//lib/protocol/http/header/cache_control.rb#31
  def <<(value); end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/header/cache_control.rb#39
  def dynamic?; end

  # The maximum time, in seconds, a response should be considered fresh.
  # See https://www.rfc-editor.org/rfc/rfc9111.html#name-max-age-2
  #
  # source://protocol-http//lib/protocol/http/header/cache_control.rb#77
  def max_age; end

  # Indicates that a response must not be used once it is stale.
  # See https://www.rfc-editor.org/rfc/rfc9111.html#name-must-revalidate
  #
  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/header/cache_control.rb#65
  def must_revalidate?; end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/header/cache_control.rb#55
  def no_cache?; end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/header/cache_control.rb#59
  def no_store?; end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/header/cache_control.rb#47
  def private?; end

  # Like must-revalidate, but for shared caches only.
  # See https://www.rfc-editor.org/rfc/rfc9111.html#name-proxy-revalidate
  #
  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/header/cache_control.rb#71
  def proxy_revalidate?; end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/header/cache_control.rb#51
  def public?; end

  # Like max-age, but for shared caches only, which should use it before
  # max-age when present.
  # See https://www.rfc-editor.org/rfc/rfc9111.html#name-s-maxage
  #
  # source://protocol-http//lib/protocol/http/header/cache_control.rb#84
  def s_maxage; end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/header/cache_control.rb#35
  def static?; end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/header/cache_control.rb#43
  def streaming?; end

  private

  # source://protocol-http//lib/protocol/http/header/cache_control.rb#90
  def find_integer_value(value_name); end
end

# source://protocol-http//lib/protocol/http/header/cache_control.rb#21
Protocol::HTTP::Header::CacheControl::DYNAMIC = T.let(T.unsafe(nil), String)

# source://protocol-http//lib/protocol/http/header/cache_control.rb#17
Protocol::HTTP::Header::CacheControl::MAX_AGE = T.let(T.unsafe(nil), String)

# source://protocol-http//lib/protocol/http/header/cache_control.rb#24
Protocol::HTTP::Header::CacheControl::MUST_REVALIDATE = T.let(T.unsafe(nil), String)

# source://protocol-http//lib/protocol/http/header/cache_control.rb#15
Protocol::HTTP::Header::CacheControl::NO_CACHE = T.let(T.unsafe(nil), String)

# source://protocol-http//lib/protocol/http/header/cache_control.rb#16
Protocol::HTTP::Header::CacheControl::NO_STORE = T.let(T.unsafe(nil), String)

# source://protocol-http//lib/protocol/http/header/cache_control.rb#13
Protocol::HTTP::Header::CacheControl::PRIVATE = T.let(T.unsafe(nil), String)

# source://protocol-http//lib/protocol/http/header/cache_control.rb#25
Protocol::HTTP::Header::CacheControl::PROXY_REVALIDATE = T.let(T.unsafe(nil), String)

# source://protocol-http//lib/protocol/http/header/cache_control.rb#14
Protocol::HTTP::Header::CacheControl::PUBLIC = T.let(T.unsafe(nil), String)

# source://protocol-http//lib/protocol/http/header/cache_control.rb#20
Protocol::HTTP::Header::CacheControl::STATIC = T.let(T.unsafe(nil), String)

# source://protocol-http//lib/protocol/http/header/cache_control.rb#22
Protocol::HTTP::Header::CacheControl::STREAMING = T.let(T.unsafe(nil), String)

# source://protocol-http//lib/protocol/http/header/cache_control.rb#18
Protocol::HTTP::Header::CacheControl::S_MAXAGE = T.let(T.unsafe(nil), String)

# source://protocol-http//lib/protocol/http/header/connection.rb#11
class Protocol::HTTP::Header::Connection < ::Protocol::HTTP::Header::Split
  # @return [Connection] a new instance of Connection
  #
  # source://protocol-http//lib/protocol/http/header/connection.rb#16
  def initialize(value = T.unsafe(nil)); end

  # source://protocol-http//lib/protocol/http/header/connection.rb#20
  def <<(value); end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/header/connection.rb#28
  def close?; end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/header/connection.rb#24
  def keep_alive?; end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/header/connection.rb#32
  def upgrade?; end
end

# source://protocol-http//lib/protocol/http/header/connection.rb#13
Protocol::HTTP::Header::Connection::CLOSE = T.let(T.unsafe(nil), String)

# source://protocol-http//lib/protocol/http/header/connection.rb#12
Protocol::HTTP::Header::Connection::KEEP_ALIVE = T.let(T.unsafe(nil), String)

# source://protocol-http//lib/protocol/http/header/connection.rb#14
Protocol::HTTP::Header::Connection::UPGRADE = T.let(T.unsafe(nil), String)

# The Cookie HTTP request header contains stored HTTP cookies previously sent by the server with the Set-Cookie header.
#
# source://protocol-http//lib/protocol/http/header/cookie.rb#13
class Protocol::HTTP::Header::Cookie < ::Protocol::HTTP::Header::Multiple
  # source://protocol-http//lib/protocol/http/header/cookie.rb#14
  def to_h; end
end

# source://protocol-http//lib/protocol/http/header/date.rb#11
class Protocol::HTTP::Header::Date < ::String
  # source://protocol-http//lib/protocol/http/header/date.rb#12
  def <<(value); end

  # source://protocol-http//lib/protocol/http/header/date.rb#16
  def to_time; end
end

# source://protocol-http//lib/protocol/http/header/etag.rb#9
class Protocol::HTTP::Header::ETag < ::String
  # source://protocol-http//lib/protocol/http/header/etag.rb#10
  def <<(value); end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/header/etag.rb#14
  def weak?; end
end

# source://protocol-http//lib/protocol/http/header/etags.rb#12
class Protocol::HTTP::Header::ETags < ::Protocol::HTTP::Header::Split
  # This implementation is not strictly correct according to the RFC-specified format.
  #
  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/header/etags.rb#18
  def match?(etag); end

  # Useful with If-Match
  #
  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/header/etags.rb#23
  def strong_match?(etag); end

  # Useful with If-None-Match
  #
  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/header/etags.rb#28
  def weak_match?(etag); end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/header/etags.rb#13
  def wildcard?; end

  private

  # source://protocol-http//lib/protocol/http/header/etags.rb#34
  def opposite_tag(etag); end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/header/etags.rb#38
  def weak_tag?(tag); end
end

# Header value which is split by newline charaters (e.g. cookies).
#
# source://protocol-http//lib/protocol/http/header/multiple.rb#10
class Protocol::HTTP::Header::Multiple < ::Array
  # @return [Multiple] a new instance of Multiple
  #
  # source://protocol-http//lib/protocol/http/header/multiple.rb#11
  def initialize(value); end

  # source://protocol-http//lib/protocol/http/header/multiple.rb#17
  def to_s; end
end

# The Set-Cookie HTTP response header sends cookies from the server to the user agent.
#
# source://protocol-http//lib/protocol/http/header/cookie.rb#24
class Protocol::HTTP::Header::SetCookie < ::Protocol::HTTP::Header::Cookie; end

# Header value which is split by commas.
#
# source://protocol-http//lib/protocol/http/header/split.rb#10
class Protocol::HTTP::Header::Split < ::Array
  # @return [Split] a new instance of Split
  #
  # source://protocol-http//lib/protocol/http/header/split.rb#13
  def initialize(value); end

  # source://protocol-http//lib/protocol/http/header/split.rb#21
  def <<(value); end

  # source://protocol-http//lib/protocol/http/header/split.rb#25
  def to_s; end
end

# source://protocol-http//lib/protocol/http/header/split.rb#11
Protocol::HTTP::Header::Split::COMMA = T.let(T.unsafe(nil), Regexp)

# source://protocol-http//lib/protocol/http/header/vary.rb#11
class Protocol::HTTP::Header::Vary < ::Protocol::HTTP::Header::Split
  # @return [Vary] a new instance of Vary
  #
  # source://protocol-http//lib/protocol/http/header/vary.rb#12
  def initialize(value); end

  # source://protocol-http//lib/protocol/http/header/vary.rb#16
  def <<(value); end
end

# Headers are an array of key-value pairs. Some header keys represent multiple values.
#
# source://protocol-http//lib/protocol/http/headers.rb#20
class Protocol::HTTP::Headers
  # @return [Headers] a new instance of Headers
  #
  # source://protocol-http//lib/protocol/http/headers.rb#50
  def initialize(fields = T.unsafe(nil), indexed = T.unsafe(nil)); end

  # source://protocol-http//lib/protocol/http/headers.rb#306
  def ==(other); end

  # source://protocol-http//lib/protocol/http/headers.rb#289
  def [](key); end

  # Append the value to the given key. Some values can be appended multiple times, others can only be set once.
  #
  # @param key [String] The header key.
  # @param value The header value.
  #
  # source://protocol-http//lib/protocol/http/headers.rb#196
  def []=(key, value); end

  # Add the specified header key value pair.
  #
  # @param key [String] the header key.
  # @param value [String] the header value to assign.
  #
  # source://protocol-http//lib/protocol/http/headers.rb#168
  def add(key, value); end

  # source://protocol-http//lib/protocol/http/headers.rb#65
  def clear; end

  # Delete all headers with the given key, and return the merged value.
  #
  # source://protocol-http//lib/protocol/http/headers.rb#252
  def delete(key); end

  # source://protocol-http//lib/protocol/http/headers.rb#136
  def each(&block); end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/headers.rb#132
  def empty?; end

  # source://protocol-http//lib/protocol/http/headers.rb#150
  def extract(keys); end

  # An array of `[key, value]` pairs.
  #
  # source://protocol-http//lib/protocol/http/headers.rb#86
  def fields; end

  # source://protocol-http//lib/protocol/http/headers.rb#81
  def flatten; end

  # Flatten trailer into the headers.
  #
  # source://protocol-http//lib/protocol/http/headers.rb#72
  def flatten!; end

  # source://protocol-http//lib/protocol/http/headers.rb#120
  def freeze; end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/headers.rb#140
  def include?(key); end

  # source://protocol-http//lib/protocol/http/headers.rb#302
  def inspect; end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/headers.rb#140
  def key?(key); end

  # source://protocol-http//lib/protocol/http/headers.rb#146
  def keys; end

  # source://protocol-http//lib/protocol/http/headers.rb#189
  def merge(headers); end

  # source://protocol-http//lib/protocol/http/headers.rb#181
  def merge!(headers); end

  # Set the specified header key to the specified value, replacing any existing header keys with the same name.
  #
  # @param key [String] the header key to replace.
  # @param value [String] the header value to assign.
  #
  # source://protocol-http//lib/protocol/http/headers.rb#175
  def set(key, value); end

  # A hash table of `{key, policy[key].map(values)}`
  #
  # source://protocol-http//lib/protocol/http/headers.rb#294
  def to_h; end

  # Enumerate all headers in the trailer, if there are any.
  #
  # source://protocol-http//lib/protocol/http/headers.rb#112
  def trailer(&block); end

  # Record the current headers, and prepare to add trailers.
  #
  # This method is typically used after headers are sent to capture any
  # additional headers which should then be sent as trailers.
  #
  # A sender that intends to generate one or more trailer fields in a
  # message should generate a trailer header field in the header section of
  # that message to indicate which fields might be present in the trailers.
  #
  # source://protocol-http//lib/protocol/http/headers.rb#105
  def trailer!(&block); end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/headers.rb#89
  def trailer?; end

  protected

  # source://protocol-http//lib/protocol/http/headers.rb#276
  def merge_into(hash, key, value); end

  private

  # source://protocol-http//lib/protocol/http/headers.rb#58
  def initialize_dup(other); end

  class << self
    # Construct an instance from a headers Array or Hash. No-op if already an instance of `Headers`. If the underlying array is frozen, it will be duped.
    #
    # @return [Headers] an instance of headers.
    #
    # source://protocol-http//lib/protocol/http/headers.rb#28
    def [](headers); end
  end
end

# Used for merging objects into a sequential list of headers. Normalizes header keys and values.
#
# source://protocol-http//lib/protocol/http/headers.rb#318
class Protocol::HTTP::Headers::Merged
  include ::Enumerable

  # @return [Merged] a new instance of Merged
  #
  # source://protocol-http//lib/protocol/http/headers.rb#321
  def initialize(*all); end

  # source://protocol-http//lib/protocol/http/headers.rb#337
  def <<(headers); end

  # source://protocol-http//lib/protocol/http/headers.rb#333
  def clear; end

  # source://protocol-http//lib/protocol/http/headers.rb#344
  def each(&block); end

  # source://protocol-http//lib/protocol/http/headers.rb#325
  def fields; end

  # source://protocol-http//lib/protocol/http/headers.rb#329
  def flatten; end
end

# source://protocol-http//lib/protocol/http/headers.rb#22
Protocol::HTTP::Headers::Multiple = Protocol::HTTP::Header::Multiple

# source://protocol-http//lib/protocol/http/headers.rb#204
Protocol::HTTP::Headers::POLICY = T.let(T.unsafe(nil), Hash)

# source://protocol-http//lib/protocol/http/headers.rb#21
Protocol::HTTP::Headers::Split = Protocol::HTTP::Header::Split

# source://protocol-http//lib/protocol/http/headers.rb#24
Protocol::HTTP::Headers::TRAILER = T.let(T.unsafe(nil), String)

# Provides a convenient interface for commonly supported HTTP methods.
#
# | Method Name | Request Body | Response Body | Safe | Idempotent | Cacheable |
# | ----------- | ------------ | ------------- | ---- | ---------- | --------- |
# | GET         | Optional     | Yes           | Yes  | Yes        | Yes       |
# | HEAD        | Optional     | No            | Yes  | Yes        | Yes       |
# | POST        | Yes          | Yes           | No   | No         | Yes       |
# | PUT         | Yes          | Yes           | No   | Yes        | No        |
# | DELETE      | Optional     | Yes           | No   | Yes        | No        |
# | CONNECT     | Optional     | Yes           | No   | No         | No        |
# | OPTIONS     | Optional     | Yes           | Yes  | Yes        | No        |
# | TRACE       | No           | Yes           | Yes  | Yes        | No        |
# | PATCH       | Yes          | Yes           | No   | No         | No        |
#
# These methods are defined in this module using lower case names. They are for convenience only and you should not overload those methods.
#
# See <https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods> for more details.
#
# source://protocol-http//lib/protocol/http/methods.rb#25
class Protocol::HTTP::Methods
  # source://protocol-http//lib/protocol/http/methods.rb#73
  def connect(location, headers = T.unsafe(nil), body = T.unsafe(nil)); end

  # source://protocol-http//lib/protocol/http/methods.rb#73
  def delete(location, headers = T.unsafe(nil), body = T.unsafe(nil)); end

  # source://protocol-http//lib/protocol/http/methods.rb#73
  def get(location, headers = T.unsafe(nil), body = T.unsafe(nil)); end

  # source://protocol-http//lib/protocol/http/methods.rb#73
  def head(location, headers = T.unsafe(nil), body = T.unsafe(nil)); end

  # source://protocol-http//lib/protocol/http/methods.rb#73
  def options(location, headers = T.unsafe(nil), body = T.unsafe(nil)); end

  # source://protocol-http//lib/protocol/http/methods.rb#73
  def patch(location, headers = T.unsafe(nil), body = T.unsafe(nil)); end

  # source://protocol-http//lib/protocol/http/methods.rb#73
  def post(location, headers = T.unsafe(nil), body = T.unsafe(nil)); end

  # source://protocol-http//lib/protocol/http/methods.rb#73
  def put(location, headers = T.unsafe(nil), body = T.unsafe(nil)); end

  # source://protocol-http//lib/protocol/http/methods.rb#73
  def trace(location, headers = T.unsafe(nil), body = T.unsafe(nil)); end

  class << self
    # Enumerate all HTTP methods.
    #
    # source://protocol-http//lib/protocol/http/methods.rb#64
    def each; end

    # @return [Boolean]
    #
    # source://protocol-http//lib/protocol/http/methods.rb#53
    def valid?(name); end
  end
end

# The CONNECT method establishes a tunnel to the server identified by the target resource.
#
# source://protocol-http//lib/protocol/http/methods.rb#42
Protocol::HTTP::Methods::CONNECT = T.let(T.unsafe(nil), String)

# The DELETE method deletes the specified resource.
#
# source://protocol-http//lib/protocol/http/methods.rb#39
Protocol::HTTP::Methods::DELETE = T.let(T.unsafe(nil), String)

# The GET method requests a representation of the specified resource. Requests using GET should only retrieve data.
#
# source://protocol-http//lib/protocol/http/methods.rb#27
Protocol::HTTP::Methods::GET = T.let(T.unsafe(nil), String)

# The HEAD method asks for a response identical to a GET request, but without the response body.
#
# source://protocol-http//lib/protocol/http/methods.rb#30
Protocol::HTTP::Methods::HEAD = T.let(T.unsafe(nil), String)

# The OPTIONS method describes the communication options for the target resource.
#
# source://protocol-http//lib/protocol/http/methods.rb#45
Protocol::HTTP::Methods::OPTIONS = T.let(T.unsafe(nil), String)

# The PATCH method applies partial modifications to a resource.
#
# source://protocol-http//lib/protocol/http/methods.rb#51
Protocol::HTTP::Methods::PATCH = T.let(T.unsafe(nil), String)

# The POST method submits an entity to the specified resource, often causing a change in state or side effects on the server.
#
# source://protocol-http//lib/protocol/http/methods.rb#33
Protocol::HTTP::Methods::POST = T.let(T.unsafe(nil), String)

# The PUT method replaces all current representations of the target resource with the request payload.
#
# source://protocol-http//lib/protocol/http/methods.rb#36
Protocol::HTTP::Methods::PUT = T.let(T.unsafe(nil), String)

# The TRACE method performs a message loop-back test along the path to the target resource.
#
# source://protocol-http//lib/protocol/http/methods.rb#48
Protocol::HTTP::Methods::TRACE = T.let(T.unsafe(nil), String)

# source://protocol-http//lib/protocol/http/request.rb#14
class Protocol::HTTP::Request
  include ::Protocol::HTTP::Body::Reader

  # @return [Request] a new instance of Request
  #
  # source://protocol-http//lib/protocol/http/request.rb#17
  def initialize(scheme = T.unsafe(nil), authority = T.unsafe(nil), method = T.unsafe(nil), path = T.unsafe(nil), version = T.unsafe(nil), headers = T.unsafe(nil), body = T.unsafe(nil), protocol = T.unsafe(nil)); end

  # The request authority, usually a hostname and port number.
  #
  # source://protocol-http//lib/protocol/http/request.rb#32
  def authority; end

  # The request authority, usually a hostname and port number.
  #
  # source://protocol-http//lib/protocol/http/request.rb#32
  def authority=(_arg0); end

  # The request body, an instance of Protocol::HTTP::Body::Readable or similar.
  #
  # source://protocol-http//lib/protocol/http/request.rb#47
  def body; end

  # The request body, an instance of Protocol::HTTP::Body::Readable or similar.
  #
  # source://protocol-http//lib/protocol/http/request.rb#47
  def body=(_arg0); end

  # Send the request to the given connection.
  #
  # source://protocol-http//lib/protocol/http/request.rb#53
  def call(connection); end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/request.rb#61
  def connect?; end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/request.rb#57
  def head?; end

  # The request headers, contains metadata associated with the request such as the user agent, accept (content type), accept-language, etc.
  #
  # source://protocol-http//lib/protocol/http/request.rb#44
  def headers; end

  # The request headers, contains metadata associated with the request such as the user agent, accept (content type), accept-language, etc.
  #
  # source://protocol-http//lib/protocol/http/request.rb#44
  def headers=(_arg0); end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/request.rb#72
  def idempotent?; end

  # The request method, usually one of "GET", "HEAD", "POST", "PUT", "DELETE", "CONNECT" or "OPTIONS".
  #
  # source://protocol-http//lib/protocol/http/request.rb#35
  def method; end

  # The request method, usually one of "GET", "HEAD", "POST", "PUT", "DELETE", "CONNECT" or "OPTIONS".
  #
  # source://protocol-http//lib/protocol/http/request.rb#35
  def method=(_arg0); end

  # The request path, usually a path and query string.
  #
  # source://protocol-http//lib/protocol/http/request.rb#38
  def path; end

  # The request path, usually a path and query string.
  #
  # source://protocol-http//lib/protocol/http/request.rb#38
  def path=(_arg0); end

  # The request protocol, usually empty, but occasionally "websocket" or "webtransport", can be either single value `String` or multi-value `Array` of `String` instances. In HTTP/1, it is used to request a connection upgrade, and in HTTP/2 it is used to indicate a specfic protocol for the stream.
  #
  # source://protocol-http//lib/protocol/http/request.rb#50
  def protocol; end

  # The request protocol, usually empty, but occasionally "websocket" or "webtransport", can be either single value `String` or multi-value `Array` of `String` instances. In HTTP/1, it is used to request a connection upgrade, and in HTTP/2 it is used to indicate a specfic protocol for the stream.
  #
  # source://protocol-http//lib/protocol/http/request.rb#50
  def protocol=(_arg0); end

  # The request scheme, usually one of "http" or "https".
  #
  # source://protocol-http//lib/protocol/http/request.rb#29
  def scheme; end

  # The request scheme, usually one of "http" or "https".
  #
  # source://protocol-http//lib/protocol/http/request.rb#29
  def scheme=(_arg0); end

  # source://protocol-http//lib/protocol/http/request.rb#76
  def to_s; end

  # The request version, usually "http/1.0", "http/1.1", "h2", or "h3".
  #
  # source://protocol-http//lib/protocol/http/request.rb#41
  def version; end

  # The request version, usually "http/1.0", "http/1.1", "h2", or "h3".
  #
  # source://protocol-http//lib/protocol/http/request.rb#41
  def version=(_arg0); end

  class << self
    # source://protocol-http//lib/protocol/http/request.rb#65
    def [](method, path, headers = T.unsafe(nil), body = T.unsafe(nil)); end
  end
end

# source://protocol-http//lib/protocol/http/response.rb#11
class Protocol::HTTP::Response
  include ::Protocol::HTTP::Body::Reader

  # @return [Response] a new instance of Response
  #
  # source://protocol-http//lib/protocol/http/response.rb#14
  def initialize(version = T.unsafe(nil), status = T.unsafe(nil), headers = T.unsafe(nil), body = T.unsafe(nil), protocol = T.unsafe(nil)); end

  # Whether the status is 400 (bad request).
  #
  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/response.rb#84
  def bad_request?; end

  # Returns the value of attribute body.
  #
  # source://protocol-http//lib/protocol/http/response.rb#25
  def body; end

  # Sets the attribute body
  #
  # @param value the value to set the attribute body to.
  #
  # source://protocol-http//lib/protocol/http/response.rb#25
  def body=(_arg0); end

  # Whether the status is 100 (continue).
  #
  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/response.rb#33
  def continue?; end

  # Whether the status is considered a failure.
  #
  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/response.rb#79
  def failure?; end

  # Whether the status is considered final. Note that 101 is considered final.
  #
  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/response.rb#43
  def final?; end

  # Returns the value of attribute headers.
  #
  # source://protocol-http//lib/protocol/http/response.rb#24
  def headers; end

  # Sets the attribute headers
  #
  # @param value the value to set the attribute headers to.
  #
  # source://protocol-http//lib/protocol/http/response.rb#24
  def headers=(_arg0); end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/response.rb#28
  def hijack?; end

  # Whether the status is considered informational.
  #
  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/response.rb#38
  def informational?; end

  # Whether the status is 500 (internal server error).
  #
  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/response.rb#89
  def internal_server_error?; end

  # Whether the status is 304 (not modified).
  #
  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/response.rb#69
  def not_modified?; end

  # Whether the status is 200 (ok).
  #
  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/response.rb#49
  def ok?; end

  # Whether the status is 206 (partial content).
  #
  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/response.rb#59
  def partial?; end

  # Whether the status is 307 (temporary redirect) and should preserve the method of the request when following the redirect.
  #
  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/response.rb#74
  def preserve_method?; end

  # Returns the value of attribute protocol.
  #
  # source://protocol-http//lib/protocol/http/response.rb#26
  def protocol; end

  # Sets the attribute protocol
  #
  # @param value the value to set the attribute protocol to.
  #
  # source://protocol-http//lib/protocol/http/response.rb#26
  def protocol=(_arg0); end

  # Whether the status is considered a redirection.
  #
  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/response.rb#64
  def redirection?; end

  # Whether the status is 500 (internal server error).
  #
  # @deprecated Use {#internal_server_error?} instead.
  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/response.rb#89
  def server_failure?; end

  # Returns the value of attribute status.
  #
  # source://protocol-http//lib/protocol/http/response.rb#23
  def status; end

  # Sets the attribute status
  #
  # @param value the value to set the attribute status to.
  #
  # source://protocol-http//lib/protocol/http/response.rb#23
  def status=(_arg0); end

  # Whether the status is considered successful.
  #
  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/response.rb#54
  def success?; end

  # source://protocol-http//lib/protocol/http/response.rb#111
  def to_ary; end

  # source://protocol-http//lib/protocol/http/response.rb#107
  def to_s; end

  # Returns the value of attribute version.
  #
  # source://protocol-http//lib/protocol/http/response.rb#22
  def version; end

  # Sets the attribute version
  #
  # @param value the value to set the attribute version to.
  #
  # source://protocol-http//lib/protocol/http/response.rb#22
  def version=(_arg0); end

  class << self
    # source://protocol-http//lib/protocol/http/response.rb#96
    def [](status, headers = T.unsafe(nil), body = T.unsafe(nil), protocol = T.unsafe(nil)); end

    # source://protocol-http//lib/protocol/http/response.rb#103
    def for_exception(exception); end
  end
end

# source://protocol-http//lib/protocol/http/url.rb#9
module Protocol::HTTP::URL
  class << self
    # source://protocol-http//lib/protocol/http/url.rb#71
    def assign(keys, value, parent); end

    # TODO use native C extension from `Trenni::Reference`.
    #
    # source://protocol-http//lib/protocol/http/url.rb#92
    def decode(string, maximum = T.unsafe(nil), symbolize_keys: T.unsafe(nil)); end

    # Encodes a hash or array into a query string.
    #
    # source://protocol-http//lib/protocol/http/url.rb#36
    def encode(value, prefix = T.unsafe(nil)); end

    # Escapes a string using percent encoding.
    #
    # source://protocol-http//lib/protocol/http/url.rb#11
    def escape(string, encoding = T.unsafe(nil)); end

    # Escapes non-path characters using percent encoding.
    #
    # source://protocol-http//lib/protocol/http/url.rb#28
    def escape_path(path); end

    # Scan a string for URL-encoded key/value pairs.
    #
    # source://protocol-http//lib/protocol/http/url.rb#59
    def scan(string); end

    # source://protocol-http//lib/protocol/http/url.rb#67
    def split(name); end

    # Unescapes a percent encoded string.
    #
    # source://protocol-http//lib/protocol/http/url.rb#18
    def unescape(string, encoding = T.unsafe(nil)); end
  end
end

# According to https://tools.ietf.org/html/rfc3986#section-3.3, we escape non-pchar.
#
# source://protocol-http//lib/protocol/http/url.rb#25
Protocol::HTTP::URL::NON_PCHAR = T.let(T.unsafe(nil), Regexp)
