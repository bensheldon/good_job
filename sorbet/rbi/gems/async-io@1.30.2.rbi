# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `async-io` gem.
# Please instead update this file by running `bin/tapioca sync`.

# typed: true

module Async
  extend(::Console)

  class << self
    def run(*arguments, &block); end
  end
end

module Async::IO
  class << self
    def pipe; end
    def try_convert(io, &block); end
  end
end

Async::IO::Address = Addrinfo

class Async::IO::AddressEndpoint < ::Async::IO::Endpoint
  def initialize(address, **options); end

  def address; end
  def bind(&block); end
  def connect(&block); end
  def to_s; end
end

Async::IO::BLOCK_SIZE = T.let(T.unsafe(nil), Integer)

class Async::IO::BasicSocket < ::Async::IO::Generic
  include(::Socket::Constants)
  include(::Async::IO::Peer)

  def close_read(*args, &block); end
  def close_write(*args, &block); end
  def connect_address(*args, &block); end
  def do_not_reverse_lookup(*args, &block); end
  def do_not_reverse_lookup=(*args, &block); end
  def getpeereid(*args, &block); end
  def getpeername(*args, &block); end
  def getsockname(*args, &block); end
  def getsockopt(*args, &block); end
  def local_address(*args, &block); end
  def recv(*args); end
  def recv_nonblock(*args, exception: T.unsafe(nil)); end
  def recvmsg(*args); end
  def recvmsg_nonblock(*args, exception: T.unsafe(nil)); end
  def remote_address(*args, &block); end
  def send(*args); end
  def sendmsg(*args); end
  def sendmsg_nonblock(*args, exception: T.unsafe(nil)); end
  def setsockopt(*args, &block); end
  def shutdown(*args, &block); end
end

class Async::IO::Buffer < ::String
  def initialize; end

  def <<(string); end
  def concat(string); end
end

Async::IO::Buffer::BINARY = T.let(T.unsafe(nil), Encoding)

class Async::IO::Endpoint
  def initialize(**options); end

  def accept(backlog = T.unsafe(nil), &block); end
  def bound; end
  def each; end
  def hostname; end
  def linger; end
  def local_address; end
  def options; end
  def options=(_arg0); end
  def reuse_address; end
  def reuse_port; end
  def timeout; end
  def with(**options); end

  class << self
    def parse(string, **options); end
    def ssl(*args, ssl_context: T.unsafe(nil), hostname: T.unsafe(nil), **options); end
    def tcp(*args, **options); end
    def udp(*args, **options); end
  end
end

class Async::IO::Generic < ::Async::Wrapper
  extend(::Forwardable)

  def <<(buffer); end
  def advise(*args, &block); end
  def autoclose=(*args, &block); end
  def autoclose?(*args, &block); end
  def binmode(*args, &block); end
  def binmode?(*args, &block); end
  def close_on_exec=(*args, &block); end
  def close_on_exec?(*args, &block); end
  def close_read(*args, &block); end
  def close_write(*args, &block); end
  def closed?(*args, &block); end
  def connected?; end
  def dup; end
  def eof(*args, &block); end
  def eof?(*args, &block); end
  def external_encoding(*args, &block); end
  def fcntl(*args, &block); end
  def fdatasync(*args, &block); end
  def fileno(*args, &block); end
  def flush(*args, &block); end
  def fsync(*args, &block); end
  def internal_encoding(*args, &block); end
  def ioctl(*args, &block); end
  def isatty(*args, &block); end
  def nonblock; end
  def nonblock=(value); end
  def nonblock?; end
  def nread(*args, &block); end
  def pathconf(*args, &block); end
  def pid(*args, &block); end
  def pos(*args, &block); end
  def pos=(*args, &block); end
  def pread(*args, &block); end
  def pwrite(*args, &block); end
  def read(length = T.unsafe(nil), buffer = T.unsafe(nil)); end
  def read_nonblock(*args, exception: T.unsafe(nil)); end
  def readpartial(*args, exception: T.unsafe(nil)); end
  def ready?(*args, &block); end
  def reopen(*args, &block); end
  def rewind(*args, &block); end
  def seek(*args, &block); end
  def set_encoding(*args, &block); end
  def set_encoding_by_bom(*args, &block); end
  def stat(*args, &block); end
  def sync(*args, &block); end
  def sync=(*args, &block); end
  def sysread(*args); end
  def sysseek(*args, &block); end
  def syswrite(*args); end
  def tell(*args, &block); end
  def timeout; end
  def timeout=(_arg0); end
  def to_i(*args, &block); end
  def to_io(*args, &block); end
  def tty?(*args, &block); end
  def wait(timeout = T.unsafe(nil), mode = T.unsafe(nil)); end
  def write(buffer); end
  def write_nonblock(*args, exception: T.unsafe(nil)); end

  protected

  def async_send(*arguments, timeout: T.unsafe(nil)); end

  class << self
    def wrap(*args); end
    def wrap_blocking_method(new_name, method_name, invert: T.unsafe(nil), &block); end
    def wrapped_klass; end
    def wraps(klass, *additional_methods); end
  end
end

Async::IO::Generic::WRAPPERS = T.let(T.unsafe(nil), Hash)

class Async::IO::HostEndpoint < ::Async::IO::Endpoint
  def initialize(specification, **options); end

  def address; end
  def bind(&block); end
  def connect; end
  def each; end
  def hostname; end
  def to_s; end
end

class Async::IO::IPSocket < ::Async::IO::BasicSocket
  def addr(*args, &block); end
  def peeraddr(*args, &block); end
  def recvfrom(*args); end
  def recvfrom_nonblock(*args, exception: T.unsafe(nil)); end
end

Async::IO::MAXIMUM_READ_SIZE = T.let(T.unsafe(nil), Integer)

module Async::IO::Peer
  include(::Socket::Constants)

  def connected?; end
  def eof; end
  def eof?; end
  def protocol; end
  def sync; end
  def sync=(value); end
  def type; end
end

class Async::IO::SSLEndpoint < ::Async::IO::Endpoint
  def initialize(endpoint, **options); end

  def address; end
  def bind; end
  def build_context(context = T.unsafe(nil)); end
  def connect(&block); end
  def context; end
  def each; end
  def endpoint; end
  def hostname; end
  def options; end
  def params; end
  def to_s; end
end

Async::IO::SSLError = OpenSSL::SSL::SSLError

class Async::IO::SSLServer
  include(::Async::IO::Server)
  extend(::Forwardable)

  def initialize(server, context); end

  def accept(task: T.unsafe(nil), **options); end
  def close(*args, &block); end
  def close_on_exec=(*args, &block); end
  def context; end
  def dup; end
  def fileno; end
  def getsockopt(*args, &block); end
  def listen(*args); end
  def local_address(*args, &block); end
  def reactor=(*args, &block); end
  def server; end
  def setsockopt(*args, &block); end
  def timeout(*args, &block); end
  def timeout=(*args, &block); end
end

class Async::IO::SSLSocket < ::Async::IO::Generic
  include(::Socket::Constants)
  include(::Async::IO::Peer)

  def initialize(socket, context); end

  def accept(*args); end
  def accept_nonblock(*args, exception: T.unsafe(nil)); end
  def alpn_protocol(*args, &block); end
  def cert(*args, &block); end
  def cipher(*args, &block); end
  def client_ca(*args, &block); end
  def close_read; end
  def close_write; end
  def connect(*args); end
  def connect_nonblock(*args, exception: T.unsafe(nil)); end
  def context(*args, &block); end
  def finished_message(*args, &block); end
  def getsockopt(*args, &block); end
  def hostname(*args, &block); end
  def hostname=(*args, &block); end
  def local_address; end
  def npn_protocol(*args, &block); end
  def peer_cert(*args, &block); end
  def peer_cert_chain(*args, &block); end
  def peer_finished_message(*args, &block); end
  def pending(*args, &block); end
  def post_connection_check(*args, &block); end
  def remote_address; end
  def session(*args, &block); end
  def session=(*args, &block); end
  def session_reused?(*args, &block); end
  def setsockopt(*args, &block); end
  def shutdown(how); end
  def ssl_version(*args, &block); end
  def state(*args, &block); end
  def sync_close(*args, &block); end
  def sync_close=(*args, &block); end
  def sysclose(*args, &block); end
  def tmp_key(*args, &block); end
  def verify_result(*args, &block); end

  class << self
    def connect(socket, context, hostname = T.unsafe(nil), &block); end
  end
end

Async::IO::SecureEndpoint = Async::IO::SSLEndpoint

module Async::IO::Server
  def accept_each(timeout: T.unsafe(nil), task: T.unsafe(nil)); end
end

class Async::IO::Socket < ::Async::IO::BasicSocket
  include(::Async::IO::Server)

  def accept(timeout: T.unsafe(nil), task: T.unsafe(nil)); end
  def accept_nonblock(timeout: T.unsafe(nil), task: T.unsafe(nil)); end
  def bind(*args, &block); end
  def connect(*args); end
  def connect_nonblock(*args); end
  def ipv6only!(*args, &block); end
  def listen(*args, &block); end
  def recvfrom(*args); end
  def recvfrom_nonblock(*args, exception: T.unsafe(nil)); end
  def sysaccept(timeout: T.unsafe(nil), task: T.unsafe(nil)); end

  class << self
    def accept(*args, backlog: T.unsafe(nil), &block); end
    def bind(local_address, protocol: T.unsafe(nil), task: T.unsafe(nil), **options, &block); end
    def build(*args, timeout: T.unsafe(nil), reuse_address: T.unsafe(nil), reuse_port: T.unsafe(nil), linger: T.unsafe(nil), task: T.unsafe(nil)); end
    def connect(remote_address, local_address: T.unsafe(nil), task: T.unsafe(nil), **options); end
    def pair(*args); end
  end
end

class Async::IO::Stream
  def initialize(io, block_size: T.unsafe(nil), maximum_read_size: T.unsafe(nil), sync: T.unsafe(nil), deferred: T.unsafe(nil)); end

  def <<(string); end
  def block_size; end
  def close; end
  def close_read; end
  def close_write; end
  def closed?; end
  def connected?; end
  def eof; end
  def eof!; end
  def eof?; end
  def flush; end
  def gets(separator = T.unsafe(nil), **options); end
  def io; end
  def peek; end
  def puts(*arguments, separator: T.unsafe(nil)); end
  def read(size = T.unsafe(nil)); end
  def read_exactly(size, exception: T.unsafe(nil)); end
  def read_partial(size = T.unsafe(nil)); end
  def read_until(pattern, offset = T.unsafe(nil), chomp: T.unsafe(nil)); end
  def readpartial(size = T.unsafe(nil)); end
  def write(string); end

  private

  def consume_read_buffer(size = T.unsafe(nil)); end
  def fill_read_buffer(size = T.unsafe(nil)); end

  class << self
    def open(path, mode = T.unsafe(nil), **options); end
  end
end

Async::IO::Stream::BLOCK_SIZE = T.let(T.unsafe(nil), Integer)

Async::VERSION = T.let(T.unsafe(nil), String)
