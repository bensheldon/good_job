# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `mdl` gem.
# Please instead update this file by running `bin/tapioca gem mdl`.

module Kramdown
  class << self
    # Return the data directory for kramdown.
    def data_dir; end
  end
end

# This module contains all available parsers. A parser takes an input string and converts the
# string to an element tree.
#
# New parsers should be derived from the Base class which provides common functionality - see its
# API documentation for how to create a custom converter class.
module Kramdown::Parser; end

# modified parser class - see comment above
class Kramdown::Parser::MarkdownLint < ::Kramdown::Parser::Kramdown
  # @return [MarkdownLint] a new instance of MarkdownLint
  def initialize(source, options); end
end

# Regular kramdown parser, but with GFM style fenced code blocks
Kramdown::Parser::MarkdownLint::FENCED_CODEBLOCK_MATCH = T.let(T.unsafe(nil), Regexp)

# The kramdown version.
Kramdown::VERSION = T.let(T.unsafe(nil), String)

# Primary MDL container
module MarkdownLint
  class << self
    def run(argv = T.unsafe(nil)); end
  end
end

# Our Mixlib::CLI class
class MarkdownLint::CLI
  include ::Mixlib::CLI
  extend ::Mixlib::CLI::ClassMethods
  extend ::Mixlib::CLI::InheritMethods

  def run(argv = T.unsafe(nil)); end

  class << self
    def probe_config_file(path); end
    def toggle_list(parts, to_sym = T.unsafe(nil)); end
  end
end

MarkdownLint::CLI::CONFIG_FILE = T.let(T.unsafe(nil), String)

# our Mixlib::Config class
module MarkdownLint::Config
  extend ::Mixlib::Config

  class << self
    def config_context_hashes; end
    def config_context_hashes=(_arg0); end
    def config_context_lists; end
    def config_context_lists=(_arg0); end
    def config_contexts; end
    def config_contexts=(_arg0); end
    def config_parent; end
    def config_parent=(_arg0); end
    def configurables; end
    def configurables=(_arg0); end
    def configuration; end
    def configuration=(_arg0); end
    def style(*args, &block); end
    def style=(value); end
  end
end

# Representation of the markdown document passed to rule checks
class MarkdownLint::Doc
  # Create a new document given a string containing the markdown source
  #
  # @return [Doc] a new instance of Doc
  def initialize(text, ignore_front_matter = T.unsafe(nil)); end

  # Returns the actual source line for a given element. You can pass in an
  # element object or an options hash here. This is useful if you need to
  # examine the source line directly for your rule to make use of
  # information that isn't present in the parsed document.
  def element_line(element); end

  # Returns the line number a given element is located on in the source
  # file. You can pass in either an element object or an options hash here.
  def element_linenumber(element); end

  # Returns a list of line numbers for all elements passed in. You can pass
  # in a list of element objects or a list of options hashes here.
  def element_linenumbers(elements); end

  # Returns the actual source lines for a list of elements. You can pass in
  # a list of elements objects or a list of options hashes here.
  def element_lines(elements); end

  # A list of raw markdown source lines. Note that the list is 0-indexed,
  # while line numbers in the parsed source are 1-indexed, so you need to
  # subtract 1 from a line number to get the correct line. The element_line*
  # methods take care of this for you.
  def elements; end

  # Extracts the text from an element whose children consist of text
  # elements and other things
  def extract_text(element, prefix = T.unsafe(nil), restore_whitespace = T.unsafe(nil)); end

  # Find all elements of a given type, returning their options hash. The
  # options hash has most of the useful data about an element and often you
  # can just use this in your rules.
  #
  #   # Returns [ { :location => 1, :element_level => 2 }, ... ]
  #   elements = find_type(:li)
  #
  # If +nested+ is set to false, this returns only top level elements of a
  # given type.
  def find_type(type, nested = T.unsafe(nil)); end

  # Find all elements of a given type, returning a list of the element
  # objects themselves.
  #
  # Instead of a single type, a list of types can be provided instead to
  # find all types.
  #
  # If +nested+ is set to false, this returns only top level elements of a
  # given type.
  def find_type_elements(type, nested = T.unsafe(nil), elements = T.unsafe(nil)); end

  # A variation on find_type_elements that allows you to skip drilling down
  # into children of specific element types.
  #
  # Instead of a single type, a list of types can be provided instead to
  # find all types.
  #
  # Unlike find_type_elements, this method will always search for nested
  # elements, and skip the element types given to nested_except.
  def find_type_elements_except(type, nested_except = T.unsafe(nil), elements = T.unsafe(nil)); end

  # Returns the header 'style' - :atx (hashes at the beginning), :atx_closed
  # (atx header style, but with hashes at the end of the line also), :setext
  # (underlined). You can pass in the element object or an options hash
  # here.
  def header_style(header); end

  # Returns how much a given line is indented. Hard tabs are treated as an
  # indent of 8 spaces. You need to pass in the raw string here.
  def indent_for(line); end

  # A list of raw markdown source lines. Note that the list is 0-indexed,
  # while line numbers in the parsed source are 1-indexed, so you need to
  # subtract 1 from a line number to get the correct line. The element_line*
  # methods take care of this for you.
  def lines; end

  # Returns the list style for a list: :asterisk, :plus, :dash, :ordered or
  # :ordered_paren depending on which symbol is used to denote the list
  # item. You can pass in either the element itself or an options hash here.
  def list_style(item); end

  # Returns line numbers for lines that match the given regular expression
  def matching_lines(regex); end

  # Returns line numbers for lines that match the given regular expression.
  # Only considers text inside of 'text' elements (i.e. regular markdown
  # text and not code/links or other elements).
  def matching_text_element_lines(regex, exclude_nested = T.unsafe(nil)); end

  # A list of raw markdown source lines. Note that the list is 0-indexed,
  # while line numbers in the parsed source are 1-indexed, so you need to
  # subtract 1 from a line number to get the correct line. The element_line*
  # methods take care of this for you.
  def offset; end

  # A list of raw markdown source lines. Note that the list is 0-indexed,
  # while line numbers in the parsed source are 1-indexed, so you need to
  # subtract 1 from a line number to get the correct line. The element_line*
  # methods take care of this for you.
  def parsed; end

  private

  # Adds a 'level' and 'parent' option to all elements to show how nested they
  # are
  def add_annotations(elements, level = T.unsafe(nil), parent = T.unsafe(nil)); end

  class << self
    # Alternate 'constructor' passing in a filename
    def new_from_file(filename, ignore_front_matter = T.unsafe(nil)); end
  end
end

# defines a single rule
class MarkdownLint::Rule
  # @return [Rule] a new instance of Rule
  def initialize(id, description, block); end

  def aliases(*aliases); end
  def check(&block); end

  # Returns the value of attribute description.
  def description; end

  # Sets the attribute description
  #
  # @param value the value to set the attribute description to.
  def description=(_arg0); end

  # Returns the value of attribute id.
  def id; end

  # Sets the attribute id
  #
  # @param value the value to set the attribute id to.
  def id=(_arg0); end

  def params(params = T.unsafe(nil)); end
  def tags(*tags); end
end

# defines a ruleset
class MarkdownLint::RuleSet
  # @return [RuleSet] a new instance of RuleSet
  def initialize; end

  def load(rules_file); end
  def load_default; end
  def rule(id, description, &block); end

  # Returns the value of attribute rules.
  def rules; end
end

# defines a style
class MarkdownLint::Style
  # @return [Style] a new instance of Style
  def initialize(all_rules); end

  def all; end
  def exclude_rule(id); end
  def exclude_tag(tag); end
  def rule(id, params = T.unsafe(nil)); end

  # Returns the value of attribute rules.
  def rules; end

  def tag(tag); end

  class << self
    def load(style_file, rules); end
  end
end

MarkdownLint::VERSION = T.let(T.unsafe(nil), String)
