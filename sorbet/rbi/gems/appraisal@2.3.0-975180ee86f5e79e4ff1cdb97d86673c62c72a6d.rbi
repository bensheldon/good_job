# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `appraisal` gem.
# Please instead update this file by running `bin/tapioca gem appraisal`.

module Appraisal; end

# Represents one appraisal and its dependencies
class Appraisal::Appraisal
  # @return [Appraisal] a new instance of Appraisal
  def initialize(name, source_gemfile); end

  def gem(*args); end

  # Returns the value of attribute gemfile.
  def gemfile; end

  def gemfile_path; end
  def gemspec(options = T.unsafe(nil)); end
  def git(*args, &block); end
  def git_source(*args, &block); end
  def group(*args, &block); end
  def install(options = T.unsafe(nil)); end

  # Returns the value of attribute name.
  def name; end

  def path(*args, &block); end
  def platforms(*args, &block); end
  def relative_gemfile_path; end
  def relativize; end
  def remove_gem(*args); end
  def ruby(*args); end
  def source(*args, &block); end
  def update(gems = T.unsafe(nil)); end
  def write_gemfile; end

  private

  def bundle_options(options); end
  def check_command; end
  def clean_name; end
  def gemfile_name; end
  def gemfile_root; end
  def install_command(options = T.unsafe(nil)); end
  def lockfile_path; end
  def project_root; end
  def update_command(gems); end
end

Appraisal::Appraisal::DEFAULT_INSTALL_OPTIONS = T.let(T.unsafe(nil), Hash)

# Loads and parses Appraisals file
class Appraisal::AppraisalFile
  # @return [AppraisalFile] a new instance of AppraisalFile
  def initialize; end

  # Returns the value of attribute appraisals.
  def appraisals; end

  def appraise(name, &block); end
  def each(&block); end

  # Returns the value of attribute gemfile.
  def gemfile; end

  private

  def path; end
  def run(definitions); end

  class << self
    def each(&block); end
  end
end

# Raises when Appraisal is unable to locate Appraisals file in the current directory.
class Appraisal::AppraisalsNotFound < ::StandardError
  def message; end
end

class Appraisal::BundlerDSL
  # @return [BundlerDSL] a new instance of BundlerDSL
  def initialize; end

  # Returns the value of attribute dependencies.
  def dependencies; end

  def for_dup; end
  def gem(name, *requirements); end
  def gemspec(options = T.unsafe(nil)); end
  def git(source, options = T.unsafe(nil), &block); end
  def git_source(source, &block); end
  def group(*names, &block); end
  def path(source, options = T.unsafe(nil), &block); end
  def platform(*names, &block); end
  def platforms(*names, &block); end
  def remove_gem(name); end
  def ruby(ruby_version); end
  def run(&block); end
  def source(source, &block); end
  def to_s; end

  protected

  # Sets the attribute git_sources
  #
  # @param value the value to set the attribute git_sources to.
  def git_sources=(_arg0); end

  private

  def dependencies_entry; end
  def dependencies_entry_for_dup; end
  def gemspec_entry; end
  def gemspec_entry_for_dup; end
  def gits_entry; end
  def gits_entry_for_dup; end
  def groups_entry; end
  def groups_entry_for_dup; end
  def indent(string); end
  def paths_entry; end
  def paths_entry_for_dup; end
  def platforms_entry; end
  def platforms_entry_for_dup; end
  def ruby_version_entry; end
  def ruby_version_entry_for_dup; end
  def source_blocks_entry; end
  def source_blocks_entry_for_dup; end
  def source_entry; end
  def source_entry_for_dup; end
  def substitute_git_source(requirements); end
end

Appraisal::BundlerDSL::PARTS = T.let(T.unsafe(nil), Array)

# Executes commands with a clean environment
class Appraisal::Command
  # @return [Command] a new instance of Command
  def initialize(command, options = T.unsafe(nil)); end

  # Returns the value of attribute command.
  def command; end

  # Returns the value of attribute env.
  def env; end

  # Returns the value of attribute gemfile.
  def gemfile; end

  def run; end

  private

  def announce; end
  def command_as_string; end
  def command_starting_with_bundle(original_command); end

  # @return [Boolean]
  def command_starts_with_bundle?(original_command); end

  def ensure_bundler_is_available; end
end

# Dependency on a gem and optional version requirements
class Appraisal::Dependency
  # @return [Dependency] a new instance of Dependency
  def initialize(name, requirements); end

  def for_dup; end

  # Returns the value of attribute name.
  def name; end

  # Returns the value of attribute requirements.
  def requirements; end

  # Sets the attribute requirements
  #
  # @param value the value to set the attribute requirements to.
  def requirements=(_arg0); end

  def to_s; end

  private

  def formatted_output(output_requirements); end
  def gem_name; end

  # @return [Boolean]
  def no_requirements?; end

  def path_prefixed_requirements; end
end

class Appraisal::DependencyList
  # @return [DependencyList] a new instance of DependencyList
  def initialize; end

  def add(name, requirements); end
  def for_dup; end
  def remove(name); end
  def to_s; end
end

# Load bundler Gemfiles and merge dependencies
class Appraisal::Gemfile < ::Appraisal::BundlerDSL
  def dup; end
  def load(path); end
  def run(definitions); end
end

class Appraisal::Gemspec
  # @return [Gemspec] a new instance of Gemspec
  def initialize(options = T.unsafe(nil)); end

  def for_dup; end

  # Returns the value of attribute options.
  def options; end

  def to_s; end

  private

  def exported_options; end
end

class Appraisal::Git < ::Appraisal::BundlerDSL
  # @return [Git] a new instance of Git
  def initialize(source, options = T.unsafe(nil)); end

  def for_dup; end
  def to_s; end
end

class Appraisal::Group < ::Appraisal::BundlerDSL
  # @return [Group] a new instance of Group
  def initialize(group_names); end

  def for_dup; end
  def to_s; end

  private

  def formatted_output(output_dependencies); end
end

class Appraisal::Path < ::Appraisal::BundlerDSL
  # @return [Path] a new instance of Path
  def initialize(source, options = T.unsafe(nil)); end

  def for_dup; end
  def to_s; end
end

class Appraisal::Platform < ::Appraisal::BundlerDSL
  # @return [Platform] a new instance of Platform
  def initialize(platform_names); end

  def for_dup; end
  def to_s; end

  private

  def formatted_output(output_dependencies); end
end

class Appraisal::Source < ::Appraisal::BundlerDSL
  # @return [Source] a new instance of Source
  def initialize(source); end

  def for_dup; end
  def to_s; end

  private

  def formatted_output(output_dependencies); end
end

# Defines tasks for installing appraisal dependencies and running other tasks
# for a given appraisal.
class Appraisal::Task < ::Rake::TaskLib
  # @return [Task] a new instance of Task
  def initialize; end
end

# Contains methods for various operations
module Appraisal::Utils
  class << self
    def bundler_version; end
    def format_arguments(arguments); end
    def format_hash_value(key, value); end
    def format_string(object, enclosing_object = T.unsafe(nil)); end
    def join_parts(parts); end
    def prefix_path(path); end

    # @return [Boolean]
    def support_parallel_installation?; end
  end
end

Appraisal::VERSION = T.let(T.unsafe(nil), String)
