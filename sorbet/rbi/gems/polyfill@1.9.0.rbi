# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `polyfill` gem.
# Please instead update this file by running `bin/tapioca gem polyfill`.

module Polyfill
  private

  def get(module_name, methods, options = T.unsafe(nil)); end

  class << self
    def get(module_name, methods, options = T.unsafe(nil)); end
  end
end

module Polyfill::InternalUtils
  private

  def create_module(*args); end
  def current_ruby_version; end
  def ignore_warnings; end
  def keep_only_these_methods!(mod, whitelist); end
  def methods_to_keep(modules, methods, lead_symbol, module_name); end
  def modules_to_use(module_name, versions); end
  def namify_arguments(*args); end
  def polyfill_versions_to_use(desired_version = T.unsafe(nil)); end
  def to_f(obj); end
  def to_hash(obj); end
  def to_int(obj); end
  def to_str(obj); end

  class << self
    def create_module(*args); end
    def current_ruby_version; end
    def ignore_warnings; end
    def keep_only_these_methods!(mod, whitelist); end
    def methods_to_keep(modules, methods, lead_symbol, module_name); end
    def modules_to_use(module_name, versions); end
    def namify_arguments(*args); end
    def polyfill_versions_to_use(desired_version = T.unsafe(nil)); end
    def to_f(obj); end
    def to_hash(obj); end
    def to_int(obj); end
    def to_str(obj); end
  end
end

Polyfill::InternalUtils::VERSIONS = T.let(T.unsafe(nil), Hash)
module Polyfill::Module; end
module Polyfill::Module::MezpFbnVtZXJhYmxlPT5bIiNjaHVua193aGlsZSJdLCA6dmVyc2lvbj0_1IjIuNCJ9; end
module Polyfill::Module::MezpIYXNoPT5bIiNzbGljZSJdfQ__; end
module Polyfill::Module::MezpJbnRlZ2VyPT5bIiNjZWlsIiwgIiNmbG9vciIsICIjcm91bmQiLCAiI3RydW5jYXRlIl0sIDp2ZXJzaW9uPT4iMi40In0_; end
module Polyfill::Module::MezpLZXJuZWw9PlsiI3lpZWxkX3NlbGYiXSwgOnZlcnNpb249PiIyLjUifQ__; end
module Polyfill::Module::MezpOdW1lcmljPT5bIiNkdXAiXSwgOnZlcnNpb249PiIyLjQifQ__; end
module Polyfill::V2_2; end

module Polyfill::V2_2::Enumerable
  # @raise [ArgumentError]
  def max(n = T.unsafe(nil)); end

  # @raise [ArgumentError]
  def max_by(n = T.unsafe(nil)); end

  # @raise [ArgumentError]
  def min(n = T.unsafe(nil)); end

  # @raise [ArgumentError]
  def min_by(n = T.unsafe(nil)); end

  # @raise [ArgumentError]
  def slice_after(pattern = T.unsafe(nil)); end

  def slice_when; end
end

module Polyfill::V2_2::Kernel
  def itself; end
end

module Polyfill::V2_2::Math; end

module Polyfill::V2_2::Math::ClassMethods
  def log(*args); end
end

module Polyfill::V2_2::Prime; end

module Polyfill::V2_2::Prime::ClassMethods
  # @return [Boolean]
  def prime?(*args); end
end

module Polyfill::V2_2::Vector
  def +@; end
end

module Polyfill::V2_3; end

module Polyfill::V2_3::Array
  def bsearch_index; end
  def dig(head, *rest); end
end

module Polyfill::V2_3::Enumerable
  def chunk_while; end
  def grep_v(pattern); end
  def slice_before(*args); end
end

module Polyfill::V2_3::Enumerator; end

module Polyfill::V2_3::Enumerator::Lazy
  def grep_v(pattern); end
end

module Polyfill::V2_3::Hash
  def <(other); end
  def <=(other); end
  def >(other); end
  def >=(other); end
  def dig(head, *rest); end
  def fetch_values(*keys); end
  def to_proc; end
end

module Polyfill::V2_3::Kernel
  def loop; end
end

module Polyfill::V2_3::Numeric
  # @return [Boolean]
  def negative?; end

  # @return [Boolean]
  def positive?; end
end

module Polyfill::V2_3::Prime; end

module Polyfill::V2_3::Prime::ClassMethods
  # @return [Boolean]
  def prime?(*args); end
end

module Polyfill::V2_3::String
  def +@; end
  def -@; end
end

module Polyfill::V2_3::String::ClassMethods
  def new(*args); end
end

module Polyfill::V2_3::Struct
  def dig(head, *rest); end
end

module Polyfill::V2_4; end

module Polyfill::V2_4::Array
  def concat(*others); end
  def sum(init = T.unsafe(nil)); end
end

module Polyfill::V2_4::Comparable
  def clamp(min, max); end
end

module Polyfill::V2_4::Dir; end

module Polyfill::V2_4::Dir::ClassMethods
  # @return [Boolean]
  def empty?(path_name); end
end

module Polyfill::V2_4::Enumerable
  def chunk(*_arg0); end
  def sum(init = T.unsafe(nil)); end
  def uniq; end
end

module Polyfill::V2_4::Enumerator; end

module Polyfill::V2_4::Enumerator::Lazy
  def chunk_while; end
  def uniq; end
end

module Polyfill::V2_4::File; end

module Polyfill::V2_4::File::ClassMethods
  # @return [Boolean]
  def empty?(file_name); end
end

module Polyfill::V2_4::Float
  def ceil(ndigits = T.unsafe(nil)); end
  def floor(ndigits = T.unsafe(nil)); end
  def truncate(ndigits = T.unsafe(nil)); end
end

module Polyfill::V2_4::Hash
  def compact; end
  def compact!; end
  def transform_values; end
  def transform_values!; end
end

module Polyfill::V2_4::IO
  def each_line(*args); end
  def gets(*args); end
  def lines(*args); end
  def readline(*args); end
  def readlines(*args); end
end

module Polyfill::V2_4::IO::ClassMethods
  def foreach(name, *args); end
  def readlines(file_name, *args); end
end

module Polyfill::V2_4::IPAddr
  def <=>(*_arg0); end
  def ==(*_arg0); end
end

module Polyfill::V2_4::Integer
  def ceil(ndigits = T.unsafe(nil)); end

  # @raise [Math::DomainError]
  def digits(base = T.unsafe(nil)); end

  def floor(ndigits = T.unsafe(nil)); end
  def round(ndigits = T.unsafe(nil), half: T.unsafe(nil)); end
  def truncate(ndigits = T.unsafe(nil)); end
end

module Polyfill::V2_4::MatchData
  def named_captures; end
  def values_at(*indexes); end
end

module Polyfill::V2_4::Numeric
  def clone(freeze: T.unsafe(nil)); end
  def dup; end

  # @return [Boolean]
  def finite?; end

  # @return [Boolean]
  def infinite?; end
end

module Polyfill::V2_4::Object
  def clone(freeze: T.unsafe(nil)); end
end

module Polyfill::V2_4::Pathname
  # @return [Boolean]
  def empty?; end
end

module Polyfill::V2_4::Regexp
  # @return [Boolean]
  def match?(string, position = T.unsafe(nil)); end
end

module Polyfill::V2_4::String
  # @return [Boolean]
  def casecmp?(other); end

  def concat(*others); end
  def each_line(*args); end
  def lines(*args); end

  # @return [Boolean]
  def match?(pattern, position = T.unsafe(nil)); end

  def prepend(*others); end
  def unpack1(*args); end
end

module Polyfill::V2_4::String::ClassMethods
  def new(*args); end
end

module Polyfill::V2_4::StringIO
  def each_line(*args); end
  def gets(*args); end
  def lines(*args); end
  def readline(*args); end
  def readlines(*args); end
end

module Polyfill::V2_4::StringIO::ClassMethods
  def foreach(name, *args); end
  def readlines(file_name, *args); end
end

module Polyfill::V2_4::Symbol
  # @return [Boolean]
  def casecmp?(other); end

  def match(*args); end

  # @return [Boolean]
  def match?(pattern, position = T.unsafe(nil)); end
end

module Polyfill::V2_5; end

module Polyfill::V2_5::Array
  def append(*args); end
  def prepend(*args); end
end

module Polyfill::V2_5::BigDecimal
  def clone; end
  def dup; end
end

module Polyfill::V2_5::Dir; end

module Polyfill::V2_5::Dir::ClassMethods
  def children(dirname, encoding: T.unsafe(nil)); end
  def each_child(dirname, encoding: T.unsafe(nil)); end
end

module Polyfill::V2_5::Enumerable
  # @return [Boolean]
  def all?(*pattern); end

  # @return [Boolean]
  def any?(*pattern); end

  # @return [Boolean]
  def none?(*pattern); end

  # @return [Boolean]
  def one?(*pattern); end
end

module Polyfill::V2_5::Hash
  def slice(*keys); end
  def transform_keys; end
end

module Polyfill::V2_5::Integer
  # @return [Boolean]
  def allbits?(mask); end

  # @return [Boolean]
  def anybits?(mask); end

  def ceil(*_arg0); end
  def floor(*_arg0); end

  # @return [Boolean]
  def nobits?(mask); end

  def round(*_arg0); end
  def truncate(*_arg0); end
end

module Polyfill::V2_5::Integer::ClassMethods
  def sqrt(n); end
end

module Polyfill::V2_5::Kernel
  # @yield [_self]
  # @yieldparam _self [Polyfill::V2_5::Kernel] the object that the method was called on
  def yield_self; end
end

module Polyfill::V2_5::Set
  def ===(other); end
  def to_s; end
end

module Polyfill::V2_5::String
  def casecmp(other_str); end

  # @return [Boolean]
  def casecmp?(other_str); end

  def delete_prefix(prefix); end
  def delete_prefix!(prefix); end
  def delete_suffix(suffix); end
  def delete_suffix!(suffix); end
  def each_grapheme_cluster; end
  def grapheme_clusters; end

  # @return [Boolean]
  def start_with?(*prefixes); end
end

module Polyfill::V2_5::Struct; end

module Polyfill::V2_5::Struct::ClassMethods
  def new(*args, keyword_init: T.unsafe(nil)); end
end

module Polyfill::V2_5::Time; end

module Polyfill::V2_5::Time::ClassMethods
  def at(*args); end
end

module Polyfill::V2_6; end

module Polyfill::V2_6::Array
  def difference(*arrays); end
  def to_h; end
  def union(*arrays); end
end

module Polyfill::V2_6::Enumerable
  def to_h; end
end

module Polyfill::V2_6::Hash
  def merge(*args); end
  def merge!(*args); end
  def to_h; end
  def update(*args); end
end

module Polyfill::V2_6::Kernel
  def Complex(*args, exception: T.unsafe(nil)); end
  def Float(arg, exception: T.unsafe(nil)); end
  def Integer(arg, exception: T.unsafe(nil)); end
  def Rational(*args, exception: T.unsafe(nil)); end
  def then; end
end

module Polyfill::V2_6::OpenStruct
  def to_h; end
end

module Polyfill::V2_6::String
  def split(*_arg0); end
end

module Polyfill::V2_6::Struct
  def to_h; end
end

Polyfill::VERSION = T.let(T.unsafe(nil), Gem::Version)
