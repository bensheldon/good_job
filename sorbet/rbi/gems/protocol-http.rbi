# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: true
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/protocol-http/all/protocol-http.rbi
#
# protocol-http-0.22.5

module Protocol
end
module Protocol::HTTP
end
module Protocol::HTTP::Body
end
class Protocol::HTTP::Body::Readable
  def call(stream); end
  def close(error = nil); end
  def each; end
  def empty?; end
  def finish; end
  def join; end
  def length; end
  def read; end
  def ready?; end
  def stream?; end
end
class Protocol::HTTP::Body::Wrapper < Protocol::HTTP::Body::Readable
  def body; end
  def call(stream); end
  def close(error = nil); end
  def empty?; end
  def finish; end
  def initialize(body); end
  def inspect; end
  def length; end
  def read; end
  def ready?; end
  def self.wrap(message); end
  def stream?; end
end
class Protocol::HTTP::Body::Completable < Protocol::HTTP::Body::Wrapper
  def close(error = nil); end
  def finish; end
  def initialize(body, callback); end
  def self.wrap(message, &block); end
end
class Protocol::HTTP::Methods
  def connect(location, headers = nil, body = nil); end
  def delete(location, headers = nil, body = nil); end
  def get(location, headers = nil, body = nil); end
  def head(location, headers = nil, body = nil); end
  def link(location, headers = nil, body = nil); end
  def options(location, headers = nil, body = nil); end
  def patch(location, headers = nil, body = nil); end
  def post(location, headers = nil, body = nil); end
  def put(location, headers = nil, body = nil); end
  def self.each; end
  def self.valid?(name); end
  def trace(location, headers = nil, body = nil); end
  def unlink(location, headers = nil, body = nil); end
end
module Protocol::HTTP::Header
end
class Protocol::HTTP::Header::Split < Array
  def <<(value); end
  def initialize(value); end
  def to_s; end
end
class Protocol::HTTP::Header::Multiple < Array
  def initialize(value); end
  def to_s; end
end
module Protocol::HTTP::URL
  def self.assign(keys, value, parent); end
  def self.decode(string, maximum = nil, symbolize_keys: nil); end
  def self.encode(value, prefix = nil); end
  def self.escape(string, encoding = nil); end
  def self.escape_path(path); end
  def self.scan(string); end
  def self.split(name); end
  def self.unescape(string, encoding = nil); end
end
class Protocol::HTTP::Cookie
  def directives; end
  def encoded_name; end
  def encoded_value; end
  def initialize(name, value, directives); end
  def name; end
  def self.parse(string); end
  def self.parse_directives(strings); end
  def to_s; end
  def value; end
end
class Protocol::HTTP::Header::Cookie < Protocol::HTTP::Header::Multiple
  def to_h; end
end
class Protocol::HTTP::Header::SetCookie < Protocol::HTTP::Header::Cookie
end
class Protocol::HTTP::Header::Connection < Protocol::HTTP::Header::Split
  def <<(value); end
  def close?; end
  def initialize(value); end
  def keep_alive?; end
  def upgrade?; end
end
class Protocol::HTTP::Header::CacheControl < Protocol::HTTP::Header::Split
  def <<(value); end
  def dynamic?; end
  def initialize(value); end
  def max_age; end
  def no_cache?; end
  def no_store?; end
  def private?; end
  def public?; end
  def static?; end
  def streaming?; end
end
class Protocol::HTTP::Header::ETag < String
  def <<(value); end
  def weak?; end
end
class Protocol::HTTP::Header::ETags < Protocol::HTTP::Header::Split
  def match?(etag); end
  def wildcard?; end
end
class Protocol::HTTP::Header::Vary < Protocol::HTTP::Header::Split
  def <<(value); end
  def initialize(value); end
end
class Protocol::HTTP::Header::Authorization < String
  def credentials; end
  def self.basic(username, password); end
end
class Protocol::HTTP::Headers
  def ==(other); end
  def [](key); end
  def []=(key, value); end
  def add(key, value); end
  def clear; end
  def delete(key); end
  def each(&block); end
  def empty?; end
  def extract(keys); end
  def fields; end
  def flatten!; end
  def flatten; end
  def freeze; end
  def include?(key); end
  def initialize(fields = nil, indexed = nil); end
  def initialize_dup(other); end
  def inspect; end
  def keys; end
  def merge!(headers); end
  def merge(headers); end
  def merge_into(hash, key, value); end
  def self.[](headers); end
  def set(key, value); end
  def to_h; end
  def trailer!(&block); end
  def trailer(&block); end
  def trailer?; end
end
class Protocol::HTTP::Headers::Merged
  def <<(headers); end
  def clear; end
  def each(&block); end
  def initialize(*all); end
  include Enumerable
end
class Protocol::HTTP::Error < StandardError
end
class Protocol::HTTP::Body::Head < Protocol::HTTP::Body::Readable
  def empty?; end
  def initialize(length); end
  def length; end
  def ready?; end
  def self.for(body); end
end
class Protocol::HTTP::Body::Buffered < Protocol::HTTP::Body::Readable
  def chunks; end
  def empty?; end
  def finish; end
  def initialize(chunks = nil, length = nil); end
  def inspect; end
  def length; end
  def read; end
  def ready?; end
  def rewind; end
  def self.for(body); end
  def self.wrap(body); end
  def write(chunk); end
end
module Protocol::HTTP::Body::Reader
  def body?; end
  def close(error = nil); end
  def each(&block); end
  def finish; end
  def read; end
  def save(path, mode = nil, *args); end
end
class Protocol::HTTP::Request
  def authority; end
  def authority=(arg0); end
  def body; end
  def body=(arg0); end
  def call(connection); end
  def connect?; end
  def head?; end
  def headers; end
  def headers=(arg0); end
  def idempotent?; end
  def initialize(scheme = nil, authority = nil, method = nil, path = nil, version = nil, headers = nil, body = nil, protocol = nil); end
  def method; end
  def method=(arg0); end
  def path; end
  def path=(arg0); end
  def protocol; end
  def protocol=(arg0); end
  def scheme; end
  def scheme=(arg0); end
  def self.[](method, path, headers, body); end
  def to_s; end
  def version; end
  def version=(arg0); end
end
class Protocol::HTTP::Response
  def bad_request?; end
  def body; end
  def body=(arg0); end
  def continue?; end
  def failure?; end
  def headers; end
  def headers=(arg0); end
  def hijack?; end
  def initialize(version = nil, status = nil, headers = nil, body = nil, protocol = nil); end
  def not_modified?; end
  def partial?; end
  def preserve_method?; end
  def protocol; end
  def protocol=(arg0); end
  def redirection?; end
  def self.[](status, headers = nil, body = nil, protocol = nil); end
  def self.for_exception(exception); end
  def server_failure?; end
  def status; end
  def status=(arg0); end
  def success?; end
  def to_ary; end
  def to_s; end
  def version; end
  def version=(arg0); end
end
