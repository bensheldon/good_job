# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `rack` gem.
# Please instead update this file by running `bin/tapioca gem rack`.

# The Rack main module, serving as a namespace for all core Rack
# modules and classes.
#
# All modules meant for use in your application are <tt>autoload</tt>ed here,
# so it should be enough just to <tt>require 'rack'</tt> in your code.
module Rack
  class << self
    # Return the Rack release as a dotted string.
    def release; end

    # Return the Rack protocol version as a dotted string.
    def version; end
  end
end

module Rack::Auth; end

# Rack::Auth::AbstractHandler implements common authentication functionality.
#
# +realm+ should be set for all handlers.
class Rack::Auth::AbstractHandler
  # @return [AbstractHandler] a new instance of AbstractHandler
  def initialize(app, realm = T.unsafe(nil), &authenticator); end

  # Returns the value of attribute realm.
  def realm; end

  # Sets the attribute realm
  #
  # @param value the value to set the attribute realm to.
  def realm=(_arg0); end

  private

  def bad_request; end
  def unauthorized(www_authenticate = T.unsafe(nil)); end
end

class Rack::Auth::AbstractRequest
  # @return [AbstractRequest] a new instance of AbstractRequest
  def initialize(env); end

  def params; end
  def parts; end

  # @return [Boolean]
  def provided?; end

  def request; end
  def scheme; end

  # @return [Boolean]
  def valid?; end

  private

  def authorization_key; end
end

Rack::Auth::AbstractRequest::AUTHORIZATION_KEYS = T.let(T.unsafe(nil), Array)

# Rack::Auth::Basic implements HTTP Basic Authentication, as per RFC 2617.
#
# Initialize with the Rack application that you want protecting,
# and a block that checks if a username and password pair are valid.
#
# See also: <tt>example/protectedlobster.rb</tt>
class Rack::Auth::Basic < ::Rack::Auth::AbstractHandler
  def call(env); end

  private

  def challenge; end

  # @return [Boolean]
  def valid?(auth); end
end

class Rack::Auth::Basic::Request < ::Rack::Auth::AbstractRequest
  # @return [Boolean]
  def basic?; end

  def credentials; end
  def username; end
end

module Rack::Auth::Digest; end

# Rack::Auth::Digest::MD5 implements the MD5 algorithm version of
# HTTP Digest Authentication, as per RFC 2617.
#
# Initialize with the [Rack] application that you want protecting,
# and a block that looks up a plaintext password for a given username.
#
# +opaque+ needs to be set to a constant base64/hexadecimal string.
class Rack::Auth::Digest::MD5 < ::Rack::Auth::AbstractHandler
  # @return [MD5] a new instance of MD5
  def initialize(app, realm = T.unsafe(nil), opaque = T.unsafe(nil), &authenticator); end

  def call(env); end

  # Returns the value of attribute opaque.
  def opaque; end

  # Sets the attribute opaque
  #
  # @param value the value to set the attribute opaque to.
  def opaque=(_arg0); end

  # Sets the attribute passwords_hashed
  #
  # @param value the value to set the attribute passwords_hashed to.
  def passwords_hashed=(_arg0); end

  # @return [Boolean]
  def passwords_hashed?; end

  private

  def A1(auth, password); end
  def A2(auth); end
  def H(data); end
  def KD(secret, data); end
  def challenge(hash = T.unsafe(nil)); end
  def digest(auth, password); end
  def md5(data); end
  def params(hash = T.unsafe(nil)); end

  # @return [Boolean]
  def valid?(auth); end

  # @return [Boolean]
  def valid_digest?(auth); end

  # @return [Boolean]
  def valid_nonce?(auth); end

  # @return [Boolean]
  def valid_opaque?(auth); end

  # @return [Boolean]
  def valid_qop?(auth); end
end

Rack::Auth::Digest::MD5::QOP = T.let(T.unsafe(nil), String)

# Rack::Auth::Digest::Nonce is the default nonce generator for the
# Rack::Auth::Digest::MD5 authentication handler.
#
# +private_key+ needs to set to a constant string.
#
# +time_limit+ can be optionally set to an integer (number of seconds),
# to limit the validity of the generated nonces.
class Rack::Auth::Digest::Nonce
  # @return [Nonce] a new instance of Nonce
  def initialize(timestamp = T.unsafe(nil), given_digest = T.unsafe(nil)); end

  def digest; end

  # @return [Boolean]
  def fresh?; end

  # @return [Boolean]
  def stale?; end

  def to_s; end

  # @return [Boolean]
  def valid?; end

  class << self
    def parse(string); end

    # Returns the value of attribute private_key.
    def private_key; end

    # Sets the attribute private_key
    #
    # @param value the value to set the attribute private_key to.
    def private_key=(_arg0); end

    # Returns the value of attribute time_limit.
    def time_limit; end

    # Sets the attribute time_limit
    #
    # @param value the value to set the attribute time_limit to.
    def time_limit=(_arg0); end
  end
end

class Rack::Auth::Digest::Params < ::Hash
  # @return [Params] a new instance of Params
  # @yield [_self]
  # @yieldparam _self [Rack::Auth::Digest::Params] the object that the method was called on
  def initialize; end

  def [](k); end
  def []=(k, v); end

  # From WEBrick::HTTPUtils
  def quote(str); end

  def to_s; end

  class << self
    # From WEBrick::HTTPUtils
    def dequote(str); end

    def parse(str); end
    def split_header_value(str); end
  end
end

Rack::Auth::Digest::Params::UNQUOTED = T.let(T.unsafe(nil), Array)

class Rack::Auth::Digest::Request < ::Rack::Auth::AbstractRequest
  # @return [Boolean]
  def correct_uri?; end

  # @return [Boolean]
  def digest?; end

  def method; end

  # @raise [ArgumentError]
  def method_missing(sym, *args); end

  def nonce; end
  def params; end

  # @return [Boolean]
  def respond_to?(sym, *_arg1); end
end

# Proxy for response bodies allowing calling a block when
# the response body is closed (after the response has been fully
# sent to the client).
class Rack::BodyProxy
  # Set the response body to wrap, and the block to call when the
  # response has been fully sent.
  #
  # @return [BodyProxy] a new instance of BodyProxy
  def initialize(body, &block); end

  # If not already closed, close the wrapped body and
  # then call the block the proxy was initialized with.
  def close; end

  # Whether the proxy is closed.  The proxy starts as not closed,
  # and becomes closed on the first call to close.
  #
  # @return [Boolean]
  def closed?; end

  # Delegate missing methods to the wrapped body.
  def method_missing(method_name, *args, &block); end

  private

  # Return whether the wrapped body responds to the method.
  #
  # @return [Boolean]
  def respond_to_missing?(method_name, include_all = T.unsafe(nil)); end
end

# Rack::Builder implements a small DSL to iteratively construct Rack
# applications.
#
# Example:
#
#  require 'rack/lobster'
#  app = Rack::Builder.new do
#    use Rack::CommonLogger
#    use Rack::ShowExceptions
#    map "/lobster" do
#      use Rack::Lint
#      run Rack::Lobster.new
#    end
#  end
#
#  run app
#
# Or
#
#  app = Rack::Builder.app do
#    use Rack::CommonLogger
#    run lambda { |env| [200, {'Content-Type' => 'text/plain'}, ['OK']] }
#  end
#
#  run app
#
# +use+ adds middleware to the stack, +run+ dispatches to an application.
# You can use +map+ to construct a Rack::URLMap in a convenient way.
class Rack::Builder
  # Initialize a new Rack::Builder instance.  +default_app+ specifies the
  # default application if +run+ is not called later.  If a block
  # is given, it is evaluted in the context of the instance.
  #
  # @return [Builder] a new instance of Builder
  def initialize(default_app = T.unsafe(nil), &block); end

  # Call the Rack application generated by this builder instance. Note that
  # this rebuilds the Rack application and runs the warmup code (if any)
  # every time it is called, so it should not be used if performance is important.
  def call(env); end

  # Freeze the app (set using run) and all middleware instances when building the application
  # in to_app.
  def freeze_app; end

  # Creates a route within the application.  Routes under the mapped path will be sent to
  # the Rack application specified by run inside the block.  Other requests will be sent to the
  # default application specified by run outside the block.
  #
  #   Rack::Builder.app do
  #     map '/heartbeat' do
  #       run Heartbeat
  #     end
  #     run App
  #   end
  #
  # The +use+ method can also be used inside the block to specify middleware to run under a specific path:
  #
  #   Rack::Builder.app do
  #     map '/heartbeat' do
  #       use Middleware
  #       run Heartbeat
  #     end
  #     run App
  #   end
  #
  # This example includes a piece of middleware which will run before +/heartbeat+ requests hit +Heartbeat+.
  #
  # Note that providing a +path+ of +/+ will ignore any default application given in a +run+ statement
  # outside the block.
  def map(path, &block); end

  # Takes an argument that is an object that responds to #call and returns a Rack response.
  # The simplest form of this is a lambda object:
  #
  #   run lambda { |env| [200, { "Content-Type" => "text/plain" }, ["OK"]] }
  #
  # However this could also be a class:
  #
  #   class Heartbeat
  #     def self.call(env)
  #      [200, { "Content-Type" => "text/plain" }, ["OK"]]
  #     end
  #   end
  #
  #   run Heartbeat
  def run(app); end

  # Return the Rack application generated by this instance.
  def to_app; end

  # Specifies middleware to use in a stack.
  #
  #   class Middleware
  #     def initialize(app)
  #       @app = app
  #     end
  #
  #     def call(env)
  #       env["rack.some_header"] = "setting an example"
  #       @app.call(env)
  #     end
  #   end
  #
  #   use Middleware
  #   run lambda { |env| [200, { "Content-Type" => "text/plain" }, ["OK"]] }
  #
  # All requests through to this application will first be processed by the middleware class.
  # The +call+ method in this example sets an additional environment key which then can be
  # referenced in the application if required.
  def use(middleware, *args, &block); end

  # Takes a lambda or block that is used to warm-up the application. This block is called
  # before the Rack application is returned by to_app.
  #
  #   warmup do |app|
  #     client = Rack::MockRequest.new(app)
  #     client.get('/')
  #   end
  #
  #   use SomeMiddleware
  #   run MyApp
  def warmup(prc = T.unsafe(nil), &block); end

  private

  # Generate a URLMap instance by generating new Rack applications for each
  # map block in this instance.
  def generate_map(default_app, mapping); end

  class << self
    # Create a new Rack::Builder instance and return the Rack application
    # generated from it.
    def app(default_app = T.unsafe(nil), &block); end

    # Load the given file as a rackup file, treating the
    # contents as if specified inside a Rack::Builder block.
    #
    # Treats the first comment at the beginning of a line
    # that starts with a backslash as options similar to
    # options passed on a rackup command line.
    #
    # Ignores content in the file after +__END__+, so that
    # use of +__END__+ will not result in a syntax error.
    #
    # Example config.ru file:
    #
    #   $ cat config.ru
    #
    #   #\ -p 9393
    #
    #   use Rack::ContentLength
    #   require './app.rb'
    #   run App
    def load_file(path, opts = T.unsafe(nil)); end

    # Evaluate the given +builder_script+ string in the context of
    # a Rack::Builder block, returning a Rack application.
    def new_from_string(builder_script, file = T.unsafe(nil)); end

    # Parse the given config file to get a Rack application.
    #
    # If the config file ends in +.ru+, it is treated as a
    # rackup file and the contents will be treated as if
    # specified inside a Rack::Builder block, using the given
    # options.
    #
    # If the config file does not end in +.ru+, it is
    # required and Rack will use the basename of the file
    # to guess which constant will be the Rack application to run.
    # The options given will be ignored in this case.
    #
    # Examples:
    #
    #   Rack::Builder.parse_file('config.ru')
    #   # Rack application built using Rack::Builder.new
    #
    #   Rack::Builder.parse_file('app.rb')
    #   # requires app.rb, which can be anywhere in Ruby's
    #   # load path. After requiring, assumes App constant
    #   # contains Rack application
    #
    #   Rack::Builder.parse_file('./my_app.rb')
    #   # requires ./my_app.rb, which should be in the
    #   # process's current directory.  After requiring,
    #   # assumes MyApp constant contains Rack application
    def parse_file(config, opts = T.unsafe(nil)); end
  end
end

# https://stackoverflow.com/questions/2223882/whats-the-difference-between-utf-8-and-utf-8-without-bom
Rack::Builder::UTF_8_BOM = T.let(T.unsafe(nil), String)

Rack::CACHE_CONTROL = T.let(T.unsafe(nil), String)
Rack::CONTENT_LENGTH = T.let(T.unsafe(nil), String)
Rack::CONTENT_TYPE = T.let(T.unsafe(nil), String)

# Rack::Cascade tries a request on several apps, and returns the
# first response that is not 404 or 405 (or in a list of configured
# status codes).  If all applications tried return one of the configured
# status codes, return the last response.
class Rack::Cascade
  # Set the apps to send requests to, and what statuses result in
  # cascading.  Arguments:
  #
  # apps: An enumerable of rack applications.
  # cascade_for: The statuses to use cascading for.  If a response is received
  #              from an app, the next app is tried.
  #
  # @return [Cascade] a new instance of Cascade
  def initialize(apps, cascade_for = T.unsafe(nil)); end

  # Append an app to the list of apps to cascade.  This app will
  # be tried last.
  def <<(app); end

  # Append an app to the list of apps to cascade.  This app will
  # be tried last.
  def add(app); end

  # An array of applications to try in order.
  def apps; end

  # Call each app in order.  If the responses uses a status that requires
  # cascading, try the next app.  If all responses require cascading,
  # return the response from the last app.
  def call(env); end

  # Whether the given app is one of the apps to cascade to.
  #
  # @return [Boolean]
  def include?(app); end
end

# deprecated, no longer used
Rack::Cascade::NotFound = T.let(T.unsafe(nil), Array)

# Middleware that applies chunked transfer encoding to response bodies
# when the response does not include a Content-Length header.
#
# This supports the Trailer response header to allow the use of trailing
# headers in the chunked encoding.  However, using this requires you manually
# specify a response body that supports a +trailers+ method.  Example:
#
#   [200, { 'Trailer' => 'Expires'}, ["Hello", "World"]]
#   # error raised
#
#   body = ["Hello", "World"]
#   def body.trailers
#     { 'Expires' => Time.now.to_s }
#   end
#   [200, { 'Trailer' => 'Expires'}, body]
#   # No exception raised
class Rack::Chunked
  include ::Rack::Utils

  # @return [Chunked] a new instance of Chunked
  def initialize(app); end

  # If the rack app returns a response that should have a body,
  # but does not have Content-Length or Transfer-Encoding headers,
  # modify the response to use chunked Transfer-Encoding.
  def call(env); end

  # Whether the HTTP version supports chunked encoding (HTTP 1.1 does).
  #
  # @return [Boolean]
  def chunkable_version?(ver); end
end

# A body wrapper that emits chunked responses.
class Rack::Chunked::Body
  # Store the response body to be chunked.
  #
  # @return [Body] a new instance of Body
  def initialize(body); end

  # Close the response body if the response body supports it.
  def close; end

  # For each element yielded by the response body, yield
  # the element in chunked encoding.
  #
  # @yield [TAIL]
  def each(&block); end

  private

  # Do nothing as this class does not support trailer headers.
  def yield_trailers; end
end

Rack::Chunked::Body::TAIL = T.let(T.unsafe(nil), String)
Rack::Chunked::Body::TERM = T.let(T.unsafe(nil), String)

# A body wrapper that emits chunked responses and also supports
# sending Trailer headers.  Note that the response body provided to
# initialize must have a +trailers+ method that returns a hash
# of trailer headers, and the rack response itself should have a
# Trailer header listing the headers that the +trailers+ method
# will return.
class Rack::Chunked::TrailerBody < ::Rack::Chunked::Body
  private

  # Yield strings for each trailer header.
  def yield_trailers; end
end

# Rack::CommonLogger forwards every request to the given +app+, and
# logs a line in the
# {Apache common log format}[http://httpd.apache.org/docs/1.3/logs.html#common]
# to the configured logger.
class Rack::CommonLogger
  # +logger+ can be any object that supports the +write+ or +<<+ methods,
  # which includes the standard library Logger.  These methods are called
  # with a single string argument, the log message.
  # If +logger+ is nil, CommonLogger will fall back <tt>env['rack.errors']</tt>.
  #
  # @return [CommonLogger] a new instance of CommonLogger
  def initialize(app, logger = T.unsafe(nil)); end

  # Log all requests in common_log format after a response has been
  # returned.  Note that if the app raises an exception, the request
  # will not be logged, so if exception handling middleware are used,
  # they should be loaded after this middleware.  Additionally, because
  # the logging happens after the request body has been fully sent, any
  # exceptions raised during the sending of the response body will
  # cause the request not to be logged.
  def call(env); end

  private

  # Attempt to determine the content length for the response to
  # include it in the logged data.
  def extract_content_length(headers); end

  # Log the request to the configured logger.
  def log(env, status, header, began_at); end
end

# Common Log Format: http://httpd.apache.org/docs/1.3/logs.html#common
#
#   lilith.local - - [07/Aug/2006 23:58:02 -0400] "GET / HTTP/1.1" 500 -
#
#   %{%s - %s [%s] "%s %s%s %s" %d %s\n} %
#
# The actual format is slightly different than the above due to the
# separation of SCRIPT_NAME and PATH_INFO, and because the elapsed
# time in seconds is included at the end.
Rack::CommonLogger::FORMAT = T.let(T.unsafe(nil), String)

# Middleware that enables conditional GET using If-None-Match and
# If-Modified-Since. The application should set either or both of the
# Last-Modified or Etag response headers according to RFC 2616. When
# either of the conditions is met, the response body is set to be zero
# length and the response status is set to 304 Not Modified.
#
# Applications that defer response body generation until the body's each
# message is received will avoid response body generation completely when
# a conditional GET matches.
#
# Adapted from Michael Klishin's Merb implementation:
# https://github.com/wycats/merb/blob/master/merb-core/lib/merb-core/rack/middleware/conditional_get.rb
class Rack::ConditionalGet
  # @return [ConditionalGet] a new instance of ConditionalGet
  def initialize(app); end

  # Return empty 304 response if the response has not been
  # modified since the last request.
  def call(env); end

  private

  # Whether the ETag response header matches the If-None-Match request header.
  # If so, the request has not been modified.
  #
  # @return [Boolean]
  def etag_matches?(none_match, headers); end

  # Return whether the response has not been modified since the
  # last request.
  #
  # @return [Boolean]
  def fresh?(env, headers); end

  # Whether the Last-Modified response header matches the If-Modified-Since
  # request header.  If so, the request has not been modified.
  #
  # @return [Boolean]
  def modified_since?(modified_since, headers); end

  # Return a Time object for the given string (which should be in RFC2822
  # format), or nil if the string cannot be parsed.
  def to_rfc2822(since); end
end

# Rack::Config modifies the environment using the block given during
# initialization.
#
# Example:
#     use Rack::Config do |env|
#       env['my-key'] = 'some-value'
#     end
class Rack::Config
  # @return [Config] a new instance of Config
  def initialize(app, &block); end

  def call(env); end
end

# Sets the Content-Length header on responses that do not specify
# a Content-Length or Transfer-Encoding header.  Note that this
# does not fix responses that have an invalid Content-Length
# header specified.
class Rack::ContentLength
  include ::Rack::Utils

  # @return [ContentLength] a new instance of ContentLength
  def initialize(app); end

  def call(env); end
end

# Sets the Content-Type header on responses which don't have one.
#
# Builder Usage:
#   use Rack::ContentType, "text/plain"
#
# When no content type argument is provided, "text/html" is the
# default.
class Rack::ContentType
  include ::Rack::Utils

  # @return [ContentType] a new instance of ContentType
  def initialize(app, content_type = T.unsafe(nil)); end

  def call(env); end
end

Rack::DELETE = T.let(T.unsafe(nil), String)

# This middleware enables content encoding of http responses,
# usually for purposes of compression.
#
# Currently supported encodings:
#
# * gzip
# * identity (no transformation)
#
# This middleware automatically detects when encoding is supported
# and allowed. For example no encoding is made when a cache
# directive of 'no-transform' is present, when the response status
# code is one that doesn't allow an entity body, or when the body
# is empty.
#
# Note that despite the name, Deflater does not support the +deflate+
# encoding.
class Rack::Deflater
  # Creates Rack::Deflater middleware. Options:
  #
  # :if :: a lambda enabling / disabling deflation based on returned boolean value
  #        (e.g <tt>use Rack::Deflater, :if => lambda { |*, body| sum=0; body.each { |i| sum += i.length }; sum > 512 }</tt>).
  #        However, be aware that calling `body.each` inside the block will break cases where `body.each` is not idempotent,
  #        such as when it is an +IO+ instance.
  # :include :: a list of content types that should be compressed. By default, all content types are compressed.
  # :sync :: determines if the stream is going to be flushed after every chunk.  Flushing after every chunk reduces
  #          latency for time-sensitive streaming applications, but hurts compression and throughput.
  #          Defaults to +true+.
  #
  # @return [Deflater] a new instance of Deflater
  def initialize(app, options = T.unsafe(nil)); end

  def call(env); end

  private

  # Whether the body should be compressed.
  #
  # @return [Boolean]
  def should_deflate?(env, status, headers, body); end
end

# Body class used for gzip encoded responses.
class Rack::Deflater::GzipStream
  # Initialize the gzip stream.  Arguments:
  # body :: Response body to compress with gzip
  # mtime :: The modification time of the body, used to set the
  #          modification time in the gzip header.
  # sync :: Whether to flush each gzip chunk as soon as it is ready.
  #
  # @return [GzipStream] a new instance of GzipStream
  def initialize(body, mtime, sync); end

  # Close the original body if possible.
  def close; end

  # Yield gzip compressed strings to the given block.
  def each(&block); end

  # Call the block passed to #each with the the gzipped data.
  def write(data); end
end

# Rack::Directory serves entries below the +root+ given, according to the
# path info of the Rack request. If a directory is found, the file's contents
# will be presented in an html based index. If a file is found, the env will
# be passed to the specified +app+.
#
# If +app+ is not specified, a Rack::Files of the same +root+ will be used.
class Rack::Directory
  # Set the root directory and application for serving files.
  #
  # @return [Directory] a new instance of Directory
  def initialize(root, app = T.unsafe(nil)); end

  def call(env); end

  # Rack response to use for requests with invalid paths, or nil if path is valid.
  def check_bad_request(path_info); end

  # Rack response to use for requests with paths outside the root, or nil if path is inside the root.
  def check_forbidden(path_info); end

  # Rack response to use for unreadable and non-file, non-directory entries.
  def entity_not_found(path_info); end

  # Provide human readable file sizes
  def filesize_format(int); end

  # Internals of request handling.  Similar to call but does
  # not remove body for HEAD requests.
  def get(env); end

  # Rack response to use for directories under the root.
  def list_directory(path_info, path, script_name); end

  # Rack response to use for files and directories under the root.
  # Unreadable and non-file, non-directory entries will get a 404 response.
  def list_path(env, path, path_info, script_name); end

  # The root of the directory hierarchy.  Only requests for files and
  # directories inside of the root directory are supported.
  def root; end

  # File::Stat for the given path, but return nil for missing/bad entries.
  def stat(path); end
end

Rack::Directory::DIR_FILE = T.let(T.unsafe(nil), String)
Rack::Directory::DIR_PAGE_FOOTER = T.let(T.unsafe(nil), String)
Rack::Directory::DIR_PAGE_HEADER = T.let(T.unsafe(nil), String)

# Body class for directory entries, showing an index page with links
# to each file.
class Rack::Directory::DirectoryBody < ::Struct
  # Yield strings for each part of the directory entry
  #
  # @yield [DIR_PAGE_HEADER % [ show_path, show_path ]]
  def each; end

  private

  # Escape each element in the array of html strings.
  def DIR_FILE_escape(htmls); end
end

# Stolen from Ramaze
Rack::Directory::FILESIZE_FORMAT = T.let(T.unsafe(nil), Array)

Rack::ETAG = T.let(T.unsafe(nil), String)

# Automatically sets the ETag header on all String bodies.
#
# The ETag header is skipped if ETag or Last-Modified headers are sent or if
# a sendfile body (body.responds_to :to_path) is given (since such cases
# should be handled by apache/nginx).
#
# On initialization, you can pass two parameters: a Cache-Control directive
# used when Etag is absent and a directive when it is present. The first
# defaults to nil, while the second defaults to "max-age=0, private, must-revalidate"
class Rack::ETag
  # @return [ETag] a new instance of ETag
  def initialize(app, no_cache_control = T.unsafe(nil), cache_control = T.unsafe(nil)); end

  def call(env); end

  private

  def digest_body(body); end

  # @return [Boolean]
  def etag_body?(body); end

  # @return [Boolean]
  def etag_status?(status); end

  # @return [Boolean]
  def skip_caching?(headers); end
end

Rack::ETag::DEFAULT_CACHE_CONTROL = T.let(T.unsafe(nil), String)
Rack::ETag::ETAG_STRING = T.let(T.unsafe(nil), String)
Rack::EXPIRES = T.let(T.unsafe(nil), String)

# This middleware provides hooks to certain places in the request /
# response lifecycle.  This is so that middleware that don't need to filter
# the response data can safely leave it alone and not have to send messages
# down the traditional "rack stack".
#
# The events are:
#
# * on_start(request, response)
#
#   This event is sent at the start of the request, before the next
#   middleware in the chain is called.  This method is called with a request
#   object, and a response object.  Right now, the response object is always
#   nil, but in the future it may actually be a real response object.
#
# * on_commit(request, response)
#
#   The response has been committed.  The application has returned, but the
#   response has not been sent to the webserver yet.  This method is always
#   called with a request object and the response object.  The response
#   object is constructed from the rack triple that the application returned.
#   Changes may still be made to the response object at this point.
#
# * on_send(request, response)
#
#   The webserver has started iterating over the response body and presumably
#   has started sending data over the wire. This method is always called with
#   a request object and the response object.  The response object is
#   constructed from the rack triple that the application returned.  Changes
#   SHOULD NOT be made to the response object as the webserver has already
#   started sending data.  Any mutations will likely result in an exception.
#
# * on_finish(request, response)
#
#   The webserver has closed the response, and all data has been written to
#   the response socket.  The request and response object should both be
#   read-only at this point.  The body MAY NOT be available on the response
#   object as it may have been flushed to the socket.
#
# * on_error(request, response, error)
#
#   An exception has occurred in the application or an `on_commit` event.
#   This method will get the request, the response (if available) and the
#   exception that was raised.
#
# ## Order
#
# `on_start` is called on the handlers in the order that they were passed to
# the constructor.  `on_commit`, on_send`, `on_finish`, and `on_error` are
# called in the reverse order.  `on_finish` handlers are called inside an
# `ensure` block, so they are guaranteed to be called even if something
# raises an exception.  If something raises an exception in a `on_finish`
# method, then nothing is guaranteed.
class Rack::Events
  # @return [Events] a new instance of Events
  def initialize(app, handlers); end

  def call(env); end

  private

  def make_request(env); end
  def make_response(status, headers, body); end
  def on_commit(request, response); end
  def on_error(request, response, e); end
  def on_finish(request, response); end
  def on_start(request, response); end
end

module Rack::Events::Abstract
  def on_commit(req, res); end
  def on_error(req, res, e); end
  def on_finish(req, res); end
  def on_send(req, res); end
  def on_start(req, res); end
end

class Rack::Events::BufferedResponse < ::Rack::Response::Raw
  # @return [BufferedResponse] a new instance of BufferedResponse
  def initialize(status, headers, body); end

  # Returns the value of attribute body.
  def body; end

  def to_a; end
end

class Rack::Events::EventedBodyProxy < ::Rack::BodyProxy
  # @return [EventedBodyProxy] a new instance of EventedBodyProxy
  def initialize(body, request, response, handlers, &block); end

  def each; end

  # Returns the value of attribute request.
  def request; end

  # Returns the value of attribute response.
  def response; end
end

Rack::File = Rack::Files

# Rack::Files serves files below the +root+ directory given, according to the
# path info of the Rack request.
# e.g. when Rack::Files.new("/etc") is used, you can access 'passwd' file
# as http://localhost:9292/passwd
#
# Handlers can detect if bodies are a Rack::Files, and use mechanisms
# like sendfile on the +path+.
class Rack::Files
  # @return [Files] a new instance of Files
  def initialize(root, headers = T.unsafe(nil), default_mime = T.unsafe(nil)); end

  def call(env); end
  def get(env); end

  # Returns the value of attribute root.
  def root; end

  def serving(request, path); end

  private

  def fail(status, body, headers = T.unsafe(nil)); end
  def filesize(path); end

  # The MIME type for the contents of the file located at @path
  def mime_type(path, default_mime); end

  class << self
    # @todo remove in 3.0
    def method_added(name); end
  end
end

Rack::Files::ALLOWED_VERBS = T.let(T.unsafe(nil), Array)
Rack::Files::ALLOW_HEADER = T.let(T.unsafe(nil), String)

class Rack::Files::BaseIterator
  # @return [BaseIterator] a new instance of BaseIterator
  def initialize(path, ranges, options); end

  def bytesize; end
  def close; end
  def each; end

  # Returns the value of attribute options.
  def options; end

  # Returns the value of attribute path.
  def path; end

  # Returns the value of attribute ranges.
  def ranges; end

  private

  def each_range_part(file, range); end

  # @return [Boolean]
  def multipart?; end

  def multipart_heading(range); end
end

class Rack::Files::Iterator < ::Rack::Files::BaseIterator
  def to_path; end
end

Rack::Files::MULTIPART_BOUNDARY = T.let(T.unsafe(nil), String)

# Rack::ForwardRequest gets caught by Rack::Recursive and redirects
# the current request to the app at +url+.
#
#   raise ForwardRequest.new("/not-found")
class Rack::ForwardRequest < ::Exception
  # @return [ForwardRequest] a new instance of ForwardRequest
  def initialize(url, env = T.unsafe(nil)); end

  # Returns the value of attribute env.
  def env; end

  # Returns the value of attribute url.
  def url; end
end

# HTTP method verbs
Rack::GET = T.let(T.unsafe(nil), String)

Rack::HEAD = T.let(T.unsafe(nil), String)
Rack::HTTPS = T.let(T.unsafe(nil), String)
Rack::HTTP_COOKIE = T.let(T.unsafe(nil), String)
Rack::HTTP_HOST = T.let(T.unsafe(nil), String)
Rack::HTTP_PORT = T.let(T.unsafe(nil), String)
Rack::HTTP_VERSION = T.let(T.unsafe(nil), String)

# *Handlers* connect web servers with Rack.
#
# Rack includes Handlers for Thin, WEBrick, FastCGI, CGI, SCGI
# and LiteSpeed.
#
# Handlers usually are activated by calling <tt>MyHandler.run(myapp)</tt>.
# A second optional hash can be passed to include server-specific
# configuration.
module Rack::Handler
  class << self
    def default; end
    def get(server); end

    # Select first available Rack handler given an `Array` of server names.
    # Raises `LoadError` if no handler was found.
    #
    #   > pick ['thin', 'webrick']
    #   => Rack::Handler::WEBrick
    #
    # @raise [LoadError]
    def pick(server_names); end

    def register(server, klass); end

    # Transforms server-name constants to their canonical form as filenames,
    # then tries to require them but silences the LoadError if not found
    #
    # Naming convention:
    #
    #   Foo # => 'foo'
    #   FooBar # => 'foo_bar.rb'
    #   FooBAR # => 'foobar.rb'
    #   FOObar # => 'foobar.rb'
    #   FOOBAR # => 'foobar.rb'
    #   FooBarBaz # => 'foo_bar_baz.rb'
    def try_require(prefix, const_name); end
  end
end

class Rack::Handler::CGI
  class << self
    def run(app, **options); end
    def send_body(body); end
    def send_headers(status, headers); end
    def serve(app); end
  end
end

Rack::Handler::SERVER_NAMES = T.let(T.unsafe(nil), Array)

class Rack::Handler::WEBrick < ::WEBrick::HTTPServlet::AbstractServlet
  # @return [WEBrick] a new instance of WEBrick
  def initialize(server, app); end

  def service(req, res); end

  class << self
    # @yield [@server]
    def run(app, **options); end

    def shutdown; end
    def valid_options; end
  end
end

# Rack::Head returns an empty body for all HEAD requests. It leaves
# all other requests unchanged.
class Rack::Head
  # @return [Head] a new instance of Head
  def initialize(app); end

  def call(env); end
end

Rack::LINK = T.let(T.unsafe(nil), String)

# Rack::Lint validates your application and the requests and
# responses according to the Rack spec.
class Rack::Lint
  include ::Rack::Lint::Assertion

  # @return [Lint] a new instance of Lint
  def initialize(app); end

  def _call(env); end

  # A Rack application is a Ruby object (not a class) that
  # responds to +call+.
  def call(env = T.unsafe(nil)); end

  # === The Content-Length
  def check_content_length(status, headers); end

  # === The Content-Type
  def check_content_type(status, headers); end

  # == The Environment
  def check_env(env); end

  # === The Error Stream
  def check_error(error); end

  # === The Headers
  def check_headers(header); end

  # === Hijacking
  #
  # AUTHORS: n.b. The trailing whitespace between paragraphs is important and
  # should not be removed. The whitespace creates paragraphs in the RDoc
  # output.
  #
  # ==== Request (before status)
  def check_hijack(env); end

  # ==== Response (after headers)
  # It is also possible to hijack a response after the status and headers
  # have been sent.
  def check_hijack_response(headers, env); end

  # === The Input Stream
  #
  # The input stream is an IO-like object which contains the raw HTTP
  # POST data.
  def check_input(input); end

  # === The Status
  def check_status(status); end

  def close; end

  # === The Body
  def each; end

  def verify_content_length(bytes); end
end

module Rack::Lint::Assertion
  def assert(message); end
end

class Rack::Lint::ErrorWrapper
  include ::Rack::Lint::Assertion

  # @return [ErrorWrapper] a new instance of ErrorWrapper
  def initialize(error); end

  # * +close+ must never be called on the error stream.
  def close(*args); end

  # * +flush+ must be called without arguments and must be called
  #   in order to make the error appear for sure.
  def flush; end

  # * +puts+ must be called with a single argument that responds to +to_s+.
  def puts(str); end

  # * +write+ must be called with a single argument that is a String.
  def write(str); end
end

class Rack::Lint::HijackWrapper
  include ::Rack::Lint::Assertion
  extend ::Forwardable

  # @return [HijackWrapper] a new instance of HijackWrapper
  def initialize(io); end

  def close(*args, &block); end
  def close_read(*args, &block); end
  def close_write(*args, &block); end
  def closed?(*args, &block); end
  def flush(*args, &block); end
  def read(*args, &block); end
  def read_nonblock(*args, &block); end
  def write(*args, &block); end
  def write_nonblock(*args, &block); end
end

Rack::Lint::HijackWrapper::REQUIRED_METHODS = T.let(T.unsafe(nil), Array)

class Rack::Lint::InputWrapper
  include ::Rack::Lint::Assertion

  # @return [InputWrapper] a new instance of InputWrapper
  def initialize(input); end

  # * +close+ must never be called on the input stream.
  def close(*args); end

  # * +each+ must be called without arguments and only yield Strings.
  def each(*args); end

  # * +gets+ must be called without arguments and return a string,
  #   or +nil+ on EOF.
  def gets(*args); end

  # * +read+ behaves like IO#read.
  #   Its signature is <tt>read([length, [buffer]])</tt>.
  #
  #   If given, +length+ must be a non-negative Integer (>= 0) or +nil+,
  #   and +buffer+ must be a String and may not be nil.
  #
  #   If +length+ is given and not nil, then this method reads at most
  #   +length+ bytes from the input stream.
  #
  #   If +length+ is not given or nil, then this method reads
  #   all data until EOF.
  #
  #   When EOF is reached, this method returns nil if +length+ is given
  #   and not nil, or "" if +length+ is not given or is nil.
  #
  #   If +buffer+ is given, then the read data will be placed
  #   into +buffer+ instead of a newly created String object.
  def read(*args); end

  # * +rewind+ must be called without arguments. It rewinds the input
  #   stream back to the beginning. It must not raise Errno::ESPIPE:
  #   that is, it may not be a pipe or a socket. Therefore, handler
  #   developers must buffer the input data into some rewindable object
  #   if the underlying input stream is not rewindable.
  def rewind(*args); end
end

# :stopdoc:
class Rack::Lint::LintError < ::RuntimeError; end

# Rack::Lock locks every request inside a mutex, so that every request
# will effectively be executed synchronously.
class Rack::Lock
  # @return [Lock] a new instance of Lock
  def initialize(app, mutex = T.unsafe(nil)); end

  def call(env); end

  private

  def unlock; end
end

# Sets up rack.logger to write to rack.errors stream
class Rack::Logger
  # @return [Logger] a new instance of Logger
  def initialize(app, level = T.unsafe(nil)); end

  def call(env); end
end

# Rack::MediaType parse media type and parameters out of content_type string
class Rack::MediaType
  class << self
    # The media type parameters provided in CONTENT_TYPE as a Hash, or
    # an empty Hash if no CONTENT_TYPE or media-type parameters were
    # provided.  e.g., when the CONTENT_TYPE is "text/plain;charset=utf-8",
    # this method responds with the following Hash:
    #   { 'charset' => 'utf-8' }
    def params(content_type); end

    # The media type (type/subtype) portion of the CONTENT_TYPE header
    # without any media type parameters. e.g., when CONTENT_TYPE is
    # "text/plain;charset=utf-8", the media-type is "text/plain".
    #
    # For more information on the use of media types in HTTP, see:
    # http://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.7
    def type(content_type); end

    private

    def strip_doublequotes(str); end
  end
end

Rack::MediaType::SPLIT_PATTERN = T.let(T.unsafe(nil), Regexp)

class Rack::MethodOverride
  # @return [MethodOverride] a new instance of MethodOverride
  def initialize(app); end

  def call(env); end
  def method_override(env); end

  private

  def allowed_methods; end
  def method_override_param(req); end
end

Rack::MethodOverride::ALLOWED_METHODS = T.let(T.unsafe(nil), Array)
Rack::MethodOverride::HTTP_METHODS = T.let(T.unsafe(nil), Array)
Rack::MethodOverride::HTTP_METHOD_OVERRIDE_HEADER = T.let(T.unsafe(nil), String)
Rack::MethodOverride::METHOD_OVERRIDE_PARAM_KEY = T.let(T.unsafe(nil), String)

module Rack::Mime
  private

  # Returns true if the given value is a mime match for the given mime match
  # specification, false otherwise.
  #
  #    Rack::Mime.match?('text/html', 'text/*') => true
  #    Rack::Mime.match?('text/plain', '*') => true
  #    Rack::Mime.match?('text/html', 'application/json') => false
  #
  # @return [Boolean]
  def match?(value, matcher); end

  # Returns String with mime type if found, otherwise use +fallback+.
  # +ext+ should be filename extension in the '.ext' format that
  #       File.extname(file) returns.
  # +fallback+ may be any object
  #
  # Also see the documentation for MIME_TYPES
  #
  # Usage:
  #     Rack::Mime.mime_type('.foo')
  #
  # This is a shortcut for:
  #     Rack::Mime::MIME_TYPES.fetch('.foo', 'application/octet-stream')
  def mime_type(ext, fallback = T.unsafe(nil)); end

  class << self
    # Returns true if the given value is a mime match for the given mime match
    # specification, false otherwise.
    #
    #    Rack::Mime.match?('text/html', 'text/*') => true
    #    Rack::Mime.match?('text/plain', '*') => true
    #    Rack::Mime.match?('text/html', 'application/json') => false
    #
    # @return [Boolean]
    def match?(value, matcher); end

    # Returns String with mime type if found, otherwise use +fallback+.
    # +ext+ should be filename extension in the '.ext' format that
    #       File.extname(file) returns.
    # +fallback+ may be any object
    #
    # Also see the documentation for MIME_TYPES
    #
    # Usage:
    #     Rack::Mime.mime_type('.foo')
    #
    # This is a shortcut for:
    #     Rack::Mime::MIME_TYPES.fetch('.foo', 'application/octet-stream')
    def mime_type(ext, fallback = T.unsafe(nil)); end
  end
end

# List of most common mime-types, selected various sources
# according to their usefulness in a webserving scope for Ruby
# users.
#
# To amend this list with your local mime.types list you can use:
#
#     require 'webrick/httputils'
#     list = WEBrick::HTTPUtils.load_mime_types('/etc/mime.types')
#     Rack::Mime::MIME_TYPES.merge!(list)
#
# N.B. On Ubuntu the mime.types file does not include the leading period, so
# users may need to modify the data before merging into the hash.
Rack::Mime::MIME_TYPES = T.let(T.unsafe(nil), Hash)

# Rack::MockRequest helps testing your Rack application without
# actually using HTTP.
#
# After performing a request on a URL with get/post/put/patch/delete, it
# returns a MockResponse with useful helper methods for effective
# testing.
#
# You can pass a hash with additional configuration to the
# get/post/put/patch/delete.
# <tt>:input</tt>:: A String or IO-like to be used as rack.input.
# <tt>:fatal</tt>:: Raise a FatalWarning if the app writes to rack.errors.
# <tt>:lint</tt>:: If true, wrap the application in a Rack::Lint.
class Rack::MockRequest
  # @return [MockRequest] a new instance of MockRequest
  def initialize(app); end

  # Make a DELETE request and return a MockResponse. See #request.
  def delete(uri, opts = T.unsafe(nil)); end

  # Make a GET request and return a MockResponse. See #request.
  def get(uri, opts = T.unsafe(nil)); end

  # Make a HEAD request and return a MockResponse. See #request.
  def head(uri, opts = T.unsafe(nil)); end

  # Make an OPTIONS request and return a MockResponse. See #request.
  def options(uri, opts = T.unsafe(nil)); end

  # Make a PATCH request and return a MockResponse. See #request.
  def patch(uri, opts = T.unsafe(nil)); end

  # Make a POST request and return a MockResponse. See #request.
  def post(uri, opts = T.unsafe(nil)); end

  # Make a PUT request and return a MockResponse. See #request.
  def put(uri, opts = T.unsafe(nil)); end

  # Make a request using the given request method for the given
  # uri to the rack application and return a MockResponse.
  # Options given are passed to MockRequest.env_for.
  def request(method = T.unsafe(nil), uri = T.unsafe(nil), opts = T.unsafe(nil)); end

  class << self
    # Return the Rack environment used for a request to +uri+.
    # All options that are strings are added to the returned environment.
    # Options:
    # :fatal :: Whether to raise an exception if request outputs to rack.errors
    # :input :: The rack.input to set
    # :method :: The HTTP request method to use
    # :params :: The params to use
    # :script_name :: The SCRIPT_NAME to set
    def env_for(uri = T.unsafe(nil), opts = T.unsafe(nil)); end

    # For historical reasons, we're pinning to RFC 2396.
    # URI::Parser = URI::RFC2396_Parser
    def parse_uri_rfc2396(uri); end
  end
end

Rack::MockRequest::DEFAULT_ENV = T.let(T.unsafe(nil), Hash)

class Rack::MockRequest::FatalWarner
  def flush; end

  # @raise [FatalWarning]
  def puts(warning); end

  def string; end

  # @raise [FatalWarning]
  def write(warning); end
end

class Rack::MockRequest::FatalWarning < ::RuntimeError; end

# Rack::MockResponse provides useful helpers for testing your apps.
# Usually, you don't create the MockResponse on your own, but use
# MockRequest.
class Rack::MockResponse < ::Rack::Response
  # @return [MockResponse] a new instance of MockResponse
  def initialize(status, headers, body, errors = T.unsafe(nil)); end

  def =~(other); end
  def body; end
  def cookie(name); end

  # Headers
  def cookies; end

  # @return [Boolean]
  def empty?; end

  # Errors
  def errors; end

  # Errors
  def errors=(_arg0); end

  def match(other); end

  # Headers
  def original_headers; end

  private

  def identify_cookie_attributes(cookie_filling); end
  def parse_cookies_from_header; end

  class << self
    def [](*_arg0); end
  end
end

# A multipart form data parser, adapted from IOWA.
#
# Usually, Rack::Request#POST takes care of calling this.
module Rack::Multipart
  class << self
    def build_multipart(params, first = T.unsafe(nil)); end
    def extract_multipart(req, params = T.unsafe(nil)); end
    def parse_multipart(env, params = T.unsafe(nil)); end
  end
end

Rack::Multipart::ATTRIBUTE = T.let(T.unsafe(nil), Regexp)

# Updated definitions from RFC 2231
Rack::Multipart::ATTRIBUTE_CHAR = T.let(T.unsafe(nil), Regexp)

Rack::Multipart::BROKEN_QUOTED = T.let(T.unsafe(nil), Regexp)
Rack::Multipart::BROKEN_UNQUOTED = T.let(T.unsafe(nil), Regexp)
Rack::Multipart::CONDISP = T.let(T.unsafe(nil), Regexp)
Rack::Multipart::DISPPARM = T.let(T.unsafe(nil), Regexp)
Rack::Multipart::EOL = T.let(T.unsafe(nil), String)
Rack::Multipart::EXTENDED_INITIAL_NAME = T.let(T.unsafe(nil), Regexp)
Rack::Multipart::EXTENDED_INITIAL_PARAMETER = T.let(T.unsafe(nil), Regexp)
Rack::Multipart::EXTENDED_INITIAL_VALUE = T.let(T.unsafe(nil), Regexp)
Rack::Multipart::EXTENDED_OTHER_NAME = T.let(T.unsafe(nil), Regexp)
Rack::Multipart::EXTENDED_OTHER_PARAMETER = T.let(T.unsafe(nil), Regexp)
Rack::Multipart::EXTENDED_OTHER_VALUE = T.let(T.unsafe(nil), Regexp)
Rack::Multipart::EXTENDED_PARAMETER = T.let(T.unsafe(nil), Regexp)

class Rack::Multipart::Generator
  # @return [Generator] a new instance of Generator
  def initialize(params, first = T.unsafe(nil)); end

  def dump; end

  private

  def content_for_other(file, name); end
  def content_for_tempfile(io, file, name); end
  def flattened_params; end

  # @return [Boolean]
  def multipart?; end
end

Rack::Multipart::MULTIPART = T.let(T.unsafe(nil), Regexp)
Rack::Multipart::MULTIPART_BOUNDARY = T.let(T.unsafe(nil), String)
Rack::Multipart::MULTIPART_CONTENT_DISPOSITION = T.let(T.unsafe(nil), Regexp)
Rack::Multipart::MULTIPART_CONTENT_ID = T.let(T.unsafe(nil), Regexp)
Rack::Multipart::MULTIPART_CONTENT_TYPE = T.let(T.unsafe(nil), Regexp)
class Rack::Multipart::MultipartPartLimitError < ::Errno::EMFILE; end

class Rack::Multipart::Parser
  # @return [Parser] a new instance of Parser
  def initialize(boundary, tempfile, bufsize, query_parser); end

  def on_read(content); end
  def result; end

  # Returns the value of attribute state.
  def state; end

  private

  def consume_boundary; end
  def full_boundary; end
  def get_filename(head); end
  def handle_consume_token; end
  def handle_empty_content!(content); end
  def handle_fast_forward; end
  def handle_mime_body; end
  def handle_mime_head; end
  def run_parser; end
  def tag_multipart_encoding(filename, content_type, name, body); end

  class << self
    def parse(io, content_length, content_type, tmpfile, bufsize, qp); end
    def parse_boundary(content_type); end
  end
end

Rack::Multipart::Parser::BOUNDARY_REGEX = T.let(T.unsafe(nil), Regexp)
Rack::Multipart::Parser::BUFSIZE = T.let(T.unsafe(nil), Integer)

class Rack::Multipart::Parser::BoundedIO
  # @return [BoundedIO] a new instance of BoundedIO
  def initialize(io, content_length); end

  def read(size, outbuf = T.unsafe(nil)); end
  def rewind; end
end

Rack::Multipart::Parser::CHARSET = T.let(T.unsafe(nil), String)

class Rack::Multipart::Parser::Collector
  include ::Enumerable

  # @return [Collector] a new instance of Collector
  def initialize(tempfile); end

  def each; end
  def on_mime_body(mime_index, content); end
  def on_mime_finish(mime_index); end
  def on_mime_head(mime_index, head, filename, content_type, name); end

  private

  def check_open_files; end
end

class Rack::Multipart::Parser::Collector::BufferPart < ::Rack::Multipart::Parser::Collector::MimePart
  def close; end

  # @return [Boolean]
  def file?; end
end

class Rack::Multipart::Parser::Collector::MimePart < ::Struct
  # @yield [data]
  def get_data; end
end

class Rack::Multipart::Parser::Collector::TempfilePart < ::Rack::Multipart::Parser::Collector::MimePart
  def close; end

  # @return [Boolean]
  def file?; end
end

Rack::Multipart::Parser::EMPTY = T.let(T.unsafe(nil), Rack::Multipart::Parser::MultipartInfo)

class Rack::Multipart::Parser::MultipartInfo < ::Struct
  # Returns the value of attribute params
  #
  # @return [Object] the current value of params
  def params; end

  # Sets the attribute params
  #
  # @param value [Object] the value to set the attribute params to.
  # @return [Object] the newly set value
  def params=(_); end

  # Returns the value of attribute tmp_files
  #
  # @return [Object] the current value of tmp_files
  def tmp_files; end

  # Sets the attribute tmp_files
  #
  # @param value [Object] the value to set the attribute tmp_files to.
  # @return [Object] the newly set value
  def tmp_files=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def members; end
    def new(*_arg0); end
  end
end

Rack::Multipart::Parser::TEMPFILE_FACTORY = T.let(T.unsafe(nil), Proc)
Rack::Multipart::Parser::TEXT_PLAIN = T.let(T.unsafe(nil), String)
Rack::Multipart::REGULAR_PARAMETER = T.let(T.unsafe(nil), Regexp)
Rack::Multipart::REGULAR_PARAMETER_NAME = T.let(T.unsafe(nil), Regexp)
Rack::Multipart::RFC2183 = T.let(T.unsafe(nil), Regexp)
Rack::Multipart::SECTION = T.let(T.unsafe(nil), Regexp)
Rack::Multipart::TOKEN = T.let(T.unsafe(nil), Regexp)

class Rack::Multipart::UploadedFile
  # @return [UploadedFile] a new instance of UploadedFile
  def initialize(filepath = T.unsafe(nil), ct = T.unsafe(nil), bin = T.unsafe(nil), path: T.unsafe(nil), content_type: T.unsafe(nil), binary: T.unsafe(nil), filename: T.unsafe(nil), io: T.unsafe(nil)); end

  # The content type of the "uploaded" file
  def content_type; end

  # The content type of the "uploaded" file
  def content_type=(_arg0); end

  def local_path; end
  def method_missing(method_name, *args, &block); end

  # The filename, *not* including the path, of the "uploaded" file
  def original_filename; end

  def path; end

  # @return [Boolean]
  def respond_to?(*args); end
end

Rack::Multipart::VALUE = T.let(T.unsafe(nil), Regexp)

class Rack::NullLogger
  # @return [NullLogger] a new instance of NullLogger
  def initialize(app); end

  def <<(msg); end
  def add(severity, message = T.unsafe(nil), progname = T.unsafe(nil), &block); end
  def call(env); end
  def close; end
  def datetime_format; end
  def datetime_format=(datetime_format); end
  def debug(progname = T.unsafe(nil), &block); end

  # @return [Boolean]
  def debug?; end

  def error(progname = T.unsafe(nil), &block); end

  # @return [Boolean]
  def error?; end

  def fatal(progname = T.unsafe(nil), &block); end

  # @return [Boolean]
  def fatal?; end

  def formatter; end
  def formatter=(formatter); end
  def info(progname = T.unsafe(nil), &block); end

  # @return [Boolean]
  def info?; end

  def level; end
  def level=(level); end
  def progname; end
  def progname=(progname); end
  def sev_threshold; end
  def sev_threshold=(sev_threshold); end
  def unknown(progname = T.unsafe(nil), &block); end
  def warn(progname = T.unsafe(nil), &block); end

  # @return [Boolean]
  def warn?; end
end

Rack::OPTIONS = T.let(T.unsafe(nil), String)
Rack::PATCH = T.let(T.unsafe(nil), String)
Rack::PATH_INFO = T.let(T.unsafe(nil), String)
Rack::POST = T.let(T.unsafe(nil), String)
Rack::PUT = T.let(T.unsafe(nil), String)
Rack::QUERY_STRING = T.let(T.unsafe(nil), String)

class Rack::QueryParser
  # @return [QueryParser] a new instance of QueryParser
  def initialize(params_class, key_space_limit, param_depth_limit); end

  # Returns the value of attribute key_space_limit.
  def key_space_limit; end

  def make_params; end
  def new_depth_limit(param_depth_limit); end
  def new_space_limit(key_space_limit); end

  # normalize_params recursively expands parameters into structural types. If
  # the structural types represented by two different parameter names are in
  # conflict, a ParameterTypeError is raised.
  #
  # @raise [RangeError]
  def normalize_params(params, name, v, depth); end

  # Returns the value of attribute param_depth_limit.
  def param_depth_limit; end

  # parse_nested_query expands a query string into structural types. Supported
  # types are Arrays, Hashes and basic value types. It is possible to supply
  # query strings with parameters of conflicting types, in this case a
  # ParameterTypeError is raised. Users are encouraged to return a 400 in this
  # case.
  def parse_nested_query(qs, d = T.unsafe(nil)); end

  # Stolen from Mongrel, with some small modifications:
  # Parses a query string by breaking it up at the '&'
  # and ';' characters.  You can also use this to parse
  # cookies by changing the characters used in the second
  # parameter (which defaults to '&;').
  def parse_query(qs, d = T.unsafe(nil), &unescaper); end

  private

  # @return [Boolean]
  def params_hash_has_key?(hash, key); end

  # @return [Boolean]
  def params_hash_type?(obj); end

  def unescape(s); end

  class << self
    def make_default(key_space_limit, param_depth_limit); end
  end
end

Rack::QueryParser::COMMON_SEP = T.let(T.unsafe(nil), Hash)
Rack::QueryParser::DEFAULT_SEP = T.let(T.unsafe(nil), Regexp)

# InvalidParameterError is the error that is raised when incoming structural
# parameters (parsed by parse_nested_query) contain invalid format or byte
# sequence.
class Rack::QueryParser::InvalidParameterError < ::ArgumentError; end

# ParameterTypeError is the error that is raised when incoming structural
# parameters (parsed by parse_nested_query) contain conflicting types.
class Rack::QueryParser::ParameterTypeError < ::TypeError; end

class Rack::QueryParser::Params
  # @return [Params] a new instance of Params
  def initialize(limit); end

  def [](key); end

  # @raise [RangeError]
  def []=(key, value); end

  # @return [Boolean]
  def key?(key); end

  # Recursively unwraps nested `Params` objects and constructs an object
  # of the same shape, but using the objects' internal representations
  # (Ruby hashes) in place of the objects. The result is a hash consisting
  # purely of Ruby primitives.
  #
  #   Mutation warning!
  #
  #   1. This method mutates the internal representation of the `Params`
  #      objects in order to save object allocations.
  #
  #   2. The value you get back is a reference to the internal hash
  #      representation, not a copy.
  #
  #   3. Because the `Params` object's internal representation is mutable
  #      through the `#[]=` method, it is not thread safe. The result of
  #      getting the hash representation while another thread is adding a
  #      key to it is non-deterministic.
  def to_h; end

  # Recursively unwraps nested `Params` objects and constructs an object
  # of the same shape, but using the objects' internal representations
  # (Ruby hashes) in place of the objects. The result is a hash consisting
  # purely of Ruby primitives.
  #
  #   Mutation warning!
  #
  #   1. This method mutates the internal representation of the `Params`
  #      objects in order to save object allocations.
  #
  #   2. The value you get back is a reference to the internal hash
  #      representation, not a copy.
  #
  #   3. Because the `Params` object's internal representation is mutable
  #      through the `#[]=` method, it is not thread safe. The result of
  #      getting the hash representation while another thread is adding a
  #      key to it is non-deterministic.
  def to_params_hash; end
end

Rack::RACK_ERRORS = T.let(T.unsafe(nil), String)
Rack::RACK_HIJACK = T.let(T.unsafe(nil), String)
Rack::RACK_HIJACK_IO = T.let(T.unsafe(nil), String)
Rack::RACK_INPUT = T.let(T.unsafe(nil), String)
Rack::RACK_IS_HIJACK = T.let(T.unsafe(nil), String)
Rack::RACK_LOGGER = T.let(T.unsafe(nil), String)
Rack::RACK_METHODOVERRIDE_ORIGINAL_METHOD = T.let(T.unsafe(nil), String)
Rack::RACK_MULTIPART_BUFFER_SIZE = T.let(T.unsafe(nil), String)
Rack::RACK_MULTIPART_TEMPFILE_FACTORY = T.let(T.unsafe(nil), String)
Rack::RACK_MULTIPROCESS = T.let(T.unsafe(nil), String)
Rack::RACK_MULTITHREAD = T.let(T.unsafe(nil), String)
Rack::RACK_RECURSIVE_INCLUDE = T.let(T.unsafe(nil), String)
Rack::RACK_REQUEST_COOKIE_HASH = T.let(T.unsafe(nil), String)
Rack::RACK_REQUEST_COOKIE_STRING = T.let(T.unsafe(nil), String)
Rack::RACK_REQUEST_FORM_HASH = T.let(T.unsafe(nil), String)
Rack::RACK_REQUEST_FORM_INPUT = T.let(T.unsafe(nil), String)
Rack::RACK_REQUEST_FORM_VARS = T.let(T.unsafe(nil), String)
Rack::RACK_REQUEST_QUERY_HASH = T.let(T.unsafe(nil), String)
Rack::RACK_REQUEST_QUERY_STRING = T.let(T.unsafe(nil), String)
Rack::RACK_RUNONCE = T.let(T.unsafe(nil), String)
Rack::RACK_SESSION = T.let(T.unsafe(nil), String)
Rack::RACK_SESSION_OPTIONS = T.let(T.unsafe(nil), String)
Rack::RACK_SESSION_UNPACKED_COOKIE_DATA = T.let(T.unsafe(nil), String)
Rack::RACK_SHOWSTATUS_DETAIL = T.let(T.unsafe(nil), String)
Rack::RACK_TEMPFILES = T.let(T.unsafe(nil), String)
Rack::RACK_URL_SCHEME = T.let(T.unsafe(nil), String)

# Rack environment variables
Rack::RACK_VERSION = T.let(T.unsafe(nil), String)

Rack::RELEASE = T.let(T.unsafe(nil), String)
Rack::REQUEST_METHOD = T.let(T.unsafe(nil), String)
Rack::REQUEST_PATH = T.let(T.unsafe(nil), String)

# Rack::Recursive allows applications called down the chain to
# include data from other applications (by using
# <tt>rack['rack.recursive.include'][...]</tt> or raise a
# ForwardRequest to redirect internally.
class Rack::Recursive
  # @return [Recursive] a new instance of Recursive
  def initialize(app); end

  def _call(env); end
  def call(env); end
  def include(env, path); end
end

# High performant source reloader
#
# This class acts as Rack middleware.
#
# What makes it especially suited for use in a production environment is that
# any file will only be checked once and there will only be made one system
# call stat(2).
#
# Please note that this will not reload files in the background, it does so
# only when actively called.
#
# It is performing a check/reload cycle at the start of every request, but
# also respects a cool down time, during which nothing will be done.
class Rack::Reloader
  # @return [Reloader] a new instance of Reloader
  def initialize(app, cooldown = T.unsafe(nil), backend = T.unsafe(nil)); end

  def call(env); end
  def reload!(stderr = T.unsafe(nil)); end

  # A safe Kernel::load, issuing the hooks depending on the results
  def safe_load(file, mtime, stderr = T.unsafe(nil)); end
end

module Rack::Reloader::Stat
  # Takes a relative or absolute +file+ name, a couple possible +paths+ that
  # the +file+ might reside in. Returns the full path and File::Stat for the
  # path.
  def figure_path(file, paths); end

  def rotation; end
  def safe_stat(file); end
end

# Rack::Request provides a convenient interface to a Rack
# environment.  It is stateless, the environment +env+ passed to the
# constructor will be directly modified.
#
#   req = Rack::Request.new(env)
#   req.post?
#   req.params["data"]
class Rack::Request
  include ::Rack::Request::Env
  include ::Rack::Request::Helpers

  # @return [Request] a new instance of Request
  def initialize(env); end

  def delete_param(k); end
  def params; end
  def query; end
  def update_param(k, v); end
  def version_supplied; end
  def version_supplied=(_arg0); end
  def xhr?; end

  class << self
    # Returns the value of attribute ip_filter.
    def ip_filter; end

    # Sets the attribute ip_filter
    #
    # @param value the value to set the attribute ip_filter to.
    def ip_filter=(_arg0); end
  end
end

Rack::Request::ALLOWED_SCHEMES = T.let(T.unsafe(nil), Array)

module Rack::Request::Env
  def initialize(env); end

  # Add a header that may have multiple values.
  #
  # Example:
  #   request.add_header 'Accept', 'image/png'
  #   request.add_header 'Accept', '*/*'
  #
  #   assert_equal 'image/png,*/*', request.get_header('Accept')
  #
  # http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.2
  def add_header(key, v); end

  # Delete a request specific value for `name`.
  def delete_header(name); end

  # Loops through each key / value pair in the request specific data.
  def each_header(&block); end

  # The environment of the request.
  def env; end

  # If a block is given, it yields to the block if the value hasn't been set
  # on the request.
  def fetch_header(name, &block); end

  # Get a request specific value for `name`.
  def get_header(name); end

  # Predicate method to test to see if `name` has been set as request
  # specific data
  #
  # @return [Boolean]
  def has_header?(name); end

  # Set a request specific value for `name` to `v`
  def set_header(name, v); end

  private

  def initialize_copy(other); end
end

module Rack::Request::Helpers
  # Returns the data received in the query string.
  def GET; end

  # Returns the data received in the request body.
  #
  # This method support both application/x-www-form-urlencoded and
  # multipart/form-data.
  def POST; end

  # shortcut for <tt>request.params[key]</tt>
  def [](key); end

  # shortcut for <tt>request.params[key] = value</tt>
  #
  # Note that modifications will not be persisted in the env. Use update_param or delete_param if you want to destructively modify params.
  def []=(key, value); end

  def accept_encoding; end
  def accept_language; end

  # The authority of the incoming request as defined by RFC3976.
  # https://tools.ietf.org/html/rfc3986#section-3.2
  #
  # In HTTP/1, this is the `host` header.
  # In HTTP/2, this is the `:authority` pseudo-header.
  def authority; end

  def base_url; end
  def body; end

  # The character set of the request body if a "charset" media type
  # parameter was given, or nil if no "charset" was specified. Note
  # that, per RFC2616, text/* media types that specify no explicit
  # charset are to be considered ISO-8859-1.
  def content_charset; end

  def content_length; end
  def content_type; end
  def cookies; end

  # Checks the HTTP request method (or verb) to see if it was of type DELETE
  #
  # @return [Boolean]
  def delete?; end

  # Destructively delete a parameter, whether it's in GET or POST. Returns the value of the deleted parameter.
  #
  # If the parameter is in both GET and POST, the POST value takes precedence since that's how #params works.
  #
  # <tt>env['rack.input']</tt> is not touched.
  def delete_param(k); end

  # Determine whether the request body contains form-data by checking
  # the request Content-Type for one of the media-types:
  # "application/x-www-form-urlencoded" or "multipart/form-data". The
  # list of form-data media types can be modified through the
  # +FORM_DATA_MEDIA_TYPES+ array.
  #
  # A request body is also assumed to contain form-data when no
  # Content-Type header is provided and the request_method is POST.
  #
  # @return [Boolean]
  def form_data?; end

  def forwarded_authority; end
  def forwarded_for; end
  def forwarded_port; end
  def fullpath; end

  # Checks the HTTP request method (or verb) to see if it was of type GET
  #
  # @return [Boolean]
  def get?; end

  # Checks the HTTP request method (or verb) to see if it was of type HEAD
  #
  # @return [Boolean]
  def head?; end

  # Returns a formatted host, suitable for being used in a URI.
  def host; end

  # The `HTTP_HOST` header.
  def host_authority; end

  def host_with_port(authority = T.unsafe(nil)); end

  # Returns an address suitable for being to resolve to an address.
  # In the case of a domain name or IPv4 address, the result is the same
  # as +host+. In the case of IPv6 or future address formats, the square
  # brackets are removed.
  def hostname; end

  def ip; end

  # Checks the HTTP request method (or verb) to see if it was of type LINK
  #
  # @return [Boolean]
  def link?; end

  def logger; end

  # The media type (type/subtype) portion of the CONTENT_TYPE header
  # without any media type parameters. e.g., when CONTENT_TYPE is
  # "text/plain;charset=utf-8", the media-type is "text/plain".
  #
  # For more information on the use of media types in HTTP, see:
  # http://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.7
  def media_type; end

  # The media type parameters provided in CONTENT_TYPE as a Hash, or
  # an empty Hash if no CONTENT_TYPE or media-type parameters were
  # provided.  e.g., when the CONTENT_TYPE is "text/plain;charset=utf-8",
  # this method responds with the following Hash:
  #   { 'charset' => 'utf-8' }
  def media_type_params; end

  # @return [Boolean]
  def multithread?; end

  # Checks the HTTP request method (or verb) to see if it was of type OPTIONS
  #
  # @return [Boolean]
  def options?; end

  # The union of GET and POST data.
  #
  # Note that modifications will not be persisted in the env. Use update_param or delete_param if you want to destructively modify params.
  def params; end

  # Determine whether the request body contains data by checking
  # the request media_type against registered parse-data media-types
  #
  # @return [Boolean]
  def parseable_data?; end

  # Checks the HTTP request method (or verb) to see if it was of type PATCH
  #
  # @return [Boolean]
  def patch?; end

  def path; end
  def path_info; end
  def path_info=(s); end
  def port; end

  # Checks the HTTP request method (or verb) to see if it was of type POST
  #
  # @return [Boolean]
  def post?; end

  # Checks the HTTP request method (or verb) to see if it was of type PUT
  #
  # @return [Boolean]
  def put?; end

  def query_string; end

  # the referer of the client
  def referer; end

  # the referer of the client
  def referrer; end

  def request_method; end
  def scheme; end
  def script_name; end
  def script_name=(s); end

  # The authority as defined by the `SERVER_NAME` and `SERVER_PORT`
  # variables.
  def server_authority; end

  def server_name; end
  def server_port; end
  def session; end
  def session_options; end

  # @return [Boolean]
  def ssl?; end

  # Checks the HTTP request method (or verb) to see if it was of type TRACE
  #
  # @return [Boolean]
  def trace?; end

  # @return [Boolean]
  def trusted_proxy?(ip); end

  # Checks the HTTP request method (or verb) to see if it was of type UNLINK
  #
  # @return [Boolean]
  def unlink?; end

  # Destructively update a parameter, whether it's in GET and/or POST. Returns nil.
  #
  # The parameter is updated wherever it was previous defined, so GET, POST, or both. If it wasn't previously defined, it's inserted into GET.
  #
  # <tt>env['rack.input']</tt> is not touched.
  def update_param(k, v); end

  # Tries to return a remake of the original request URL as a string.
  def url; end

  def user_agent; end

  # like Hash#values_at
  def values_at(*keys); end

  # @return [Boolean]
  def xhr?; end

  private

  def allowed_scheme(header); end
  def default_session; end
  def extract_proto_header(header); end
  def forwarded_scheme; end
  def parse_http_accept_header(header); end
  def parse_multipart; end
  def parse_query(qs, d = T.unsafe(nil)); end
  def query_parser; end
  def reject_trusted_ip_addresses(ip_addresses); end
  def split_authority(authority); end
  def split_header(value); end

  # Assist with compatibility when processing `X-Forwarded-For`.
  def wrap_ipv6(host); end
end

Rack::Request::Helpers::AUTHORITY = T.let(T.unsafe(nil), Regexp)

# Default ports depending on scheme. Used to decide whether or not
# to include the port in a generated URI.
Rack::Request::Helpers::DEFAULT_PORTS = T.let(T.unsafe(nil), Hash)

# The set of form-data media-types. Requests that do not indicate
# one of the media types present in this list will not be eligible
# for form-data / param parsing.
Rack::Request::Helpers::FORM_DATA_MEDIA_TYPES = T.let(T.unsafe(nil), Array)

# The address of the client which connected to the proxy.
Rack::Request::Helpers::HTTP_X_FORWARDED_FOR = T.let(T.unsafe(nil), String)

# The contents of the host/:authority header sent to the proxy.
Rack::Request::Helpers::HTTP_X_FORWARDED_HOST = T.let(T.unsafe(nil), String)

# The port used to connect to the proxy.
Rack::Request::Helpers::HTTP_X_FORWARDED_PORT = T.let(T.unsafe(nil), String)

# The protocol used to connect to the proxy.
Rack::Request::Helpers::HTTP_X_FORWARDED_PROTO = T.let(T.unsafe(nil), String)

# The value of the scheme sent to the proxy.
Rack::Request::Helpers::HTTP_X_FORWARDED_SCHEME = T.let(T.unsafe(nil), String)

# Another way for specifing https scheme was used.
Rack::Request::Helpers::HTTP_X_FORWARDED_SSL = T.let(T.unsafe(nil), String)

# The set of media-types. Requests that do not indicate
# one of the media types present in this list will not be eligible
# for param parsing like soap attachments or generic multiparts
Rack::Request::Helpers::PARSEABLE_DATA_MEDIA_TYPES = T.let(T.unsafe(nil), Array)

Rack::Request::SCHEME_WHITELIST = T.let(T.unsafe(nil), Array)

# Rack::Response provides a convenient interface to create a Rack
# response.
#
# It allows setting of headers and cookies, and provides useful
# defaults (an OK response with empty headers and body).
#
# You can use Response#write to iteratively generate your response,
# but note that this is buffered by Rack::Response until you call
# +finish+.  +finish+ however can take a block inside which calls to
# +write+ are synchronous with the Rack response.
#
# Your application's +call+ should end returning Response#finish.
class Rack::Response
  include ::Rack::Response::Helpers

  # Initialize the response object with the specified body, status
  # and headers.
  #
  # HTTP protocol RFCs.
  # conform to the HTTP protocol RFCs.
  #
  # Providing a body which responds to #to_str is legacy behaviour.
  #
  # @param body [nil, #each, #to_str] the response body.
  # @param status [Integer] the integer status as defined by the
  # @param headers [#each] a list of key-value header pairs which
  # @return [Response] a new instance of Response
  # @yield [_self]
  # @yieldparam _self [Rack::Response] the object that the method was called on
  def initialize(body = T.unsafe(nil), status = T.unsafe(nil), headers = T.unsafe(nil)); end

  def [](key); end
  def []=(key, v); end

  # Returns the value of attribute body.
  def body; end

  # Sets the attribute body
  #
  # @param value the value to set the attribute body to.
  def body=(_arg0); end

  # @return [Boolean]
  def chunked?; end

  def close; end
  def delete_header(key); end
  def each(&callback); end

  # @return [Boolean]
  def empty?; end

  # Generate a response array consistent with the requirements of the SPEC.
  # which is suitable to be returned from the middleware `#call(env)` method.
  #
  # @return [Array] a 3-tuple suitable of `[status, headers, body]`
  def finish(&block); end

  def get_header(key); end

  # @return [Boolean]
  def has_header?(key); end

  # Returns the value of attribute headers.
  #
  # @deprecated Use {#headers} instead.
  def header; end

  # Returns the value of attribute headers.
  def headers; end

  # Returns the value of attribute length.
  def length; end

  # Sets the attribute length
  #
  # @param value the value to set the attribute length to.
  def length=(_arg0); end

  def redirect(target, status = T.unsafe(nil)); end
  def set_header(key, v); end

  # Returns the value of attribute status.
  def status; end

  # Sets the attribute status
  #
  # @param value the value to set the attribute status to.
  def status=(_arg0); end

  # Generate a response array consistent with the requirements of the SPEC.
  # which is suitable to be returned from the middleware `#call(env)` method.
  # For *response
  #
  # @return [Array] a 3-tuple suitable of `[status, headers, body]`
  def to_a(&block); end

  # Append to body and update Content-Length.
  #
  # NOTE: Do not mix #write and direct #body access!
  def write(chunk); end

  class << self
    def [](status, headers, body); end
  end
end

Rack::Response::CHUNKED = T.let(T.unsafe(nil), String)

module Rack::Response::Helpers
  # @return [Boolean]
  def accepted?; end

  # Add a header that may have multiple values.
  #
  # Example:
  #   response.add_header 'Vary', 'Accept-Encoding'
  #   response.add_header 'Vary', 'Cookie'
  #
  #   assert_equal 'Accept-Encoding,Cookie', response.get_header('Vary')
  #
  # http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.2
  def add_header(key, v); end

  # @return [Boolean]
  def bad_request?; end

  # Specify that the content should be cached.
  #
  # @option directive
  # @param duration [Integer] The number of seconds until the cache expires.
  # @param directive [Hash] a customizable set of options
  def cache!(duration = T.unsafe(nil), directive: T.unsafe(nil)); end

  def cache_control; end
  def cache_control=(v); end

  # @return [Boolean]
  def client_error?; end

  def content_length; end

  # Get the content type of the response.
  def content_type; end

  # Set the content type of the response.
  def content_type=(content_type); end

  # @return [Boolean]
  def created?; end

  def delete_cookie(key, value = T.unsafe(nil)); end

  # Specifies that the content shouldn't be cached. Overrides `cache!` if already called.
  def do_not_cache!; end

  def etag; end
  def etag=(v); end

  # @return [Boolean]
  def forbidden?; end

  # @return [Boolean]
  def include?(header); end

  # @return [Boolean]
  def informational?; end

  # @return [Boolean]
  def invalid?; end

  def location; end
  def location=(location); end
  def media_type; end
  def media_type_params; end

  # @return [Boolean]
  def method_not_allowed?; end

  # @return [Boolean]
  def moved_permanently?; end

  # @return [Boolean]
  def no_content?; end

  # @return [Boolean]
  def not_found?; end

  # @return [Boolean]
  def ok?; end

  # @return [Boolean]
  def precondition_failed?; end

  # @return [Boolean]
  def redirect?; end

  # @return [Boolean]
  def redirection?; end

  # @return [Boolean]
  def server_error?; end

  def set_cookie(key, value); end
  def set_cookie_header; end
  def set_cookie_header=(v); end

  # @return [Boolean]
  def successful?; end

  # @return [Boolean]
  def unauthorized?; end

  # @return [Boolean]
  def unprocessable?; end

  protected

  def append(chunk); end
  def buffered_body!; end
end

class Rack::Response::Raw
  include ::Rack::Response::Helpers

  # @return [Raw] a new instance of Raw
  def initialize(status, headers); end

  def delete_header(key); end
  def get_header(key); end

  # @return [Boolean]
  def has_header?(key); end

  # Returns the value of attribute headers.
  def headers; end

  def set_header(key, v); end

  # Returns the value of attribute status.
  def status; end

  # Sets the attribute status
  #
  # @param value the value to set the attribute status to.
  def status=(_arg0); end
end

Rack::Response::STATUS_WITH_NO_ENTITY_BODY = T.let(T.unsafe(nil), Hash)

# Class which can make any IO object rewindable, including non-rewindable ones. It does
# this by buffering the data into a tempfile, which is rewindable.
#
# rack.input is required to be rewindable, so if your input stream IO is non-rewindable
# by nature (e.g. a pipe or a socket) then you can wrap it in an object of this class
# to easily make it rewindable.
#
# Don't forget to call #close when you're done. This frees up temporary resources that
# RewindableInput uses, though it does *not* close the original IO object.
class Rack::RewindableInput
  # @return [RewindableInput] a new instance of RewindableInput
  def initialize(io); end

  # Closes this RewindableInput object without closing the originally
  # wrapped IO object. Cleans up any temporary resources that this RewindableInput
  # has created.
  #
  # This method may be called multiple times. It does nothing on subsequent calls.
  def close; end

  def each(&block); end
  def gets; end
  def read(*args); end
  def rewind; end

  private

  # @return [Boolean]
  def filesystem_has_posix_semantics?; end

  def make_rewindable; end
end

# Sets an "X-Runtime" response header, indicating the response
# time of the request, in seconds
#
# You can put it right before the application to see the processing
# time, or before all the other middlewares to include time for them,
# too.
class Rack::Runtime
  # @return [Runtime] a new instance of Runtime
  def initialize(app, name = T.unsafe(nil)); end

  def call(env); end
end

Rack::Runtime::FORMAT_STRING = T.let(T.unsafe(nil), String)
Rack::Runtime::HEADER_NAME = T.let(T.unsafe(nil), String)
Rack::SCRIPT_NAME = T.let(T.unsafe(nil), String)
Rack::SERVER_NAME = T.let(T.unsafe(nil), String)
Rack::SERVER_PORT = T.let(T.unsafe(nil), String)
Rack::SERVER_PROTOCOL = T.let(T.unsafe(nil), String)
Rack::SET_COOKIE = T.let(T.unsafe(nil), String)

# = Sendfile
#
# The Sendfile middleware intercepts responses whose body is being
# served from a file and replaces it with a server specific X-Sendfile
# header. The web server is then responsible for writing the file contents
# to the client. This can dramatically reduce the amount of work required
# by the Ruby backend and takes advantage of the web server's optimized file
# delivery code.
#
# In order to take advantage of this middleware, the response body must
# respond to +to_path+ and the request must include an X-Sendfile-Type
# header. Rack::Files and other components implement +to_path+ so there's
# rarely anything you need to do in your application. The X-Sendfile-Type
# header is typically set in your web servers configuration. The following
# sections attempt to document
#
# === Nginx
#
# Nginx supports the X-Accel-Redirect header. This is similar to X-Sendfile
# but requires parts of the filesystem to be mapped into a private URL
# hierarchy.
#
# The following example shows the Nginx configuration required to create
# a private "/files/" area, enable X-Accel-Redirect, and pass the special
# X-Sendfile-Type and X-Accel-Mapping headers to the backend:
#
#   location ~ /files/(.*) {
#     internal;
#     alias /var/www/$1;
#   }
#
#   location / {
#     proxy_redirect     off;
#
#     proxy_set_header   Host                $host;
#     proxy_set_header   X-Real-IP           $remote_addr;
#     proxy_set_header   X-Forwarded-For     $proxy_add_x_forwarded_for;
#
#     proxy_set_header   X-Sendfile-Type     X-Accel-Redirect;
#     proxy_set_header   X-Accel-Mapping     /var/www/=/files/;
#
#     proxy_pass         http://127.0.0.1:8080/;
#   }
#
# Note that the X-Sendfile-Type header must be set exactly as shown above.
# The X-Accel-Mapping header should specify the location on the file system,
# followed by an equals sign (=), followed name of the private URL pattern
# that it maps to. The middleware performs a simple substitution on the
# resulting path.
#
# See Also: https://www.nginx.com/resources/wiki/start/topics/examples/xsendfile
#
# === lighttpd
#
# Lighttpd has supported some variation of the X-Sendfile header for some
# time, although only recent version support X-Sendfile in a reverse proxy
# configuration.
#
#   $HTTP["host"] == "example.com" {
#      proxy-core.protocol = "http"
#      proxy-core.balancer = "round-robin"
#      proxy-core.backends = (
#        "127.0.0.1:8000",
#        "127.0.0.1:8001",
#        ...
#      )
#
#      proxy-core.allow-x-sendfile = "enable"
#      proxy-core.rewrite-request = (
#        "X-Sendfile-Type" => (".*" => "X-Sendfile")
#      )
#    }
#
# See Also: http://redmine.lighttpd.net/wiki/lighttpd/Docs:ModProxyCore
#
# === Apache
#
# X-Sendfile is supported under Apache 2.x using a separate module:
#
# https://tn123.org/mod_xsendfile/
#
# Once the module is compiled and installed, you can enable it using
# XSendFile config directive:
#
#   RequestHeader Set X-Sendfile-Type X-Sendfile
#   ProxyPassReverse / http://localhost:8001/
#   XSendFile on
#
# === Mapping parameter
#
# The third parameter allows for an overriding extension of the
# X-Accel-Mapping header. Mappings should be provided in tuples of internal to
# external. The internal values may contain regular expression syntax, they
# will be matched with case indifference.
class Rack::Sendfile
  # @return [Sendfile] a new instance of Sendfile
  def initialize(app, variation = T.unsafe(nil), mappings = T.unsafe(nil)); end

  def call(env); end

  private

  def map_accel_path(env, path); end
  def variation(env); end
end

class Rack::Server
  # Options may include:
  # * :app
  #     a rack application to run (overrides :config and :builder)
  # * :builder
  #     a string to evaluate a Rack::Builder from
  # * :config
  #     a rackup configuration file path to load (.ru)
  # * :environment
  #     this selects the middleware that will be wrapped around
  #     your application. Default options available are:
  #       - development: CommonLogger, ShowExceptions, and Lint
  #       - deployment: CommonLogger
  #       - none: no extra middleware
  #     note: when the server is a cgi server, CommonLogger is not included.
  # * :server
  #     choose a specific Rack::Handler, e.g. cgi, fcgi, webrick
  # * :daemonize
  #     if true, the server will daemonize itself (fork, detach, etc)
  # * :pid
  #     path to write a pid file after daemonize
  # * :Host
  #     the host address to bind to (used by supporting Rack::Handler)
  # * :Port
  #     the port to bind to (used by supporting Rack::Handler)
  # * :AccessLog
  #     webrick access log options (or supporting Rack::Handler)
  # * :debug
  #     turn on debug output ($DEBUG = true)
  # * :warn
  #     turn on warnings ($-w = true)
  # * :include
  #     add given paths to $LOAD_PATH
  # * :require
  #     require the given libraries
  #
  # Additional options for profiling app initialization include:
  # * :heapfile
  #     location for ObjectSpace.dump_all to write the output to
  # * :profile_file
  #     location for CPU/Memory (StackProf) profile output (defaults to a tempfile)
  # * :profile_mode
  #     StackProf profile mode (cpu|wall|object)
  #
  # @return [Server] a new instance of Server
  def initialize(options = T.unsafe(nil)); end

  def app; end
  def default_options; end
  def middleware; end
  def options; end

  # Sets the attribute options
  #
  # @param value the value to set the attribute options to.
  def options=(_arg0); end

  def server; end
  def start(&block); end

  private

  def build_app(app); end
  def build_app_and_options_from_config; end
  def build_app_from_string; end
  def check_pid!; end
  def daemonize_app; end
  def handle_profiling(heapfile, profile_mode, filename); end
  def make_profile_name(filename); end
  def opt_parser; end
  def parse_options(args); end
  def pidfile_process_status; end
  def wrapped_app; end
  def write_pid; end

  class << self
    def default_middleware_by_environment; end
    def logging_middleware; end
    def middleware; end

    # Start a new rack server (like running rackup). This will parse ARGV and
    # provide standard ARGV rackup options, defaulting to load 'config.ru'.
    #
    # Providing an options hash will prevent ARGV parsing and will not include
    # any default options.
    #
    # This method can be used to very easily launch a CGI application, for
    # example:
    #
    #  Rack::Server.start(
    #    :app => lambda do |e|
    #      [200, {'Content-Type' => 'text/html'}, ['hello world']]
    #    end,
    #    :server => 'cgi'
    #  )
    #
    # Further options available here are documented on Rack::Server#initialize
    def start(options = T.unsafe(nil)); end
  end
end

class Rack::Server::Options
  def handler_opts(options); end
  def parse!(args); end
end

module Rack::Session; end
module Rack::Session::Abstract; end

class Rack::Session::Abstract::ID < ::Rack::Session::Abstract::Persisted
  # All thread safety and session destroy procedures should occur here.
  # Should return a new session id or nil if options[:drop]
  def delete_session(req, sid, options); end

  # All thread safety and session retrieval procedures should occur here.
  # Should return [session_id, session].
  # If nil is provided as the session id, generation of a new valid id
  # should occur within.
  def find_session(req, sid); end

  # All thread safety and session storage procedures should occur here.
  # Must return the session id if the session was saved successfully, or
  # false if the session could not be saved.
  def write_session(req, sid, session, options); end

  class << self
    # @private
    def inherited(klass); end
  end
end

# ID sets up a basic framework for implementing an id based sessioning
# service. Cookies sent to the client for maintaining sessions will only
# contain an id reference. Only #find_session, #write_session and
# #delete_session are required to be overwritten.
#
# All parameters are optional.
# * :key determines the name of the cookie, by default it is
#   'rack.session'
# * :path, :domain, :expire_after, :secure, and :httponly set the related
#   cookie options as by Rack::Response#set_cookie
# * :skip will not a set a cookie in the response nor update the session state
# * :defer will not set a cookie in the response but still update the session
#   state if it is used with a backend
# * :renew (implementation dependent) will prompt the generation of a new
#   session id, and migration of data to be referenced at the new id. If
#   :defer is set, it will be overridden and the cookie will be set.
# * :sidbits sets the number of bits in length that a generated session
#   id will be.
#
# These options can be set on a per request basis, at the location of
# <tt>env['rack.session.options']</tt>. Additionally the id of the
# session can be found within the options hash at the key :id. It is
# highly not recommended to change its value.
#
# Is Rack::Utils::Context compatible.
#
# Not included by default; you must require 'rack/session/abstract/id'
# to use.
class Rack::Session::Abstract::Persisted
  # @return [Persisted] a new instance of Persisted
  def initialize(app, options = T.unsafe(nil)); end

  def call(env); end

  # Acquires the session from the environment and the session id from
  # the session options and passes them to #write_session. If successful
  # and the :defer option is not true, a cookie will be added to the
  # response with the session's id.
  def commit_session(req, res); end

  def context(env, app = T.unsafe(nil)); end

  # Returns the value of attribute default_options.
  def default_options; end

  # Returns the value of attribute key.
  def key; end

  # Returns the value of attribute sid_secure.
  def sid_secure; end

  private

  # Session should be committed if it was loaded, any of specific options like :renew, :drop
  # or :expire_after was given and the security permissions match. Skips if skip is given.
  #
  # @return [Boolean]
  def commit_session?(req, session, options); end

  def cookie_value(data); end

  # Returns the current session id from the SessionHash.
  def current_session_id(req); end

  # All thread safety and session destroy procedures should occur here.
  # Should return a new session id or nil if options[:drop]
  def delete_session(req, sid, options); end

  # Extract session id from request object.
  def extract_session_id(request); end

  # All thread safety and session retrieval procedures should occur here.
  # Should return [session_id, session].
  # If nil is provided as the session id, generation of a new valid id
  # should occur within.
  def find_session(env, sid); end

  # @return [Boolean]
  def force_options?(options); end

  # @return [Boolean]
  def forced_session_update?(session, options); end

  # Generate a new session id using Ruby #rand.  The size of the
  # session id is controlled by the :sidbits option.
  # Monkey patch this to use custom methods for session id generation.
  def generate_sid(secure = T.unsafe(nil)); end

  def initialize_sid; end

  # Extracts the session id from provided cookies and passes it and the
  # environment to #find_session.
  def load_session(req); end

  # @return [Boolean]
  def loaded_session?(session); end

  def make_request(env); end

  # Sets the lazy session at 'rack.session' and places options and session
  # metadata into 'rack.session.options'.
  def prepare_session(req); end

  # @return [Boolean]
  def security_matches?(request, options); end

  # Allow subclasses to prepare_session for different Session classes
  def session_class; end

  # Check if the session exists or not.
  #
  # @return [Boolean]
  def session_exists?(req); end

  # Sets the cookie back to the client with session id. We skip the cookie
  # setting if the value didn't change (sid is the same) or expires was given.
  def set_cookie(request, res, cookie); end

  # All thread safety and session storage procedures should occur here.
  # Must return the session id if the session was saved successfully, or
  # false if the session could not be saved.
  def write_session(req, sid, session, options); end
end

Rack::Session::Abstract::Persisted::DEFAULT_OPTIONS = T.let(T.unsafe(nil), Hash)

class Rack::Session::Abstract::PersistedSecure < ::Rack::Session::Abstract::Persisted
  def extract_session_id(*_arg0); end
  def generate_sid(*_arg0); end

  private

  def cookie_value(data); end
  def session_class; end
end

class Rack::Session::Abstract::PersistedSecure::SecureSessionHash < ::Rack::Session::Abstract::SessionHash
  def [](key); end
end

# SessionHash is responsible to lazily load the session from store.
class Rack::Session::Abstract::SessionHash
  include ::Enumerable

  # @return [SessionHash] a new instance of SessionHash
  def initialize(store, req); end

  def [](key); end
  def []=(key, value); end
  def clear; end
  def delete(key); end
  def destroy; end
  def dig(key, *keys); end
  def each(&block); end

  # @return [Boolean]
  def empty?; end

  # @return [Boolean]
  def exists?; end

  def fetch(key, default = T.unsafe(nil), &block); end

  # @return [Boolean]
  def has_key?(key); end

  def id; end

  # Sets the attribute id
  #
  # @param value the value to set the attribute id to.
  def id=(_arg0); end

  # @return [Boolean]
  def include?(key); end

  def inspect; end

  # @return [Boolean]
  def key?(key); end

  def keys; end

  # @return [Boolean]
  def loaded?; end

  def merge!(hash); end
  def options; end
  def replace(hash); end
  def store(key, value); end
  def to_hash; end
  def update(hash); end
  def values; end

  private

  def load!; end
  def load_for_read!; end
  def load_for_write!; end
  def stringify_keys(other); end

  class << self
    def find(req); end
    def set(req, session); end
    def set_options(req, options); end
  end
end

Rack::Session::Abstract::SessionHash::Unspecified = T.let(T.unsafe(nil), Object)

# Rack::Session::Cookie provides simple cookie based session management.
# By default, the session is a Ruby Hash stored as base64 encoded marshalled
# data set to :key (default: rack.session).  The object that encodes the
# session data is configurable and must respond to +encode+ and +decode+.
# Both methods must take a string and return a string.
#
# When the secret key is set, cookie data is checked for data integrity.
# The old secret key is also accepted and allows graceful secret rotation.
#
# Example:
#
#     use Rack::Session::Cookie, :key => 'rack.session',
#                                :domain => 'foo.com',
#                                :path => '/',
#                                :expire_after => 2592000,
#                                :secret => 'change_me',
#                                :old_secret => 'also_change_me'
#
#     All parameters are optional.
#
#
#   Rack::Session::Cookie.new(application, {
#     :coder => Rack::Session::Cookie::Identity.new
#   })
#
#
#   Rack::Session::Cookie.new(application, {
#     :coder => Class.new {
#       def encode(str); str.reverse; end
#       def decode(str); str.reverse; end
#     }.new
#   })
class Rack::Session::Cookie < ::Rack::Session::Abstract::PersistedSecure
  # @return [Cookie] a new instance of Cookie
  def initialize(app, options = T.unsafe(nil)); end

  # Returns the value of attribute coder.
  def coder; end

  private

  def delete_session(req, session_id, options); end

  # @return [Boolean]
  def digest_match?(data, digest); end

  def extract_session_id(request); end
  def find_session(req, sid); end
  def generate_hmac(data, secret); end
  def persistent_session_id!(data, sid = T.unsafe(nil)); end

  # @return [Boolean]
  def secure?(options); end

  def unpacked_cookie_data(request); end
  def write_session(req, session_id, session, options); end
end

# Encode session cookies as Base64
class Rack::Session::Cookie::Base64
  def decode(str); end
  def encode(str); end
end

# N.B. Unlike other encoding methods, the contained objects must be a
# valid JSON composite type, either a Hash or an Array.
class Rack::Session::Cookie::Base64::JSON < ::Rack::Session::Cookie::Base64
  def decode(str); end
  def encode(obj); end
end

# Encode session cookies as Marshaled Base64 data
class Rack::Session::Cookie::Base64::Marshal < ::Rack::Session::Cookie::Base64
  def decode(str); end
  def encode(str); end
end

class Rack::Session::Cookie::Base64::ZipJSON < ::Rack::Session::Cookie::Base64
  def decode(str); end
  def encode(obj); end
end

# Use no encoding for session cookies
class Rack::Session::Cookie::Identity
  def decode(str); end
  def encode(str); end
end

class Rack::Session::Cookie::SessionId
  # @return [SessionId] a new instance of SessionId
  def initialize(session_id, cookie_value); end

  # Returns the value of attribute cookie_value.
  def cookie_value; end
end

# Rack::Session::Pool provides simple cookie based session management.
# Session data is stored in a hash held by @pool.
# In the context of a multithreaded environment, sessions being
# committed to the pool is done in a merging manner.
#
# The :drop option is available in rack.session.options if you wish to
# explicitly remove the session from the session cache.
#
# Example:
#   myapp = MyRackApp.new
#   sessioned = Rack::Session::Pool.new(myapp,
#     :domain => 'foo.com',
#     :expire_after => 2592000
#   )
#   Rack::Handler::WEBrick.run sessioned
class Rack::Session::Pool < ::Rack::Session::Abstract::PersistedSecure
  # @return [Pool] a new instance of Pool
  def initialize(app, options = T.unsafe(nil)); end

  def delete_session(req, session_id, options); end
  def find_session(req, sid); end
  def generate_sid; end

  # Returns the value of attribute mutex.
  def mutex; end

  # Returns the value of attribute pool.
  def pool; end

  def with_lock(req); end
  def write_session(req, session_id, new_session, options); end

  private

  def get_session_with_fallback(sid); end
end

Rack::Session::Pool::DEFAULT_OPTIONS = T.let(T.unsafe(nil), Hash)

class Rack::Session::SessionId
  # @return [SessionId] a new instance of SessionId
  def initialize(public_id); end

  # Returns the value of attribute public_id.
  def cookie_value; end

  # @return [Boolean]
  def empty?; end

  def inspect; end
  def private_id; end

  # Returns the value of attribute public_id.
  def public_id; end

  # Returns the value of attribute public_id.
  def to_s; end

  private

  def hash_sid(sid); end
end

Rack::Session::SessionId::ID_VERSION = T.let(T.unsafe(nil), Integer)

# Rack::ShowExceptions catches all exceptions raised from the app it
# wraps.  It shows a useful backtrace with the sourcefile and
# clickable context, the whole Rack environment and the request
# data.
#
# Be careful when you use this on public-facing sites as it could
# reveal information helpful to attackers.
class Rack::ShowExceptions
  # @return [ShowExceptions] a new instance of ShowExceptions
  def initialize(app); end

  def call(env); end
  def dump_exception(exception); end
  def h(obj); end

  # @return [Boolean]
  def prefers_plaintext?(env); end

  def pretty(env, exception); end
  def template; end

  private

  # @return [Boolean]
  def accepts_html?(env); end
end

Rack::ShowExceptions::CONTEXT = T.let(T.unsafe(nil), Integer)
Rack::ShowExceptions::TEMPLATE = T.let(T.unsafe(nil), ERB)

# Rack::ShowStatus catches all empty responses and replaces them
# with a site explaining the error.
#
# Additional details can be put into <tt>rack.showstatus.detail</tt>
# and will be shown as HTML.  If such details exist, the error page
# is always rendered, even if the reply was not empty.
class Rack::ShowStatus
  # @return [ShowStatus] a new instance of ShowStatus
  def initialize(app); end

  def call(env); end
  def h(obj); end
end

Rack::ShowStatus::TEMPLATE = T.let(T.unsafe(nil), String)

# The Rack::Static middleware intercepts requests for static files
# (javascript files, images, stylesheets, etc) based on the url prefixes or
# route mappings passed in the options, and serves them using a Rack::Files
# object. This allows a Rack stack to serve both static and dynamic content.
#
# Examples:
#
# Serve all requests beginning with /media from the "media" folder located
# in the current directory (ie media/*):
#
#     use Rack::Static, :urls => ["/media"]
#
# Same as previous, but instead of returning 404 for missing files under
# /media, call the next middleware:
#
#     use Rack::Static, :urls => ["/media"], :cascade => true
#
# Serve all requests beginning with /css or /images from the folder "public"
# in the current directory (ie public/css/* and public/images/*):
#
#     use Rack::Static, :urls => ["/css", "/images"], :root => "public"
#
# Serve all requests to / with "index.html" from the folder "public" in the
# current directory (ie public/index.html):
#
#     use Rack::Static, :urls => {"/" => 'index.html'}, :root => 'public'
#
# Serve all requests normally from the folder "public" in the current
# directory but uses index.html as default route for "/"
#
#     use Rack::Static, :urls => [""], :root => 'public', :index =>
#     'index.html'
#
# Set custom HTTP Headers for based on rules:
#
#     use Rack::Static, :root => 'public',
#         :header_rules => [
#           [rule, {header_field => content, header_field => content}],
#           [rule, {header_field => content}]
#         ]
#
#  Rules for selecting files:
#
#  1) All files
#     Provide the :all symbol
#     :all => Matches every file
#
#  2) Folders
#     Provide the folder path as a string
#     '/folder' or '/folder/subfolder' => Matches files in a certain folder
#
#  3) File Extensions
#     Provide the file extensions as an array
#     ['css', 'js'] or %w(css js) => Matches files ending in .css or .js
#
#  4) Regular Expressions / Regexp
#     Provide a regular expression
#     %r{\.(?:css|js)\z} => Matches files ending in .css or .js
#     /\.(?:eot|ttf|otf|woff2|woff|svg)\z/ => Matches files ending in
#       the most common web font formats (.eot, .ttf, .otf, .woff2, .woff, .svg)
#       Note: This Regexp is available as a shortcut, using the :fonts rule
#
#  5) Font Shortcut
#     Provide the :fonts symbol
#     :fonts => Uses the Regexp rule stated right above to match all common web font endings
#
#  Rule Ordering:
#    Rules are applied in the order that they are provided.
#    List rather general rules above special ones.
#
#  Complete example use case including HTTP header rules:
#
#     use Rack::Static, :root => 'public',
#         :header_rules => [
#           # Cache all static files in public caches (e.g. Rack::Cache)
#           #  as well as in the browser
#           [:all, {'Cache-Control' => 'public, max-age=31536000'}],
#
#           # Provide web fonts with cross-origin access-control-headers
#           #  Firefox requires this when serving assets using a Content Delivery Network
#           [:fonts, {'Access-Control-Allow-Origin' => '*'}]
#         ]
class Rack::Static
  # @return [Static] a new instance of Static
  def initialize(app, options = T.unsafe(nil)); end

  # @return [Boolean]
  def add_index_root?(path); end

  # Convert HTTP header rules to HTTP headers
  def applicable_rules(path); end

  def call(env); end
  def can_serve(path); end
  def overwrite_file_path(path); end
  def route_file(path); end
end

Rack::TRACE = T.let(T.unsafe(nil), String)
Rack::TRANSFER_ENCODING = T.let(T.unsafe(nil), String)

# Middleware tracks and cleans Tempfiles created throughout a request (i.e. Rack::Multipart)
# Ideas/strategy based on posts by Eric Wong and Charles Oliver Nutter
# https://groups.google.com/forum/#!searchin/rack-devel/temp/rack-devel/brK8eh-MByw/sw61oJJCGRMJ
class Rack::TempfileReaper
  # @return [TempfileReaper] a new instance of TempfileReaper
  def initialize(app); end

  def call(env); end
end

Rack::UNLINK = T.let(T.unsafe(nil), String)

# Rack::URLMap takes a hash mapping urls or paths to apps, and
# dispatches accordingly.  Support for HTTP/1.1 host names exists if
# the URLs start with <tt>http://</tt> or <tt>https://</tt>.
#
# URLMap modifies the SCRIPT_NAME and PATH_INFO such that the part
# relevant for dispatch is in the SCRIPT_NAME, and the rest in the
# PATH_INFO.  This should be taken care of when you need to
# reconstruct the URL in order to create links.
#
# URLMap dispatches in such a way that the longest paths are tried
# first, since they are most specific.
class Rack::URLMap
  # @return [URLMap] a new instance of URLMap
  def initialize(map = T.unsafe(nil)); end

  def call(env); end
  def remap(map); end

  private

  # @return [Boolean]
  def casecmp?(v1, v2); end
end

# Rack::Utils contains a grab-bag of useful methods for writing web
# applications adopted from all kinds of Ruby libraries.
module Rack::Utils
  private

  def add_cookie_to_header(header, key, value); end

  # Adds a cookie that will *remove* a cookie from the client.  Hence the
  # strange method name.
  def add_remove_cookie_to_header(header, key, value = T.unsafe(nil)); end

  # Return best accept value to use, based on the algorithm
  # in RFC 2616 Section 14.  If there are multiple best
  # matches (same specificity and quality), the value returned
  # is arbitrary.
  def best_q_match(q_value_header, available_mimes); end

  def build_nested_query(value, prefix = T.unsafe(nil)); end
  def build_query(params); end

  # Parses the "Range:" header, if present, into an array of Range objects.
  # Returns nil if the header is missing or syntactically invalid.
  # Returns an empty array if none of the ranges are satisfiable.
  def byte_ranges(env, size); end

  def clean_path_info(path_info); end

  # :nocov:
  def clock_time; end

  def delete_cookie_header!(header, key, value = T.unsafe(nil)); end

  # URI escapes. (CGI style space to +)
  def escape(s); end

  # Escape ampersands, brackets and quotes to their HTML/XML entities.
  def escape_html(string); end

  # Like URI escaping, but with %20 instead of +. Strictly speaking this is
  # true URI escaping.
  def escape_path(s); end

  def get_byte_ranges(http_range, size); end
  def make_delete_cookie_header(header, key, value); end
  def parse_cookies(env); end
  def parse_cookies_header(header); end
  def parse_nested_query(qs, d = T.unsafe(nil)); end
  def parse_query(qs, d = T.unsafe(nil), &unescaper); end
  def q_values(q_value_header); end

  # Modified version of stdlib time.rb Time#rfc2822 to use '%d-%b-%Y' instead
  # of '% %b %Y'.
  # It assumes that the time is in GMT to comply to the RFC 2109.
  #
  # NOTE: I'm not sure the RFC says it requires GMT, but is ambiguous enough
  # that I'm certain someone implemented only that option.
  # Do not use %a and %b from Time.strptime, it would use localized names for
  # weekday and month.
  def rfc2109(time); end

  def rfc2822(time); end

  # Constant time string comparison.
  #
  # NOTE: the values compared should be of fixed length, such as strings
  # that have already been processed by HMAC. This should not be used
  # on variable length plaintext strings because it could leak length info
  # via timing attacks.
  def secure_compare(a, b); end

  def select_best_encoding(available_encodings, accept_encoding); end
  def set_cookie_header!(header, key, value); end
  def status_code(status); end

  # Unescapes a URI escaped string with +encoding+. +encoding+ will be the
  # target encoding of the string returned, and it defaults to UTF-8
  def unescape(s, encoding = T.unsafe(nil)); end

  # Unescapes the **path** component of a URI.  See Rack::Utils.unescape for
  # unescaping query parameters or form components.
  def unescape_path(s); end

  def valid_path?(path); end

  class << self
    def add_cookie_to_header(header, key, value); end

    # Adds a cookie that will *remove* a cookie from the client.  Hence the
    # strange method name.
    def add_remove_cookie_to_header(header, key, value = T.unsafe(nil)); end

    # Return best accept value to use, based on the algorithm
    # in RFC 2616 Section 14.  If there are multiple best
    # matches (same specificity and quality), the value returned
    # is arbitrary.
    def best_q_match(q_value_header, available_mimes); end

    def build_nested_query(value, prefix = T.unsafe(nil)); end
    def build_query(params); end

    # Parses the "Range:" header, if present, into an array of Range objects.
    # Returns nil if the header is missing or syntactically invalid.
    # Returns an empty array if none of the ranges are satisfiable.
    def byte_ranges(env, size); end

    def clean_path_info(path_info); end
    def clock_time; end

    # Returns the value of attribute default_query_parser.
    def default_query_parser; end

    # Sets the attribute default_query_parser
    #
    # @param value the value to set the attribute default_query_parser to.
    def default_query_parser=(_arg0); end

    def delete_cookie_header!(header, key, value = T.unsafe(nil)); end

    # URI escapes. (CGI style space to +)
    def escape(s); end

    # Escape ampersands, brackets and quotes to their HTML/XML entities.
    def escape_html(string); end

    # Like URI escaping, but with %20 instead of +. Strictly speaking this is
    # true URI escaping.
    def escape_path(s); end

    def get_byte_ranges(http_range, size); end
    def key_space_limit; end
    def key_space_limit=(v); end
    def make_delete_cookie_header(header, key, value); end

    # Returns the value of attribute multipart_part_limit.
    def multipart_part_limit; end

    # Sets the attribute multipart_part_limit
    #
    # @param value the value to set the attribute multipart_part_limit to.
    def multipart_part_limit=(_arg0); end

    def param_depth_limit; end
    def param_depth_limit=(v); end
    def parse_cookies(env); end
    def parse_cookies_header(header); end
    def parse_nested_query(qs, d = T.unsafe(nil)); end
    def parse_query(qs, d = T.unsafe(nil), &unescaper); end
    def q_values(q_value_header); end

    # Modified version of stdlib time.rb Time#rfc2822 to use '%d-%b-%Y' instead
    # of '% %b %Y'.
    # It assumes that the time is in GMT to comply to the RFC 2109.
    #
    # NOTE: I'm not sure the RFC says it requires GMT, but is ambiguous enough
    # that I'm certain someone implemented only that option.
    # Do not use %a and %b from Time.strptime, it would use localized names for
    # weekday and month.
    def rfc2109(time); end

    def rfc2822(time); end

    # Constant time string comparison.
    #
    # NOTE: the values compared should be of fixed length, such as strings
    # that have already been processed by HMAC. This should not be used
    # on variable length plaintext strings because it could leak length info
    # via timing attacks.
    def secure_compare(a, b); end

    def select_best_encoding(available_encodings, accept_encoding); end
    def set_cookie_header!(header, key, value); end
    def status_code(status); end

    # Unescapes a URI escaped string with +encoding+. +encoding+ will be the
    # target encoding of the string returned, and it defaults to UTF-8
    def unescape(s, encoding = T.unsafe(nil)); end

    # Unescapes the **path** component of a URI.  See Rack::Utils.unescape for
    # unescaping query parameters or form components.
    def unescape_path(s); end

    # @return [Boolean]
    def valid_path?(path); end
  end
end

Rack::Utils::COMMON_SEP = T.let(T.unsafe(nil), Hash)

# Context allows the use of a compatible middleware at different points
# in a request handling stack. A compatible middleware must define
# #context which should take the arguments env and app. The first of which
# would be the request environment. The second of which would be the rack
# application that the request would be forwarded to.
class Rack::Utils::Context
  # @return [Context] a new instance of Context
  def initialize(app_f, app_r); end

  # Returns the value of attribute app.
  def app; end

  def call(env); end
  def context(env, app = T.unsafe(nil)); end

  # Returns the value of attribute for.
  def for; end

  def recontext(app); end
end

Rack::Utils::DEFAULT_SEP = T.let(T.unsafe(nil), Regexp)
Rack::Utils::ESCAPE_HTML = T.let(T.unsafe(nil), Hash)
Rack::Utils::ESCAPE_HTML_PATTERN = T.let(T.unsafe(nil), Regexp)

# Every standard HTTP code mapped to the appropriate message.
# Generated with:
#   curl -s https://www.iana.org/assignments/http-status-codes/http-status-codes-1.csv | \
#     ruby -ne 'm = /^(\d{3}),(?!Unassigned|\(Unused\))([^,]+)/.match($_) and \
#               puts "#{m[1]} => \x27#{m[2].strip}\x27,"'
Rack::Utils::HTTP_STATUS_CODES = T.let(T.unsafe(nil), Hash)

# A case-insensitive Hash that preserves the original case of a
# header when set.
#
# @api private
class Rack::Utils::HeaderHash < ::Hash
  # @api private
  # @return [HeaderHash] a new instance of HeaderHash
  def initialize(hash = T.unsafe(nil)); end

  # @api private
  def [](k); end

  # @api private
  def []=(k, v); end

  # on clear, we need to clear @names hash
  #
  # @api private
  def clear; end

  # @api private
  def delete(k); end

  # @api private
  def each; end

  # @api private
  # @return [Boolean]
  def has_key?(k); end

  # @api private
  # @return [Boolean]
  def include?(k); end

  # @api private
  # @return [Boolean]
  def key?(k); end

  # @api private
  # @return [Boolean]
  def member?(k); end

  # @api private
  def merge(other); end

  # @api private
  def merge!(other); end

  # @api private
  def replace(other); end

  # @api private
  def to_hash; end

  protected

  # @api private
  def names; end

  private

  # on dup/clone, we need to duplicate @names hash
  #
  # @api private
  def initialize_copy(other); end

  class << self
    # @api private
    def [](headers); end
  end
end

Rack::Utils::InvalidParameterError = Rack::QueryParser::InvalidParameterError
Rack::Utils::KeySpaceConstrainedParams = Rack::QueryParser::Params
Rack::Utils::NULL_BYTE = T.let(T.unsafe(nil), String)
Rack::Utils::PATH_SEPS = T.let(T.unsafe(nil), Regexp)
Rack::Utils::ParameterTypeError = Rack::QueryParser::ParameterTypeError

# Responses with HTTP status codes that should not have an entity body
Rack::Utils::STATUS_WITH_NO_ENTITY_BODY = T.let(T.unsafe(nil), Hash)

Rack::Utils::SYMBOL_TO_STATUS_CODE = T.let(T.unsafe(nil), Hash)

# The Rack protocol version number implemented.
Rack::VERSION = T.let(T.unsafe(nil), Array)

# This monkey patch allows for applications to perform their own chunking
# through WEBrick::HTTPResponse if rack is set to true.
class WEBrick::HTTPResponse
  # Returns the value of attribute rack.
  def rack; end

  # Sets the attribute rack
  #
  # @param value the value to set the attribute rack to.
  def rack=(_arg0); end

  def setup_header; end
end
