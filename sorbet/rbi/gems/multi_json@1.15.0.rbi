# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `multi_json` gem.
# Please instead update this file by running `bin/tapioca gem multi_json`.

module MultiJson
  include ::MultiJson::Options
  extend ::MultiJson::Options
  extend ::MultiJson

  # Get the current adapter class.
  def adapter; end

  # Set the JSON parser utilizing a symbol, string, or class.
  # Supported by default are:
  #
  # * <tt>:oj</tt>
  # * <tt>:json_gem</tt>
  # * <tt>:json_pure</tt>
  # * <tt>:ok_json</tt>
  # * <tt>:yajl</tt>
  # * <tt>:nsjsonserialization</tt> (MacRuby only)
  # * <tt>:gson</tt> (JRuby only)
  # * <tt>:jr_jackson</tt> (JRuby only)
  def adapter=(new_adapter); end

  def cached_options(*_arg0); end
  def current_adapter(options = T.unsafe(nil)); end

  # Decode a JSON string into Ruby.
  #
  # <b>Options</b>
  #
  # <tt>:symbolize_keys</tt> :: If true, will use symbols instead of strings for the keys.
  # <tt>:adapter</tt> :: If set, the selected adapter will be used for this call.
  def decode(string, options = T.unsafe(nil)); end

  # The default adapter based on what you currently
  # have loaded and installed. First checks to see
  # if any adapters are already loaded, then checks
  # to see which are installed if none are loaded.
  def default_adapter; end

  # The default adapter based on what you currently
  # have loaded and installed. First checks to see
  # if any adapters are already loaded, then checks
  # to see which are installed if none are loaded.
  def default_engine; end

  def default_options; end
  def default_options=(value); end

  # Encodes a Ruby object as JSON.
  def dump(object, options = T.unsafe(nil)); end

  # Encodes a Ruby object as JSON.
  def encode(object, options = T.unsafe(nil)); end

  # Get the current adapter class.
  def engine; end

  # Set the JSON parser utilizing a symbol, string, or class.
  # Supported by default are:
  #
  # * <tt>:oj</tt>
  # * <tt>:json_gem</tt>
  # * <tt>:json_pure</tt>
  # * <tt>:ok_json</tt>
  # * <tt>:yajl</tt>
  # * <tt>:nsjsonserialization</tt> (MacRuby only)
  # * <tt>:gson</tt> (JRuby only)
  # * <tt>:jr_jackson</tt> (JRuby only)
  def engine=(new_adapter); end

  # Decode a JSON string into Ruby.
  #
  # <b>Options</b>
  #
  # <tt>:symbolize_keys</tt> :: If true, will use symbols instead of strings for the keys.
  # <tt>:adapter</tt> :: If set, the selected adapter will be used for this call.
  def load(string, options = T.unsafe(nil)); end

  def load_adapter(new_adapter); end
  def reset_cached_options!(*_arg0); end

  # Set the JSON parser utilizing a symbol, string, or class.
  # Supported by default are:
  #
  # * <tt>:oj</tt>
  # * <tt>:json_gem</tt>
  # * <tt>:json_pure</tt>
  # * <tt>:ok_json</tt>
  # * <tt>:yajl</tt>
  # * <tt>:nsjsonserialization</tt> (MacRuby only)
  # * <tt>:gson</tt> (JRuby only)
  # * <tt>:jr_jackson</tt> (JRuby only)
  def use(new_adapter); end

  # Executes passed block using specified adapter.
  def with_adapter(new_adapter); end

  # Executes passed block using specified adapter.
  def with_engine(new_adapter); end

  private

  def load_adapter_from_string_name(name); end
end

MultiJson::ALIASES = T.let(T.unsafe(nil), Hash)

class MultiJson::AdapterError < ::ArgumentError
  # Returns the value of attribute cause.
  def cause; end

  class << self
    def build(original_exception); end
  end
end

# Legacy support
MultiJson::DecodeError = MultiJson::ParseError

MultiJson::LoadError = MultiJson::ParseError

module MultiJson::Options
  def default_dump_options; end
  def default_load_options; end
  def dump_options(*args); end
  def dump_options=(options); end
  def load_options(*args); end
  def load_options=(options); end

  private

  def get_options(options, *args); end
end

module MultiJson::OptionsCache
  extend ::MultiJson::OptionsCache

  def fetch(type, key, &block); end
  def reset; end

  private

  def write(cache, key); end
end

# Normally MultiJson is used with a few option sets for both dump/load
# methods. When options are generated dynamically though, every call would
# cause a cache miss and the cache would grow indefinitely. To prevent
# this, we just reset the cache every time the number of keys outgrows
# 1000.
MultiJson::OptionsCache::MAX_CACHE_SIZE = T.let(T.unsafe(nil), Integer)

class MultiJson::ParseError < ::StandardError
  # Returns the value of attribute cause.
  def cause; end

  # Returns the value of attribute data.
  def data; end

  class << self
    def build(original_exception, data); end
  end
end

MultiJson::REQUIREMENT_MAP = T.let(T.unsafe(nil), Array)
MultiJson::VERSION = T.let(T.unsafe(nil), String)

class MultiJson::Version
  class << self
    # @return [String]
    def to_s; end
  end
end

MultiJson::Version::MAJOR = T.let(T.unsafe(nil), Integer)
MultiJson::Version::MINOR = T.let(T.unsafe(nil), Integer)
MultiJson::Version::PATCH = T.let(T.unsafe(nil), Integer)
