# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `activerecord` gem.
# Please instead update this file by running `bin/tapioca gem activerecord`.

module ActiveRecord
  extend ::ActiveSupport::Autoload

  class << self
    def eager_load!; end

    # Returns the version of the currently loaded Active Record as a <tt>Gem::Version</tt>
    def gem_version; end

    # Returns the version of the currently loaded ActiveRecord as a <tt>Gem::Version</tt>
    def version; end
  end
end

# Raised when trying to use a feature in Active Record which requires Active Job but the gem is not present.
class ActiveRecord::ActiveJobRequiredError < ::ActiveRecord::ActiveRecordError; end

# = Active Record Errors
#
# Generic Active Record exception class.
class ActiveRecord::ActiveRecordError < ::StandardError; end

# Raised when Active Record cannot find database adapter specified in
# +config/database.yml+ or programmatically.
class ActiveRecord::AdapterNotFound < ::ActiveRecord::ActiveRecordError; end

# Raised when adapter not specified on connection (or configuration file
# +config/database.yml+ misses adapter field).
class ActiveRecord::AdapterNotSpecified < ::ActiveRecord::ActiveRecordError; end

# AdapterTimeout will be raised when database clients times out while waiting from the server.
class ActiveRecord::AdapterTimeout < ::ActiveRecord::QueryAborted; end

# See ActiveRecord::Aggregations::ClassMethods for documentation
module ActiveRecord::Aggregations
  def reload(*_arg0); end

  private

  def clear_aggregation_cache; end
  def init_internals; end
  def initialize_dup(*_arg0); end
end

# Active Record implements aggregation through a macro-like class method called #composed_of
# for representing attributes as value objects. It expresses relationships like "Account [is]
# composed of Money [among other things]" or "Person [is] composed of [an] address". Each call
# to the macro adds a description of how the value objects are created from the attributes of
# the entity object (when the entity is initialized either as a new object or from finding an
# existing object) and how it can be turned back into attributes (when the entity is saved to
# the database).
#
#   class Customer < ActiveRecord::Base
#     composed_of :balance, class_name: "Money", mapping: %w(balance amount)
#     composed_of :address, mapping: [ %w(address_street street), %w(address_city city) ]
#   end
#
# The customer class now has the following methods to manipulate the value objects:
# * <tt>Customer#balance, Customer#balance=(money)</tt>
# * <tt>Customer#address, Customer#address=(address)</tt>
#
# These methods will operate with value objects like the ones described below:
#
#  class Money
#    include Comparable
#    attr_reader :amount, :currency
#    EXCHANGE_RATES = { "USD_TO_DKK" => 6 }
#
#    def initialize(amount, currency = "USD")
#      @amount, @currency = amount, currency
#    end
#
#    def exchange_to(other_currency)
#      exchanged_amount = (amount * EXCHANGE_RATES["#{currency}_TO_#{other_currency}"]).floor
#      Money.new(exchanged_amount, other_currency)
#    end
#
#    def ==(other_money)
#      amount == other_money.amount && currency == other_money.currency
#    end
#
#    def <=>(other_money)
#      if currency == other_money.currency
#        amount <=> other_money.amount
#      else
#        amount <=> other_money.exchange_to(currency).amount
#      end
#    end
#  end
#
#  class Address
#    attr_reader :street, :city
#    def initialize(street, city)
#      @street, @city = street, city
#    end
#
#    def close_to?(other_address)
#      city == other_address.city
#    end
#
#    def ==(other_address)
#      city == other_address.city && street == other_address.street
#    end
#  end
#
# Now it's possible to access attributes from the database through the value objects instead. If
# you choose to name the composition the same as the attribute's name, it will be the only way to
# access that attribute. That's the case with our +balance+ attribute. You interact with the value
# objects just like you would with any other attribute:
#
#   customer.balance = Money.new(20)     # sets the Money value object and the attribute
#   customer.balance                     # => Money value object
#   customer.balance.exchange_to("DKK")  # => Money.new(120, "DKK")
#   customer.balance > Money.new(10)     # => true
#   customer.balance == Money.new(20)    # => true
#   customer.balance < Money.new(5)      # => false
#
# Value objects can also be composed of multiple attributes, such as the case of Address. The order
# of the mappings will determine the order of the parameters.
#
#   customer.address_street = "Hyancintvej"
#   customer.address_city   = "Copenhagen"
#   customer.address        # => Address.new("Hyancintvej", "Copenhagen")
#
#   customer.address = Address.new("May Street", "Chicago")
#   customer.address_street # => "May Street"
#   customer.address_city   # => "Chicago"
#
# == Writing value objects
#
# Value objects are immutable and interchangeable objects that represent a given value, such as
# a Money object representing $5. Two Money objects both representing $5 should be equal (through
# methods such as <tt>==</tt> and <tt><=></tt> from Comparable if ranking makes sense). This is
# unlike entity objects where equality is determined by identity. An entity class such as Customer can
# easily have two different objects that both have an address on Hyancintvej. Entity identity is
# determined by object or relational unique identifiers (such as primary keys). Normal
# ActiveRecord::Base classes are entity objects.
#
# It's also important to treat the value objects as immutable. Don't allow the Money object to have
# its amount changed after creation. Create a new Money object with the new value instead. The
# <tt>Money#exchange_to</tt> method is an example of this. It returns a new value object instead of changing
# its own values. Active Record won't persist value objects that have been changed through means
# other than the writer method.
#
# The immutable requirement is enforced by Active Record by freezing any object assigned as a value
# object. Attempting to change it afterwards will result in a +RuntimeError+.
#
# Read more about value objects on http://c2.com/cgi/wiki?ValueObject and on the dangers of not
# keeping value objects immutable on http://c2.com/cgi/wiki?ValueObjectsShouldBeImmutable
#
# == Custom constructors and converters
#
# By default value objects are initialized by calling the <tt>new</tt> constructor of the value
# class passing each of the mapped attributes, in the order specified by the <tt>:mapping</tt>
# option, as arguments. If the value class doesn't support this convention then #composed_of allows
# a custom constructor to be specified.
#
# When a new value is assigned to the value object, the default assumption is that the new value
# is an instance of the value class. Specifying a custom converter allows the new value to be automatically
# converted to an instance of value class if necessary.
#
# For example, the +NetworkResource+ model has +network_address+ and +cidr_range+ attributes that should be
# aggregated using the +NetAddr::CIDR+ value class (https://www.rubydoc.info/gems/netaddr/1.5.0/NetAddr/CIDR).
# The constructor for the value class is called +create+ and it expects a CIDR address string as a parameter.
# New values can be assigned to the value object using either another +NetAddr::CIDR+ object, a string
# or an array. The <tt>:constructor</tt> and <tt>:converter</tt> options can be used to meet
# these requirements:
#
#   class NetworkResource < ActiveRecord::Base
#     composed_of :cidr,
#                 class_name: 'NetAddr::CIDR',
#                 mapping: [ %w(network_address network), %w(cidr_range bits) ],
#                 allow_nil: true,
#                 constructor: Proc.new { |network_address, cidr_range| NetAddr::CIDR.create("#{network_address}/#{cidr_range}") },
#                 converter: Proc.new { |value| NetAddr::CIDR.create(value.is_a?(Array) ? value.join('/') : value) }
#   end
#
#   # This calls the :constructor
#   network_resource = NetworkResource.new(network_address: '192.168.0.1', cidr_range: 24)
#
#   # These assignments will both use the :converter
#   network_resource.cidr = [ '192.168.2.1', 8 ]
#   network_resource.cidr = '192.168.0.1/24'
#
#   # This assignment won't use the :converter as the value is already an instance of the value class
#   network_resource.cidr = NetAddr::CIDR.create('192.168.2.1/8')
#
#   # Saving and then reloading will use the :constructor on reload
#   network_resource.save
#   network_resource.reload
#
# == Finding records by a value object
#
# Once a #composed_of relationship is specified for a model, records can be loaded from the database
# by specifying an instance of the value object in the conditions hash. The following example
# finds all customers with +address_street+ equal to "May Street" and +address_city+ equal to "Chicago":
#
#   Customer.where(address: Address.new("May Street", "Chicago"))
module ActiveRecord::Aggregations::ClassMethods
  # Adds reader and writer methods for manipulating a value object:
  # <tt>composed_of :address</tt> adds <tt>address</tt> and <tt>address=(new_address)</tt> methods.
  #
  # Options are:
  # * <tt>:class_name</tt> - Specifies the class name of the association. Use it only if that name
  #   can't be inferred from the part id. So <tt>composed_of :address</tt> will by default be linked
  #   to the Address class, but if the real class name is +CompanyAddress+, you'll have to specify it
  #   with this option.
  # * <tt>:mapping</tt> - Specifies the mapping of entity attributes to attributes of the value
  #   object. Each mapping is represented as an array where the first item is the name of the
  #   entity attribute and the second item is the name of the attribute in the value object. The
  #   order in which mappings are defined determines the order in which attributes are sent to the
  #   value class constructor.
  # * <tt>:allow_nil</tt> - Specifies that the value object will not be instantiated when all mapped
  #   attributes are +nil+. Setting the value object to +nil+ has the effect of writing +nil+ to all
  #   mapped attributes.
  #   This defaults to +false+.
  # * <tt>:constructor</tt> - A symbol specifying the name of the constructor method or a Proc that
  #   is called to initialize the value object. The constructor is passed all of the mapped attributes,
  #   in the order that they are defined in the <tt>:mapping option</tt>, as arguments and uses them
  #   to instantiate a <tt>:class_name</tt> object.
  #   The default is <tt>:new</tt>.
  # * <tt>:converter</tt> - A symbol specifying the name of a class method of <tt>:class_name</tt>
  #   or a Proc that is called when a new value is assigned to the value object. The converter is
  #   passed the single value that is used in the assignment and is only called if the new value is
  #   not an instance of <tt>:class_name</tt>. If <tt>:allow_nil</tt> is set to true, the converter
  #   can return +nil+ to skip the assignment.
  #
  # Option examples:
  #   composed_of :temperature, mapping: %w(reading celsius)
  #   composed_of :balance, class_name: "Money", mapping: %w(balance amount)
  #   composed_of :address, mapping: [ %w(address_street street), %w(address_city city) ]
  #   composed_of :gps_location
  #   composed_of :gps_location, allow_nil: true
  #   composed_of :ip_address,
  #               class_name: 'IPAddr',
  #               mapping: %w(ip to_i),
  #               constructor: Proc.new { |ip| IPAddr.new(ip, Socket::AF_INET) },
  #               converter: Proc.new { |ip| ip.is_a?(Integer) ? IPAddr.new(ip, Socket::AF_INET) : IPAddr.new(ip.to_s) }
  def composed_of(part_id, options = T.unsafe(nil)); end

  private

  def reader_method(name, class_name, mapping, allow_nil, constructor); end
  def writer_method(name, class_name, mapping, allow_nil, converter); end
end

class ActiveRecord::AmbiguousSourceReflectionForThroughAssociation < ::ActiveRecord::ActiveRecordError
  # @return [AmbiguousSourceReflectionForThroughAssociation] a new instance of AmbiguousSourceReflectionForThroughAssociation
  def initialize(klass, macro, association_name, options, possible_sources); end
end

class ActiveRecord::AssociationNotFoundError < ::ActiveRecord::ConfigurationError
  include ::DidYouMean::Correctable

  # @return [AssociationNotFoundError] a new instance of AssociationNotFoundError
  def initialize(record = T.unsafe(nil), association_name = T.unsafe(nil)); end

  # Returns the value of attribute association_name.
  def association_name; end

  # Returns the value of attribute record.
  def record; end
end

class ActiveRecord::AssociationNotFoundError::Correction
  # @return [Correction] a new instance of Correction
  def initialize(error); end

  def corrections; end
end

class ActiveRecord::AssociationRelation < ::ActiveRecord::Relation
  # @return [AssociationRelation] a new instance of AssociationRelation
  def initialize(klass, association, **_arg2); end

  def ==(other); end
  def build(attributes = T.unsafe(nil), &block); end
  def insert(attributes, **kwargs); end
  def insert!(attributes, **kwargs); end
  def insert_all(attributes, **kwargs); end
  def insert_all!(attributes, **kwargs); end
  def new(attributes = T.unsafe(nil), &block); end
  def proxy_association; end
  def upsert(attributes, **kwargs); end
  def upsert_all(attributes, **kwargs); end

  private

  def _create(attributes, &block); end
  def _create!(attributes, &block); end
  def _new(attributes, &block); end
  def exec_queries; end
end

# Raised when an object assigned to an association has an incorrect type.
#
#   class Ticket < ActiveRecord::Base
#     has_many :patches
#   end
#
#   class Patch < ActiveRecord::Base
#     belongs_to :ticket
#   end
#
#   # Comments are not patches, this assignment raises AssociationTypeMismatch.
#   @ticket.patches << Comment.new(content: "Please attach tests to your patch.")
class ActiveRecord::AssociationTypeMismatch < ::ActiveRecord::ActiveRecordError; end

# See ActiveRecord::Associations::ClassMethods for documentation.
module ActiveRecord::Associations
  extend ::ActiveSupport::Autoload
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::ActiveRecord::Associations::ClassMethods

  # Returns the association instance for the given name, instantiating it if it doesn't already exist
  def association(name); end

  # @return [Boolean]
  def association_cached?(name); end

  def reload(*_arg0); end

  private

  # Returns the specified association instance if it exists, +nil+ otherwise.
  def association_instance_get(name); end

  # Set the specified association instance.
  def association_instance_set(name, association); end

  # Clears out the association cache.
  def clear_association_cache; end

  def init_internals; end
  def initialize_dup(*_arg0); end

  class << self
    def eager_load!; end
  end
end

# Keeps track of table aliases for ActiveRecord::Associations::JoinDependency
class ActiveRecord::Associations::AliasTracker
  # table_joins is an array of arel joins which might conflict with the aliases we assign here
  #
  # @return [AliasTracker] a new instance of AliasTracker
  def initialize(connection, aliases); end

  def aliased_table_for(arel_table, table_name = T.unsafe(nil)); end

  # Returns the value of attribute aliases.
  def aliases; end

  private

  def truncate(name); end

  class << self
    def create(connection, initial_table, joins, aliases = T.unsafe(nil)); end
    def initial_count_for(connection, name, table_joins); end
  end
end

# = Active Record Associations
#
# This is the root class of all associations ('+ Foo' signifies an included module Foo):
#
#   Association
#     SingularAssociation
#       HasOneAssociation + ForeignAssociation
#         HasOneThroughAssociation + ThroughAssociation
#       BelongsToAssociation
#         BelongsToPolymorphicAssociation
#     CollectionAssociation
#       HasManyAssociation + ForeignAssociation
#         HasManyThroughAssociation + ThroughAssociation
#
# Associations in Active Record are middlemen between the object that
# holds the association, known as the <tt>owner</tt>, and the associated
# result set, known as the <tt>target</tt>. Association metadata is available in
# <tt>reflection</tt>, which is an instance of <tt>ActiveRecord::Reflection::AssociationReflection</tt>.
#
# For example, given
#
#   class Blog < ActiveRecord::Base
#     has_many :posts
#   end
#
#   blog = Blog.first
#
# The association of <tt>blog.posts</tt> has the object +blog+ as its
# <tt>owner</tt>, the collection of its posts as <tt>target</tt>, and
# the <tt>reflection</tt> object represents a <tt>:has_many</tt> macro.
class ActiveRecord::Associations::Association
  # @return [Association] a new instance of Association
  def initialize(owner, reflection); end

  def create(attributes = T.unsafe(nil), &block); end
  def create!(attributes = T.unsafe(nil), &block); end
  def extensions; end
  def initialize_attributes(record, except_from_scope_attributes = T.unsafe(nil)); end
  def inversed_from(record); end
  def inversed_from_queries(record); end

  # Returns the class of the target. belongs_to polymorphic overrides this to look at the
  # polymorphic_type field on the owner.
  def klass; end

  # Loads the \target if needed and returns it.
  #
  # This method is abstract in the sense that it relies on +find_target+,
  # which is expected to be provided by descendants.
  #
  # If the \target is already \loaded it is just returned. Thus, you can call
  # +load_target+ unconditionally to get the \target.
  #
  # ActiveRecord::RecordNotFound is rescued within the method, and it is
  # not reraised. The proxy is \reset and +nil+ is the return value.
  def load_target; end

  # Asserts the \target has been loaded setting the \loaded flag to +true+.
  def loaded!; end

  # Has the \target been already \loaded?
  #
  # @return [Boolean]
  def loaded?; end

  # We can't dump @reflection and @through_reflection since it contains the scope proc
  def marshal_dump; end

  def marshal_load(data); end
  def options(*_arg0, &_arg1); end
  def owner; end
  def reflection; end

  # Reloads the \target and returns +self+ on success.
  # The QueryCache is cleared if +force+ is true.
  def reload(force = T.unsafe(nil)); end

  # Remove the inverse association, if possible
  def remove_inverse_instance(record); end

  # Resets the \loaded flag to +false+ and sets the \target to +nil+.
  def reset; end

  def reset_negative_cache; end
  def reset_scope; end
  def scope; end

  # Set the inverse association, if possible
  def set_inverse_instance(record); end

  def set_inverse_instance_from_queries(record); end

  # The target is stale if the target no longer points to the record(s) that the
  # relevant foreign_key(s) refers to. If stale, the association accessor method
  # on the owner will reload the target. It's up to subclasses to implement the
  # stale_state method if relevant.
  #
  # Note that if the target has not been loaded, it is not considered stale.
  #
  # @return [Boolean]
  def stale_target?; end

  def target; end

  # Sets the target of this association to <tt>\target</tt>, and the \loaded flag to +true+.
  def target=(target); end

  private

  # The scope for this association.
  #
  # Note that the association_scope is merged into the target_scope only when the
  # scope method is called. This is because at that point the call may be surrounded
  # by scope.scoping { ... } or unscoped { ... } etc, which affects the scope which
  # actually gets built.
  def association_scope; end

  def build_record(attributes); end
  def enqueue_destroy_association(options); end
  def find_target; end

  # @return [Boolean]
  def find_target?; end

  # Returns true if record contains the foreign_key
  #
  # @return [Boolean]
  def foreign_key_for?(record); end

  # Returns true if there is a foreign key present on the owner which
  # references the target. This is used to determine whether we can load
  # the target if the owner is currently a new record (and therefore
  # without a key). If the owner is a new record then foreign_key must
  # be present in order to load target.
  #
  # Currently implemented by belongs_to (vanilla and polymorphic) and
  # has_one/has_many :through associations which go through a belongs_to.
  #
  # @return [Boolean]
  def foreign_key_present?; end

  # @return [Boolean]
  def inversable?(record); end

  def inverse_association_for(record); end

  # Can be redefined by subclasses, notably polymorphic belongs_to
  # The record parameter is necessary to support polymorphic inverses as we must check for
  # the association in the specific class of the record.
  def inverse_reflection_for(record); end

  # Returns true if inverse association on the given record needs to be set.
  # This method is redefined by subclasses.
  #
  # @return [Boolean]
  def invertible_for?(record); end

  # @return [Boolean]
  def matches_foreign_key?(record); end

  # Raises ActiveRecord::AssociationTypeMismatch unless +record+ is of
  # the kind of the class of the associated objects. Meant to be used as
  # a sanity check when you are about to assign an associated record.
  def raise_on_type_mismatch!(record); end

  def scope_for_create; end

  # Returns true if statement cache should be skipped on the association reader.
  #
  # @return [Boolean]
  def skip_statement_cache?(scope); end

  # This should be implemented to return the values of the relevant key(s) on the owner,
  # so that when stale_state is different from the value stored on the last find_target,
  # the target is stale.
  #
  # This is only relevant to certain associations, which is why it returns +nil+ by default.
  def stale_state; end

  # @return [Boolean]
  def strict_loading?; end

  # Can be overridden (i.e. in ThroughAssociation) to merge in other scopes (i.e. the
  # through association's scope)
  def target_scope; end
end

class ActiveRecord::Associations::AssociationScope
  # @return [AssociationScope] a new instance of AssociationScope
  def initialize(value_transformation); end

  def scope(association); end

  private

  def add_constraints(scope, owner, chain); end
  def apply_scope(scope, table, key, value); end
  def eval_scope(reflection, scope, owner); end
  def get_chain(reflection, association, tracker); end
  def join(table, constraint); end
  def last_chain_scope(scope, reflection, owner); end
  def next_chain_scope(scope, reflection, next_reflection); end
  def transform_value(value); end

  # Returns the value of attribute value_transformation.
  def value_transformation; end

  class << self
    def create(&block); end
    def get_bind_values(owner, chain); end
    def scope(association); end
  end
end

ActiveRecord::Associations::AssociationScope::INSTANCE = T.let(T.unsafe(nil), ActiveRecord::Associations::AssociationScope)

class ActiveRecord::Associations::AssociationScope::ReflectionProxy < ::SimpleDelegator
  # @return [ReflectionProxy] a new instance of ReflectionProxy
  def initialize(reflection, aliased_table); end

  # Returns the value of attribute aliased_table.
  def aliased_table; end

  def all_includes; end
end

# = Active Record Belongs To Association
class ActiveRecord::Associations::BelongsToAssociation < ::ActiveRecord::Associations::SingularAssociation
  def decrement_counters; end
  def decrement_counters_before_last_save; end
  def default(&block); end
  def handle_dependency; end
  def increment_counters; end
  def inversed_from(record); end
  def reset; end

  # @return [Boolean]
  def target_changed?; end

  # @return [Boolean]
  def updated?; end

  private

  # @return [Boolean]
  def find_target?; end

  # @return [Boolean]
  def foreign_key_present?; end

  # @return [Boolean]
  def invertible_for?(record); end

  def primary_key(klass); end
  def replace(record); end
  def replace_keys(record, force: T.unsafe(nil)); end

  # @return [Boolean]
  def require_counter_update?; end

  def stale_state; end
  def update_counters(by); end
  def update_counters_via_scope(klass, foreign_key, by); end
end

# = Active Record Belongs To Polymorphic Association
class ActiveRecord::Associations::BelongsToPolymorphicAssociation < ::ActiveRecord::Associations::BelongsToAssociation
  def klass; end

  # @return [Boolean]
  def target_changed?; end

  private

  def inverse_reflection_for(record); end
  def raise_on_type_mismatch!(record); end
  def replace_keys(record, force: T.unsafe(nil)); end
  def stale_state; end
end

module ActiveRecord::Associations::Builder; end

class ActiveRecord::Associations::Builder::Association
  class << self
    def build(model, name, scope, options, &block); end

    # @raise [ArgumentError]
    def create_reflection(model, name, scope, options, &block); end

    # Returns the value of attribute extensions.
    def extensions; end

    # Sets the attribute extensions
    #
    # @param value the value to set the attribute extensions to.
    def extensions=(_arg0); end

    private

    def add_after_commit_jobs_callback(model, dependent); end
    def add_destroy_callbacks(model, reflection); end
    def build_scope(scope); end
    def check_dependent_options(dependent, model); end

    # Defines the setter and getter methods for the association
    # class Post < ActiveRecord::Base
    #   has_many :comments
    # end
    #
    # Post.first.comments and Post.first.comments= methods are defined by this method...
    def define_accessors(model, reflection); end

    def define_callbacks(model, reflection); end
    def define_extensions(model, name); end
    def define_readers(mixin, name); end
    def define_validations(model, reflection); end
    def define_writers(mixin, name); end

    # @raise [NotImplementedError]
    def macro; end

    # @raise [NotImplementedError]
    def valid_dependent_options; end

    def valid_options(options); end
    def validate_options(options); end
  end
end

ActiveRecord::Associations::Builder::Association::VALID_OPTIONS = T.let(T.unsafe(nil), Array)

class ActiveRecord::Associations::Builder::BelongsTo < ::ActiveRecord::Associations::Builder::SingularAssociation
  class << self
    def touch_record(o, changes, foreign_key, name, touch, touch_method); end

    private

    def add_counter_cache_callbacks(model, reflection); end
    def add_default_callbacks(model, reflection); end
    def add_destroy_callbacks(model, reflection); end
    def add_touch_callbacks(model, reflection); end
    def define_callbacks(model, reflection); end
    def define_validations(model, reflection); end
    def macro; end
    def valid_dependent_options; end
    def valid_options(options); end
  end
end

class ActiveRecord::Associations::Builder::CollectionAssociation < ::ActiveRecord::Associations::Builder::Association
  class << self
    def define_callbacks(model, reflection); end

    private

    def define_callback(model, callback_name, name, options); end
    def define_extensions(model, name, &block); end

    # Defines the setter and getter methods for the collection_singular_ids.
    def define_readers(mixin, name); end

    def define_writers(mixin, name); end
    def valid_options(options); end
  end
end

ActiveRecord::Associations::Builder::CollectionAssociation::CALLBACKS = T.let(T.unsafe(nil), Array)

class ActiveRecord::Associations::Builder::HasAndBelongsToMany
  # @return [HasAndBelongsToMany] a new instance of HasAndBelongsToMany
  def initialize(association_name, lhs_model, options); end

  # Returns the value of attribute association_name.
  def association_name; end

  # Returns the value of attribute lhs_model.
  def lhs_model; end

  def middle_reflection(join_model); end

  # Returns the value of attribute options.
  def options; end

  def through_model; end

  private

  def belongs_to_options(options); end
  def middle_options(join_model); end
  def table_name; end
end

class ActiveRecord::Associations::Builder::HasMany < ::ActiveRecord::Associations::Builder::CollectionAssociation
  class << self
    private

    def macro; end
    def valid_dependent_options; end
    def valid_options(options); end
  end
end

class ActiveRecord::Associations::Builder::HasOne < ::ActiveRecord::Associations::Builder::SingularAssociation
  class << self
    def touch_record(record, name, touch); end

    private

    def add_destroy_callbacks(model, reflection); end
    def add_touch_callbacks(model, reflection); end
    def define_callbacks(model, reflection); end
    def define_validations(model, reflection); end
    def macro; end
    def valid_dependent_options; end
    def valid_options(options); end
  end
end

class ActiveRecord::Associations::Builder::SingularAssociation < ::ActiveRecord::Associations::Builder::Association
  class << self
    private

    def define_accessors(model, reflection); end

    # Defines the (build|create)_association methods for belongs_to or has_one association
    def define_constructors(mixin, name); end

    def valid_options(options); end
  end
end

# \Associations are a set of macro-like class methods for tying objects together through
# foreign keys. They express relationships like "Project has one Project Manager"
# or "Project belongs to a Portfolio". Each macro adds a number of methods to the
# class which are specialized according to the collection or association symbol and the
# options hash. It works much the same way as Ruby's own <tt>attr*</tt>
# methods.
#
#   class Project < ActiveRecord::Base
#     belongs_to              :portfolio
#     has_one                 :project_manager
#     has_many                :milestones
#     has_and_belongs_to_many :categories
#   end
#
# The project class now has the following methods (and more) to ease the traversal and
# manipulation of its relationships:
# * <tt>Project#portfolio</tt>, <tt>Project#portfolio=(portfolio)</tt>, <tt>Project#reload_portfolio</tt>
# * <tt>Project#project_manager</tt>, <tt>Project#project_manager=(project_manager)</tt>, <tt>Project#reload_project_manager</tt>
# * <tt>Project#milestones.empty?</tt>, <tt>Project#milestones.size</tt>, <tt>Project#milestones</tt>, <tt>Project#milestones<<(milestone)</tt>,
#   <tt>Project#milestones.delete(milestone)</tt>, <tt>Project#milestones.destroy(milestone)</tt>, <tt>Project#milestones.find(milestone_id)</tt>,
#   <tt>Project#milestones.build</tt>, <tt>Project#milestones.create</tt>
# * <tt>Project#categories.empty?</tt>, <tt>Project#categories.size</tt>, <tt>Project#categories</tt>, <tt>Project#categories<<(category1)</tt>,
#   <tt>Project#categories.delete(category1)</tt>, <tt>Project#categories.destroy(category1)</tt>
#
# === A word of warning
#
# Don't create associations that have the same name as {instance methods}[rdoc-ref:ActiveRecord::Core] of
# <tt>ActiveRecord::Base</tt>. Since the association adds a method with that name to
# its model, using an association with the same name as one provided by <tt>ActiveRecord::Base</tt> will override the method inherited through <tt>ActiveRecord::Base</tt> and will break things.
# For instance, +attributes+ and +connection+ would be bad choices for association names, because those names already exist in the list of <tt>ActiveRecord::Base</tt> instance methods.
#
# == Auto-generated methods
# See also Instance Public methods below for more details.
#
# === Singular associations (one-to-one)
#                                     |            |  belongs_to  |
#   generated methods                 | belongs_to | :polymorphic | has_one
#   ----------------------------------+------------+--------------+---------
#   other                             |     X      |      X       |    X
#   other=(other)                     |     X      |      X       |    X
#   build_other(attributes={})        |     X      |              |    X
#   create_other(attributes={})       |     X      |              |    X
#   create_other!(attributes={})      |     X      |              |    X
#   reload_other                      |     X      |      X       |    X
#
# === Collection associations (one-to-many / many-to-many)
#                                     |       |          | has_many
#   generated methods                 | habtm | has_many | :through
#   ----------------------------------+-------+----------+----------
#   others                            |   X   |    X     |    X
#   others=(other,other,...)          |   X   |    X     |    X
#   other_ids                         |   X   |    X     |    X
#   other_ids=(id,id,...)             |   X   |    X     |    X
#   others<<                          |   X   |    X     |    X
#   others.push                       |   X   |    X     |    X
#   others.concat                     |   X   |    X     |    X
#   others.build(attributes={})       |   X   |    X     |    X
#   others.create(attributes={})      |   X   |    X     |    X
#   others.create!(attributes={})     |   X   |    X     |    X
#   others.size                       |   X   |    X     |    X
#   others.length                     |   X   |    X     |    X
#   others.count                      |   X   |    X     |    X
#   others.sum(*args)                 |   X   |    X     |    X
#   others.empty?                     |   X   |    X     |    X
#   others.clear                      |   X   |    X     |    X
#   others.delete(other,other,...)    |   X   |    X     |    X
#   others.delete_all                 |   X   |    X     |    X
#   others.destroy(other,other,...)   |   X   |    X     |    X
#   others.destroy_all                |   X   |    X     |    X
#   others.find(*args)                |   X   |    X     |    X
#   others.exists?                    |   X   |    X     |    X
#   others.distinct                   |   X   |    X     |    X
#   others.reset                      |   X   |    X     |    X
#   others.reload                     |   X   |    X     |    X
#
# === Overriding generated methods
#
# Association methods are generated in a module included into the model
# class, making overrides easy. The original generated method can thus be
# called with +super+:
#
#   class Car < ActiveRecord::Base
#     belongs_to :owner
#     belongs_to :old_owner
#
#     def owner=(new_owner)
#       self.old_owner = self.owner
#       super
#     end
#   end
#
# The association methods module is included immediately after the
# generated attributes methods module, meaning an association will
# override the methods for an attribute with the same name.
#
# == Cardinality and associations
#
# Active Record associations can be used to describe one-to-one, one-to-many and many-to-many
# relationships between models. Each model uses an association to describe its role in
# the relation. The #belongs_to association is always used in the model that has
# the foreign key.
#
# === One-to-one
#
# Use #has_one in the base, and #belongs_to in the associated model.
#
#   class Employee < ActiveRecord::Base
#     has_one :office
#   end
#   class Office < ActiveRecord::Base
#     belongs_to :employee    # foreign key - employee_id
#   end
#
# === One-to-many
#
# Use #has_many in the base, and #belongs_to in the associated model.
#
#   class Manager < ActiveRecord::Base
#     has_many :employees
#   end
#   class Employee < ActiveRecord::Base
#     belongs_to :manager     # foreign key - manager_id
#   end
#
# === Many-to-many
#
# There are two ways to build a many-to-many relationship.
#
# The first way uses a #has_many association with the <tt>:through</tt> option and a join model, so
# there are two stages of associations.
#
#   class Assignment < ActiveRecord::Base
#     belongs_to :programmer  # foreign key - programmer_id
#     belongs_to :project     # foreign key - project_id
#   end
#   class Programmer < ActiveRecord::Base
#     has_many :assignments
#     has_many :projects, through: :assignments
#   end
#   class Project < ActiveRecord::Base
#     has_many :assignments
#     has_many :programmers, through: :assignments
#   end
#
# For the second way, use #has_and_belongs_to_many in both models. This requires a join table
# that has no corresponding model or primary key.
#
#   class Programmer < ActiveRecord::Base
#     has_and_belongs_to_many :projects       # foreign keys in the join table
#   end
#   class Project < ActiveRecord::Base
#     has_and_belongs_to_many :programmers    # foreign keys in the join table
#   end
#
# Choosing which way to build a many-to-many relationship is not always simple.
# If you need to work with the relationship model as its own entity,
# use #has_many <tt>:through</tt>. Use #has_and_belongs_to_many when working with legacy schemas or when
# you never work directly with the relationship itself.
#
# == Is it a #belongs_to or #has_one association?
#
# Both express a 1-1 relationship. The difference is mostly where to place the foreign
# key, which goes on the table for the class declaring the #belongs_to relationship.
#
#   class User < ActiveRecord::Base
#     # I reference an account.
#     belongs_to :account
#   end
#
#   class Account < ActiveRecord::Base
#     # One user references me.
#     has_one :user
#   end
#
# The tables for these classes could look something like:
#
#   CREATE TABLE users (
#     id bigint NOT NULL auto_increment,
#     account_id bigint default NULL,
#     name varchar default NULL,
#     PRIMARY KEY  (id)
#   )
#
#   CREATE TABLE accounts (
#     id bigint NOT NULL auto_increment,
#     name varchar default NULL,
#     PRIMARY KEY  (id)
#   )
#
# == Unsaved objects and associations
#
# You can manipulate objects and associations before they are saved to the database, but
# there is some special behavior you should be aware of, mostly involving the saving of
# associated objects.
#
# You can set the <tt>:autosave</tt> option on a #has_one, #belongs_to,
# #has_many, or #has_and_belongs_to_many association. Setting it
# to +true+ will _always_ save the members, whereas setting it to +false+ will
# _never_ save the members. More details about <tt>:autosave</tt> option is available at
# AutosaveAssociation.
#
# === One-to-one associations
#
# * Assigning an object to a #has_one association automatically saves that object and
#   the object being replaced (if there is one), in order to update their foreign
#   keys - except if the parent object is unsaved (<tt>new_record? == true</tt>).
# * If either of these saves fail (due to one of the objects being invalid), an
#   ActiveRecord::RecordNotSaved exception is raised and the assignment is
#   cancelled.
# * If you wish to assign an object to a #has_one association without saving it,
#   use the <tt>#build_association</tt> method (documented below). The object being
#   replaced will still be saved to update its foreign key.
# * Assigning an object to a #belongs_to association does not save the object, since
#   the foreign key field belongs on the parent. It does not save the parent either.
#
# === Collections
#
# * Adding an object to a collection (#has_many or #has_and_belongs_to_many) automatically
#   saves that object, except if the parent object (the owner of the collection) is not yet
#   stored in the database.
# * If saving any of the objects being added to a collection (via <tt>push</tt> or similar)
#   fails, then <tt>push</tt> returns +false+.
# * If saving fails while replacing the collection (via <tt>association=</tt>), an
#   ActiveRecord::RecordNotSaved exception is raised and the assignment is
#   cancelled.
# * You can add an object to a collection without automatically saving it by using the
#   <tt>collection.build</tt> method (documented below).
# * All unsaved (<tt>new_record? == true</tt>) members of the collection are automatically
#   saved when the parent is saved.
#
# == Customizing the query
#
# \Associations are built from <tt>Relation</tt> objects, and you can use the Relation syntax
# to customize them. For example, to add a condition:
#
#   class Blog < ActiveRecord::Base
#     has_many :published_posts, -> { where(published: true) }, class_name: 'Post'
#   end
#
# Inside the <tt>-> { ... }</tt> block you can use all of the usual Relation methods.
#
# === Accessing the owner object
#
# Sometimes it is useful to have access to the owner object when building the query. The owner
# is passed as a parameter to the block. For example, the following association would find all
# events that occur on the user's birthday:
#
#   class User < ActiveRecord::Base
#     has_many :birthday_events, ->(user) { where(starts_on: user.birthday) }, class_name: 'Event'
#   end
#
# Note: Joining, eager loading and preloading of these associations is not possible.
# These operations happen before instance creation and the scope will be called with a +nil+ argument.
#
# == Association callbacks
#
# Similar to the normal callbacks that hook into the life cycle of an Active Record object,
# you can also define callbacks that get triggered when you add an object to or remove an
# object from an association collection.
#
#   class Project
#     has_and_belongs_to_many :developers, after_add: :evaluate_velocity
#
#     def evaluate_velocity(developer)
#       ...
#     end
#   end
#
# It's possible to stack callbacks by passing them as an array. Example:
#
#   class Project
#     has_and_belongs_to_many :developers,
#                             after_add: [:evaluate_velocity, Proc.new { |p, d| p.shipping_date = Time.now}]
#   end
#
# Possible callbacks are: +before_add+, +after_add+, +before_remove+ and +after_remove+.
#
# If any of the +before_add+ callbacks throw an exception, the object will not be
# added to the collection.
#
# Similarly, if any of the +before_remove+ callbacks throw an exception, the object
# will not be removed from the collection.
#
# == Association extensions
#
# The proxy objects that control the access to associations can be extended through anonymous
# modules. This is especially beneficial for adding new finders, creators, and other
# factory-type methods that are only used as part of this association.
#
#   class Account < ActiveRecord::Base
#     has_many :people do
#       def find_or_create_by_name(name)
#         first_name, last_name = name.split(" ", 2)
#         find_or_create_by(first_name: first_name, last_name: last_name)
#       end
#     end
#   end
#
#   person = Account.first.people.find_or_create_by_name("David Heinemeier Hansson")
#   person.first_name # => "David"
#   person.last_name  # => "Heinemeier Hansson"
#
# If you need to share the same extensions between many associations, you can use a named
# extension module.
#
#   module FindOrCreateByNameExtension
#     def find_or_create_by_name(name)
#       first_name, last_name = name.split(" ", 2)
#       find_or_create_by(first_name: first_name, last_name: last_name)
#     end
#   end
#
#   class Account < ActiveRecord::Base
#     has_many :people, -> { extending FindOrCreateByNameExtension }
#   end
#
#   class Company < ActiveRecord::Base
#     has_many :people, -> { extending FindOrCreateByNameExtension }
#   end
#
# Some extensions can only be made to work with knowledge of the association's internals.
# Extensions can access relevant state using the following methods (where +items+ is the
# name of the association):
#
# * <tt>record.association(:items).owner</tt> - Returns the object the association is part of.
# * <tt>record.association(:items).reflection</tt> - Returns the reflection object that describes the association.
# * <tt>record.association(:items).target</tt> - Returns the associated object for #belongs_to and #has_one, or
#   the collection of associated objects for #has_many and #has_and_belongs_to_many.
#
# However, inside the actual extension code, you will not have access to the <tt>record</tt> as
# above. In this case, you can access <tt>proxy_association</tt>. For example,
# <tt>record.association(:items)</tt> and <tt>record.items.proxy_association</tt> will return
# the same object, allowing you to make calls like <tt>proxy_association.owner</tt> inside
# association extensions.
#
# == Association Join Models
#
# Has Many associations can be configured with the <tt>:through</tt> option to use an
# explicit join model to retrieve the data. This operates similarly to a
# #has_and_belongs_to_many association. The advantage is that you're able to add validations,
# callbacks, and extra attributes on the join model. Consider the following schema:
#
#   class Author < ActiveRecord::Base
#     has_many :authorships
#     has_many :books, through: :authorships
#   end
#
#   class Authorship < ActiveRecord::Base
#     belongs_to :author
#     belongs_to :book
#   end
#
#   @author = Author.first
#   @author.authorships.collect { |a| a.book } # selects all books that the author's authorships belong to
#   @author.books                              # selects all books by using the Authorship join model
#
# You can also go through a #has_many association on the join model:
#
#   class Firm < ActiveRecord::Base
#     has_many   :clients
#     has_many   :invoices, through: :clients
#   end
#
#   class Client < ActiveRecord::Base
#     belongs_to :firm
#     has_many   :invoices
#   end
#
#   class Invoice < ActiveRecord::Base
#     belongs_to :client
#   end
#
#   @firm = Firm.first
#   @firm.clients.flat_map { |c| c.invoices } # select all invoices for all clients of the firm
#   @firm.invoices                            # selects all invoices by going through the Client join model
#
# Similarly you can go through a #has_one association on the join model:
#
#   class Group < ActiveRecord::Base
#     has_many   :users
#     has_many   :avatars, through: :users
#   end
#
#   class User < ActiveRecord::Base
#     belongs_to :group
#     has_one    :avatar
#   end
#
#   class Avatar < ActiveRecord::Base
#     belongs_to :user
#   end
#
#   @group = Group.first
#   @group.users.collect { |u| u.avatar }.compact # select all avatars for all users in the group
#   @group.avatars                                # selects all avatars by going through the User join model.
#
# An important caveat with going through #has_one or #has_many associations on the
# join model is that these associations are *read-only*. For example, the following
# would not work following the previous example:
#
#   @group.avatars << Avatar.new   # this would work if User belonged_to Avatar rather than the other way around
#   @group.avatars.delete(@group.avatars.last)  # so would this
#
# == Setting Inverses
#
# If you are using a #belongs_to on the join model, it is a good idea to set the
# <tt>:inverse_of</tt> option on the #belongs_to, which will mean that the following example
# works correctly (where <tt>tags</tt> is a #has_many <tt>:through</tt> association):
#
#   @post = Post.first
#   @tag = @post.tags.build name: "ruby"
#   @tag.save
#
# The last line ought to save the through record (a <tt>Tagging</tt>). This will only work if the
# <tt>:inverse_of</tt> is set:
#
#   class Tagging < ActiveRecord::Base
#     belongs_to :post
#     belongs_to :tag, inverse_of: :taggings
#   end
#
# If you do not set the <tt>:inverse_of</tt> record, the association will
# do its best to match itself up with the correct inverse. Automatic
# inverse detection only works on #has_many, #has_one, and
# #belongs_to associations.
#
# <tt>:foreign_key</tt> and <tt>:through</tt> options on the associations,
# or a custom scope, will also prevent the association's inverse
# from being found automatically.
#
# The automatic guessing of the inverse association uses a heuristic based
# on the name of the class, so it may not work for all associations,
# especially the ones with non-standard names.
#
# You can turn off the automatic detection of inverse associations by setting
# the <tt>:inverse_of</tt> option to <tt>false</tt> like so:
#
#   class Tagging < ActiveRecord::Base
#     belongs_to :tag, inverse_of: false
#   end
#
# == Nested \Associations
#
# You can actually specify *any* association with the <tt>:through</tt> option, including an
# association which has a <tt>:through</tt> option itself. For example:
#
#   class Author < ActiveRecord::Base
#     has_many :posts
#     has_many :comments, through: :posts
#     has_many :commenters, through: :comments
#   end
#
#   class Post < ActiveRecord::Base
#     has_many :comments
#   end
#
#   class Comment < ActiveRecord::Base
#     belongs_to :commenter
#   end
#
#   @author = Author.first
#   @author.commenters # => People who commented on posts written by the author
#
# An equivalent way of setting up this association this would be:
#
#   class Author < ActiveRecord::Base
#     has_many :posts
#     has_many :commenters, through: :posts
#   end
#
#   class Post < ActiveRecord::Base
#     has_many :comments
#     has_many :commenters, through: :comments
#   end
#
#   class Comment < ActiveRecord::Base
#     belongs_to :commenter
#   end
#
# When using a nested association, you will not be able to modify the association because there
# is not enough information to know what modification to make. For example, if you tried to
# add a <tt>Commenter</tt> in the example above, there would be no way to tell how to set up the
# intermediate <tt>Post</tt> and <tt>Comment</tt> objects.
#
# == Polymorphic \Associations
#
# Polymorphic associations on models are not restricted on what types of models they
# can be associated with. Rather, they specify an interface that a #has_many association
# must adhere to.
#
#   class Asset < ActiveRecord::Base
#     belongs_to :attachable, polymorphic: true
#   end
#
#   class Post < ActiveRecord::Base
#     has_many :assets, as: :attachable         # The :as option specifies the polymorphic interface to use.
#   end
#
#   @asset.attachable = @post
#
# This works by using a type column in addition to a foreign key to specify the associated
# record. In the Asset example, you'd need an +attachable_id+ integer column and an
# +attachable_type+ string column.
#
# Using polymorphic associations in combination with single table inheritance (STI) is
# a little tricky. In order for the associations to work as expected, ensure that you
# store the base model for the STI models in the type column of the polymorphic
# association. To continue with the asset example above, suppose there are guest posts
# and member posts that use the posts table for STI. In this case, there must be a +type+
# column in the posts table.
#
# Note: The <tt>attachable_type=</tt> method is being called when assigning an +attachable+.
# The +class_name+ of the +attachable+ is passed as a String.
#
#   class Asset < ActiveRecord::Base
#     belongs_to :attachable, polymorphic: true
#
#     def attachable_type=(class_name)
#        super(class_name.constantize.base_class.to_s)
#     end
#   end
#
#   class Post < ActiveRecord::Base
#     # because we store "Post" in attachable_type now dependent: :destroy will work
#     has_many :assets, as: :attachable, dependent: :destroy
#   end
#
#   class GuestPost < Post
#   end
#
#   class MemberPost < Post
#   end
#
# == Caching
#
# All of the methods are built on a simple caching principle that will keep the result
# of the last query around unless specifically instructed not to. The cache is even
# shared across methods to make it even cheaper to use the macro-added methods without
# worrying too much about performance at the first go.
#
#   project.milestones             # fetches milestones from the database
#   project.milestones.size        # uses the milestone cache
#   project.milestones.empty?      # uses the milestone cache
#   project.milestones.reload.size # fetches milestones from the database
#   project.milestones             # uses the milestone cache
#
# == Eager loading of associations
#
# Eager loading is a way to find objects of a certain class and a number of named associations.
# It is one of the easiest ways to prevent the dreaded N+1 problem in which fetching 100
# posts that each need to display their author triggers 101 database queries. Through the
# use of eager loading, the number of queries will be reduced from 101 to 2.
#
#   class Post < ActiveRecord::Base
#     belongs_to :author
#     has_many   :comments
#   end
#
# Consider the following loop using the class above:
#
#   Post.all.each do |post|
#     puts "Post:            " + post.title
#     puts "Written by:      " + post.author.name
#     puts "Last comment on: " + post.comments.first.created_on
#   end
#
# To iterate over these one hundred posts, we'll generate 201 database queries. Let's
# first just optimize it for retrieving the author:
#
#   Post.includes(:author).each do |post|
#
# This references the name of the #belongs_to association that also used the <tt>:author</tt>
# symbol. After loading the posts, +find+ will collect the +author_id+ from each one and load
# all of the referenced authors with one query. Doing so will cut down the number of queries
# from 201 to 102.
#
# We can improve upon the situation further by referencing both associations in the finder with:
#
#   Post.includes(:author, :comments).each do |post|
#
# This will load all comments with a single query. This reduces the total number of queries
# to 3. In general, the number of queries will be 1 plus the number of associations
# named (except if some of the associations are polymorphic #belongs_to - see below).
#
# To include a deep hierarchy of associations, use a hash:
#
#   Post.includes(:author, { comments: { author: :gravatar } }).each do |post|
#
# The above code will load all the comments and all of their associated
# authors and gravatars. You can mix and match any combination of symbols,
# arrays, and hashes to retrieve the associations you want to load.
#
# All of this power shouldn't fool you into thinking that you can pull out huge amounts
# of data with no performance penalty just because you've reduced the number of queries.
# The database still needs to send all the data to Active Record and it still needs to
# be processed. So it's no catch-all for performance problems, but it's a great way to
# cut down on the number of queries in a situation as the one described above.
#
# Since only one table is loaded at a time, conditions or orders cannot reference tables
# other than the main one. If this is the case, Active Record falls back to the previously
# used <tt>LEFT OUTER JOIN</tt> based strategy. For example:
#
#   Post.includes([:author, :comments]).where(['comments.approved = ?', true])
#
# This will result in a single SQL query with joins along the lines of:
# <tt>LEFT OUTER JOIN comments ON comments.post_id = posts.id</tt> and
# <tt>LEFT OUTER JOIN authors ON authors.id = posts.author_id</tt>. Note that using conditions
# like this can have unintended consequences.
# In the above example, posts with no approved comments are not returned at all because
# the conditions apply to the SQL statement as a whole and not just to the association.
#
# You must disambiguate column references for this fallback to happen, for example
# <tt>order: "author.name DESC"</tt> will work but <tt>order: "name DESC"</tt> will not.
#
# If you want to load all posts (including posts with no approved comments), then write
# your own <tt>LEFT OUTER JOIN</tt> query using <tt>ON</tt>:
#
#   Post.joins("LEFT OUTER JOIN comments ON comments.post_id = posts.id AND comments.approved = '1'")
#
# In this case, it is usually more natural to include an association which has conditions defined on it:
#
#   class Post < ActiveRecord::Base
#     has_many :approved_comments, -> { where(approved: true) }, class_name: 'Comment'
#   end
#
#   Post.includes(:approved_comments)
#
# This will load posts and eager load the +approved_comments+ association, which contains
# only those comments that have been approved.
#
# If you eager load an association with a specified <tt>:limit</tt> option, it will be ignored,
# returning all the associated objects:
#
#   class Picture < ActiveRecord::Base
#     has_many :most_recent_comments, -> { order('id DESC').limit(10) }, class_name: 'Comment'
#   end
#
#   Picture.includes(:most_recent_comments).first.most_recent_comments # => returns all associated comments.
#
# Eager loading is supported with polymorphic associations.
#
#   class Address < ActiveRecord::Base
#     belongs_to :addressable, polymorphic: true
#   end
#
# A call that tries to eager load the addressable model
#
#   Address.includes(:addressable)
#
# This will execute one query to load the addresses and load the addressables with one
# query per addressable type.
# For example, if all the addressables are either of class Person or Company, then a total
# of 3 queries will be executed. The list of addressable types to load is determined on
# the back of the addresses loaded. This is not supported if Active Record has to fallback
# to the previous implementation of eager loading and will raise ActiveRecord::EagerLoadPolymorphicError.
# The reason is that the parent model's type is a column value so its corresponding table
# name cannot be put in the +FROM+/+JOIN+ clauses of that query.
#
# == Table Aliasing
#
# Active Record uses table aliasing in the case that a table is referenced multiple times
# in a join. If a table is referenced only once, the standard table name is used. The
# second time, the table is aliased as <tt>#{reflection_name}_#{parent_table_name}</tt>.
# Indexes are appended for any more successive uses of the table name.
#
#   Post.joins(:comments)
#   # => SELECT ... FROM posts INNER JOIN comments ON ...
#   Post.joins(:special_comments) # STI
#   # => SELECT ... FROM posts INNER JOIN comments ON ... AND comments.type = 'SpecialComment'
#   Post.joins(:comments, :special_comments) # special_comments is the reflection name, posts is the parent table name
#   # => SELECT ... FROM posts INNER JOIN comments ON ... INNER JOIN comments special_comments_posts
#
# Acts as tree example:
#
#   TreeMixin.joins(:children)
#   # => SELECT ... FROM mixins INNER JOIN mixins childrens_mixins ...
#   TreeMixin.joins(children: :parent)
#   # => SELECT ... FROM mixins INNER JOIN mixins childrens_mixins ...
#                               INNER JOIN parents_mixins ...
#   TreeMixin.joins(children: {parent: :children})
#   # => SELECT ... FROM mixins INNER JOIN mixins childrens_mixins ...
#                               INNER JOIN parents_mixins ...
#                               INNER JOIN mixins childrens_mixins_2
#
# Has and Belongs to Many join tables use the same idea, but add a <tt>_join</tt> suffix:
#
#   Post.joins(:categories)
#   # => SELECT ... FROM posts INNER JOIN categories_posts ... INNER JOIN categories ...
#   Post.joins(categories: :posts)
#   # => SELECT ... FROM posts INNER JOIN categories_posts ... INNER JOIN categories ...
#                              INNER JOIN categories_posts posts_categories_join INNER JOIN posts posts_categories
#   Post.joins(categories: {posts: :categories})
#   # => SELECT ... FROM posts INNER JOIN categories_posts ... INNER JOIN categories ...
#                              INNER JOIN categories_posts posts_categories_join INNER JOIN posts posts_categories
#                              INNER JOIN categories_posts categories_posts_join INNER JOIN categories categories_posts_2
#
# If you wish to specify your own custom joins using ActiveRecord::QueryMethods#joins method, those table
# names will take precedence over the eager associations:
#
#   Post.joins(:comments).joins("inner join comments ...")
#   # => SELECT ... FROM posts INNER JOIN comments_posts ON ... INNER JOIN comments ...
#   Post.joins(:comments, :special_comments).joins("inner join comments ...")
#   # => SELECT ... FROM posts INNER JOIN comments comments_posts ON ...
#                              INNER JOIN comments special_comments_posts ...
#                              INNER JOIN comments ...
#
# Table aliases are automatically truncated according to the maximum length of table identifiers
# according to the specific database.
#
# == Modules
#
# By default, associations will look for objects within the current module scope. Consider:
#
#   module MyApplication
#     module Business
#       class Firm < ActiveRecord::Base
#         has_many :clients
#       end
#
#       class Client < ActiveRecord::Base; end
#     end
#   end
#
# When <tt>Firm#clients</tt> is called, it will in turn call
# <tt>MyApplication::Business::Client.find_all_by_firm_id(firm.id)</tt>.
# If you want to associate with a class in another module scope, this can be done by
# specifying the complete class name.
#
#   module MyApplication
#     module Business
#       class Firm < ActiveRecord::Base; end
#     end
#
#     module Billing
#       class Account < ActiveRecord::Base
#         belongs_to :firm, class_name: "MyApplication::Business::Firm"
#       end
#     end
#   end
#
# == Bi-directional associations
#
# When you specify an association, there is usually an association on the associated model
# that specifies the same relationship in reverse. For example, with the following models:
#
#    class Dungeon < ActiveRecord::Base
#      has_many :traps
#      has_one :evil_wizard
#    end
#
#    class Trap < ActiveRecord::Base
#      belongs_to :dungeon
#    end
#
#    class EvilWizard < ActiveRecord::Base
#      belongs_to :dungeon
#    end
#
# The +traps+ association on +Dungeon+ and the +dungeon+ association on +Trap+ are
# the inverse of each other, and the inverse of the +dungeon+ association on +EvilWizard+
# is the +evil_wizard+ association on +Dungeon+ (and vice-versa). By default,
# Active Record can guess the inverse of the association based on the name
# of the class. The result is the following:
#
#    d = Dungeon.first
#    t = d.traps.first
#    d.object_id == t.dungeon.object_id # => true
#
# The +Dungeon+ instances +d+ and <tt>t.dungeon</tt> in the above example refer to
# the same in-memory instance since the association matches the name of the class.
# The result would be the same if we added +:inverse_of+ to our model definitions:
#
#    class Dungeon < ActiveRecord::Base
#      has_many :traps, inverse_of: :dungeon
#      has_one :evil_wizard, inverse_of: :dungeon
#    end
#
#    class Trap < ActiveRecord::Base
#      belongs_to :dungeon, inverse_of: :traps
#    end
#
#    class EvilWizard < ActiveRecord::Base
#      belongs_to :dungeon, inverse_of: :evil_wizard
#    end
#
# For more information, see the documentation for the +:inverse_of+ option.
#
# == Deleting from associations
#
# === Dependent associations
#
# #has_many, #has_one, and #belongs_to associations support the <tt>:dependent</tt> option.
# This allows you to specify that associated records should be deleted when the owner is
# deleted.
#
# For example:
#
#     class Author
#       has_many :posts, dependent: :destroy
#     end
#     Author.find(1).destroy # => Will destroy all of the author's posts, too
#
# The <tt>:dependent</tt> option can have different values which specify how the deletion
# is done. For more information, see the documentation for this option on the different
# specific association types. When no option is given, the behavior is to do nothing
# with the associated records when destroying a record.
#
# Note that <tt>:dependent</tt> is implemented using Rails' callback
# system, which works by processing callbacks in order. Therefore, other
# callbacks declared either before or after the <tt>:dependent</tt> option
# can affect what it does.
#
# Note that <tt>:dependent</tt> option is ignored for #has_one <tt>:through</tt> associations.
#
# === Delete or destroy?
#
# #has_many and #has_and_belongs_to_many associations have the methods <tt>destroy</tt>,
# <tt>delete</tt>, <tt>destroy_all</tt> and <tt>delete_all</tt>.
#
# For #has_and_belongs_to_many, <tt>delete</tt> and <tt>destroy</tt> are the same: they
# cause the records in the join table to be removed.
#
# For #has_many, <tt>destroy</tt> and <tt>destroy_all</tt> will always call the <tt>destroy</tt> method of the
# record(s) being removed so that callbacks are run. However <tt>delete</tt> and <tt>delete_all</tt> will either
# do the deletion according to the strategy specified by the <tt>:dependent</tt> option, or
# if no <tt>:dependent</tt> option is given, then it will follow the default strategy.
# The default strategy is to do nothing (leave the foreign keys with the parent ids set), except for
# #has_many <tt>:through</tt>, where the default strategy is <tt>delete_all</tt> (delete
# the join records, without running their callbacks).
#
# There is also a <tt>clear</tt> method which is the same as <tt>delete_all</tt>, except that
# it returns the association rather than the records which have been deleted.
#
# === What gets deleted?
#
# There is a potential pitfall here: #has_and_belongs_to_many and #has_many <tt>:through</tt>
# associations have records in join tables, as well as the associated records. So when we
# call one of these deletion methods, what exactly should be deleted?
#
# The answer is that it is assumed that deletion on an association is about removing the
# <i>link</i> between the owner and the associated object(s), rather than necessarily the
# associated objects themselves. So with #has_and_belongs_to_many and #has_many
# <tt>:through</tt>, the join records will be deleted, but the associated records won't.
#
# This makes sense if you think about it: if you were to call <tt>post.tags.delete(Tag.find_by(name: 'food'))</tt>
# you would want the 'food' tag to be unlinked from the post, rather than for the tag itself
# to be removed from the database.
#
# However, there are examples where this strategy doesn't make sense. For example, suppose
# a person has many projects, and each project has many tasks. If we deleted one of a person's
# tasks, we would probably not want the project to be deleted. In this scenario, the delete method
# won't actually work: it can only be used if the association on the join model is a
# #belongs_to. In other situations you are expected to perform operations directly on
# either the associated records or the <tt>:through</tt> association.
#
# With a regular #has_many there is no distinction between the "associated records"
# and the "link", so there is only one choice for what gets deleted.
#
# With #has_and_belongs_to_many and #has_many <tt>:through</tt>, if you want to delete the
# associated records themselves, you can always do something along the lines of
# <tt>person.tasks.each(&:destroy)</tt>.
#
# == Type safety with ActiveRecord::AssociationTypeMismatch
#
# If you attempt to assign an object to an association that doesn't match the inferred
# or specified <tt>:class_name</tt>, you'll get an ActiveRecord::AssociationTypeMismatch.
#
# == Options
#
# All of the association macros can be specialized through options. This makes cases
# more complex than the simple and guessable ones possible.
module ActiveRecord::Associations::ClassMethods
  # Specifies a one-to-one association with another class. This method should only be used
  # if this class contains the foreign key. If the other class contains the foreign key,
  # then you should use #has_one instead. See also ActiveRecord::Associations::ClassMethods's overview
  # on when to use #has_one and when to use #belongs_to.
  #
  # Methods will be added for retrieval and query for a single associated object, for which
  # this object holds an id:
  #
  # +association+ is a placeholder for the symbol passed as the +name+ argument, so
  # <tt>belongs_to :author</tt> would add among others <tt>author.nil?</tt>.
  #
  # [association]
  #   Returns the associated object. +nil+ is returned if none is found.
  # [association=(associate)]
  #   Assigns the associate object, extracts the primary key, and sets it as the foreign key.
  #   No modification or deletion of existing records takes place.
  # [build_association(attributes = {})]
  #   Returns a new object of the associated type that has been instantiated
  #   with +attributes+ and linked to this object through a foreign key, but has not yet been saved.
  # [create_association(attributes = {})]
  #   Returns a new object of the associated type that has been instantiated
  #   with +attributes+, linked to this object through a foreign key, and that
  #   has already been saved (if it passed the validation).
  # [create_association!(attributes = {})]
  #   Does the same as <tt>create_association</tt>, but raises ActiveRecord::RecordInvalid
  #   if the record is invalid.
  # [reload_association]
  #   Returns the associated object, forcing a database read.
  #
  # === Example
  #
  # A Post class declares <tt>belongs_to :author</tt>, which will add:
  # * <tt>Post#author</tt> (similar to <tt>Author.find(author_id)</tt>)
  # * <tt>Post#author=(author)</tt> (similar to <tt>post.author_id = author.id</tt>)
  # * <tt>Post#build_author</tt> (similar to <tt>post.author = Author.new</tt>)
  # * <tt>Post#create_author</tt> (similar to <tt>post.author = Author.new; post.author.save; post.author</tt>)
  # * <tt>Post#create_author!</tt> (similar to <tt>post.author = Author.new; post.author.save!; post.author</tt>)
  # * <tt>Post#reload_author</tt>
  # The declaration can also include an +options+ hash to specialize the behavior of the association.
  #
  # === Scopes
  #
  # You can pass a second argument +scope+ as a callable (i.e. proc or
  # lambda) to retrieve a specific record or customize the generated query
  # when you access the associated object.
  #
  # Scope examples:
  #   belongs_to :firm, -> { where(id: 2) }
  #   belongs_to :user, -> { joins(:friends) }
  #   belongs_to :level, ->(game) { where("game_level > ?", game.current_level) }
  #
  # === Options
  #
  # [:class_name]
  #   Specify the class name of the association. Use it only if that name can't be inferred
  #   from the association name. So <tt>belongs_to :author</tt> will by default be linked to the Author class, but
  #   if the real class name is Person, you'll have to specify it with this option.
  # [:foreign_key]
  #   Specify the foreign key used for the association. By default this is guessed to be the name
  #   of the association with an "_id" suffix. So a class that defines a <tt>belongs_to :person</tt>
  #   association will use "person_id" as the default <tt>:foreign_key</tt>. Similarly,
  #   <tt>belongs_to :favorite_person, class_name: "Person"</tt> will use a foreign key
  #   of "favorite_person_id".
  #
  #   If you are going to modify the association (rather than just read from it), then it is
  #   a good idea to set the <tt>:inverse_of</tt> option.
  # [:foreign_type]
  #   Specify the column used to store the associated object's type, if this is a polymorphic
  #   association. By default this is guessed to be the name of the association with a "_type"
  #   suffix. So a class that defines a <tt>belongs_to :taggable, polymorphic: true</tt>
  #   association will use "taggable_type" as the default <tt>:foreign_type</tt>.
  # [:primary_key]
  #   Specify the method that returns the primary key of associated object used for the association.
  #   By default this is +id+.
  # [:dependent]
  #   If set to <tt>:destroy</tt>, the associated object is destroyed when this object is. If set to
  #   <tt>:delete</tt>, the associated object is deleted *without* calling its destroy method. If set to
  #   <tt>:destroy_async</tt>, the associated object is scheduled to be destroyed in a background job.
  #   This option should not be specified when #belongs_to is used in conjunction with
  #   a #has_many relationship on another class because of the potential to leave
  #   orphaned records behind.
  # [:counter_cache]
  #   Caches the number of belonging objects on the associate class through the use of CounterCache::ClassMethods#increment_counter
  #   and CounterCache::ClassMethods#decrement_counter. The counter cache is incremented when an object of this
  #   class is created and decremented when it's destroyed. This requires that a column
  #   named <tt>#{table_name}_count</tt> (such as +comments_count+ for a belonging Comment class)
  #   is used on the associate class (such as a Post class) - that is the migration for
  #   <tt>#{table_name}_count</tt> is created on the associate class (such that <tt>Post.comments_count</tt> will
  #   return the count cached, see note below). You can also specify a custom counter
  #   cache column by providing a column name instead of a +true+/+false+ value to this
  #   option (e.g., <tt>counter_cache: :my_custom_counter</tt>.)
  #   Note: Specifying a counter cache will add it to that model's list of readonly attributes
  #   using +attr_readonly+.
  # [:polymorphic]
  #   Specify this association is a polymorphic association by passing +true+.
  #   Note: If you've enabled the counter cache, then you may want to add the counter cache attribute
  #   to the +attr_readonly+ list in the associated classes (e.g. <tt>class Post; attr_readonly :comments_count; end</tt>).
  # [:validate]
  #   When set to +true+, validates new objects added to association when saving the parent object. +false+ by default.
  #   If you want to ensure associated objects are revalidated on every update, use +validates_associated+.
  # [:autosave]
  #   If true, always save the associated object or destroy it if marked for destruction, when
  #   saving the parent object.
  #   If false, never save or destroy the associated object.
  #   By default, only save the associated object if it's a new record.
  #
  #   Note that NestedAttributes::ClassMethods#accepts_nested_attributes_for
  #   sets <tt>:autosave</tt> to <tt>true</tt>.
  # [:touch]
  #   If true, the associated object will be touched (the updated_at/on attributes set to current time)
  #   when this record is either saved or destroyed. If you specify a symbol, that attribute
  #   will be updated with the current time in addition to the updated_at/on attribute.
  #   Please note that with touching no validation is performed and only the +after_touch+,
  #   +after_commit+ and +after_rollback+ callbacks are executed.
  # [:inverse_of]
  #   Specifies the name of the #has_one or #has_many association on the associated
  #   object that is the inverse of this #belongs_to association.
  #   See ActiveRecord::Associations::ClassMethods's overview on Bi-directional associations for more detail.
  # [:optional]
  #   When set to +true+, the association will not have its presence validated.
  # [:required]
  #   When set to +true+, the association will also have its presence validated.
  #   This will validate the association itself, not the id. You can use
  #   +:inverse_of+ to avoid an extra query during validation.
  #   NOTE: <tt>required</tt> is set to <tt>true</tt> by default and is deprecated. If
  #   you don't want to have association presence validated, use <tt>optional: true</tt>.
  # [:default]
  #   Provide a callable (i.e. proc or lambda) to specify that the association should
  #   be initialized with a particular record before validation.
  # [:strict_loading]
  #   Enforces strict loading every time the associated record is loaded through this association.
  # [:ensuring_owner_was]
  #   Specifies an instance method to be called on the owner. The method must return true in order for the
  #   associated records to be deleted in a background job.
  #
  # Option examples:
  #   belongs_to :firm, foreign_key: "client_of"
  #   belongs_to :person, primary_key: "name", foreign_key: "person_name"
  #   belongs_to :author, class_name: "Person", foreign_key: "author_id"
  #   belongs_to :valid_coupon, ->(o) { where "discounts > ?", o.payments_count },
  #                             class_name: "Coupon", foreign_key: "coupon_id"
  #   belongs_to :attachable, polymorphic: true
  #   belongs_to :project, -> { readonly }
  #   belongs_to :post, counter_cache: true
  #   belongs_to :comment, touch: true
  #   belongs_to :company, touch: :employees_last_updated_at
  #   belongs_to :user, optional: true
  #   belongs_to :account, default: -> { company.account }
  #   belongs_to :account, strict_loading: true
  def belongs_to(name, scope = T.unsafe(nil), **options); end

  # Specifies a many-to-many relationship with another class. This associates two classes via an
  # intermediate join table. Unless the join table is explicitly specified as an option, it is
  # guessed using the lexical order of the class names. So a join between Developer and Project
  # will give the default join table name of "developers_projects" because "D" precedes "P" alphabetically.
  # Note that this precedence is calculated using the <tt><</tt> operator for String. This
  # means that if the strings are of different lengths, and the strings are equal when compared
  # up to the shortest length, then the longer string is considered of higher
  # lexical precedence than the shorter one. For example, one would expect the tables "paper_boxes" and "papers"
  # to generate a join table name of "papers_paper_boxes" because of the length of the name "paper_boxes",
  # but it in fact generates a join table name of "paper_boxes_papers". Be aware of this caveat, and use the
  # custom <tt>:join_table</tt> option if you need to.
  # If your tables share a common prefix, it will only appear once at the beginning. For example,
  # the tables "catalog_categories" and "catalog_products" generate a join table name of "catalog_categories_products".
  #
  # The join table should not have a primary key or a model associated with it. You must manually generate the
  # join table with a migration such as this:
  #
  #   class CreateDevelopersProjectsJoinTable < ActiveRecord::Migration[6.0]
  #     def change
  #       create_join_table :developers, :projects
  #     end
  #   end
  #
  # It's also a good idea to add indexes to each of those columns to speed up the joins process.
  # However, in MySQL it is advised to add a compound index for both of the columns as MySQL only
  # uses one index per table during the lookup.
  #
  # Adds the following methods for retrieval and query:
  #
  # +collection+ is a placeholder for the symbol passed as the +name+ argument, so
  # <tt>has_and_belongs_to_many :categories</tt> would add among others <tt>categories.empty?</tt>.
  #
  # [collection]
  #   Returns a Relation of all the associated objects.
  #   An empty Relation is returned if none are found.
  # [collection<<(object, ...)]
  #   Adds one or more objects to the collection by creating associations in the join table
  #   (<tt>collection.push</tt> and <tt>collection.concat</tt> are aliases to this method).
  #   Note that this operation instantly fires update SQL without waiting for the save or update call on the
  #   parent object, unless the parent object is a new record.
  # [collection.delete(object, ...)]
  #   Removes one or more objects from the collection by removing their associations from the join table.
  #   This does not destroy the objects.
  # [collection.destroy(object, ...)]
  #   Removes one or more objects from the collection by running destroy on each association in the join table, overriding any dependent option.
  #   This does not destroy the objects.
  # [collection=objects]
  #   Replaces the collection's content by deleting and adding objects as appropriate.
  # [collection_singular_ids]
  #   Returns an array of the associated objects' ids.
  # [collection_singular_ids=ids]
  #   Replace the collection by the objects identified by the primary keys in +ids+.
  # [collection.clear]
  #   Removes every object from the collection. This does not destroy the objects.
  # [collection.empty?]
  #   Returns +true+ if there are no associated objects.
  # [collection.size]
  #   Returns the number of associated objects.
  # [collection.find(id)]
  #   Finds an associated object responding to the +id+ and that
  #   meets the condition that it has to be associated with this object.
  #   Uses the same rules as ActiveRecord::FinderMethods#find.
  # [collection.exists?(...)]
  #   Checks whether an associated object with the given conditions exists.
  #   Uses the same rules as ActiveRecord::FinderMethods#exists?.
  # [collection.build(attributes = {})]
  #   Returns a new object of the collection type that has been instantiated
  #   with +attributes+ and linked to this object through the join table, but has not yet been saved.
  # [collection.create(attributes = {})]
  #   Returns a new object of the collection type that has been instantiated
  #   with +attributes+, linked to this object through the join table, and that has already been
  #   saved (if it passed the validation).
  # [collection.reload]
  #   Returns a Relation of all of the associated objects, forcing a database read.
  #   An empty Relation is returned if none are found.
  #
  # === Example
  #
  # A Developer class declares <tt>has_and_belongs_to_many :projects</tt>, which will add:
  # * <tt>Developer#projects</tt>
  # * <tt>Developer#projects<<</tt>
  # * <tt>Developer#projects.delete</tt>
  # * <tt>Developer#projects.destroy</tt>
  # * <tt>Developer#projects=</tt>
  # * <tt>Developer#project_ids</tt>
  # * <tt>Developer#project_ids=</tt>
  # * <tt>Developer#projects.clear</tt>
  # * <tt>Developer#projects.empty?</tt>
  # * <tt>Developer#projects.size</tt>
  # * <tt>Developer#projects.find(id)</tt>
  # * <tt>Developer#projects.exists?(...)</tt>
  # * <tt>Developer#projects.build</tt> (similar to <tt>Project.new(developer_id: id)</tt>)
  # * <tt>Developer#projects.create</tt> (similar to <tt>c = Project.new(developer_id: id); c.save; c</tt>)
  # * <tt>Developer#projects.reload</tt>
  # The declaration may include an +options+ hash to specialize the behavior of the association.
  #
  # === Scopes
  #
  # You can pass a second argument +scope+ as a callable (i.e. proc or
  # lambda) to retrieve a specific set of records or customize the generated
  # query when you access the associated collection.
  #
  # Scope examples:
  #   has_and_belongs_to_many :projects, -> { includes(:milestones, :manager) }
  #   has_and_belongs_to_many :categories, ->(post) {
  #     where("default_category = ?", post.default_category)
  #   }
  #
  # === Extensions
  #
  # The +extension+ argument allows you to pass a block into a
  # has_and_belongs_to_many association. This is useful for adding new
  # finders, creators and other factory-type methods to be used as part of
  # the association.
  #
  # Extension examples:
  #   has_and_belongs_to_many :contractors do
  #     def find_or_create_by_name(name)
  #       first_name, last_name = name.split(" ", 2)
  #       find_or_create_by(first_name: first_name, last_name: last_name)
  #     end
  #   end
  #
  # === Options
  #
  # [:class_name]
  #   Specify the class name of the association. Use it only if that name can't be inferred
  #   from the association name. So <tt>has_and_belongs_to_many :projects</tt> will by default be linked to the
  #   Project class, but if the real class name is SuperProject, you'll have to specify it with this option.
  # [:join_table]
  #   Specify the name of the join table if the default based on lexical order isn't what you want.
  #   <b>WARNING:</b> If you're overwriting the table name of either class, the +table_name+ method
  #   MUST be declared underneath any #has_and_belongs_to_many declaration in order to work.
  # [:foreign_key]
  #   Specify the foreign key used for the association. By default this is guessed to be the name
  #   of this class in lower-case and "_id" suffixed. So a Person class that makes
  #   a #has_and_belongs_to_many association to Project will use "person_id" as the
  #   default <tt>:foreign_key</tt>.
  #
  #   If you are going to modify the association (rather than just read from it), then it is
  #   a good idea to set the <tt>:inverse_of</tt> option.
  # [:association_foreign_key]
  #   Specify the foreign key used for the association on the receiving side of the association.
  #   By default this is guessed to be the name of the associated class in lower-case and "_id" suffixed.
  #   So if a Person class makes a #has_and_belongs_to_many association to Project,
  #   the association will use "project_id" as the default <tt>:association_foreign_key</tt>.
  # [:validate]
  #   When set to +true+, validates new objects added to association when saving the parent object. +true+ by default.
  #   If you want to ensure associated objects are revalidated on every update, use +validates_associated+.
  # [:autosave]
  #   If true, always save the associated objects or destroy them if marked for destruction, when
  #   saving the parent object.
  #   If false, never save or destroy the associated objects.
  #   By default, only save associated objects that are new records.
  #
  #   Note that NestedAttributes::ClassMethods#accepts_nested_attributes_for sets
  #   <tt>:autosave</tt> to <tt>true</tt>.
  # [:strict_loading]
  #   Enforces strict loading every time an associated record is loaded through this association.
  #
  # Option examples:
  #   has_and_belongs_to_many :projects
  #   has_and_belongs_to_many :projects, -> { includes(:milestones, :manager) }
  #   has_and_belongs_to_many :nations, class_name: "Country"
  #   has_and_belongs_to_many :categories, join_table: "prods_cats"
  #   has_and_belongs_to_many :categories, -> { readonly }
  #   has_and_belongs_to_many :categories, strict_loading: true
  def has_and_belongs_to_many(name, scope = T.unsafe(nil), **options, &extension); end

  # Specifies a one-to-many association. The following methods for retrieval and query of
  # collections of associated objects will be added:
  #
  # +collection+ is a placeholder for the symbol passed as the +name+ argument, so
  # <tt>has_many :clients</tt> would add among others <tt>clients.empty?</tt>.
  #
  # [collection]
  #   Returns a Relation of all the associated objects.
  #   An empty Relation is returned if none are found.
  # [collection<<(object, ...)]
  #   Adds one or more objects to the collection by setting their foreign keys to the collection's primary key.
  #   Note that this operation instantly fires update SQL without waiting for the save or update call on the
  #   parent object, unless the parent object is a new record.
  #   This will also run validations and callbacks of associated object(s).
  # [collection.delete(object, ...)]
  #   Removes one or more objects from the collection by setting their foreign keys to +NULL+.
  #   Objects will be in addition destroyed if they're associated with <tt>dependent: :destroy</tt>,
  #   and deleted if they're associated with <tt>dependent: :delete_all</tt>.
  #
  #   If the <tt>:through</tt> option is used, then the join records are deleted (rather than
  #   nullified) by default, but you can specify <tt>dependent: :destroy</tt> or
  #   <tt>dependent: :nullify</tt> to override this.
  # [collection.destroy(object, ...)]
  #   Removes one or more objects from the collection by running <tt>destroy</tt> on
  #   each record, regardless of any dependent option, ensuring callbacks are run.
  #
  #   If the <tt>:through</tt> option is used, then the join records are destroyed
  #   instead, not the objects themselves.
  # [collection=objects]
  #   Replaces the collections content by deleting and adding objects as appropriate. If the <tt>:through</tt>
  #   option is true callbacks in the join models are triggered except destroy callbacks, since deletion is
  #   direct by default. You can specify <tt>dependent: :destroy</tt> or
  #   <tt>dependent: :nullify</tt> to override this.
  # [collection_singular_ids]
  #   Returns an array of the associated objects' ids
  # [collection_singular_ids=ids]
  #   Replace the collection with the objects identified by the primary keys in +ids+. This
  #   method loads the models and calls <tt>collection=</tt>. See above.
  # [collection.clear]
  #   Removes every object from the collection. This destroys the associated objects if they
  #   are associated with <tt>dependent: :destroy</tt>, deletes them directly from the
  #   database if <tt>dependent: :delete_all</tt>, otherwise sets their foreign keys to +NULL+.
  #   If the <tt>:through</tt> option is true no destroy callbacks are invoked on the join models.
  #   Join models are directly deleted.
  # [collection.empty?]
  #   Returns +true+ if there are no associated objects.
  # [collection.size]
  #   Returns the number of associated objects.
  # [collection.find(...)]
  #   Finds an associated object according to the same rules as ActiveRecord::FinderMethods#find.
  # [collection.exists?(...)]
  #   Checks whether an associated object with the given conditions exists.
  #   Uses the same rules as ActiveRecord::FinderMethods#exists?.
  # [collection.build(attributes = {}, ...)]
  #   Returns one or more new objects of the collection type that have been instantiated
  #   with +attributes+ and linked to this object through a foreign key, but have not yet
  #   been saved.
  # [collection.create(attributes = {})]
  #   Returns a new object of the collection type that has been instantiated
  #   with +attributes+, linked to this object through a foreign key, and that has already
  #   been saved (if it passed the validation). *Note*: This only works if the base model
  #   already exists in the DB, not if it is a new (unsaved) record!
  # [collection.create!(attributes = {})]
  #   Does the same as <tt>collection.create</tt>, but raises ActiveRecord::RecordInvalid
  #   if the record is invalid.
  # [collection.reload]
  #   Returns a Relation of all of the associated objects, forcing a database read.
  #   An empty Relation is returned if none are found.
  #
  # === Example
  #
  # A <tt>Firm</tt> class declares <tt>has_many :clients</tt>, which will add:
  # * <tt>Firm#clients</tt> (similar to <tt>Client.where(firm_id: id)</tt>)
  # * <tt>Firm#clients<<</tt>
  # * <tt>Firm#clients.delete</tt>
  # * <tt>Firm#clients.destroy</tt>
  # * <tt>Firm#clients=</tt>
  # * <tt>Firm#client_ids</tt>
  # * <tt>Firm#client_ids=</tt>
  # * <tt>Firm#clients.clear</tt>
  # * <tt>Firm#clients.empty?</tt> (similar to <tt>firm.clients.size == 0</tt>)
  # * <tt>Firm#clients.size</tt> (similar to <tt>Client.count "firm_id = #{id}"</tt>)
  # * <tt>Firm#clients.find</tt> (similar to <tt>Client.where(firm_id: id).find(id)</tt>)
  # * <tt>Firm#clients.exists?(name: 'ACME')</tt> (similar to <tt>Client.exists?(name: 'ACME', firm_id: firm.id)</tt>)
  # * <tt>Firm#clients.build</tt> (similar to <tt>Client.new(firm_id: id)</tt>)
  # * <tt>Firm#clients.create</tt> (similar to <tt>c = Client.new(firm_id: id); c.save; c</tt>)
  # * <tt>Firm#clients.create!</tt> (similar to <tt>c = Client.new(firm_id: id); c.save!</tt>)
  # * <tt>Firm#clients.reload</tt>
  # The declaration can also include an +options+ hash to specialize the behavior of the association.
  #
  # === Scopes
  #
  # You can pass a second argument +scope+ as a callable (i.e. proc or
  # lambda) to retrieve a specific set of records or customize the generated
  # query when you access the associated collection.
  #
  # Scope examples:
  #   has_many :comments, -> { where(author_id: 1) }
  #   has_many :employees, -> { joins(:address) }
  #   has_many :posts, ->(blog) { where("max_post_length > ?", blog.max_post_length) }
  #
  # === Extensions
  #
  # The +extension+ argument allows you to pass a block into a has_many
  # association. This is useful for adding new finders, creators and other
  # factory-type methods to be used as part of the association.
  #
  # Extension examples:
  #   has_many :employees do
  #     def find_or_create_by_name(name)
  #       first_name, last_name = name.split(" ", 2)
  #       find_or_create_by(first_name: first_name, last_name: last_name)
  #     end
  #   end
  #
  # === Options
  # [:class_name]
  #   Specify the class name of the association. Use it only if that name can't be inferred
  #   from the association name. So <tt>has_many :products</tt> will by default be linked
  #   to the +Product+ class, but if the real class name is +SpecialProduct+, you'll have to
  #   specify it with this option.
  # [:foreign_key]
  #   Specify the foreign key used for the association. By default this is guessed to be the name
  #   of this class in lower-case and "_id" suffixed. So a Person class that makes a #has_many
  #   association will use "person_id" as the default <tt>:foreign_key</tt>.
  #
  #   If you are going to modify the association (rather than just read from it), then it is
  #   a good idea to set the <tt>:inverse_of</tt> option.
  # [:foreign_type]
  #   Specify the column used to store the associated object's type, if this is a polymorphic
  #   association. By default this is guessed to be the name of the polymorphic association
  #   specified on "as" option with a "_type" suffix. So a class that defines a
  #   <tt>has_many :tags, as: :taggable</tt> association will use "taggable_type" as the
  #   default <tt>:foreign_type</tt>.
  # [:primary_key]
  #   Specify the name of the column to use as the primary key for the association. By default this is +id+.
  # [:dependent]
  #   Controls what happens to the associated objects when
  #   their owner is destroyed. Note that these are implemented as
  #   callbacks, and Rails executes callbacks in order. Therefore, other
  #   similar callbacks may affect the <tt>:dependent</tt> behavior, and the
  #   <tt>:dependent</tt> behavior may affect other callbacks.
  #
  #   * <tt>nil</tt> do nothing (default).
  #   * <tt>:destroy</tt> causes all the associated objects to also be destroyed.
  #   * <tt>:destroy_async</tt> destroys all the associated objects in a background job. <b>WARNING:</b> Do not use
  #     this option if the association is backed by foreign key constraints in your database. The foreign key
  #     constraint actions will occur inside the same transaction that deletes its owner.
  #   * <tt>:delete_all</tt> causes all the associated objects to be deleted directly from the database (so callbacks will not be executed).
  #   * <tt>:nullify</tt> causes the foreign keys to be set to +NULL+. Polymorphic type will also be nullified
  #     on polymorphic associations. Callbacks are not executed.
  #   * <tt>:restrict_with_exception</tt> causes an <tt>ActiveRecord::DeleteRestrictionError</tt> exception to be raised if there are any associated records.
  #   * <tt>:restrict_with_error</tt> causes an error to be added to the owner if there are any associated objects.
  #
  #   If using with the <tt>:through</tt> option, the association on the join model must be
  #   a #belongs_to, and the records which get deleted are the join records, rather than
  #   the associated records.
  #
  #   If using <tt>dependent: :destroy</tt> on a scoped association, only the scoped objects are destroyed.
  #   For example, if a Post model defines
  #   <tt>has_many :comments, -> { where published: true }, dependent: :destroy</tt> and <tt>destroy</tt> is
  #   called on a post, only published comments are destroyed. This means that any unpublished comments in the
  #   database would still contain a foreign key pointing to the now deleted post.
  # [:counter_cache]
  #   This option can be used to configure a custom named <tt>:counter_cache.</tt> You only need this option,
  #   when you customized the name of your <tt>:counter_cache</tt> on the #belongs_to association.
  # [:as]
  #   Specifies a polymorphic interface (See #belongs_to).
  # [:through]
  #   Specifies an association through which to perform the query. This can be any other type
  #   of association, including other <tt>:through</tt> associations. Options for <tt>:class_name</tt>,
  #   <tt>:primary_key</tt> and <tt>:foreign_key</tt> are ignored, as the association uses the
  #   source reflection.
  #
  #   If the association on the join model is a #belongs_to, the collection can be modified
  #   and the records on the <tt>:through</tt> model will be automatically created and removed
  #   as appropriate. Otherwise, the collection is read-only, so you should manipulate the
  #   <tt>:through</tt> association directly.
  #
  #   If you are going to modify the association (rather than just read from it), then it is
  #   a good idea to set the <tt>:inverse_of</tt> option on the source association on the
  #   join model. This allows associated records to be built which will automatically create
  #   the appropriate join model records when they are saved. (See the 'Association Join Models'
  #   section above.)
  # [:source]
  #   Specifies the source association name used by #has_many <tt>:through</tt> queries.
  #   Only use it if the name cannot be inferred from the association.
  #   <tt>has_many :subscribers, through: :subscriptions</tt> will look for either <tt>:subscribers</tt> or
  #   <tt>:subscriber</tt> on Subscription, unless a <tt>:source</tt> is given.
  # [:source_type]
  #   Specifies type of the source association used by #has_many <tt>:through</tt> queries where the source
  #   association is a polymorphic #belongs_to.
  # [:validate]
  #   When set to +true+, validates new objects added to association when saving the parent object. +true+ by default.
  #   If you want to ensure associated objects are revalidated on every update, use +validates_associated+.
  # [:autosave]
  #   If true, always save the associated objects or destroy them if marked for destruction,
  #   when saving the parent object. If false, never save or destroy the associated objects.
  #   By default, only save associated objects that are new records. This option is implemented as a
  #   +before_save+ callback. Because callbacks are run in the order they are defined, associated objects
  #   may need to be explicitly saved in any user-defined +before_save+ callbacks.
  #
  #   Note that NestedAttributes::ClassMethods#accepts_nested_attributes_for sets
  #   <tt>:autosave</tt> to <tt>true</tt>.
  # [:inverse_of]
  #   Specifies the name of the #belongs_to association on the associated object
  #   that is the inverse of this #has_many association.
  #   See ActiveRecord::Associations::ClassMethods's overview on Bi-directional associations for more detail.
  # [:extend]
  #   Specifies a module or array of modules that will be extended into the association object returned.
  #   Useful for defining methods on associations, especially when they should be shared between multiple
  #   association objects.
  # [:strict_loading]
  #   Enforces strict loading every time the associated record is loaded through this association.
  # [:ensuring_owner_was]
  #   Specifies an instance method to be called on the owner. The method must return true in order for the
  #   associated records to be deleted in a background job.
  #
  # Option examples:
  #   has_many :comments, -> { order("posted_on") }
  #   has_many :comments, -> { includes(:author) }
  #   has_many :people, -> { where(deleted: false).order("name") }, class_name: "Person"
  #   has_many :tracks, -> { order("position") }, dependent: :destroy
  #   has_many :comments, dependent: :nullify
  #   has_many :tags, as: :taggable
  #   has_many :reports, -> { readonly }
  #   has_many :subscribers, through: :subscriptions, source: :user
  #   has_many :comments, strict_loading: true
  def has_many(name, scope = T.unsafe(nil), **options, &extension); end

  # Specifies a one-to-one association with another class. This method should only be used
  # if the other class contains the foreign key. If the current class contains the foreign key,
  # then you should use #belongs_to instead. See also ActiveRecord::Associations::ClassMethods's overview
  # on when to use #has_one and when to use #belongs_to.
  #
  # The following methods for retrieval and query of a single associated object will be added:
  #
  # +association+ is a placeholder for the symbol passed as the +name+ argument, so
  # <tt>has_one :manager</tt> would add among others <tt>manager.nil?</tt>.
  #
  # [association]
  #   Returns the associated object. +nil+ is returned if none is found.
  # [association=(associate)]
  #   Assigns the associate object, extracts the primary key, sets it as the foreign key,
  #   and saves the associate object. To avoid database inconsistencies, permanently deletes an existing
  #   associated object when assigning a new one, even if the new one isn't saved to database.
  # [build_association(attributes = {})]
  #   Returns a new object of the associated type that has been instantiated
  #   with +attributes+ and linked to this object through a foreign key, but has not
  #   yet been saved.
  # [create_association(attributes = {})]
  #   Returns a new object of the associated type that has been instantiated
  #   with +attributes+, linked to this object through a foreign key, and that
  #   has already been saved (if it passed the validation).
  # [create_association!(attributes = {})]
  #   Does the same as <tt>create_association</tt>, but raises ActiveRecord::RecordInvalid
  #   if the record is invalid.
  # [reload_association]
  #   Returns the associated object, forcing a database read.
  #
  # === Example
  #
  # An Account class declares <tt>has_one :beneficiary</tt>, which will add:
  # * <tt>Account#beneficiary</tt> (similar to <tt>Beneficiary.where(account_id: id).first</tt>)
  # * <tt>Account#beneficiary=(beneficiary)</tt> (similar to <tt>beneficiary.account_id = account.id; beneficiary.save</tt>)
  # * <tt>Account#build_beneficiary</tt> (similar to <tt>Beneficiary.new(account_id: id)</tt>)
  # * <tt>Account#create_beneficiary</tt> (similar to <tt>b = Beneficiary.new(account_id: id); b.save; b</tt>)
  # * <tt>Account#create_beneficiary!</tt> (similar to <tt>b = Beneficiary.new(account_id: id); b.save!; b</tt>)
  # * <tt>Account#reload_beneficiary</tt>
  #
  # === Scopes
  #
  # You can pass a second argument +scope+ as a callable (i.e. proc or
  # lambda) to retrieve a specific record or customize the generated query
  # when you access the associated object.
  #
  # Scope examples:
  #   has_one :author, -> { where(comment_id: 1) }
  #   has_one :employer, -> { joins(:company) }
  #   has_one :latest_post, ->(blog) { where("created_at > ?", blog.enabled_at) }
  #
  # === Options
  #
  # The declaration can also include an +options+ hash to specialize the behavior of the association.
  #
  # Options are:
  # [:class_name]
  #   Specify the class name of the association. Use it only if that name can't be inferred
  #   from the association name. So <tt>has_one :manager</tt> will by default be linked to the Manager class, but
  #   if the real class name is Person, you'll have to specify it with this option.
  # [:dependent]
  #   Controls what happens to the associated object when
  #   its owner is destroyed:
  #
  #   * <tt>nil</tt> do nothing (default).
  #   * <tt>:destroy</tt> causes the associated object to also be destroyed
  #   * <tt>:destroy_async</tt> causes the associated object to be destroyed in a background job. <b>WARNING:</b> Do not use
  #     this option if the association is backed by foreign key constraints in your database. The foreign key
  #     constraint actions will occur inside the same transaction that deletes its owner.
  #   * <tt>:delete</tt> causes the associated object to be deleted directly from the database (so callbacks will not execute)
  #   * <tt>:nullify</tt> causes the foreign key to be set to +NULL+. Polymorphic type column is also nullified
  #     on polymorphic associations. Callbacks are not executed.
  #   * <tt>:restrict_with_exception</tt> causes an <tt>ActiveRecord::DeleteRestrictionError</tt> exception to be raised if there is an associated record
  #   * <tt>:restrict_with_error</tt> causes an error to be added to the owner if there is an associated object
  #
  #   Note that <tt>:dependent</tt> option is ignored when using <tt>:through</tt> option.
  # [:foreign_key]
  #   Specify the foreign key used for the association. By default this is guessed to be the name
  #   of this class in lower-case and "_id" suffixed. So a Person class that makes a #has_one association
  #   will use "person_id" as the default <tt>:foreign_key</tt>.
  #
  #   If you are going to modify the association (rather than just read from it), then it is
  #   a good idea to set the <tt>:inverse_of</tt> option.
  # [:foreign_type]
  #   Specify the column used to store the associated object's type, if this is a polymorphic
  #   association. By default this is guessed to be the name of the polymorphic association
  #   specified on "as" option with a "_type" suffix. So a class that defines a
  #   <tt>has_one :tag, as: :taggable</tt> association will use "taggable_type" as the
  #   default <tt>:foreign_type</tt>.
  # [:primary_key]
  #   Specify the method that returns the primary key used for the association. By default this is +id+.
  # [:as]
  #   Specifies a polymorphic interface (See #belongs_to).
  # [:through]
  #   Specifies a Join Model through which to perform the query. Options for <tt>:class_name</tt>,
  #   <tt>:primary_key</tt>, and <tt>:foreign_key</tt> are ignored, as the association uses the
  #   source reflection. You can only use a <tt>:through</tt> query through a #has_one
  #   or #belongs_to association on the join model.
  #
  #   If you are going to modify the association (rather than just read from it), then it is
  #   a good idea to set the <tt>:inverse_of</tt> option.
  # [:source]
  #   Specifies the source association name used by #has_one <tt>:through</tt> queries.
  #   Only use it if the name cannot be inferred from the association.
  #   <tt>has_one :favorite, through: :favorites</tt> will look for a
  #   <tt>:favorite</tt> on Favorite, unless a <tt>:source</tt> is given.
  # [:source_type]
  #   Specifies type of the source association used by #has_one <tt>:through</tt> queries where the source
  #   association is a polymorphic #belongs_to.
  # [:validate]
  #   When set to +true+, validates new objects added to association when saving the parent object. +false+ by default.
  #   If you want to ensure associated objects are revalidated on every update, use +validates_associated+.
  # [:autosave]
  #   If true, always save the associated object or destroy it if marked for destruction,
  #   when saving the parent object. If false, never save or destroy the associated object.
  #   By default, only save the associated object if it's a new record.
  #
  #   Note that NestedAttributes::ClassMethods#accepts_nested_attributes_for sets
  #   <tt>:autosave</tt> to <tt>true</tt>.
  # [:inverse_of]
  #   Specifies the name of the #belongs_to association on the associated object
  #   that is the inverse of this #has_one association.
  #   See ActiveRecord::Associations::ClassMethods's overview on Bi-directional associations for more detail.
  # [:required]
  #   When set to +true+, the association will also have its presence validated.
  #   This will validate the association itself, not the id. You can use
  #   +:inverse_of+ to avoid an extra query during validation.
  # [:strict_loading]
  #   Enforces strict loading every time the associated record is loaded through this association.
  # [:ensuring_owner_was]
  #   Specifies an instance method to be called on the owner. The method must return true in order for the
  #   associated records to be deleted in a background job.
  #
  # Option examples:
  #   has_one :credit_card, dependent: :destroy  # destroys the associated credit card
  #   has_one :credit_card, dependent: :nullify  # updates the associated records foreign
  #                                                 # key value to NULL rather than destroying it
  #   has_one :last_comment, -> { order('posted_on') }, class_name: "Comment"
  #   has_one :project_manager, -> { where(role: 'project_manager') }, class_name: "Person"
  #   has_one :attachment, as: :attachable
  #   has_one :boss, -> { readonly }
  #   has_one :club, through: :membership
  #   has_one :primary_address, -> { where(primary: true) }, through: :addressables, source: :addressable
  #   has_one :credit_card, required: true
  #   has_one :credit_card, strict_loading: true
  def has_one(name, scope = T.unsafe(nil), **options); end
end

# = Active Record Association Collection
#
# CollectionAssociation is an abstract class that provides common stuff to
# ease the implementation of association proxies that represent
# collections. See the class hierarchy in Association.
#
#   CollectionAssociation:
#     HasManyAssociation => has_many
#       HasManyThroughAssociation + ThroughAssociation => has_many :through
#
# The CollectionAssociation class provides common methods to the collections
# defined by +has_and_belongs_to_many+, +has_many+ or +has_many+ with
# the +:through association+ option.
#
# You need to be careful with assumptions regarding the target: The proxy
# does not fetch records from the database until it needs them, but new
# ones created with +build+ are added to the target. So, the target may be
# non-empty and still lack children waiting to be read from the database.
# If you look directly to the database you cannot assume that's the entire
# collection because new records may have been added to the target, etc.
#
# If you need to work on all current children, new and existing records,
# +load_target+ and the +loaded+ flag are your friends.
class ActiveRecord::Associations::CollectionAssociation < ::ActiveRecord::Associations::Association
  def add_to_target(record, skip_callbacks: T.unsafe(nil), replace: T.unsafe(nil), &block); end
  def build(attributes = T.unsafe(nil), &block); end

  # Add +records+ to this association. Since +<<+ flattens its argument list
  # and inserts each record, +push+ and +concat+ behave identically.
  def concat(*records); end

  # Removes +records+ from this association calling +before_remove+ and
  # +after_remove+ callbacks.
  #
  # This method is abstract in the sense that +delete_records+ has to be
  # provided by descendants. Note this method does not imply the records
  # are actually removed from the database, that depends precisely on
  # +delete_records+. They are in any case removed from the collection.
  def delete(*records); end

  # Removes all records from the association without calling callbacks
  # on the associated records. It honors the +:dependent+ option. However
  # if the +:dependent+ value is +:destroy+ then in that case the +:delete_all+
  # deletion strategy for the association is applied.
  #
  # You can force a particular deletion strategy by passing a parameter.
  #
  # Example:
  #
  # @author.books.delete_all(:nullify)
  # @author.books.delete_all(:delete_all)
  #
  # See delete for more info.
  def delete_all(dependent = T.unsafe(nil)); end

  # Deletes the +records+ and removes them from this association calling
  # +before_remove+ , +after_remove+ , +before_destroy+ and +after_destroy+ callbacks.
  #
  # Note that this method removes records from the database ignoring the
  # +:dependent+ option.
  def destroy(*records); end

  # Destroy all the records from this association.
  #
  # See destroy for more info.
  def destroy_all; end

  # Returns true if the collection is empty.
  #
  # If the collection has been loaded
  # it is equivalent to <tt>collection.size.zero?</tt>. If the
  # collection has not been loaded, it is equivalent to
  # <tt>!collection.exists?</tt>. If the collection has not already been
  # loaded and you are going to fetch the records anyway it is better to
  # check <tt>collection.length.zero?</tt>.
  #
  # @return [Boolean]
  def empty?; end

  def find(*args); end

  # @return [Boolean]
  def find_from_target?; end

  # Implements the ids reader method, e.g. foo.item_ids for Foo.has_many :items
  def ids_reader; end

  # Implements the ids writer method, e.g. foo.item_ids= for Foo.has_many :items
  def ids_writer(ids); end

  # @return [Boolean]
  def include?(record); end

  def load_target; end

  # @return [Boolean]
  def null_scope?; end

  # Implements the reader method, e.g. foo.items for Foo.has_many :items
  def reader; end

  # Replace this collection with +other_array+. This will perform a diff
  # and delete/add only records that have changed.
  def replace(other_array); end

  def reset; end
  def scope; end

  # Returns the size of the collection by executing a SELECT COUNT(*)
  # query if the collection hasn't been loaded, and calling
  # <tt>collection.size</tt> if it has.
  #
  # If the collection has been already loaded +size+ and +length+ are
  # equivalent. If not and you are going to need the records anyway
  # +length+ will take one less query. Otherwise +size+ is more efficient.
  #
  # This method is abstract in the sense that it relies on
  # +count_records+, which is a method descendants have to provide.
  def size; end

  def target=(record); end

  # Starts a transaction in the association class's database connection.
  #
  #   class Author < ActiveRecord::Base
  #     has_many :books
  #   end
  #
  #   Author.first.books.transaction do
  #     # same effect as calling Book.transaction
  #   end
  def transaction(*args); end

  # Implements the writer method, e.g. foo.items= for Foo.has_many :items
  def writer(records); end

  private

  def _create_record(attributes, raise = T.unsafe(nil), &block); end
  def callback(method, record); end
  def callbacks_for(callback_name); end

  # @raise [ActiveRecord::Rollback]
  def concat_records(records, raise = T.unsafe(nil)); end

  def delete_or_destroy(records, method); end

  # Delete the given records from the association,
  # using one of the methods +:destroy+, +:delete_all+
  # or +:nullify+ (or +nil+, in which case a default is used).
  #
  # @raise [NotImplementedError]
  def delete_records(records, method); end

  # If the :inverse_of option has been
  # specified, then #find scans the entire collection.
  def find_by_scan(*args); end

  # @return [Boolean]
  def include_in_memory?(record); end

  # Do the relevant stuff to insert the given record into the association collection.
  def insert_record(record, validate = T.unsafe(nil), raise = T.unsafe(nil), &block); end

  # We have some records loaded from the database (persisted) and some that are
  # in-memory (memory). The same record may be represented in the persisted array
  # and in the memory array.
  #
  # So the task of this method is to merge them according to the following rules:
  #
  #   * The final array must not have duplicates
  #   * The order of the persisted array is to be preserved
  #   * Any changes made to attributes on objects in the memory array are to be preserved
  #   * Otherwise, attributes should have the value found in the database
  def merge_target_lists(persisted, memory); end

  def remove_records(existing_records, records, method); end
  def replace_common_records_in_memory(new_target, original_target); end
  def replace_on_target(record, skip_callbacks, replace:, inversing: T.unsafe(nil)); end
  def replace_records(new_target, original_target); end
end

# Collection proxies in Active Record are middlemen between an
# <tt>association</tt>, and its <tt>target</tt> result set.
#
# For example, given
#
#   class Blog < ActiveRecord::Base
#     has_many :posts
#   end
#
#   blog = Blog.first
#
# The collection proxy returned by <tt>blog.posts</tt> is built from a
# <tt>:has_many</tt> <tt>association</tt>, and delegates to a collection
# of posts as the <tt>target</tt>.
#
# This class delegates unknown methods to the <tt>association</tt>'s
# relation class via a delegate cache.
#
# The <tt>target</tt> result set is not loaded until needed. For example,
#
#   blog.posts.count
#
# is computed directly through SQL and does not trigger by itself the
# instantiation of the actual post records.
class ActiveRecord::Associations::CollectionProxy < ::ActiveRecord::Relation
  # @return [CollectionProxy] a new instance of CollectionProxy
  def initialize(klass, association, **_arg2); end

  # Adds one or more +records+ to the collection by setting their foreign keys
  # to the association's primary key. Since <tt><<</tt> flattens its argument list and
  # inserts each record, +push+ and +concat+ behave identically. Returns +self+
  # so several appends may be chained together.
  #
  #   class Person < ActiveRecord::Base
  #     has_many :pets
  #   end
  #
  #   person.pets.size # => 0
  #   person.pets << Pet.new(name: 'Fancy-Fancy')
  #   person.pets << [Pet.new(name: 'Spook'), Pet.new(name: 'Choo-Choo')]
  #   person.pets.size # => 3
  #
  #   person.id # => 1
  #   person.pets
  #   # => [
  #   #      #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
  #   #      #<Pet id: 2, name: "Spook", person_id: 1>,
  #   #      #<Pet id: 3, name: "Choo-Choo", person_id: 1>
  #   #    ]
  def <<(*records); end

  # Equivalent to <tt>Array#==</tt>. Returns +true+ if the two arrays
  # contain the same number of elements and if each element is equal
  # to the corresponding element in the +other+ array, otherwise returns
  # +false+.
  #
  #   class Person < ActiveRecord::Base
  #     has_many :pets
  #   end
  #
  #   person.pets
  #   # => [
  #   #      #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
  #   #      #<Pet id: 2, name: "Spook", person_id: 1>
  #   #    ]
  #
  #   other = person.pets.to_ary
  #
  #   person.pets == other
  #   # => true
  #
  #   other = [Pet.new(id: 1), Pet.new(id: 2)]
  #
  #   person.pets == other
  #   # => false
  def ==(other); end

  def _select!(*_arg0, &_arg1); end
  def and(*_arg0, &_arg1); end
  def and!(*_arg0, &_arg1); end
  def annotate(*_arg0, &_arg1); end
  def annotate!(*_arg0, &_arg1); end
  def annotate_values(*_arg0, &_arg1); end
  def annotate_values=(arg); end

  # Adds one or more +records+ to the collection by setting their foreign keys
  # to the association's primary key. Since <tt><<</tt> flattens its argument list and
  # inserts each record, +push+ and +concat+ behave identically. Returns +self+
  # so several appends may be chained together.
  #
  #   class Person < ActiveRecord::Base
  #     has_many :pets
  #   end
  #
  #   person.pets.size # => 0
  #   person.pets << Pet.new(name: 'Fancy-Fancy')
  #   person.pets << [Pet.new(name: 'Spook'), Pet.new(name: 'Choo-Choo')]
  #   person.pets.size # => 3
  #
  #   person.id # => 1
  #   person.pets
  #   # => [
  #   #      #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
  #   #      #<Pet id: 2, name: "Spook", person_id: 1>,
  #   #      #<Pet id: 3, name: "Choo-Choo", person_id: 1>
  #   #    ]
  def append(*records); end

  def arel(*_arg0, &_arg1); end

  # Returns a new object of the collection type that has been instantiated
  # with +attributes+ and linked to this object, but have not yet been saved.
  # You can pass an array of attributes hashes, this will return an array
  # with the new objects.
  #
  #   class Person
  #     has_many :pets
  #   end
  #
  #   person.pets.build
  #   # => #<Pet id: nil, name: nil, person_id: 1>
  #
  #   person.pets.build(name: 'Fancy-Fancy')
  #   # => #<Pet id: nil, name: "Fancy-Fancy", person_id: 1>
  #
  #   person.pets.build([{name: 'Spook'}, {name: 'Choo-Choo'}, {name: 'Brain'}])
  #   # => [
  #   #      #<Pet id: nil, name: "Spook", person_id: 1>,
  #   #      #<Pet id: nil, name: "Choo-Choo", person_id: 1>,
  #   #      #<Pet id: nil, name: "Brain", person_id: 1>
  #   #    ]
  #
  #   person.pets.size  # => 5 # size of the collection
  #   person.pets.count # => 0 # count from database
  def build(attributes = T.unsafe(nil), &block); end

  # --
  def calculate(operation, column_name); end

  # Equivalent to +delete_all+. The difference is that returns +self+, instead
  # of an array with the deleted objects, so methods can be chained. See
  # +delete_all+ for more information.
  # Note that because +delete_all+ removes records by directly
  # running an SQL query into the database, the +updated_at+ column of
  # the object is not changed.
  def clear; end

  # Adds one or more +records+ to the collection by setting their foreign keys
  # to the association's primary key. Since <tt><<</tt> flattens its argument list and
  # inserts each record, +push+ and +concat+ behave identically. Returns +self+
  # so several appends may be chained together.
  #
  #   class Person < ActiveRecord::Base
  #     has_many :pets
  #   end
  #
  #   person.pets.size # => 0
  #   person.pets << Pet.new(name: 'Fancy-Fancy')
  #   person.pets << [Pet.new(name: 'Spook'), Pet.new(name: 'Choo-Choo')]
  #   person.pets.size # => 3
  #
  #   person.id # => 1
  #   person.pets
  #   # => [
  #   #      #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
  #   #      #<Pet id: 2, name: "Spook", person_id: 1>,
  #   #      #<Pet id: 3, name: "Choo-Choo", person_id: 1>
  #   #    ]
  def concat(*records); end

  def construct_join_dependency(*_arg0, &_arg1); end

  # Returns a new object of the collection type that has been instantiated with
  # attributes, linked to this object and that has already been saved (if it
  # passes the validations).
  #
  #   class Person
  #     has_many :pets
  #   end
  #
  #   person.pets.create(name: 'Fancy-Fancy')
  #   # => #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>
  #
  #   person.pets.create([{name: 'Spook'}, {name: 'Choo-Choo'}])
  #   # => [
  #   #      #<Pet id: 2, name: "Spook", person_id: 1>,
  #   #      #<Pet id: 3, name: "Choo-Choo", person_id: 1>
  #   #    ]
  #
  #   person.pets.size  # => 3
  #   person.pets.count # => 3
  #
  #   person.pets.find(1, 2, 3)
  #   # => [
  #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
  #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
  #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
  #   #    ]
  def create(attributes = T.unsafe(nil), &block); end

  # Like #create, except that if the record is invalid, raises an exception.
  #
  #   class Person
  #     has_many :pets
  #   end
  #
  #   class Pet
  #     validates :name, presence: true
  #   end
  #
  #   person.pets.create!(name: nil)
  #   # => ActiveRecord::RecordInvalid: Validation failed: Name can't be blank
  def create!(attributes = T.unsafe(nil), &block); end

  def create_with(*_arg0, &_arg1); end
  def create_with!(*_arg0, &_arg1); end
  def create_with_value(*_arg0, &_arg1); end
  def create_with_value=(arg); end

  # Deletes the +records+ supplied from the collection according to the strategy
  # specified by the +:dependent+ option. If no +:dependent+ option is given,
  # then it will follow the default strategy. Returns an array with the
  # deleted records.
  #
  # For <tt>has_many :through</tt> associations, the default deletion strategy is
  # +:delete_all+.
  #
  # For +has_many+ associations, the default deletion strategy is +:nullify+.
  # This sets the foreign keys to +NULL+.
  #
  #   class Person < ActiveRecord::Base
  #     has_many :pets # dependent: :nullify option by default
  #   end
  #
  #   person.pets.size # => 3
  #   person.pets
  #   # => [
  #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
  #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
  #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
  #   #    ]
  #
  #   person.pets.delete(Pet.find(1))
  #   # => [#<Pet id: 1, name: "Fancy-Fancy", person_id: 1>]
  #
  #   person.pets.size # => 2
  #   person.pets
  #   # => [
  #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
  #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
  #   #    ]
  #
  #   Pet.find(1)
  #   # => #<Pet id: 1, name: "Fancy-Fancy", person_id: nil>
  #
  # If it is set to <tt>:destroy</tt> all the +records+ are removed by calling
  # their +destroy+ method. See +destroy+ for more information.
  #
  #   class Person < ActiveRecord::Base
  #     has_many :pets, dependent: :destroy
  #   end
  #
  #   person.pets.size # => 3
  #   person.pets
  #   # => [
  #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
  #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
  #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
  #   #    ]
  #
  #   person.pets.delete(Pet.find(1), Pet.find(3))
  #   # => [
  #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
  #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
  #   #    ]
  #
  #   person.pets.size # => 1
  #   person.pets
  #   # => [#<Pet id: 2, name: "Spook", person_id: 1>]
  #
  #   Pet.find(1, 3)
  #   # => ActiveRecord::RecordNotFound: Couldn't find all Pets with 'id': (1, 3)
  #
  # If it is set to <tt>:delete_all</tt>, all the +records+ are deleted
  # *without* calling their +destroy+ method.
  #
  #   class Person < ActiveRecord::Base
  #     has_many :pets, dependent: :delete_all
  #   end
  #
  #   person.pets.size # => 3
  #   person.pets
  #   # => [
  #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
  #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
  #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
  #   #    ]
  #
  #   person.pets.delete(Pet.find(1))
  #   # => [#<Pet id: 1, name: "Fancy-Fancy", person_id: 1>]
  #
  #   person.pets.size # => 2
  #   person.pets
  #   # => [
  #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
  #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
  #   #    ]
  #
  #   Pet.find(1)
  #   # => ActiveRecord::RecordNotFound: Couldn't find Pet with 'id'=1
  #
  # You can pass +Integer+ or +String+ values, it finds the records
  # responding to the +id+ and executes delete on them.
  #
  #   class Person < ActiveRecord::Base
  #     has_many :pets
  #   end
  #
  #   person.pets.size # => 3
  #   person.pets
  #   # => [
  #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
  #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
  #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
  #   #    ]
  #
  #   person.pets.delete("1")
  #   # => [#<Pet id: 1, name: "Fancy-Fancy", person_id: 1>]
  #
  #   person.pets.delete(2, 3)
  #   # => [
  #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
  #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
  #   #    ]
  def delete(*records); end

  # Deletes all the records from the collection according to the strategy
  # specified by the +:dependent+ option. If no +:dependent+ option is given,
  # then it will follow the default strategy.
  #
  # For <tt>has_many :through</tt> associations, the default deletion strategy is
  # +:delete_all+.
  #
  # For +has_many+ associations, the default deletion strategy is +:nullify+.
  # This sets the foreign keys to +NULL+.
  #
  #   class Person < ActiveRecord::Base
  #     has_many :pets # dependent: :nullify option by default
  #   end
  #
  #   person.pets.size # => 3
  #   person.pets
  #   # => [
  #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
  #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
  #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
  #   #    ]
  #
  #   person.pets.delete_all
  #   # => [
  #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
  #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
  #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
  #   #    ]
  #
  #   person.pets.size # => 0
  #   person.pets      # => []
  #
  #   Pet.find(1, 2, 3)
  #   # => [
  #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: nil>,
  #   #       #<Pet id: 2, name: "Spook", person_id: nil>,
  #   #       #<Pet id: 3, name: "Choo-Choo", person_id: nil>
  #   #    ]
  #
  # Both +has_many+ and <tt>has_many :through</tt> dependencies default to the
  # +:delete_all+ strategy if the +:dependent+ option is set to +:destroy+.
  # Records are not instantiated and callbacks will not be fired.
  #
  #   class Person < ActiveRecord::Base
  #     has_many :pets, dependent: :destroy
  #   end
  #
  #   person.pets.size # => 3
  #   person.pets
  #   # => [
  #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
  #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
  #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
  #   #    ]
  #
  #   person.pets.delete_all
  #
  #   Pet.find(1, 2, 3)
  #   # => ActiveRecord::RecordNotFound: Couldn't find all Pets with 'id': (1, 2, 3)
  #
  # If it is set to <tt>:delete_all</tt>, all the objects are deleted
  # *without* calling their +destroy+ method.
  #
  #   class Person < ActiveRecord::Base
  #     has_many :pets, dependent: :delete_all
  #   end
  #
  #   person.pets.size # => 3
  #   person.pets
  #   # => [
  #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
  #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
  #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
  #   #    ]
  #
  #   person.pets.delete_all
  #
  #   Pet.find(1, 2, 3)
  #   # => ActiveRecord::RecordNotFound: Couldn't find all Pets with 'id': (1, 2, 3)
  def delete_all(dependent = T.unsafe(nil)); end

  # Destroys the +records+ supplied and removes them from the collection.
  # This method will _always_ remove record from the database ignoring
  # the +:dependent+ option. Returns an array with the removed records.
  #
  #   class Person < ActiveRecord::Base
  #     has_many :pets
  #   end
  #
  #   person.pets.size # => 3
  #   person.pets
  #   # => [
  #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
  #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
  #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
  #   #    ]
  #
  #   person.pets.destroy(Pet.find(1))
  #   # => [#<Pet id: 1, name: "Fancy-Fancy", person_id: 1>]
  #
  #   person.pets.size # => 2
  #   person.pets
  #   # => [
  #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
  #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
  #   #    ]
  #
  #   person.pets.destroy(Pet.find(2), Pet.find(3))
  #   # => [
  #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
  #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
  #   #    ]
  #
  #   person.pets.size  # => 0
  #   person.pets       # => []
  #
  #   Pet.find(1, 2, 3) # => ActiveRecord::RecordNotFound: Couldn't find all Pets with 'id': (1, 2, 3)
  #
  # You can pass +Integer+ or +String+ values, it finds the records
  # responding to the +id+ and then deletes them from the database.
  #
  #   person.pets.size # => 3
  #   person.pets
  #   # => [
  #   #       #<Pet id: 4, name: "Benny", person_id: 1>,
  #   #       #<Pet id: 5, name: "Brain", person_id: 1>,
  #   #       #<Pet id: 6, name: "Boss",  person_id: 1>
  #   #    ]
  #
  #   person.pets.destroy("4")
  #   # => #<Pet id: 4, name: "Benny", person_id: 1>
  #
  #   person.pets.size # => 2
  #   person.pets
  #   # => [
  #   #       #<Pet id: 5, name: "Brain", person_id: 1>,
  #   #       #<Pet id: 6, name: "Boss",  person_id: 1>
  #   #    ]
  #
  #   person.pets.destroy(5, 6)
  #   # => [
  #   #       #<Pet id: 5, name: "Brain", person_id: 1>,
  #   #       #<Pet id: 6, name: "Boss",  person_id: 1>
  #   #    ]
  #
  #   person.pets.size  # => 0
  #   person.pets       # => []
  #
  #   Pet.find(4, 5, 6) # => ActiveRecord::RecordNotFound: Couldn't find all Pets with 'id': (4, 5, 6)
  def destroy(*records); end

  # Deletes the records of the collection directly from the database
  # ignoring the +:dependent+ option. Records are instantiated and it
  # invokes +before_remove+, +after_remove+ , +before_destroy+ and
  # +after_destroy+ callbacks.
  #
  #   class Person < ActiveRecord::Base
  #     has_many :pets
  #   end
  #
  #   person.pets.size # => 3
  #   person.pets
  #   # => [
  #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
  #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
  #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
  #   #    ]
  #
  #   person.pets.destroy_all
  #
  #   person.pets.size # => 0
  #   person.pets      # => []
  #
  #   Pet.find(1) # => Couldn't find Pet with id=1
  def destroy_all; end

  def distinct(*_arg0, &_arg1); end
  def distinct!(*_arg0, &_arg1); end
  def distinct_value(*_arg0, &_arg1); end
  def distinct_value=(arg); end
  def eager_load(*_arg0, &_arg1); end
  def eager_load!(*_arg0, &_arg1); end
  def eager_load_values(*_arg0, &_arg1); end
  def eager_load_values=(arg); end

  # Returns +true+ if the collection is empty. If the collection has been
  # loaded it is equivalent
  # to <tt>collection.size.zero?</tt>. If the collection has not been loaded,
  # it is equivalent to <tt>!collection.exists?</tt>. If the collection has
  # not already been loaded and you are going to fetch the records anyway it
  # is better to check <tt>collection.length.zero?</tt>.
  #
  #   class Person < ActiveRecord::Base
  #     has_many :pets
  #   end
  #
  #   person.pets.count  # => 1
  #   person.pets.empty? # => false
  #
  #   person.pets.delete_all
  #
  #   person.pets.count  # => 0
  #   person.pets.empty? # => true
  #
  # @return [Boolean]
  def empty?; end

  def except(*_arg0, &_arg1); end
  def extending(*_arg0, &_arg1); end
  def extending!(*_arg0, &_arg1); end
  def extending_values(*_arg0, &_arg1); end
  def extending_values=(arg); end
  def extensions(*_arg0, &_arg1); end
  def extract_associated(*_arg0, &_arg1); end

  # Finds an object in the collection responding to the +id+. Uses the same
  # rules as ActiveRecord::Base.find. Returns ActiveRecord::RecordNotFound
  # error if the object cannot be found.
  #
  #   class Person < ActiveRecord::Base
  #     has_many :pets
  #   end
  #
  #   person.pets
  #   # => [
  #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
  #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
  #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
  #   #    ]
  #
  #   person.pets.find(1) # => #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>
  #   person.pets.find(4) # => ActiveRecord::RecordNotFound: Couldn't find Pet with 'id'=4
  #
  #   person.pets.find(2) { |pet| pet.name.downcase! }
  #   # => #<Pet id: 2, name: "fancy-fancy", person_id: 1>
  #
  #   person.pets.find(2, 3)
  #   # => [
  #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
  #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
  #   #    ]
  def find(*args); end

  def from(*_arg0, &_arg1); end
  def from!(*_arg0, &_arg1); end
  def from_clause(*_arg0, &_arg1); end
  def from_clause=(arg); end
  def group(*_arg0, &_arg1); end
  def group!(*_arg0, &_arg1); end
  def group_values(*_arg0, &_arg1); end
  def group_values=(arg); end
  def having(*_arg0, &_arg1); end
  def having!(*_arg0, &_arg1); end
  def having_clause(*_arg0, &_arg1); end
  def having_clause=(arg); end

  # Returns +true+ if the given +record+ is present in the collection.
  #
  #   class Person < ActiveRecord::Base
  #     has_many :pets
  #   end
  #
  #   person.pets # => [#<Pet id: 20, name: "Snoop">]
  #
  #   person.pets.include?(Pet.find(20)) # => true
  #   person.pets.include?(Pet.find(21)) # => false
  #
  # @return [Boolean]
  def include?(record); end

  def includes(*_arg0, &_arg1); end
  def includes!(*_arg0, &_arg1); end
  def includes_values(*_arg0, &_arg1); end
  def includes_values=(arg); end
  def insert(*_arg0, &_arg1); end
  def insert!(*_arg0, &_arg1); end
  def insert_all(*_arg0, &_arg1); end
  def insert_all!(*_arg0, &_arg1); end
  def inspect; end
  def joins(*_arg0, &_arg1); end
  def joins!(*_arg0, &_arg1); end
  def joins_values(*_arg0, &_arg1); end
  def joins_values=(arg); end

  # Returns the last record, or the last +n+ records, from the collection.
  # If the collection is empty, the first form returns +nil+, and the second
  # form returns an empty array.
  #
  #   class Person < ActiveRecord::Base
  #     has_many :pets
  #   end
  #
  #   person.pets
  #   # => [
  #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
  #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
  #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
  #   #    ]
  #
  #   person.pets.last # => #<Pet id: 3, name: "Choo-Choo", person_id: 1>
  #
  #   person.pets.last(2)
  #   # => [
  #   #      #<Pet id: 2, name: "Spook", person_id: 1>,
  #   #      #<Pet id: 3, name: "Choo-Choo", person_id: 1>
  #   #    ]
  #
  #   another_person_without.pets         # => []
  #   another_person_without.pets.last    # => nil
  #   another_person_without.pets.last(3) # => []
  def last(limit = T.unsafe(nil)); end

  def left_joins(*_arg0, &_arg1); end
  def left_outer_joins(*_arg0, &_arg1); end
  def left_outer_joins!(*_arg0, &_arg1); end
  def left_outer_joins_values(*_arg0, &_arg1); end
  def left_outer_joins_values=(arg); end
  def limit(*_arg0, &_arg1); end
  def limit!(*_arg0, &_arg1); end
  def limit_value(*_arg0, &_arg1); end
  def limit_value=(arg); end
  def load_target; end

  # Returns +true+ if the association has been loaded, otherwise +false+.
  #
  #   person.pets.loaded? # => false
  #   person.pets
  #   person.pets.loaded? # => true
  #
  # @return [Boolean]
  def loaded; end

  # Returns +true+ if the association has been loaded, otherwise +false+.
  #
  #   person.pets.loaded? # => false
  #   person.pets
  #   person.pets.loaded? # => true
  #
  # @return [Boolean]
  def loaded?; end

  def lock(*_arg0, &_arg1); end
  def lock!(*_arg0, &_arg1); end
  def lock_value(*_arg0, &_arg1); end
  def lock_value=(arg); end
  def merge(*_arg0, &_arg1); end
  def merge!(*_arg0, &_arg1); end

  # Returns a new object of the collection type that has been instantiated
  # with +attributes+ and linked to this object, but have not yet been saved.
  # You can pass an array of attributes hashes, this will return an array
  # with the new objects.
  #
  #   class Person
  #     has_many :pets
  #   end
  #
  #   person.pets.build
  #   # => #<Pet id: nil, name: nil, person_id: 1>
  #
  #   person.pets.build(name: 'Fancy-Fancy')
  #   # => #<Pet id: nil, name: "Fancy-Fancy", person_id: 1>
  #
  #   person.pets.build([{name: 'Spook'}, {name: 'Choo-Choo'}, {name: 'Brain'}])
  #   # => [
  #   #      #<Pet id: nil, name: "Spook", person_id: 1>,
  #   #      #<Pet id: nil, name: "Choo-Choo", person_id: 1>,
  #   #      #<Pet id: nil, name: "Brain", person_id: 1>
  #   #    ]
  #
  #   person.pets.size  # => 5 # size of the collection
  #   person.pets.count # => 0 # count from database
  def new(attributes = T.unsafe(nil), &block); end

  def none(*_arg0, &_arg1); end
  def none!(*_arg0, &_arg1); end
  def offset(*_arg0, &_arg1); end
  def offset!(*_arg0, &_arg1); end
  def offset_value(*_arg0, &_arg1); end
  def offset_value=(arg); end
  def only(*_arg0, &_arg1); end
  def optimizer_hints(*_arg0, &_arg1); end
  def optimizer_hints!(*_arg0, &_arg1); end
  def optimizer_hints_values(*_arg0, &_arg1); end
  def optimizer_hints_values=(arg); end
  def or(*_arg0, &_arg1); end
  def or!(*_arg0, &_arg1); end
  def order(*_arg0, &_arg1); end
  def order!(*_arg0, &_arg1); end
  def order_values(*_arg0, &_arg1); end
  def order_values=(arg); end
  def pluck(*column_names); end
  def preload(*_arg0, &_arg1); end
  def preload!(*_arg0, &_arg1); end
  def preload_values(*_arg0, &_arg1); end
  def preload_values=(arg); end

  # @raise [NoMethodError]
  def prepend(*args); end

  def proxy_association; end

  # Adds one or more +records+ to the collection by setting their foreign keys
  # to the association's primary key. Since <tt><<</tt> flattens its argument list and
  # inserts each record, +push+ and +concat+ behave identically. Returns +self+
  # so several appends may be chained together.
  #
  #   class Person < ActiveRecord::Base
  #     has_many :pets
  #   end
  #
  #   person.pets.size # => 0
  #   person.pets << Pet.new(name: 'Fancy-Fancy')
  #   person.pets << [Pet.new(name: 'Spook'), Pet.new(name: 'Choo-Choo')]
  #   person.pets.size # => 3
  #
  #   person.id # => 1
  #   person.pets
  #   # => [
  #   #      #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
  #   #      #<Pet id: 2, name: "Spook", person_id: 1>,
  #   #      #<Pet id: 3, name: "Choo-Choo", person_id: 1>
  #   #    ]
  def push(*records); end

  def readonly(*_arg0, &_arg1); end
  def readonly!(*_arg0, &_arg1); end
  def readonly_value(*_arg0, &_arg1); end
  def readonly_value=(arg); end

  # :method: to_ary
  #
  # :call-seq:
  #   to_ary()
  #
  # Returns a new array of objects from the collection. If the collection
  # hasn't been loaded, it fetches the records from the database.
  #
  #   class Person < ActiveRecord::Base
  #     has_many :pets
  #   end
  #
  #   person.pets
  #   # => [
  #   #       #<Pet id: 4, name: "Benny", person_id: 1>,
  #   #       #<Pet id: 5, name: "Brain", person_id: 1>,
  #   #       #<Pet id: 6, name: "Boss",  person_id: 1>
  #   #    ]
  #
  #   other_pets = person.pets.to_ary
  #   # => [
  #   #       #<Pet id: 4, name: "Benny", person_id: 1>,
  #   #       #<Pet id: 5, name: "Brain", person_id: 1>,
  #   #       #<Pet id: 6, name: "Boss",  person_id: 1>
  #   #    ]
  #
  #   other_pets.replace([Pet.new(name: 'BooGoo')])
  #
  #   other_pets
  #   # => [#<Pet id: nil, name: "BooGoo", person_id: 1>]
  #
  #   person.pets
  #   # This is not affected by replace
  #   # => [
  #   #       #<Pet id: 4, name: "Benny", person_id: 1>,
  #   #       #<Pet id: 5, name: "Brain", person_id: 1>,
  #   #       #<Pet id: 6, name: "Boss",  person_id: 1>
  #   #    ]
  def records; end

  def references(*_arg0, &_arg1); end
  def references!(*_arg0, &_arg1); end
  def references_values(*_arg0, &_arg1); end
  def references_values=(arg); end

  # Reloads the collection from the database. Returns +self+.
  #
  #   class Person < ActiveRecord::Base
  #     has_many :pets
  #   end
  #
  #   person.pets # fetches pets from the database
  #   # => [#<Pet id: 1, name: "Snoop", group: "dogs", person_id: 1>]
  #
  #   person.pets # uses the pets cache
  #   # => [#<Pet id: 1, name: "Snoop", group: "dogs", person_id: 1>]
  #
  #   person.pets.reload # fetches pets from the database
  #   # => [#<Pet id: 1, name: "Snoop", group: "dogs", person_id: 1>]
  def reload; end

  def reorder(*_arg0, &_arg1); end
  def reorder!(*_arg0, &_arg1); end
  def reordering_value(*_arg0, &_arg1); end
  def reordering_value=(arg); end

  # Replaces this collection with +other_array+. This will perform a diff
  # and delete/add only records that have changed.
  #
  #   class Person < ActiveRecord::Base
  #     has_many :pets
  #   end
  #
  #   person.pets
  #   # => [#<Pet id: 1, name: "Gorby", group: "cats", person_id: 1>]
  #
  #   other_pets = [Pet.new(name: 'Puff', group: 'celebrities')]
  #
  #   person.pets.replace(other_pets)
  #
  #   person.pets
  #   # => [#<Pet id: 2, name: "Puff", group: "celebrities", person_id: 1>]
  #
  # If the supplied array has an incorrect association type, it raises
  # an <tt>ActiveRecord::AssociationTypeMismatch</tt> error:
  #
  #   person.pets.replace(["doo", "ggie", "gaga"])
  #   # => ActiveRecord::AssociationTypeMismatch: Pet expected, got String
  def replace(other_array); end

  def reselect(*_arg0, &_arg1); end
  def reselect!(*_arg0, &_arg1); end

  # Unloads the association. Returns +self+.
  #
  #   class Person < ActiveRecord::Base
  #     has_many :pets
  #   end
  #
  #   person.pets # fetches pets from the database
  #   # => [#<Pet id: 1, name: "Snoop", group: "dogs", person_id: 1>]
  #
  #   person.pets # uses the pets cache
  #   # => [#<Pet id: 1, name: "Snoop", group: "dogs", person_id: 1>]
  #
  #   person.pets.reset # clears the pets cache
  #
  #   person.pets  # fetches pets from the database
  #   # => [#<Pet id: 1, name: "Snoop", group: "dogs", person_id: 1>]
  def reset; end

  def reset_scope; end
  def reverse_order(*_arg0, &_arg1); end
  def reverse_order!(*_arg0, &_arg1); end
  def reverse_order_value(*_arg0, &_arg1); end
  def reverse_order_value=(arg); end
  def rewhere(*_arg0, &_arg1); end

  # Returns a <tt>Relation</tt> object for the records in this association
  def scope; end

  def scoping(*_arg0, &_arg1); end
  def select_values(*_arg0, &_arg1); end
  def select_values=(arg); end

  # Returns the size of the collection. If the collection hasn't been loaded,
  # it executes a <tt>SELECT COUNT(*)</tt> query. Else it calls <tt>collection.size</tt>.
  #
  # If the collection has been already loaded +size+ and +length+ are
  # equivalent. If not and you are going to need the records anyway
  # +length+ will take one less query. Otherwise +size+ is more efficient.
  #
  #   class Person < ActiveRecord::Base
  #     has_many :pets
  #   end
  #
  #   person.pets.size # => 3
  #   # executes something like SELECT COUNT(*) FROM "pets" WHERE "pets"."person_id" = 1
  #
  #   person.pets # This will execute a SELECT * FROM query
  #   # => [
  #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
  #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
  #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
  #   #    ]
  #
  #   person.pets.size # => 3
  #   # Because the collection is already loaded, this will behave like
  #   # collection.size and no SQL count query is executed.
  def size; end

  def skip_preloading!(*_arg0, &_arg1); end
  def skip_query_cache!(*_arg0, &_arg1); end
  def skip_query_cache_value(*_arg0, &_arg1); end
  def skip_query_cache_value=(arg); end
  def spawn(*_arg0, &_arg1); end
  def strict_loading(*_arg0, &_arg1); end
  def strict_loading!(*_arg0, &_arg1); end
  def strict_loading_value(*_arg0, &_arg1); end
  def strict_loading_value=(arg); end

  # Gives a record (or N records if a parameter is supplied) from the collection
  # using the same rules as <tt>ActiveRecord::Base.take</tt>.
  #
  #   class Person < ActiveRecord::Base
  #     has_many :pets
  #   end
  #
  #   person.pets
  #   # => [
  #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
  #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
  #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
  #   #    ]
  #
  #   person.pets.take # => #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>
  #
  #   person.pets.take(2)
  #   # => [
  #   #      #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
  #   #      #<Pet id: 2, name: "Spook", person_id: 1>
  #   #    ]
  #
  #   another_person_without.pets         # => []
  #   another_person_without.pets.take    # => nil
  #   another_person_without.pets.take(2) # => []
  def take(limit = T.unsafe(nil)); end

  def target; end
  def uniq!(*_arg0, &_arg1); end
  def unscope(*_arg0, &_arg1); end
  def unscope!(*_arg0, &_arg1); end
  def unscope_values(*_arg0, &_arg1); end
  def unscope_values=(arg); end
  def upsert(*_arg0, &_arg1); end
  def upsert_all(*_arg0, &_arg1); end
  def values(*_arg0, &_arg1); end
  def where(*_arg0, &_arg1); end
  def where!(*_arg0, &_arg1); end
  def where_clause(*_arg0, &_arg1); end
  def where_clause=(arg); end

  private

  def exec_queries; end

  # @return [Boolean]
  def find_from_target?; end

  def find_nth_from_last(index); end
  def find_nth_with_limit(index, limit); end

  # @return [Boolean]
  def null_scope?; end
end

module ActiveRecord::Associations::ForeignAssociation
  # @return [Boolean]
  def foreign_key_present?; end

  def nullified_owner_attributes; end

  private

  # Sets the owner attributes on the given record
  def set_owner_attributes(record); end
end

# = Active Record Has Many Association
# This is the proxy that handles a has many association.
#
# If the association has a <tt>:through</tt> option further specialization
# is provided by its child HasManyThroughAssociation.
class ActiveRecord::Associations::HasManyAssociation < ::ActiveRecord::Associations::CollectionAssociation
  include ::ActiveRecord::Associations::ForeignAssociation

  def handle_dependency; end
  def insert_record(record, validate = T.unsafe(nil), raise = T.unsafe(nil)); end

  private

  def _create_record(attributes, *_arg1); end
  def concat_records(records, *_arg1); end

  # Returns the number of records in this collection.
  #
  # If the association has a counter cache it gets that value. Otherwise
  # it will attempt to do a count via SQL, bounded to <tt>:limit</tt> if
  # there's one. Some configuration options like :group make it impossible
  # to do an SQL count, in those cases the array count will be used.
  #
  # That does not depend on whether the collection has already been loaded
  # or not. The +size+ method is the one that takes the loaded flag into
  # account and delegates to +count_records+ if needed.
  #
  # If the collection is empty the target is set to an empty array and
  # the loaded flag is set to true as well.
  def count_records; end

  def delete_count(method, scope); end
  def delete_or_nullify_all_records(method); end

  # Deletes the records according to the <tt>:dependent</tt> option.
  def delete_records(records, method); end

  def difference(a, b); end
  def intersection(a, b); end
  def update_counter(difference, reflection = T.unsafe(nil)); end
  def update_counter_if_success(saved_successfully, difference); end
  def update_counter_in_memory(difference, reflection = T.unsafe(nil)); end
end

# = Active Record Has Many Through Association
class ActiveRecord::Associations::HasManyThroughAssociation < ::ActiveRecord::Associations::HasManyAssociation
  include ::ActiveRecord::Associations::ThroughAssociation

  # @return [HasManyThroughAssociation] a new instance of HasManyThroughAssociation
  def initialize(owner, reflection); end

  def concat(*records); end
  def insert_record(record, validate = T.unsafe(nil), raise = T.unsafe(nil)); end

  private

  def build_record(attributes); end

  # The through record (built with build_record) is temporarily cached
  # so that it may be reused if insert_record is subsequently called.
  #
  # However, after insert_record has been called, the cache is cleared in
  # order to allow multiple instances of the same record in an association.
  def build_through_record(record); end

  def concat_records(records); end
  def delete_or_nullify_all_records(method); end
  def delete_records(records, method); end
  def delete_through_records(records); end
  def difference(a, b); end
  def distribution(array); end
  def find_target; end
  def intersection(a, b); end

  # NOTE - not sure that we can actually cope with inverses here
  #
  # @return [Boolean]
  def invertible_for?(record); end

  def mark_occurrence(distribution, record); end
  def remove_records(existing_records, records, method); end
  def save_through_record(record); end

  # @return [Boolean]
  def target_reflection_has_associated_record?; end

  def through_records_for(record); end

  # Returns the value of attribute through_scope.
  def through_scope; end

  def through_scope_attributes; end

  # @return [Boolean]
  def update_through_counter?(method); end
end

# = Active Record Has One Association
class ActiveRecord::Associations::HasOneAssociation < ::ActiveRecord::Associations::SingularAssociation
  include ::ActiveRecord::Associations::ForeignAssociation

  def delete(method = T.unsafe(nil)); end
  def handle_dependency; end

  private

  def _create_record(attributes, raise_error = T.unsafe(nil), &block); end
  def nullify_owner_attributes(record); end
  def remove_target!(method); end
  def replace(record, save = T.unsafe(nil)); end

  # The reason that the save param for replace is false, if for create (not just build),
  # is because the setting of the foreign keys is actually handled by the scoping when
  # the record is instantiated, and so they are set straight away and do not need to be
  # updated within replace.
  def set_new_record(record); end

  def transaction_if(value); end
end

# = Active Record Has One Through Association
class ActiveRecord::Associations::HasOneThroughAssociation < ::ActiveRecord::Associations::HasOneAssociation
  include ::ActiveRecord::Associations::ThroughAssociation

  private

  def create_through_record(record, save); end
  def replace(record, save = T.unsafe(nil)); end
end

class ActiveRecord::Associations::JoinDependency
  # @return [JoinDependency] a new instance of JoinDependency
  def initialize(base, table, associations, join_type); end

  def apply_column_aliases(relation); end
  def base_klass; end
  def each(&block); end
  def instantiate(result_set, strict_loading_value, &block); end
  def join_constraints(joins_to_add, alias_tracker, references); end
  def reflections; end

  protected

  # Returns the value of attribute join_root.
  def join_root; end

  # Returns the value of attribute join_type.
  def join_type; end

  private

  # Returns the value of attribute alias_tracker.
  def alias_tracker; end

  def aliases; end
  def build(associations, base_klass); end
  def construct(ar_parent, parent, row, seen, model_cache, strict_loading_value); end
  def construct_model(record, node, row, model_cache, id, strict_loading_value); end
  def find_reflection(klass, name); end

  # Returns the value of attribute join_root_alias.
  def join_root_alias; end

  def make_constraints(parent, child, join_type); end
  def make_join_constraints(join_root, join_type); end
  def walk(left, right, join_type); end

  class << self
    def make_tree(associations); end
    def walk_tree(associations, hash); end
  end
end

class ActiveRecord::Associations::JoinDependency::Aliases
  # @return [Aliases] a new instance of Aliases
  def initialize(tables); end

  def column_alias(node, column); end
  def column_aliases(node); end
  def columns; end
end

class ActiveRecord::Associations::JoinDependency::Aliases::Column < ::Struct
  # Returns the value of attribute alias
  #
  # @return [Object] the current value of alias
  def alias; end

  # Sets the attribute alias
  #
  # @param value [Object] the value to set the attribute alias to.
  # @return [Object] the newly set value
  def alias=(_); end

  # Returns the value of attribute name
  #
  # @return [Object] the current value of name
  def name; end

  # Sets the attribute name
  #
  # @param value [Object] the value to set the attribute name to.
  # @return [Object] the newly set value
  def name=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def members; end
    def new(*_arg0); end
  end
end

class ActiveRecord::Associations::JoinDependency::Aliases::Table < ::Struct
  def column_aliases; end

  # Returns the value of attribute columns
  #
  # @return [Object] the current value of columns
  def columns; end

  # Sets the attribute columns
  #
  # @param value [Object] the value to set the attribute columns to.
  # @return [Object] the newly set value
  def columns=(_); end

  # Returns the value of attribute node
  #
  # @return [Object] the current value of node
  def node; end

  # Sets the attribute node
  #
  # @param value [Object] the value to set the attribute node to.
  # @return [Object] the newly set value
  def node=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def members; end
    def new(*_arg0); end
  end
end

class ActiveRecord::Associations::JoinDependency::JoinAssociation < ::ActiveRecord::Associations::JoinDependency::JoinPart
  # @return [JoinAssociation] a new instance of JoinAssociation
  def initialize(reflection, children); end

  def join_constraints(foreign_table, foreign_klass, join_type, alias_tracker); end

  # @return [Boolean]
  def match?(other); end

  # @return [Boolean]
  def readonly?; end

  # Returns the value of attribute reflection.
  def reflection; end

  # @return [Boolean]
  def strict_loading?; end

  # Returns the value of attribute table.
  def table; end

  # Sets the attribute table
  #
  # @param value the value to set the attribute table to.
  def table=(_arg0); end

  # Returns the value of attribute tables.
  def tables; end

  private

  def append_constraints(join, constraints); end
end

class ActiveRecord::Associations::JoinDependency::JoinBase < ::ActiveRecord::Associations::JoinDependency::JoinPart
  # @return [JoinBase] a new instance of JoinBase
  def initialize(base_klass, table, children); end

  # @return [Boolean]
  def match?(other); end

  # Returns the value of attribute table.
  def table; end
end

# A JoinPart represents a part of a JoinDependency. It is inherited
# by JoinBase and JoinAssociation. A JoinBase represents the Active Record which
# everything else is being joined onto. A JoinAssociation represents an association which
# is joining to the base. A JoinAssociation may result in more than one actual join
# operations (for example a has_and_belongs_to_many JoinAssociation would result in
# two; one for the join table and one for the target table).
class ActiveRecord::Associations::JoinDependency::JoinPart
  include ::Enumerable

  # @return [JoinPart] a new instance of JoinPart
  def initialize(base_klass, children); end

  def attribute_types(*_arg0, &_arg1); end

  # The Active Record class which this join part is associated 'about'; for a JoinBase
  # this is the actual base model, for a JoinAssociation this is the target model of the
  # association.
  def base_klass; end

  # The Active Record class which this join part is associated 'about'; for a JoinBase
  # this is the actual base model, for a JoinAssociation this is the target model of the
  # association.
  def children; end

  def column_names(*_arg0, &_arg1); end

  # @yield [_self]
  # @yieldparam _self [ActiveRecord::Associations::JoinDependency::JoinPart] the object that the method was called on
  def each(&block); end

  def each_children(&block); end
  def extract_record(row, column_names_with_alias); end
  def instantiate(row, aliases, column_types = T.unsafe(nil), &block); end

  # @return [Boolean]
  def match?(other); end

  def primary_key(*_arg0, &_arg1); end

  # An Arel::Table for the active_record
  #
  # @raise [NotImplementedError]
  def table; end

  def table_name(*_arg0, &_arg1); end
end

# Implements the details of eager loading of Active Record associations.
#
# Suppose that you have the following two Active Record models:
#
#   class Author < ActiveRecord::Base
#     # columns: name, age
#     has_many :books
#   end
#
#   class Book < ActiveRecord::Base
#     # columns: title, sales, author_id
#   end
#
# When you load an author with all associated books Active Record will make
# multiple queries like this:
#
#   Author.includes(:books).where(name: ['bell hooks', 'Homer']).to_a
#
#   => SELECT `authors`.* FROM `authors` WHERE `name` IN ('bell hooks', 'Homer')
#   => SELECT `books`.* FROM `books` WHERE `author_id` IN (2, 5)
#
# Active Record saves the ids of the records from the first query to use in
# the second. Depending on the number of associations involved there can be
# arbitrarily many SQL queries made.
#
# However, if there is a WHERE clause that spans across tables Active
# Record will fall back to a slightly more resource-intensive single query:
#
#   Author.includes(:books).where(books: {title: 'Illiad'}).to_a
#   => SELECT `authors`.`id` AS t0_r0, `authors`.`name` AS t0_r1, `authors`.`age` AS t0_r2,
#             `books`.`id`   AS t1_r0, `books`.`title`  AS t1_r1, `books`.`sales` AS t1_r2
#      FROM `authors`
#      LEFT OUTER JOIN `books` ON `authors`.`id` =  `books`.`author_id`
#      WHERE `books`.`title` = 'Illiad'
#
# This could result in many rows that contain redundant data and it performs poorly at scale
# and is therefore only used when necessary.
class ActiveRecord::Associations::Preloader
  extend ::ActiveSupport::Autoload

  # @return [Preloader] a new instance of Preloader
  def initialize(associate_by_default: T.unsafe(nil)); end

  # Eager loads the named associations for the given Active Record record(s).
  #
  # In this description, 'association name' shall refer to the name passed
  # to an association creation method. For example, a model that specifies
  # <tt>belongs_to :author</tt>, <tt>has_many :buyers</tt> has association
  # names +:author+ and +:buyers+.
  #
  # == Parameters
  # +records+ is an array of ActiveRecord::Base. This array needs not be flat,
  # i.e. +records+ itself may also contain arrays of records. In any case,
  # +preload_associations+ will preload all associations records by
  # flattening +records+.
  #
  # +associations+ specifies one or more associations that you want to
  # preload. It may be:
  # - a Symbol or a String which specifies a single association name. For
  #   example, specifying +:books+ allows this method to preload all books
  #   for an Author.
  # - an Array which specifies multiple association names. This array
  #   is processed recursively. For example, specifying <tt>[:avatar, :books]</tt>
  #   allows this method to preload an author's avatar as well as all of his
  #   books.
  # - a Hash which specifies multiple association names, as well as
  #   association names for the to-be-preloaded association objects. For
  #   example, specifying <tt>{ author: :avatar }</tt> will preload a
  #   book's author, as well as that author's avatar.
  #
  # +:associations+ has the same format as the +:include+ option for
  # <tt>ActiveRecord::Base.find</tt>. So +associations+ could look like this:
  #
  #   :books
  #   [ :books, :author ]
  #   { author: :avatar }
  #   [ :books, { author: :avatar } ]
  def preload(records, associations, preload_scope = T.unsafe(nil)); end

  private

  def grouped_records(association, records, polymorphic_parent); end

  # Returns a class containing the logic needed to load preload the data
  # and attach it to a relation. The class returned implements a `run` method
  # that accepts a preloader.
  def preloader_for(reflection, owners); end

  def preloaders_for_hash(association, records, scope, polymorphic_parent); end

  # Loads all the given data into +records+ for a singular +association+.
  #
  # Functions by instantiating a preloader class such as Preloader::Association and
  # call the +run+ method for each passed in class in the +records+ argument.
  #
  # Not all records have the same class, so group then preload group on the reflection
  # itself so that if various subclass share the same association then we do not split
  # them unnecessarily
  #
  # Additionally, polymorphic belongs_to associations can have multiple associated
  # classes, depending on the polymorphic_type field. So we group by the classes as
  # well.
  def preloaders_for_one(association, records, scope, polymorphic_parent); end

  def preloaders_for_reflection(reflection, records, scope); end

  # Loads all the given data into +records+ for the +association+.
  def preloaders_on(association, records, scope, polymorphic_parent = T.unsafe(nil)); end
end

class ActiveRecord::Associations::Preloader::AlreadyLoaded
  # @return [AlreadyLoaded] a new instance of AlreadyLoaded
  def initialize(klass, owners, reflection, preload_scope, associate_by_default = T.unsafe(nil)); end

  def preloaded_records; end
  def records_by_owner; end
  def run; end

  private

  # Returns the value of attribute owners.
  def owners; end

  # Returns the value of attribute reflection.
  def reflection; end
end

class ActiveRecord::Associations::Preloader::Association
  # @return [Association] a new instance of Association
  def initialize(klass, owners, reflection, preload_scope, associate_by_default = T.unsafe(nil)); end

  def preloaded_records; end
  def records_by_owner; end
  def run; end

  private

  def associate_records_to_owner(owner, records); end

  # The name of the key on the associated records
  def association_key_name; end

  def association_key_type; end
  def build_scope; end
  def convert_key(key); end

  # @return [Boolean]
  def key_conversion_required?; end

  # Returns the value of attribute klass.
  def klass; end

  def load_records; end

  # Returns the value of attribute model.
  def model; end

  # The name of the key on the model which declares the association
  def owner_key_name; end

  def owner_key_type; end
  def owner_keys; end

  # Returns the value of attribute owners.
  def owners; end

  def owners_by_key; end

  # Returns the value of attribute preload_scope.
  def preload_scope; end

  def records_for(ids); end

  # Returns the value of attribute reflection.
  def reflection; end

  def reflection_scope; end
  def scope; end
end

class ActiveRecord::Associations::Preloader::ThroughAssociation < ::ActiveRecord::Associations::Preloader::Association
  # @return [ThroughAssociation] a new instance of ThroughAssociation
  def initialize(*_arg0); end

  def preloaded_records; end
  def records_by_owner; end

  private

  def middle_records; end
  def preload_index; end
  def source_preloaders; end
  def source_reflection; end
  def through_preloaders; end
  def through_reflection; end
  def through_scope; end
end

ActiveRecord::Associations::Preloader::ThroughAssociation::PRELOADER = T.let(T.unsafe(nil), ActiveRecord::Associations::Preloader)

class ActiveRecord::Associations::SingularAssociation < ::ActiveRecord::Associations::Association
  def build(attributes = T.unsafe(nil), &block); end

  # Implements the reload reader method, e.g. foo.reload_bar for
  # Foo.has_one :bar
  def force_reload_reader; end

  # Implements the reader method, e.g. foo.bar for Foo.has_one :bar
  def reader; end

  # Implements the writer method, e.g. foo.bar= for Foo.belongs_to :bar
  def writer(record); end

  private

  # @raise [RecordInvalid]
  def _create_record(attributes, raise_error = T.unsafe(nil), &block); end

  def find_target; end

  # @raise [NotImplementedError]
  def replace(record); end

  def scope_for_create; end
  def set_new_record(record); end
end

# = Active Record Through Association
module ActiveRecord::Associations::ThroughAssociation
  def source_reflection(*_arg0, &_arg1); end

  private

  def build_record(attributes); end

  # Construct attributes for :through pointing to owner and associate. This is used by the
  # methods which create and delete records on the association.
  #
  # We only support indirectly modifying through associations which have a belongs_to source.
  # This is the "has_many :tags, through: :taggings" situation, where the join model
  # typically has a belongs_to on both side. In other words, associations which could also
  # be represented as has_and_belongs_to_many associations.
  #
  # We do not support creating/deleting records on the association where the source has
  # some other type, because this opens up a whole can of worms, and in basically any
  # situation it is more natural for the user to just create or modify their join records
  # directly as required.
  def construct_join_attributes(*records); end

  def ensure_mutable; end
  def ensure_not_nested; end

  # @return [Boolean]
  def foreign_key_present?; end

  # Note: this does not capture all cases, for example it would be crazy to try to
  # properly support stale-checking for nested associations.
  def stale_state; end

  # We merge in these scopes for two reasons:
  #
  #   1. To get the default_scope conditions for any of the other reflections in the chain
  #   2. To get the type conditions for any STI models in the chain
  def target_scope; end

  def through_association; end
  def through_reflection; end
end

module ActiveRecord::AttributeAssignment
  include ::ActiveModel::ForbiddenAttributesProtection
  include ::ActiveModel::AttributeAssignment

  private

  def _assign_attributes(attributes); end

  # Instantiates objects for all attribute classes that needs more than one constructor parameter. This is done
  # by calling new on the column type or aggregation type (through composed_of) object with these parameters.
  # So having the pairs written_on(1) = "2004", written_on(2) = "6", written_on(3) = "24", will instantiate
  # written_on (a date type) with Date.new("2004", "6", "24"). You can also specify a typecast character in the
  # parentheses to have the parameters typecasted before they're used in the constructor. Use i for Integer and
  # f for Float. If all the values for a given attribute are empty, the attribute will be set to +nil+.
  def assign_multiparameter_attributes(pairs); end

  # Assign any deferred nested attributes after the base attributes have been set.
  def assign_nested_parameter_attributes(pairs); end

  def execute_callstack_for_multiparameter_attributes(callstack); end
  def extract_callstack_for_multiparameter_attributes(pairs); end
  def find_parameter_position(multiparameter_name); end
  def type_cast_attribute_value(multiparameter_name, value); end
end

# Raised when an error occurred while doing a mass assignment to an attribute through the
# {ActiveRecord::Base#attributes=}[rdoc-ref:AttributeAssignment#attributes=] method.
# The exception has an +attribute+ property that is the name of the offending attribute.
class ActiveRecord::AttributeAssignmentError < ::ActiveRecord::ActiveRecordError
  # @return [AttributeAssignmentError] a new instance of AttributeAssignmentError
  def initialize(message = T.unsafe(nil), exception = T.unsafe(nil), attribute = T.unsafe(nil)); end

  # Returns the value of attribute attribute.
  def attribute; end

  # Returns the value of attribute exception.
  def exception; end
end

# = Active Record Attribute Methods
module ActiveRecord::AttributeMethods
  extend ::ActiveSupport::Concern
  extend ::ActiveSupport::Autoload
  include GeneratedInstanceMethods
  include ::ActiveModel::AttributeMethods
  include ::ActiveRecord::AttributeMethods::Read
  include ::ActiveRecord::AttributeMethods::Write
  include ::ActiveRecord::AttributeMethods::BeforeTypeCast
  include ::ActiveRecord::AttributeMethods::Query
  include ::ActiveRecord::AttributeMethods::PrimaryKey
  include ::ActiveRecord::AttributeMethods::TimeZoneConversion
  include ::ActiveModel::Dirty
  include ::ActiveRecord::AttributeMethods::Dirty
  include ::ActiveRecord::AttributeMethods::Serialization

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::ActiveModel::AttributeMethods::ClassMethods
  mixes_in_class_methods ::ActiveRecord::AttributeMethods::ClassMethods
  mixes_in_class_methods ::ActiveRecord::AttributeMethods::Read::ClassMethods
  mixes_in_class_methods ::ActiveRecord::AttributeMethods::Write::ClassMethods
  mixes_in_class_methods ::ActiveRecord::AttributeMethods::PrimaryKey::ClassMethods
  mixes_in_class_methods ::ActiveRecord::AttributeMethods::TimeZoneConversion::ClassMethods
  mixes_in_class_methods ::ActiveRecord::AttributeMethods::Serialization::ClassMethods

  # Returns the value of the attribute identified by <tt>attr_name</tt> after it has been typecast (for example,
  # "2004-12-12" in a date column is cast to a date object, like Date.new(2004, 12, 12)). It raises
  # <tt>ActiveModel::MissingAttributeError</tt> if the identified attribute is missing.
  #
  # Note: +:id+ is always present.
  #
  #   class Person < ActiveRecord::Base
  #     belongs_to :organization
  #   end
  #
  #   person = Person.new(name: 'Francesco', age: '22')
  #   person[:name] # => "Francesco"
  #   person[:age]  # => 22
  #
  #   person = Person.select('id').first
  #   person[:name]            # => ActiveModel::MissingAttributeError: missing attribute: name
  #   person[:organization_id] # => ActiveModel::MissingAttributeError: missing attribute: organization_id
  def [](attr_name); end

  # Updates the attribute identified by <tt>attr_name</tt> with the specified +value+.
  # (Alias for the protected #write_attribute method).
  #
  #   class Person < ActiveRecord::Base
  #   end
  #
  #   person = Person.new
  #   person[:age] = '22'
  #   person[:age] # => 22
  #   person[:age].class # => Integer
  def []=(attr_name, value); end

  # @return [Boolean]
  def _has_attribute?(attr_name); end

  # Returns the name of all database fields which have been read from this
  # model. This can be useful in development mode to determine which fields
  # need to be selected. For performance critical pages, selecting only the
  # required fields can be an easy performance win (assuming you aren't using
  # all of the fields on the model).
  #
  # For example:
  #
  #   class PostsController < ActionController::Base
  #     after_action :print_accessed_fields, only: :index
  #
  #     def index
  #       @posts = Post.all
  #     end
  #
  #     private
  #
  #     def print_accessed_fields
  #       p @posts.first.accessed_fields
  #     end
  #   end
  #
  # Which allows you to quickly change your code to:
  #
  #   class PostsController < ActionController::Base
  #     def index
  #       @posts = Post.select(:id, :title, :author_id, :updated_at)
  #     end
  #   end
  def accessed_fields; end

  # Returns an <tt>#inspect</tt>-like string for the value of the
  # attribute +attr_name+. String attributes are truncated up to 50
  # characters, Date and Time attributes are returned in the
  # <tt>:db</tt> format. Other attributes return the value of
  # <tt>#inspect</tt> without modification.
  #
  #   person = Person.create!(name: 'David Heinemeier Hansson ' * 3)
  #
  #   person.attribute_for_inspect(:name)
  #   # => "\"David Heinemeier Hansson David Heinemeier Hansson ...\""
  #
  #   person.attribute_for_inspect(:created_at)
  #   # => "\"2012-10-22 00:15:07\""
  #
  #   person.attribute_for_inspect(:tag_ids)
  #   # => "[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]"
  def attribute_for_inspect(attr_name); end

  # Returns an array of names for the attributes available on this object.
  #
  #   class Person < ActiveRecord::Base
  #   end
  #
  #   person = Person.new
  #   person.attribute_names
  #   # => ["id", "created_at", "updated_at", "name", "age"]
  def attribute_names; end

  # Returns +true+ if the specified +attribute+ has been set by the user or by a
  # database load and is neither +nil+ nor <tt>empty?</tt> (the latter only applies
  # to objects that respond to <tt>empty?</tt>, most notably Strings). Otherwise, +false+.
  # Note that it always returns +true+ with boolean attributes.
  #
  #   class Task < ActiveRecord::Base
  #   end
  #
  #   task = Task.new(title: '', is_done: false)
  #   task.attribute_present?(:title)   # => false
  #   task.attribute_present?(:is_done) # => true
  #   task.title = 'Buy milk'
  #   task.is_done = true
  #   task.attribute_present?(:title)   # => true
  #   task.attribute_present?(:is_done) # => true
  #
  # @return [Boolean]
  def attribute_present?(attr_name); end

  # Returns a hash of all the attributes with their names as keys and the values of the attributes as values.
  #
  #   class Person < ActiveRecord::Base
  #   end
  #
  #   person = Person.create(name: 'Francesco', age: 22)
  #   person.attributes
  #   # => {"id"=>3, "created_at"=>Sun, 21 Oct 2012 04:53:04, "updated_at"=>Sun, 21 Oct 2012 04:53:04, "name"=>"Francesco", "age"=>22}
  def attributes; end

  # Returns +true+ if the given attribute is in the attributes hash, otherwise +false+.
  #
  #   class Person < ActiveRecord::Base
  #     alias_attribute :new_name, :name
  #   end
  #
  #   person = Person.new
  #   person.has_attribute?(:name)     # => true
  #   person.has_attribute?(:new_name) # => true
  #   person.has_attribute?('age')     # => true
  #   person.has_attribute?(:nothing)  # => false
  #
  # @return [Boolean]
  def has_attribute?(attr_name); end

  # A Person object with a name attribute can ask <tt>person.respond_to?(:name)</tt>,
  # <tt>person.respond_to?(:name=)</tt>, and <tt>person.respond_to?(:name?)</tt>
  # which will all return +true+. It also defines the attribute methods if they have
  # not been generated.
  #
  #   class Person < ActiveRecord::Base
  #   end
  #
  #   person = Person.new
  #   person.respond_to?(:name)    # => true
  #   person.respond_to?(:name=)   # => true
  #   person.respond_to?(:name?)   # => true
  #   person.respond_to?('age')    # => true
  #   person.respond_to?('age=')   # => true
  #   person.respond_to?('age?')   # => true
  #   person.respond_to?(:nothing) # => false
  #
  # @return [Boolean]
  def respond_to?(name, include_private = T.unsafe(nil)); end

  private

  # @return [Boolean]
  def attribute_method?(attr_name); end

  # Filters out the primary keys, from the attribute names, when the primary
  # key is to be generated (e.g. the id attribute has no value).
  def attributes_for_create(attribute_names); end

  # Filters the primary keys and readonly attributes from the attribute names.
  def attributes_for_update(attribute_names); end

  def attributes_with_values(attribute_names); end
  def format_for_inspect(name, value); end

  # @return [Boolean]
  def pk_attribute?(name); end

  class << self
    def dangerous_attribute_methods; end
  end

  module GeneratedClassMethods
    def attribute_aliases; end
    def attribute_aliases=(value); end
    def attribute_aliases?; end
    def attribute_method_matchers; end
    def attribute_method_matchers=(value); end
    def attribute_method_matchers?; end
    def partial_writes; end
    def partial_writes=(value); end
    def partial_writes?; end
    def skip_time_zone_conversion_for_attributes; end
    def skip_time_zone_conversion_for_attributes=(value); end
    def skip_time_zone_conversion_for_attributes?; end
    def time_zone_aware_types; end
    def time_zone_aware_types=(value); end
    def time_zone_aware_types?; end
  end

  module GeneratedInstanceMethods
    def attribute_aliases; end
    def attribute_aliases?; end
    def attribute_method_matchers; end
    def attribute_method_matchers?; end
    def partial_writes; end
    def partial_writes?; end
    def skip_time_zone_conversion_for_attributes; end
    def skip_time_zone_conversion_for_attributes?; end
    def time_zone_aware_types; end
    def time_zone_aware_types?; end
  end
end

# = Active Record Attribute Methods Before Type Cast
#
# ActiveRecord::AttributeMethods::BeforeTypeCast provides a way to
# read the value of the attributes before typecasting and deserialization.
#
#   class Task < ActiveRecord::Base
#   end
#
#   task = Task.new(id: '1', completed_on: '2012-10-21')
#   task.id           # => 1
#   task.completed_on # => Sun, 21 Oct 2012
#
#   task.attributes_before_type_cast
#   # => {"id"=>"1", "completed_on"=>"2012-10-21", ... }
#   task.read_attribute_before_type_cast('id')           # => "1"
#   task.read_attribute_before_type_cast('completed_on') # => "2012-10-21"
#
# In addition to #read_attribute_before_type_cast and #attributes_before_type_cast,
# it declares a method for all attributes with the <tt>*_before_type_cast</tt>
# suffix.
#
#   task.id_before_type_cast           # => "1"
#   task.completed_on_before_type_cast # => "2012-10-21"
module ActiveRecord::AttributeMethods::BeforeTypeCast
  extend ::ActiveSupport::Concern

  # Returns a hash of attributes before typecasting and deserialization.
  #
  #   class Task < ActiveRecord::Base
  #   end
  #
  #   task = Task.new(title: nil, is_done: true, completed_on: '2012-10-21')
  #   task.attributes
  #   # => {"id"=>nil, "title"=>nil, "is_done"=>true, "completed_on"=>Sun, 21 Oct 2012, "created_at"=>nil, "updated_at"=>nil}
  #   task.attributes_before_type_cast
  #   # => {"id"=>nil, "title"=>nil, "is_done"=>true, "completed_on"=>"2012-10-21", "created_at"=>nil, "updated_at"=>nil}
  def attributes_before_type_cast; end

  # Returns the value of the attribute identified by +attr_name+ before
  # typecasting and deserialization.
  #
  #   class Task < ActiveRecord::Base
  #   end
  #
  #   task = Task.new(id: '1', completed_on: '2012-10-21')
  #   task.read_attribute('id')                            # => 1
  #   task.read_attribute_before_type_cast('id')           # => '1'
  #   task.read_attribute('completed_on')                  # => Sun, 21 Oct 2012
  #   task.read_attribute_before_type_cast('completed_on') # => "2012-10-21"
  #   task.read_attribute_before_type_cast(:completed_on)  # => "2012-10-21"
  def read_attribute_before_type_cast(attr_name); end

  private

  # Dispatch target for <tt>*_before_type_cast</tt> attribute methods.
  def attribute_before_type_cast(attr_name); end

  # @return [Boolean]
  def attribute_came_from_user?(attr_name); end

  def attribute_for_database(attr_name); end
end

module ActiveRecord::AttributeMethods::ClassMethods
  # @return [Boolean]
  def _has_attribute?(attr_name); end

  # Returns +true+ if +attribute+ is an attribute method and table exists,
  # +false+ otherwise.
  #
  #   class Person < ActiveRecord::Base
  #   end
  #
  #   Person.attribute_method?('name')   # => true
  #   Person.attribute_method?(:age=)    # => true
  #   Person.attribute_method?(:nothing) # => false
  #
  # @return [Boolean]
  def attribute_method?(attribute); end

  # Returns an array of column names as strings if it's not an abstract class and
  # table exists. Otherwise it returns an empty array.
  #
  #   class Person < ActiveRecord::Base
  #   end
  #
  #   Person.attribute_names
  #   # => ["id", "created_at", "updated_at", "name", "age"]
  def attribute_names; end

  # A method name is 'dangerous' if it is already (re)defined by Active Record, but
  # not by any ancestors. (So 'puts' is not dangerous but 'save' is.)
  #
  # @return [Boolean]
  def dangerous_attribute_method?(name); end

  # A class method is 'dangerous' if it is already (re)defined by Active Record, but
  # not by any ancestors. (So 'puts' is not dangerous but 'new' is.)
  #
  # @return [Boolean]
  def dangerous_class_method?(method_name); end

  # Generates all the attribute related methods for columns in the database
  # accessors, mutators and query methods.
  def define_attribute_methods; end

  # Returns true if the given attribute exists, otherwise false.
  #
  #   class Person < ActiveRecord::Base
  #     alias_attribute :new_name, :name
  #   end
  #
  #   Person.has_attribute?('name')     # => true
  #   Person.has_attribute?('new_name') # => true
  #   Person.has_attribute?(:age)       # => true
  #   Person.has_attribute?(:nothing)   # => false
  #
  # @return [Boolean]
  def has_attribute?(attr_name); end

  def inherited(child_class); end
  def initialize_generated_modules; end

  # Raises an ActiveRecord::DangerousAttributeError exception when an
  # \Active \Record method is defined in the model, otherwise +false+.
  #
  #   class Person < ActiveRecord::Base
  #     def save
  #       'already defined by Active Record'
  #     end
  #   end
  #
  #   Person.instance_method_already_implemented?(:save)
  #   # => ActiveRecord::DangerousAttributeError: save is defined by Active Record. Check to make sure that you don't have an attribute or method with the same name.
  #
  #   Person.instance_method_already_implemented?(:name)
  #   # => false
  #
  # @return [Boolean]
  def instance_method_already_implemented?(method_name); end

  # @return [Boolean]
  def method_defined_within?(name, klass, superklass = T.unsafe(nil)); end

  def undefine_attribute_methods; end
end

module ActiveRecord::AttributeMethods::Dirty
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods
  include ::ActiveModel::AttributeMethods
  include ::ActiveModel::Dirty

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::ActiveModel::AttributeMethods::ClassMethods

  # Returns the original value of an attribute before the last save.
  #
  # This method is useful in after callbacks to get the original value of an
  # attribute before the save that triggered the callbacks to run. It can be
  # invoked as +name_before_last_save+ instead of
  # <tt>attribute_before_last_save("name")</tt>.
  def attribute_before_last_save(attr_name); end

  # Returns the change to an attribute that will be persisted during the
  # next save.
  #
  # This method is useful in validations and before callbacks, to see the
  # change to an attribute that will occur when the record is saved. It can
  # be invoked as +name_change_to_be_saved+ instead of
  # <tt>attribute_change_to_be_saved("name")</tt>.
  #
  # If the attribute will change, the result will be an array containing the
  # original value and the new value about to be saved.
  def attribute_change_to_be_saved(attr_name); end

  # Returns the value of an attribute in the database, as opposed to the
  # in-memory value that will be persisted the next time the record is
  # saved.
  #
  # This method is useful in validations and before callbacks, to see the
  # original value of an attribute prior to any changes about to be
  # saved. It can be invoked as +name_in_database+ instead of
  # <tt>attribute_in_database("name")</tt>.
  def attribute_in_database(attr_name); end

  # Returns a hash of the attributes that will change when the record is
  # next saved.
  #
  # The hash keys are the attribute names, and the hash values are the
  # original attribute values in the database (as opposed to the in-memory
  # values about to be saved).
  def attributes_in_database; end

  # Returns an array of the names of any attributes that will change when
  # the record is next saved.
  def changed_attribute_names_to_save; end

  # Returns a hash containing all the changes that will be persisted during
  # the next save.
  def changes_to_save; end

  # Will the next call to +save+ have any changes to persist?
  #
  # @return [Boolean]
  def has_changes_to_save?; end

  # <tt>reload</tt> the record and clears changed attributes.
  def reload(*_arg0); end

  # Returns the change to an attribute during the last save. If the
  # attribute was changed, the result will be an array containing the
  # original value and the saved value.
  #
  # This method is useful in after callbacks, to see the change in an
  # attribute during the save that triggered the callbacks to run. It can be
  # invoked as +saved_change_to_name+ instead of
  # <tt>saved_change_to_attribute("name")</tt>.
  def saved_change_to_attribute(attr_name); end

  # Did this attribute change when we last saved?
  #
  # This method is useful in after callbacks to determine if an attribute
  # was changed during the save that triggered the callbacks to run. It can
  # be invoked as +saved_change_to_name?+ instead of
  # <tt>saved_change_to_attribute?("name")</tt>.
  #
  # ==== Options
  #
  # +from+ When passed, this method will return false unless the original
  # value is equal to the given option
  #
  # +to+ When passed, this method will return false unless the value was
  # changed to the given value
  #
  # @return [Boolean]
  def saved_change_to_attribute?(attr_name, **options); end

  # Returns a hash containing all the changes that were just saved.
  def saved_changes; end

  # Did the last call to +save+ have any changes to change?
  #
  # @return [Boolean]
  def saved_changes?; end

  # Will this attribute change the next time we save?
  #
  # This method is useful in validations and before callbacks to determine
  # if the next call to +save+ will change a particular attribute. It can be
  # invoked as +will_save_change_to_name?+ instead of
  # <tt>will_save_change_to_attribute?("name")</tt>.
  #
  # ==== Options
  #
  # +from+ When passed, this method will return false unless the original
  # value is equal to the given option
  #
  # +to+ When passed, this method will return false unless the value will be
  # changed to the given value
  #
  # @return [Boolean]
  def will_save_change_to_attribute?(attr_name, **options); end

  private

  def _create_record(attribute_names = T.unsafe(nil)); end
  def _touch_row(attribute_names, time); end
  def _update_record(attribute_names = T.unsafe(nil)); end
  def attribute_names_for_partial_writes; end
  def write_attribute_without_type_cast(attr_name, value); end

  module GeneratedClassMethods
    def attribute_aliases; end
    def attribute_aliases=(value); end
    def attribute_aliases?; end
    def attribute_method_matchers; end
    def attribute_method_matchers=(value); end
    def attribute_method_matchers?; end
    def partial_writes; end
    def partial_writes=(value); end
    def partial_writes?; end
  end

  module GeneratedInstanceMethods
    def attribute_aliases; end
    def attribute_aliases?; end
    def attribute_method_matchers; end
    def attribute_method_matchers?; end
    def partial_writes; end
    def partial_writes?; end
  end
end

class ActiveRecord::AttributeMethods::GeneratedAttributeMethods < ::Module
  include ::Mutex_m

  def lock; end
  def locked?; end
  def synchronize(&block); end
  def try_lock; end
  def unlock; end
end

module ActiveRecord::AttributeMethods::PrimaryKey
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::ActiveRecord::AttributeMethods::PrimaryKey::ClassMethods

  # Returns the primary key column's value.
  def id; end

  # Sets the primary key column's value.
  def id=(value); end

  # Queries the primary key column's value.
  #
  # @return [Boolean]
  def id?; end

  # Returns the primary key column's value before type cast.
  def id_before_type_cast; end

  def id_for_database; end

  # Returns the primary key column's value from the database.
  def id_in_database; end

  # Returns the primary key column's previous value.
  def id_was; end

  # Returns this record's primary key value wrapped in an array if one is
  # available.
  def to_key; end

  private

  # @return [Boolean]
  def attribute_method?(attr_name); end
end

module ActiveRecord::AttributeMethods::PrimaryKey::ClassMethods
  # @return [Boolean]
  def dangerous_attribute_method?(method_name); end

  def get_primary_key(base_name); end

  # @return [Boolean]
  def instance_method_already_implemented?(method_name); end

  # Defines the primary key field -- can be overridden in subclasses.
  # Overwriting will negate any effect of the +primary_key_prefix_type+
  # setting, though.
  def primary_key; end

  # Sets the name of the primary key column.
  #
  #   class Project < ActiveRecord::Base
  #     self.primary_key = 'sysid'
  #   end
  #
  # You can also define the #primary_key method yourself:
  #
  #   class Project < ActiveRecord::Base
  #     def self.primary_key
  #       'foo_' + super
  #     end
  #   end
  #
  #   Project.primary_key # => "foo_id"
  def primary_key=(value); end

  # Returns a quoted version of the primary key name, used to construct
  # SQL statements.
  def quoted_primary_key; end

  def reset_primary_key; end

  private

  def suppress_composite_primary_key(pk); end
end

ActiveRecord::AttributeMethods::PrimaryKey::ClassMethods::ID_ATTRIBUTE_METHODS = T.let(T.unsafe(nil), Set)

module ActiveRecord::AttributeMethods::Query
  extend ::ActiveSupport::Concern

  def query_attribute(attr_name); end

  private

  def attribute?(attr_name); end
end

ActiveRecord::AttributeMethods::RESTRICTED_CLASS_METHODS = T.let(T.unsafe(nil), Array)

module ActiveRecord::AttributeMethods::Read
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::ActiveRecord::AttributeMethods::Read::ClassMethods

  # This method exists to avoid the expensive primary_key check internally, without
  # breaking compatibility with the read_attribute API
  def _read_attribute(attr_name, &block); end

  # Returns the value of the attribute identified by <tt>attr_name</tt> after
  # it has been typecast (for example, "2004-12-12" in a date column is cast
  # to a date object, like Date.new(2004, 12, 12)).
  def read_attribute(attr_name, &block); end

  private

  # This method exists to avoid the expensive primary_key check internally, without
  # breaking compatibility with the read_attribute API
  def attribute(attr_name, &block); end
end

module ActiveRecord::AttributeMethods::Read::ClassMethods
  private

  def define_method_attribute(name, owner:); end
end

module ActiveRecord::AttributeMethods::Serialization
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::ActiveRecord::AttributeMethods::Serialization::ClassMethods
end

module ActiveRecord::AttributeMethods::Serialization::ClassMethods
  # If you have an attribute that needs to be saved to the database as an
  # object, and retrieved as the same object, then specify the name of that
  # attribute using this method and it will be handled automatically. The
  # serialization is done through YAML. If +class_name+ is specified, the
  # serialized object must be of that class on assignment and retrieval.
  # Otherwise SerializationTypeMismatch will be raised.
  #
  # Empty objects as <tt>{}</tt>, in the case of +Hash+, or <tt>[]</tt>, in the case of
  # +Array+, will always be persisted as null.
  #
  # Keep in mind that database adapters handle certain serialization tasks
  # for you. For instance: +json+ and +jsonb+ types in PostgreSQL will be
  # converted between JSON object/array syntax and Ruby +Hash+ or +Array+
  # objects transparently. There is no need to use #serialize in this
  # case.
  #
  # For more complex cases, such as conversion to or from your application
  # domain objects, consider using the ActiveRecord::Attributes API.
  #
  # ==== Parameters
  #
  # * +attr_name+ - The field name that should be serialized.
  # * +class_name_or_coder+ - Optional, a coder object, which responds to +.load+ and +.dump+
  #   or a class name that the object type should be equal to.
  #
  # ==== Options
  #
  # +default+ The default value to use when no value is provided. If this option
  # is not passed, the previous default value (if any) will be used.
  # Otherwise, the default will be +nil+.
  #
  # ==== Example
  #
  #   # Serialize a preferences attribute.
  #   class User < ActiveRecord::Base
  #     serialize :preferences
  #   end
  #
  #   # Serialize preferences using JSON as coder.
  #   class User < ActiveRecord::Base
  #     serialize :preferences, JSON
  #   end
  #
  #   # Serialize preferences as Hash using YAML coder.
  #   class User < ActiveRecord::Base
  #     serialize :preferences, Hash
  #   end
  def serialize(attr_name, class_name_or_coder = T.unsafe(nil), **options); end

  private

  # @return [Boolean]
  def type_incompatible_with_serialize?(type, class_name); end
end

class ActiveRecord::AttributeMethods::Serialization::ColumnNotSerializableError < ::StandardError
  # @return [ColumnNotSerializableError] a new instance of ColumnNotSerializableError
  def initialize(name, type); end
end

module ActiveRecord::AttributeMethods::TimeZoneConversion
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::ActiveRecord::AttributeMethods::TimeZoneConversion::ClassMethods

  module GeneratedClassMethods
    def skip_time_zone_conversion_for_attributes; end
    def skip_time_zone_conversion_for_attributes=(value); end
    def skip_time_zone_conversion_for_attributes?; end
    def time_zone_aware_types; end
    def time_zone_aware_types=(value); end
    def time_zone_aware_types?; end
  end

  module GeneratedInstanceMethods
    def skip_time_zone_conversion_for_attributes; end
    def skip_time_zone_conversion_for_attributes?; end
    def time_zone_aware_types; end
    def time_zone_aware_types?; end
  end
end

module ActiveRecord::AttributeMethods::TimeZoneConversion::ClassMethods
  def define_attribute(name, cast_type, **_arg2); end

  private

  # @return [Boolean]
  def create_time_zone_conversion_attribute?(name, cast_type); end
end

class ActiveRecord::AttributeMethods::TimeZoneConversion::TimeZoneConverter
  def cast(value); end
  def deserialize(value); end

  private

  def convert_time_to_time_zone(value); end
  def map_avoiding_infinite_recursion(value); end
  def set_time_zone_without_conversion(value); end

  class << self
    def new(subtype); end
  end
end

module ActiveRecord::AttributeMethods::Write
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::ActiveRecord::AttributeMethods::Write::ClassMethods

  # This method exists to avoid the expensive primary_key check internally, without
  # breaking compatibility with the write_attribute API
  def _write_attribute(attr_name, value); end

  # Updates the attribute identified by <tt>attr_name</tt> with the
  # specified +value+. Empty strings for Integer and Float columns are
  # turned into +nil+.
  def write_attribute(attr_name, value); end

  private

  # This method exists to avoid the expensive primary_key check internally, without
  # breaking compatibility with the write_attribute API
  def attribute=(attr_name, value); end

  def write_attribute_without_type_cast(attr_name, value); end
end

module ActiveRecord::AttributeMethods::Write::ClassMethods
  private

  def define_method_attribute=(name, owner:); end
end

# See ActiveRecord::Attributes::ClassMethods for documentation
module ActiveRecord::Attributes
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::ActiveRecord::Attributes::ClassMethods

  module GeneratedClassMethods
    def attributes_to_define_after_schema_loads; end
    def attributes_to_define_after_schema_loads=(value); end
    def attributes_to_define_after_schema_loads?; end
  end

  module GeneratedInstanceMethods; end
end

module ActiveRecord::Attributes::ClassMethods
  # :call-seq: attribute(name, cast_type = nil, **options)
  #
  # Defines an attribute with a type on this model. It will override the
  # type of existing attributes if needed. This allows control over how
  # values are converted to and from SQL when assigned to a model. It also
  # changes the behavior of values passed to
  # {ActiveRecord::Base.where}[rdoc-ref:QueryMethods#where]. This will let you use
  # your domain objects across much of Active Record, without having to
  # rely on implementation details or monkey patching.
  #
  # +name+ The name of the methods to define attribute methods for, and the
  # column which this will persist to.
  #
  # +cast_type+ A symbol such as +:string+ or +:integer+, or a type object
  # to be used for this attribute. See the examples below for more
  # information about providing custom type objects.
  #
  # ==== Options
  #
  # The following options are accepted:
  #
  # +default+ The default value to use when no value is provided. If this option
  # is not passed, the previous default value (if any) will be used.
  # Otherwise, the default will be +nil+.
  #
  # +array+ (PostgreSQL only) specifies that the type should be an array (see the
  # examples below).
  #
  # +range+ (PostgreSQL only) specifies that the type should be a range (see the
  # examples below).
  #
  # When using a symbol for +cast_type+, extra options are forwarded to the
  # constructor of the type object.
  #
  # ==== Examples
  #
  # The type detected by Active Record can be overridden.
  #
  #   # db/schema.rb
  #   create_table :store_listings, force: true do |t|
  #     t.decimal :price_in_cents
  #   end
  #
  #   # app/models/store_listing.rb
  #   class StoreListing < ActiveRecord::Base
  #   end
  #
  #   store_listing = StoreListing.new(price_in_cents: '10.1')
  #
  #   # before
  #   store_listing.price_in_cents # => BigDecimal(10.1)
  #
  #   class StoreListing < ActiveRecord::Base
  #     attribute :price_in_cents, :integer
  #   end
  #
  #   # after
  #   store_listing.price_in_cents # => 10
  #
  # A default can also be provided.
  #
  #   # db/schema.rb
  #   create_table :store_listings, force: true do |t|
  #     t.string :my_string, default: "original default"
  #   end
  #
  #   StoreListing.new.my_string # => "original default"
  #
  #   # app/models/store_listing.rb
  #   class StoreListing < ActiveRecord::Base
  #     attribute :my_string, :string, default: "new default"
  #   end
  #
  #   StoreListing.new.my_string # => "new default"
  #
  #   class Product < ActiveRecord::Base
  #     attribute :my_default_proc, :datetime, default: -> { Time.now }
  #   end
  #
  #   Product.new.my_default_proc # => 2015-05-30 11:04:48 -0600
  #   sleep 1
  #   Product.new.my_default_proc # => 2015-05-30 11:04:49 -0600
  #
  # \Attributes do not need to be backed by a database column.
  #
  #   # app/models/my_model.rb
  #   class MyModel < ActiveRecord::Base
  #     attribute :my_string, :string
  #     attribute :my_int_array, :integer, array: true
  #     attribute :my_float_range, :float, range: true
  #   end
  #
  #   model = MyModel.new(
  #     my_string: "string",
  #     my_int_array: ["1", "2", "3"],
  #     my_float_range: "[1,3.5]",
  #   )
  #   model.attributes
  #   # =>
  #     {
  #       my_string: "string",
  #       my_int_array: [1, 2, 3],
  #       my_float_range: 1.0..3.5
  #     }
  #
  # Passing options to the type constructor
  #
  #   # app/models/my_model.rb
  #   class MyModel < ActiveRecord::Base
  #     attribute :small_int, :integer, limit: 2
  #   end
  #
  #   MyModel.create(small_int: 65537)
  #   # => Error: 65537 is out of range for the limit of two bytes
  #
  # ==== Creating Custom Types
  #
  # Users may also define their own custom types, as long as they respond
  # to the methods defined on the value type. The method +deserialize+ or
  # +cast+ will be called on your type object, with raw input from the
  # database or from your controllers. See ActiveModel::Type::Value for the
  # expected API. It is recommended that your type objects inherit from an
  # existing type, or from ActiveRecord::Type::Value
  #
  #   class MoneyType < ActiveRecord::Type::Integer
  #     def cast(value)
  #       if !value.kind_of?(Numeric) && value.include?('$')
  #         price_in_dollars = value.gsub(/\$/, '').to_f
  #         super(price_in_dollars * 100)
  #       else
  #         super
  #       end
  #     end
  #   end
  #
  #   # config/initializers/types.rb
  #   ActiveRecord::Type.register(:money, MoneyType)
  #
  #   # app/models/store_listing.rb
  #   class StoreListing < ActiveRecord::Base
  #     attribute :price_in_cents, :money
  #   end
  #
  #   store_listing = StoreListing.new(price_in_cents: '$10.00')
  #   store_listing.price_in_cents # => 1000
  #
  # For more details on creating custom types, see the documentation for
  # ActiveModel::Type::Value. For more details on registering your types
  # to be referenced by a symbol, see ActiveRecord::Type.register. You can
  # also pass a type object directly, in place of a symbol.
  #
  # ==== \Querying
  #
  # When {ActiveRecord::Base.where}[rdoc-ref:QueryMethods#where] is called, it will
  # use the type defined by the model class to convert the value to SQL,
  # calling +serialize+ on your type object. For example:
  #
  #   class Money < Struct.new(:amount, :currency)
  #   end
  #
  #   class MoneyType < ActiveRecord::Type::Value
  #     def initialize(currency_converter:)
  #       @currency_converter = currency_converter
  #     end
  #
  #     # value will be the result of +deserialize+ or
  #     # +cast+. Assumed to be an instance of +Money+ in
  #     # this case.
  #     def serialize(value)
  #       value_in_bitcoins = @currency_converter.convert_to_bitcoins(value)
  #       value_in_bitcoins.amount
  #     end
  #   end
  #
  #   # config/initializers/types.rb
  #   ActiveRecord::Type.register(:money, MoneyType)
  #
  #   # app/models/product.rb
  #   class Product < ActiveRecord::Base
  #     currency_converter = ConversionRatesFromTheInternet.new
  #     attribute :price_in_bitcoins, :money, currency_converter: currency_converter
  #   end
  #
  #   Product.where(price_in_bitcoins: Money.new(5, "USD"))
  #   # => SELECT * FROM products WHERE price_in_bitcoins = 0.02230
  #
  #   Product.where(price_in_bitcoins: Money.new(5, "GBP"))
  #   # => SELECT * FROM products WHERE price_in_bitcoins = 0.03412
  #
  # ==== Dirty Tracking
  #
  # The type of an attribute is given the opportunity to change how dirty
  # tracking is performed. The methods +changed?+ and +changed_in_place?+
  # will be called from ActiveModel::Dirty. See the documentation for those
  # methods in ActiveModel::Type::Value for more details.
  def attribute(name, cast_type = T.unsafe(nil), **options, &block); end

  # This is the low level API which sits beneath +attribute+. It only
  # accepts type objects, and will do its work immediately instead of
  # waiting for the schema to load. Automatic schema detection and
  # ClassMethods#attribute both call this under the hood. While this method
  # is provided so it can be used by plugin authors, application code
  # should probably use ClassMethods#attribute.
  #
  # +name+ The name of the attribute being defined. Expected to be a +String+.
  #
  # +cast_type+ The type object to use for this attribute.
  #
  # +default+ The default value to use when no value is provided. If this option
  # is not passed, the previous default value (if any) will be used.
  # Otherwise, the default will be +nil+. A proc can also be passed, and
  # will be called once each time a new value is needed.
  #
  # +user_provided_default+ Whether the default value should be cast using
  # +cast+ or +deserialize+.
  def define_attribute(name, cast_type, default: T.unsafe(nil), user_provided_default: T.unsafe(nil)); end

  def load_schema!; end

  private

  def _lookup_cast_type(name, type, options); end
  def decorate_attribute_type(attr_name, **default); end
  def define_default_attribute(name, value, type, from_user:); end
end

ActiveRecord::Attributes::ClassMethods::NO_DEFAULT_PROVIDED = T.let(T.unsafe(nil), Object)

# = Active Record Autosave Association
#
# AutosaveAssociation is a module that takes care of automatically saving
# associated records when their parent is saved. In addition to saving, it
# also destroys any associated records that were marked for destruction.
# (See #mark_for_destruction and #marked_for_destruction?).
#
# Saving of the parent, its associations, and the destruction of marked
# associations, all happen inside a transaction. This should never leave the
# database in an inconsistent state.
#
# If validations for any of the associations fail, their error messages will
# be applied to the parent.
#
# Note that it also means that associations marked for destruction won't
# be destroyed directly. They will however still be marked for destruction.
#
# Note that <tt>autosave: false</tt> is not same as not declaring <tt>:autosave</tt>.
# When the <tt>:autosave</tt> option is not present then new association records are
# saved but the updated association records are not saved.
#
# == Validation
#
# Child records are validated unless <tt>:validate</tt> is +false+.
#
# == Callbacks
#
# Association with autosave option defines several callbacks on your
# model (around_save, before_save, after_create, after_update). Please note that
# callbacks are executed in the order they were defined in
# model. You should avoid modifying the association content before
# autosave callbacks are executed. Placing your callbacks after
# associations is usually a good practice.
#
# === One-to-one Example
#
#   class Post < ActiveRecord::Base
#     has_one :author, autosave: true
#   end
#
# Saving changes to the parent and its associated model can now be performed
# automatically _and_ atomically:
#
#   post = Post.find(1)
#   post.title       # => "The current global position of migrating ducks"
#   post.author.name # => "alloy"
#
#   post.title = "On the migration of ducks"
#   post.author.name = "Eloy Duran"
#
#   post.save
#   post.reload
#   post.title       # => "On the migration of ducks"
#   post.author.name # => "Eloy Duran"
#
# Destroying an associated model, as part of the parent's save action, is as
# simple as marking it for destruction:
#
#   post.author.mark_for_destruction
#   post.author.marked_for_destruction? # => true
#
# Note that the model is _not_ yet removed from the database:
#
#   id = post.author.id
#   Author.find_by(id: id).nil? # => false
#
#   post.save
#   post.reload.author # => nil
#
# Now it _is_ removed from the database:
#
#   Author.find_by(id: id).nil? # => true
#
# === One-to-many Example
#
# When <tt>:autosave</tt> is not declared new children are saved when their parent is saved:
#
#   class Post < ActiveRecord::Base
#     has_many :comments # :autosave option is not declared
#   end
#
#   post = Post.new(title: 'ruby rocks')
#   post.comments.build(body: 'hello world')
#   post.save # => saves both post and comment
#
#   post = Post.create(title: 'ruby rocks')
#   post.comments.build(body: 'hello world')
#   post.save # => saves both post and comment
#
#   post = Post.create(title: 'ruby rocks')
#   comment = post.comments.create(body: 'hello world')
#   comment.body = 'hi everyone'
#   post.save # => saves post, but not comment
#
# When <tt>:autosave</tt> is true all children are saved, no matter whether they
# are new records or not:
#
#   class Post < ActiveRecord::Base
#     has_many :comments, autosave: true
#   end
#
#   post = Post.create(title: 'ruby rocks')
#   comment = post.comments.create(body: 'hello world')
#   comment.body = 'hi everyone'
#   post.comments.build(body: "good morning.")
#   post.save # => saves post and both comments.
#
# Destroying one of the associated models as part of the parent's save action
# is as simple as marking it for destruction:
#
#   post.comments # => [#<Comment id: 1, ...>, #<Comment id: 2, ...]>
#   post.comments[1].mark_for_destruction
#   post.comments[1].marked_for_destruction? # => true
#   post.comments.length # => 2
#
# Note that the model is _not_ yet removed from the database:
#
#   id = post.comments.last.id
#   Comment.find_by(id: id).nil? # => false
#
#   post.save
#   post.reload.comments.length # => 1
#
# Now it _is_ removed from the database:
#
#   Comment.find_by(id: id).nil? # => true
#
# === Caveats
#
# Note that autosave will only trigger for already-persisted association records
# if the records themselves have been changed. This is to protect against
# <tt>SystemStackError</tt> caused by circular association validations. The one
# exception is if a custom validation context is used, in which case the validations
# will always fire on the associated records.
module ActiveRecord::AutosaveAssociation
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::ActiveRecord::AutosaveAssociation::ClassMethods

  # Returns whether or not this record has been changed in any way (including whether
  # any of its nested autosave associations are likewise changed)
  #
  # @return [Boolean]
  def changed_for_autosave?; end

  # Returns the association for the parent being destroyed.
  #
  # Used to avoid updating the counter cache unnecessarily.
  def destroyed_by_association; end

  # Records the association that is being destroyed and destroying this
  # record in the process.
  def destroyed_by_association=(reflection); end

  # Marks this record to be destroyed as part of the parent's save transaction.
  # This does _not_ actually destroy the record instantly, rather child record will be destroyed
  # when <tt>parent.save</tt> is called.
  #
  # Only useful if the <tt>:autosave</tt> option on the parent is enabled for this associated model.
  def mark_for_destruction; end

  # Returns whether or not this record will be destroyed as part of the parent's save transaction.
  #
  # Only useful if the <tt>:autosave</tt> option on the parent is enabled for this associated model.
  #
  # @return [Boolean]
  def marked_for_destruction?; end

  # Reloads the attributes of the object as usual and clears <tt>marked_for_destruction</tt> flag.
  def reload(options = T.unsafe(nil)); end

  private

  def _ensure_no_duplicate_errors; end

  # Is used as an around_save callback to check while saving a collection
  # association whether or not the parent was a new record before saving.
  def around_save_collection_association; end

  # Returns the record for an association collection that should be validated
  # or saved. If +autosave+ is +false+ only new records will be returned,
  # unless the parent is/was a new record itself.
  def associated_records_to_validate_or_save(association, new_record, autosave); end

  # @return [Boolean]
  def association_foreign_key_changed?(reflection, record, key); end

  # Returns whether or not the association is valid and applies any errors to
  # the parent, <tt>self</tt>, if it wasn't. Skips any <tt>:autosave</tt>
  # enabled records if they're marked_for_destruction? or destroyed.
  #
  # @return [Boolean]
  def association_valid?(reflection, record, index = T.unsafe(nil)); end

  # @return [Boolean]
  def custom_validation_context?; end

  # Go through nested autosave associations that are loaded in memory (without loading
  # any new ones), and return true if any are changed for autosave.
  # Returns false if already called to prevent an infinite loop.
  #
  # @return [Boolean]
  def nested_records_changed_for_autosave?; end

  def normalize_reflection_attribute(indexed_attribute, reflection, index, attribute); end

  # If the record is new or it has changed, returns true.
  #
  # @return [Boolean]
  def record_changed?(reflection, record, key); end

  # Saves the associated record if it's new or <tt>:autosave</tt> is enabled.
  #
  # In addition, it will destroy the association if it was marked for destruction.
  def save_belongs_to_association(reflection); end

  # Saves any new associated records, or all loaded autosave associations if
  # <tt>:autosave</tt> is enabled on the association.
  #
  # In addition, it destroys all children that were marked for destruction
  # with #mark_for_destruction.
  #
  # This all happens inside a transaction, _if_ the Transactions module is included into
  # ActiveRecord::Base after the AutosaveAssociation module, which it does by default.
  def save_collection_association(reflection); end

  # Saves the associated record if it's new or <tt>:autosave</tt> is enabled
  # on the association.
  #
  # In addition, it will destroy the association if it was marked for
  # destruction with #mark_for_destruction.
  #
  # This all happens inside a transaction, _if_ the Transactions module is included into
  # ActiveRecord::Base after the AutosaveAssociation module, which it does by default.
  def save_has_one_association(reflection); end

  # Validate the associated records if <tt>:validate</tt> or
  # <tt>:autosave</tt> is turned on for the association specified by
  # +reflection+.
  def validate_collection_association(reflection); end

  # Validate the association if <tt>:validate</tt> or <tt>:autosave</tt> is
  # turned on for the association.
  def validate_single_association(reflection); end
end

module ActiveRecord::AutosaveAssociation::AssociationBuilderExtension
  class << self
    def build(model, reflection); end
    def valid_options; end
  end
end

module ActiveRecord::AutosaveAssociation::ClassMethods
  private

  # Adds validation and save callbacks for the association as specified by
  # the +reflection+.
  #
  # For performance reasons, we don't check whether to validate at runtime.
  # However the validation and callback methods are lazy and those methods
  # get created when they are invoked for the very first time. However,
  # this can change, for instance, when using nested attributes, which is
  # called _after_ the association has been defined. Since we don't want
  # the callbacks to get defined multiple times, there are guards that
  # check if the save or validation methods have already been defined
  # before actually defining them.
  def add_autosave_association_callbacks(reflection); end

  def define_autosave_validation_callbacks(reflection); end
  def define_non_cyclic_method(name, &block); end
end

# = Active Record
#
# Active Record objects don't specify their attributes directly, but rather infer them from
# the table definition with which they're linked. Adding, removing, and changing attributes
# and their type is done directly in the database. Any change is instantly reflected in the
# Active Record objects. The mapping that binds a given Active Record class to a certain
# database table will happen automatically in most common cases, but can be overwritten for the uncommon ones.
#
# See the mapping rules in table_name and the full example in link:files/activerecord/README_rdoc.html for more insight.
#
# == Creation
#
# Active Records accept constructor parameters either in a hash or as a block. The hash
# method is especially useful when you're receiving the data from somewhere else, like an
# HTTP request. It works like this:
#
#   user = User.new(name: "David", occupation: "Code Artist")
#   user.name # => "David"
#
# You can also use block initialization:
#
#   user = User.new do |u|
#     u.name = "David"
#     u.occupation = "Code Artist"
#   end
#
# And of course you can just create a bare object and specify the attributes after the fact:
#
#   user = User.new
#   user.name = "David"
#   user.occupation = "Code Artist"
#
# == Conditions
#
# Conditions can either be specified as a string, array, or hash representing the WHERE-part of an SQL statement.
# The array form is to be used when the condition input is tainted and requires sanitization. The string form can
# be used for statements that don't involve tainted data. The hash form works much like the array form, except
# only equality and range is possible. Examples:
#
#   class User < ActiveRecord::Base
#     def self.authenticate_unsafely(user_name, password)
#       where("user_name = '#{user_name}' AND password = '#{password}'").first
#     end
#
#     def self.authenticate_safely(user_name, password)
#       where("user_name = ? AND password = ?", user_name, password).first
#     end
#
#     def self.authenticate_safely_simply(user_name, password)
#       where(user_name: user_name, password: password).first
#     end
#   end
#
# The <tt>authenticate_unsafely</tt> method inserts the parameters directly into the query
# and is thus susceptible to SQL-injection attacks if the <tt>user_name</tt> and +password+
# parameters come directly from an HTTP request. The <tt>authenticate_safely</tt> and
# <tt>authenticate_safely_simply</tt> both will sanitize the <tt>user_name</tt> and +password+
# before inserting them in the query, which will ensure that an attacker can't escape the
# query and fake the login (or worse).
#
# When using multiple parameters in the conditions, it can easily become hard to read exactly
# what the fourth or fifth question mark is supposed to represent. In those cases, you can
# resort to named bind variables instead. That's done by replacing the question marks with
# symbols and supplying a hash with values for the matching symbol keys:
#
#   Company.where(
#     "id = :id AND name = :name AND division = :division AND created_at > :accounting_date",
#     { id: 3, name: "37signals", division: "First", accounting_date: '2005-01-01' }
#   ).first
#
# Similarly, a simple hash without a statement will generate conditions based on equality with the SQL AND
# operator. For instance:
#
#   Student.where(first_name: "Harvey", status: 1)
#   Student.where(params[:student])
#
# A range may be used in the hash to use the SQL BETWEEN operator:
#
#   Student.where(grade: 9..12)
#
# An array may be used in the hash to use the SQL IN operator:
#
#   Student.where(grade: [9,11,12])
#
# When joining tables, nested hashes or keys written in the form 'table_name.column_name'
# can be used to qualify the table name of a particular condition. For instance:
#
#   Student.joins(:schools).where(schools: { category: 'public' })
#   Student.joins(:schools).where('schools.category' => 'public' )
#
# == Overwriting default accessors
#
# All column values are automatically available through basic accessors on the Active Record
# object, but sometimes you want to specialize this behavior. This can be done by overwriting
# the default accessors (using the same name as the attribute) and calling
# +super+ to actually change things.
#
#   class Song < ActiveRecord::Base
#     # Uses an integer of seconds to hold the length of the song
#
#     def length=(minutes)
#       super(minutes.to_i * 60)
#     end
#
#     def length
#       super / 60
#     end
#   end
#
# == Attribute query methods
#
# In addition to the basic accessors, query methods are also automatically available on the Active Record object.
# Query methods allow you to test whether an attribute value is present.
# Additionally, when dealing with numeric values, a query method will return false if the value is zero.
#
# For example, an Active Record User with the <tt>name</tt> attribute has a <tt>name?</tt> method that you can call
# to determine whether the user has a name:
#
#   user = User.new(name: "David")
#   user.name? # => true
#
#   anonymous = User.new(name: "")
#   anonymous.name? # => false
#
# == Accessing attributes before they have been typecasted
#
# Sometimes you want to be able to read the raw attribute data without having the column-determined
# typecast run its course first. That can be done by using the <tt><attribute>_before_type_cast</tt>
# accessors that all attributes have. For example, if your Account model has a <tt>balance</tt> attribute,
# you can call <tt>account.balance_before_type_cast</tt> or <tt>account.id_before_type_cast</tt>.
#
# This is especially useful in validation situations where the user might supply a string for an
# integer field and you want to display the original string back in an error message. Accessing the
# attribute normally would typecast the string to 0, which isn't what you want.
#
# == Dynamic attribute-based finders
#
# Dynamic attribute-based finders are a mildly deprecated way of getting (and/or creating) objects
# by simple queries without turning to SQL. They work by appending the name of an attribute
# to <tt>find_by_</tt> like <tt>Person.find_by_user_name</tt>.
# Instead of writing <tt>Person.find_by(user_name: user_name)</tt>, you can use
# <tt>Person.find_by_user_name(user_name)</tt>.
#
# It's possible to add an exclamation point (!) on the end of the dynamic finders to get them to raise an
# ActiveRecord::RecordNotFound error if they do not return any records,
# like <tt>Person.find_by_last_name!</tt>.
#
# It's also possible to use multiple attributes in the same <tt>find_by_</tt> by separating them with
# "_and_".
#
#  Person.find_by(user_name: user_name, password: password)
#  Person.find_by_user_name_and_password(user_name, password) # with dynamic finder
#
# It's even possible to call these dynamic finder methods on relations and named scopes.
#
#   Payment.order("created_on").find_by_amount(50)
#
# == Saving arrays, hashes, and other non-mappable objects in text columns
#
# Active Record can serialize any object in text columns using YAML. To do so, you must
# specify this with a call to the class method
# {serialize}[rdoc-ref:AttributeMethods::Serialization::ClassMethods#serialize].
# This makes it possible to store arrays, hashes, and other non-mappable objects without doing
# any additional work.
#
#   class User < ActiveRecord::Base
#     serialize :preferences
#   end
#
#   user = User.create(preferences: { "background" => "black", "display" => large })
#   User.find(user.id).preferences # => { "background" => "black", "display" => large }
#
# You can also specify a class option as the second parameter that'll raise an exception
# if a serialized object is retrieved as a descendant of a class not in the hierarchy.
#
#   class User < ActiveRecord::Base
#     serialize :preferences, Hash
#   end
#
#   user = User.create(preferences: %w( one two three ))
#   User.find(user.id).preferences    # raises SerializationTypeMismatch
#
# When you specify a class option, the default value for that attribute will be a new
# instance of that class.
#
#   class User < ActiveRecord::Base
#     serialize :preferences, OpenStruct
#   end
#
#   user = User.new
#   user.preferences.theme_color = "red"
#
#
# == Single table inheritance
#
# Active Record allows inheritance by storing the name of the class in a
# column that is named "type" by default. See ActiveRecord::Inheritance for
# more details.
#
# == Connection to multiple databases in different models
#
# Connections are usually created through
# {ActiveRecord::Base.establish_connection}[rdoc-ref:ConnectionHandling#establish_connection] and retrieved
# by ActiveRecord::Base.connection. All classes inheriting from ActiveRecord::Base will use this
# connection. But you can also set a class-specific connection. For example, if Course is an
# ActiveRecord::Base, but resides in a different database, you can just say <tt>Course.establish_connection</tt>
# and Course and all of its subclasses will use this connection instead.
#
# This feature is implemented by keeping a connection pool in ActiveRecord::Base that is
# a hash indexed by the class. If a connection is requested, the
# {ActiveRecord::Base.retrieve_connection}[rdoc-ref:ConnectionHandling#retrieve_connection] method
# will go up the class-hierarchy until a connection is found in the connection pool.
#
# == Exceptions
#
# * ActiveRecordError - Generic error class and superclass of all other errors raised by Active Record.
# * AdapterNotSpecified - The configuration hash used in
#   {ActiveRecord::Base.establish_connection}[rdoc-ref:ConnectionHandling#establish_connection]
#   didn't include an <tt>:adapter</tt> key.
# * AdapterNotFound - The <tt>:adapter</tt> key used in
#   {ActiveRecord::Base.establish_connection}[rdoc-ref:ConnectionHandling#establish_connection]
#   specified a non-existent adapter
#   (or a bad spelling of an existing one).
# * AssociationTypeMismatch - The object assigned to the association wasn't of the type
#   specified in the association definition.
# * AttributeAssignmentError - An error occurred while doing a mass assignment through the
#   {ActiveRecord::Base#attributes=}[rdoc-ref:AttributeAssignment#attributes=] method.
#   You can inspect the +attribute+ property of the exception object to determine which attribute
#   triggered the error.
# * ConnectionNotEstablished - No connection has been established.
#   Use {ActiveRecord::Base.establish_connection}[rdoc-ref:ConnectionHandling#establish_connection] before querying.
# * MultiparameterAssignmentErrors - Collection of errors that occurred during a mass assignment using the
#   {ActiveRecord::Base#attributes=}[rdoc-ref:AttributeAssignment#attributes=] method.
#   The +errors+ property of this exception contains an array of
#   AttributeAssignmentError
#   objects that should be inspected to determine which attributes triggered the errors.
# * RecordInvalid - raised by {ActiveRecord::Base#save!}[rdoc-ref:Persistence#save!] and
#   {ActiveRecord::Base.create!}[rdoc-ref:Persistence::ClassMethods#create!]
#   when the record is invalid.
# * RecordNotFound - No record responded to the {ActiveRecord::Base.find}[rdoc-ref:FinderMethods#find] method.
#   Either the row with the given ID doesn't exist or the row didn't meet the additional restrictions.
#   Some {ActiveRecord::Base.find}[rdoc-ref:FinderMethods#find] calls do not raise this exception to signal
#   nothing was found, please check its documentation for further details.
# * SerializationTypeMismatch - The serialized object wasn't of the class specified as the second parameter.
# * StatementInvalid - The database server rejected the SQL statement. The precise error is added in the message.
#
# *Note*: The attributes listed are class-level attributes (accessible from both the class and instance level).
# So it's possible to assign a logger to the class through <tt>Base.logger=</tt> which will then be used by all
# instances in the current object space.
class ActiveRecord::Base
  include ::ActiveRecord::Core
  include ::ActiveRecord::Persistence
  include ::ActiveRecord::ReadonlyAttributes
  include ::ActiveRecord::ModelSchema
  include ::ActiveRecord::Inheritance
  include ::ActiveRecord::Scoping
  include ::ActiveRecord::Scoping::Default
  include ::ActiveRecord::Scoping::Named
  include ::ActiveRecord::Sanitization
  include ::ActiveModel::ForbiddenAttributesProtection
  include ::ActiveModel::AttributeAssignment
  include ::ActiveRecord::AttributeAssignment
  include ::ActiveModel::Conversion
  include ::ActiveRecord::Integration
  include ::ActiveModel::Validations
  include ::ActiveSupport::Callbacks
  include ::ActiveModel::Validations::HelperMethods
  include ::ActiveRecord::Validations
  include ::ActiveRecord::CounterCache
  include ::ActiveRecord::Attributes
  include ::ActiveRecord::Locking::Optimistic
  include ::ActiveRecord::Locking::Pessimistic
  include ::ActiveModel::AttributeMethods
  include ::ActiveRecord::AttributeMethods
  include ::ActiveRecord::Base::GeneratedAttributeMethods
  include ::ActiveRecord::Base::GeneratedAssociationMethods
  include ::ActiveRecord::AttributeMethods::Read
  include ::ActiveRecord::AttributeMethods::Write
  include ::ActiveRecord::AttributeMethods::BeforeTypeCast
  include ::ActiveRecord::AttributeMethods::Query
  include ::ActiveRecord::AttributeMethods::PrimaryKey
  include ::ActiveRecord::AttributeMethods::TimeZoneConversion
  include ::ActiveModel::Dirty
  include ::ActiveRecord::AttributeMethods::Dirty
  include ::ActiveRecord::AttributeMethods::Serialization
  include ::ActiveRecord::Callbacks
  include ::ActiveModel::Validations::Callbacks
  include ::ActiveRecord::Timestamp
  include ::ActiveRecord::Associations
  include ::ActiveModel::SecurePassword
  include ::ActiveRecord::AutosaveAssociation
  include ::ActiveRecord::NestedAttributes
  include ::ActiveRecord::Transactions
  include ::ActiveRecord::TouchLater
  include ::ActiveRecord::NoTouching
  include ::ActiveRecord::Reflection
  include ::ActiveModel::Serialization
  include ::ActiveModel::Serializers::JSON
  include ::ActiveRecord::Serialization
  include ::ActiveRecord::Store
  include ::ActiveRecord::SecureToken
  include ::ActiveRecord::SignedId
  include ::ActiveRecord::Suppressor
  extend ::ActiveModel::Naming
  extend ::ActiveSupport::Benchmarkable
  extend ::ActiveSupport::DescendantsTracker
  extend ::ActiveRecord::ConnectionHandling
  extend ::ActiveRecord::QueryCache::ClassMethods
  extend ::ActiveRecord::Querying
  extend ::ActiveModel::Translation
  extend ::ActiveRecord::Translation
  extend ::ActiveRecord::DynamicMatchers
  extend ::ActiveRecord::DelegatedType
  extend ::ActiveRecord::Explain
  extend ::ActiveRecord::Enum
  extend ::ActiveRecord::Delegation::DelegateCache
  extend ::ActiveRecord::Aggregations::ClassMethods
  extend ::ActiveRecord::Core::ClassMethods
  extend ::ActiveRecord::Persistence::ClassMethods
  extend ::ActiveRecord::ReadonlyAttributes::ClassMethods
  extend ::ActiveRecord::ModelSchema::ClassMethods
  extend ::ActiveRecord::Inheritance::ClassMethods
  extend ::ActiveRecord::Scoping::ClassMethods
  extend ::ActiveRecord::Scoping::Default::ClassMethods
  extend ::ActiveRecord::Scoping::Named::ClassMethods
  extend ::ActiveRecord::Sanitization::ClassMethods
  extend ::ActiveModel::Conversion::ClassMethods
  extend ::ActiveRecord::Integration::ClassMethods
  extend ::ActiveModel::Validations::ClassMethods
  extend ::ActiveModel::Callbacks
  extend ::ActiveSupport::Callbacks::ClassMethods
  extend ::ActiveModel::Validations::HelperMethods
  extend ::ActiveRecord::Validations::ClassMethods
  extend ::ActiveRecord::CounterCache::ClassMethods
  extend ::ActiveRecord::Attributes::ClassMethods
  extend ::ActiveRecord::Locking::Optimistic::ClassMethods
  extend ::ActiveModel::AttributeMethods::ClassMethods
  extend ::ActiveRecord::AttributeMethods::ClassMethods
  extend ::ActiveRecord::AttributeMethods::Read::ClassMethods
  extend ::ActiveRecord::AttributeMethods::Write::ClassMethods
  extend ::ActiveRecord::AttributeMethods::PrimaryKey::ClassMethods
  extend ::ActiveRecord::AttributeMethods::TimeZoneConversion::ClassMethods
  extend ::ActiveRecord::AttributeMethods::Serialization::ClassMethods
  extend ::ActiveRecord::Callbacks::ClassMethods
  extend ::ActiveModel::Validations::Callbacks::ClassMethods
  extend ::ActiveRecord::Timestamp::ClassMethods
  extend ::ActiveRecord::Associations::ClassMethods
  extend ::ActiveModel::SecurePassword::ClassMethods
  extend ::ActiveRecord::AutosaveAssociation::ClassMethods
  extend ::ActiveRecord::NestedAttributes::ClassMethods
  extend ::ActiveRecord::Transactions::ClassMethods
  extend ::ActiveRecord::NoTouching::ClassMethods
  extend ::ActiveRecord::Reflection::ClassMethods
  extend ::ActiveRecord::Store::ClassMethods
  extend ::ActiveRecord::SecureToken::ClassMethods
  extend ::ActiveRecord::SignedId::ClassMethods
  extend ::ActiveRecord::Suppressor::ClassMethods

  def __callbacks; end
  def __callbacks?; end
  def _before_commit_callbacks; end
  def _commit_callbacks; end
  def _create_callbacks; end
  def _destroy_callbacks; end
  def _find_callbacks; end
  def _initialize_callbacks; end
  def _reflections; end
  def _reflections?; end
  def _rollback_callbacks; end
  def _run_before_commit_callbacks(&block); end
  def _run_commit_callbacks(&block); end
  def _run_create_callbacks(&block); end
  def _run_destroy_callbacks(&block); end
  def _run_find_callbacks(&block); end
  def _run_initialize_callbacks(&block); end
  def _run_rollback_callbacks(&block); end
  def _run_save_callbacks(&block); end
  def _run_touch_callbacks(&block); end
  def _run_update_callbacks(&block); end
  def _run_validate_callbacks(&block); end
  def _run_validation_callbacks(&block); end
  def _save_callbacks; end
  def _touch_callbacks; end
  def _update_callbacks; end
  def _validate_callbacks; end
  def _validation_callbacks; end
  def _validators; end
  def _validators?; end
  def aggregate_reflections; end
  def aggregate_reflections?; end
  def attribute_aliases; end
  def attribute_aliases?; end
  def attribute_method_matchers; end
  def attribute_method_matchers?; end
  def cache_timestamp_format; end
  def cache_timestamp_format?; end
  def cache_versioning; end
  def cache_versioning?; end
  def collection_cache_versioning; end
  def collection_cache_versioning?; end
  def column_for_attribute(*_arg0, &_arg1); end
  def default_connection_handler; end
  def default_connection_handler?; end
  def default_role; end
  def default_role?; end
  def default_scope_override; end
  def default_scopes; end
  def default_shard; end
  def default_shard?; end
  def default_timezone; end
  def defined_enums; end
  def defined_enums?; end
  def destroy_association_async_job; end
  def dump_schema_after_migration; end
  def dump_schemas; end
  def error_on_ignored_order; end
  def include_root_in_json; end
  def include_root_in_json?; end
  def index_nested_attribute_errors; end
  def legacy_connection_handling; end
  def lock_optimistically; end
  def lock_optimistically?; end
  def logger; end
  def model_name(*_arg0, &_arg1); end
  def nested_attributes_options; end
  def nested_attributes_options?; end
  def partial_writes; end
  def partial_writes?; end
  def pluralize_table_names; end
  def pluralize_table_names?; end
  def primary_key_prefix_type; end
  def record_timestamps; end
  def record_timestamps=(_arg0); end
  def record_timestamps?; end
  def schema_format; end
  def signed_id_verifier_secret; end
  def skip_time_zone_conversion_for_attributes; end
  def skip_time_zone_conversion_for_attributes?; end
  def store_full_class_name; end
  def store_full_class_name?; end
  def store_full_sti_class; end
  def store_full_sti_class?; end
  def suppress_multiple_database_warning; end
  def table_name_prefix; end
  def table_name_prefix?; end
  def table_name_suffix; end
  def table_name_suffix?; end
  def time_zone_aware_attributes; end
  def time_zone_aware_types; end
  def time_zone_aware_types?; end
  def timestamped_migrations; end
  def type_for_attribute(*_arg0, &_arg1); end
  def validation_context; end
  def verbose_query_logs; end
  def warn_on_records_fetched_greater_than; end

  private

  def validation_context=(_arg0); end

  class << self
    def __callbacks; end
    def __callbacks=(value); end
    def __callbacks?; end
    def _attr_readonly; end
    def _attr_readonly=(value); end
    def _attr_readonly?; end
    def _before_commit_callbacks; end
    def _before_commit_callbacks=(value); end
    def _commit_callbacks; end
    def _commit_callbacks=(value); end
    def _create_callbacks; end
    def _create_callbacks=(value); end
    def _destroy_callbacks; end
    def _destroy_callbacks=(value); end
    def _find_callbacks; end
    def _find_callbacks=(value); end
    def _initialize_callbacks; end
    def _initialize_callbacks=(value); end
    def _reflections; end
    def _reflections=(value); end
    def _reflections?; end
    def _rollback_callbacks; end
    def _rollback_callbacks=(value); end
    def _save_callbacks; end
    def _save_callbacks=(value); end
    def _touch_callbacks; end
    def _touch_callbacks=(value); end
    def _update_callbacks; end
    def _update_callbacks=(value); end
    def _validate_callbacks; end
    def _validate_callbacks=(value); end
    def _validation_callbacks; end
    def _validation_callbacks=(value); end
    def _validators; end
    def _validators=(value); end
    def _validators?; end
    def action_on_strict_loading_violation; end
    def action_on_strict_loading_violation=(val); end
    def after_create(*args, **options, &block); end
    def after_destroy(*args, **options, &block); end
    def after_find(*args, **options, &block); end
    def after_initialize(*args, **options, &block); end
    def after_save(*args, **options, &block); end
    def after_touch(*args, **options, &block); end
    def after_update(*args, **options, &block); end
    def aggregate_reflections; end
    def aggregate_reflections=(value); end
    def aggregate_reflections?; end
    def allow_unsafe_raw_sql; end
    def allow_unsafe_raw_sql=(value); end
    def around_create(*args, **options, &block); end
    def around_destroy(*args, **options, &block); end
    def around_save(*args, **options, &block); end
    def around_update(*args, **options, &block); end
    def attribute_aliases; end
    def attribute_aliases=(value); end
    def attribute_aliases?; end
    def attribute_method_matchers; end
    def attribute_method_matchers=(value); end
    def attribute_method_matchers?; end
    def attributes_to_define_after_schema_loads; end
    def attributes_to_define_after_schema_loads=(value); end
    def attributes_to_define_after_schema_loads?; end
    def before_create(*args, **options, &block); end
    def before_destroy(*args, **options, &block); end
    def before_save(*args, **options, &block); end
    def before_update(*args, **options, &block); end
    def belongs_to_required_by_default; end
    def belongs_to_required_by_default=(value); end
    def belongs_to_required_by_default?; end
    def cache_timestamp_format; end
    def cache_timestamp_format=(value); end
    def cache_timestamp_format?; end
    def cache_versioning; end
    def cache_versioning=(value); end
    def cache_versioning?; end
    def collection_cache_versioning; end
    def collection_cache_versioning=(value); end
    def collection_cache_versioning?; end
    def configurations; end
    def configurations=(config); end
    def connected_to_stack; end
    def connection_class; end
    def connection_class=(b); end
    def connection_class?; end
    def connection_classes; end
    def connection_handler; end
    def connection_handler=(handler); end
    def connection_handlers; end
    def connection_handlers=(handlers); end
    def current_preventing_writes; end
    def current_role; end
    def current_shard; end
    def default_connection_handler; end
    def default_connection_handler=(value); end
    def default_connection_handler?; end
    def default_role; end
    def default_role=(value); end
    def default_role?; end
    def default_scope_override; end
    def default_scope_override=(value); end
    def default_scopes; end
    def default_scopes=(value); end
    def default_shard; end
    def default_shard=(value); end
    def default_shard?; end
    def default_timezone; end
    def default_timezone=(val); end
    def defined_enums; end
    def defined_enums=(value); end
    def defined_enums?; end
    def destroy_association_async_job; end
    def destroy_association_async_job=(value); end
    def dump_schema_after_migration; end
    def dump_schema_after_migration=(val); end
    def dump_schemas; end
    def dump_schemas=(val); end
    def error_on_ignored_order; end
    def error_on_ignored_order=(val); end
    def has_many_inversing; end
    def has_many_inversing=(val); end
    def immutable_strings_by_default; end
    def immutable_strings_by_default=(value); end
    def immutable_strings_by_default?; end
    def implicit_order_column; end
    def implicit_order_column=(value); end
    def implicit_order_column?; end
    def include_root_in_json; end
    def include_root_in_json=(value); end
    def include_root_in_json?; end
    def index_nested_attribute_errors; end
    def index_nested_attribute_errors=(val); end
    def internal_metadata_table_name; end
    def internal_metadata_table_name=(value); end
    def internal_metadata_table_name?; end
    def legacy_connection_handling; end
    def legacy_connection_handling=(val); end
    def local_stored_attributes; end
    def local_stored_attributes=(_arg0); end
    def lock_optimistically; end
    def lock_optimistically=(value); end
    def lock_optimistically?; end
    def logger; end
    def logger=(val); end
    def maintain_test_schema; end
    def maintain_test_schema=(val); end
    def nested_attributes_options; end
    def nested_attributes_options=(value); end
    def nested_attributes_options?; end
    def partial_writes; end
    def partial_writes=(value); end
    def partial_writes?; end
    def pluralize_table_names; end
    def pluralize_table_names=(value); end
    def pluralize_table_names?; end
    def primary_key_prefix_type; end
    def primary_key_prefix_type=(val); end
    def queues; end
    def queues=(val); end
    def reading_role; end
    def reading_role=(val); end
    def record_timestamps; end
    def record_timestamps=(value); end
    def record_timestamps?; end
    def schema_format; end
    def schema_format=(val); end
    def schema_migrations_table_name; end
    def schema_migrations_table_name=(value); end
    def schema_migrations_table_name?; end
    def signed_id_verifier_secret; end
    def signed_id_verifier_secret=(val); end
    def skip_time_zone_conversion_for_attributes; end
    def skip_time_zone_conversion_for_attributes=(value); end
    def skip_time_zone_conversion_for_attributes?; end
    def store_full_class_name; end
    def store_full_class_name=(value); end
    def store_full_class_name?; end
    def store_full_sti_class; end
    def store_full_sti_class=(value); end
    def store_full_sti_class?; end
    def strict_loading_by_default; end
    def strict_loading_by_default=(value); end
    def strict_loading_by_default?; end
    def strict_loading_violation!(owner:, reflection:); end
    def suppress_multiple_database_warning; end
    def suppress_multiple_database_warning=(val); end
    def table_name_prefix; end
    def table_name_prefix=(value); end
    def table_name_prefix?; end
    def table_name_suffix; end
    def table_name_suffix=(value); end
    def table_name_suffix?; end
    def time_zone_aware_attributes; end
    def time_zone_aware_attributes=(val); end
    def time_zone_aware_types; end
    def time_zone_aware_types=(value); end
    def time_zone_aware_types?; end
    def timestamped_migrations; end
    def timestamped_migrations=(val); end
    def verbose_query_logs; end
    def verbose_query_logs=(val); end
    def warn_on_records_fetched_greater_than; end
    def warn_on_records_fetched_greater_than=(val); end
    def writing_role; end
    def writing_role=(val); end
  end
end

module ActiveRecord::Base::GeneratedAssociationMethods; end
module ActiveRecord::Base::GeneratedAttributeMethods; end

module ActiveRecord::Batches
  # Looping through a collection of records from the database
  # (using the Scoping::Named::ClassMethods.all method, for example)
  # is very inefficient since it will try to instantiate all the objects at once.
  #
  # In that case, batch processing methods allow you to work
  # with the records in batches, thereby greatly reducing memory consumption.
  #
  # The #find_each method uses #find_in_batches with a batch size of 1000 (or as
  # specified by the +:batch_size+ option).
  #
  #   Person.find_each do |person|
  #     person.do_awesome_stuff
  #   end
  #
  #   Person.where("age > 21").find_each do |person|
  #     person.party_all_night!
  #   end
  #
  # If you do not provide a block to #find_each, it will return an Enumerator
  # for chaining with other methods:
  #
  #   Person.find_each.with_index do |person, index|
  #     person.award_trophy(index + 1)
  #   end
  #
  # ==== Options
  # * <tt>:batch_size</tt> - Specifies the size of the batch. Defaults to 1000.
  # * <tt>:start</tt> - Specifies the primary key value to start from, inclusive of the value.
  # * <tt>:finish</tt> - Specifies the primary key value to end at, inclusive of the value.
  # * <tt>:error_on_ignore</tt> - Overrides the application config to specify if an error should be raised when
  #   an order is present in the relation.
  # * <tt>:order</tt> - Specifies the primary key order (can be :asc or :desc). Defaults to :asc.
  #
  # Limits are honored, and if present there is no requirement for the batch
  # size: it can be less than, equal to, or greater than the limit.
  #
  # The options +start+ and +finish+ are especially useful if you want
  # multiple workers dealing with the same processing queue. You can make
  # worker 1 handle all the records between id 1 and 9999 and worker 2
  # handle from 10000 and beyond by setting the +:start+ and +:finish+
  # option on each worker.
  #
  #   # In worker 1, let's process until 9999 records.
  #   Person.find_each(finish: 9_999) do |person|
  #     person.party_all_night!
  #   end
  #
  #   # In worker 2, let's process from record 10_000 and onwards.
  #   Person.find_each(start: 10_000) do |person|
  #     person.party_all_night!
  #   end
  #
  # NOTE: Order can be ascending (:asc) or descending (:desc). It is automatically set to
  # ascending on the primary key ("id ASC").
  # This also means that this method only works when the primary key is
  # orderable (e.g. an integer or string).
  #
  # NOTE: By its nature, batch processing is subject to race conditions if
  # other processes are modifying the database.
  def find_each(start: T.unsafe(nil), finish: T.unsafe(nil), batch_size: T.unsafe(nil), error_on_ignore: T.unsafe(nil), order: T.unsafe(nil)); end

  # Yields each batch of records that was found by the find options as
  # an array.
  #
  #   Person.where("age > 21").find_in_batches do |group|
  #     sleep(50) # Make sure it doesn't get too crowded in there!
  #     group.each { |person| person.party_all_night! }
  #   end
  #
  # If you do not provide a block to #find_in_batches, it will return an Enumerator
  # for chaining with other methods:
  #
  #   Person.find_in_batches.with_index do |group, batch|
  #     puts "Processing group ##{batch}"
  #     group.each(&:recover_from_last_night!)
  #   end
  #
  # To be yielded each record one by one, use #find_each instead.
  #
  # ==== Options
  # * <tt>:batch_size</tt> - Specifies the size of the batch. Defaults to 1000.
  # * <tt>:start</tt> - Specifies the primary key value to start from, inclusive of the value.
  # * <tt>:finish</tt> - Specifies the primary key value to end at, inclusive of the value.
  # * <tt>:error_on_ignore</tt> - Overrides the application config to specify if an error should be raised when
  #   an order is present in the relation.
  # * <tt>:order</tt> - Specifies the primary key order (can be :asc or :desc). Defaults to :asc.
  #
  # Limits are honored, and if present there is no requirement for the batch
  # size: it can be less than, equal to, or greater than the limit.
  #
  # The options +start+ and +finish+ are especially useful if you want
  # multiple workers dealing with the same processing queue. You can make
  # worker 1 handle all the records between id 1 and 9999 and worker 2
  # handle from 10000 and beyond by setting the +:start+ and +:finish+
  # option on each worker.
  #
  #   # Let's process from record 10_000 on.
  #   Person.find_in_batches(start: 10_000) do |group|
  #     group.each { |person| person.party_all_night! }
  #   end
  #
  # NOTE: Order can be ascending (:asc) or descending (:desc). It is automatically set to
  # ascending on the primary key ("id ASC").
  # This also means that this method only works when the primary key is
  # orderable (e.g. an integer or string).
  #
  # NOTE: By its nature, batch processing is subject to race conditions if
  # other processes are modifying the database.
  def find_in_batches(start: T.unsafe(nil), finish: T.unsafe(nil), batch_size: T.unsafe(nil), error_on_ignore: T.unsafe(nil), order: T.unsafe(nil)); end

  # Yields ActiveRecord::Relation objects to work with a batch of records.
  #
  #   Person.where("age > 21").in_batches do |relation|
  #     relation.delete_all
  #     sleep(10) # Throttle the delete queries
  #   end
  #
  # If you do not provide a block to #in_batches, it will return a
  # BatchEnumerator which is enumerable.
  #
  #   Person.in_batches.each_with_index do |relation, batch_index|
  #     puts "Processing relation ##{batch_index}"
  #     relation.delete_all
  #   end
  #
  # Examples of calling methods on the returned BatchEnumerator object:
  #
  #   Person.in_batches.delete_all
  #   Person.in_batches.update_all(awesome: true)
  #   Person.in_batches.each_record(&:party_all_night!)
  #
  # ==== Options
  # * <tt>:of</tt> - Specifies the size of the batch. Defaults to 1000.
  # * <tt>:load</tt> - Specifies if the relation should be loaded. Defaults to false.
  # * <tt>:start</tt> - Specifies the primary key value to start from, inclusive of the value.
  # * <tt>:finish</tt> - Specifies the primary key value to end at, inclusive of the value.
  # * <tt>:error_on_ignore</tt> - Overrides the application config to specify if an error should be raised when
  #   an order is present in the relation.
  # * <tt>:order</tt> - Specifies the primary key order (can be :asc or :desc). Defaults to :asc.
  #
  # Limits are honored, and if present there is no requirement for the batch
  # size, it can be less than, equal, or greater than the limit.
  #
  # The options +start+ and +finish+ are especially useful if you want
  # multiple workers dealing with the same processing queue. You can make
  # worker 1 handle all the records between id 1 and 9999 and worker 2
  # handle from 10000 and beyond by setting the +:start+ and +:finish+
  # option on each worker.
  #
  #   # Let's process from record 10_000 on.
  #   Person.in_batches(start: 10_000).update_all(awesome: true)
  #
  # An example of calling where query method on the relation:
  #
  #   Person.in_batches.each do |relation|
  #     relation.update_all('age = age + 1')
  #     relation.where('age > 21').update_all(should_party: true)
  #     relation.where('age <= 21').delete_all
  #   end
  #
  # NOTE: If you are going to iterate through each record, you should call
  # #each_record on the yielded BatchEnumerator:
  #
  #   Person.in_batches.each_record(&:party_all_night!)
  #
  # NOTE: Order can be ascending (:asc) or descending (:desc). It is automatically set to
  # ascending on the primary key ("id ASC").
  # This also means that this method only works when the primary key is
  # orderable (e.g. an integer or string).
  #
  # NOTE: By its nature, batch processing is subject to race conditions if
  # other processes are modifying the database.
  def in_batches(of: T.unsafe(nil), start: T.unsafe(nil), finish: T.unsafe(nil), load: T.unsafe(nil), error_on_ignore: T.unsafe(nil), order: T.unsafe(nil)); end

  private

  def act_on_ignored_order(error_on_ignore); end
  def apply_finish_limit(relation, finish, order); end
  def apply_limits(relation, start, finish, order); end
  def apply_start_limit(relation, start, order); end
  def batch_order(order); end
end

class ActiveRecord::Batches::BatchEnumerator
  include ::Enumerable

  # @return [BatchEnumerator] a new instance of BatchEnumerator
  def initialize(relation:, of: T.unsafe(nil), start: T.unsafe(nil), finish: T.unsafe(nil)); end

  # Deletes records in batches. Returns the total number of rows affected.
  #
  #   Person.in_batches.delete_all
  #
  # See Relation#delete_all for details of how each batch is deleted.
  def delete_all; end

  # Destroys records in batches.
  #
  #   Person.where("age < 10").in_batches.destroy_all
  #
  # See Relation#destroy_all for details of how each batch is destroyed.
  def destroy_all; end

  # Yields an ActiveRecord::Relation object for each batch of records.
  #
  #   Person.in_batches.each do |relation|
  #     relation.update_all(awesome: true)
  #   end
  def each; end

  # Looping through a collection of records from the database (using the
  # +all+ method, for example) is very inefficient since it will try to
  # instantiate all the objects at once.
  #
  # In that case, batch processing methods allow you to work with the
  # records in batches, thereby greatly reducing memory consumption.
  #
  #   Person.in_batches.each_record do |person|
  #     person.do_awesome_stuff
  #   end
  #
  #   Person.where("age > 21").in_batches(of: 10).each_record do |person|
  #     person.party_all_night!
  #   end
  #
  # If you do not provide a block to #each_record, it will return an Enumerator
  # for chaining with other methods:
  #
  #   Person.in_batches.each_record.with_index do |person, index|
  #     person.award_trophy(index + 1)
  #   end
  def each_record; end

  # Updates records in batches. Returns the total number of rows affected.
  #
  #   Person.in_batches.update_all("age = age + 1")
  #
  # See Relation#update_all for details of how each batch is updated.
  def update_all(updates); end
end

ActiveRecord::Batches::ORDER_IGNORE_MESSAGE = T.let(T.unsafe(nil), String)

module ActiveRecord::Calculations
  # Calculates the average value on a given column. Returns +nil+ if there's
  # no row. See #calculate for examples with options.
  #
  #   Person.average(:age) # => 35.8
  def average(column_name); end

  # This calculates aggregate values in the given column. Methods for #count, #sum, #average,
  # #minimum, and #maximum have been added as shortcuts.
  #
  #   Person.calculate(:count, :all) # The same as Person.count
  #   Person.average(:age) # SELECT AVG(age) FROM people...
  #
  #   # Selects the minimum age for any family without any minors
  #   Person.group(:last_name).having("min(age) > 17").minimum(:age)
  #
  #   Person.sum("2 * age")
  #
  # There are two basic forms of output:
  #
  # * Single aggregate value: The single value is type cast to Integer for COUNT, Float
  #   for AVG, and the given column's type for everything else.
  #
  # * Grouped values: This returns an ordered hash of the values and groups them. It
  #   takes either a column name, or the name of a belongs_to association.
  #
  #      values = Person.group('last_name').maximum(:age)
  #      puts values["Drake"]
  #      # => 43
  #
  #      drake  = Family.find_by(last_name: 'Drake')
  #      values = Person.group(:family).maximum(:age) # Person belongs_to :family
  #      puts values[drake]
  #      # => 43
  #
  #      values.each do |family, max_age|
  #        ...
  #      end
  def calculate(operation, column_name); end

  # Count the records.
  #
  #   Person.count
  #   # => the total count of all people
  #
  #   Person.count(:age)
  #   # => returns the total count of all people whose age is present in database
  #
  #   Person.count(:all)
  #   # => performs a COUNT(*) (:all is an alias for '*')
  #
  #   Person.distinct.count(:age)
  #   # => counts the number of different age values
  #
  # If #count is used with {Relation#group}[rdoc-ref:QueryMethods#group],
  # it returns a Hash whose keys represent the aggregated column,
  # and the values are the respective amounts:
  #
  #   Person.group(:city).count
  #   # => { 'Rome' => 5, 'Paris' => 3 }
  #
  # If #count is used with {Relation#group}[rdoc-ref:QueryMethods#group] for multiple columns, it returns a Hash whose
  # keys are an array containing the individual values of each column and the value
  # of each key would be the #count.
  #
  #   Article.group(:status, :category).count
  #   # =>  {["draft", "business"]=>10, ["draft", "technology"]=>4,
  #          ["published", "business"]=>0, ["published", "technology"]=>2}
  #
  # If #count is used with {Relation#select}[rdoc-ref:QueryMethods#select], it will count the selected columns:
  #
  #   Person.select(:age).count
  #   # => counts the number of different age values
  #
  # Note: not all valid {Relation#select}[rdoc-ref:QueryMethods#select] expressions are valid #count expressions. The specifics differ
  # between databases. In invalid cases, an error from the database is thrown.
  def count(column_name = T.unsafe(nil)); end

  # Pluck all the ID's for the relation using the table's primary key
  #
  #   Person.ids # SELECT people.id FROM people
  #   Person.joins(:companies).ids # SELECT people.id FROM people INNER JOIN companies ON companies.person_id = people.id
  def ids; end

  # Calculates the maximum value on a given column. The value is returned
  # with the same data type of the column, or +nil+ if there's no row. See
  # #calculate for examples with options.
  #
  #   Person.maximum(:age) # => 93
  def maximum(column_name); end

  # Calculates the minimum value on a given column. The value is returned
  # with the same data type of the column, or +nil+ if there's no row. See
  # #calculate for examples with options.
  #
  #   Person.minimum(:age) # => 7
  def minimum(column_name); end

  # Pick the value(s) from the named column(s) in the current relation.
  # This is short-hand for <tt>relation.limit(1).pluck(*column_names).first</tt>, and is primarily useful
  # when you have a relation that's already narrowed down to a single row.
  #
  # Just like #pluck, #pick will only load the actual value, not the entire record object, so it's also
  # more efficient. The value is, again like with pluck, typecast by the column type.
  #
  #   Person.where(id: 1).pick(:name)
  #   # SELECT people.name FROM people WHERE id = 1 LIMIT 1
  #   # => 'David'
  #
  #   Person.where(id: 1).pick(:name, :email_address)
  #   # SELECT people.name, people.email_address FROM people WHERE id = 1 LIMIT 1
  #   # => [ 'David', 'david@loudthinking.com' ]
  def pick(*column_names); end

  # Use #pluck as a shortcut to select one or more attributes without
  # loading a bunch of records just to grab the attributes you want.
  #
  #   Person.pluck(:name)
  #
  # instead of
  #
  #   Person.all.map(&:name)
  #
  # Pluck returns an Array of attribute values type-casted to match
  # the plucked column names, if they can be deduced. Plucking an SQL fragment
  # returns String values by default.
  #
  #   Person.pluck(:name)
  #   # SELECT people.name FROM people
  #   # => ['David', 'Jeremy', 'Jose']
  #
  #   Person.pluck(:id, :name)
  #   # SELECT people.id, people.name FROM people
  #   # => [[1, 'David'], [2, 'Jeremy'], [3, 'Jose']]
  #
  #   Person.distinct.pluck(:role)
  #   # SELECT DISTINCT role FROM people
  #   # => ['admin', 'member', 'guest']
  #
  #   Person.where(age: 21).limit(5).pluck(:id)
  #   # SELECT people.id FROM people WHERE people.age = 21 LIMIT 5
  #   # => [2, 3]
  #
  #   Person.pluck(Arel.sql('DATEDIFF(updated_at, created_at)'))
  #   # SELECT DATEDIFF(updated_at, created_at) FROM people
  #   # => ['0', '27761', '173']
  #
  # See also #ids.
  def pluck(*column_names); end

  # Calculates the sum of values on a given column. The value is returned
  # with the same data type of the column, +0+ if there's no row. See
  # #calculate for examples with options.
  #
  #   Person.sum(:age) # => 4562
  def sum(column_name = T.unsafe(nil)); end

  private

  def aggregate_column(column_name); end

  # @return [Boolean]
  def all_attributes?(column_names); end

  def build_count_subquery(relation, column_name, distinct); end

  # Converts the given field to the value that the database adapter returns as
  # a usable column name:
  #
  #   column_alias_for("users.id")                 # => "users_id"
  #   column_alias_for("sum(id)")                  # => "sum_id"
  #   column_alias_for("count(distinct users.id)") # => "count_distinct_users_id"
  #   column_alias_for("count(*)")                 # => "count_all"
  def column_alias_for(field); end

  # @return [Boolean]
  def distinct_select?(column_name); end

  def execute_grouped_calculation(operation, column_name, distinct); end
  def execute_simple_calculation(operation, column_name, distinct); end

  # @return [Boolean]
  def has_include?(column_name); end

  def lookup_cast_type_from_join_dependencies(name, join_dependencies = T.unsafe(nil)); end
  def operation_over_aggregate_column(column, operation, distinct); end
  def perform_calculation(operation, column_name); end
  def select_for_count; end
  def type_cast_calculated_value(value, operation); end
  def type_cast_pluck_values(result, columns); end
  def type_for(field, &block); end
end

# = Active Record \Callbacks
#
# \Callbacks are hooks into the life cycle of an Active Record object that allow you to trigger logic
# before or after a change in the object state. This can be used to make sure that associated and
# dependent objects are deleted when {ActiveRecord::Base#destroy}[rdoc-ref:Persistence#destroy] is called (by overwriting +before_destroy+) or
# to massage attributes before they're validated (by overwriting +before_validation+).
# As an example of the callbacks initiated, consider the {ActiveRecord::Base#save}[rdoc-ref:Persistence#save] call for a new record:
#
# * (-) <tt>save</tt>
# * (-) <tt>valid</tt>
# * (1) <tt>before_validation</tt>
# * (-) <tt>validate</tt>
# * (2) <tt>after_validation</tt>
# * (3) <tt>before_save</tt>
# * (4) <tt>before_create</tt>
# * (-) <tt>create</tt>
# * (5) <tt>after_create</tt>
# * (6) <tt>after_save</tt>
# * (7) <tt>after_commit</tt>
#
# Also, an <tt>after_rollback</tt> callback can be configured to be triggered whenever a rollback is issued.
# Check out ActiveRecord::Transactions for more details about <tt>after_commit</tt> and
# <tt>after_rollback</tt>.
#
# Additionally, an <tt>after_touch</tt> callback is triggered whenever an
# object is touched.
#
# Lastly an <tt>after_find</tt> and <tt>after_initialize</tt> callback is triggered for each object that
# is found and instantiated by a finder, with <tt>after_initialize</tt> being triggered after new objects
# are instantiated as well.
#
# There are nineteen callbacks in total, which give a lot of control over how to react and prepare for each state in the
# Active Record life cycle. The sequence for calling {ActiveRecord::Base#save}[rdoc-ref:Persistence#save] for an existing record is similar,
# except that each <tt>_create</tt> callback is replaced by the corresponding <tt>_update</tt> callback.
#
# Examples:
#   class CreditCard < ActiveRecord::Base
#     # Strip everything but digits, so the user can specify "555 234 34" or
#     # "5552-3434" and both will mean "55523434"
#     before_validation(on: :create) do
#       self.number = number.gsub(/[^0-9]/, "") if attribute_present?("number")
#     end
#   end
#
#   class Subscription < ActiveRecord::Base
#     before_create :record_signup
#
#     private
#       def record_signup
#         self.signed_up_on = Date.today
#       end
#   end
#
#   class Firm < ActiveRecord::Base
#     # Disables access to the system, for associated clients and people when the firm is destroyed
#     before_destroy { |record| Person.where(firm_id: record.id).update_all(access: 'disabled')   }
#     before_destroy { |record| Client.where(client_of: record.id).update_all(access: 'disabled') }
#   end
#
# == Inheritable callback queues
#
# Besides the overwritable callback methods, it's also possible to register callbacks through the
# use of the callback macros. Their main advantage is that the macros add behavior into a callback
# queue that is kept intact through an inheritance hierarchy.
#
#   class Topic < ActiveRecord::Base
#     before_destroy :destroy_author
#   end
#
#   class Reply < Topic
#     before_destroy :destroy_readers
#   end
#
# When <tt>Topic#destroy</tt> is run only +destroy_author+ is called. When <tt>Reply#destroy</tt> is
# run, both +destroy_author+ and +destroy_readers+ are called.
#
# *IMPORTANT:* In order for inheritance to work for the callback queues, you must specify the
# callbacks before specifying the associations. Otherwise, you might trigger the loading of a
# child before the parent has registered the callbacks and they won't be inherited.
#
# == Types of callbacks
#
# There are three types of callbacks accepted by the callback macros: method references (symbol), callback objects,
# inline methods (using a proc). Method references and callback objects are the recommended approaches,
# inline methods using a proc are sometimes appropriate (such as for creating mix-ins).
#
# The method reference callbacks work by specifying a protected or private method available in the object, like this:
#
#   class Topic < ActiveRecord::Base
#     before_destroy :delete_parents
#
#     private
#       def delete_parents
#         self.class.delete_by(parent_id: id)
#       end
#   end
#
# The callback objects have methods named after the callback called with the record as the only parameter, such as:
#
#   class BankAccount < ActiveRecord::Base
#     before_save      EncryptionWrapper.new
#     after_save       EncryptionWrapper.new
#     after_initialize EncryptionWrapper.new
#   end
#
#   class EncryptionWrapper
#     def before_save(record)
#       record.credit_card_number = encrypt(record.credit_card_number)
#     end
#
#     def after_save(record)
#       record.credit_card_number = decrypt(record.credit_card_number)
#     end
#
#     alias_method :after_initialize, :after_save
#
#     private
#       def encrypt(value)
#         # Secrecy is committed
#       end
#
#       def decrypt(value)
#         # Secrecy is unveiled
#       end
#   end
#
# So you specify the object you want to be messaged on a given callback. When that callback is triggered, the object has
# a method by the name of the callback messaged. You can make these callbacks more flexible by passing in other
# initialization data such as the name of the attribute to work with:
#
#   class BankAccount < ActiveRecord::Base
#     before_save      EncryptionWrapper.new("credit_card_number")
#     after_save       EncryptionWrapper.new("credit_card_number")
#     after_initialize EncryptionWrapper.new("credit_card_number")
#   end
#
#   class EncryptionWrapper
#     def initialize(attribute)
#       @attribute = attribute
#     end
#
#     def before_save(record)
#       record.send("#{@attribute}=", encrypt(record.send("#{@attribute}")))
#     end
#
#     def after_save(record)
#       record.send("#{@attribute}=", decrypt(record.send("#{@attribute}")))
#     end
#
#     alias_method :after_initialize, :after_save
#
#     private
#       def encrypt(value)
#         # Secrecy is committed
#       end
#
#       def decrypt(value)
#         # Secrecy is unveiled
#       end
#   end
#
# == <tt>before_validation*</tt> returning statements
#
# If the +before_validation+ callback throws +:abort+, the process will be
# aborted and {ActiveRecord::Base#save}[rdoc-ref:Persistence#save] will return +false+.
# If {ActiveRecord::Base#save!}[rdoc-ref:Persistence#save!] is called it will raise an ActiveRecord::RecordInvalid exception.
# Nothing will be appended to the errors object.
#
# == Canceling callbacks
#
# If a <tt>before_*</tt> callback throws +:abort+, all the later callbacks and
# the associated action are cancelled.
# Callbacks are generally run in the order they are defined, with the exception of callbacks defined as
# methods on the model, which are called last.
#
# == Ordering callbacks
#
# Sometimes application code requires that callbacks execute in a specific order. For example, a +before_destroy+
# callback (+log_children+ in this case) should be executed before records in the +children+ association are destroyed by the
# <tt>dependent: :destroy</tt> option.
#
# Let's look at the code below:
#
#   class Topic < ActiveRecord::Base
#     has_many :children, dependent: :destroy
#
#     before_destroy :log_children
#
#     private
#       def log_children
#         # Child processing
#       end
#   end
#
# In this case, the problem is that when the +before_destroy+ callback is executed, records in the +children+ association no
# longer exist because the {ActiveRecord::Base#destroy}[rdoc-ref:Persistence#destroy] callback was executed first.
# You can use the +prepend+ option on the +before_destroy+ callback to avoid this.
#
#   class Topic < ActiveRecord::Base
#     has_many :children, dependent: :destroy
#
#     before_destroy :log_children, prepend: true
#
#     private
#       def log_children
#         # Child processing
#       end
#   end
#
# This way, the +before_destroy+ is executed before the <tt>dependent: :destroy</tt> is called, and the data is still available.
#
# Also, there are cases when you want several callbacks of the same type to
# be executed in order.
#
# For example:
#
#   class Topic < ActiveRecord::Base
#     has_many :children
#
#     after_save :log_children
#     after_save :do_something_else
#
#     private
#
#     def log_children
#       # Child processing
#     end
#
#     def do_something_else
#       # Something else
#     end
#   end
#
# In this case the +log_children+ is executed before +do_something_else+.
# The same applies to all non-transactional callbacks.
#
# As seen below, in case there are multiple transactional callbacks the order
# is reversed.
#
# For example:
#
#   class Topic < ActiveRecord::Base
#     has_many :children
#
#     after_commit :log_children
#     after_commit :do_something_else
#
#     private
#
#     def log_children
#       # Child processing
#     end
#
#     def do_something_else
#       # Something else
#     end
#   end
#
# In this case the +do_something_else+ is executed before +log_children+.
#
# == \Transactions
#
# The entire callback chain of a {#save}[rdoc-ref:Persistence#save], {#save!}[rdoc-ref:Persistence#save!],
# or {#destroy}[rdoc-ref:Persistence#destroy] call runs within a transaction. That includes <tt>after_*</tt> hooks.
# If everything goes fine a +COMMIT+ is executed once the chain has been completed.
#
# If a <tt>before_*</tt> callback cancels the action a +ROLLBACK+ is issued. You
# can also trigger a +ROLLBACK+ raising an exception in any of the callbacks,
# including <tt>after_*</tt> hooks. Note, however, that in that case the client
# needs to be aware of it because an ordinary {#save}[rdoc-ref:Persistence#save] will raise such exception
# instead of quietly returning +false+.
#
# == Debugging callbacks
#
# The callback chain is accessible via the <tt>_*_callbacks</tt> method on an object. Active Model \Callbacks support
# <tt>:before</tt>, <tt>:after</tt> and <tt>:around</tt> as values for the <tt>kind</tt> property. The <tt>kind</tt> property
# defines what part of the chain the callback runs in.
#
# To find all callbacks in the +before_save+ callback chain:
#
#   Topic._save_callbacks.select { |cb| cb.kind.eql?(:before) }
#
# Returns an array of callback objects that form the +before_save+ chain.
#
# To further check if the before_save chain contains a proc defined as <tt>rest_when_dead</tt> use the <tt>filter</tt> property of the callback object:
#
#   Topic._save_callbacks.select { |cb| cb.kind.eql?(:before) }.collect(&:filter).include?(:rest_when_dead)
#
# Returns true or false depending on whether the proc is contained in the +before_save+ callback chain on a Topic model.
module ActiveRecord::Callbacks
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods
  include ::ActiveSupport::Callbacks
  include ::ActiveModel::Validations::Callbacks

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::ActiveRecord::Callbacks::ClassMethods
  mixes_in_class_methods ::ActiveModel::Validations::Callbacks::ClassMethods
  mixes_in_class_methods ::ActiveSupport::Callbacks::ClassMethods
  mixes_in_class_methods ::ActiveSupport::DescendantsTracker

  def destroy; end
  def increment!(attribute, by = T.unsafe(nil), touch: T.unsafe(nil)); end
  def touch(*_arg0, **_arg1); end

  private

  def _create_record; end
  def _update_record; end
  def create_or_update(**_arg0); end

  module GeneratedClassMethods
    def __callbacks; end
    def __callbacks=(value); end
    def __callbacks?; end
  end

  module GeneratedInstanceMethods
    def __callbacks; end
    def __callbacks?; end
  end
end

ActiveRecord::Callbacks::CALLBACKS = T.let(T.unsafe(nil), Array)

module ActiveRecord::Callbacks::ClassMethods
  include ::ActiveModel::Callbacks
end

module ActiveRecord::Coders; end

class ActiveRecord::Coders::JSON
  class << self
    def dump(obj); end
    def load(json); end
  end
end

class ActiveRecord::Coders::YAMLColumn
  # @return [YAMLColumn] a new instance of YAMLColumn
  def initialize(attr_name, object_class = T.unsafe(nil)); end

  def assert_valid_value(obj, action:); end
  def dump(obj); end
  def load(yaml); end

  # Returns the value of attribute object_class.
  def object_class; end

  # Sets the attribute object_class
  #
  # @param value the value to set the attribute object_class to.
  def object_class=(_arg0); end

  private

  def check_arity_of_constructor; end
  def yaml_load(payload); end
end

class ActiveRecord::ConcurrentMigrationError < ::ActiveRecord::MigrationError
  # @return [ConcurrentMigrationError] a new instance of ConcurrentMigrationError
  def initialize(message = T.unsafe(nil)); end
end

ActiveRecord::ConcurrentMigrationError::DEFAULT_MESSAGE = T.let(T.unsafe(nil), String)
ActiveRecord::ConcurrentMigrationError::RELEASE_LOCK_FAILED_MESSAGE = T.let(T.unsafe(nil), String)

# Raised when association is being configured improperly or user tries to use
# offset and limit together with
# {ActiveRecord::Base.has_many}[rdoc-ref:Associations::ClassMethods#has_many] or
# {ActiveRecord::Base.has_and_belongs_to_many}[rdoc-ref:Associations::ClassMethods#has_and_belongs_to_many]
# associations.
class ActiveRecord::ConfigurationError < ::ActiveRecord::ActiveRecordError; end

module ActiveRecord::ConnectionAdapters
  extend ::ActiveSupport::Autoload
end

# Active Record supports multiple database systems. AbstractAdapter and
# related classes form the abstraction layer which makes this possible.
# An AbstractAdapter represents a connection to a database, and provides an
# abstract interface for database-specific functionality such as establishing
# a connection, escaping values, building the right SQL fragments for +:offset+
# and +:limit+ options, etc.
#
# All the concrete database adapters follow the interface laid down in this class.
# {ActiveRecord::Base.connection}[rdoc-ref:ConnectionHandling#connection] returns an AbstractAdapter object, which
# you can use.
#
# Most of the methods in the adapter are useful during migrations. Most
# notably, the instance methods provided by SchemaStatements are very useful.
class ActiveRecord::ConnectionAdapters::AbstractAdapter
  include ::ActiveSupport::Callbacks
  include ::ActiveRecord::Migration::JoinTable
  include ::ActiveRecord::ConnectionAdapters::SchemaStatements
  include ::ActiveRecord::ConnectionAdapters::DatabaseStatements
  include ::ActiveRecord::ConnectionAdapters::Quoting
  include ::ActiveRecord::ConnectionAdapters::DatabaseLimits
  include ::ActiveRecord::ConnectionAdapters::QueryCache
  include ::ActiveRecord::ConnectionAdapters::Savepoints
  extend ::ActiveSupport::Callbacks::ClassMethods
  extend ::ActiveSupport::DescendantsTracker

  # @return [AbstractAdapter] a new instance of AbstractAdapter
  def initialize(connection, logger = T.unsafe(nil), config = T.unsafe(nil)); end

  def __callbacks; end
  def __callbacks?; end
  def _checkin_callbacks; end
  def _checkout_callbacks; end
  def _run_checkin_callbacks(&block); end
  def _run_checkout_callbacks(&block); end

  # Checks whether the connection to the database is still active. This includes
  # checking whether the database is actually capable of responding, i.e. whether
  # the connection isn't stale.
  #
  # @return [Boolean]
  def active?; end

  # Returns the human-readable name of the adapter. Use mixed case - one
  # can always use downcase if needed.
  def adapter_name; end

  # @return [Boolean]
  def advisory_locks_enabled?; end

  # Called by ActiveRecord::InsertAll,
  # Passed an instance of ActiveRecord::InsertAll::Builder,
  # This method implements standard bulk inserts for all databases, but
  # should be overridden by adapters to implement common features with
  # non-standard syntax like handling duplicates or returning values.
  def build_insert_sql(insert); end

  def case_insensitive_comparison(attribute, value); end
  def case_sensitive_comparison(attribute, value); end
  def check_version; end

  # Clear any caching the database adapter may be doing.
  def clear_cache!; end

  # Check the connection back in to the connection pool
  def close; end

  def connection_klass; end
  def create(*_arg0); end
  def database_version; end

  # @return [Boolean]
  def default_index_type?(index); end

  def default_uniqueness_comparison(attribute, value); end
  def delete(*_arg0); end

  # This is meant to be implemented by the adapters that support extensions
  def disable_extension(name); end

  # Override to turn off referential integrity while executing <tt>&block</tt>.
  def disable_referential_integrity; end

  # Immediately forget this connection ever existed. Unlike disconnect!,
  # this will not communicate with the server.
  #
  # After calling this method, the behavior of all other methods becomes
  # undefined. This is called internally just before a forked process gets
  # rid of a connection that belonged to its parent.
  def discard!; end

  # Disconnects from the database if already connected. Otherwise, this
  # method does nothing.
  def disconnect!; end

  # This is meant to be implemented by the adapters that support extensions
  def enable_extension(name); end

  def exec_insert_all(*_arg0); end

  # this method must only be called while holding connection pool's mutex
  def expire; end

  # A list of extensions, to be filled in by adapters that support them.
  def extensions; end

  # This is meant to be implemented by the adapters that support advisory
  # locks
  #
  # Return true if we got the lock, otherwise false
  def get_advisory_lock(lock_id); end

  def get_database_version; end

  # Returns the value of attribute owner.
  def in_use?; end

  # A list of index algorithms, to be filled by adapters that support them.
  def index_algorithms; end

  def insert(*_arg0); end

  # this method must only be called while holding connection pool's mutex
  def lease; end

  # Returns the value of attribute lock.
  def lock; end

  # Returns the value of attribute logger.
  def logger; end

  def migration_context; end
  def migrations_paths; end

  # Returns the value of attribute owner.
  def owner; end

  # Returns the value of attribute pool.
  def pool; end

  # Sets the attribute pool
  #
  # @param value the value to set the attribute pool to.
  def pool=(_arg0); end

  # Should primary key values be selected from their corresponding
  # sequence before the insert statement? If true, next_sequence_value
  # is called before each insert to set the record's primary key.
  #
  # @return [Boolean]
  def prefetch_primary_key?(table_name = T.unsafe(nil)); end

  # @return [Boolean]
  def prepared_statements; end

  # @return [Boolean]
  def prepared_statements?; end

  def prepared_statements_disabled_cache; end

  # Determines whether writes are currently being prevented.
  #
  # Returns true if the connection is a replica.
  #
  # If the application is using legacy handling, returns
  # true if +connection_handler.prevent_writes+ is set.
  #
  # If the application is using the new connection handling
  # will return true based on +current_preventing_writes+.
  #
  # @return [Boolean]
  def preventing_writes?; end

  # Provides access to the underlying database driver for this adapter. For
  # example, this method returns a Mysql2::Client object in case of Mysql2Adapter,
  # and a PG::Connection object in case of PostgreSQLAdapter.
  #
  # This is useful for when you need to call a proprietary method such as
  # PostgreSQL's lo_* methods.
  def raw_connection; end

  # Disconnects from the database if already connected, and establishes a
  # new connection with the database. Implementors should call super if they
  # override the default implementation.
  def reconnect!; end

  # This is meant to be implemented by the adapters that support advisory
  # locks.
  #
  # Return true if we released the lock, otherwise false
  def release_advisory_lock(lock_id); end

  # @return [Boolean]
  def replica?; end

  # Returns true if its required to reload the connection between requests for development mode.
  #
  # @return [Boolean]
  def requires_reloading?; end

  # Reset the state of this connection, directing the DBMS to clear
  # transactions and other connection-related server-side state. Usually a
  # database-dependent operation.
  #
  # The default implementation does nothing; the implementation should be
  # overridden by concrete adapters.
  def reset!; end

  def rollback_db_transaction(*_arg0); end
  def rollback_to_savepoint(*_arg0); end
  def schema_cache; end
  def schema_cache=(cache); end
  def schema_migration; end

  # Seconds since this connection was returned to the pool
  def seconds_idle; end

  # this method must only be called while holding connection pool's mutex (and a desire for segfaults)
  def steal!; end

  # Does this adapter support application-enforced advisory locking?
  #
  # @return [Boolean]
  def supports_advisory_locks?; end

  # @return [Boolean]
  def supports_bulk_alter?; end

  # Does this adapter support creating check constraints?
  #
  # @return [Boolean]
  def supports_check_constraints?; end

  # Does this adapter support metadata comments on database objects (tables, columns, indexes)?
  #
  # @return [Boolean]
  def supports_comments?; end

  # Can comments for tables, columns, and indexes be specified in create/alter table statements?
  #
  # @return [Boolean]
  def supports_comments_in_create?; end

  # @return [Boolean]
  def supports_common_table_expressions?; end

  # Does this adapter support datetime with precision?
  #
  # @return [Boolean]
  def supports_datetime_with_precision?; end

  # Does this adapter support DDL rollbacks in transactions? That is, would
  # CREATE TABLE or ALTER TABLE get rolled back by a transaction?
  #
  # @return [Boolean]
  def supports_ddl_transactions?; end

  # Does this adapter support explain?
  #
  # @return [Boolean]
  def supports_explain?; end

  # Does this adapter support expression indices?
  #
  # @return [Boolean]
  def supports_expression_index?; end

  # Does this adapter support database extensions?
  #
  # @return [Boolean]
  def supports_extensions?; end

  # Does this adapter support creating foreign key constraints?
  #
  # @return [Boolean]
  def supports_foreign_keys?; end

  # Does this adapter support foreign/external tables?
  #
  # @return [Boolean]
  def supports_foreign_tables?; end

  # Does this adapter support index sort order?
  #
  # @return [Boolean]
  def supports_index_sort_order?; end

  # Does this adapter support creating indexes in the same statement as
  # creating the table?
  #
  # @return [Boolean]
  def supports_indexes_in_create?; end

  # @return [Boolean]
  def supports_insert_conflict_target?; end

  # @return [Boolean]
  def supports_insert_on_duplicate_skip?; end

  # @return [Boolean]
  def supports_insert_on_duplicate_update?; end

  # @return [Boolean]
  def supports_insert_returning?; end

  # Does this adapter support json data type?
  #
  # @return [Boolean]
  def supports_json?; end

  # @return [Boolean]
  def supports_lazy_transactions?; end

  # Does this adapter support materialized views?
  #
  # @return [Boolean]
  def supports_materialized_views?; end

  # Does this adapter support optimizer hints?
  #
  # @return [Boolean]
  def supports_optimizer_hints?; end

  # Does this adapter support partial indices?
  #
  # @return [Boolean]
  def supports_partial_index?; end

  # @return [Boolean]
  def supports_partitioned_indexes?; end

  # Does this adapter support savepoints?
  #
  # @return [Boolean]
  def supports_savepoints?; end

  # Does this adapter support setting the isolation level for a transaction?
  #
  # @return [Boolean]
  def supports_transaction_isolation?; end

  # Does this adapter support creating invalid constraints?
  #
  # @return [Boolean]
  def supports_validate_constraints?; end

  # Does this adapter support views?
  #
  # @return [Boolean]
  def supports_views?; end

  # Does this adapter support virtual columns?
  #
  # @return [Boolean]
  def supports_virtual_columns?; end

  # Removes the connection from the pool and disconnect it.
  def throw_away!; end

  def truncate(*_arg0); end
  def truncate_tables(*_arg0); end
  def unprepared_statement; end
  def update(*_arg0); end

  # @return [Boolean]
  def use_metadata_table?; end

  # @return [Boolean]
  def valid_type?(type); end

  # Checks whether the connection to the database is still active (i.e. not stale).
  # This is done under the hood by calling #active?. If the connection
  # is no longer active, then this method will reconnect to the database.
  def verify!; end

  # Returns the value of attribute visitor.
  def visitor; end

  private

  def arel_visitor; end

  # Builds the result object.
  #
  # This is an internal hook to make possible connection adapters to build
  # custom result objects with connection-specific data.
  def build_result(columns:, rows:, column_types: T.unsafe(nil)); end

  def build_statement_pool; end

  # @return [Boolean]
  def can_perform_case_insensitive_comparison_for?(column); end

  def collector; end
  def column_for(table_name, column_name); end
  def column_for_attribute(attribute); end
  def extract_limit(sql_type); end
  def extract_precision(sql_type); end
  def extract_scale(sql_type); end
  def initialize_type_map(m = T.unsafe(nil)); end
  def log(sql, name = T.unsafe(nil), binds = T.unsafe(nil), type_casted_binds = T.unsafe(nil), statement_name = T.unsafe(nil)); end
  def register_class_with_limit(mapping, key, klass); end
  def register_class_with_precision(mapping, key, klass); end
  def reload_type_map; end
  def translate_exception(exception, message:, sql:, binds:); end
  def translate_exception_class(e, sql, binds); end
  def type_map; end

  # @return [Boolean]
  def without_prepared_statement?(binds); end

  class << self
    def __callbacks; end
    def __callbacks=(value); end
    def __callbacks?; end
    def _checkin_callbacks; end
    def _checkin_callbacks=(value); end
    def _checkout_callbacks; end
    def _checkout_callbacks=(value); end
    def build_read_query_regexp(*parts); end

    # Does the database for this adapter exist?
    #
    # @raise [NotImplementedError]
    # @return [Boolean]
    def database_exists?(config); end

    def quoted_column_names; end
    def quoted_table_names; end
    def type_cast_config_to_boolean(config); end
    def type_cast_config_to_integer(config); end
  end
end

ActiveRecord::ConnectionAdapters::AbstractAdapter::ADAPTER_NAME = T.let(T.unsafe(nil), String)
ActiveRecord::ConnectionAdapters::AbstractAdapter::COMMENT_REGEX = T.let(T.unsafe(nil), Regexp)
ActiveRecord::ConnectionAdapters::AbstractAdapter::DEFAULT_READ_QUERY = T.let(T.unsafe(nil), Array)
ActiveRecord::ConnectionAdapters::AbstractAdapter::SIMPLE_INT = T.let(T.unsafe(nil), Regexp)

class ActiveRecord::ConnectionAdapters::AbstractAdapter::Version
  include ::Comparable

  # @return [Version] a new instance of Version
  def initialize(version_string, full_version_string = T.unsafe(nil)); end

  def <=>(version_string); end

  # Returns the value of attribute full_version_string.
  def full_version_string; end

  def to_s; end
end

module ActiveRecord::ConnectionAdapters::AbstractPool
  def get_schema_cache(connection); end
  def set_schema_cache(cache); end
end

class ActiveRecord::ConnectionAdapters::AddColumnDefinition < ::Struct
  # Returns the value of attribute column
  #
  # @return [Object] the current value of column
  def column; end

  # Sets the attribute column
  #
  # @param value [Object] the value to set the attribute column to.
  # @return [Object] the newly set value
  def column=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def members; end
    def new(*_arg0); end
  end
end

class ActiveRecord::ConnectionAdapters::AlterTable
  # @return [AlterTable] a new instance of AlterTable
  def initialize(td); end

  def add_check_constraint(expression, options); end
  def add_column(name, type, **options); end
  def add_foreign_key(to_table, options); end

  # Returns the value of attribute adds.
  def adds; end

  # Returns the value of attribute check_constraint_adds.
  def check_constraint_adds; end

  # Returns the value of attribute check_constraint_drops.
  def check_constraint_drops; end

  def drop_check_constraint(constraint_name); end
  def drop_foreign_key(name); end

  # Returns the value of attribute foreign_key_adds.
  def foreign_key_adds; end

  # Returns the value of attribute foreign_key_drops.
  def foreign_key_drops; end

  def name; end
end

class ActiveRecord::ConnectionAdapters::ChangeColumnDefinition < ::Struct
  # Returns the value of attribute column
  #
  # @return [Object] the current value of column
  def column; end

  # Sets the attribute column
  #
  # @param value [Object] the value to set the attribute column to.
  # @return [Object] the newly set value
  def column=(_); end

  # Returns the value of attribute name
  #
  # @return [Object] the current value of name
  def name; end

  # Sets the attribute name
  #
  # @param value [Object] the value to set the attribute name to.
  # @return [Object] the newly set value
  def name=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def members; end
    def new(*_arg0); end
  end
end

class ActiveRecord::ConnectionAdapters::CheckConstraintDefinition < ::Struct
  # @return [Boolean]
  def export_name_on_schema_dump?; end

  # Returns the value of attribute expression
  #
  # @return [Object] the current value of expression
  def expression; end

  # Sets the attribute expression
  #
  # @param value [Object] the value to set the attribute expression to.
  # @return [Object] the newly set value
  def expression=(_); end

  def name; end

  # Returns the value of attribute options
  #
  # @return [Object] the current value of options
  def options; end

  # Sets the attribute options
  #
  # @param value [Object] the value to set the attribute options to.
  # @return [Object] the newly set value
  def options=(_); end

  # Returns the value of attribute table_name
  #
  # @return [Object] the current value of table_name
  def table_name; end

  # Sets the attribute table_name
  #
  # @param value [Object] the value to set the attribute table_name to.
  # @return [Object] the newly set value
  def table_name=(_); end

  # @return [Boolean]
  def validate?; end

  # @return [Boolean]
  def validated?; end

  class << self
    def [](*_arg0); end
    def inspect; end
    def members; end
    def new(*_arg0); end
  end
end

# An abstract definition of a column in a table.
class ActiveRecord::ConnectionAdapters::Column
  include ::ActiveRecord::ConnectionAdapters::Deduplicable
  extend ::ActiveRecord::ConnectionAdapters::Deduplicable::ClassMethods

  # Instantiates a new column in the table.
  #
  # +name+ is the column's name, such as <tt>supplier_id</tt> in <tt>supplier_id bigint</tt>.
  # +default+ is the type-casted default value, such as +new+ in <tt>sales_stage varchar(20) default 'new'</tt>.
  # +sql_type_metadata+ is various information about the type of the column
  # +null+ determines if this column allows +NULL+ values.
  #
  # @return [Column] a new instance of Column
  def initialize(name, default, sql_type_metadata = T.unsafe(nil), null = T.unsafe(nil), default_function = T.unsafe(nil), collation: T.unsafe(nil), comment: T.unsafe(nil), **_arg7); end

  def ==(other); end

  # @return [Boolean]
  def bigint?; end

  # Returns the value of attribute collation.
  def collation; end

  # Returns the value of attribute comment.
  def comment; end

  # Returns the value of attribute default.
  def default; end

  # Returns the value of attribute default_function.
  def default_function; end

  def encode_with(coder); end
  def eql?(other); end

  # @return [Boolean]
  def has_default?; end

  def hash; end

  # Returns the human name of the column name.
  #
  # ===== Examples
  #  Column.new('sales_stage', ...).human_name # => 'Sales stage'
  def human_name; end

  def init_with(coder); end
  def limit(*_arg0, &_arg1); end

  # Returns the value of attribute name.
  def name; end

  # Returns the value of attribute null.
  def null; end

  def precision(*_arg0, &_arg1); end
  def scale(*_arg0, &_arg1); end
  def sql_type(*_arg0, &_arg1); end

  # Returns the value of attribute sql_type_metadata.
  def sql_type_metadata; end

  def type(*_arg0, &_arg1); end

  private

  def deduplicated; end
end

# Abstract representation of a column definition. Instances of this type
# are typically created by methods in TableDefinition, and added to the
# +columns+ attribute of said TableDefinition object, in order to be used
# for generating a number of table creation or table changing SQL statements.
class ActiveRecord::ConnectionAdapters::ColumnDefinition < ::Struct
  def aliased_types(name, fallback); end
  def collation; end
  def collation=(value); end
  def comment; end
  def comment=(value); end
  def default; end
  def default=(value); end
  def limit; end
  def limit=(value); end

  # Returns the value of attribute name
  #
  # @return [Object] the current value of name
  def name; end

  # Sets the attribute name
  #
  # @param value [Object] the value to set the attribute name to.
  # @return [Object] the newly set value
  def name=(_); end

  def null; end
  def null=(value); end

  # Returns the value of attribute options
  #
  # @return [Object] the current value of options
  def options; end

  # Sets the attribute options
  #
  # @param value [Object] the value to set the attribute options to.
  # @return [Object] the newly set value
  def options=(_); end

  def precision; end
  def precision=(value); end

  # @return [Boolean]
  def primary_key?; end

  def scale; end
  def scale=(value); end

  # Returns the value of attribute sql_type
  #
  # @return [Object] the current value of sql_type
  def sql_type; end

  # Sets the attribute sql_type
  #
  # @param value [Object] the value to set the attribute sql_type to.
  # @return [Object] the newly set value
  def sql_type=(_); end

  # Returns the value of attribute type
  #
  # @return [Object] the current value of type
  def type; end

  # Sets the attribute type
  #
  # @param value [Object] the value to set the attribute type to.
  # @return [Object] the newly set value
  def type=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def members; end
    def new(*_arg0); end
  end
end

module ActiveRecord::ConnectionAdapters::ColumnMethods
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::ActiveRecord::ConnectionAdapters::ColumnMethods::ClassMethods

  # Appends a primary key definition to the table definition.
  # Can be called multiple times, but this is probably not a good idea.
  def primary_key(name, type = T.unsafe(nil), **options); end
end

module ActiveRecord::ConnectionAdapters::ColumnMethods::ClassMethods
  private

  def define_column_methods(*column_types); end
end

# ConnectionHandler is a collection of ConnectionPool objects. It is used
# for keeping separate connection pools that connect to different databases.
#
# For example, suppose that you have 5 models, with the following hierarchy:
#
#   class Author < ActiveRecord::Base
#   end
#
#   class BankAccount < ActiveRecord::Base
#   end
#
#   class Book < ActiveRecord::Base
#     establish_connection :library_db
#   end
#
#   class ScaryBook < Book
#   end
#
#   class GoodBook < Book
#   end
#
# And a database.yml that looked like this:
#
#   development:
#     database: my_application
#     host: localhost
#
#   library_db:
#     database: library
#     host: some.library.org
#
# Your primary database in the development environment is "my_application"
# but the Book model connects to a separate database called "library_db"
# (this can even be a database on a different machine).
#
# Book, ScaryBook and GoodBook will all use the same connection pool to
# "library_db" while Author, BankAccount, and any other models you create
# will use the default connection pool to "my_application".
#
# The various connection pools are managed by a single instance of
# ConnectionHandler accessible via ActiveRecord::Base.connection_handler.
# All Active Record models use this handler to determine the connection pool that they
# should use.
#
# The ConnectionHandler class is not coupled with the Active models, as it has no knowledge
# about the model. The model needs to pass a connection specification name to the handler,
# in order to look up the correct connection pool.
class ActiveRecord::ConnectionAdapters::ConnectionHandler
  # @return [ConnectionHandler] a new instance of ConnectionHandler
  def initialize; end

  # Returns true if there are any active connections among the connection
  # pools that the ConnectionHandler is managing.
  #
  # @return [Boolean]
  def active_connections?(role = T.unsafe(nil)); end

  def all_connection_pools; end

  # Returns any connections in use by the current thread back to the pool,
  # and also returns connections to the pool cached by threads that are no
  # longer alive.
  def clear_active_connections!(role = T.unsafe(nil)); end

  def clear_all_connections!(role = T.unsafe(nil)); end

  # Clears the cache which maps classes.
  #
  # See ConnectionPool#clear_reloadable_connections! for details.
  def clear_reloadable_connections!(role = T.unsafe(nil)); end

  # Returns true if a connection that's accessible to this class has
  # already been opened.
  #
  # @return [Boolean]
  def connected?(spec_name, role: T.unsafe(nil), shard: T.unsafe(nil)); end

  def connection_pool_list(role = T.unsafe(nil)); end
  def connection_pool_names; end
  def connection_pools(role = T.unsafe(nil)); end
  def establish_connection(config, owner_name: T.unsafe(nil), role: T.unsafe(nil), shard: T.unsafe(nil)); end

  # Disconnects all currently idle connections.
  #
  # See ConnectionPool#flush! for details.
  def flush_idle_connections!(role = T.unsafe(nil)); end

  def prevent_writes; end
  def prevent_writes=(prevent_writes); end

  # Remove the connection for this class. This will close the active
  # connection and the defined connection (if they exist). The result
  # can be used as an argument for #establish_connection, for easily
  # re-establishing the connection.
  def remove_connection(*args, &block); end

  def remove_connection_pool(owner, role: T.unsafe(nil), shard: T.unsafe(nil)); end

  # Locate the connection of the nearest super class. This can be an
  # active or defined connection: if it is the latter, it will be
  # opened and set as the active connection for the class it was defined
  # for (not necessarily the current class).
  def retrieve_connection(spec_name, role: T.unsafe(nil), shard: T.unsafe(nil)); end

  # Retrieving the connection pool happens a lot, so we cache it in @owner_to_pool_manager.
  # This makes retrieving the connection pool O(1) once the process is warm.
  # When a connection is established or removed, we invalidate the cache.
  def retrieve_connection_pool(owner, role: T.unsafe(nil), shard: T.unsafe(nil)); end

  # Prevent writing to the database regardless of role.
  #
  # In some cases you may want to prevent writes to the database
  # even if you are on a database that can write. `while_preventing_writes`
  # will prevent writes to the database for the duration of the block.
  #
  # This method does not provide the same protection as a readonly
  # user and is meant to be a safeguard against accidental writes.
  #
  # See `READ_QUERY` for the queries that are blocked by this
  # method.
  def while_preventing_writes(enabled = T.unsafe(nil)); end

  private

  # Returns the pool manager for an owner.
  #
  # Using `"primary"` to look up the pool manager for `ActiveRecord::Base` is
  # deprecated in favor of looking it up by `"ActiveRecord::Base"`.
  #
  # During the deprecation period, if `"primary"` is passed, the pool manager
  # for `ActiveRecord::Base` will still be returned.
  def get_pool_manager(owner); end

  # Returns the value of attribute owner_to_pool_manager.
  def owner_to_pool_manager; end

  # Returns an instance of PoolConfig for a given adapter.
  # Accepts a hash one layer deep that contains all connection information.
  #
  # == Example
  #
  #   config = { "production" => { "host" => "localhost", "database" => "foo", "adapter" => "sqlite3" } }
  #   pool_config = Base.configurations.resolve_pool_config(:production)
  #   pool_config.db_config.configuration_hash
  #   # => { host: "localhost", database: "foo", adapter: "sqlite3" }
  #
  # @raise [AdapterNotSpecified]
  def resolve_pool_config(config, owner_name); end
end

ActiveRecord::ConnectionAdapters::ConnectionHandler::FINALIZER = T.let(T.unsafe(nil), Proc)

# Connection pool base class for managing Active Record database
# connections.
#
# == Introduction
#
# A connection pool synchronizes thread access to a limited number of
# database connections. The basic idea is that each thread checks out a
# database connection from the pool, uses that connection, and checks the
# connection back in. ConnectionPool is completely thread-safe, and will
# ensure that a connection cannot be used by two threads at the same time,
# as long as ConnectionPool's contract is correctly followed. It will also
# handle cases in which there are more threads than connections: if all
# connections have been checked out, and a thread tries to checkout a
# connection anyway, then ConnectionPool will wait until some other thread
# has checked in a connection.
#
# == Obtaining (checking out) a connection
#
# Connections can be obtained and used from a connection pool in several
# ways:
#
# 1. Simply use {ActiveRecord::Base.connection}[rdoc-ref:ConnectionHandling.connection]
#    as with Active Record 2.1 and
#    earlier (pre-connection-pooling). Eventually, when you're done with
#    the connection(s) and wish it to be returned to the pool, you call
#    {ActiveRecord::Base.clear_active_connections!}[rdoc-ref:ConnectionAdapters::ConnectionHandler#clear_active_connections!].
#    This will be the default behavior for Active Record when used in conjunction with
#    Action Pack's request handling cycle.
# 2. Manually check out a connection from the pool with
#    {ActiveRecord::Base.connection_pool.checkout}[rdoc-ref:#checkout]. You are responsible for
#    returning this connection to the pool when finished by calling
#    {ActiveRecord::Base.connection_pool.checkin(connection)}[rdoc-ref:#checkin].
# 3. Use {ActiveRecord::Base.connection_pool.with_connection(&block)}[rdoc-ref:#with_connection], which
#    obtains a connection, yields it as the sole argument to the block,
#    and returns it to the pool after the block completes.
#
# Connections in the pool are actually AbstractAdapter objects (or objects
# compatible with AbstractAdapter's interface).
#
# == Options
#
# There are several connection-pooling-related options that you can add to
# your database connection configuration:
#
# * +pool+: maximum number of connections the pool may manage (default 5).
# * +idle_timeout+: number of seconds that a connection will be kept
#   unused in the pool before it is automatically disconnected (default
#   300 seconds). Set this to zero to keep connections forever.
# * +checkout_timeout+: number of seconds to wait for a connection to
#   become available before giving up and raising a timeout error (default
#   5 seconds).
#
# --
# Synchronization policy:
# * all public methods can be called outside +synchronize+
# * access to these instance variables needs to be in +synchronize+:
#   * @connections
#   * @now_connecting
# * private methods that require being called in a +synchronize+ blocks
#   are now explicitly documented
class ActiveRecord::ConnectionAdapters::ConnectionPool
  include ::MonitorMixin
  include ::ActiveRecord::ConnectionAdapters::QueryCache::ConnectionPoolConfiguration
  include ::ActiveRecord::ConnectionAdapters::AbstractPool

  # Creates a new ConnectionPool object. +pool_config+ is a PoolConfig
  # object which describes database connection information (e.g. adapter,
  # host name, username, password, etc), as well as the maximum size for
  # this ConnectionPool.
  #
  # The default ConnectionPool maximum size is 5.
  #
  # @return [ConnectionPool] a new instance of ConnectionPool
  def initialize(pool_config); end

  # Returns true if there is an open connection being used for the current thread.
  #
  # This method only works for connections that have been obtained through
  # #connection or #with_connection methods. Connections obtained through
  # #checkout will not be detected by #active_connection?
  #
  # @return [Boolean]
  def active_connection?; end

  # Returns the value of attribute automatic_reconnect.
  def automatic_reconnect; end

  # Sets the attribute automatic_reconnect
  #
  # @param value the value to set the attribute automatic_reconnect to.
  def automatic_reconnect=(_arg0); end

  # Check-in a database connection back into the pool, indicating that you
  # no longer need this connection.
  #
  # +conn+: an AbstractAdapter object, which was obtained by earlier by
  # calling #checkout on this pool.
  def checkin(conn); end

  # Check-out a database connection from the pool, indicating that you want
  # to use it. You should call #checkin when you no longer need this.
  #
  # This is done by either returning and leasing existing connection, or by
  # creating a new connection and leasing it.
  #
  # If all connections are leased and the pool is at capacity (meaning the
  # number of currently leased connections is greater than or equal to the
  # size limit set), an ActiveRecord::ConnectionTimeoutError exception will be raised.
  #
  # Returns: an AbstractAdapter object.
  #
  # Raises:
  # - ActiveRecord::ConnectionTimeoutError no connection can be obtained from the pool.
  def checkout(checkout_timeout = T.unsafe(nil)); end

  # Returns the value of attribute checkout_timeout.
  def checkout_timeout; end

  # Sets the attribute checkout_timeout
  #
  # @param value the value to set the attribute checkout_timeout to.
  def checkout_timeout=(_arg0); end

  # Clears the cache which maps classes and re-connects connections that
  # require reloading.
  #
  # Raises:
  # - ActiveRecord::ExclusiveConnectionTimeoutError if unable to gain ownership of all
  #   connections in the pool within a timeout interval (default duration is
  #   <tt>spec.db_config.checkout_timeout * 2</tt> seconds).
  def clear_reloadable_connections(raise_on_acquisition_timeout = T.unsafe(nil)); end

  # Clears the cache which maps classes and re-connects connections that
  # require reloading.
  #
  # The pool first tries to gain ownership of all connections. If unable to
  # do so within a timeout interval (default duration is
  # <tt>spec.db_config.checkout_timeout * 2</tt> seconds), then the pool forcefully
  # clears the cache and reloads connections without any regard for other
  # connection owning threads.
  def clear_reloadable_connections!; end

  # Returns true if a connection has already been opened.
  #
  # @return [Boolean]
  def connected?; end

  # Retrieve the connection associated with the current thread, or call
  # #checkout to obtain one if necessary.
  #
  # #connection can be called any number of times; the connection is
  # held in a cache keyed by a thread.
  def connection; end

  # Returns the value of attribute connection_klass.
  def connection_klass; end

  # Returns an array containing the connections currently in the pool.
  # Access to the array does not require synchronization on the pool because
  # the array is newly created and not retained by the pool.
  #
  # However; this method bypasses the ConnectionPool's thread-safe connection
  # access pattern. A returned connection may be owned by another thread,
  # unowned, or by happen-stance owned by the calling thread.
  #
  # Calling methods on a connection without ownership is subject to the
  # thread-safety guarantees of the underlying method. Many of the methods
  # on connection adapter classes are inherently multi-thread unsafe.
  def connections; end

  # Returns the value of attribute db_config.
  def db_config; end

  # Discards all connections in the pool (even if they're currently
  # leased!), along with the pool itself. Any further interaction with the
  # pool (except #spec and #schema_cache) is undefined.
  #
  # See AbstractAdapter#discard!
  def discard!; end

  # @return [Boolean]
  def discarded?; end

  # Disconnects all connections in the pool, and clears the pool.
  #
  # Raises:
  # - ActiveRecord::ExclusiveConnectionTimeoutError if unable to gain ownership of all
  #   connections in the pool within a timeout interval (default duration is
  #   <tt>spec.db_config.checkout_timeout * 2</tt> seconds).
  def disconnect(raise_on_acquisition_timeout = T.unsafe(nil)); end

  # Disconnects all connections in the pool, and clears the pool.
  #
  # The pool first tries to gain ownership of all connections. If unable to
  # do so within a timeout interval (default duration is
  # <tt>spec.db_config.checkout_timeout * 2</tt> seconds), then the pool is forcefully
  # disconnected without any regard for other connection owning threads.
  def disconnect!; end

  # Disconnect all connections that have been idle for at least
  # +minimum_idle+ seconds. Connections currently checked out, or that were
  # checked in less than +minimum_idle+ seconds ago, are unaffected.
  def flush(minimum_idle = T.unsafe(nil)); end

  # Disconnect all currently idle connections. Connections currently checked
  # out are unaffected.
  def flush!; end

  def lock_thread=(lock_thread); end
  def num_waiting_in_queue; end

  # Returns the value of attribute pool_config.
  def pool_config; end

  # Recover lost connections for the pool. A lost connection can occur if
  # a programmer forgets to checkin a connection at the end of a thread
  # or a thread dies unexpectedly.
  def reap; end

  # Returns the value of attribute reaper.
  def reaper; end

  # Signal that the thread is finished with the current connection.
  # #release_connection releases the connection-thread association
  # and returns the connection to the pool.
  #
  # This method only works for connections that have been obtained through
  # #connection or #with_connection methods, connections obtained through
  # #checkout will not be automatically released.
  def release_connection(owner_thread = T.unsafe(nil)); end

  # Remove a connection from the connection pool. The connection will
  # remain open and active but will no longer be managed by this pool.
  def remove(conn); end

  def schema_cache(*_arg0, &_arg1); end
  def schema_cache=(arg); end

  # Returns the value of attribute size.
  def size; end

  # Return connection pool's usage statistic
  # Example:
  #
  #    ActiveRecord::Base.connection_pool.stat # => { size: 15, connections: 1, busy: 1, dead: 0, idle: 0, waiting: 0, checkout_timeout: 5 }
  def stat; end

  # If a connection obtained through #connection or #with_connection methods
  # already exists yield it to the block. If no such connection
  # exists checkout a connection, yield it to the block, and checkin the
  # connection when finished.
  def with_connection; end

  private

  # Acquire a connection by one of 1) immediately removing one
  # from the queue of available connections, 2) creating a new
  # connection if the pool is not at capacity, 3) waiting on the
  # queue for a connection to become available.
  #
  # Raises:
  # - ActiveRecord::ConnectionTimeoutError if a connection could not be acquired
  #
  # --
  # Implementation detail: the connection returned by +acquire_connection+
  # will already be "+connection.lease+ -ed" to the current thread.
  def acquire_connection(checkout_timeout); end

  def adopt_connection(conn); end
  def attempt_to_checkout_all_existing_connections(raise_on_acquisition_timeout = T.unsafe(nil)); end

  # --
  # this is unfortunately not concurrent
  def bulk_make_new_connections(num_new_conns_needed); end

  def checkout_and_verify(c); end

  # --
  # Must be called in a synchronize block.
  def checkout_for_exclusive_access(checkout_timeout); end

  # @raise [ConnectionNotEstablished]
  def checkout_new_connection; end

  # --
  # From the discussion on GitHub:
  #  https://github.com/rails/rails/pull/14938#commitcomment-6601951
  # This hook-in method allows for easier monkey-patching fixes needed by
  # JRuby users that use Fibers.
  def connection_cache_key(thread); end

  def current_thread; end
  def new_connection; end

  # --
  # if owner_thread param is omitted, this must be called in synchronize block
  def release(conn, owner_thread = T.unsafe(nil)); end

  # --
  # if owner_thread param is omitted, this must be called in synchronize block
  def remove_connection_from_thread_cache(conn, owner_thread = T.unsafe(nil)); end

  # If the pool is not at a <tt>@size</tt> limit, establish new connection. Connecting
  # to the DB is done outside main synchronized section.
  # --
  # Implementation constraint: a newly established connection returned by this
  # method must be in the +.leased+ state.
  def try_to_checkout_new_connection; end

  # Take control of all existing connections so a "group" action such as
  # reload/disconnect can be performed safely. It is no longer enough to
  # wrap it in +synchronize+ because some pool's actions are allowed
  # to be performed outside of the main +synchronize+ block.
  def with_exclusively_acquired_all_connections(raise_on_acquisition_timeout = T.unsafe(nil)); end

  def with_new_connections_blocked; end
end

# Adds the ability to turn a basic fair FIFO queue into one
# biased to some thread.
module ActiveRecord::ConnectionAdapters::ConnectionPool::BiasableQueue
  def with_a_bias_for(thread); end
end

class ActiveRecord::ConnectionAdapters::ConnectionPool::BiasableQueue::BiasedConditionVariable
  # semantics of condition variables guarantee that +broadcast+, +broadcast_on_biased+,
  # +signal+ and +wait+ methods are only called while holding a lock
  #
  # @return [BiasedConditionVariable] a new instance of BiasedConditionVariable
  def initialize(lock, other_cond, preferred_thread); end

  def broadcast; end
  def broadcast_on_biased; end
  def signal; end
  def wait(timeout); end
end

# Connections must be leased while holding the main pool mutex. This is
# an internal subclass that also +.leases+ returned connections while
# still in queue's critical section (queue synchronizes with the same
# <tt>@lock</tt> as the main pool) so that a returned connection is already
# leased and there is no need to re-enter synchronized block.
class ActiveRecord::ConnectionAdapters::ConnectionPool::ConnectionLeasingQueue < ::ActiveRecord::ConnectionAdapters::ConnectionPool::Queue
  include ::ActiveRecord::ConnectionAdapters::ConnectionPool::BiasableQueue

  private

  def internal_poll(timeout); end
end

# Threadsafe, fair, LIFO queue.  Meant to be used by ConnectionPool
# with which it shares a Monitor.
class ActiveRecord::ConnectionAdapters::ConnectionPool::Queue
  # @return [Queue] a new instance of Queue
  def initialize(lock = T.unsafe(nil)); end

  # Add +element+ to the queue.  Never blocks.
  def add(element); end

  # Test if any threads are currently waiting on the queue.
  #
  # @return [Boolean]
  def any_waiting?; end

  # Remove all elements from the queue.
  def clear; end

  # If +element+ is in the queue, remove and return it, or +nil+.
  def delete(element); end

  # Returns the number of threads currently waiting on this
  # queue.
  def num_waiting; end

  # Remove the head of the queue.
  #
  # If +timeout+ is not given, remove and return the head of the
  # queue if the number of available elements is strictly
  # greater than the number of threads currently waiting (that
  # is, don't jump ahead in line).  Otherwise, return +nil+.
  #
  # If +timeout+ is given, block if there is no element
  # available, waiting up to +timeout+ seconds for an element to
  # become available.
  #
  # Raises:
  # - ActiveRecord::ConnectionTimeoutError if +timeout+ is given and no element
  # becomes available within +timeout+ seconds,
  def poll(timeout = T.unsafe(nil)); end

  private

  # Test if the queue currently contains any elements.
  #
  # @return [Boolean]
  def any?; end

  # A thread can remove an element from the queue without
  # waiting if and only if the number of currently available
  # connections is strictly greater than the number of waiting
  # threads.
  #
  # @return [Boolean]
  def can_remove_no_wait?; end

  def internal_poll(timeout); end

  # Remove and return the head of the queue if the number of
  # available elements is strictly greater than the number of
  # threads currently waiting.  Otherwise, return +nil+.
  def no_wait_poll; end

  # Removes and returns the head of the queue if possible, or +nil+.
  def remove; end

  def synchronize(&block); end

  # Waits on the queue up to +timeout+ seconds, then removes and
  # returns the head of the queue.
  def wait_poll(timeout); end
end

# Every +frequency+ seconds, the reaper will call +reap+ and +flush+ on
# +pool+. A reaper instantiated with a zero frequency will never reap
# the connection pool.
#
# Configure the frequency by setting +reaping_frequency+ in your database
# yaml file (default 60 seconds).
class ActiveRecord::ConnectionAdapters::ConnectionPool::Reaper
  # @return [Reaper] a new instance of Reaper
  def initialize(pool, frequency); end

  # Returns the value of attribute frequency.
  def frequency; end

  # Returns the value of attribute pool.
  def pool; end

  def run; end

  class << self
    def register_pool(pool, frequency); end

    private

    def spawn_thread(frequency); end
  end
end

class ActiveRecord::ConnectionAdapters::CreateIndexDefinition < ::Struct
  # Returns the value of attribute algorithm
  #
  # @return [Object] the current value of algorithm
  def algorithm; end

  # Sets the attribute algorithm
  #
  # @param value [Object] the value to set the attribute algorithm to.
  # @return [Object] the newly set value
  def algorithm=(_); end

  # Returns the value of attribute if_not_exists
  #
  # @return [Object] the current value of if_not_exists
  def if_not_exists; end

  # Sets the attribute if_not_exists
  #
  # @param value [Object] the value to set the attribute if_not_exists to.
  # @return [Object] the newly set value
  def if_not_exists=(_); end

  # Returns the value of attribute index
  #
  # @return [Object] the current value of index
  def index; end

  # Sets the attribute index
  #
  # @param value [Object] the value to set the attribute index to.
  # @return [Object] the newly set value
  def index=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def members; end
    def new(*_arg0); end
  end
end

module ActiveRecord::ConnectionAdapters::DatabaseLimits
  # Returns the maximum allowed length for an index name. This
  # limit is enforced by \Rails and is less than or equal to
  # #index_name_length. The gap between
  # #index_name_length is to allow internal \Rails
  # operations to use prefixes in temporary operations.
  def allowed_index_name_length(*args, &block); end

  # Returns the maximum number of elements in an IN (x,y,z) clause.
  # +nil+ means no limit.
  def in_clause_length(*args, &block); end

  # Returns the maximum length of an index name.
  def index_name_length; end

  def max_identifier_length; end

  # Returns the maximum length of a table alias.
  def table_alias_length; end

  private

  def bind_params_length; end
end

module ActiveRecord::ConnectionAdapters::DatabaseStatements
  def initialize; end

  # Register a record with the current transaction so that its after_commit and after_rollback callbacks
  # can be called.
  def add_transaction_record(record, ensure_finalize = T.unsafe(nil)); end

  # Begins the transaction (and turns off auto-committing).
  def begin_db_transaction; end

  # Begins the transaction with the isolation level set. Raises an error by
  # default; adapters that support setting the isolation level should implement
  # this method.
  #
  # @raise [ActiveRecord::TransactionIsolationError]
  def begin_isolated_db_transaction(isolation); end

  def begin_transaction(*_arg0, &_arg1); end

  # This is used in the StatementCache object. It returns an object that
  # can be used to query the database repeatedly.
  def cacheable_query(klass, arel); end

  # Commits the transaction (and turns on auto-committing).
  def commit_db_transaction; end

  def commit_transaction(*_arg0, &_arg1); end

  # Executes an INSERT query and returns the new record's ID
  #
  # +id_value+ will be returned unless the value is +nil+, in
  # which case the database will attempt to calculate the last inserted
  # id and return that value.
  #
  # If the next id was calculated in advance (as in Oracle), it should be
  # passed in as +id_value+.
  def create(arel, name = T.unsafe(nil), pk = T.unsafe(nil), id_value = T.unsafe(nil), sequence_name = T.unsafe(nil), binds = T.unsafe(nil)); end

  def current_transaction(*_arg0, &_arg1); end
  def default_sequence_name(table, column); end

  # Executes the delete statement and returns the number of rows affected.
  def delete(arel, name = T.unsafe(nil), binds = T.unsafe(nil)); end

  def disable_lazy_transactions!(*_arg0, &_arg1); end
  def empty_insert_statement_value(primary_key = T.unsafe(nil)); end
  def enable_lazy_transactions!(*_arg0, &_arg1); end

  # Executes delete +sql+ statement in the context of this connection using
  # +binds+ as the bind substitutes. +name+ is logged along with
  # the executed +sql+ statement.
  def exec_delete(sql, name = T.unsafe(nil), binds = T.unsafe(nil)); end

  # Executes insert +sql+ statement in the context of this connection using
  # +binds+ as the bind substitutes. +name+ is logged along with
  # the executed +sql+ statement.
  def exec_insert(sql, name = T.unsafe(nil), binds = T.unsafe(nil), pk = T.unsafe(nil), sequence_name = T.unsafe(nil)); end

  def exec_insert_all(sql, name); end

  # Executes +sql+ statement in the context of this connection using
  # +binds+ as the bind substitutes. +name+ is logged along with
  # the executed +sql+ statement.
  #
  # @raise [NotImplementedError]
  def exec_query(sql, name = T.unsafe(nil), binds = T.unsafe(nil), prepare: T.unsafe(nil)); end

  def exec_rollback_db_transaction; end

  # Executes update +sql+ statement in the context of this connection using
  # +binds+ as the bind substitutes. +name+ is logged along with
  # the executed +sql+ statement.
  def exec_update(sql, name = T.unsafe(nil), binds = T.unsafe(nil)); end

  # Executes the SQL statement in the context of this connection and returns
  # the raw result from the connection adapter.
  # Note: depending on your database connector, the result returned by this
  # method may be manually memory managed. Consider using the exec_query
  # wrapper instead.
  #
  # @raise [NotImplementedError]
  def execute(sql, name = T.unsafe(nil)); end

  # @raise [NotImplementedError]
  def explain(arel, binds = T.unsafe(nil)); end

  # Executes an INSERT query and returns the new record's ID
  #
  # +id_value+ will be returned unless the value is +nil+, in
  # which case the database will attempt to calculate the last inserted
  # id and return that value.
  #
  # If the next id was calculated in advance (as in Oracle), it should be
  # passed in as +id_value+.
  def insert(arel, name = T.unsafe(nil), pk = T.unsafe(nil), id_value = T.unsafe(nil), sequence_name = T.unsafe(nil), binds = T.unsafe(nil)); end

  # Inserts the given fixture into the table. Overridden in adapters that require
  # something beyond a simple insert (e.g. Oracle).
  # Most of adapters should implement +insert_fixtures_set+ that leverages bulk SQL insert.
  # We keep this method to provide fallback
  # for databases like sqlite that do not support bulk inserts.
  def insert_fixture(fixture, table_name); end

  def insert_fixtures_set(fixture_set, tables_to_delete = T.unsafe(nil)); end
  def mark_transaction_written_if_write(sql); end
  def materialize_transactions(*_arg0, &_arg1); end
  def open_transactions(*_arg0, &_arg1); end
  def query(sql, name = T.unsafe(nil)); end
  def query_value(sql, name = T.unsafe(nil)); end
  def query_values(sql, name = T.unsafe(nil)); end

  # Set the sequence to the max value of the table's column.
  def reset_sequence!(table, column, sequence = T.unsafe(nil)); end

  def reset_transaction; end

  # Rolls back the transaction (and turns on auto-committing). Must be
  # done if the transaction block raises an exception or returns false.
  def rollback_db_transaction; end

  def rollback_to_savepoint(name = T.unsafe(nil)); end
  def rollback_transaction(*_arg0, &_arg1); end

  # Sanitizes the given LIMIT parameter in order to prevent SQL injection.
  #
  # The +limit+ may be anything that can evaluate to a string via #to_s. It
  # should look like an integer, or an Arel SQL literal.
  #
  # Returns Integer and Arel::Nodes::SqlLiteral limits as is.
  def sanitize_limit(limit); end

  # Returns an ActiveRecord::Result instance.
  def select_all(arel, name = T.unsafe(nil), binds = T.unsafe(nil), preparable: T.unsafe(nil)); end

  # Returns a record hash with the column names as keys and column values
  # as values.
  def select_one(arel, name = T.unsafe(nil), binds = T.unsafe(nil)); end

  # Returns an array of arrays containing the field values.
  # Order is the same as that returned by +columns+.
  def select_rows(arel, name = T.unsafe(nil), binds = T.unsafe(nil)); end

  # Returns a single value from a record
  def select_value(arel, name = T.unsafe(nil), binds = T.unsafe(nil)); end

  # Returns an array of the values of the first column in a select:
  #   select_values("SELECT id FROM companies LIMIT 3") => [1,2,3]
  def select_values(arel, name = T.unsafe(nil), binds = T.unsafe(nil)); end

  # Converts an arel AST to SQL
  def to_sql(arel_or_sql_string, binds = T.unsafe(nil)); end

  # Runs the given block in a database transaction, and returns the result
  # of the block.
  #
  # == Nested transactions support
  #
  # #transaction calls can be nested. By default, this makes all database
  # statements in the nested transaction block become part of the parent
  # transaction. For example, the following behavior may be surprising:
  #
  #   ActiveRecord::Base.transaction do
  #     Post.create(title: 'first')
  #     ActiveRecord::Base.transaction do
  #       Post.create(title: 'second')
  #       raise ActiveRecord::Rollback
  #     end
  #   end
  #
  # This creates both "first" and "second" posts. Reason is the
  # ActiveRecord::Rollback exception in the nested block does not issue a
  # ROLLBACK. Since these exceptions are captured in transaction blocks,
  # the parent block does not see it and the real transaction is committed.
  #
  # Most databases don't support true nested transactions. At the time of
  # writing, the only database that supports true nested transactions that
  # we're aware of, is MS-SQL.
  #
  # In order to get around this problem, #transaction will emulate the effect
  # of nested transactions, by using savepoints:
  # https://dev.mysql.com/doc/refman/en/savepoint.html.
  #
  # It is safe to call this method if a database transaction is already open,
  # i.e. if #transaction is called within another #transaction block. In case
  # of a nested call, #transaction will behave as follows:
  #
  # - The block will be run without doing anything. All database statements
  #   that happen within the block are effectively appended to the already
  #   open database transaction.
  # - However, if +:requires_new+ is set, the block will be wrapped in a
  #   database savepoint acting as a sub-transaction.
  #
  # In order to get a ROLLBACK for the nested transaction you may ask for a
  # real sub-transaction by passing <tt>requires_new: true</tt>.
  # If anything goes wrong, the database rolls back to the beginning of
  # the sub-transaction without rolling back the parent transaction.
  # If we add it to the previous example:
  #
  #   ActiveRecord::Base.transaction do
  #     Post.create(title: 'first')
  #     ActiveRecord::Base.transaction(requires_new: true) do
  #       Post.create(title: 'second')
  #       raise ActiveRecord::Rollback
  #     end
  #   end
  #
  # only post with title "first" is created.
  #
  # See ActiveRecord::Transactions to learn more.
  #
  # === Caveats
  #
  # MySQL doesn't support DDL transactions. If you perform a DDL operation,
  # then any created savepoints will be automatically released. For example,
  # if you've created a savepoint, then you execute a CREATE TABLE statement,
  # then the savepoint that was created will be automatically released.
  #
  # This means that, on MySQL, you shouldn't execute DDL operations inside
  # a #transaction call that you know might create a savepoint. Otherwise,
  # #transaction will raise exceptions when it tries to release the
  # already-automatically-released savepoints:
  #
  #   Model.connection.transaction do  # BEGIN
  #     Model.connection.transaction(requires_new: true) do  # CREATE SAVEPOINT active_record_1
  #       Model.connection.create_table(...)
  #       # active_record_1 now automatically released
  #     end  # RELEASE SAVEPOINT active_record_1  <--- BOOM! database error!
  #   end
  #
  # == Transaction isolation
  #
  # If your database supports setting the isolation level for a transaction, you can set
  # it like so:
  #
  #   Post.transaction(isolation: :serializable) do
  #     # ...
  #   end
  #
  # Valid isolation levels are:
  #
  # * <tt>:read_uncommitted</tt>
  # * <tt>:read_committed</tt>
  # * <tt>:repeatable_read</tt>
  # * <tt>:serializable</tt>
  #
  # You should consult the documentation for your database to understand the
  # semantics of these different levels:
  #
  # * https://www.postgresql.org/docs/current/static/transaction-iso.html
  # * https://dev.mysql.com/doc/refman/en/set-transaction.html
  #
  # An ActiveRecord::TransactionIsolationError will be raised if:
  #
  # * The adapter does not support setting the isolation level
  # * You are joining an existing open transaction
  # * You are creating a nested (savepoint) transaction
  #
  # The mysql2 and postgresql adapters support setting the transaction
  # isolation level.
  def transaction(requires_new: T.unsafe(nil), isolation: T.unsafe(nil), joinable: T.unsafe(nil)); end

  def transaction_isolation_levels; end
  def transaction_manager; end

  # @return [Boolean]
  def transaction_open?; end

  # Executes the truncate statement.
  def truncate(table_name, name = T.unsafe(nil)); end

  def truncate_tables(*table_names); end

  # Executes the update statement and returns the number of rows affected.
  def update(arel, name = T.unsafe(nil), binds = T.unsafe(nil)); end

  # Fixture value is quoted by Arel, however scalar values
  # are not quotable. In this case we want to convert
  # the column value to YAML.
  def with_yaml_fallback(value); end

  def within_new_transaction(*_arg0, &_arg1); end

  # Determines whether the SQL statement is a write query.
  #
  # @raise [NotImplementedError]
  # @return [Boolean]
  def write_query?(sql); end

  private

  def arel_from_relation(relation); end
  def build_fixture_sql(fixtures, table_name); end
  def build_fixture_statements(fixture_set); end
  def build_truncate_statement(table_name); end
  def build_truncate_statements(table_names); end
  def combine_multi_statements(total_sql); end
  def default_insert_value(column); end
  def execute_batch(statements, name = T.unsafe(nil)); end
  def last_inserted_id(result); end

  # Returns an ActiveRecord::Result instance.
  def select(sql, name = T.unsafe(nil), binds = T.unsafe(nil)); end

  def select_prepared(sql, name = T.unsafe(nil), binds = T.unsafe(nil)); end
  def single_value_from_rows(rows); end
  def sql_for_insert(sql, pk, binds); end
  def to_sql_and_binds(arel_or_sql_string, binds = T.unsafe(nil), preparable = T.unsafe(nil)); end
  def with_multi_statements; end
end

ActiveRecord::ConnectionAdapters::DatabaseStatements::DEFAULT_INSERT_VALUE = T.let(T.unsafe(nil), Arel::Nodes::SqlLiteral)

module ActiveRecord::ConnectionAdapters::Deduplicable
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::ActiveRecord::ConnectionAdapters::Deduplicable::ClassMethods

  def -@; end
  def deduplicate; end

  private

  def deduplicated; end
end

module ActiveRecord::ConnectionAdapters::Deduplicable::ClassMethods
  def new(*_arg0, **_arg1); end
  def registry; end
end

class ActiveRecord::ConnectionAdapters::ForeignKeyDefinition < ::Struct
  def column; end

  # @return [Boolean]
  def custom_primary_key?; end

  # @return [Boolean]
  def defined_for?(to_table: T.unsafe(nil), validate: T.unsafe(nil), **options); end

  # @return [Boolean]
  def export_name_on_schema_dump?; end

  # Returns the value of attribute from_table
  #
  # @return [Object] the current value of from_table
  def from_table; end

  # Sets the attribute from_table
  #
  # @param value [Object] the value to set the attribute from_table to.
  # @return [Object] the newly set value
  def from_table=(_); end

  def name; end
  def on_delete; end
  def on_update; end

  # Returns the value of attribute options
  #
  # @return [Object] the current value of options
  def options; end

  # Sets the attribute options
  #
  # @param value [Object] the value to set the attribute options to.
  # @return [Object] the newly set value
  def options=(_); end

  def primary_key; end

  # Returns the value of attribute to_table
  #
  # @return [Object] the current value of to_table
  def to_table; end

  # Sets the attribute to_table
  #
  # @param value [Object] the value to set the attribute to_table to.
  # @return [Object] the newly set value
  def to_table=(_); end

  # @return [Boolean]
  def validate?; end

  # @return [Boolean]
  def validated?; end

  private

  def default_primary_key; end

  class << self
    def [](*_arg0); end
    def inspect; end
    def members; end
    def new(*_arg0); end
  end
end

# Abstract representation of an index definition on a table. Instances of
# this type are typically created and returned by methods in database
# adapters. e.g. ActiveRecord::ConnectionAdapters::MySQL::SchemaStatements#indexes
class ActiveRecord::ConnectionAdapters::IndexDefinition
  # @return [IndexDefinition] a new instance of IndexDefinition
  def initialize(table, name, unique = T.unsafe(nil), columns = T.unsafe(nil), lengths: T.unsafe(nil), orders: T.unsafe(nil), opclasses: T.unsafe(nil), where: T.unsafe(nil), type: T.unsafe(nil), using: T.unsafe(nil), comment: T.unsafe(nil)); end

  def column_options; end
  def columns; end
  def comment; end
  def lengths; end
  def name; end
  def opclasses; end
  def orders; end
  def table; end
  def type; end
  def unique; end
  def using; end
  def where; end

  private

  def concise_options(options); end
end

class ActiveRecord::ConnectionAdapters::LegacyPoolManager
  # @return [LegacyPoolManager] a new instance of LegacyPoolManager
  def initialize; end

  def get_pool_config(_, shard); end
  def pool_configs(_ = T.unsafe(nil)); end
  def remove_pool_config(_, shard); end
  def set_pool_config(role, shard, pool_config); end
  def shard_names; end
end

class ActiveRecord::ConnectionAdapters::NullColumn < ::ActiveRecord::ConnectionAdapters::Column
  # @return [NullColumn] a new instance of NullColumn
  def initialize(name, **_arg1); end
end

class ActiveRecord::ConnectionAdapters::NullPool
  include ::ActiveRecord::ConnectionAdapters::AbstractPool

  def connection_klass; end

  # Returns the value of attribute schema_cache.
  def schema_cache; end

  # Sets the attribute schema_cache
  #
  # @param value the value to set the attribute schema_cache to.
  def schema_cache=(_arg0); end
end

class ActiveRecord::ConnectionAdapters::NullTransaction
  # @return [NullTransaction] a new instance of NullTransaction
  def initialize; end

  def add_record(record, _ = T.unsafe(nil)); end

  # @return [Boolean]
  def closed?; end

  # @return [Boolean]
  def joinable?; end

  # @return [Boolean]
  def open?; end

  def state; end
end

class ActiveRecord::ConnectionAdapters::PoolConfig
  include ::Mutex_m

  # @return [PoolConfig] a new instance of PoolConfig
  def initialize(connection_klass, db_config); end

  # Returns the value of attribute connection_klass.
  def connection_klass; end

  def connection_specification_name; end

  # Returns the value of attribute db_config.
  def db_config; end

  def discard_pool!; end
  def disconnect!; end
  def lock; end
  def locked?; end
  def pool; end

  # Returns the value of attribute schema_cache.
  def schema_cache; end

  # Sets the attribute schema_cache
  #
  # @param value the value to set the attribute schema_cache to.
  def schema_cache=(_arg0); end

  def synchronize(&block); end
  def try_lock; end
  def unlock; end

  class << self
    def discard_pools!; end
  end
end

ActiveRecord::ConnectionAdapters::PoolConfig::INSTANCES = T.let(T.unsafe(nil), ObjectSpace::WeakMap[T.untyped])

class ActiveRecord::ConnectionAdapters::PoolManager
  # @return [PoolManager] a new instance of PoolManager
  def initialize; end

  def get_pool_config(role, shard); end
  def pool_configs(role = T.unsafe(nil)); end
  def remove_pool_config(role, shard); end
  def remove_role(role); end
  def role_names; end
  def set_pool_config(role, shard, pool_config); end
  def shard_names; end
end

module ActiveRecord::ConnectionAdapters::PostgreSQL; end

class ActiveRecord::ConnectionAdapters::PostgreSQL::AlterTable < ::ActiveRecord::ConnectionAdapters::AlterTable
  # @return [AlterTable] a new instance of AlterTable
  def initialize(td); end

  # Returns the value of attribute constraint_validations.
  def constraint_validations; end

  def validate_constraint(name); end
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::Column < ::ActiveRecord::ConnectionAdapters::Column
  # @return [Column] a new instance of Column
  def initialize(*_arg0, serial: T.unsafe(nil), **_arg2); end

  def ==(other); end
  def array; end
  def array?; end
  def encode_with(coder); end
  def eql?(other); end
  def fmod(*_arg0, &_arg1); end
  def hash; end
  def init_with(coder); end
  def oid(*_arg0, &_arg1); end

  # @return [Boolean]
  def serial?; end

  def sql_type; end
end

module ActiveRecord::ConnectionAdapters::PostgreSQL::ColumnMethods
  extend ::ActiveSupport::Concern

  # Defines the primary key field.
  # Use of the native PostgreSQL UUID type is supported, and can be used
  # by defining your tables as such:
  #
  #   create_table :stuffs, id: :uuid do |t|
  #     t.string :content
  #     t.timestamps
  #   end
  #
  # By default, this will use the <tt>gen_random_uuid()</tt> function from the
  # +pgcrypto+ extension. As that extension is only available in
  # PostgreSQL 9.4+, for earlier versions an explicit default can be set
  # to use <tt>uuid_generate_v4()</tt> from the +uuid-ossp+ extension instead:
  #
  #   create_table :stuffs, id: false do |t|
  #     t.primary_key :id, :uuid, default: "uuid_generate_v4()"
  #     t.uuid :foo_id
  #     t.timestamps
  #   end
  #
  # To enable the appropriate extension, which is a requirement, use
  # the +enable_extension+ method in your migrations.
  #
  # To use a UUID primary key without any of the extensions, set the
  # +:default+ option to +nil+:
  #
  #   create_table :stuffs, id: false do |t|
  #     t.primary_key :id, :uuid, default: nil
  #     t.uuid :foo_id
  #     t.timestamps
  #   end
  #
  # You may also pass a custom stored procedure that returns a UUID or use a
  # different UUID generation function from another library.
  #
  # Note that setting the UUID primary key default value to +nil+ will
  # require you to assure that you always provide a UUID value before saving
  # a record (as primary keys cannot be +nil+). This might be done via the
  # +SecureRandom.uuid+ method and a +before_save+ callback, for instance.
  def primary_key(name, type = T.unsafe(nil), **options); end
end

module ActiveRecord::ConnectionAdapters::PostgreSQL::DatabaseStatements
  # Begins a transaction.
  def begin_db_transaction; end

  def begin_isolated_db_transaction(isolation); end

  # Commits a transaction.
  def commit_db_transaction; end

  def exec_delete(sql, name = T.unsafe(nil), binds = T.unsafe(nil)); end
  def exec_insert(sql, name = T.unsafe(nil), binds = T.unsafe(nil), pk = T.unsafe(nil), sequence_name = T.unsafe(nil)); end
  def exec_query(sql, name = T.unsafe(nil), binds = T.unsafe(nil), prepare: T.unsafe(nil)); end

  # Aborts a transaction.
  def exec_rollback_db_transaction; end

  def exec_update(sql, name = T.unsafe(nil), binds = T.unsafe(nil)); end

  # Executes an SQL statement, returning a PG::Result object on success
  # or raising a PG::Error exception otherwise.
  # Note: the PG::Result object is manually memory managed; if you don't
  # need it specifically, you may want consider the <tt>exec_query</tt> wrapper.
  def execute(sql, name = T.unsafe(nil)); end

  def explain(arel, binds = T.unsafe(nil)); end

  # Queries the database and returns the results in an Array-like object
  def query(sql, name = T.unsafe(nil)); end

  # @return [Boolean]
  def write_query?(sql); end

  private

  def build_truncate_statements(table_names); end
  def execute_batch(statements, name = T.unsafe(nil)); end

  # Returns the current ID of a table's sequence.
  def last_insert_id_result(sequence_name); end

  def sql_for_insert(sql, pk, binds); end
  def suppress_composite_primary_key(pk); end
end

ActiveRecord::ConnectionAdapters::PostgreSQL::DatabaseStatements::READ_QUERY = T.let(T.unsafe(nil), Regexp)

class ActiveRecord::ConnectionAdapters::PostgreSQL::ExplainPrettyPrinter
  # Pretty prints the result of an EXPLAIN in a way that resembles the output of the
  # PostgreSQL shell:
  #
  #                                     QUERY PLAN
  #   ------------------------------------------------------------------------------
  #    Nested Loop Left Join  (cost=0.00..37.24 rows=8 width=0)
  #      Join Filter: (posts.user_id = users.id)
  #      ->  Index Scan using users_pkey on users  (cost=0.00..8.27 rows=1 width=4)
  #            Index Cond: (id = 1)
  #      ->  Seq Scan on posts  (cost=0.00..28.88 rows=8 width=4)
  #            Filter: (posts.user_id = 1)
  #   (6 rows)
  def pp(result); end
end

# Value Object to hold a schema qualified name.
# This is usually the name of a PostgreSQL relation but it can also represent
# schema qualified type names. +schema+ and +identifier+ are unquoted to prevent
# double quoting.
class ActiveRecord::ConnectionAdapters::PostgreSQL::Name
  # @return [Name] a new instance of Name
  def initialize(schema, identifier); end

  def ==(o); end
  def eql?(o); end
  def hash; end

  # Returns the value of attribute identifier.
  def identifier; end

  def quoted; end

  # Returns the value of attribute schema.
  def schema; end

  def to_s; end

  protected

  def parts; end

  private

  def unquote(part); end
end

ActiveRecord::ConnectionAdapters::PostgreSQL::Name::SEPARATOR = T.let(T.unsafe(nil), String)
module ActiveRecord::ConnectionAdapters::PostgreSQL::OID; end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Array < ::ActiveModel::Type::Value
  include ::ActiveModel::Type::Helpers::Mutable

  # @return [Array] a new instance of Array
  def initialize(subtype, delimiter = T.unsafe(nil)); end

  def ==(other); end
  def cast(value); end

  # @return [Boolean]
  def changed_in_place?(raw_old_value, new_value); end

  # Returns the value of attribute delimiter.
  def delimiter; end

  def deserialize(value); end

  # @return [Boolean]
  def force_equality?(value); end

  def limit(*_arg0, &_arg1); end
  def map(value, &block); end
  def precision(*_arg0, &_arg1); end
  def scale(*_arg0, &_arg1); end
  def serialize(value); end

  # Returns the value of attribute subtype.
  def subtype; end

  def type(*_arg0, &_arg1); end
  def type_cast_for_schema(value); end
  def user_input_in_time_zone(*_arg0, &_arg1); end

  private

  def type_cast_array(value, method); end
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Array::Data < ::Struct
  # Returns the value of attribute encoder
  #
  # @return [Object] the current value of encoder
  def encoder; end

  # Sets the attribute encoder
  #
  # @param value [Object] the value to set the attribute encoder to.
  # @return [Object] the newly set value
  def encoder=(_); end

  # Returns the value of attribute values
  #
  # @return [Object] the current value of values
  def values; end

  # Sets the attribute values
  #
  # @param value [Object] the value to set the attribute values to.
  # @return [Object] the newly set value
  def values=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def members; end
    def new(*_arg0); end
  end
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Bit < ::ActiveModel::Type::Value
  def cast_value(value); end
  def serialize(value); end
  def type; end
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Bit::Data
  # @return [Data] a new instance of Data
  def initialize(value); end

  # @return [Boolean]
  def binary?; end

  # @return [Boolean]
  def hex?; end

  def to_s; end

  private

  # Returns the value of attribute value.
  def value; end
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::BitVarying < ::ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Bit
  def type; end
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Bytea < ::ActiveModel::Type::Binary
  def deserialize(value); end
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Cidr < ::ActiveModel::Type::Value
  def cast_value(value); end
  def serialize(value); end
  def type; end
  def type_cast_for_schema(value); end
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Date < ::ActiveRecord::Type::Date
  def cast_value(value); end
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::DateTime < ::ActiveRecord::Type::DateTime
  def cast_value(value); end
  def type_cast_for_schema(value); end
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Decimal < ::ActiveModel::Type::Decimal
  def infinity(options = T.unsafe(nil)); end
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Enum < ::ActiveModel::Type::Value
  def type; end

  private

  def cast_value(value); end
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Hstore < ::ActiveModel::Type::Value
  include ::ActiveModel::Type::Helpers::Mutable

  def accessor; end

  # Will compare the Hash equivalents of +raw_old_value+ and +new_value+.
  # By comparing hashes, this avoids an edge case where the order of
  # the keys change between the two hashes, and they would not be marked
  # as equal.
  #
  # @return [Boolean]
  def changed_in_place?(raw_old_value, new_value); end

  def deserialize(value); end
  def serialize(value); end
  def type; end

  private

  def escape_hstore(value); end
end

ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Hstore::HstorePair = T.let(T.unsafe(nil), Regexp)

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Inet < ::ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Cidr
  def type; end
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Interval < ::ActiveModel::Type::Value
  def cast_value(value); end
  def serialize(value); end
  def type; end
  def type_cast_for_schema(value); end
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Jsonb < ::ActiveRecord::Type::Json
  def type; end
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::LegacyPoint < ::ActiveModel::Type::Value
  include ::ActiveModel::Type::Helpers::Mutable

  def cast(value); end
  def serialize(value); end
  def type; end

  private

  def number_for_point(number); end
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Macaddr < ::ActiveModel::Type::String
  # @return [Boolean]
  def changed?(old_value, new_value, _new_value_before_type_cast); end

  # @return [Boolean]
  def changed_in_place?(raw_old_value, new_value); end

  def type; end
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Money < ::ActiveModel::Type::Decimal
  def cast_value(value); end
  def scale; end
  def type; end
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Oid < ::ActiveRecord::Type::UnsignedInteger
  def type; end
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Point < ::ActiveModel::Type::Value
  include ::ActiveModel::Type::Helpers::Mutable

  def cast(value); end
  def serialize(value); end
  def type; end
  def type_cast_for_schema(value); end

  private

  def build_point(x, y); end
  def number_for_point(number); end
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Range < ::ActiveModel::Type::Value
  # @return [Range] a new instance of Range
  def initialize(subtype, type = T.unsafe(nil)); end

  def ==(other); end
  def cast_value(value); end

  # @return [Boolean]
  def force_equality?(value); end

  def map(value); end
  def serialize(value); end

  # Returns the value of attribute subtype.
  def subtype; end

  # Returns the value of attribute type.
  def type; end

  def type_cast_for_schema(value); end
  def user_input_in_time_zone(*_arg0, &_arg1); end

  private

  def extract_bounds(value); end
  def infinity(negative: T.unsafe(nil)); end

  # @return [Boolean]
  def infinity?(value); end

  def type_cast_single(value); end
  def type_cast_single_for_database(value); end

  # When formatting the bound values of range types, PostgreSQL quotes
  # the bound value using double-quotes in certain conditions. Within
  # a double-quoted string, literal " and \ characters are themselves
  # escaped. In input, PostgreSQL accepts multiple escape styles for "
  # (either \" or "") but in output always uses "".
  # See:
  # * https://www.postgresql.org/docs/current/rangetypes.html#RANGETYPES-IO
  # * https://www.postgresql.org/docs/current/rowtypes.html#ROWTYPES-IO-SYNTAX
  def unquote(value); end
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::SpecializedString < ::ActiveModel::Type::String
  # @return [SpecializedString] a new instance of SpecializedString
  def initialize(type, **options); end

  # Returns the value of attribute type.
  def type; end
end

# This class uses the data from PostgreSQL pg_type table to build
# the OID -> Type mapping.
#   - OID is an integer representing the type.
#   - Type is an OID::Type object.
# This class has side effects on the +store+ passed during initialization.
class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::TypeMapInitializer
  # @return [TypeMapInitializer] a new instance of TypeMapInitializer
  def initialize(store); end

  def query_conditions_for_initial_load; end
  def run(records); end

  private

  def alias_type(oid, target); end

  # @raise [ArgumentError]
  def assert_valid_registration(oid, oid_type); end

  def register(oid, oid_type = T.unsafe(nil), &block); end
  def register_array_type(row); end
  def register_composite_type(row); end
  def register_domain_type(row); end
  def register_enum_type(row); end
  def register_mapped_type(row); end
  def register_range_type(row); end
  def register_with_subtype(oid, target_oid); end
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Uuid < ::ActiveModel::Type::Value
  # @return [Boolean]
  def changed?(old_value, new_value, _new_value_before_type_cast); end

  # @return [Boolean]
  def changed_in_place?(raw_old_value, new_value); end

  def serialize(value); end
  def type; end

  private

  def cast_value(value); end
end

ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Uuid::ACCEPTABLE_UUID = T.let(T.unsafe(nil), Regexp)

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Vector < ::ActiveModel::Type::Value
  # +delim+ corresponds to the `typdelim` column in the pg_types
  # table.  +subtype+ is derived from the `typelem` column in the
  # pg_types table.
  #
  # @return [Vector] a new instance of Vector
  def initialize(delim, subtype); end

  # FIXME: this should probably split on +delim+ and use +subtype+
  # to cast the values.  Unfortunately, the current Rails behavior
  # is to just return the string.
  def cast(value); end

  # Returns the value of attribute delim.
  def delim; end

  # Returns the value of attribute subtype.
  def subtype; end
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Xml < ::ActiveModel::Type::String
  def serialize(value); end
  def type; end
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Xml::Data
  # @return [Data] a new instance of Data
  def initialize(value); end

  def to_s; end
end

module ActiveRecord::ConnectionAdapters::PostgreSQL::Quoting
  def column_name_matcher; end
  def column_name_with_order_matcher; end

  # Escapes binary strings for bytea input to the database.
  def escape_bytea(value); end

  def lookup_cast_type_from_column(column); end

  # Quotes column names for use in SQL queries.
  def quote_column_name(name); end

  def quote_default_expression(value, column); end

  # Quotes schema names for use in SQL queries.
  def quote_schema_name(name); end

  # Quotes strings for use in SQL input.
  def quote_string(s); end

  # Checks the following cases:
  #
  # - table_name
  # - "table.name"
  # - schema_name.table_name
  # - schema_name."table.name"
  # - "schema.name".table_name
  # - "schema.name"."table.name"
  def quote_table_name(name); end

  def quote_table_name_for_assignment(table, attr); end
  def quoted_binary(value); end

  # Quote date/time values for use in SQL input.
  def quoted_date(value); end

  # Unescapes bytea output from a database to the binary string it represents.
  # NOTE: This is NOT an inverse of escape_bytea! This is only to be used
  # on escaped binary output from database drive.
  def unescape_bytea(value); end

  private

  def _quote(value); end
  def _type_cast(value); end
  def determine_encoding_of_strings_in_array(value); end
  def encode_array(array_data); end
  def encode_range(range); end

  # @return [Boolean]
  def infinity?(value); end

  def lookup_cast_type(sql_type); end
  def type_cast_array(values); end
  def type_cast_range_value(value); end
end

ActiveRecord::ConnectionAdapters::PostgreSQL::Quoting::COLUMN_NAME = T.let(T.unsafe(nil), Regexp)
ActiveRecord::ConnectionAdapters::PostgreSQL::Quoting::COLUMN_NAME_WITH_ORDER = T.let(T.unsafe(nil), Regexp)

module ActiveRecord::ConnectionAdapters::PostgreSQL::ReferentialIntegrity
  def disable_referential_integrity; end
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::SchemaCreation < ::ActiveRecord::ConnectionAdapters::SchemaCreation
  private

  def add_column_options!(sql, options); end

  # Returns any SQL string to go between CREATE and TABLE. May be nil.
  def table_modifier_in_create(o); end

  def visit_AddForeignKey(o); end
  def visit_AlterTable(o); end
  def visit_ChangeColumnDefinition(o); end
  def visit_CheckConstraintDefinition(o); end
  def visit_ValidateConstraint(name); end
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::SchemaDumper < ::ActiveRecord::ConnectionAdapters::SchemaDumper
  private

  # @return [Boolean]
  def default_primary_key?(column); end

  # @return [Boolean]
  def explicit_primary_key_default?(column); end

  def extensions(stream); end
  def prepare_column_options(column); end
  def schema_expression(column); end
  def schema_type(column); end
end

module ActiveRecord::ConnectionAdapters::PostgreSQL::SchemaStatements
  def add_column(table_name, column_name, type, **options); end
  def add_index(table_name, column_name, **options); end
  def change_column(table_name, column_name, type, **options); end

  # Adds comment for given table column or drops it if +comment+ is a +nil+
  def change_column_comment(table_name, column_name, comment_or_changes); end

  # Changes the default value of a table column.
  def change_column_default(table_name, column_name, default_or_changes); end

  def change_column_null(table_name, column_name, null, default = T.unsafe(nil)); end

  # Adds comment for given table or drops it if +comment+ is a +nil+
  def change_table_comment(table_name, comment_or_changes); end

  def check_constraints(table_name); end

  # Returns the current client message level.
  def client_min_messages; end

  # Set the client message level.
  def client_min_messages=(level); end

  # Returns the current database collation.
  def collation; end

  # PostgreSQL requires the ORDER BY columns in the select list for distinct queries, and
  # requires that the ORDER BY include the distinct column.
  def columns_for_distinct(columns, orders); end

  # Create a new PostgreSQL database. Options include <tt>:owner</tt>, <tt>:template</tt>,
  # <tt>:encoding</tt> (defaults to utf8), <tt>:collation</tt>, <tt>:ctype</tt>,
  # <tt>:tablespace</tt>, and <tt>:connection_limit</tt> (note that MySQL uses
  # <tt>:charset</tt> while PostgreSQL uses <tt>:encoding</tt>).
  #
  # Example:
  #   create_database config[:database], config
  def create_database(name, options = T.unsafe(nil)); end

  # Creates a schema for the given schema name.
  def create_schema(schema_name); end

  def create_schema_dumper(options); end

  # Returns the current database ctype.
  def ctype; end

  # Returns the current database name.
  def current_database; end

  # Returns the current schema name.
  def current_schema; end

  # Returns the sequence name for a table's primary key or some other specified key.
  def default_sequence_name(table_name, pk = T.unsafe(nil)); end

  # Drops a PostgreSQL database.
  #
  # Example:
  #   drop_database 'matt_development'
  def drop_database(name); end

  # Drops the schema for the given schema name.
  def drop_schema(schema_name, **options); end

  def drop_table(table_name, **options); end

  # Returns the current database encoding format.
  def encoding; end

  def foreign_keys(table_name); end

  # @return [Boolean]
  def foreign_table_exists?(table_name); end

  def foreign_tables; end

  # Verifies existence of an index with a given name.
  #
  # @return [Boolean]
  def index_name_exists?(table_name, index_name); end

  # Returns an array of indexes for the given table.
  def indexes(table_name); end

  # Returns a table's primary key and belonging sequence.
  def pk_and_sequence_for(table); end

  def primary_keys(table_name); end

  # Drops the database specified on the +name+ attribute
  # and creates it again using the provided +options+.
  def recreate_database(name, options = T.unsafe(nil)); end

  def remove_index(table_name, column_name = T.unsafe(nil), **options); end

  # Renames a column in a table.
  def rename_column(table_name, column_name, new_column_name); end

  # Renames an index of a table. Raises error if length of new
  # index name is greater than allowed limit.
  def rename_index(table_name, old_name, new_name); end

  # Renames a table.
  # Also renames a table's primary key sequence if the sequence name exists and
  # matches the Active Record default.
  #
  # Example:
  #   rename_table('octopuses', 'octopi')
  def rename_table(table_name, new_name); end

  # Resets the sequence of a table's primary key to the maximum value.
  def reset_pk_sequence!(table, pk = T.unsafe(nil), sequence = T.unsafe(nil)); end

  # Returns true if schema exists.
  #
  # @return [Boolean]
  def schema_exists?(name); end

  # Returns an array of schema names.
  def schema_names; end

  # Returns the active schema search path.
  def schema_search_path; end

  # Sets the schema search path to a string of comma-separated schema names.
  # Names beginning with $ have to be quoted (e.g. $user => '$user').
  # See: https://www.postgresql.org/docs/current/static/ddl-schemas.html
  #
  # This should be not be called manually but set in database.yml.
  def schema_search_path=(schema_csv); end

  def serial_sequence(table, column); end

  # Sets the sequence of a table's primary key to the specified value.
  def set_pk_sequence!(table, value); end

  # Returns a comment stored in database for given table
  def table_comment(table_name); end

  def table_options(table_name); end

  # Maps logical Rails types to PostgreSQL-specific data types.
  def type_to_sql(type, limit: T.unsafe(nil), precision: T.unsafe(nil), scale: T.unsafe(nil), array: T.unsafe(nil), **_arg5); end

  def update_table_definition(table_name, base); end

  # Validates the given check constraint.
  #
  #   validate_check_constraint :products, name: "price_check"
  #
  # The +options+ hash accepts the same keys as add_check_constraint[rdoc-ref:ConnectionAdapters::SchemaStatements#add_check_constraint].
  def validate_check_constraint(table_name, **options); end

  # Validates the given constraint.
  #
  # Validates the constraint named +constraint_name+ on +accounts+.
  #
  #   validate_constraint :accounts, :constraint_name
  def validate_constraint(table_name, constraint_name); end

  # Validates the given foreign key.
  #
  # Validates the foreign key on +accounts.branch_id+.
  #
  #   validate_foreign_key :accounts, :branches
  #
  # Validates the foreign key on +accounts.owner_id+.
  #
  #   validate_foreign_key :accounts, column: :owner_id
  #
  # Validates the foreign key named +special_fk_name+ on the +accounts+ table.
  #
  #   validate_foreign_key :accounts, name: :special_fk_name
  #
  # The +options+ hash accepts the same keys as SchemaStatements#add_foreign_key.
  def validate_foreign_key(from_table, to_table = T.unsafe(nil), **options); end

  private

  def add_column_for_alter(table_name, column_name, type, **options); end
  def add_index_opclass(quoted_columns, **options); end
  def add_options_for_index_columns(quoted_columns, **options); end
  def change_column_default_for_alter(table_name, column_name, default_or_changes); end
  def change_column_for_alter(table_name, column_name, type, **options); end
  def change_column_null_for_alter(table_name, column_name, null, default = T.unsafe(nil)); end
  def create_alter_table(name); end
  def create_table_definition(name, **options); end
  def data_source_sql(name = T.unsafe(nil), type: T.unsafe(nil)); end
  def extract_foreign_key_action(specifier); end
  def extract_schema_qualified_name(string); end
  def fetch_type_metadata(column_name, sql_type, oid, fmod); end
  def new_column_from_field(table_name, field); end
  def quoted_scope(name = T.unsafe(nil), type: T.unsafe(nil)); end
  def schema_creation; end
  def sequence_name_from_parts(table_name, column_name, suffix); end
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::Table < ::ActiveRecord::ConnectionAdapters::Table
  include ::ActiveRecord::ConnectionAdapters::PostgreSQL::ColumnMethods

  def bigserial(*names, **options); end
  def bit(*names, **options); end
  def bit_varying(*names, **options); end
  def box(*names, **options); end
  def cidr(*names, **options); end
  def circle(*names, **options); end
  def citext(*names, **options); end
  def daterange(*names, **options); end
  def hstore(*names, **options); end
  def inet(*names, **options); end
  def int4range(*names, **options); end
  def int8range(*names, **options); end
  def interval(*names, **options); end
  def jsonb(*names, **options); end
  def line(*names, **options); end
  def lseg(*names, **options); end
  def ltree(*names, **options); end
  def macaddr(*names, **options); end
  def money(*names, **options); end
  def numrange(*names, **options); end
  def oid(*names, **options); end
  def path(*names, **options); end
  def point(*names, **options); end
  def polygon(*names, **options); end
  def serial(*names, **options); end
  def tsrange(*names, **options); end
  def tstzrange(*names, **options); end
  def tsvector(*names, **options); end
  def uuid(*names, **options); end
  def xml(*names, **options); end
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::TableDefinition < ::ActiveRecord::ConnectionAdapters::TableDefinition
  include ::ActiveRecord::ConnectionAdapters::PostgreSQL::ColumnMethods

  # @return [TableDefinition] a new instance of TableDefinition
  def initialize(*_arg0, **_arg1); end

  def bigserial(*names, **options); end
  def bit(*names, **options); end
  def bit_varying(*names, **options); end
  def box(*names, **options); end
  def cidr(*names, **options); end
  def circle(*names, **options); end
  def citext(*names, **options); end
  def daterange(*names, **options); end
  def hstore(*names, **options); end
  def inet(*names, **options); end
  def int4range(*names, **options); end
  def int8range(*names, **options); end
  def interval(*names, **options); end
  def jsonb(*names, **options); end
  def line(*names, **options); end
  def lseg(*names, **options); end
  def ltree(*names, **options); end
  def macaddr(*names, **options); end
  def money(*names, **options); end
  def numrange(*names, **options); end
  def oid(*names, **options); end
  def path(*names, **options); end
  def point(*names, **options); end
  def polygon(*names, **options); end
  def serial(*names, **options); end
  def tsrange(*names, **options); end
  def tstzrange(*names, **options); end
  def tsvector(*names, **options); end

  # Returns the value of attribute unlogged.
  def unlogged; end

  def uuid(*names, **options); end
  def xml(*names, **options); end

  private

  def integer_like_primary_key_type(type, options); end
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::TypeMetadata
  include ::ActiveRecord::ConnectionAdapters::Deduplicable
  extend ::ActiveRecord::ConnectionAdapters::Deduplicable::ClassMethods

  # @return [TypeMetadata] a new instance of TypeMetadata
  def initialize(type_metadata, oid: T.unsafe(nil), fmod: T.unsafe(nil)); end

  def ==(other); end
  def eql?(other); end

  # Returns the value of attribute fmod.
  def fmod; end

  def hash; end

  # Returns the value of attribute oid.
  def oid; end

  private

  def deduplicated; end
end

module ActiveRecord::ConnectionAdapters::PostgreSQL::Utils
  extend ::ActiveRecord::ConnectionAdapters::PostgreSQL::Utils

  # Returns an instance of <tt>ActiveRecord::ConnectionAdapters::PostgreSQL::Name</tt>
  # extracted from +string+.
  # +schema+ is +nil+ if not specified in +string+.
  # +schema+ and +identifier+ exclude surrounding quotes (regardless of whether provided in +string+)
  # +string+ supports the range of schema/table references understood by PostgreSQL, for example:
  #
  # * <tt>table_name</tt>
  # * <tt>"table.name"</tt>
  # * <tt>schema_name.table_name</tt>
  # * <tt>schema_name."table.name"</tt>
  # * <tt>"schema_name".table_name</tt>
  # * <tt>"schema.name"."table name"</tt>
  def extract_schema_qualified_name(string); end
end

# The PostgreSQL adapter works with the native C (https://github.com/ged/ruby-pg) driver.
#
# Options:
#
# * <tt>:host</tt> - Defaults to a Unix-domain socket in /tmp. On machines without Unix-domain sockets,
#   the default is to connect to localhost.
# * <tt>:port</tt> - Defaults to 5432.
# * <tt>:username</tt> - Defaults to be the same as the operating system name of the user running the application.
# * <tt>:password</tt> - Password to be used if the server demands password authentication.
# * <tt>:database</tt> - Defaults to be the same as the user name.
# * <tt>:schema_search_path</tt> - An optional schema search path for the connection given
#   as a string of comma-separated schema names. This is backward-compatible with the <tt>:schema_order</tt> option.
# * <tt>:encoding</tt> - An optional client encoding that is used in a <tt>SET client_encoding TO
#   <encoding></tt> call on the connection.
# * <tt>:min_messages</tt> - An optional client min messages that is used in a
#   <tt>SET client_min_messages TO <min_messages></tt> call on the connection.
# * <tt>:variables</tt> - An optional hash of additional parameters that
#   will be used in <tt>SET SESSION key = val</tt> calls on the connection.
# * <tt>:insert_returning</tt> - An optional boolean to control the use of <tt>RETURNING</tt> for <tt>INSERT</tt> statements
#   defaults to true.
#
# Any further options are used as connection parameters to libpq. See
# https://www.postgresql.org/docs/current/static/libpq-connect.html for the
# list of parameters.
#
# In addition, default connection parameters of libpq can be set per environment variables.
# See https://www.postgresql.org/docs/current/static/libpq-envars.html .
class ActiveRecord::ConnectionAdapters::PostgreSQLAdapter < ::ActiveRecord::ConnectionAdapters::AbstractAdapter
  include ::ActiveRecord::ConnectionAdapters::PostgreSQL::Quoting
  include ::ActiveRecord::ConnectionAdapters::PostgreSQL::ReferentialIntegrity
  include ::ActiveRecord::ConnectionAdapters::PostgreSQL::SchemaStatements
  include ::ActiveRecord::ConnectionAdapters::PostgreSQL::DatabaseStatements
  include ::ActiveRecordExplainAnalyze::PostgreSQLAdapter

  # Initializes and connects a PostgreSQL adapter.
  #
  # @return [PostgreSQLAdapter] a new instance of PostgreSQLAdapter
  def initialize(connection, logger, connection_parameters, config); end

  # Is this connection alive and ready for queries?
  #
  # @return [Boolean]
  def active?; end

  def build_insert_sql(insert); end
  def check_version; end

  # :singleton-method:
  # PostgreSQL allows the creation of "unlogged" tables, which do not record
  # data in the PostgreSQL Write-Ahead Log. This can make the tables faster,
  # but significantly increases the risk of data loss if the database
  # crashes. As a result, this should not be used in production
  # environments. If you would like all created tables to be unlogged in
  # the test environment you can add the following line to your test.rb
  # file:
  #
  #   ActiveRecord::ConnectionAdapters::PostgreSQLAdapter.create_unlogged_tables = true
  def create_unlogged_tables; end

  def create_unlogged_tables=(_arg0); end
  def create_unlogged_tables?; end

  # @return [Boolean]
  def default_index_type?(index); end

  def disable_extension(name); end
  def discard!; end

  # Disconnects from the database if already connected. Otherwise, this
  # method does nothing.
  def disconnect!; end

  def enable_extension(name); end

  # @return [Boolean]
  def extension_available?(name); end

  # @return [Boolean]
  def extension_enabled?(name); end

  def extensions; end
  def get_advisory_lock(lock_id); end

  # Returns the version of the connected PostgreSQL server.
  def get_database_version; end

  def index_algorithms; end

  # Returns the configured supported identifier length supported by PostgreSQL
  def max_identifier_length; end

  def native_database_types; end
  def postgresql_version; end

  # Close then reopen the connection.
  def reconnect!; end

  def release_advisory_lock(lock_id); end
  def reset!; end

  # Set the authorized user for this session
  def session_auth=(user); end

  def set_standard_conforming_strings; end

  # @return [Boolean]
  def supports_advisory_locks?; end

  # @return [Boolean]
  def supports_bulk_alter?; end

  # @return [Boolean]
  def supports_check_constraints?; end

  # @return [Boolean]
  def supports_comments?; end

  # @return [Boolean]
  def supports_common_table_expressions?; end

  # @return [Boolean]
  def supports_datetime_with_precision?; end

  # @return [Boolean]
  def supports_ddl_transactions?; end

  # @return [Boolean]
  def supports_explain?; end

  # @return [Boolean]
  def supports_expression_index?; end

  # @return [Boolean]
  def supports_extensions?; end

  # @return [Boolean]
  def supports_foreign_keys?; end

  # @return [Boolean]
  def supports_foreign_tables?; end

  # @return [Boolean]
  def supports_index_sort_order?; end

  # @return [Boolean]
  def supports_insert_conflict_target?; end

  # @return [Boolean]
  def supports_insert_on_conflict?; end

  # @return [Boolean]
  def supports_insert_on_duplicate_skip?; end

  # @return [Boolean]
  def supports_insert_on_duplicate_update?; end

  # @return [Boolean]
  def supports_insert_returning?; end

  # @return [Boolean]
  def supports_json?; end

  # @return [Boolean]
  def supports_lazy_transactions?; end

  # @return [Boolean]
  def supports_materialized_views?; end

  # @return [Boolean]
  def supports_optimizer_hints?; end

  # @return [Boolean]
  def supports_partial_index?; end

  # @return [Boolean]
  def supports_partitioned_indexes?; end

  # @return [Boolean]
  def supports_pgcrypto_uuid?; end

  # @return [Boolean]
  def supports_savepoints?; end

  # @return [Boolean]
  def supports_transaction_isolation?; end

  # @return [Boolean]
  def supports_validate_constraints?; end

  # @return [Boolean]
  def supports_views?; end

  # @return [Boolean]
  def use_insert_returning?; end

  private

  def add_pg_decoders; end
  def add_pg_encoders; end
  def arel_visitor; end
  def build_statement_pool; end

  # @return [Boolean]
  def can_perform_case_insensitive_comparison_for?(column); end

  # Returns the list of a table's column names, data types, and default values.
  #
  # The underlying query is roughly:
  #  SELECT column.name, column.type, default.value, column.comment
  #    FROM column LEFT JOIN default
  #      ON column.table_id = default.table_id
  #     AND column.num = default.column_num
  #   WHERE column.table_id = get_table_id('table_name')
  #     AND column.num > 0
  #     AND NOT column.is_dropped
  #   ORDER BY column.num
  #
  # If the table name is not prefixed with a schema, the database will
  # take the first match from the schema search path.
  #
  # Query implementation notes:
  #  - format_type includes the column size constraint, e.g. varchar(50)
  #  - ::regclass is a function that gives the id for a table name
  def column_definitions(table_name); end

  # Configures the encoding, verbosity, schema search path, and time zone of the connection.
  # This is called by #connect and should not be called manually.
  def configure_connection; end

  # Connects to a PostgreSQL server and sets up the adapter depending on the
  # connected server's characteristics.
  def connect; end

  def construct_coder(row, coder_class); end
  def exec_cache(sql, name, binds); end
  def exec_no_cache(sql, name, binds); end
  def execute_and_clear(sql, name, binds, prepare: T.unsafe(nil)); end
  def extract_default_function(default_value, default); end
  def extract_table_ref_from_insert_sql(sql); end

  # Extracts the value from a PostgreSQL column default definition.
  def extract_value_from_default(default); end

  def get_oid_type(oid, fmod, column_name, sql_type = T.unsafe(nil)); end

  # @return [Boolean]
  def has_default_function?(default_value, default); end

  # @return [Boolean]
  def in_transaction?; end

  def initialize_type_map(m = T.unsafe(nil)); end

  # Annoyingly, the code for prepared statements whose return value may
  # have changed is FEATURE_NOT_SUPPORTED.
  #
  # This covers various different error types so we need to do additional
  # work to classify the exception definitively as a
  # ActiveRecord::PreparedStatementCacheExpired
  #
  # Check here for more details:
  # https://git.postgresql.org/gitweb/?p=postgresql.git;a=blob;f=src/backend/utils/cache/plancache.c#l573
  #
  # @return [Boolean]
  def is_cached_plan_failure?(e); end

  def load_additional_types(oids = T.unsafe(nil)); end

  # Prepare the statement if it hasn't been prepared, return
  # the statement key.
  def prepare_statement(sql, binds); end

  # Returns the statement identifier for the client side cache
  # of statements
  def sql_key(sql); end

  def translate_exception(exception, message:, sql:, binds:); end
  def update_typemap_for_default_timezone; end

  class << self
    def create_unlogged_tables; end
    def create_unlogged_tables=(value); end
    def create_unlogged_tables?; end

    # @return [Boolean]
    def database_exists?(config); end

    def new_client(conn_params); end
  end
end

ActiveRecord::ConnectionAdapters::PostgreSQLAdapter::ADAPTER_NAME = T.let(T.unsafe(nil), String)
ActiveRecord::ConnectionAdapters::PostgreSQLAdapter::DEADLOCK_DETECTED = T.let(T.unsafe(nil), String)
ActiveRecord::ConnectionAdapters::PostgreSQLAdapter::DUPLICATE_DATABASE = T.let(T.unsafe(nil), String)
ActiveRecord::ConnectionAdapters::PostgreSQLAdapter::FEATURE_NOT_SUPPORTED = T.let(T.unsafe(nil), String)
ActiveRecord::ConnectionAdapters::PostgreSQLAdapter::FOREIGN_KEY_VIOLATION = T.let(T.unsafe(nil), String)
ActiveRecord::ConnectionAdapters::PostgreSQLAdapter::LOCK_NOT_AVAILABLE = T.let(T.unsafe(nil), String)

class ActiveRecord::ConnectionAdapters::PostgreSQLAdapter::MoneyDecoder < ::PG::SimpleDecoder
  def decode(value, tuple = T.unsafe(nil), field = T.unsafe(nil)); end
end

ActiveRecord::ConnectionAdapters::PostgreSQLAdapter::MoneyDecoder::TYPE = T.let(T.unsafe(nil), ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Money)
ActiveRecord::ConnectionAdapters::PostgreSQLAdapter::NATIVE_DATABASE_TYPES = T.let(T.unsafe(nil), Hash)
ActiveRecord::ConnectionAdapters::PostgreSQLAdapter::NOT_NULL_VIOLATION = T.let(T.unsafe(nil), String)
ActiveRecord::ConnectionAdapters::PostgreSQLAdapter::NUMERIC_VALUE_OUT_OF_RANGE = T.let(T.unsafe(nil), String)
ActiveRecord::ConnectionAdapters::PostgreSQLAdapter::OID = ActiveRecord::ConnectionAdapters::PostgreSQL::OID
ActiveRecord::ConnectionAdapters::PostgreSQLAdapter::QUERY_CANCELED = T.let(T.unsafe(nil), String)
ActiveRecord::ConnectionAdapters::PostgreSQLAdapter::SERIALIZATION_FAILURE = T.let(T.unsafe(nil), String)

class ActiveRecord::ConnectionAdapters::PostgreSQLAdapter::StatementPool < ::ActiveRecord::ConnectionAdapters::StatementPool
  # @return [StatementPool] a new instance of StatementPool
  def initialize(connection, max); end

  def next_key; end

  private

  # @return [Boolean]
  def connection_active?; end

  def dealloc(key); end
end

ActiveRecord::ConnectionAdapters::PostgreSQLAdapter::UNIQUE_VIOLATION = T.let(T.unsafe(nil), String)

# See https://www.postgresql.org/docs/current/static/errcodes-appendix.html
ActiveRecord::ConnectionAdapters::PostgreSQLAdapter::VALUE_LIMIT_VIOLATION = T.let(T.unsafe(nil), String)

ActiveRecord::ConnectionAdapters::PostgreSQLColumn = ActiveRecord::ConnectionAdapters::PostgreSQL::Column
ActiveRecord::ConnectionAdapters::PostgreSQLTypeMetadata = ActiveRecord::ConnectionAdapters::PostgreSQL::TypeMetadata

class ActiveRecord::ConnectionAdapters::PrimaryKeyDefinition < ::Struct
  # Returns the value of attribute name
  #
  # @return [Object] the current value of name
  def name; end

  # Sets the attribute name
  #
  # @param value [Object] the value to set the attribute name to.
  # @return [Object] the newly set value
  def name=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def members; end
    def new(*_arg0); end
  end
end

module ActiveRecord::ConnectionAdapters::QueryCache
  def initialize(*_arg0); end

  # Enable the query cache within the block.
  def cache; end

  # Clears the query cache.
  #
  # One reason you may wish to call this method explicitly is between queries
  # that ask the database to randomize results. Otherwise the cache would see
  # the same SQL query and repeatedly return the same result each time, silently
  # undermining the randomness you were expecting.
  def clear_query_cache; end

  def disable_query_cache!; end
  def enable_query_cache!; end

  # Returns the value of attribute query_cache.
  def query_cache; end

  # Returns the value of attribute query_cache_enabled.
  def query_cache_enabled; end

  def select_all(arel, name = T.unsafe(nil), binds = T.unsafe(nil), preparable: T.unsafe(nil)); end

  # Disable the query cache within the block.
  def uncached; end

  private

  # Database adapters can override this method to
  # provide custom cache information.
  def cache_notification_info(sql, name, binds); end

  def cache_sql(sql, name, binds); end
  def configure_query_cache!; end

  # If arel is locked this is a SELECT ... FOR UPDATE or somesuch. Such
  # queries should not be cached.
  #
  # @return [Boolean]
  def locked?(arel); end

  class << self
    def dirties_query_cache(base, *method_names); end
    def included(base); end
  end
end

module ActiveRecord::ConnectionAdapters::QueryCache::ConnectionPoolConfiguration
  def initialize(*_arg0); end

  def disable_query_cache!; end
  def enable_query_cache!; end
  def query_cache_enabled; end
end

module ActiveRecord::ConnectionAdapters::Quoting
  def column_name_matcher; end
  def column_name_with_order_matcher; end

  # If you are having to call this function, you are likely doing something
  # wrong. The column does not have sufficient type information if the user
  # provided a custom type on the class level either explicitly (via
  # Attributes::ClassMethods#attribute) or implicitly (via
  # AttributeMethods::Serialization::ClassMethods#serialize, +time_zone_aware_attributes+).
  # In almost all cases, the sql type should only be used to change quoting behavior, when the primitive to
  # represent the type doesn't sufficiently reflect the differences
  # (varchar vs binary) for example. The type used to get this primitive
  # should have been provided before reaching the connection adapter.
  def lookup_cast_type_from_column(column); end

  # Quotes the column value to help prevent
  # {SQL injection attacks}[https://en.wikipedia.org/wiki/SQL_injection].
  def quote(value); end

  # Quotes the column name. Defaults to no quoting.
  def quote_column_name(column_name); end

  def quote_default_expression(value, column); end

  # Quotes a string, escaping any ' (single quote) and \ (backslash)
  # characters.
  def quote_string(s); end

  # Quotes the table name. Defaults to column name quoting.
  def quote_table_name(table_name); end

  # Override to return the quoted table name for assignment. Defaults to
  # table quoting.
  #
  # This works for mysql2 where table.column can be used to
  # resolve ambiguity.
  #
  # We override this in the sqlite3 and postgresql adapters to use only
  # the column name (as per syntax requirements).
  def quote_table_name_for_assignment(table, attr); end

  def quoted_binary(value); end

  # Quote date/time values for use in SQL input. Includes microseconds
  # if the value is a Time responding to usec.
  def quoted_date(value); end

  def quoted_false; end
  def quoted_time(value); end
  def quoted_true; end
  def sanitize_as_sql_comment(value); end

  # Cast a +value+ to a type that the database understands. For example,
  # SQLite does not understand dates, so this method will convert a Date
  # to a String.
  def type_cast(value, column = T.unsafe(nil)); end

  def unquoted_false; end
  def unquoted_true; end

  private

  def _quote(value); end
  def _type_cast(value); end
  def lookup_cast_type(sql_type); end
  def type_casted_binds(binds); end
end

# Regexp for column names (with or without a table name prefix).
# Matches the following:
#
#   "#{table_name}.#{column_name}"
#   "#{column_name}"
ActiveRecord::ConnectionAdapters::Quoting::COLUMN_NAME = T.let(T.unsafe(nil), Regexp)

# Regexp for column names with order (with or without a table name prefix,
# with or without various order modifiers). Matches the following:
#
#   "#{table_name}.#{column_name}"
#   "#{table_name}.#{column_name} #{direction}"
#   "#{table_name}.#{column_name} #{direction} NULLS FIRST"
#   "#{table_name}.#{column_name} NULLS LAST"
#   "#{column_name}"
#   "#{column_name} #{direction}"
#   "#{column_name} #{direction} NULLS FIRST"
#   "#{column_name} NULLS LAST"
ActiveRecord::ConnectionAdapters::Quoting::COLUMN_NAME_WITH_ORDER = T.let(T.unsafe(nil), Regexp)

class ActiveRecord::ConnectionAdapters::RealTransaction < ::ActiveRecord::ConnectionAdapters::Transaction
  def commit; end
  def materialize!; end
  def rollback; end
end

class ActiveRecord::ConnectionAdapters::ReferenceDefinition
  # @return [ReferenceDefinition] a new instance of ReferenceDefinition
  def initialize(name, polymorphic: T.unsafe(nil), index: T.unsafe(nil), foreign_key: T.unsafe(nil), type: T.unsafe(nil), **options); end

  def add_to(table); end

  private

  def as_options(value); end
  def column_name; end
  def column_names; end
  def columns; end

  # Returns the value of attribute foreign_key.
  def foreign_key; end

  def foreign_key_options; end
  def foreign_table_name; end

  # Returns the value of attribute index.
  def index; end

  def index_options(table_name); end

  # Returns the value of attribute name.
  def name; end

  # Returns the value of attribute options.
  def options; end

  # Returns the value of attribute polymorphic.
  def polymorphic; end

  def polymorphic_index_name(table_name); end
  def polymorphic_options; end

  # Returns the value of attribute type.
  def type; end
end

class ActiveRecord::ConnectionAdapters::SavepointTransaction < ::ActiveRecord::ConnectionAdapters::Transaction
  # @return [SavepointTransaction] a new instance of SavepointTransaction
  def initialize(connection, savepoint_name, parent_transaction, **options); end

  def commit; end

  # @return [Boolean]
  def full_rollback?; end

  def materialize!; end
  def rollback; end
end

module ActiveRecord::ConnectionAdapters::Savepoints
  def create_savepoint(name = T.unsafe(nil)); end
  def current_savepoint_name; end
  def exec_rollback_to_savepoint(name = T.unsafe(nil)); end
  def release_savepoint(name = T.unsafe(nil)); end
end

class ActiveRecord::ConnectionAdapters::SchemaCache
  # @return [SchemaCache] a new instance of SchemaCache
  def initialize(conn); end

  # Add internal cache for table with +table_name+.
  def add(table_name); end

  # Clears out internal caches
  def clear!; end

  # Clear out internal caches for the data source +name+.
  def clear_data_source_cache!(name); end

  # Get the columns for a table
  def columns(table_name); end

  # Get the columns for a table as a hash, key is the column name
  # value is the column object.
  def columns_hash(table_name); end

  # Checks whether the columns hash is already cached for a table.
  #
  # @return [Boolean]
  def columns_hash?(table_name); end

  # Returns the value of attribute connection.
  def connection; end

  # Sets the attribute connection
  #
  # @param value the value to set the attribute connection to.
  def connection=(_arg0); end

  # A cached lookup for table existence.
  #
  # @return [Boolean]
  def data_source_exists?(name); end

  def data_sources(name); end
  def database_version; end
  def dump_to(filename); end
  def encode_with(coder); end
  def indexes(table_name); end
  def init_with(coder); end
  def marshal_dump; end
  def marshal_load(array); end
  def primary_keys(table_name); end
  def size; end

  # Returns the value of attribute version.
  def version; end

  private

  def deep_deduplicate(value); end
  def derive_columns_hash_and_deduplicate_values; end
  def initialize_dup(other); end
  def open(filename); end
  def prepare_data_sources; end
  def reset_version!; end

  class << self
    def load_from(filename); end

    private

    def read(filename, &block); end
  end
end

class ActiveRecord::ConnectionAdapters::SchemaCreation
  # @return [SchemaCreation] a new instance of SchemaCreation
  def initialize(conn); end

  def accept(o); end

  private

  def action_sql(action, dependency); end
  def add_column_options!(sql, options); end
  def add_table_options!(create_sql, o); end
  def check_constraint_in_create(table_name, expression, options); end
  def check_constraint_options(*_arg0, &_arg1); end
  def column_options(o); end
  def foreign_key_in_create(from_table, to_table, options); end
  def foreign_key_options(*_arg0, &_arg1); end
  def options_include_default?(*_arg0, &_arg1); end
  def quote_column_name(*_arg0, &_arg1); end
  def quote_default_expression(*_arg0, &_arg1); end
  def quote_table_name(*_arg0, &_arg1); end
  def quoted_columns(o); end
  def quoted_columns_for_index(*_arg0, &_arg1); end
  def supports_check_constraints?(*_arg0, &_arg1); end
  def supports_foreign_keys?(*_arg0, &_arg1); end

  # @return [Boolean]
  def supports_index_using?; end

  def supports_indexes_in_create?(*_arg0, &_arg1); end
  def supports_partial_index?(*_arg0, &_arg1); end

  # Returns any SQL string to go between CREATE and TABLE. May be nil.
  def table_modifier_in_create(o); end

  def to_sql(sql); end
  def type_to_sql(*_arg0, &_arg1); end
  def visit_AddCheckConstraint(o); end
  def visit_AddColumnDefinition(o); end
  def visit_AddForeignKey(o); end
  def visit_AlterTable(o); end
  def visit_CheckConstraintDefinition(o); end
  def visit_ColumnDefinition(o); end
  def visit_CreateIndexDefinition(o); end
  def visit_DropCheckConstraint(name); end
  def visit_DropForeignKey(name); end
  def visit_ForeignKeyDefinition(o); end
  def visit_PrimaryKeyDefinition(o); end
  def visit_TableDefinition(o); end
end

class ActiveRecord::ConnectionAdapters::SchemaDumper < ::ActiveRecord::SchemaDumper
  private

  def column_spec(column); end
  def column_spec_for_primary_key(column); end

  # @return [Boolean]
  def default_primary_key?(column); end

  # @return [Boolean]
  def explicit_primary_key_default?(column); end

  def prepare_column_options(column); end
  def schema_collation(column); end
  def schema_default(column); end
  def schema_expression(column); end
  def schema_limit(column); end
  def schema_precision(column); end
  def schema_scale(column); end
  def schema_type(column); end
  def schema_type_with_virtual(column); end

  class << self
    def create(connection, options); end
  end
end

module ActiveRecord::ConnectionAdapters::SchemaStatements
  include ::ActiveRecord::Migration::JoinTable

  # Adds a reference. The reference column is a bigint by default,
  # the <tt>:type</tt> option can be used to specify a different type.
  # Optionally adds a +_type+ column, if <tt>:polymorphic</tt> option is provided.
  # #add_reference and #add_belongs_to are acceptable.
  #
  # The +options+ hash can include the following keys:
  # [<tt>:type</tt>]
  #   The reference column type. Defaults to +:bigint+.
  # [<tt>:index</tt>]
  #   Add an appropriate index. Defaults to true.
  #   See #add_index for usage of this option.
  # [<tt>:foreign_key</tt>]
  #   Add an appropriate foreign key constraint. Defaults to false, pass true
  #   to add. In case the join table can't be inferred from the association
  #   pass <tt>:to_table</tt> with the appropriate table name.
  # [<tt>:polymorphic</tt>]
  #   Whether an additional +_type+ column should be added. Defaults to false.
  # [<tt>:null</tt>]
  #   Whether the column allows nulls. Defaults to true.
  #
  # ====== Create a user_id bigint column without an index
  #
  #   add_reference(:products, :user, index: false)
  #
  # ====== Create a user_id string column
  #
  #   add_reference(:products, :user, type: :string)
  #
  # ====== Create supplier_id, supplier_type columns
  #
  #   add_reference(:products, :supplier, polymorphic: true)
  #
  # ====== Create a supplier_id column with a unique index
  #
  #   add_reference(:products, :supplier, index: { unique: true })
  #
  # ====== Create a supplier_id column with a named index
  #
  #   add_reference(:products, :supplier, index: { name: "my_supplier_index" })
  #
  # ====== Create a supplier_id column and appropriate foreign key
  #
  #   add_reference(:products, :supplier, foreign_key: true)
  #
  # ====== Create a supplier_id column and a foreign key to the firms table
  #
  #   add_reference(:products, :supplier, foreign_key: { to_table: :firms })
  def add_belongs_to(table_name, ref_name, **options); end

  # Adds a new check constraint to the table. +expression+ is a String
  # representation of verifiable boolean condition.
  #
  #   add_check_constraint :products, "price > 0", name: "price_check"
  #
  # generates:
  #
  #   ALTER TABLE "products" ADD CONSTRAINT price_check CHECK (price > 0)
  #
  # The +options+ hash can include the following keys:
  # [<tt>:name</tt>]
  #   The constraint name. Defaults to <tt>chk_rails_<identifier></tt>.
  # [<tt>:validate</tt>]
  #   (PostgreSQL only) Specify whether or not the constraint should be validated. Defaults to +true+.
  def add_check_constraint(table_name, expression, **options); end

  # Add a new +type+ column named +column_name+ to +table_name+.
  #
  # The +type+ parameter is normally one of the migrations native types,
  # which is one of the following:
  # <tt>:primary_key</tt>, <tt>:string</tt>, <tt>:text</tt>,
  # <tt>:integer</tt>, <tt>:bigint</tt>, <tt>:float</tt>, <tt>:decimal</tt>, <tt>:numeric</tt>,
  # <tt>:datetime</tt>, <tt>:time</tt>, <tt>:date</tt>,
  # <tt>:binary</tt>, <tt>:boolean</tt>.
  #
  # You may use a type not in this list as long as it is supported by your
  # database (for example, "polygon" in MySQL), but this will not be database
  # agnostic and should usually be avoided.
  #
  # Available options are (none of these exists by default):
  # * <tt>:limit</tt> -
  #   Requests a maximum column length. This is the number of characters for a <tt>:string</tt> column
  #   and number of bytes for <tt>:text</tt>, <tt>:binary</tt>, and <tt>:integer</tt> columns.
  #   This option is ignored by some backends.
  # * <tt>:default</tt> -
  #   The column's default value. Use +nil+ for +NULL+.
  # * <tt>:null</tt> -
  #   Allows or disallows +NULL+ values in the column.
  # * <tt>:precision</tt> -
  #   Specifies the precision for the <tt>:decimal</tt>, <tt>:numeric</tt>,
  #   <tt>:datetime</tt>, and <tt>:time</tt> columns.
  # * <tt>:scale</tt> -
  #   Specifies the scale for the <tt>:decimal</tt> and <tt>:numeric</tt> columns.
  # * <tt>:collation</tt> -
  #   Specifies the collation for a <tt>:string</tt> or <tt>:text</tt> column. If not specified, the
  #   column will have the same collation as the table.
  # * <tt>:comment</tt> -
  #   Specifies the comment for the column. This option is ignored by some backends.
  # * <tt>:if_not_exists</tt> -
  #   Specifies if the column already exists to not try to re-add it. This will avoid
  #   duplicate column errors.
  #
  # Note: The precision is the total number of significant digits,
  # and the scale is the number of digits that can be stored following
  # the decimal point. For example, the number 123.45 has a precision of 5
  # and a scale of 2. A decimal with a precision of 5 and a scale of 2 can
  # range from -999.99 to 999.99.
  #
  # Please be aware of different RDBMS implementations behavior with
  # <tt>:decimal</tt> columns:
  # * The SQL standard says the default scale should be 0, <tt>:scale</tt> <=
  #   <tt>:precision</tt>, and makes no comments about the requirements of
  #   <tt>:precision</tt>.
  # * MySQL: <tt>:precision</tt> [1..63], <tt>:scale</tt> [0..30].
  #   Default is (10,0).
  # * PostgreSQL: <tt>:precision</tt> [1..infinity],
  #   <tt>:scale</tt> [0..infinity]. No default.
  # * SQLite3: No restrictions on <tt>:precision</tt> and <tt>:scale</tt>,
  #   but the maximum supported <tt>:precision</tt> is 16. No default.
  # * Oracle: <tt>:precision</tt> [1..38], <tt>:scale</tt> [-84..127].
  #   Default is (38,0).
  # * SqlServer: <tt>:precision</tt> [1..38], <tt>:scale</tt> [0..38].
  #   Default (38,0).
  #
  # == Examples
  #
  #  add_column(:users, :picture, :binary, limit: 2.megabytes)
  #  # ALTER TABLE "users" ADD "picture" blob(2097152)
  #
  #  add_column(:articles, :status, :string, limit: 20, default: 'draft', null: false)
  #  # ALTER TABLE "articles" ADD "status" varchar(20) DEFAULT 'draft' NOT NULL
  #
  #  add_column(:answers, :bill_gates_money, :decimal, precision: 15, scale: 2)
  #  # ALTER TABLE "answers" ADD "bill_gates_money" decimal(15,2)
  #
  #  add_column(:measurements, :sensor_reading, :decimal, precision: 30, scale: 20)
  #  # ALTER TABLE "measurements" ADD "sensor_reading" decimal(30,20)
  #
  #  # While :scale defaults to zero on most databases, it
  #  # probably wouldn't hurt to include it.
  #  add_column(:measurements, :huge_integer, :decimal, precision: 30)
  #  # ALTER TABLE "measurements" ADD "huge_integer" decimal(30)
  #
  #  # Defines a column that stores an array of a type.
  #  add_column(:users, :skills, :text, array: true)
  #  # ALTER TABLE "users" ADD "skills" text[]
  #
  #  # Defines a column with a database-specific type.
  #  add_column(:shapes, :triangle, 'polygon')
  #  # ALTER TABLE "shapes" ADD "triangle" polygon
  #
  #  # Ignores the method call if the column exists
  #  add_column(:shapes, :triangle, 'polygon', if_not_exists: true)
  def add_column(table_name, column_name, type, **options); end

  def add_columns(table_name, *column_names, type:, **options); end

  # Adds a new foreign key. +from_table+ is the table with the key column,
  # +to_table+ contains the referenced primary key.
  #
  # The foreign key will be named after the following pattern: <tt>fk_rails_<identifier></tt>.
  # +identifier+ is a 10 character long string which is deterministically generated from the
  # +from_table+ and +column+. A custom name can be specified with the <tt>:name</tt> option.
  #
  # ====== Creating a simple foreign key
  #
  #   add_foreign_key :articles, :authors
  #
  # generates:
  #
  #   ALTER TABLE "articles" ADD CONSTRAINT fk_rails_e74ce85cbc FOREIGN KEY ("author_id") REFERENCES "authors" ("id")
  #
  # ====== Creating a foreign key on a specific column
  #
  #   add_foreign_key :articles, :users, column: :author_id, primary_key: "lng_id"
  #
  # generates:
  #
  #   ALTER TABLE "articles" ADD CONSTRAINT fk_rails_58ca3d3a82 FOREIGN KEY ("author_id") REFERENCES "users" ("lng_id")
  #
  # ====== Creating a cascading foreign key
  #
  #   add_foreign_key :articles, :authors, on_delete: :cascade
  #
  # generates:
  #
  #   ALTER TABLE "articles" ADD CONSTRAINT fk_rails_e74ce85cbc FOREIGN KEY ("author_id") REFERENCES "authors" ("id") ON DELETE CASCADE
  #
  # The +options+ hash can include the following keys:
  # [<tt>:column</tt>]
  #   The foreign key column name on +from_table+. Defaults to <tt>to_table.singularize + "_id"</tt>
  # [<tt>:primary_key</tt>]
  #   The primary key column name on +to_table+. Defaults to +id+.
  # [<tt>:name</tt>]
  #   The constraint name. Defaults to <tt>fk_rails_<identifier></tt>.
  # [<tt>:on_delete</tt>]
  #   Action that happens <tt>ON DELETE</tt>. Valid values are +:nullify+, +:cascade+ and +:restrict+
  # [<tt>:on_update</tt>]
  #   Action that happens <tt>ON UPDATE</tt>. Valid values are +:nullify+, +:cascade+ and +:restrict+
  # [<tt>:validate</tt>]
  #   (PostgreSQL only) Specify whether or not the constraint should be validated. Defaults to +true+.
  def add_foreign_key(from_table, to_table, **options); end

  # Adds a new index to the table. +column_name+ can be a single Symbol, or
  # an Array of Symbols.
  #
  # The index will be named after the table and the column name(s), unless
  # you pass <tt>:name</tt> as an option.
  #
  # ====== Creating a simple index
  #
  #   add_index(:suppliers, :name)
  #
  # generates:
  #
  #   CREATE INDEX index_suppliers_on_name ON suppliers(name)
  #
  # ====== Creating a index which already exists
  #
  #   add_index(:suppliers, :name, if_not_exists: true)
  #
  # generates:
  #
  #   CREATE INDEX IF NOT EXISTS index_suppliers_on_name ON suppliers(name)
  #
  # Note: Not supported by MySQL.
  #
  # ====== Creating a unique index
  #
  #   add_index(:accounts, [:branch_id, :party_id], unique: true)
  #
  # generates:
  #
  #   CREATE UNIQUE INDEX index_accounts_on_branch_id_and_party_id ON accounts(branch_id, party_id)
  #
  # ====== Creating a named index
  #
  #   add_index(:accounts, [:branch_id, :party_id], unique: true, name: 'by_branch_party')
  #
  # generates:
  #
  #  CREATE UNIQUE INDEX by_branch_party ON accounts(branch_id, party_id)
  #
  # ====== Creating an index with specific key length
  #
  #   add_index(:accounts, :name, name: 'by_name', length: 10)
  #
  # generates:
  #
  #   CREATE INDEX by_name ON accounts(name(10))
  #
  # ====== Creating an index with specific key lengths for multiple keys
  #
  #   add_index(:accounts, [:name, :surname], name: 'by_name_surname', length: {name: 10, surname: 15})
  #
  # generates:
  #
  #   CREATE INDEX by_name_surname ON accounts(name(10), surname(15))
  #
  # Note: SQLite doesn't support index length.
  #
  # ====== Creating an index with a sort order (desc or asc, asc is the default)
  #
  #   add_index(:accounts, [:branch_id, :party_id, :surname], name: 'by_branch_desc_party', order: {branch_id: :desc, party_id: :asc})
  #
  # generates:
  #
  #   CREATE INDEX by_branch_desc_party ON accounts(branch_id DESC, party_id ASC, surname)
  #
  # Note: MySQL only supports index order from 8.0.1 onwards (earlier versions accepted the syntax but ignored it).
  #
  # ====== Creating a partial index
  #
  #   add_index(:accounts, [:branch_id, :party_id], unique: true, where: "active")
  #
  # generates:
  #
  #   CREATE UNIQUE INDEX index_accounts_on_branch_id_and_party_id ON accounts(branch_id, party_id) WHERE active
  #
  # Note: Partial indexes are only supported for PostgreSQL and SQLite.
  #
  # ====== Creating an index with a specific method
  #
  #   add_index(:developers, :name, using: 'btree')
  #
  # generates:
  #
  #   CREATE INDEX index_developers_on_name ON developers USING btree (name) -- PostgreSQL
  #   CREATE INDEX index_developers_on_name USING btree ON developers (name) -- MySQL
  #
  # Note: only supported by PostgreSQL and MySQL
  #
  # ====== Creating an index with a specific operator class
  #
  #   add_index(:developers, :name, using: 'gist', opclass: :gist_trgm_ops)
  #   # CREATE INDEX developers_on_name ON developers USING gist (name gist_trgm_ops) -- PostgreSQL
  #
  #   add_index(:developers, [:name, :city], using: 'gist', opclass: { city: :gist_trgm_ops })
  #   # CREATE INDEX developers_on_name_and_city ON developers USING gist (name, city gist_trgm_ops) -- PostgreSQL
  #
  #   add_index(:developers, [:name, :city], using: 'gist', opclass: :gist_trgm_ops)
  #   # CREATE INDEX developers_on_name_and_city ON developers USING gist (name gist_trgm_ops, city gist_trgm_ops) -- PostgreSQL
  #
  # Note: only supported by PostgreSQL
  #
  # ====== Creating an index with a specific type
  #
  #   add_index(:developers, :name, type: :fulltext)
  #
  # generates:
  #
  #   CREATE FULLTEXT INDEX index_developers_on_name ON developers (name) -- MySQL
  #
  # Note: only supported by MySQL.
  #
  # ====== Creating an index with a specific algorithm
  #
  #  add_index(:developers, :name, algorithm: :concurrently)
  #  # CREATE INDEX CONCURRENTLY developers_on_name on developers (name)
  #
  # Note: only supported by PostgreSQL.
  #
  # Concurrently adding an index is not supported in a transaction.
  #
  # For more information see the {"Transactional Migrations" section}[rdoc-ref:Migration].
  def add_index(table_name, column_name, **options); end

  def add_index_options(table_name, column_name, name: T.unsafe(nil), if_not_exists: T.unsafe(nil), internal: T.unsafe(nil), **options); end

  # Adds a reference. The reference column is a bigint by default,
  # the <tt>:type</tt> option can be used to specify a different type.
  # Optionally adds a +_type+ column, if <tt>:polymorphic</tt> option is provided.
  # #add_reference and #add_belongs_to are acceptable.
  #
  # The +options+ hash can include the following keys:
  # [<tt>:type</tt>]
  #   The reference column type. Defaults to +:bigint+.
  # [<tt>:index</tt>]
  #   Add an appropriate index. Defaults to true.
  #   See #add_index for usage of this option.
  # [<tt>:foreign_key</tt>]
  #   Add an appropriate foreign key constraint. Defaults to false, pass true
  #   to add. In case the join table can't be inferred from the association
  #   pass <tt>:to_table</tt> with the appropriate table name.
  # [<tt>:polymorphic</tt>]
  #   Whether an additional +_type+ column should be added. Defaults to false.
  # [<tt>:null</tt>]
  #   Whether the column allows nulls. Defaults to true.
  #
  # ====== Create a user_id bigint column without an index
  #
  #   add_reference(:products, :user, index: false)
  #
  # ====== Create a user_id string column
  #
  #   add_reference(:products, :user, type: :string)
  #
  # ====== Create supplier_id, supplier_type columns
  #
  #   add_reference(:products, :supplier, polymorphic: true)
  #
  # ====== Create a supplier_id column with a unique index
  #
  #   add_reference(:products, :supplier, index: { unique: true })
  #
  # ====== Create a supplier_id column with a named index
  #
  #   add_reference(:products, :supplier, index: { name: "my_supplier_index" })
  #
  # ====== Create a supplier_id column and appropriate foreign key
  #
  #   add_reference(:products, :supplier, foreign_key: true)
  #
  # ====== Create a supplier_id column and a foreign key to the firms table
  #
  #   add_reference(:products, :supplier, foreign_key: { to_table: :firms })
  def add_reference(table_name, ref_name, **options); end

  # Adds timestamps (+created_at+ and +updated_at+) columns to +table_name+.
  # Additional options (like +:null+) are forwarded to #add_column.
  #
  #   add_timestamps(:suppliers, null: true)
  def add_timestamps(table_name, **options); end

  def assume_migrated_upto_version(version); end

  # Changes the column's definition according to the new options.
  # See TableDefinition#column for details of the options you can use.
  #
  #   change_column(:suppliers, :name, :string, limit: 80)
  #   change_column(:accounts, :description, :text)
  #
  # @raise [NotImplementedError]
  def change_column(table_name, column_name, type, **options); end

  # Changes the comment for a column or removes it if +nil+.
  #
  # Passing a hash containing +:from+ and +:to+ will make this change
  # reversible in migration:
  #
  #   change_column_comment(:posts, :state, from: "old_comment", to: "new_comment")
  #
  # @raise [NotImplementedError]
  def change_column_comment(table_name, column_name, comment_or_changes); end

  # Sets a new default value for a column:
  #
  #   change_column_default(:suppliers, :qualification, 'new')
  #   change_column_default(:accounts, :authorized, 1)
  #
  # Setting the default to +nil+ effectively drops the default:
  #
  #   change_column_default(:users, :email, nil)
  #
  # Passing a hash containing +:from+ and +:to+ will make this change
  # reversible in migration:
  #
  #   change_column_default(:posts, :state, from: nil, to: "draft")
  #
  # @raise [NotImplementedError]
  def change_column_default(table_name, column_name, default_or_changes); end

  # Sets or removes a <tt>NOT NULL</tt> constraint on a column. The +null+ flag
  # indicates whether the value can be +NULL+. For example
  #
  #   change_column_null(:users, :nickname, false)
  #
  # says nicknames cannot be +NULL+ (adds the constraint), whereas
  #
  #   change_column_null(:users, :nickname, true)
  #
  # allows them to be +NULL+ (drops the constraint).
  #
  # The method accepts an optional fourth argument to replace existing
  # <tt>NULL</tt>s with some other value. Use that one when enabling the
  # constraint if needed, since otherwise those rows would not be valid.
  #
  # Please note the fourth argument does not set a column's default.
  #
  # @raise [NotImplementedError]
  def change_column_null(table_name, column_name, null, default = T.unsafe(nil)); end

  # A block for changing columns in +table+.
  #
  #   # change_table() yields a Table instance
  #   change_table(:suppliers) do |t|
  #     t.column :name, :string, limit: 60
  #     # Other column alterations here
  #   end
  #
  # The +options+ hash can include the following keys:
  # [<tt>:bulk</tt>]
  #   Set this to true to make this a bulk alter query, such as
  #
  #     ALTER TABLE `users` ADD COLUMN age INT, ADD COLUMN birthdate DATETIME ...
  #
  #   Defaults to false.
  #
  #   Only supported on the MySQL and PostgreSQL adapter, ignored elsewhere.
  #
  # ====== Add a column
  #
  #   change_table(:suppliers) do |t|
  #     t.column :name, :string, limit: 60
  #   end
  #
  # ====== Change type of a column
  #
  #   change_table(:suppliers) do |t|
  #     t.change :metadata, :json
  #   end
  #
  # ====== Add 2 integer columns
  #
  #   change_table(:suppliers) do |t|
  #     t.integer :width, :height, null: false, default: 0
  #   end
  #
  # ====== Add created_at/updated_at columns
  #
  #   change_table(:suppliers) do |t|
  #     t.timestamps
  #   end
  #
  # ====== Add a foreign key column
  #
  #   change_table(:suppliers) do |t|
  #     t.references :company
  #   end
  #
  # Creates a <tt>company_id(bigint)</tt> column.
  #
  # ====== Add a polymorphic foreign key column
  #
  #  change_table(:suppliers) do |t|
  #    t.belongs_to :company, polymorphic: true
  #  end
  #
  # Creates <tt>company_type(varchar)</tt> and <tt>company_id(bigint)</tt> columns.
  #
  # ====== Remove a column
  #
  #  change_table(:suppliers) do |t|
  #    t.remove :company
  #  end
  #
  # ====== Remove several columns
  #
  #  change_table(:suppliers) do |t|
  #    t.remove :company_id
  #    t.remove :width, :height
  #  end
  #
  # ====== Remove an index
  #
  #  change_table(:suppliers) do |t|
  #    t.remove_index :company_id
  #  end
  #
  # See also Table for details on all of the various column transformations.
  def change_table(table_name, **options); end

  # Changes the comment for a table or removes it if +nil+.
  #
  # Passing a hash containing +:from+ and +:to+ will make this change
  # reversible in migration:
  #
  #   change_table_comment(:posts, from: "old_comment", to: "new_comment")
  #
  # @raise [NotImplementedError]
  def change_table_comment(table_name, comment_or_changes); end

  def check_constraint_options(table_name, expression, options); end

  # Returns an array of check constraints for the given table.
  # The check constraints are represented as CheckConstraintDefinition objects.
  #
  # @raise [NotImplementedError]
  def check_constraints(table_name); end

  # Checks to see if a column exists in a given table.
  #
  #   # Check a column exists
  #   column_exists?(:suppliers, :name)
  #
  #   # Check a column exists of a particular type
  #   column_exists?(:suppliers, :name, :string)
  #
  #   # Check a column exists with a specific definition
  #   column_exists?(:suppliers, :name, :string, limit: 100)
  #   column_exists?(:suppliers, :name, :string, default: 'default')
  #   column_exists?(:suppliers, :name, :string, null: false)
  #   column_exists?(:suppliers, :tax, :decimal, precision: 8, scale: 2)
  #
  # @return [Boolean]
  def column_exists?(table_name, column_name, type = T.unsafe(nil), **options); end

  # Returns an array of +Column+ objects for the table specified by +table_name+.
  def columns(table_name); end

  # Given a set of columns and an ORDER BY clause, returns the columns for a SELECT DISTINCT.
  # PostgreSQL, MySQL, and Oracle override this for custom DISTINCT syntax - they
  # require the order columns appear in the SELECT.
  #
  #   columns_for_distinct("posts.id", ["posts.created_at desc"])
  def columns_for_distinct(columns, orders); end

  # Creates a new join table with the name created using the lexical order of the first two
  # arguments. These arguments can be a String or a Symbol.
  #
  #   # Creates a table called 'assemblies_parts' with no id.
  #   create_join_table(:assemblies, :parts)
  #
  # You can pass an +options+ hash which can include the following keys:
  # [<tt>:table_name</tt>]
  #   Sets the table name, overriding the default.
  # [<tt>:column_options</tt>]
  #   Any extra options you want appended to the columns definition.
  # [<tt>:options</tt>]
  #   Any extra options you want appended to the table definition.
  # [<tt>:temporary</tt>]
  #   Make a temporary table.
  # [<tt>:force</tt>]
  #   Set to true to drop the table before creating it.
  #   Defaults to false.
  #
  # Note that #create_join_table does not create any indices by default; you can use
  # its block form to do so yourself:
  #
  #   create_join_table :products, :categories do |t|
  #     t.index :product_id
  #     t.index :category_id
  #   end
  #
  # ====== Add a backend specific option to the generated SQL (MySQL)
  #
  #   create_join_table(:assemblies, :parts, options: 'ENGINE=InnoDB DEFAULT CHARSET=utf8')
  #
  # generates:
  #
  #   CREATE TABLE assemblies_parts (
  #     assembly_id bigint NOT NULL,
  #     part_id bigint NOT NULL,
  #   ) ENGINE=InnoDB DEFAULT CHARSET=utf8
  def create_join_table(table_1, table_2, column_options: T.unsafe(nil), **options); end

  def create_schema_dumper(options); end

  # Creates a new table with the name +table_name+. +table_name+ may either
  # be a String or a Symbol.
  #
  # There are two ways to work with #create_table. You can use the block
  # form or the regular form, like this:
  #
  # === Block form
  #
  #   # create_table() passes a TableDefinition object to the block.
  #   # This form will not only create the table, but also columns for the
  #   # table.
  #
  #   create_table(:suppliers) do |t|
  #     t.column :name, :string, limit: 60
  #     # Other fields here
  #   end
  #
  # === Block form, with shorthand
  #
  #   # You can also use the column types as method calls, rather than calling the column method.
  #   create_table(:suppliers) do |t|
  #     t.string :name, limit: 60
  #     # Other fields here
  #   end
  #
  # === Regular form
  #
  #   # Creates a table called 'suppliers' with no columns.
  #   create_table(:suppliers)
  #   # Add a column to 'suppliers'.
  #   add_column(:suppliers, :name, :string, {limit: 60})
  #
  # The +options+ hash can include the following keys:
  # [<tt>:id</tt>]
  #   Whether to automatically add a primary key column. Defaults to true.
  #   Join tables for {ActiveRecord::Base.has_and_belongs_to_many}[rdoc-ref:Associations::ClassMethods#has_and_belongs_to_many] should set it to false.
  #
  #   A Symbol can be used to specify the type of the generated primary key column.
  # [<tt>:primary_key</tt>]
  #   The name of the primary key, if one is to be added automatically.
  #   Defaults to +id+. If <tt>:id</tt> is false, then this option is ignored.
  #
  #   If an array is passed, a composite primary key will be created.
  #
  #   Note that Active Record models will automatically detect their
  #   primary key. This can be avoided by using
  #   {self.primary_key=}[rdoc-ref:AttributeMethods::PrimaryKey::ClassMethods#primary_key=] on the model
  #   to define the key explicitly.
  #
  # [<tt>:options</tt>]
  #   Any extra options you want appended to the table definition.
  # [<tt>:temporary</tt>]
  #   Make a temporary table.
  # [<tt>:force</tt>]
  #   Set to true to drop the table before creating it.
  #   Set to +:cascade+ to drop dependent objects as well.
  #   Defaults to false.
  # [<tt>:if_not_exists</tt>]
  #   Set to true to avoid raising an error when the table already exists.
  #   Defaults to false.
  # [<tt>:as</tt>]
  #   SQL to use to generate the table. When this option is used, the block is
  #   ignored, as are the <tt>:id</tt> and <tt>:primary_key</tt> options.
  #
  # ====== Add a backend specific option to the generated SQL (MySQL)
  #
  #   create_table(:suppliers, options: 'ENGINE=InnoDB DEFAULT CHARSET=utf8mb4')
  #
  # generates:
  #
  #   CREATE TABLE suppliers (
  #     id bigint auto_increment PRIMARY KEY
  #   ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4
  #
  # ====== Rename the primary key column
  #
  #   create_table(:objects, primary_key: 'guid') do |t|
  #     t.column :name, :string, limit: 80
  #   end
  #
  # generates:
  #
  #   CREATE TABLE objects (
  #     guid bigint auto_increment PRIMARY KEY,
  #     name varchar(80)
  #   )
  #
  # ====== Change the primary key column type
  #
  #   create_table(:tags, id: :string) do |t|
  #     t.column :label, :string
  #   end
  #
  # generates:
  #
  #   CREATE TABLE tags (
  #     id varchar PRIMARY KEY,
  #     label varchar
  #   )
  #
  # ====== Create a composite primary key
  #
  #   create_table(:orders, primary_key: [:product_id, :client_id]) do |t|
  #     t.belongs_to :product
  #     t.belongs_to :client
  #   end
  #
  # generates:
  #
  #   CREATE TABLE order (
  #       product_id bigint NOT NULL,
  #       client_id bigint NOT NULL
  #   );
  #
  #   ALTER TABLE ONLY "orders"
  #     ADD CONSTRAINT orders_pkey PRIMARY KEY (product_id, client_id);
  #
  # ====== Do not add a primary key column
  #
  #   create_table(:categories_suppliers, id: false) do |t|
  #     t.column :category_id, :bigint
  #     t.column :supplier_id, :bigint
  #   end
  #
  # generates:
  #
  #   CREATE TABLE categories_suppliers (
  #     category_id bigint,
  #     supplier_id bigint
  #   )
  #
  # ====== Create a temporary table based on a query
  #
  #   create_table(:long_query, temporary: true,
  #     as: "SELECT * FROM orders INNER JOIN line_items ON order_id=orders.id")
  #
  # generates:
  #
  #   CREATE TEMPORARY TABLE long_query AS
  #     SELECT * FROM orders INNER JOIN line_items ON order_id=orders.id
  #
  # See also TableDefinition#column for details on how to create columns.
  #
  # @yield [td]
  def create_table(table_name, id: T.unsafe(nil), primary_key: T.unsafe(nil), force: T.unsafe(nil), **options); end

  # Checks to see if the data source +name+ exists on the database.
  #
  #   data_source_exists?(:ebooks)
  #
  # @return [Boolean]
  def data_source_exists?(name); end

  # Returns the relation names useable to back Active Record models.
  # For most adapters this means all #tables and #views.
  def data_sources; end

  # Drops the join table specified by the given arguments.
  # See #create_join_table for details.
  #
  # Although this command ignores the block if one is given, it can be helpful
  # to provide one in a migration's +change+ method so it can be reverted.
  # In that case, the block will be used by #create_join_table.
  def drop_join_table(table_1, table_2, **options); end

  # Drops a table from the database.
  #
  # [<tt>:force</tt>]
  #   Set to +:cascade+ to drop dependent objects as well.
  #   Defaults to false.
  # [<tt>:if_exists</tt>]
  #   Set to +true+ to only drop the table if it exists.
  #   Defaults to false.
  #
  # Although this command ignores most +options+ and the block if one is given,
  # it can be helpful to provide these in a migration's +change+ method so it can be reverted.
  # In that case, +options+ and the block will be used by #create_table.
  def drop_table(table_name, **options); end

  def dump_schema_information; end
  def foreign_key_column_for(table_name); end

  # Checks to see if a foreign key exists on a table for a given foreign key definition.
  #
  #   # Checks to see if a foreign key exists.
  #   foreign_key_exists?(:accounts, :branches)
  #
  #   # Checks to see if a foreign key on a specified column exists.
  #   foreign_key_exists?(:accounts, column: :owner_id)
  #
  #   # Checks to see if a foreign key with a custom name exists.
  #   foreign_key_exists?(:accounts, name: "special_fk_name")
  #
  # @return [Boolean]
  def foreign_key_exists?(from_table, to_table = T.unsafe(nil), **options); end

  def foreign_key_options(from_table, to_table, options); end

  # Returns an array of foreign keys for the given table.
  # The foreign keys are represented as ForeignKeyDefinition objects.
  #
  # @raise [NotImplementedError]
  def foreign_keys(table_name); end

  def index_algorithm(algorithm); end

  # Checks to see if an index exists on a table for a given index definition.
  #
  #   # Check an index exists
  #   index_exists?(:suppliers, :company_id)
  #
  #   # Check an index on multiple columns exists
  #   index_exists?(:suppliers, [:company_id, :company_type])
  #
  #   # Check a unique index exists
  #   index_exists?(:suppliers, :company_id, unique: true)
  #
  #   # Check an index with a custom name exists
  #   index_exists?(:suppliers, :company_id, name: "idx_company_id")
  #
  # @return [Boolean]
  def index_exists?(table_name, column_name, **options); end

  def index_name(table_name, options); end

  # Verifies the existence of an index with a given name.
  #
  # @return [Boolean]
  def index_name_exists?(table_name, index_name); end

  # Returns an array of indexes for the given table.
  #
  # @raise [NotImplementedError]
  def indexes(table_name); end

  def internal_string_options_for_primary_key; end

  # Returns a hash of mappings from the abstract data types to the native
  # database types. See TableDefinition#column for details on the recognized
  # abstract data types.
  def native_database_types; end

  # @return [Boolean]
  def options_include_default?(options); end

  # Returns just a table's primary key
  def primary_key(table_name); end

  def quoted_columns_for_index(column_names, options); end

  # Removes the reference(s). Also removes a +type+ column if one exists.
  # #remove_reference and #remove_belongs_to are acceptable.
  #
  # ====== Remove the reference
  #
  #   remove_reference(:products, :user, index: false)
  #
  # ====== Remove polymorphic reference
  #
  #   remove_reference(:products, :supplier, polymorphic: true)
  #
  # ====== Remove the reference with a foreign key
  #
  #   remove_reference(:products, :user, foreign_key: true)
  def remove_belongs_to(table_name, ref_name, foreign_key: T.unsafe(nil), polymorphic: T.unsafe(nil), **options); end

  # Removes the given check constraint from the table.
  #
  #   remove_check_constraint :products, name: "price_check"
  #
  # The +expression+ parameter will be ignored if present. It can be helpful
  # to provide this in a migration's +change+ method so it can be reverted.
  # In that case, +expression+ will be used by #add_check_constraint.
  def remove_check_constraint(table_name, expression = T.unsafe(nil), **options); end

  # Removes the column from the table definition.
  #
  #   remove_column(:suppliers, :qualification)
  #
  # The +type+ and +options+ parameters will be ignored if present. It can be helpful
  # to provide these in a migration's +change+ method so it can be reverted.
  # In that case, +type+ and +options+ will be used by #add_column.
  # Indexes on the column are automatically removed.
  #
  # If the options provided include an +if_exists+ key, it will be used to check if the
  # column does not exist. This will silently ignore the migration rather than raising
  # if the column was already used.
  #
  #   remove_column(:suppliers, :qualification, if_exists: true)
  def remove_column(table_name, column_name, type = T.unsafe(nil), **options); end

  # Removes the given columns from the table definition.
  #
  #   remove_columns(:suppliers, :qualification, :experience)
  #
  # +type+ and other column options can be passed to make migration reversible.
  #
  #    remove_columns(:suppliers, :qualification, :experience, type: :string, null: false)
  def remove_columns(table_name, *column_names, type: T.unsafe(nil), **options); end

  # Removes the given foreign key from the table. Any option parameters provided
  # will be used to re-add the foreign key in case of a migration rollback.
  # It is recommended that you provide any options used when creating the foreign
  # key so that the migration can be reverted properly.
  #
  # Removes the foreign key on +accounts.branch_id+.
  #
  #   remove_foreign_key :accounts, :branches
  #
  # Removes the foreign key on +accounts.owner_id+.
  #
  #   remove_foreign_key :accounts, column: :owner_id
  #
  # Removes the foreign key on +accounts.owner_id+.
  #
  #   remove_foreign_key :accounts, to_table: :owners
  #
  # Removes the foreign key named +special_fk_name+ on the +accounts+ table.
  #
  #   remove_foreign_key :accounts, name: :special_fk_name
  #
  # The +options+ hash accepts the same keys as SchemaStatements#add_foreign_key
  # with an addition of
  # [<tt>:to_table</tt>]
  #   The name of the table that contains the referenced primary key.
  def remove_foreign_key(from_table, to_table = T.unsafe(nil), **options); end

  # Removes the given index from the table.
  #
  # Removes the index on +branch_id+ in the +accounts+ table if exactly one such index exists.
  #
  #   remove_index :accounts, :branch_id
  #
  # Removes the index on +branch_id+ in the +accounts+ table if exactly one such index exists.
  #
  #   remove_index :accounts, column: :branch_id
  #
  # Removes the index on +branch_id+ and +party_id+ in the +accounts+ table if exactly one such index exists.
  #
  #   remove_index :accounts, column: [:branch_id, :party_id]
  #
  # Removes the index named +by_branch_party+ in the +accounts+ table.
  #
  #   remove_index :accounts, name: :by_branch_party
  #
  # Removes the index on +branch_id+ named +by_branch_party+ in the +accounts+ table.
  #
  #   remove_index :accounts, :branch_id, name: :by_branch_party
  #
  # Checks if the index exists before trying to remove it. Will silently ignore indexes that
  # don't exist.
  #
  #   remove_index :accounts, if_exists: true
  #
  # Removes the index named +by_branch_party+ in the +accounts+ table +concurrently+.
  #
  #   remove_index :accounts, name: :by_branch_party, algorithm: :concurrently
  #
  # Note: only supported by PostgreSQL.
  #
  # Concurrently removing an index is not supported in a transaction.
  #
  # For more information see the {"Transactional Migrations" section}[rdoc-ref:Migration].
  def remove_index(table_name, column_name = T.unsafe(nil), **options); end

  # Removes the reference(s). Also removes a +type+ column if one exists.
  # #remove_reference and #remove_belongs_to are acceptable.
  #
  # ====== Remove the reference
  #
  #   remove_reference(:products, :user, index: false)
  #
  # ====== Remove polymorphic reference
  #
  #   remove_reference(:products, :supplier, polymorphic: true)
  #
  # ====== Remove the reference with a foreign key
  #
  #   remove_reference(:products, :user, foreign_key: true)
  def remove_reference(table_name, ref_name, foreign_key: T.unsafe(nil), polymorphic: T.unsafe(nil), **options); end

  # Removes the timestamp columns (+created_at+ and +updated_at+) from the table definition.
  #
  #  remove_timestamps(:suppliers)
  def remove_timestamps(table_name, **options); end

  # Renames a column.
  #
  #   rename_column(:suppliers, :description, :name)
  #
  # @raise [NotImplementedError]
  def rename_column(table_name, column_name, new_column_name); end

  # Renames an index.
  #
  # Rename the +index_people_on_last_name+ index to +index_users_on_last_name+:
  #
  #   rename_index :people, 'index_people_on_last_name', 'index_users_on_last_name'
  def rename_index(table_name, old_name, new_name); end

  # Renames a table.
  #
  #   rename_table('octopuses', 'octopi')
  #
  # @raise [NotImplementedError]
  def rename_table(table_name, new_name); end

  # Truncates a table alias according to the limits of the current adapter.
  def table_alias_for(table_name); end

  # Returns the table comment that's stored in database metadata.
  def table_comment(table_name); end

  # Checks to see if the table +table_name+ exists on the database.
  #
  #   table_exists?(:developers)
  #
  # @return [Boolean]
  def table_exists?(table_name); end

  def table_options(table_name); end

  # Returns an array of table names defined in the database.
  def tables; end

  def type_to_sql(type, limit: T.unsafe(nil), precision: T.unsafe(nil), scale: T.unsafe(nil), **_arg4); end
  def update_table_definition(table_name, base); end

  # Checks to see if the view +view_name+ exists on the database.
  #
  #   view_exists?(:ebooks)
  #
  # @return [Boolean]
  def view_exists?(view_name); end

  # Returns an array of view names defined in the database.
  def views; end

  private

  def add_column_for_alter(table_name, column_name, type, **options); end
  def add_index_sort_order(quoted_columns, **options); end

  # Overridden by the MySQL adapter for supporting index lengths and by
  # the PostgreSQL adapter for supporting operator classes.
  def add_options_for_index_columns(quoted_columns, **options); end

  def add_timestamps_for_alter(table_name, **options); end
  def bulk_change_table(table_name, operations); end

  # @return [Boolean]
  def can_remove_index_by_name?(column_name, options); end

  def check_constraint_for(table_name, **options); end
  def check_constraint_for!(table_name, expression: T.unsafe(nil), **options); end
  def check_constraint_name(table_name, **options); end
  def column_options_keys; end
  def create_alter_table(name); end
  def create_table_definition(name, **options); end

  # @raise [NotImplementedError]
  def data_source_sql(name = T.unsafe(nil), type: T.unsafe(nil)); end

  def extract_foreign_key_action(specifier); end
  def extract_new_comment_value(default_or_changes); end
  def extract_new_default_value(default_or_changes); end
  def extract_table_options!(options); end
  def fetch_type_metadata(sql_type); end
  def foreign_key_for(from_table, **options); end
  def foreign_key_for!(from_table, to_table: T.unsafe(nil), **options); end
  def foreign_key_name(table_name, options); end
  def index_column_names(column_names); end

  # @raise [ArgumentError]
  def index_name_for_remove(table_name, column_name, options); end

  def index_name_options(column_names); end
  def insert_versions_sql(versions); end
  def options_for_index_columns(options); end

  # @raise [NotImplementedError]
  def quoted_scope(name = T.unsafe(nil), type: T.unsafe(nil)); end

  def remove_column_for_alter(table_name, column_name, type = T.unsafe(nil), **options); end
  def remove_columns_for_alter(table_name, *column_names, **options); end
  def remove_timestamps_for_alter(table_name, **options); end
  def rename_column_indexes(table_name, column_name, new_column_name); end
  def rename_column_sql(table_name, column_name, new_column_name); end
  def rename_table_indexes(table_name, new_name); end
  def schema_creation; end
  def strip_table_name_prefix_and_suffix(table_name); end
  def validate_index_length!(table_name, new_name, internal = T.unsafe(nil)); end
end

class ActiveRecord::ConnectionAdapters::SqlTypeMetadata
  include ::ActiveRecord::ConnectionAdapters::Deduplicable
  extend ::ActiveRecord::ConnectionAdapters::Deduplicable::ClassMethods

  # @return [SqlTypeMetadata] a new instance of SqlTypeMetadata
  def initialize(sql_type: T.unsafe(nil), type: T.unsafe(nil), limit: T.unsafe(nil), precision: T.unsafe(nil), scale: T.unsafe(nil)); end

  def ==(other); end
  def eql?(other); end
  def hash; end

  # Returns the value of attribute limit.
  def limit; end

  # Returns the value of attribute precision.
  def precision; end

  # Returns the value of attribute scale.
  def scale; end

  # Returns the value of attribute sql_type.
  def sql_type; end

  # Returns the value of attribute type.
  def type; end

  private

  def deduplicated; end
end

class ActiveRecord::ConnectionAdapters::StatementPool
  include ::Enumerable

  # @return [StatementPool] a new instance of StatementPool
  def initialize(statement_limit = T.unsafe(nil)); end

  def [](key); end
  def []=(sql, stmt); end
  def clear; end
  def delete(key); end
  def each(&block); end

  # @return [Boolean]
  def key?(key); end

  def length; end

  private

  def cache; end

  # @raise [NotImplementedError]
  def dealloc(stmt); end
end

ActiveRecord::ConnectionAdapters::StatementPool::DEFAULT_STATEMENT_LIMIT = T.let(T.unsafe(nil), Integer)

# Represents an SQL table in an abstract way for updating a table.
# Also see TableDefinition and {connection.create_table}[rdoc-ref:SchemaStatements#create_table]
#
# Available transformations are:
#
#   change_table :table do |t|
#     t.primary_key
#     t.column
#     t.index
#     t.rename_index
#     t.timestamps
#     t.change
#     t.change_default
#     t.change_null
#     t.rename
#     t.references
#     t.belongs_to
#     t.check_constraint
#     t.string
#     t.text
#     t.integer
#     t.bigint
#     t.float
#     t.decimal
#     t.numeric
#     t.datetime
#     t.timestamp
#     t.time
#     t.date
#     t.binary
#     t.boolean
#     t.foreign_key
#     t.json
#     t.virtual
#     t.remove
#     t.remove_foreign_key
#     t.remove_references
#     t.remove_belongs_to
#     t.remove_index
#     t.remove_check_constraint
#     t.remove_timestamps
#   end
class ActiveRecord::ConnectionAdapters::Table
  include ::ActiveRecord::ConnectionAdapters::ColumnMethods
  extend ::ActiveRecord::ConnectionAdapters::ColumnMethods::ClassMethods

  # @return [Table] a new instance of Table
  def initialize(table_name, base); end

  # Adds a reference.
  #
  #  t.references(:user)
  #  t.belongs_to(:supplier, foreign_key: true)
  #
  # See {connection.add_reference}[rdoc-ref:SchemaStatements#add_reference] for details of the options you can use.
  def belongs_to(*args, **options); end

  def bigint(*names, **options); end
  def binary(*names, **options); end
  def boolean(*names, **options); end

  # Changes the column's definition according to the new options.
  #
  #  t.change(:name, :string, limit: 80)
  #  t.change(:description, :text)
  #
  # See TableDefinition#column for details of the options you can use.
  def change(column_name, type, **options); end

  # Sets a new default value for a column.
  #
  #  t.change_default(:qualification, 'new')
  #  t.change_default(:authorized, 1)
  #  t.change_default(:status, from: nil, to: "draft")
  #
  # See {connection.change_column_default}[rdoc-ref:SchemaStatements#change_column_default]
  def change_default(column_name, default_or_changes); end

  # Sets or removes a NOT NULL constraint on a column.
  #
  #  t.change_null(:qualification, true)
  #  t.change_null(:qualification, false, 0)
  #
  # See {connection.change_column_null}[rdoc-ref:SchemaStatements#change_column_null]
  def change_null(column_name, null, default = T.unsafe(nil)); end

  # Adds a check constraint.
  #
  #  t.check_constraint("price > 0", name: "price_check")
  #
  # See {connection.add_check_constraint}[rdoc-ref:SchemaStatements#add_check_constraint]
  def check_constraint(*args); end

  # Adds a new column to the named table.
  #
  #  t.column(:name, :string)
  #
  # See TableDefinition#column for details of the options you can use.
  def column(column_name, type, index: T.unsafe(nil), **options); end

  # Checks to see if a column exists.
  #
  #  t.string(:name) unless t.column_exists?(:name, :string)
  #
  # See {connection.column_exists?}[rdoc-ref:SchemaStatements#column_exists?]
  #
  # @return [Boolean]
  def column_exists?(column_name, type = T.unsafe(nil), **options); end

  def date(*names, **options); end
  def datetime(*names, **options); end
  def decimal(*names, **options); end
  def float(*names, **options); end

  # Adds a foreign key to the table using a supplied table name.
  #
  #  t.foreign_key(:authors)
  #  t.foreign_key(:authors, column: :author_id, primary_key: "id")
  #
  # See {connection.add_foreign_key}[rdoc-ref:SchemaStatements#add_foreign_key]
  def foreign_key(*args, **options); end

  # Checks to see if a foreign key exists.
  #
  #  t.foreign_key(:authors) unless t.foreign_key_exists?(:authors)
  #
  # See {connection.foreign_key_exists?}[rdoc-ref:SchemaStatements#foreign_key_exists?]
  #
  # @return [Boolean]
  def foreign_key_exists?(*args, **options); end

  # Adds a new index to the table. +column_name+ can be a single Symbol, or
  # an Array of Symbols.
  #
  #  t.index(:name)
  #  t.index([:branch_id, :party_id], unique: true)
  #  t.index([:branch_id, :party_id], unique: true, name: 'by_branch_party')
  #
  # See {connection.add_index}[rdoc-ref:SchemaStatements#add_index] for details of the options you can use.
  def index(column_name, **options); end

  # Checks to see if an index exists.
  #
  #  unless t.index_exists?(:branch_id)
  #    t.index(:branch_id)
  #  end
  #
  # See {connection.index_exists?}[rdoc-ref:SchemaStatements#index_exists?]
  #
  # @return [Boolean]
  def index_exists?(column_name, options = T.unsafe(nil)); end

  def integer(*names, **options); end
  def json(*names, **options); end

  # Returns the value of attribute name.
  def name; end

  def numeric(*names, **options); end

  # Adds a reference.
  #
  #  t.references(:user)
  #  t.belongs_to(:supplier, foreign_key: true)
  #
  # See {connection.add_reference}[rdoc-ref:SchemaStatements#add_reference] for details of the options you can use.
  def references(*args, **options); end

  # Removes the column(s) from the table definition.
  #
  #  t.remove(:qualification)
  #  t.remove(:qualification, :experience)
  #
  # See {connection.remove_columns}[rdoc-ref:SchemaStatements#remove_columns]
  def remove(*column_names, **options); end

  # Removes a reference. Optionally removes a +type+ column.
  #
  #  t.remove_references(:user)
  #  t.remove_belongs_to(:supplier, polymorphic: true)
  #
  # See {connection.remove_reference}[rdoc-ref:SchemaStatements#remove_reference]
  def remove_belongs_to(*args, **options); end

  # Removes the given check constraint from the table.
  #
  #  t.remove_check_constraint(name: "price_check")
  #
  # See {connection.remove_check_constraint}[rdoc-ref:SchemaStatements#remove_check_constraint]
  def remove_check_constraint(*args); end

  # Removes the given foreign key from the table.
  #
  #  t.remove_foreign_key(:authors)
  #  t.remove_foreign_key(column: :author_id)
  #
  # See {connection.remove_foreign_key}[rdoc-ref:SchemaStatements#remove_foreign_key]
  def remove_foreign_key(*args, **options); end

  # Removes the given index from the table.
  #
  #   t.remove_index(:branch_id)
  #   t.remove_index(column: [:branch_id, :party_id])
  #   t.remove_index(name: :by_branch_party)
  #   t.remove_index(:branch_id, name: :by_branch_party)
  #
  # See {connection.remove_index}[rdoc-ref:SchemaStatements#remove_index]
  def remove_index(column_name = T.unsafe(nil), **options); end

  # Removes a reference. Optionally removes a +type+ column.
  #
  #  t.remove_references(:user)
  #  t.remove_belongs_to(:supplier, polymorphic: true)
  #
  # See {connection.remove_reference}[rdoc-ref:SchemaStatements#remove_reference]
  def remove_references(*args, **options); end

  # Removes the timestamp columns (+created_at+ and +updated_at+) from the table.
  #
  #  t.remove_timestamps
  #
  # See {connection.remove_timestamps}[rdoc-ref:SchemaStatements#remove_timestamps]
  def remove_timestamps(**options); end

  # Renames a column.
  #
  #  t.rename(:description, :name)
  #
  # See {connection.rename_column}[rdoc-ref:SchemaStatements#rename_column]
  def rename(column_name, new_column_name); end

  # Renames the given index on the table.
  #
  #  t.rename_index(:user_id, :account_id)
  #
  # See {connection.rename_index}[rdoc-ref:SchemaStatements#rename_index]
  def rename_index(index_name, new_index_name); end

  def string(*names, **options); end
  def text(*names, **options); end
  def time(*names, **options); end
  def timestamp(*names, **options); end

  # Adds timestamps (+created_at+ and +updated_at+) columns to the table.
  #
  #  t.timestamps(null: false)
  #
  # See {connection.add_timestamps}[rdoc-ref:SchemaStatements#add_timestamps]
  def timestamps(**options); end

  def virtual(*names, **options); end
end

# Represents the schema of an SQL table in an abstract way. This class
# provides methods for manipulating the schema representation.
#
# Inside migration files, the +t+ object in {create_table}[rdoc-ref:SchemaStatements#create_table]
# is actually of this type:
#
#   class SomeMigration < ActiveRecord::Migration[6.0]
#     def up
#       create_table :foo do |t|
#         puts t.class  # => "ActiveRecord::ConnectionAdapters::TableDefinition"
#       end
#     end
#
#     def down
#       ...
#     end
#   end
class ActiveRecord::ConnectionAdapters::TableDefinition
  include ::ActiveRecord::ConnectionAdapters::ColumnMethods
  extend ::ActiveRecord::ConnectionAdapters::ColumnMethods::ClassMethods

  # @return [TableDefinition] a new instance of TableDefinition
  def initialize(conn, name, temporary: T.unsafe(nil), if_not_exists: T.unsafe(nil), options: T.unsafe(nil), as: T.unsafe(nil), comment: T.unsafe(nil), **_arg7); end

  # Returns a ColumnDefinition for the column with name +name+.
  def [](name); end

  # Returns the value of attribute as.
  def as; end

  # Adds a reference.
  #
  #  t.references(:user)
  #  t.belongs_to(:supplier, foreign_key: true)
  #  t.belongs_to(:supplier, foreign_key: true, type: :integer)
  #
  # See {connection.add_reference}[rdoc-ref:SchemaStatements#add_reference] for details of the options you can use.
  def belongs_to(*args, **options); end

  def bigint(*names, **options); end
  def binary(*names, **options); end
  def boolean(*names, **options); end
  def check_constraint(expression, **options); end

  # Returns the value of attribute check_constraints.
  def check_constraints; end

  # Instantiates a new column for the table.
  # See {connection.add_column}[rdoc-ref:ConnectionAdapters::SchemaStatements#add_column]
  # for available options.
  #
  # Additional options are:
  # * <tt>:index</tt> -
  #   Create an index for the column. Can be either <tt>true</tt> or an options hash.
  #
  # This method returns <tt>self</tt>.
  #
  # == Examples
  #
  #  # Assuming +td+ is an instance of TableDefinition
  #  td.column(:granted, :boolean, index: true)
  #
  # == Short-hand examples
  #
  # Instead of calling #column directly, you can also work with the short-hand definitions for the default types.
  # They use the type as the method name instead of as a parameter and allow for multiple columns to be defined
  # in a single statement.
  #
  # What can be written like this with the regular calls to column:
  #
  #   create_table :products do |t|
  #     t.column :shop_id,     :integer
  #     t.column :creator_id,  :integer
  #     t.column :item_number, :string
  #     t.column :name,        :string, default: "Untitled"
  #     t.column :value,       :string, default: "Untitled"
  #     t.column :created_at,  :datetime
  #     t.column :updated_at,  :datetime
  #   end
  #   add_index :products, :item_number
  #
  # can also be written as follows using the short-hand:
  #
  #   create_table :products do |t|
  #     t.integer :shop_id, :creator_id
  #     t.string  :item_number, index: true
  #     t.string  :name, :value, default: "Untitled"
  #     t.timestamps null: false
  #   end
  #
  # There's a short-hand method for each of the type values declared at the top. And then there's
  # TableDefinition#timestamps that'll add +created_at+ and +updated_at+ as datetimes.
  #
  # TableDefinition#references will add an appropriately-named _id column, plus a corresponding _type
  # column if the <tt>:polymorphic</tt> option is supplied. If <tt>:polymorphic</tt> is a hash of
  # options, these will be used when creating the <tt>_type</tt> column. The <tt>:index</tt> option
  # will also create an index, similar to calling {add_index}[rdoc-ref:ConnectionAdapters::SchemaStatements#add_index].
  # So what can be written like this:
  #
  #   create_table :taggings do |t|
  #     t.integer :tag_id, :tagger_id, :taggable_id
  #     t.string  :tagger_type
  #     t.string  :taggable_type, default: 'Photo'
  #   end
  #   add_index :taggings, :tag_id, name: 'index_taggings_on_tag_id'
  #   add_index :taggings, [:tagger_id, :tagger_type]
  #
  # Can also be written as follows using references:
  #
  #   create_table :taggings do |t|
  #     t.references :tag, index: { name: 'index_taggings_on_tag_id' }
  #     t.references :tagger, polymorphic: true
  #     t.references :taggable, polymorphic: { default: 'Photo' }, index: false
  #   end
  def column(name, type, index: T.unsafe(nil), **options); end

  # Returns an array of ColumnDefinition objects for the columns of the table.
  def columns; end

  # Returns the value of attribute comment.
  def comment; end

  def date(*names, **options); end
  def datetime(*names, **options); end
  def decimal(*names, **options); end
  def float(*names, **options); end
  def foreign_key(table_name, **options); end

  # Returns the value of attribute foreign_keys.
  def foreign_keys; end

  # Returns the value of attribute if_not_exists.
  def if_not_exists; end

  # Adds index options to the indexes hash, keyed by column name
  # This is primarily used to track indexes that need to be created after the table
  #
  #   index(:account_id, name: 'index_projects_on_account_id')
  def index(column_name, **options); end

  # Returns the value of attribute indexes.
  def indexes; end

  def integer(*names, **options); end
  def json(*names, **options); end

  # Returns the value of attribute name.
  def name; end

  def new_column_definition(name, type, **options); end
  def numeric(*names, **options); end

  # Returns the value of attribute options.
  def options; end

  def primary_keys(name = T.unsafe(nil)); end

  # Adds a reference.
  #
  #  t.references(:user)
  #  t.belongs_to(:supplier, foreign_key: true)
  #  t.belongs_to(:supplier, foreign_key: true, type: :integer)
  #
  # See {connection.add_reference}[rdoc-ref:SchemaStatements#add_reference] for details of the options you can use.
  def references(*args, **options); end

  # remove the column +name+ from the table.
  #   remove_column(:account_id)
  def remove_column(name); end

  def string(*names, **options); end

  # Returns the value of attribute temporary.
  def temporary; end

  def text(*names, **options); end
  def time(*names, **options); end
  def timestamp(*names, **options); end

  # Appends <tt>:datetime</tt> columns <tt>:created_at</tt> and
  # <tt>:updated_at</tt> to the table. See {connection.add_timestamps}[rdoc-ref:SchemaStatements#add_timestamps]
  #
  #   t.timestamps null: false
  def timestamps(**options); end

  def virtual(*names, **options); end

  private

  def aliased_types(name, fallback); end
  def create_column_definition(name, type, options); end

  # @return [Boolean]
  def integer_like_primary_key?(type, options); end

  def integer_like_primary_key_type(type, options); end
end

class ActiveRecord::ConnectionAdapters::Transaction
  # @return [Transaction] a new instance of Transaction
  def initialize(connection, isolation: T.unsafe(nil), joinable: T.unsafe(nil), run_commit_callbacks: T.unsafe(nil)); end

  def add_record(record, ensure_finalize = T.unsafe(nil)); end
  def before_commit_records; end

  # @return [Boolean]
  def closed?; end

  def commit_records; end

  # Returns the value of attribute connection.
  def connection; end

  # @return [Boolean]
  def full_rollback?; end

  # Returns the value of attribute isolation_level.
  def isolation_level; end

  # @return [Boolean]
  def joinable?; end

  def materialize!; end

  # @return [Boolean]
  def materialized?; end

  # @return [Boolean]
  def open?; end

  def records; end
  def rollback_records; end

  # Returns the value of attribute savepoint_name.
  def savepoint_name; end

  # Returns the value of attribute state.
  def state; end

  # Returns the value of attribute written.
  def written; end

  # Sets the attribute written
  #
  # @param value the value to set the attribute written to.
  def written=(_arg0); end
end

class ActiveRecord::ConnectionAdapters::TransactionManager
  # @return [TransactionManager] a new instance of TransactionManager
  def initialize(connection); end

  def begin_transaction(isolation: T.unsafe(nil), joinable: T.unsafe(nil), _lazy: T.unsafe(nil)); end
  def commit_transaction; end
  def current_transaction; end
  def disable_lazy_transactions!; end
  def enable_lazy_transactions!; end

  # @return [Boolean]
  def lazy_transactions_enabled?; end

  def materialize_transactions; end
  def open_transactions; end
  def rollback_transaction(transaction = T.unsafe(nil)); end
  def within_new_transaction(isolation: T.unsafe(nil), joinable: T.unsafe(nil)); end

  private

  # Deallocate invalidated prepared statements outside of the transaction
  def after_failure_actions(transaction, error); end
end

ActiveRecord::ConnectionAdapters::TransactionManager::NULL_TRANSACTION = T.let(T.unsafe(nil), ActiveRecord::ConnectionAdapters::NullTransaction)

class ActiveRecord::ConnectionAdapters::TransactionState
  # @return [TransactionState] a new instance of TransactionState
  def initialize(state = T.unsafe(nil)); end

  def add_child(state); end
  def commit!; end

  # @return [Boolean]
  def committed?; end

  # @return [Boolean]
  def completed?; end

  # @return [Boolean]
  def finalized?; end

  def full_commit!; end
  def full_rollback!; end

  # @return [Boolean]
  def fully_committed?; end

  # @return [Boolean]
  def fully_completed?; end

  # @return [Boolean]
  def fully_rolledback?; end

  def invalidate!; end

  # @return [Boolean]
  def invalidated?; end

  def nullify!; end
  def rollback!; end

  # @return [Boolean]
  def rolledback?; end
end

module ActiveRecord::ConnectionHandling
  def clear_active_connections!(*_arg0, &_arg1); end
  def clear_all_connections!(*_arg0, &_arg1); end
  def clear_cache!; end

  # Clears the query cache for all connections associated with the current thread.
  def clear_query_caches_for_current_thread; end

  def clear_reloadable_connections!(*_arg0, &_arg1); end

  # Returns +true+ if Active Record is connected.
  #
  # @return [Boolean]
  def connected?; end

  # Connects to a role (ex writing, reading or a custom role) and/or
  # shard for the duration of the block. At the end of the block the
  # connection will be returned to the original role / shard.
  #
  # If only a role is passed, Active Record will look up the connection
  # based on the requested role. If a non-established role is requested
  # an +ActiveRecord::ConnectionNotEstablished+ error will be raised:
  #
  #   ActiveRecord::Base.connected_to(role: :writing) do
  #     Dog.create! # creates dog using dog writing connection
  #   end
  #
  #   ActiveRecord::Base.connected_to(role: :reading) do
  #     Dog.create! # throws exception because we're on a replica
  #   end
  #
  # When swapping to a shard, the role must be passed as well. If a non-existent
  # shard is passed, an +ActiveRecord::ConnectionNotEstablished+ error will be
  # raised.
  #
  # When a shard and role is passed, Active Record will first lookup the role,
  # and then look up the connection by shard key.
  #
  #   ActiveRecord::Base.connected_to(role: :reading, shard: :shard_one_replica) do
  #     Dog.first # finds first Dog record stored on the shard one replica
  #   end
  #
  # The database kwarg is deprecated and will be removed in Rails 7.0.0 without replacement.
  def connected_to(database: T.unsafe(nil), role: T.unsafe(nil), shard: T.unsafe(nil), prevent_writes: T.unsafe(nil), &blk); end

  # Returns true if role is the current connected role.
  #
  #   ActiveRecord::Base.connected_to(role: :writing) do
  #     ActiveRecord::Base.connected_to?(role: :writing) #=> true
  #     ActiveRecord::Base.connected_to?(role: :reading) #=> false
  #   end
  #
  # @return [Boolean]
  def connected_to?(role:, shard: T.unsafe(nil)); end

  # Connects a role and/or shard to the provided connection names. Optionally +prevent_writes+
  # can be passed to block writes on a connection. +reading+ will automatically set
  # +prevent_writes+ to true.
  #
  # +connected_to_many+ is an alternative to deeply nested +connected_to+ blocks.
  #
  # Usage:
  #
  #   ActiveRecord::Base.connected_to_many(AnimalsRecord, MealsRecord, role: :reading) do
  #     Dog.first # Read from animals replica
  #     Dinner.first # Read from meals replica
  #     Person.first # Read from primary writer
  #   end
  def connected_to_many(*classes, role:, shard: T.unsafe(nil), prevent_writes: T.unsafe(nil)); end

  # Use a specified connection.
  #
  # This method is useful for ensuring that a specific connection is
  # being used. For example, when booting a console in readonly mode.
  #
  # It is not recommended to use this method in a request since it
  # does not yield to a block like +connected_to+.
  def connecting_to(role: T.unsafe(nil), shard: T.unsafe(nil), prevent_writes: T.unsafe(nil)); end

  # Returns the connection currently associated with the class. This can
  # also be used to "borrow" the connection to do database work unrelated
  # to any of the specific Active Records.
  def connection; end

  # Returns the configuration of the associated connection as a hash:
  #
  #  ActiveRecord::Base.connection_config
  #  # => {pool: 5, timeout: 5000, database: "db/development.sqlite3", adapter: "sqlite3"}
  #
  # Please use only for reading.
  def connection_config(*args, &block); end

  # Returns the db_config object from the associated connection:
  #
  #  ActiveRecord::Base.connection_db_config
  #    #<ActiveRecord::DatabaseConfigurations::HashConfig:0x00007fd1acbded10 @env_name="development",
  #      @name="primary", @config={pool: 5, timeout: 5000, database: "db/development.sqlite3", adapter: "sqlite3"}>
  #
  # Use only for reading.
  def connection_db_config; end

  def connection_pool; end

  # Return the connection specification name from the current class or its parent.
  def connection_specification_name; end

  # Sets the attribute connection_specification_name
  #
  # @param value the value to set the attribute connection_specification_name to.
  def connection_specification_name=(_arg0); end

  # Connects a model to the databases specified. The +database+ keyword
  # takes a hash consisting of a +role+ and a +database_key+.
  #
  # This will create a connection handler for switching between connections,
  # look up the config hash using the +database_key+ and finally
  # establishes a connection to that config.
  #
  #   class AnimalsModel < ApplicationRecord
  #     self.abstract_class = true
  #
  #     connects_to database: { writing: :primary, reading: :primary_replica }
  #   end
  #
  # +connects_to+ also supports horizontal sharding. The horizontal sharding API
  # also supports read replicas. Connect a model to a list of shards like this:
  #
  #   class AnimalsModel < ApplicationRecord
  #     self.abstract_class = true
  #
  #     connects_to shards: {
  #       default: { writing: :primary, reading: :primary_replica },
  #       shard_two: { writing: :primary_shard_two, reading: :primary_shard_replica_two }
  #     }
  #   end
  #
  # Returns an array of database connections.
  #
  # @raise [NotImplementedError]
  def connects_to(database: T.unsafe(nil), shards: T.unsafe(nil)); end

  # Establishes the connection to the database. Accepts a hash as input where
  # the <tt>:adapter</tt> key must be specified with the name of a database adapter (in lower-case)
  # example for regular databases (MySQL, PostgreSQL, etc):
  #
  #   ActiveRecord::Base.establish_connection(
  #     adapter:  "mysql2",
  #     host:     "localhost",
  #     username: "myuser",
  #     password: "mypass",
  #     database: "somedatabase"
  #   )
  #
  # Example for SQLite database:
  #
  #   ActiveRecord::Base.establish_connection(
  #     adapter:  "sqlite3",
  #     database: "path/to/dbfile"
  #   )
  #
  # Also accepts keys as strings (for parsing from YAML for example):
  #
  #   ActiveRecord::Base.establish_connection(
  #     "adapter"  => "sqlite3",
  #     "database" => "path/to/dbfile"
  #   )
  #
  # Or a URL:
  #
  #   ActiveRecord::Base.establish_connection(
  #     "postgres://myuser:mypass@localhost/somedatabase"
  #   )
  #
  # In case {ActiveRecord::Base.configurations}[rdoc-ref:Core.configurations]
  # is set (Rails automatically loads the contents of config/database.yml into it),
  # a symbol can also be given as argument, representing a key in the
  # configuration hash:
  #
  #   ActiveRecord::Base.establish_connection(:production)
  #
  # The exceptions AdapterNotSpecified, AdapterNotFound and +ArgumentError+
  # may be returned on an error.
  def establish_connection(config_or_env = T.unsafe(nil)); end

  def flush_idle_connections!(*_arg0, &_arg1); end
  def lookup_connection_handler(handler_key); end

  # Establishes a connection to the database that's used by all Active Record objects
  def postgresql_connection(config); end

  # @return [Boolean]
  def primary_class?; end

  def remove_connection(name = T.unsafe(nil)); end
  def retrieve_connection; end

  # Prevent writing to the database regardless of role.
  #
  # In some cases you may want to prevent writes to the database
  # even if you are on a database that can write. +while_preventing_writes+
  # will prevent writes to the database for the duration of the block.
  #
  # This method does not provide the same protection as a readonly
  # user and is meant to be a safeguard against accidental writes.
  #
  # See +READ_QUERY+ for the queries that are blocked by this
  # method.
  def while_preventing_writes(enabled = T.unsafe(nil), &block); end

  private

  def clear_on_handler(handler); end
  def resolve_config_for_connection(config_or_env); end
  def swap_connection_handler(handler, &blk); end
  def with_handler(handler_key, &blk); end
  def with_role_and_shard(role, shard, prevent_writes); end
end

ActiveRecord::ConnectionHandling::DEFAULT_ENV = T.let(T.unsafe(nil), Proc)
ActiveRecord::ConnectionHandling::RAILS_ENV = T.let(T.unsafe(nil), Proc)

# Raised when connection to the database could not been established (for example when
# {ActiveRecord::Base.connection=}[rdoc-ref:ConnectionHandling#connection]
# is given a +nil+ object).
class ActiveRecord::ConnectionNotEstablished < ::ActiveRecord::ActiveRecordError; end

# Raised when a connection could not be obtained within the connection
# acquisition timeout period: because max connections in pool
# are in use.
class ActiveRecord::ConnectionTimeoutError < ::ActiveRecord::ConnectionNotEstablished; end

module ActiveRecord::Core
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::ActiveRecord::Core::ClassMethods

  # New objects can be instantiated as either empty (pass no construction parameter) or pre-set with
  # attributes but not yet saved (pass a hash with key names matching the associated table column names).
  # In both instances, valid attribute keys are determined by the column names of the associated table --
  # hence you can't have attributes that aren't part of the table columns.
  #
  # ==== Example:
  #   # Instantiates a single new object
  #   User.new(first_name: 'Jamie')
  #
  # @yield [_self]
  # @yieldparam _self [ActiveRecord::Core] the object that the method was called on
  def initialize(attributes = T.unsafe(nil)); end

  # Allows sort on objects
  def <=>(other_object); end

  # Returns true if +comparison_object+ is the same exact object, or +comparison_object+
  # is of the same type and +self+ has an ID and it is equal to +comparison_object.id+.
  #
  # Note that new records are different from any other record by definition, unless the
  # other record is the receiver itself. Besides, if you fetch existing records with
  # +select+ and leave the ID out, you're on your own, this predicate will return false.
  #
  # Note also that destroying a record preserves its ID in the model instance, so deleted
  # models are still comparable.
  def ==(comparison_object); end

  # @return [Boolean]
  def blank?; end

  def connection_handler; end

  # Populate +coder+ with attributes about this record that should be
  # serialized. The structure of +coder+ defined in this method is
  # guaranteed to match the structure of +coder+ passed to the #init_with
  # method.
  #
  # Example:
  #
  #   class Post < ActiveRecord::Base
  #   end
  #   coder = {}
  #   Post.new.encode_with(coder)
  #   coder # => {"attributes" => {"id" => nil, ... }}
  def encode_with(coder); end

  # Returns true if +comparison_object+ is the same exact object, or +comparison_object+
  # is of the same type and +self+ has an ID and it is equal to +comparison_object.id+.
  #
  # Note that new records are different from any other record by definition, unless the
  # other record is the receiver itself. Besides, if you fetch existing records with
  # +select+ and leave the ID out, you're on your own, this predicate will return false.
  #
  # Note also that destroying a record preserves its ID in the model instance, so deleted
  # models are still comparable.
  def eql?(comparison_object); end

  # Clone and freeze the attributes hash such that associations are still
  # accessible, even on destroyed records, but cloned models will not be
  # frozen.
  def freeze; end

  # Returns +true+ if the attributes hash has been frozen.
  #
  # @return [Boolean]
  def frozen?; end

  # Delegates to id in order to allow two records of the same type and id to work with something like:
  #   [ Person.find(1), Person.find(2), Person.find(3) ] & [ Person.find(1), Person.find(4) ] # => [ Person.find(1) ]
  def hash; end

  # Initialize an empty model object from +coder+. +coder+ should be
  # the result of previously encoding an Active Record model, using
  # #encode_with.
  #
  #   class Post < ActiveRecord::Base
  #   end
  #
  #   old_post = Post.new(title: "hello world")
  #   coder = {}
  #   old_post.encode_with(coder)
  #
  #   post = Post.allocate
  #   post.init_with(coder)
  #   post.title # => 'hello world'
  def init_with(coder, &block); end

  # Initialize an empty model object from +attributes+.
  # +attributes+ should be an attributes object, and unlike the
  # `initialize` method, no assignment calls are made per attribute.
  #
  # @yield [_self]
  # @yieldparam _self [ActiveRecord::Core] the object that the method was called on
  def init_with_attributes(attributes, new_record = T.unsafe(nil)); end

  # Returns the contents of the record as a nicely formatted string.
  def inspect; end

  # @return [Boolean]
  def present?; end

  # Takes a PP and prettily prints this record to it, allowing you to get a nice result from <tt>pp record</tt>
  # when pp is required.
  def pretty_print(pp); end

  # Marks this record as read only.
  def readonly!; end

  # Returns +true+ if the record is read only.
  #
  # @return [Boolean]
  def readonly?; end

  # Returns a hash of the given methods with their names as keys and returned values as values.
  def slice(*methods); end

  # Sets the record to strict_loading mode. This will raise an error
  # if the record tries to lazily load an association.
  #
  #   user = User.first
  #   user.strict_loading!
  #   user.comments.to_a
  #   => ActiveRecord::StrictLoadingViolationError
  def strict_loading!; end

  # Returns +true+ if the record is in strict_loading mode.
  #
  # @return [Boolean]
  def strict_loading?; end

  # Returns an array of the values returned by the given methods.
  def values_at(*methods); end

  private

  # @return [Boolean]
  def custom_inspect_method_defined?; end

  def init_internals; end
  def initialize_dup(other); end
  def initialize_internals_callback; end
  def inspection_filter; end

  # +Array#flatten+ will call +#to_ary+ (recursively) on each of the elements of
  # the array, and then rescues from the possible +NoMethodError+. If those elements are
  # +ActiveRecord::Base+'s, then this triggers the various +method_missing+'s that we have,
  # which significantly impacts upon performance.
  #
  # So we can avoid the +method_missing+ hit by explicitly defining +#to_ary+ as +nil+ here.
  #
  # See also https://tenderlovemaking.com/2011/06/28/til-its-ok-to-return-nil-from-to_ary.html
  def to_ary; end

  module GeneratedClassMethods
    def belongs_to_required_by_default; end
    def belongs_to_required_by_default=(value); end
    def belongs_to_required_by_default?; end
    def default_connection_handler; end
    def default_connection_handler=(value); end
    def default_connection_handler?; end
    def default_role; end
    def default_role=(value); end
    def default_role?; end
    def default_shard; end
    def default_shard=(value); end
    def default_shard?; end
    def destroy_association_async_job; end
    def destroy_association_async_job=(value); end
    def strict_loading_by_default; end
    def strict_loading_by_default=(value); end
    def strict_loading_by_default?; end
  end

  module GeneratedInstanceMethods
    def default_connection_handler; end
    def default_connection_handler?; end
    def default_role; end
    def default_role?; end
    def default_shard; end
    def default_shard?; end
    def destroy_association_async_job; end
  end
end

module ActiveRecord::Core::ClassMethods
  # Overwrite the default class equality method to provide support for decorated models.
  def ===(object); end

  # @return [Boolean]
  def _internal?; end

  def arel_attribute(*args, &block); end

  # Returns an instance of <tt>Arel::Table</tt> loaded with the current table name.
  #
  #   class Post < ActiveRecord::Base
  #     scope :published_and_commented, -> { published.and(arel_table[:comments_count].gt(0)) }
  #   end
  def arel_table; end

  def cached_find_by_statement(key, &block); end

  # Returns columns which shouldn't be exposed while calling +#inspect+.
  def filter_attributes; end

  # Specifies columns which shouldn't be exposed while calling +#inspect+.
  def filter_attributes=(filter_attributes); end

  def find(*ids); end
  def find_by(*args); end
  def find_by!(*args); end
  def generated_association_methods; end
  def inherited(child_class); end
  def initialize_find_by_cache; end
  def initialize_generated_modules; end

  # Returns a string like 'Post(id:integer, title:string, body:text)'
  def inspect; end

  def inspection_filter; end
  def predicate_builder; end
  def type_caster; end

  private

  def relation; end
  def table_metadata; end
end

class ActiveRecord::Core::InspectionMask
  def pretty_print(pp); end
end

# = Active Record Counter Cache
module ActiveRecord::CounterCache
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::ActiveRecord::CounterCache::ClassMethods

  private

  def _create_record(attribute_names = T.unsafe(nil)); end
  def destroy_row; end
  def each_counter_cached_associations; end
end

module ActiveRecord::CounterCache::ClassMethods
  # Decrement a numeric field by one, via a direct SQL update.
  #
  # This works the same as #increment_counter but reduces the column value by
  # 1 instead of increasing it.
  #
  # ==== Parameters
  #
  # * +counter_name+ - The name of the field that should be decremented.
  # * +id+ - The id of the object that should be decremented or an array of ids.
  # * <tt>:touch</tt> - Touch timestamp columns when updating.
  #   Pass +true+ to touch +updated_at+ and/or +updated_on+. Pass a symbol to
  #   touch that column or an array of symbols to touch just those ones.
  #
  # ==== Examples
  #
  #   # Decrement the posts_count column for the record with an id of 5
  #   DiscussionBoard.decrement_counter(:posts_count, 5)
  #
  #   # Decrement the posts_count column for the record with an id of 5
  #   # and update the updated_at value.
  #   DiscussionBoard.decrement_counter(:posts_count, 5, touch: true)
  def decrement_counter(counter_name, id, touch: T.unsafe(nil)); end

  # Increment a numeric field by one, via a direct SQL update.
  #
  # This method is used primarily for maintaining counter_cache columns that are
  # used to store aggregate values. For example, a +DiscussionBoard+ may cache
  # posts_count and comments_count to avoid running an SQL query to calculate the
  # number of posts and comments there are, each time it is displayed.
  #
  # ==== Parameters
  #
  # * +counter_name+ - The name of the field that should be incremented.
  # * +id+ - The id of the object that should be incremented or an array of ids.
  # * <tt>:touch</tt> - Touch timestamp columns when updating.
  #   Pass +true+ to touch +updated_at+ and/or +updated_on+. Pass a symbol to
  #   touch that column or an array of symbols to touch just those ones.
  #
  # ==== Examples
  #
  #   # Increment the posts_count column for the record with an id of 5
  #   DiscussionBoard.increment_counter(:posts_count, 5)
  #
  #   # Increment the posts_count column for the record with an id of 5
  #   # and update the updated_at value.
  #   DiscussionBoard.increment_counter(:posts_count, 5, touch: true)
  def increment_counter(counter_name, id, touch: T.unsafe(nil)); end

  # Resets one or more counter caches to their correct value using an SQL
  # count query. This is useful when adding new counter caches, or if the
  # counter has been corrupted or modified directly by SQL.
  #
  # ==== Parameters
  #
  # * +id+ - The id of the object you wish to reset a counter on.
  # * +counters+ - One or more association counters to reset. Association name or counter name can be given.
  # * <tt>:touch</tt> - Touch timestamp columns when updating.
  #   Pass +true+ to touch +updated_at+ and/or +updated_on+. Pass a symbol to
  #   touch that column or an array of symbols to touch just those ones.
  #
  # ==== Examples
  #
  #   # For the Post with id #1, reset the comments_count
  #   Post.reset_counters(1, :comments)
  #
  #   # Like above, but also touch the +updated_at+ and/or +updated_on+
  #   # attributes.
  #   Post.reset_counters(1, :comments, touch: true)
  def reset_counters(id, *counters, touch: T.unsafe(nil)); end

  # A generic "counter updater" implementation, intended primarily to be
  # used by #increment_counter and #decrement_counter, but which may also
  # be useful on its own. It simply does a direct SQL update for the record
  # with the given ID, altering the given hash of counters by the amount
  # given by the corresponding value:
  #
  # ==== Parameters
  #
  # * +id+ - The id of the object you wish to update a counter on or an array of ids.
  # * +counters+ - A Hash containing the names of the fields
  #   to update as keys and the amount to update the field by as values.
  # * <tt>:touch</tt> option - Touch timestamp columns when updating.
  #   If attribute names are passed, they are updated along with updated_at/on
  #   attributes.
  #
  # ==== Examples
  #
  #   # For the Post with id of 5, decrement the comment_count by 1, and
  #   # increment the action_count by 1
  #   Post.update_counters 5, comment_count: -1, action_count: 1
  #   # Executes the following SQL:
  #   # UPDATE posts
  #   #    SET comment_count = COALESCE(comment_count, 0) - 1,
  #   #        action_count = COALESCE(action_count, 0) + 1
  #   #  WHERE id = 5
  #
  #   # For the Posts with id of 10 and 15, increment the comment_count by 1
  #   Post.update_counters [10, 15], comment_count: 1
  #   # Executes the following SQL:
  #   # UPDATE posts
  #   #    SET comment_count = COALESCE(comment_count, 0) + 1
  #   #  WHERE id IN (10, 15)
  #
  #   # For the Posts with id of 10 and 15, increment the comment_count by 1
  #   # and update the updated_at value for each counter.
  #   Post.update_counters [10, 15], comment_count: 1, touch: true
  #   # Executes the following SQL:
  #   # UPDATE posts
  #   #    SET comment_count = COALESCE(comment_count, 0) + 1,
  #   #    `updated_at` = '2016-10-13T09:59:23-05:00'
  #   #  WHERE id IN (10, 15)
  def update_counters(id, counters); end
end

# Raised when attribute has a name reserved by Active Record (when attribute
# has name of one of Active Record instance methods).
class ActiveRecord::DangerousAttributeError < ::ActiveRecord::ActiveRecordError; end

# Raised when creating a database if it exists.
class ActiveRecord::DatabaseAlreadyExists < ::ActiveRecord::StatementInvalid; end

# ActiveRecord::DatabaseConfigurations returns an array of DatabaseConfig
# objects (either a HashConfig or UrlConfig) that are constructed from the
# application's database configuration hash or URL string.
class ActiveRecord::DatabaseConfigurations
  # @return [DatabaseConfigurations] a new instance of DatabaseConfigurations
  def initialize(configurations = T.unsafe(nil)); end

  # Returns the config hash that corresponds with the environment
  #
  # If the application has multiple databases +default_hash+ will
  # return the first config hash for the environment.
  #
  #   { database: "my_db", adapter: "mysql2" }
  def [](*args, &block); end

  def any?(*_arg0, &_arg1); end

  # Checks if the application's configurations are empty.
  #
  # Aliased to blank?
  #
  # @return [Boolean]
  def blank?; end

  # Collects the configs for the environment and optionally the specification
  # name passed in. To include replica configurations pass <tt>include_replicas: true</tt>.
  #
  # If a name is provided a single DatabaseConfig object will be
  # returned, otherwise an array of DatabaseConfig objects will be
  # returned that corresponds with the environment and type requested.
  #
  # ==== Options
  #
  # * <tt>env_name:</tt> The environment name. Defaults to +nil+ which will collect
  #   configs for all environments.
  # * <tt>name:</tt> The db config name (i.e. primary, animals, etc.). Defaults
  #   to +nil+. If no +env_name+ is specified the config for the default env and the
  #   passed +name+ will be returned.
  # * <tt>include_replicas:</tt> Determines whether to include replicas in
  #   the returned list. Most of the time we're only iterating over the write
  #   connection (i.e. migrations don't need to run for the write and read connection).
  #   Defaults to +false+.
  def configs_for(env_name: T.unsafe(nil), spec_name: T.unsafe(nil), name: T.unsafe(nil), include_replicas: T.unsafe(nil)); end

  # Returns the value of attribute configurations.
  def configurations; end

  # Returns the config hash that corresponds with the environment
  #
  # If the application has multiple databases +default_hash+ will
  # return the first config hash for the environment.
  #
  #   { database: "my_db", adapter: "mysql2" }
  def default_hash(*args, &block); end

  # Checks if the application's configurations are empty.
  #
  # Aliased to blank?
  #
  # @return [Boolean]
  def empty?; end

  # Returns a single DatabaseConfig object based on the requested environment.
  #
  # If the application has multiple databases +find_db_config+ will return
  # the first DatabaseConfig for the environment.
  def find_db_config(env); end

  # A primary configuration is one that is named primary or if there is
  # no primary, the first configuration for an environment will be treated
  # as primary. This is used as the "default" configuration and is used
  # when the application needs to treat one configuration differently. For
  # example, when Rails dumps the schema, the primary configuration's schema
  # file will be named `schema.rb` instead of `primary_schema.rb`.
  #
  # @return [Boolean]
  def primary?(name); end

  # Returns fully resolved connection, accepts hash, string or symbol.
  # Always returns a DatabaseConfiguration::DatabaseConfig
  #
  # == Examples
  #
  # Symbol representing current environment.
  #
  #   DatabaseConfigurations.new("production" => {}).resolve(:production)
  #   # => DatabaseConfigurations::HashConfig.new(env_name: "production", config: {})
  #
  # One layer deep hash of connection values.
  #
  #   DatabaseConfigurations.new({}).resolve("adapter" => "sqlite3")
  #   # => DatabaseConfigurations::HashConfig.new(config: {"adapter" => "sqlite3"})
  #
  # Connection URL.
  #
  #   DatabaseConfigurations.new({}).resolve("postgresql://localhost/foo")
  #   # => DatabaseConfigurations::UrlConfig.new(config: {"adapter" => "postgresql", "host" => "localhost", "database" => "foo"})
  def resolve(config); end

  # Returns the DatabaseConfigurations object as a Hash.
  def to_h(*args, &block); end

  private

  def build_configs(configs); end
  def build_configuration_sentence; end
  def build_db_config_from_hash(env_name, name, config); end
  def build_db_config_from_raw_config(env_name, name, config); end
  def build_db_config_from_string(env_name, name, config); end
  def default_env; end
  def env_with_configs(env = T.unsafe(nil)); end
  def environment_url_config(env, name, config); end
  def environment_value_for(name); end
  def merge_db_environment_variables(current_env, configs); end
  def resolve_symbol_connection(name); end
  def walk_configs(env_name, config); end
end

# Expands a connection string into a hash.
class ActiveRecord::DatabaseConfigurations::ConnectionUrlResolver
  # == Example
  #
  #   url = "postgresql://foo:bar@localhost:9000/foo_test?pool=5&timeout=3000"
  #   ConnectionUrlResolver.new(url).to_hash
  #   # => {
  #     adapter:  "postgresql",
  #     host:     "localhost",
  #     port:     9000,
  #     database: "foo_test",
  #     username: "foo",
  #     password: "bar",
  #     pool:     "5",
  #     timeout:  "3000"
  #   }
  #
  # @return [ConnectionUrlResolver] a new instance of ConnectionUrlResolver
  def initialize(url); end

  # Converts the given URL to a full connection hash.
  def to_hash; end

  private

  # Returns name of the database.
  def database_from_path; end

  # Converts the query parameters of the URI into a hash.
  #
  #   "localhost?pool=5&reaping_frequency=2"
  #   # => { pool: "5", reaping_frequency: "2" }
  #
  # returns empty hash if no query present.
  #
  #   "localhost"
  #   # => {}
  def query_hash; end

  def raw_config; end

  # Returns the value of attribute uri.
  def uri; end

  def uri_parser; end
end

# ActiveRecord::Base.configurations will return either a HashConfig or
# UrlConfig respectively. It will never return a DatabaseConfig object,
# as this is the parent class for the types of database configuration objects.
class ActiveRecord::DatabaseConfigurations::DatabaseConfig
  # @return [DatabaseConfig] a new instance of DatabaseConfig
  def initialize(env_name, name); end

  # @raise [NotImplementedError]
  def _database=(database); end

  # @raise [NotImplementedError]
  def adapter; end

  def adapter_method; end

  # @raise [NotImplementedError]
  def checkout_timeout; end

  # @raise [NotImplementedError]
  def config; end

  # @raise [NotImplementedError]
  def database; end

  def env_name; end

  # @return [Boolean]
  def for_current_env?; end

  # @raise [NotImplementedError]
  def host; end

  # @raise [NotImplementedError]
  def idle_timeout; end

  # @raise [NotImplementedError]
  def migrations_paths; end

  def name; end

  # Returns the value of attribute owner_name.
  def owner_name; end

  # Sets the attribute owner_name
  #
  # @param value the value to set the attribute owner_name to.
  def owner_name=(_arg0); end

  # @raise [NotImplementedError]
  def pool; end

  # @raise [NotImplementedError]
  def reaping_frequency; end

  # @raise [NotImplementedError]
  # @return [Boolean]
  def replica?; end

  # @raise [NotImplementedError]
  def schema_cache_path; end

  def spec_name(*args, &block); end
end

# A HashConfig object is created for each database configuration entry that
# is created from a hash.
#
# A hash config:
#
#   { "development" => { "database" => "db_name" } }
#
# Becomes:
#
#   #<ActiveRecord::DatabaseConfigurations::HashConfig:0x00007fd1acbded10
#     @env_name="development", @name="primary", @config={database: "db_name"}>
#
# ==== Options
#
# * <tt>:env_name</tt> - The Rails environment, i.e. "development".
# * <tt>:name</tt> - The db config name. In a standard two-tier
#   database configuration this will default to "primary". In a multiple
#   database three-tier database configuration this corresponds to the name
#   used in the second tier, for example "primary_readonly".
# * <tt>:config</tt> - The config hash. This is the hash that contains the
#   database adapter, name, and other important information for database
#   connections.
class ActiveRecord::DatabaseConfigurations::HashConfig < ::ActiveRecord::DatabaseConfigurations::DatabaseConfig
  # @return [HashConfig] a new instance of HashConfig
  def initialize(env_name, name, configuration_hash); end

  def _database=(database); end
  def adapter; end
  def checkout_timeout; end
  def config; end

  # Returns the value of attribute configuration_hash.
  def configuration_hash; end

  def database; end
  def host; end
  def idle_timeout; end

  # The migrations paths for a database configuration. If the
  # +migrations_paths+ key is present in the config, +migrations_paths+
  # will return its value.
  def migrations_paths; end

  def pool; end

  # +reaping_frequency+ is configurable mostly for historical reasons, but it could
  # also be useful if someone wants a very low +idle_timeout+.
  def reaping_frequency; end

  # Determines whether a database configuration is for a replica / readonly
  # connection. If the +replica+ key is present in the config, +replica?+ will
  # return +true+.
  #
  # @return [Boolean]
  def replica?; end

  # The path to the schema cache dump file for a database.
  # If omitted, the filename will be read from ENV or a
  # default will be derived.
  def schema_cache_path; end
end

class ActiveRecord::DatabaseConfigurations::InvalidConfigurationError < ::StandardError; end

# A UrlConfig object is created for each database configuration
# entry that is created from a URL. This can either be a URL string
# or a hash with a URL in place of the config hash.
#
# A URL config:
#
#   postgres://localhost/foo
#
# Becomes:
#
#   #<ActiveRecord::DatabaseConfigurations::UrlConfig:0x00007fdc3238f340
#     @env_name="default_env", @name="primary",
#     @config={adapter: "postgresql", database: "foo", host: "localhost"},
#     @url="postgres://localhost/foo">
#
# ==== Options
#
# * <tt>:env_name</tt> - The Rails environment, ie "development".
# * <tt>:name</tt> - The db config name. In a standard two-tier
#   database configuration this will default to "primary". In a multiple
#   database three-tier database configuration this corresponds to the name
#   used in the second tier, for example "primary_readonly".
# * <tt>:url</tt> - The database URL.
# * <tt>:config</tt> - The config hash. This is the hash that contains the
#   database adapter, name, and other important information for database
#   connections.
class ActiveRecord::DatabaseConfigurations::UrlConfig < ::ActiveRecord::DatabaseConfigurations::HashConfig
  # @return [UrlConfig] a new instance of UrlConfig
  def initialize(env_name, name, url, configuration_hash = T.unsafe(nil)); end

  # Returns the value of attribute url.
  def url; end

  private

  # Return a Hash that can be merged into the main config that represents
  # the passed in url
  def build_url_hash; end
end

# Deadlocked will be raised when a transaction is rolled
# back by the database when a deadlock is encountered.
class ActiveRecord::Deadlocked < ::ActiveRecord::TransactionRollbackError; end

# == Delegated types
#
# Class hierarchies can map to relational database tables in many ways. Active Record, for example, offers
# purely abstract classes, where the superclass doesn't persist any attributes, and single-table inheritance,
# where all attributes from all levels of the hierarchy are represented in a single table. Both have their
# places, but neither are without their drawbacks.
#
# The problem with purely abstract classes is that all concrete subclasses must persist all the shared
# attributes themselves in their own tables (also known as class-table inheritance). This makes it hard to
# do queries across the hierarchy. For example, imagine you have the following hierarchy:
#
#   Entry < ApplicationRecord
#   Message < Entry
#   Comment < Entry
#
# How do you show a feed that has both +Message+ and +Comment+ records, which can be easily paginated?
# Well, you can't! Messages are backed by a messages table and comments by a comments table. You can't
# pull from both tables at once and use a consistent OFFSET/LIMIT scheme.
#
# You can get around the pagination problem by using single-table inheritance, but now you're forced into
# a single mega table with all the attributes from all subclasses. No matter how divergent. If a Message
# has a subject, but the comment does not, well, now the comment does anyway! So STI works best when there's
# little divergence between the subclasses and their attributes.
#
# But there's a third way: Delegated types. With this approach, the "superclass" is a concrete class
# that is represented by its own table, where all the superclass attributes that are shared amongst all the
# "subclasses" are stored. And then each of the subclasses have their own individual tables for additional
# attributes that are particular to their implementation. This is similar to what's called multi-table
# inheritance in Django, but instead of actual inheritance, this approach uses delegation to form the
# hierarchy and share responsibilities.
#
# Let's look at that entry/message/comment example using delegated types:
#
#   # Schema: entries[ id, account_id, creator_id, created_at, updated_at, entryable_type, entryable_id ]
#   class Entry < ApplicationRecord
#     belongs_to :account
#     belongs_to :creator
#     delegated_type :entryable, types: %w[ Message Comment ]
#   end
#
#   module Entryable
#     extend ActiveSupport::Concern
#
#     included do
#       has_one :entry, as: :entryable, touch: true
#     end
#   end
#
#   # Schema: messages[ id, subject ]
#   class Message < ApplicationRecord
#     include Entryable
#     has_rich_text :content
#   end
#
#   # Schema: comments[ id, content ]
#   class Comment < ApplicationRecord
#     include Entryable
#   end
#
# As you can see, neither +Message+ nor +Comment+ are meant to stand alone. Crucial metadata for both classes
# resides in the +Entry+ "superclass". But the +Entry+ absolutely can stand alone in terms of querying capacity
# in particular. You can now easily do things like:
#
#   Account.entries.order(created_at: :desc).limit(50)
#
# Which is exactly what you want when displaying both comments and messages together. The entry itself can
# be rendered as its delegated type easily, like so:
#
#   # entries/_entry.html.erb
#   <%= render "entries/entryables/#{entry.entryable_name}", entry: entry %>
#
#   # entries/entryables/_message.html.erb
#   <div class="message">
#     Posted on <%= entry.created_at %> by <%= entry.creator.name %>: <%= entry.message.content %>
#   </div>
#
#   # entries/entryables/_comment.html.erb
#   <div class="comment">
#     <%= entry.creator.name %> said: <%= entry.comment.content %>
#   </div>
#
# == Sharing behavior with concerns and controllers
#
# The entry "superclass" also serves as a perfect place to put all that shared logic that applies to both
# messages and comments, and which acts primarily on the shared attributes. Imagine:
#
#   class Entry < ApplicationRecord
#     include Eventable, Forwardable, Redeliverable
#   end
#
# Which allows you to have controllers for things like +ForwardsController+ and +RedeliverableController+
# that both act on entries, and thus provide the shared functionality to both messages and comments.
#
# == Creating new records
#
# You create a new record that uses delegated typing by creating the delegator and delegatee at the same time,
# like so:
#
#   Entry.create! entryable: Comment.new(content: "Hello!"), creator: Current.user
#
# If you need more complicated composition, or you need to perform dependent validation, you should build a factory
# method or class to take care of the complicated needs. This could be as simple as:
#
#   class Entry < ApplicationRecord
#     def self.create_with_comment(content, creator: Current.user)
#       create! entryable: Comment.new(content: content), creator: creator
#     end
#   end
#
# == Adding further delegation
#
# The delegated type shouldn't just answer the question of what the underlying class is called. In fact, that's
# an anti-pattern most of the time. The reason you're building this hierarchy is to take advantage of polymorphism.
# So here's a simple example of that:
#
#   class Entry < ApplicationRecord
#     delegated_type :entryable, types: %w[ Message Comment ]
#     delegate :title, to: :entryable
#   end
#
#   class Message < ApplicationRecord
#     def title
#       subject
#     end
#   end
#
#   class Comment < ApplicationRecord
#     def title
#       content.truncate(20)
#     end
#   end
#
# Now you can list a bunch of entries, call +Entry#title+, and polymorphism will provide you with the answer.
module ActiveRecord::DelegatedType
  # Defines this as a class that'll delegate its type for the passed +role+ to the class references in +types+.
  # That'll create a polymorphic +belongs_to+ relationship to that +role+, and it'll add all the delegated
  # type convenience methods:
  #
  #   class Entry < ApplicationRecord
  #     delegated_type :entryable, types: %w[ Message Comment ], dependent: :destroy
  #   end
  #
  #   Entry#entryable_class # => +Message+ or +Comment+
  #   Entry#entryable_name  # => "message" or "comment"
  #   Entry.messages        # => Entry.where(entryable_type: "Message")
  #   Entry#message?        # => true when entryable_type == "Message"
  #   Entry#message         # => returns the message record, when entryable_type == "Message", otherwise nil
  #   Entry#message_id      # => returns entryable_id, when entryable_type == "Message", otherwise nil
  #   Entry.comments        # => Entry.where(entryable_type: "Comment")
  #   Entry#comment?        # => true when entryable_type == "Comment"
  #   Entry#comment         # => returns the comment record, when entryable_type == "Comment", otherwise nil
  #   Entry#comment_id      # => returns entryable_id, when entryable_type == "Comment", otherwise nil
  #
  # The +options+ are passed directly to the +belongs_to+ call, so this is where you declare +dependent+ etc.
  #
  # You can also declare namespaced types:
  #
  #   class Entry < ApplicationRecord
  #     delegated_type :entryable, types: %w[ Message Comment Access::NoticeMessage ], dependent: :destroy
  #   end
  #
  #   Entry.access_notice_messages
  #   entry.access_notice_message
  #   entry.access_notice_message?
  def delegated_type(role, types:, **options); end

  private

  def define_delegated_type_methods(role, types:); end
end

module ActiveRecord::Delegation
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::ActiveRecord::Delegation::ClassMethods

  def &(*_arg0, &_arg1); end
  def +(*_arg0, &_arg1); end
  def -(*_arg0, &_arg1); end
  def [](*_arg0, &_arg1); end
  def as_json(*_arg0, &_arg1); end
  def compact(*_arg0, &_arg1); end
  def connection(*_arg0, &_arg1); end
  def each(*_arg0, &_arg1); end
  def encode_with(*_arg0, &_arg1); end
  def in_groups(*_arg0, &_arg1); end
  def in_groups_of(*_arg0, &_arg1); end
  def index(*_arg0, &_arg1); end
  def join(*_arg0, &_arg1); end
  def length(*_arg0, &_arg1); end
  def primary_key(*_arg0, &_arg1); end
  def reverse(*_arg0, &_arg1); end
  def rindex(*_arg0, &_arg1); end
  def rotate(*_arg0, &_arg1); end
  def sample(*_arg0, &_arg1); end
  def shuffle(*_arg0, &_arg1); end
  def slice(*_arg0, &_arg1); end
  def split(*_arg0, &_arg1); end
  def to_formatted_s(*_arg0, &_arg1); end
  def to_sentence(*_arg0, &_arg1); end
  def to_xml(*_arg0, &_arg1); end
  def |(*_arg0, &_arg1); end

  private

  # @return [Boolean]
  def respond_to_missing?(method, _); end
end

module ActiveRecord::Delegation::ClassMethods
  def create(klass, *args, **kwargs); end

  private

  def relation_class_for(klass); end
end

module ActiveRecord::Delegation::ClassSpecificRelation
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::ActiveRecord::Delegation::ClassSpecificRelation::ClassMethods

  private

  def method_missing(method, *args, &block); end
end

module ActiveRecord::Delegation::ClassSpecificRelation::ClassMethods
  def name; end
end

module ActiveRecord::Delegation::DelegateCache
  def generate_relation_method(method); end
  def inherited(child_class); end
  def initialize_relation_delegate_cache; end
  def relation_delegate_class(klass); end

  protected

  def include_relation_methods(delegate); end

  private

  def generated_relation_methods; end
end

class ActiveRecord::Delegation::GeneratedRelationMethods < ::Module
  include ::Mutex_m

  def generate_method(method); end
  def lock; end
  def locked?; end
  def synchronize(&block); end
  def try_lock; end
  def unlock; end
end

# This error is raised when trying to destroy a parent instance in N:1 or 1:1 associations
# (has_many, has_one) when there is at least 1 child associated instance.
# ex: if @project.tasks.size > 0, DeleteRestrictionError will be raised when trying to destroy @project
class ActiveRecord::DeleteRestrictionError < ::ActiveRecord::ActiveRecordError
  # @return [DeleteRestrictionError] a new instance of DeleteRestrictionError
  def initialize(name = T.unsafe(nil)); end
end

class ActiveRecord::DestroyAssociationAsyncError < ::StandardError; end

# Job to destroy the records associated with a destroyed record in background.
class ActiveRecord::DestroyAssociationAsyncJob < ::ActiveJob::Base
  def perform(owner_model_name: T.unsafe(nil), owner_id: T.unsafe(nil), association_class: T.unsafe(nil), association_ids: T.unsafe(nil), association_primary_key_column: T.unsafe(nil), ensuring_owner_was_method: T.unsafe(nil)); end

  private

  # @return [Boolean]
  def owner_destroyed?(owner, ensuring_owner_was_method); end

  class << self
    def queue_name; end
    def rescue_handlers; end
  end
end

class ActiveRecord::DuplicateMigrationNameError < ::ActiveRecord::MigrationError
  # @return [DuplicateMigrationNameError] a new instance of DuplicateMigrationNameError
  def initialize(name = T.unsafe(nil)); end
end

class ActiveRecord::DuplicateMigrationVersionError < ::ActiveRecord::MigrationError
  # @return [DuplicateMigrationVersionError] a new instance of DuplicateMigrationVersionError
  def initialize(version = T.unsafe(nil)); end
end

module ActiveRecord::DynamicMatchers
  private

  def method_missing(name, *arguments, &block); end

  # @return [Boolean]
  def respond_to_missing?(name, _); end
end

class ActiveRecord::DynamicMatchers::FindBy < ::ActiveRecord::DynamicMatchers::Method
  def finder; end

  class << self
    def prefix; end
  end
end

class ActiveRecord::DynamicMatchers::FindByBang < ::ActiveRecord::DynamicMatchers::Method
  def finder; end

  class << self
    def prefix; end
    def suffix; end
  end
end

class ActiveRecord::DynamicMatchers::Method
  # @return [Method] a new instance of Method
  def initialize(model, method_name); end

  # Returns the value of attribute attribute_names.
  def attribute_names; end

  def define; end

  # Returns the value of attribute model.
  def model; end

  # Returns the value of attribute name.
  def name; end

  # @return [Boolean]
  def valid?; end

  private

  # Given that the parameters starts with `_`, the finder needs to use the
  # same parameter name.
  def attributes_hash; end

  def body; end

  # @raise [NotImplementedError]
  def finder; end

  # The parameters in the signature may have reserved Ruby words, in order
  # to prevent errors, we start each param name with `_`.
  def signature; end

  class << self
    def match(model, name); end

    # Returns the value of attribute matchers.
    def matchers; end

    def pattern; end

    # @raise [NotImplementedError]
    def prefix; end

    def suffix; end
  end
end

# This error is raised when trying to eager load a polymorphic association using a JOIN.
# Eager loading polymorphic associations is only possible with
# {ActiveRecord::Relation#preload}[rdoc-ref:QueryMethods#preload].
class ActiveRecord::EagerLoadPolymorphicError < ::ActiveRecord::ActiveRecordError
  # @return [EagerLoadPolymorphicError] a new instance of EagerLoadPolymorphicError
  def initialize(reflection = T.unsafe(nil)); end
end

# Declare an enum attribute where the values map to integers in the database,
# but can be queried by name. Example:
#
#   class Conversation < ActiveRecord::Base
#     enum status: [ :active, :archived ]
#   end
#
#   # conversation.update! status: 0
#   conversation.active!
#   conversation.active? # => true
#   conversation.status  # => "active"
#
#   # conversation.update! status: 1
#   conversation.archived!
#   conversation.archived? # => true
#   conversation.status    # => "archived"
#
#   # conversation.status = 1
#   conversation.status = "archived"
#
#   conversation.status = nil
#   conversation.status.nil? # => true
#   conversation.status      # => nil
#
# Scopes based on the allowed values of the enum field will be provided
# as well. With the above example:
#
#   Conversation.active
#   Conversation.not_active
#   Conversation.archived
#   Conversation.not_archived
#
# Of course, you can also query them directly if the scopes don't fit your
# needs:
#
#   Conversation.where(status: [:active, :archived])
#   Conversation.where.not(status: :active)
#
# Defining scopes can be disabled by setting +:_scopes+ to +false+.
#
#   class Conversation < ActiveRecord::Base
#     enum status: [ :active, :archived ], _scopes: false
#   end
#
# You can set the default enum value by setting +:_default+, like:
#
#   class Conversation < ActiveRecord::Base
#     enum status: [ :active, :archived ], _default: "active"
#   end
#
#   conversation = Conversation.new
#   conversation.status # => "active"
#
# Finally, it's also possible to explicitly map the relation between attribute and
# database integer with a hash:
#
#   class Conversation < ActiveRecord::Base
#     enum status: { active: 0, archived: 1 }
#   end
#
# Note that when an array is used, the implicit mapping from the values to database
# integers is derived from the order the values appear in the array. In the example,
# <tt>:active</tt> is mapped to +0+ as it's the first element, and <tt>:archived</tt>
# is mapped to +1+. In general, the +i+-th element is mapped to <tt>i-1</tt> in the
# database.
#
# Therefore, once a value is added to the enum array, its position in the array must
# be maintained, and new values should only be added to the end of the array. To
# remove unused values, the explicit hash syntax should be used.
#
# In rare circumstances you might need to access the mapping directly.
# The mappings are exposed through a class method with the pluralized attribute
# name, which return the mapping in a +HashWithIndifferentAccess+:
#
#   Conversation.statuses[:active]    # => 0
#   Conversation.statuses["archived"] # => 1
#
# Use that class method when you need to know the ordinal value of an enum.
# For example, you can use that when manually building SQL strings:
#
#   Conversation.where("status <> ?", Conversation.statuses[:archived])
#
# You can use the +:_prefix+ or +:_suffix+ options when you need to define
# multiple enums with same values. If the passed value is +true+, the methods
# are prefixed/suffixed with the name of the enum. It is also possible to
# supply a custom value:
#
#   class Conversation < ActiveRecord::Base
#     enum status: [:active, :archived], _suffix: true
#     enum comments_status: [:active, :inactive], _prefix: :comments
#   end
#
# With the above example, the bang and predicate methods along with the
# associated scopes are now prefixed and/or suffixed accordingly:
#
#   conversation.active_status!
#   conversation.archived_status? # => false
#
#   conversation.comments_inactive!
#   conversation.comments_active? # => false
module ActiveRecord::Enum
  def enum(definitions); end
  def inherited(base); end

  private

  def _enum_methods_module; end
  def assert_valid_enum_definition_values(values); end
  def detect_enum_conflict!(enum_name, method_name, klass_method = T.unsafe(nil)); end
  def detect_negative_enum_conditions!(method_names); end

  # @raise [ArgumentError]
  def raise_conflict_error(enum_name, method_name, type: T.unsafe(nil), source: T.unsafe(nil)); end

  class << self
    def extended(base); end
  end
end

ActiveRecord::Enum::ENUM_CONFLICT_MESSAGE = T.let(T.unsafe(nil), String)

class ActiveRecord::Enum::EnumMethods < ::Module
  # @return [EnumMethods] a new instance of EnumMethods
  def initialize(klass); end

  private

  def define_enum_methods(name, value_method_name, value, enum_scopes); end

  # Returns the value of attribute klass.
  def klass; end
end

class ActiveRecord::Enum::EnumType < ::ActiveModel::Type::Value
  # @return [EnumType] a new instance of EnumType
  def initialize(name, mapping, subtype); end

  def assert_valid_value(value); end
  def cast(value); end
  def deserialize(value); end
  def serialize(value); end

  # Returns the value of attribute subtype.
  def subtype; end

  def type(*_arg0, &_arg1); end

  private

  # Returns the value of attribute mapping.
  def mapping; end

  # Returns the value of attribute name.
  def name; end
end

class ActiveRecord::EnvironmentMismatchError < ::ActiveRecord::ActiveRecordError
  # @return [EnvironmentMismatchError] a new instance of EnvironmentMismatchError
  def initialize(current: T.unsafe(nil), stored: T.unsafe(nil)); end
end

class ActiveRecord::EnvironmentStorageError < ::ActiveRecord::ActiveRecordError
  # @return [EnvironmentStorageError] a new instance of EnvironmentStorageError
  def initialize; end
end

# Raised when a pool was unable to get ahold of all its connections
# to perform a "group" action such as
# {ActiveRecord::Base.connection_pool.disconnect!}[rdoc-ref:ConnectionAdapters::ConnectionPool#disconnect!]
# or {ActiveRecord::Base.clear_reloadable_connections!}[rdoc-ref:ConnectionAdapters::ConnectionHandler#clear_reloadable_connections!].
class ActiveRecord::ExclusiveConnectionTimeoutError < ::ActiveRecord::ConnectionTimeoutError; end

module ActiveRecord::Explain
  # Executes the block with the collect flag enabled. Queries are collected
  # asynchronously by the subscriber and returned.
  def collecting_queries_for_explain; end

  # Makes the adapter execute EXPLAIN for the tuples of queries and bindings.
  # Returns a formatted string ready to be logged.
  def exec_explain(queries); end

  private

  def render_bind(attr); end
end

# This is a thread locals registry for EXPLAIN. For example
#
#   ActiveRecord::ExplainRegistry.queries
#
# returns the collected queries local to the current thread.
#
# See the documentation of ActiveSupport::PerThreadRegistry
# for further details.
class ActiveRecord::ExplainRegistry
  extend ::ActiveSupport::PerThreadRegistry

  # @return [ExplainRegistry] a new instance of ExplainRegistry
  def initialize; end

  # Returns the value of attribute collect.
  def collect; end

  # Sets the attribute collect
  #
  # @param value the value to set the attribute collect to.
  def collect=(_arg0); end

  # @return [Boolean]
  def collect?; end

  # Returns the value of attribute queries.
  def queries; end

  # Sets the attribute queries
  #
  # @param value the value to set the attribute queries to.
  def queries=(_arg0); end

  def reset; end
end

class ActiveRecord::ExplainSubscriber
  def finish(name, id, payload); end

  # @return [Boolean]
  def ignore_payload?(payload); end

  def start(name, id, payload); end
end

ActiveRecord::ExplainSubscriber::EXPLAINED_SQLS = T.let(T.unsafe(nil), Regexp)

# SCHEMA queries cannot be EXPLAINed, also we do not want to run EXPLAIN on
# our own EXPLAINs no matter how loopingly beautiful that would be.
#
# On the other hand, we want to monitor the performance of our real database
# queries, not the performance of the access to the query cache.
ActiveRecord::ExplainSubscriber::IGNORED_PAYLOADS = T.let(T.unsafe(nil), Array)

module ActiveRecord::FinderMethods
  # Returns true if a record exists in the table that matches the +id+ or
  # conditions given, or false otherwise. The argument can take six forms:
  #
  # * Integer - Finds the record with this primary key.
  # * String - Finds the record with a primary key corresponding to this
  #   string (such as <tt>'5'</tt>).
  # * Array - Finds the record that matches these +where+-style conditions
  #   (such as <tt>['name LIKE ?', "%#{query}%"]</tt>).
  # * Hash - Finds the record that matches these +where+-style conditions
  #   (such as <tt>{name: 'David'}</tt>).
  # * +false+ - Returns always +false+.
  # * No args - Returns +false+ if the relation is empty, +true+ otherwise.
  #
  # For more information about specifying conditions as a hash or array,
  # see the Conditions section in the introduction to ActiveRecord::Base.
  #
  # Note: You can't pass in a condition as a string (like <tt>name =
  # 'Jamie'</tt>), since it would be sanitized and then queried against
  # the primary key column, like <tt>id = 'name = \'Jamie\''</tt>.
  #
  #   Person.exists?(5)
  #   Person.exists?('5')
  #   Person.exists?(['name LIKE ?', "%#{query}%"])
  #   Person.exists?(id: [1, 4, 8])
  #   Person.exists?(name: 'David')
  #   Person.exists?(false)
  #   Person.exists?
  #   Person.where(name: 'Spartacus', rating: 4).exists?
  #
  # @return [Boolean]
  def exists?(conditions = T.unsafe(nil)); end

  # Find the fifth record.
  # If no order is defined it will order by primary key.
  #
  #   Person.fifth # returns the fifth object fetched by SELECT * FROM people
  #   Person.offset(3).fifth # returns the fifth object from OFFSET 3 (which is OFFSET 7)
  #   Person.where(["user_name = :u", { u: user_name }]).fifth
  def fifth; end

  # Same as #fifth but raises ActiveRecord::RecordNotFound if no record
  # is found.
  def fifth!; end

  # Find by id - This can either be a specific id (1), a list of ids (1, 5, 6), or an array of ids ([5, 6, 10]).
  # If one or more records cannot be found for the requested ids, then ActiveRecord::RecordNotFound will be raised.
  # If the primary key is an integer, find by id coerces its arguments by using +to_i+.
  #
  #   Person.find(1)          # returns the object for ID = 1
  #   Person.find("1")        # returns the object for ID = 1
  #   Person.find("31-sarah") # returns the object for ID = 31
  #   Person.find(1, 2, 6)    # returns an array for objects with IDs in (1, 2, 6)
  #   Person.find([7, 17])    # returns an array for objects with IDs in (7, 17)
  #   Person.find([1])        # returns an array for the object with ID = 1
  #   Person.where("administrator = 1").order("created_on DESC").find(1)
  #
  # NOTE: The returned records are in the same order as the ids you provide.
  # If you want the results to be sorted by database, you can use ActiveRecord::QueryMethods#where
  # method and provide an explicit ActiveRecord::QueryMethods#order option.
  # But ActiveRecord::QueryMethods#where method doesn't raise ActiveRecord::RecordNotFound.
  #
  # ==== Find with lock
  #
  # Example for find with a lock: Imagine two concurrent transactions:
  # each will read <tt>person.visits == 2</tt>, add 1 to it, and save, resulting
  # in two saves of <tt>person.visits = 3</tt>. By locking the row, the second
  # transaction has to wait until the first is finished; we get the
  # expected <tt>person.visits == 4</tt>.
  #
  #   Person.transaction do
  #     person = Person.lock(true).find(1)
  #     person.visits += 1
  #     person.save!
  #   end
  #
  # ==== Variations of #find
  #
  #   Person.where(name: 'Spartacus', rating: 4)
  #   # returns a chainable list (which can be empty).
  #
  #   Person.find_by(name: 'Spartacus', rating: 4)
  #   # returns the first item or nil.
  #
  #   Person.find_or_initialize_by(name: 'Spartacus', rating: 4)
  #   # returns the first item or returns a new instance (requires you call .save to persist against the database).
  #
  #   Person.find_or_create_by(name: 'Spartacus', rating: 4)
  #   # returns the first item or creates it and returns it.
  #
  # ==== Alternatives for #find
  #
  #   Person.where(name: 'Spartacus', rating: 4).exists?(conditions = :none)
  #   # returns a boolean indicating if any record with the given conditions exist.
  #
  #   Person.where(name: 'Spartacus', rating: 4).select("field1, field2, field3")
  #   # returns a chainable list of instances with only the mentioned fields.
  #
  #   Person.where(name: 'Spartacus', rating: 4).ids
  #   # returns an Array of ids.
  #
  #   Person.where(name: 'Spartacus', rating: 4).pluck(:field1, :field2)
  #   # returns an Array of the required fields.
  def find(*args); end

  # Finds the first record matching the specified conditions. There
  # is no implied ordering so if order matters, you should specify it
  # yourself.
  #
  # If no record is found, returns <tt>nil</tt>.
  #
  #   Post.find_by name: 'Spartacus', rating: 4
  #   Post.find_by "published_at < ?", 2.weeks.ago
  def find_by(arg, *args); end

  # Like #find_by, except that if no record is found, raises
  # an ActiveRecord::RecordNotFound error.
  def find_by!(arg, *args); end

  # Find the first record (or first N records if a parameter is supplied).
  # If no order is defined it will order by primary key.
  #
  #   Person.first # returns the first object fetched by SELECT * FROM people ORDER BY people.id LIMIT 1
  #   Person.where(["user_name = ?", user_name]).first
  #   Person.where(["user_name = :u", { u: user_name }]).first
  #   Person.order("created_on DESC").offset(5).first
  #   Person.first(3) # returns the first three objects fetched by SELECT * FROM people ORDER BY people.id LIMIT 3
  def first(limit = T.unsafe(nil)); end

  # Same as #first but raises ActiveRecord::RecordNotFound if no record
  # is found. Note that #first! accepts no arguments.
  def first!; end

  # Find the forty-second record. Also known as accessing "the reddit".
  # If no order is defined it will order by primary key.
  #
  #   Person.forty_two # returns the forty-second object fetched by SELECT * FROM people
  #   Person.offset(3).forty_two # returns the forty-second object from OFFSET 3 (which is OFFSET 44)
  #   Person.where(["user_name = :u", { u: user_name }]).forty_two
  def forty_two; end

  # Same as #forty_two but raises ActiveRecord::RecordNotFound if no record
  # is found.
  def forty_two!; end

  # Find the fourth record.
  # If no order is defined it will order by primary key.
  #
  #   Person.fourth # returns the fourth object fetched by SELECT * FROM people
  #   Person.offset(3).fourth # returns the fourth object from OFFSET 3 (which is OFFSET 6)
  #   Person.where(["user_name = :u", { u: user_name }]).fourth
  def fourth; end

  # Same as #fourth but raises ActiveRecord::RecordNotFound if no record
  # is found.
  def fourth!; end

  # Returns true if the relation contains the given record or false otherwise.
  #
  # No query is performed if the relation is loaded; the given record is
  # compared to the records in memory. If the relation is unloaded, an
  # efficient existence query is performed, as in #exists?.
  #
  # @return [Boolean]
  def include?(record); end

  # Find the last record (or last N records if a parameter is supplied).
  # If no order is defined it will order by primary key.
  #
  #   Person.last # returns the last object fetched by SELECT * FROM people
  #   Person.where(["user_name = ?", user_name]).last
  #   Person.order("created_on DESC").offset(5).last
  #   Person.last(3) # returns the last three objects fetched by SELECT * FROM people.
  #
  # Take note that in that last case, the results are sorted in ascending order:
  #
  #   [#<Person id:2>, #<Person id:3>, #<Person id:4>]
  #
  # and not:
  #
  #   [#<Person id:4>, #<Person id:3>, #<Person id:2>]
  def last(limit = T.unsafe(nil)); end

  # Same as #last but raises ActiveRecord::RecordNotFound if no record
  # is found. Note that #last! accepts no arguments.
  def last!; end

  # Returns true if the relation contains the given record or false otherwise.
  #
  # No query is performed if the relation is loaded; the given record is
  # compared to the records in memory. If the relation is unloaded, an
  # efficient existence query is performed, as in #exists?.
  #
  # @return [Boolean]
  def member?(record); end

  # This method is called whenever no records are found with either a single
  # id or multiple ids and raises an ActiveRecord::RecordNotFound exception.
  #
  # The error message is different depending on whether a single id or
  # multiple ids are provided. If multiple ids are provided, then the number
  # of results obtained should be provided in the +result_size+ argument and
  # the expected number of results should be provided in the +expected_size+
  # argument.
  def raise_record_not_found_exception!(ids = T.unsafe(nil), result_size = T.unsafe(nil), expected_size = T.unsafe(nil), key = T.unsafe(nil), not_found_ids = T.unsafe(nil)); end

  # Find the second record.
  # If no order is defined it will order by primary key.
  #
  #   Person.second # returns the second object fetched by SELECT * FROM people
  #   Person.offset(3).second # returns the second object from OFFSET 3 (which is OFFSET 4)
  #   Person.where(["user_name = :u", { u: user_name }]).second
  def second; end

  # Same as #second but raises ActiveRecord::RecordNotFound if no record
  # is found.
  def second!; end

  # Find the second-to-last record.
  # If no order is defined it will order by primary key.
  #
  #   Person.second_to_last # returns the second-to-last object fetched by SELECT * FROM people
  #   Person.offset(3).second_to_last # returns the second-to-last object from OFFSET 3
  #   Person.where(["user_name = :u", { u: user_name }]).second_to_last
  def second_to_last; end

  # Same as #second_to_last but raises ActiveRecord::RecordNotFound if no record
  # is found.
  def second_to_last!; end

  # Gives a record (or N records if a parameter is supplied) without any implied
  # order. The order will depend on the database implementation.
  # If an order is supplied it will be respected.
  #
  #   Person.take # returns an object fetched by SELECT * FROM people LIMIT 1
  #   Person.take(5) # returns 5 objects fetched by SELECT * FROM people LIMIT 5
  #   Person.where(["name LIKE '%?'", name]).take
  def take(limit = T.unsafe(nil)); end

  # Same as #take but raises ActiveRecord::RecordNotFound if no record
  # is found. Note that #take! accepts no arguments.
  def take!; end

  # Find the third record.
  # If no order is defined it will order by primary key.
  #
  #   Person.third # returns the third object fetched by SELECT * FROM people
  #   Person.offset(3).third # returns the third object from OFFSET 3 (which is OFFSET 5)
  #   Person.where(["user_name = :u", { u: user_name }]).third
  def third; end

  # Same as #third but raises ActiveRecord::RecordNotFound if no record
  # is found.
  def third!; end

  # Find the third-to-last record.
  # If no order is defined it will order by primary key.
  #
  #   Person.third_to_last # returns the third-to-last object fetched by SELECT * FROM people
  #   Person.offset(3).third_to_last # returns the third-to-last object from OFFSET 3
  #   Person.where(["user_name = :u", { u: user_name }]).third_to_last
  def third_to_last; end

  # Same as #third_to_last but raises ActiveRecord::RecordNotFound if no record
  # is found.
  def third_to_last!; end

  private

  def apply_join_dependency(eager_loading: T.unsafe(nil)); end
  def check_reorder_deprecation; end
  def construct_relation_for_exists(conditions); end
  def find_last(limit); end
  def find_nth(index); end
  def find_nth_from_last(index); end
  def find_nth_with_limit(index, limit); end
  def find_one(id); end
  def find_some(ids); end
  def find_some_ordered(ids); end
  def find_take; end
  def find_take_with_limit(limit); end

  # @raise [UnknownPrimaryKey]
  def find_with_ids(*ids); end

  def limited_ids_for(relation); end
  def ordered_relation; end

  # @return [Boolean]
  def using_limitable_reflections?(reflections); end
end

ActiveRecord::FinderMethods::ONE_AS_ONE = T.let(T.unsafe(nil), String)

class ActiveRecord::Fixture
  include ::Enumerable

  # @return [Fixture] a new instance of Fixture
  def initialize(fixture, model_class); end

  def [](key); end
  def class_name; end
  def each; end

  # @raise [FixtureClassNotFound]
  def find; end

  # Returns the value of attribute fixture.
  def fixture; end

  # Returns the value of attribute model_class.
  def model_class; end

  # Returns the value of attribute fixture.
  def to_hash; end
end

class ActiveRecord::Fixture::FixtureError < ::StandardError; end
class ActiveRecord::Fixture::FormatError < ::ActiveRecord::Fixture::FixtureError; end
class ActiveRecord::FixtureClassNotFound < ::ActiveRecord::ActiveRecordError; end

# \Fixtures are a way of organizing data that you want to test against; in short, sample data.
#
# They are stored in YAML files, one file per model, which are placed in the directory
# appointed by <tt>ActiveSupport::TestCase.fixture_path=(path)</tt> (this is automatically
# configured for Rails, so you can just put your files in <tt><your-rails-app>/test/fixtures/</tt>).
# The fixture file ends with the +.yml+ file extension, for example:
# <tt><your-rails-app>/test/fixtures/web_sites.yml</tt>).
#
# The format of a fixture file looks like this:
#
#   rubyonrails:
#     id: 1
#     name: Ruby on Rails
#     url: http://www.rubyonrails.org
#
#   google:
#     id: 2
#     name: Google
#     url: http://www.google.com
#
# This fixture file includes two fixtures. Each YAML fixture (ie. record) is given a name and
# is followed by an indented list of key/value pairs in the "key: value" format. Records are
# separated by a blank line for your viewing pleasure.
#
# Note: Fixtures are unordered. If you want ordered fixtures, use the omap YAML type.
# See https://yaml.org/type/omap.html
# for the specification. You will need ordered fixtures when you have foreign key constraints
# on keys in the same table. This is commonly needed for tree structures. Example:
#
#    --- !omap
#    - parent:
#        id:         1
#        parent_id:  NULL
#        title:      Parent
#    - child:
#        id:         2
#        parent_id:  1
#        title:      Child
#
# = Using Fixtures in Test Cases
#
# Since fixtures are a testing construct, we use them in our unit and functional tests. There
# are two ways to use the fixtures, but first let's take a look at a sample unit test:
#
#   require "test_helper"
#
#   class WebSiteTest < ActiveSupport::TestCase
#     test "web_site_count" do
#       assert_equal 2, WebSite.count
#     end
#   end
#
# By default, +test_helper.rb+ will load all of your fixtures into your test
# database, so this test will succeed.
#
# The testing environment will automatically load all the fixtures into the database before each
# test. To ensure consistent data, the environment deletes the fixtures before running the load.
#
# In addition to being available in the database, the fixture's data may also be accessed by
# using a special dynamic method, which has the same name as the model.
#
# Passing in a fixture name to this dynamic method returns the fixture matching this name:
#
#   test "find one" do
#     assert_equal "Ruby on Rails", web_sites(:rubyonrails).name
#   end
#
# Passing in multiple fixture names returns all fixtures matching these names:
#
#   test "find all by name" do
#     assert_equal 2, web_sites(:rubyonrails, :google).length
#   end
#
# Passing in no arguments returns all fixtures:
#
#   test "find all" do
#     assert_equal 2, web_sites.length
#   end
#
# Passing in any fixture name that does not exist will raise <tt>StandardError</tt>:
#
#   test "find by name that does not exist" do
#     assert_raise(StandardError) { web_sites(:reddit) }
#   end
#
# Alternatively, you may enable auto-instantiation of the fixture data. For instance, take the
# following tests:
#
#   test "find_alt_method_1" do
#     assert_equal "Ruby on Rails", @web_sites['rubyonrails']['name']
#   end
#
#   test "find_alt_method_2" do
#     assert_equal "Ruby on Rails", @rubyonrails.name
#   end
#
# In order to use these methods to access fixtured data within your test cases, you must specify one of the
# following in your ActiveSupport::TestCase-derived class:
#
# - to fully enable instantiated fixtures (enable alternate methods #1 and #2 above)
#     self.use_instantiated_fixtures = true
#
# - create only the hash for the fixtures, do not 'find' each instance (enable alternate method #1 only)
#     self.use_instantiated_fixtures = :no_instances
#
# Using either of these alternate methods incurs a performance hit, as the fixtured data must be fully
# traversed in the database to create the fixture hash and/or instance variables. This is expensive for
# large sets of fixtured data.
#
# = Dynamic fixtures with ERB
#
# Sometimes you don't care about the content of the fixtures as much as you care about the volume.
# In these cases, you can mix ERB in with your YAML fixtures to create a bunch of fixtures for load
# testing, like:
#
#   <% 1.upto(1000) do |i| %>
#   fix_<%= i %>:
#     id: <%= i %>
#     name: guy_<%= i %>
#   <% end %>
#
# This will create 1000 very simple fixtures.
#
# Using ERB, you can also inject dynamic values into your fixtures with inserts like
# <tt><%= Date.today.strftime("%Y-%m-%d") %></tt>.
# This is however a feature to be used with some caution. The point of fixtures are that they're
# stable units of predictable sample data. If you feel that you need to inject dynamic values, then
# perhaps you should reexamine whether your application is properly testable. Hence, dynamic values
# in fixtures are to be considered a code smell.
#
# Helper methods defined in a fixture will not be available in other fixtures, to prevent against
# unwanted inter-test dependencies. Methods used by multiple fixtures should be defined in a module
# that is included in ActiveRecord::FixtureSet.context_class.
#
# - define a helper method in <tt>test_helper.rb</tt>
#     module FixtureFileHelpers
#       def file_sha(path)
#         Digest::SHA2.hexdigest(File.read(Rails.root.join('test/fixtures', path)))
#       end
#     end
#     ActiveRecord::FixtureSet.context_class.include FixtureFileHelpers
#
# - use the helper method in a fixture
#     photo:
#       name: kitten.png
#       sha: <%= file_sha 'files/kitten.png' %>
#
# = Transactional Tests
#
# Test cases can use begin+rollback to isolate their changes to the database instead of having to
# delete+insert for every test case.
#
#   class FooTest < ActiveSupport::TestCase
#     self.use_transactional_tests = true
#
#     test "godzilla" do
#       assert_not_empty Foo.all
#       Foo.destroy_all
#       assert_empty Foo.all
#     end
#
#     test "godzilla aftermath" do
#       assert_not_empty Foo.all
#     end
#   end
#
# If you preload your test database with all fixture data (probably by running <tt>bin/rails db:fixtures:load</tt>)
# and use transactional tests, then you may omit all fixtures declarations in your test cases since
# all the data's already there and every case rolls back its changes.
#
# In order to use instantiated fixtures with preloaded data, set +self.pre_loaded_fixtures+ to
# true. This will provide access to fixture data for every table that has been loaded through
# fixtures (depending on the value of +use_instantiated_fixtures+).
#
# When *not* to use transactional tests:
#
# 1. You're testing whether a transaction works correctly. Nested transactions don't commit until
#    all parent transactions commit, particularly, the fixtures transaction which is begun in setup
#    and rolled back in teardown. Thus, you won't be able to verify
#    the results of your transaction until Active Record supports nested transactions or savepoints (in progress).
# 2. Your database does not support transactions. Every Active Record database supports transactions except MySQL MyISAM.
#    Use InnoDB, MaxDB, or NDB instead.
#
# = Advanced Fixtures
#
# Fixtures that don't specify an ID get some extra features:
#
# * Stable, autogenerated IDs
# * Label references for associations (belongs_to, has_one, has_many)
# * HABTM associations as inline lists
#
# There are some more advanced features available even if the id is specified:
#
# * Autofilled timestamp columns
# * Fixture label interpolation
# * Support for YAML defaults
#
# == Stable, Autogenerated IDs
#
# Here, have a monkey fixture:
#
#   george:
#     id: 1
#     name: George the Monkey
#
#   reginald:
#     id: 2
#     name: Reginald the Pirate
#
# Each of these fixtures has two unique identifiers: one for the database
# and one for the humans. Why don't we generate the primary key instead?
# Hashing each fixture's label yields a consistent ID:
#
#   george: # generated id: 503576764
#     name: George the Monkey
#
#   reginald: # generated id: 324201669
#     name: Reginald the Pirate
#
# Active Record looks at the fixture's model class, discovers the correct
# primary key, and generates it right before inserting the fixture
# into the database.
#
# The generated ID for a given label is constant, so we can discover
# any fixture's ID without loading anything, as long as we know the label.
#
# == Label references for associations (belongs_to, has_one, has_many)
#
# Specifying foreign keys in fixtures can be very fragile, not to
# mention difficult to read. Since Active Record can figure out the ID of
# any fixture from its label, you can specify FK's by label instead of ID.
#
# === belongs_to
#
# Let's break out some more monkeys and pirates.
#
#   ### in pirates.yml
#
#   reginald:
#     id: 1
#     name: Reginald the Pirate
#     monkey_id: 1
#
#   ### in monkeys.yml
#
#   george:
#     id: 1
#     name: George the Monkey
#     pirate_id: 1
#
# Add a few more monkeys and pirates and break this into multiple files,
# and it gets pretty hard to keep track of what's going on. Let's
# use labels instead of IDs:
#
#   ### in pirates.yml
#
#   reginald:
#     name: Reginald the Pirate
#     monkey: george
#
#   ### in monkeys.yml
#
#   george:
#     name: George the Monkey
#     pirate: reginald
#
# Pow! All is made clear. Active Record reflects on the fixture's model class,
# finds all the +belongs_to+ associations, and allows you to specify
# a target *label* for the *association* (monkey: george) rather than
# a target *id* for the *FK* (<tt>monkey_id: 1</tt>).
#
# ==== Polymorphic belongs_to
#
# Supporting polymorphic relationships is a little bit more complicated, since
# Active Record needs to know what type your association is pointing at. Something
# like this should look familiar:
#
#   ### in fruit.rb
#
#   belongs_to :eater, polymorphic: true
#
#   ### in fruits.yml
#
#   apple:
#     id: 1
#     name: apple
#     eater_id: 1
#     eater_type: Monkey
#
# Can we do better? You bet!
#
#   apple:
#     eater: george (Monkey)
#
# Just provide the polymorphic target type and Active Record will take care of the rest.
#
# === has_and_belongs_to_many
#
# Time to give our monkey some fruit.
#
#   ### in monkeys.yml
#
#   george:
#     id: 1
#     name: George the Monkey
#
#   ### in fruits.yml
#
#   apple:
#     id: 1
#     name: apple
#
#   orange:
#     id: 2
#     name: orange
#
#   grape:
#     id: 3
#     name: grape
#
#   ### in fruits_monkeys.yml
#
#   apple_george:
#     fruit_id: 1
#     monkey_id: 1
#
#   orange_george:
#     fruit_id: 2
#     monkey_id: 1
#
#   grape_george:
#     fruit_id: 3
#     monkey_id: 1
#
# Let's make the HABTM fixture go away.
#
#   ### in monkeys.yml
#
#   george:
#     id: 1
#     name: George the Monkey
#     fruits: apple, orange, grape
#
#   ### in fruits.yml
#
#   apple:
#     name: apple
#
#   orange:
#     name: orange
#
#   grape:
#     name: grape
#
# Zap! No more fruits_monkeys.yml file. We've specified the list of fruits
# on George's fixture, but we could've just as easily specified a list
# of monkeys on each fruit. As with +belongs_to+, Active Record reflects on
# the fixture's model class and discovers the +has_and_belongs_to_many+
# associations.
#
# == Autofilled Timestamp Columns
#
# If your table/model specifies any of Active Record's
# standard timestamp columns (+created_at+, +created_on+, +updated_at+, +updated_on+),
# they will automatically be set to <tt>Time.now</tt>.
#
# If you've set specific values, they'll be left alone.
#
# == Fixture label interpolation
#
# The label of the current fixture is always available as a column value:
#
#   geeksomnia:
#     name: Geeksomnia's Account
#     subdomain: $LABEL
#     email: $LABEL@email.com
#
# Also, sometimes (like when porting older join table fixtures) you'll need
# to be able to get a hold of the identifier for a given label. ERB
# to the rescue:
#
#   george_reginald:
#     monkey_id: <%= ActiveRecord::FixtureSet.identify(:reginald) %>
#     pirate_id: <%= ActiveRecord::FixtureSet.identify(:george) %>
#
# == Support for YAML defaults
#
# You can set and reuse defaults in your fixtures YAML file.
# This is the same technique used in the +database.yml+ file to specify
# defaults:
#
#   DEFAULTS: &DEFAULTS
#     created_on: <%= 3.weeks.ago.to_s(:db) %>
#
#   first:
#     name: Smurf
#     <<: *DEFAULTS
#
#   second:
#     name: Fraggle
#     <<: *DEFAULTS
#
# Any fixture labeled "DEFAULTS" is safely ignored.
#
# Besides using "DEFAULTS", you can also specify what fixtures will
# be ignored by setting "ignore" in "_fixture" section.
#
#   # users.yml
#   _fixture:
#     ignore:
#       - base
#     # or use "ignore: base" when there is only one fixture needs to be ignored.
#
#   base: &base
#     admin: false
#     introduction: "This is a default description"
#
#   admin:
#     <<: *base
#     admin: true
#
#   visitor:
#     <<: *base
#
# In the above example, 'base' will be ignored when creating fixtures.
# This can be used for common attributes inheriting.
#
# == Configure the fixture model class
#
# It's possible to set the fixture's model class directly in the YAML file.
# This is helpful when fixtures are loaded outside tests and
# +set_fixture_class+ is not available (e.g.
# when running <tt>bin/rails db:fixtures:load</tt>).
#
#   _fixture:
#     model_class: User
#   david:
#     name: David
#
# Any fixtures labeled "_fixture" are safely ignored.
class ActiveRecord::FixtureSet
  # @return [FixtureSet] a new instance of FixtureSet
  def initialize(_, name, class_name, path, config = T.unsafe(nil)); end

  def [](x); end
  def []=(k, v); end
  def all_loaded_fixtures; end
  def all_loaded_fixtures=(val); end

  # Returns the value of attribute config.
  def config; end

  def each(&block); end

  # Returns the value of attribute fixtures.
  def fixtures; end

  # Returns the value of attribute ignored_fixtures.
  def ignored_fixtures; end

  # Returns the value of attribute model_class.
  def model_class; end

  # Returns the value of attribute name.
  def name; end

  def size; end

  # Returns the value of attribute table_name.
  def table_name; end

  # Returns a hash of rows to be inserted. The key is the table, the value is
  # a list of rows to insert to that table.
  def table_rows; end

  private

  def ignored_fixtures=(base); end
  def model_class=(class_name); end

  # Loads the fixtures from the YAML file at +path+.
  # If the file sets the +model_class+ and current instance value is not set,
  # it uses the file value.
  def read_fixture_files(path); end

  def yaml_file_path(path); end

  class << self
    def all_loaded_fixtures; end
    def all_loaded_fixtures=(val); end
    def cache_fixtures(connection, fixtures_map); end
    def cache_for_connection(connection); end
    def cached_fixtures(connection, keys_to_fetch = T.unsafe(nil)); end

    # Superclass for the evaluation contexts used by ERB fixtures.
    def context_class; end

    def create_fixtures(fixtures_directory, fixture_set_names, class_names = T.unsafe(nil), config = T.unsafe(nil), &block); end
    def default_fixture_model_name(fixture_set_name, config = T.unsafe(nil)); end
    def default_fixture_table_name(fixture_set_name, config = T.unsafe(nil)); end

    # @return [Boolean]
    def fixture_is_cached?(connection, table_name); end

    # Returns a consistent, platform-independent identifier for +label+.
    # Integer identifiers are values less than 2^30. UUIDs are RFC 4122 version 5 SHA-1 hashes.
    def identify(label, column_type = T.unsafe(nil)); end

    def instantiate_all_loaded_fixtures(object, load_instances = T.unsafe(nil)); end
    def instantiate_fixtures(object, fixture_set, load_instances = T.unsafe(nil)); end
    def reset_cache; end
    def signed_global_id(fixture_set_name, label, column_type: T.unsafe(nil), **options); end

    private

    def insert(fixture_sets, connection); end
    def read_and_insert(fixtures_directory, fixture_files, class_names, connection); end
    def update_all_loaded_fixtures(fixtures_map); end
  end
end

class ActiveRecord::FixtureSet::ClassCache
  # @return [ClassCache] a new instance of ClassCache
  def initialize(class_names, config); end

  def [](fs_name); end

  private

  def default_fixture_model(fs_name, config); end
  def insert_class(class_names, name, klass); end
end

class ActiveRecord::FixtureSet::File
  include ::Enumerable

  # @return [File] a new instance of File
  def initialize(file); end

  def each(&block); end
  def ignored_fixtures; end
  def model_class; end

  private

  def config_row; end
  def raw_rows; end
  def rows; end

  # Validate our unmarshalled data.
  def validate(data); end

  class << self
    # Open a fixture file named +file+.  When called with a block, the block
    # is called with the filehandle and the filehandle is automatically closed
    # when the block finishes.
    def open(file); end
  end
end

# --
# An instance of FixtureSet is normally stored in a single YAML file and
# possibly in a folder with the same name.
# ++
ActiveRecord::FixtureSet::MAX_ID = T.let(T.unsafe(nil), Integer)

class ActiveRecord::FixtureSet::ModelMetadata
  # @return [ModelMetadata] a new instance of ModelMetadata
  def initialize(model_class); end

  # @return [Boolean]
  def has_primary_key_column?; end

  def inheritance_column_name; end
  def primary_key_name; end
  def primary_key_type; end
  def timestamp_column_names; end
end

# NOTE: This class has to be defined in compact style in
# order for rendering context subclassing to work correctly.
class ActiveRecord::FixtureSet::RenderContext
  class << self
    def create_subclass; end
  end
end

class ActiveRecord::FixtureSet::TableRow
  # @return [TableRow] a new instance of TableRow
  def initialize(fixture, table_rows:, label:, now:); end

  def to_hash; end

  private

  def add_join_records(association); end
  def fill_row_model_attributes; end
  def fill_timestamps; end
  def generate_primary_key; end
  def interpolate_label; end
  def model_class; end
  def model_metadata; end
  def reflection_class; end
  def resolve_enums; end
  def resolve_sti_reflections; end
end

class ActiveRecord::FixtureSet::TableRow::HasManyThroughProxy < ::ActiveRecord::FixtureSet::TableRow::ReflectionProxy
  def join_table; end
  def lhs_key; end
  def rhs_key; end
end

class ActiveRecord::FixtureSet::TableRow::ReflectionProxy
  # @return [ReflectionProxy] a new instance of ReflectionProxy
  def initialize(association); end

  def join_table; end
  def name; end
  def primary_key_type; end
end

class ActiveRecord::FixtureSet::TableRows
  # @return [TableRows] a new instance of TableRows
  def initialize(table_name, model_class:, fixtures:, config:); end

  # Returns the value of attribute model_class.
  def model_class; end

  def model_metadata; end

  # Returns the value of attribute tables.
  def tables; end

  def to_hash; end

  private

  def build_table_rows_from(table_name, fixtures, config); end
end

class ActiveRecord::HasManyThroughAssociationNotFoundError < ::ActiveRecord::ActiveRecordError
  include ::DidYouMean::Correctable

  # @return [HasManyThroughAssociationNotFoundError] a new instance of HasManyThroughAssociationNotFoundError
  def initialize(owner_class = T.unsafe(nil), reflection = T.unsafe(nil)); end

  # Returns the value of attribute owner_class.
  def owner_class; end

  # Returns the value of attribute reflection.
  def reflection; end
end

class ActiveRecord::HasManyThroughAssociationNotFoundError::Correction
  # @return [Correction] a new instance of Correction
  def initialize(error); end

  def corrections; end
end

class ActiveRecord::HasManyThroughAssociationPointlessSourceTypeError < ::ActiveRecord::ActiveRecordError
  # @return [HasManyThroughAssociationPointlessSourceTypeError] a new instance of HasManyThroughAssociationPointlessSourceTypeError
  def initialize(owner_class_name = T.unsafe(nil), reflection = T.unsafe(nil), source_reflection = T.unsafe(nil)); end
end

class ActiveRecord::HasManyThroughAssociationPolymorphicSourceError < ::ActiveRecord::ActiveRecordError
  # @return [HasManyThroughAssociationPolymorphicSourceError] a new instance of HasManyThroughAssociationPolymorphicSourceError
  def initialize(owner_class_name = T.unsafe(nil), reflection = T.unsafe(nil), source_reflection = T.unsafe(nil)); end
end

class ActiveRecord::HasManyThroughAssociationPolymorphicThroughError < ::ActiveRecord::ActiveRecordError
  # @return [HasManyThroughAssociationPolymorphicThroughError] a new instance of HasManyThroughAssociationPolymorphicThroughError
  def initialize(owner_class_name = T.unsafe(nil), reflection = T.unsafe(nil)); end
end

class ActiveRecord::HasManyThroughCantAssociateThroughHasOneOrManyReflection < ::ActiveRecord::ThroughCantAssociateThroughHasOneOrManyReflection; end
class ActiveRecord::HasManyThroughNestedAssociationsAreReadonly < ::ActiveRecord::ThroughNestedAssociationsAreReadonly; end

class ActiveRecord::HasManyThroughOrderError < ::ActiveRecord::ActiveRecordError
  # @return [HasManyThroughOrderError] a new instance of HasManyThroughOrderError
  def initialize(owner_class_name = T.unsafe(nil), reflection = T.unsafe(nil), through_reflection = T.unsafe(nil)); end
end

class ActiveRecord::HasManyThroughSourceAssociationNotFoundError < ::ActiveRecord::ActiveRecordError
  # @return [HasManyThroughSourceAssociationNotFoundError] a new instance of HasManyThroughSourceAssociationNotFoundError
  def initialize(reflection = T.unsafe(nil)); end
end

class ActiveRecord::HasOneAssociationPolymorphicThroughError < ::ActiveRecord::ActiveRecordError
  # @return [HasOneAssociationPolymorphicThroughError] a new instance of HasOneAssociationPolymorphicThroughError
  def initialize(owner_class_name = T.unsafe(nil), reflection = T.unsafe(nil)); end
end

class ActiveRecord::HasOneThroughCantAssociateThroughCollection < ::ActiveRecord::ActiveRecordError
  # @return [HasOneThroughCantAssociateThroughCollection] a new instance of HasOneThroughCantAssociateThroughCollection
  def initialize(owner_class_name = T.unsafe(nil), reflection = T.unsafe(nil), through_reflection = T.unsafe(nil)); end
end

class ActiveRecord::HasOneThroughCantAssociateThroughHasOneOrManyReflection < ::ActiveRecord::ThroughCantAssociateThroughHasOneOrManyReflection; end
class ActiveRecord::HasOneThroughNestedAssociationsAreReadonly < ::ActiveRecord::ThroughNestedAssociationsAreReadonly; end

class ActiveRecord::IllegalMigrationNameError < ::ActiveRecord::MigrationError
  # @return [IllegalMigrationNameError] a new instance of IllegalMigrationNameError
  def initialize(name = T.unsafe(nil)); end
end

# Raised when a relation cannot be mutated because it's already loaded.
#
#   class Task < ActiveRecord::Base
#   end
#
#   relation = Task.all
#   relation.loaded? # => true
#
#   # Methods which try to mutate a loaded relation fail.
#   relation.where!(title: 'TODO')  # => ActiveRecord::ImmutableRelation
#   relation.limit!(5)              # => ActiveRecord::ImmutableRelation
class ActiveRecord::ImmutableRelation < ::ActiveRecord::ActiveRecordError; end

# == Single table inheritance
#
# Active Record allows inheritance by storing the name of the class in a column that by
# default is named "type" (can be changed by overwriting <tt>Base.inheritance_column</tt>).
# This means that an inheritance looking like this:
#
#   class Company < ActiveRecord::Base; end
#   class Firm < Company; end
#   class Client < Company; end
#   class PriorityClient < Client; end
#
# When you do <tt>Firm.create(name: "37signals")</tt>, this record will be saved in
# the companies table with type = "Firm". You can then fetch this row again using
# <tt>Company.where(name: '37signals').first</tt> and it will return a Firm object.
#
# Be aware that because the type column is an attribute on the record every new
# subclass will instantly be marked as dirty and the type column will be included
# in the list of changed attributes on the record. This is different from non
# Single Table Inheritance(STI) classes:
#
#   Company.new.changed? # => false
#   Firm.new.changed?    # => true
#   Firm.new.changes     # => {"type"=>["","Firm"]}
#
# If you don't have a type column defined in your table, single-table inheritance won't
# be triggered. In that case, it'll work just like normal subclasses with no special magic
# for differentiating between them or reloading the right type with find.
#
# Note, all the attributes for all the cases are kept in the same table. Read more:
# https://www.martinfowler.com/eaaCatalog/singleTableInheritance.html
module ActiveRecord::Inheritance
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::ActiveRecord::Inheritance::ClassMethods

  private

  # Sets the attribute used for single table inheritance to this class name if this is not the
  # ActiveRecord::Base descendant.
  # Considering the hierarchy Reply < Message < ActiveRecord::Base, this makes it possible to
  # do Reply.new without having to set <tt>Reply[Reply.inheritance_column] = "Reply"</tt> yourself.
  # No such attribute would be set for objects of the Message class in that example.
  def ensure_proper_type; end

  def initialize_dup(other); end
  def initialize_internals_callback; end

  module GeneratedClassMethods
    def store_full_class_name; end
    def store_full_class_name=(value); end
    def store_full_class_name?; end
    def store_full_sti_class; end
    def store_full_sti_class=(value); end
    def store_full_sti_class?; end
  end

  module GeneratedInstanceMethods
    def store_full_class_name; end
    def store_full_class_name?; end
    def store_full_sti_class; end
    def store_full_sti_class?; end
  end
end

module ActiveRecord::Inheritance::ClassMethods
  # Set this to +true+ if this is an abstract class (see
  # <tt>abstract_class?</tt>).
  # If you are using inheritance with Active Record and don't want a class
  # to be considered as part of the STI hierarchy, you must set this to
  # true.
  # +ApplicationRecord+, for example, is generated as an abstract class.
  #
  # Consider the following default behaviour:
  #
  #   Shape = Class.new(ActiveRecord::Base)
  #   Polygon = Class.new(Shape)
  #   Square = Class.new(Polygon)
  #
  #   Shape.table_name   # => "shapes"
  #   Polygon.table_name # => "shapes"
  #   Square.table_name  # => "shapes"
  #   Shape.create!      # => #<Shape id: 1, type: nil>
  #   Polygon.create!    # => #<Polygon id: 2, type: "Polygon">
  #   Square.create!     # => #<Square id: 3, type: "Square">
  #
  # However, when using <tt>abstract_class</tt>, +Shape+ is omitted from
  # the hierarchy:
  #
  #   class Shape < ActiveRecord::Base
  #     self.abstract_class = true
  #   end
  #   Polygon = Class.new(Shape)
  #   Square = Class.new(Polygon)
  #
  #   Shape.table_name   # => nil
  #   Polygon.table_name # => "polygons"
  #   Square.table_name  # => "polygons"
  #   Shape.create!      # => NotImplementedError: Shape is an abstract class and cannot be instantiated.
  #   Polygon.create!    # => #<Polygon id: 1, type: nil>
  #   Square.create!     # => #<Square id: 2, type: "Square">
  #
  # Note that in the above example, to disallow the creation of a plain
  # +Polygon+, you should use <tt>validates :type, presence: true</tt>,
  # instead of setting it as an abstract class. This way, +Polygon+ will
  # stay in the hierarchy, and Active Record will continue to correctly
  # derive the table name.
  def abstract_class; end

  # Set this to +true+ if this is an abstract class (see
  # <tt>abstract_class?</tt>).
  # If you are using inheritance with Active Record and don't want a class
  # to be considered as part of the STI hierarchy, you must set this to
  # true.
  # +ApplicationRecord+, for example, is generated as an abstract class.
  #
  # Consider the following default behaviour:
  #
  #   Shape = Class.new(ActiveRecord::Base)
  #   Polygon = Class.new(Shape)
  #   Square = Class.new(Polygon)
  #
  #   Shape.table_name   # => "shapes"
  #   Polygon.table_name # => "shapes"
  #   Square.table_name  # => "shapes"
  #   Shape.create!      # => #<Shape id: 1, type: nil>
  #   Polygon.create!    # => #<Polygon id: 2, type: "Polygon">
  #   Square.create!     # => #<Square id: 3, type: "Square">
  #
  # However, when using <tt>abstract_class</tt>, +Shape+ is omitted from
  # the hierarchy:
  #
  #   class Shape < ActiveRecord::Base
  #     self.abstract_class = true
  #   end
  #   Polygon = Class.new(Shape)
  #   Square = Class.new(Polygon)
  #
  #   Shape.table_name   # => nil
  #   Polygon.table_name # => "polygons"
  #   Square.table_name  # => "polygons"
  #   Shape.create!      # => NotImplementedError: Shape is an abstract class and cannot be instantiated.
  #   Polygon.create!    # => #<Polygon id: 1, type: nil>
  #   Square.create!     # => #<Square id: 2, type: "Square">
  #
  # Note that in the above example, to disallow the creation of a plain
  # +Polygon+, you should use <tt>validates :type, presence: true</tt>,
  # instead of setting it as an abstract class. This way, +Polygon+ will
  # stay in the hierarchy, and Active Record will continue to correctly
  # derive the table name.
  def abstract_class=(_arg0); end

  # Returns whether this class is an abstract class or not.
  #
  # @return [Boolean]
  def abstract_class?; end

  # Returns the class descending directly from ActiveRecord::Base, or
  # an abstract class, if any, in the inheritance hierarchy.
  #
  # If A extends ActiveRecord::Base, A.base_class will return A. If B descends from A
  # through some arbitrarily deep hierarchy, B.base_class will return A.
  #
  # If B < A and C < B and if A is an abstract_class then both B.base_class
  # and C.base_class would return B as the answer since A is an abstract_class.
  def base_class; end

  # Returns whether the class is a base class.
  # See #base_class for more information.
  #
  # @return [Boolean]
  def base_class?; end

  # Returns +true+ if this does not need STI type condition. Returns
  # +false+ if STI type condition needs to be applied.
  #
  # @return [Boolean]
  def descends_from_active_record?; end

  # @return [Boolean]
  def finder_needs_type_condition?; end

  def inherited(subclass); end

  # Determines if one of the attributes passed in is the inheritance column,
  # and if the inheritance column is attr accessible, it initializes an
  # instance of the given subclass instead of the base class.
  def new(attributes = T.unsafe(nil), &block); end

  # Returns the class for the provided +name+.
  #
  # It is used to find the class correspondent to the value stored in the polymorphic type column.
  def polymorphic_class_for(name); end

  # Returns the value to be stored in the polymorphic type column for Polymorphic Associations.
  def polymorphic_name; end

  # Returns the class for the provided +type_name+.
  #
  # It is used to find the class correspondent to the value stored in the inheritance column.
  def sti_class_for(type_name); end

  # Returns the value to be stored in the inheritance column for STI.
  def sti_name; end

  protected

  # Returns the class type of the record using the current module as a prefix. So descendants of
  # MyApp::Business::Account would appear as MyApp::Business::AccountSubclass.
  def compute_type(type_name); end

  private

  # Called by +instantiate+ to decide which class to use for a new
  # record instance. For single-table inheritance, we check the record
  # for a +type+ column and return the corresponding class.
  def discriminate_class_for_record(record); end

  def find_sti_class(type_name); end

  # Detect the subclass from the inheritance column of attrs. If the inheritance column value
  # is not self or a valid subclass, raises ActiveRecord::SubclassNotFound
  def subclass_from_attributes(attrs); end

  def type_condition(table = T.unsafe(nil)); end

  # @return [Boolean]
  def using_single_table_inheritance?(record); end
end

class ActiveRecord::InsertAll
  # @raise [ArgumentError]
  # @return [InsertAll] a new instance of InsertAll
  def initialize(model, inserts, on_duplicate:, returning: T.unsafe(nil), unique_by: T.unsafe(nil)); end

  # Returns the value of attribute connection.
  def connection; end

  def execute; end

  # Returns the value of attribute inserts.
  def inserts; end

  # Returns the value of attribute keys.
  def keys; end

  def map_key_with_value; end

  # Returns the value of attribute model.
  def model; end

  # Returns the value of attribute on_duplicate.
  def on_duplicate; end

  def primary_keys; end

  # Returns the value of attribute returning.
  def returning; end

  # @return [Boolean]
  def skip_duplicates?; end

  # Returns the value of attribute unique_by.
  def unique_by; end

  def updatable_columns; end

  # @return [Boolean]
  def update_duplicates?; end

  private

  def ensure_valid_options_for_connection!; end
  def find_unique_index_for(unique_by); end
  def readonly_columns; end

  # Returns the value of attribute scope_attributes.
  def scope_attributes; end

  def to_sql; end
  def unique_by_columns; end
  def unique_indexes; end
  def verify_attributes(attributes); end
end

class ActiveRecord::InsertAll::Builder
  # @return [Builder] a new instance of Builder
  def initialize(insert_all); end

  def conflict_target; end
  def into; end
  def keys(*_arg0, &_arg1); end

  # Returns the value of attribute model.
  def model; end

  def returning; end
  def skip_duplicates?(*_arg0, &_arg1); end
  def touch_model_timestamps_unless(&block); end
  def updatable_columns; end
  def update_duplicates?(*_arg0, &_arg1); end
  def values_list; end

  private

  def columns_list; end

  # Returns the value of attribute connection.
  def connection; end

  # @raise [UnknownAttributeError]
  def extract_types_from_columns_on(table_name, keys:); end

  def format_columns(columns); end

  # Returns the value of attribute insert_all.
  def insert_all; end

  def quote_columns(columns); end

  # @return [Boolean]
  def touch_timestamp_attribute?(column_name); end
end

module ActiveRecord::Integration
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::ActiveRecord::Integration::ClassMethods

  # Returns a stable cache key that can be used to identify this record.
  #
  #   Product.new.cache_key     # => "products/new"
  #   Product.find(5).cache_key # => "products/5"
  #
  # If ActiveRecord::Base.cache_versioning is turned off, as it was in Rails 5.1 and earlier,
  # the cache key will also include a version.
  #
  #   Product.cache_versioning = false
  #   Product.find(5).cache_key  # => "products/5-20071224150000" (updated_at available)
  def cache_key; end

  # Returns a cache key along with the version.
  def cache_key_with_version; end

  # Returns a cache version that can be used together with the cache key to form
  # a recyclable caching scheme. By default, the #updated_at column is used for the
  # cache_version, but this method can be overwritten to return something else.
  #
  # Note, this method will return nil if ActiveRecord::Base.cache_versioning is set to
  # +false+.
  def cache_version; end

  # Returns a +String+, which Action Pack uses for constructing a URL to this
  # object. The default implementation returns this record's id as a +String+,
  # or +nil+ if this record's unsaved.
  #
  # For example, suppose that you have a User model, and that you have a
  # <tt>resources :users</tt> route. Normally, +user_path+ will
  # construct a path with the user object's 'id' in it:
  #
  #   user = User.find_by(name: 'Phusion')
  #   user_path(user)  # => "/users/1"
  #
  # You can override +to_param+ in your model to make +user_path+ construct
  # a path using the user's name instead of the user's id:
  #
  #   class User < ActiveRecord::Base
  #     def to_param  # overridden
  #       name
  #     end
  #   end
  #
  #   user = User.find_by(name: 'Phusion')
  #   user_path(user)  # => "/users/Phusion"
  def to_param; end

  private

  # Detects if the value before type cast
  # can be used to generate a cache_version.
  #
  # The fast cache version only works with a
  # string value directly from the database.
  #
  # We also must check if the timestamp format has been changed
  # or if the timezone is not set to UTC then
  # we cannot apply our transformations correctly.
  #
  # @return [Boolean]
  def can_use_fast_cache_version?(timestamp); end

  # Converts a raw database string to `:usec`
  # format.
  #
  # Example:
  #
  #   timestamp = "2018-10-15 20:02:15.266505"
  #   raw_timestamp_to_cache_version(timestamp)
  #   # => "20181015200215266505"
  #
  # PostgreSQL truncates trailing zeros,
  # https://github.com/postgres/postgres/commit/3e1beda2cde3495f41290e1ece5d544525810214
  # to account for this we pad the output with zeros
  def raw_timestamp_to_cache_version(timestamp); end

  module GeneratedClassMethods
    def cache_timestamp_format; end
    def cache_timestamp_format=(value); end
    def cache_timestamp_format?; end
    def cache_versioning; end
    def cache_versioning=(value); end
    def cache_versioning?; end
    def collection_cache_versioning; end
    def collection_cache_versioning=(value); end
    def collection_cache_versioning?; end
  end

  module GeneratedInstanceMethods
    def cache_timestamp_format; end
    def cache_timestamp_format?; end
    def cache_versioning; end
    def cache_versioning?; end
    def collection_cache_versioning; end
    def collection_cache_versioning?; end
  end
end

module ActiveRecord::Integration::ClassMethods
  def collection_cache_key(collection = T.unsafe(nil), timestamp_column = T.unsafe(nil)); end

  # Defines your model's +to_param+ method to generate "pretty" URLs
  # using +method_name+, which can be any attribute or method that
  # responds to +to_s+.
  #
  #   class User < ActiveRecord::Base
  #     to_param :name
  #   end
  #
  #   user = User.find_by(name: 'Fancy Pants')
  #   user.id         # => 123
  #   user_path(user) # => "/users/123-fancy-pants"
  #
  # Values longer than 20 characters will be truncated. The value
  # is truncated word by word.
  #
  #   user = User.find_by(name: 'David Heinemeier Hansson')
  #   user.id         # => 125
  #   user_path(user) # => "/users/125-david-heinemeier"
  #
  # Because the generated param begins with the record's +id+, it is
  # suitable for passing to +find+. In a controller, for example:
  #
  #   params[:id]               # => "123-fancy-pants"
  #   User.find(params[:id]).id # => 123
  def to_param(method_name = T.unsafe(nil)); end
end

# This class is used to create a table that keeps track of values and keys such
# as which environment migrations were run in.
#
# This is enabled by default. To disable this functionality set
# `use_metadata_table` to false in your database configuration.
class ActiveRecord::InternalMetadata < ::ActiveRecord::Base
  include ::ActiveRecord::InternalMetadata::GeneratedAttributeMethods
  include ::ActiveRecord::InternalMetadata::GeneratedAssociationMethods

  class << self
    def [](key); end
    def []=(key, value); end

    # @return [Boolean]
    def _internal?; end

    def _validators; end

    # Creates an internal metadata table with columns +key+ and +value+
    def create_table; end

    def defined_enums; end
    def drop_table; end

    # @return [Boolean]
    def enabled?; end

    def primary_key; end
    def record_timestamps; end
    def table_name; end
  end
end

module ActiveRecord::InternalMetadata::GeneratedAssociationMethods; end
module ActiveRecord::InternalMetadata::GeneratedAttributeMethods; end

# Raised when a record cannot be inserted or updated because it references a non-existent record,
# or when a record cannot be deleted because a parent record references it.
class ActiveRecord::InvalidForeignKey < ::ActiveRecord::WrappedDatabaseException; end

class ActiveRecord::InverseOfAssociationNotFoundError < ::ActiveRecord::ActiveRecordError
  include ::DidYouMean::Correctable

  # @return [InverseOfAssociationNotFoundError] a new instance of InverseOfAssociationNotFoundError
  def initialize(reflection = T.unsafe(nil), associated_class = T.unsafe(nil)); end

  # Returns the value of attribute associated_class.
  def associated_class; end

  # Returns the value of attribute reflection.
  def reflection; end
end

class ActiveRecord::InverseOfAssociationNotFoundError::Correction
  # @return [Correction] a new instance of Correction
  def initialize(error); end

  def corrections; end
end

# Exception that can be raised to stop migrations from being rolled back.
# For example the following migration is not reversible.
# Rolling back this migration will raise an ActiveRecord::IrreversibleMigration error.
#
#   class IrreversibleMigrationExample < ActiveRecord::Migration[6.0]
#     def change
#       create_table :distributors do |t|
#         t.string :zipcode
#       end
#
#       execute <<~SQL
#         ALTER TABLE distributors
#           ADD CONSTRAINT zipchk
#             CHECK (char_length(zipcode) = 5) NO INHERIT;
#       SQL
#     end
#   end
#
# There are two ways to mitigate this problem.
#
# 1. Define <tt>#up</tt> and <tt>#down</tt> methods instead of <tt>#change</tt>:
#
#  class ReversibleMigrationExample < ActiveRecord::Migration[6.0]
#    def up
#      create_table :distributors do |t|
#        t.string :zipcode
#      end
#
#      execute <<~SQL
#        ALTER TABLE distributors
#          ADD CONSTRAINT zipchk
#            CHECK (char_length(zipcode) = 5) NO INHERIT;
#      SQL
#    end
#
#    def down
#      execute <<~SQL
#        ALTER TABLE distributors
#          DROP CONSTRAINT zipchk
#      SQL
#
#      drop_table :distributors
#    end
#  end
#
# 2. Use the #reversible method in <tt>#change</tt> method:
#
#   class ReversibleMigrationExample < ActiveRecord::Migration[6.0]
#     def change
#       create_table :distributors do |t|
#         t.string :zipcode
#       end
#
#       reversible do |dir|
#         dir.up do
#           execute <<~SQL
#             ALTER TABLE distributors
#               ADD CONSTRAINT zipchk
#                 CHECK (char_length(zipcode) = 5) NO INHERIT;
#           SQL
#         end
#
#         dir.down do
#           execute <<~SQL
#             ALTER TABLE distributors
#               DROP CONSTRAINT zipchk
#           SQL
#         end
#       end
#     end
#   end
class ActiveRecord::IrreversibleMigration < ::ActiveRecord::MigrationError; end

# IrreversibleOrderError is raised when a relation's order is too complex for
# +reverse_order+ to automatically reverse.
class ActiveRecord::IrreversibleOrderError < ::ActiveRecord::ActiveRecordError; end

module ActiveRecord::LegacyYamlAdapter
  class << self
    def convert(klass, coder); end
  end
end

module ActiveRecord::LegacyYamlAdapter::Rails41
  class << self
    def convert(klass, coder); end
  end
end

module ActiveRecord::LegacyYamlAdapter::Rails420
  class << self
    def convert(klass, coder); end
  end
end

# LockWaitTimeout will be raised when lock wait timeout exceeded.
class ActiveRecord::LockWaitTimeout < ::ActiveRecord::StatementInvalid; end

module ActiveRecord::Locking
  extend ::ActiveSupport::Autoload
end

# In de/serialize we change `nil` to 0, so that we can allow passing
# `nil` values to `lock_version`, and not result in `ActiveRecord::StaleObjectError`
# during update record.
class ActiveRecord::Locking::LockingType
  def deserialize(value); end
  def encode_with(coder); end
  def init_with(coder); end
  def serialize(value); end

  class << self
    def new(subtype); end
  end
end

# == What is Optimistic Locking
#
# Optimistic locking allows multiple users to access the same record for edits, and assumes a minimum of
# conflicts with the data. It does this by checking whether another process has made changes to a record since
# it was opened, an <tt>ActiveRecord::StaleObjectError</tt> exception is thrown if that has occurred
# and the update is ignored.
#
# Check out <tt>ActiveRecord::Locking::Pessimistic</tt> for an alternative.
#
# == Usage
#
# Active Record supports optimistic locking if the +lock_version+ field is present. Each update to the
# record increments the +lock_version+ column and the locking facilities ensure that records instantiated twice
# will let the last one saved raise a +StaleObjectError+ if the first was also updated. Example:
#
#   p1 = Person.find(1)
#   p2 = Person.find(1)
#
#   p1.first_name = "Michael"
#   p1.save
#
#   p2.first_name = "should fail"
#   p2.save # Raises an ActiveRecord::StaleObjectError
#
# Optimistic locking will also check for stale data when objects are destroyed. Example:
#
#   p1 = Person.find(1)
#   p2 = Person.find(1)
#
#   p1.first_name = "Michael"
#   p1.save
#
#   p2.destroy # Raises an ActiveRecord::StaleObjectError
#
# You're then responsible for dealing with the conflict by rescuing the exception and either rolling back, merging,
# or otherwise apply the business logic needed to resolve the conflict.
#
# This locking mechanism will function inside a single Ruby process. To make it work across all
# web requests, the recommended approach is to add +lock_version+ as a hidden field to your form.
#
# This behavior can be turned off by setting <tt>ActiveRecord::Base.lock_optimistically = false</tt>.
# To override the name of the +lock_version+ column, set the <tt>locking_column</tt> class attribute:
#
#   class Person < ActiveRecord::Base
#     self.locking_column = :lock_person
#   end
module ActiveRecord::Locking::Optimistic
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::ActiveRecord::Locking::Optimistic::ClassMethods

  def increment!(*_arg0, **_arg1); end

  # @return [Boolean]
  def locking_enabled?; end

  private

  def _create_record(attribute_names = T.unsafe(nil)); end
  def _lock_value_for_database(locking_column); end
  def _touch_row(attribute_names, time); end
  def _update_row(attribute_names, attempted_action = T.unsafe(nil)); end
  def destroy_row; end

  module GeneratedClassMethods
    def lock_optimistically; end
    def lock_optimistically=(value); end
    def lock_optimistically?; end
  end

  module GeneratedInstanceMethods
    def lock_optimistically; end
    def lock_optimistically?; end
  end
end

module ActiveRecord::Locking::Optimistic::ClassMethods
  def define_attribute(name, cast_type, **_arg2); end

  # The version column used for optimistic locking. Defaults to +lock_version+.
  def locking_column; end

  # Set the column to use for optimistic locking. Defaults to +lock_version+.
  def locking_column=(value); end

  # Returns true if the +lock_optimistically+ flag is set to true
  # (which it is, by default) and the table includes the
  # +locking_column+ column (defaults to +lock_version+).
  #
  # @return [Boolean]
  def locking_enabled?; end

  # Reset the column used for optimistic locking back to the +lock_version+ default.
  def reset_locking_column; end

  # Make sure the lock version column gets updated when counters are
  # updated.
  def update_counters(id, counters); end
end

ActiveRecord::Locking::Optimistic::ClassMethods::DEFAULT_LOCKING_COLUMN = T.let(T.unsafe(nil), String)

# Locking::Pessimistic provides support for row-level locking using
# SELECT ... FOR UPDATE and other lock types.
#
# Chain <tt>ActiveRecord::Base#find</tt> to <tt>ActiveRecord::QueryMethods#lock</tt> to obtain an exclusive
# lock on the selected rows:
#   # select * from accounts where id=1 for update
#   Account.lock.find(1)
#
# Call <tt>lock('some locking clause')</tt> to use a database-specific locking clause
# of your own such as 'LOCK IN SHARE MODE' or 'FOR UPDATE NOWAIT'. Example:
#
#   Account.transaction do
#     # select * from accounts where name = 'shugo' limit 1 for update nowait
#     shugo = Account.lock("FOR UPDATE NOWAIT").find_by(name: "shugo")
#     yuko = Account.lock("FOR UPDATE NOWAIT").find_by(name: "yuko")
#     shugo.balance -= 100
#     shugo.save!
#     yuko.balance += 100
#     yuko.save!
#   end
#
# You can also use <tt>ActiveRecord::Base#lock!</tt> method to lock one record by id.
# This may be better if you don't need to lock every row. Example:
#
#   Account.transaction do
#     # select * from accounts where ...
#     accounts = Account.where(...)
#     account1 = accounts.detect { |account| ... }
#     account2 = accounts.detect { |account| ... }
#     # select * from accounts where id=? for update
#     account1.lock!
#     account2.lock!
#     account1.balance -= 100
#     account1.save!
#     account2.balance += 100
#     account2.save!
#   end
#
# You can start a transaction and acquire the lock in one go by calling
# <tt>with_lock</tt> with a block. The block is called from within
# a transaction, the object is already locked. Example:
#
#   account = Account.first
#   account.with_lock do
#     # This block is called within a transaction,
#     # account is already locked.
#     account.balance -= 100
#     account.save!
#   end
#
# Database-specific information on row locking:
#
# [MySQL]
#   https://dev.mysql.com/doc/refman/en/innodb-locking-reads.html
#
# [PostgreSQL]
#   https://www.postgresql.org/docs/current/interactive/sql-select.html#SQL-FOR-UPDATE-SHARE
module ActiveRecord::Locking::Pessimistic
  # Obtain a row lock on this record. Reloads the record to obtain the requested
  # lock. Pass an SQL locking clause to append the end of the SELECT statement
  # or pass true for "FOR UPDATE" (the default, an exclusive row lock). Returns
  # the locked record.
  def lock!(lock = T.unsafe(nil)); end

  # Wraps the passed block in a transaction, locking the object
  # before yielding. You can pass the SQL locking clause
  # as argument (see <tt>lock!</tt>).
  def with_lock(lock = T.unsafe(nil)); end
end

class ActiveRecord::LogSubscriber < ::ActiveSupport::LogSubscriber
  def backtrace_cleaner; end
  def backtrace_cleaner=(_arg0); end
  def backtrace_cleaner?; end
  def sql(event); end
  def strict_loading_violation(event); end

  private

  def colorize_payload_name(name, payload_name); end
  def debug(progname = T.unsafe(nil), &block); end
  def extract_query_source_location(locations); end
  def log_query_source; end
  def logger; end
  def render_bind(attr, value); end
  def sql_color(sql); end
  def type_casted_binds(casted_binds); end

  class << self
    def backtrace_cleaner; end
    def backtrace_cleaner=(value); end
    def backtrace_cleaner?; end
    def reset_runtime; end
    def runtime; end
    def runtime=(value); end
  end
end

ActiveRecord::LogSubscriber::IGNORE_PAYLOAD_NAMES = T.let(T.unsafe(nil), Array)

module ActiveRecord::Middleware
  extend ::ActiveSupport::Autoload
end

# The DatabaseSelector Middleware provides a framework for automatically
# swapping from the primary to the replica database connection. Rails
# provides a basic framework to determine when to swap and allows for
# applications to write custom strategy classes to override the default
# behavior.
#
# The resolver class defines when the application should switch (i.e. read
# from the primary if a write occurred less than 2 seconds ago) and a
# resolver context class that sets a value that helps the resolver class
# decide when to switch.
#
# Rails default middleware uses the request's session to set a timestamp
# that informs the application when to read from a primary or read from a
# replica.
#
# To use the DatabaseSelector in your application with default settings add
# the following options to your environment config:
#
#   config.active_record.database_selector = { delay: 2.seconds }
#   config.active_record.database_resolver = ActiveRecord::Middleware::DatabaseSelector::Resolver
#   config.active_record.database_resolver_context = ActiveRecord::Middleware::DatabaseSelector::Resolver::Session
#
# New applications will include these lines commented out in the production.rb.
#
# The default behavior can be changed by setting the config options to a
# custom class:
#
#   config.active_record.database_selector = { delay: 2.seconds }
#   config.active_record.database_resolver = MyResolver
#   config.active_record.database_resolver_context = MyResolver::MySession
class ActiveRecord::Middleware::DatabaseSelector
  # @return [DatabaseSelector] a new instance of DatabaseSelector
  def initialize(app, resolver_klass = T.unsafe(nil), context_klass = T.unsafe(nil), options = T.unsafe(nil)); end

  # Middleware that determines which database connection to use in a multiple
  # database application.
  def call(env); end

  # Returns the value of attribute context_klass.
  def context_klass; end

  # Returns the value of attribute options.
  def options; end

  # Returns the value of attribute resolver_klass.
  def resolver_klass; end

  private

  # @return [Boolean]
  def reading_request?(request); end

  def select_database(request, &blk); end
end

# The Resolver class is used by the DatabaseSelector middleware to
# determine which database the request should use.
#
# To change the behavior of the Resolver class in your application,
# create a custom resolver class that inherits from
# DatabaseSelector::Resolver and implements the methods that need to
# be changed.
#
# By default the Resolver class will send read traffic to the replica
# if it's been 2 seconds since the last write.
class ActiveRecord::Middleware::DatabaseSelector::Resolver
  # @return [Resolver] a new instance of Resolver
  def initialize(context, options = T.unsafe(nil)); end

  # Returns the value of attribute context.
  def context; end

  # Returns the value of attribute delay.
  def delay; end

  # Returns the value of attribute instrumenter.
  def instrumenter; end

  def read(&blk); end
  def update_context(response); end
  def write(&blk); end

  private

  def read_from_primary(&blk); end

  # @return [Boolean]
  def read_from_primary?; end

  def read_from_replica(&blk); end
  def send_to_replica_delay; end

  # @return [Boolean]
  def time_since_last_write_ok?; end

  def write_to_primary(&blk); end

  class << self
    def call(context, options = T.unsafe(nil)); end
  end
end

ActiveRecord::Middleware::DatabaseSelector::Resolver::SEND_TO_REPLICA_DELAY = T.let(T.unsafe(nil), ActiveSupport::Duration)

# The session class is used by the DatabaseSelector::Resolver to save
# timestamps of the last write in the session.
#
# The last_write is used to determine whether it's safe to read
# from the replica or the request needs to be sent to the primary.
class ActiveRecord::Middleware::DatabaseSelector::Resolver::Session
  # @return [Session] a new instance of Session
  def initialize(session); end

  def last_write_timestamp; end
  def save(response); end

  # Returns the value of attribute session.
  def session; end

  def update_last_write_timestamp; end

  class << self
    def call(request); end

    # Converts time to a timestamp that represents milliseconds since
    # epoch.
    def convert_time_to_timestamp(time); end

    # Converts milliseconds since epoch timestamp into a time object.
    def convert_timestamp_to_time(timestamp); end
  end
end

# = Active Record Migrations
#
# Migrations can manage the evolution of a schema used by several physical
# databases. It's a solution to the common problem of adding a field to make
# a new feature work in your local database, but being unsure of how to
# push that change to other developers and to the production server. With
# migrations, you can describe the transformations in self-contained classes
# that can be checked into version control systems and executed against
# another database that might be one, two, or five versions behind.
#
# Example of a simple migration:
#
#   class AddSsl < ActiveRecord::Migration[6.0]
#     def up
#       add_column :accounts, :ssl_enabled, :boolean, default: true
#     end
#
#     def down
#       remove_column :accounts, :ssl_enabled
#     end
#   end
#
# This migration will add a boolean flag to the accounts table and remove it
# if you're backing out of the migration. It shows how all migrations have
# two methods +up+ and +down+ that describes the transformations
# required to implement or remove the migration. These methods can consist
# of both the migration specific methods like +add_column+ and +remove_column+,
# but may also contain regular Ruby code for generating data needed for the
# transformations.
#
# Example of a more complex migration that also needs to initialize data:
#
#   class AddSystemSettings < ActiveRecord::Migration[6.0]
#     def up
#       create_table :system_settings do |t|
#         t.string  :name
#         t.string  :label
#         t.text    :value
#         t.string  :type
#         t.integer :position
#       end
#
#       SystemSetting.create  name:  'notice',
#                             label: 'Use notice?',
#                             value: 1
#     end
#
#     def down
#       drop_table :system_settings
#     end
#   end
#
# This migration first adds the +system_settings+ table, then creates the very
# first row in it using the Active Record model that relies on the table. It
# also uses the more advanced +create_table+ syntax where you can specify a
# complete table schema in one block call.
#
# == Available transformations
#
# === Creation
#
# * <tt>create_join_table(table_1, table_2, options)</tt>: Creates a join
#   table having its name as the lexical order of the first two
#   arguments. See
#   ActiveRecord::ConnectionAdapters::SchemaStatements#create_join_table for
#   details.
# * <tt>create_table(name, options)</tt>: Creates a table called +name+ and
#   makes the table object available to a block that can then add columns to it,
#   following the same format as +add_column+. See example above. The options hash
#   is for fragments like "DEFAULT CHARSET=UTF-8" that are appended to the create
#   table definition.
# * <tt>add_column(table_name, column_name, type, options)</tt>: Adds a new column
#   to the table called +table_name+
#   named +column_name+ specified to be one of the following types:
#   <tt>:string</tt>, <tt>:text</tt>, <tt>:integer</tt>, <tt>:float</tt>,
#   <tt>:decimal</tt>, <tt>:datetime</tt>, <tt>:timestamp</tt>, <tt>:time</tt>,
#   <tt>:date</tt>, <tt>:binary</tt>, <tt>:boolean</tt>. A default value can be
#   specified by passing an +options+ hash like <tt>{ default: 11 }</tt>.
#   Other options include <tt>:limit</tt> and <tt>:null</tt> (e.g.
#   <tt>{ limit: 50, null: false }</tt>) -- see
#   ActiveRecord::ConnectionAdapters::TableDefinition#column for details.
# * <tt>add_foreign_key(from_table, to_table, options)</tt>: Adds a new
#   foreign key. +from_table+ is the table with the key column, +to_table+ contains
#   the referenced primary key.
# * <tt>add_index(table_name, column_names, options)</tt>: Adds a new index
#   with the name of the column. Other options include
#   <tt>:name</tt>, <tt>:unique</tt> (e.g.
#   <tt>{ name: 'users_name_index', unique: true }</tt>) and <tt>:order</tt>
#   (e.g. <tt>{ order: { name: :desc } }</tt>).
# * <tt>add_reference(:table_name, :reference_name)</tt>: Adds a new column
#   +reference_name_id+ by default an integer. See
#   ActiveRecord::ConnectionAdapters::SchemaStatements#add_reference for details.
# * <tt>add_timestamps(table_name, options)</tt>: Adds timestamps (+created_at+
#   and +updated_at+) columns to +table_name+.
#
# === Modification
#
# * <tt>change_column(table_name, column_name, type, options)</tt>:  Changes
#   the column to a different type using the same parameters as add_column.
# * <tt>change_column_default(table_name, column_name, default_or_changes)</tt>:
#   Sets a default value for +column_name+ defined by +default_or_changes+ on
#   +table_name+. Passing a hash containing <tt>:from</tt> and <tt>:to</tt>
#   as +default_or_changes+ will make this change reversible in the migration.
# * <tt>change_column_null(table_name, column_name, null, default = nil)</tt>:
#   Sets or removes a <tt>NOT NULL</tt> constraint on +column_name+. The +null+ flag
#   indicates whether the value can be +NULL+. See
#   ActiveRecord::ConnectionAdapters::SchemaStatements#change_column_null for
#   details.
# * <tt>change_table(name, options)</tt>: Allows to make column alterations to
#   the table called +name+. It makes the table object available to a block that
#   can then add/remove columns, indexes or foreign keys to it.
# * <tt>rename_column(table_name, column_name, new_column_name)</tt>: Renames
#   a column but keeps the type and content.
# * <tt>rename_index(table_name, old_name, new_name)</tt>: Renames an index.
# * <tt>rename_table(old_name, new_name)</tt>: Renames the table called +old_name+
#   to +new_name+.
#
# === Deletion
#
# * <tt>drop_table(name)</tt>: Drops the table called +name+.
# * <tt>drop_join_table(table_1, table_2, options)</tt>: Drops the join table
#   specified by the given arguments.
# * <tt>remove_column(table_name, column_name, type, options)</tt>: Removes the column
#   named +column_name+ from the table called +table_name+.
# * <tt>remove_columns(table_name, *column_names)</tt>: Removes the given
#   columns from the table definition.
# * <tt>remove_foreign_key(from_table, to_table = nil, **options)</tt>: Removes the
#   given foreign key from the table called +table_name+.
# * <tt>remove_index(table_name, column: column_names)</tt>: Removes the index
#   specified by +column_names+.
# * <tt>remove_index(table_name, name: index_name)</tt>: Removes the index
#   specified by +index_name+.
# * <tt>remove_reference(table_name, ref_name, options)</tt>: Removes the
#   reference(s) on +table_name+ specified by +ref_name+.
# * <tt>remove_timestamps(table_name, options)</tt>: Removes the timestamp
#   columns (+created_at+ and +updated_at+) from the table definition.
#
# == Irreversible transformations
#
# Some transformations are destructive in a manner that cannot be reversed.
# Migrations of that kind should raise an <tt>ActiveRecord::IrreversibleMigration</tt>
# exception in their +down+ method.
#
# == Running migrations from within Rails
#
# The Rails package has several tools to help create and apply migrations.
#
# To generate a new migration, you can use
#   bin/rails generate migration MyNewMigration
#
# where MyNewMigration is the name of your migration. The generator will
# create an empty migration file <tt>timestamp_my_new_migration.rb</tt>
# in the <tt>db/migrate/</tt> directory where <tt>timestamp</tt> is the
# UTC formatted date and time that the migration was generated.
#
# There is a special syntactic shortcut to generate migrations that add fields to a table.
#
#   bin/rails generate migration add_fieldname_to_tablename fieldname:string
#
# This will generate the file <tt>timestamp_add_fieldname_to_tablename.rb</tt>, which will look like this:
#   class AddFieldnameToTablename < ActiveRecord::Migration[6.0]
#     def change
#       add_column :tablenames, :fieldname, :string
#     end
#   end
#
# To run migrations against the currently configured database, use
# <tt>bin/rails db:migrate</tt>. This will update the database by running all of the
# pending migrations, creating the <tt>schema_migrations</tt> table
# (see "About the schema_migrations table" section below) if missing. It will also
# invoke the db:schema:dump command, which will update your db/schema.rb file
# to match the structure of your database.
#
# To roll the database back to a previous migration version, use
# <tt>bin/rails db:rollback VERSION=X</tt> where <tt>X</tt> is the version to which
# you wish to downgrade. Alternatively, you can also use the STEP option if you
# wish to rollback last few migrations. <tt>bin/rails db:rollback STEP=2</tt> will rollback
# the latest two migrations.
#
# If any of the migrations throw an <tt>ActiveRecord::IrreversibleMigration</tt> exception,
# that step will fail and you'll have some manual work to do.
#
# == More examples
#
# Not all migrations change the schema. Some just fix the data:
#
#   class RemoveEmptyTags < ActiveRecord::Migration[6.0]
#     def up
#       Tag.all.each { |tag| tag.destroy if tag.pages.empty? }
#     end
#
#     def down
#       # not much we can do to restore deleted data
#       raise ActiveRecord::IrreversibleMigration, "Can't recover the deleted tags"
#     end
#   end
#
# Others remove columns when they migrate up instead of down:
#
#   class RemoveUnnecessaryItemAttributes < ActiveRecord::Migration[6.0]
#     def up
#       remove_column :items, :incomplete_items_count
#       remove_column :items, :completed_items_count
#     end
#
#     def down
#       add_column :items, :incomplete_items_count
#       add_column :items, :completed_items_count
#     end
#   end
#
# And sometimes you need to do something in SQL not abstracted directly by migrations:
#
#   class MakeJoinUnique < ActiveRecord::Migration[6.0]
#     def up
#       execute "ALTER TABLE `pages_linked_pages` ADD UNIQUE `page_id_linked_page_id` (`page_id`,`linked_page_id`)"
#     end
#
#     def down
#       execute "ALTER TABLE `pages_linked_pages` DROP INDEX `page_id_linked_page_id`"
#     end
#   end
#
# == Using a model after changing its table
#
# Sometimes you'll want to add a column in a migration and populate it
# immediately after. In that case, you'll need to make a call to
# <tt>Base#reset_column_information</tt> in order to ensure that the model has the
# latest column data from after the new column was added. Example:
#
#   class AddPeopleSalary < ActiveRecord::Migration[6.0]
#     def up
#       add_column :people, :salary, :integer
#       Person.reset_column_information
#       Person.all.each do |p|
#         p.update_attribute :salary, SalaryCalculator.compute(p)
#       end
#     end
#   end
#
# == Controlling verbosity
#
# By default, migrations will describe the actions they are taking, writing
# them to the console as they happen, along with benchmarks describing how
# long each step took.
#
# You can quiet them down by setting ActiveRecord::Migration.verbose = false.
#
# You can also insert your own messages and benchmarks by using the +say_with_time+
# method:
#
#   def up
#     ...
#     say_with_time "Updating salaries..." do
#       Person.all.each do |p|
#         p.update_attribute :salary, SalaryCalculator.compute(p)
#       end
#     end
#     ...
#   end
#
# The phrase "Updating salaries..." would then be printed, along with the
# benchmark for the block when the block completes.
#
# == Timestamped Migrations
#
# By default, Rails generates migrations that look like:
#
#    20080717013526_your_migration_name.rb
#
# The prefix is a generation timestamp (in UTC).
#
# If you'd prefer to use numeric prefixes, you can turn timestamped migrations
# off by setting:
#
#    config.active_record.timestamped_migrations = false
#
# In application.rb.
#
# == Reversible Migrations
#
# Reversible migrations are migrations that know how to go +down+ for you.
# You simply supply the +up+ logic, and the Migration system figures out
# how to execute the down commands for you.
#
# To define a reversible migration, define the +change+ method in your
# migration like this:
#
#   class TenderloveMigration < ActiveRecord::Migration[6.0]
#     def change
#       create_table(:horses) do |t|
#         t.column :content, :text
#         t.column :remind_at, :datetime
#       end
#     end
#   end
#
# This migration will create the horses table for you on the way up, and
# automatically figure out how to drop the table on the way down.
#
# Some commands cannot be reversed. If you care to define how to move up
# and down in these cases, you should define the +up+ and +down+ methods
# as before.
#
# If a command cannot be reversed, an
# <tt>ActiveRecord::IrreversibleMigration</tt> exception will be raised when
# the migration is moving down.
#
# For a list of commands that are reversible, please see
# <tt>ActiveRecord::Migration::CommandRecorder</tt>.
#
# == Transactional Migrations
#
# If the database adapter supports DDL transactions, all migrations will
# automatically be wrapped in a transaction. There are queries that you
# can't execute inside a transaction though, and for these situations
# you can turn the automatic transactions off.
#
#   class ChangeEnum < ActiveRecord::Migration[6.0]
#     disable_ddl_transaction!
#
#     def up
#       execute "ALTER TYPE model_size ADD VALUE 'new_value'"
#     end
#   end
#
# Remember that you can still open your own transactions, even if you
# are in a Migration with <tt>self.disable_ddl_transaction!</tt>.
class ActiveRecord::Migration
  # @return [Migration] a new instance of Migration
  def initialize(name = T.unsafe(nil), version = T.unsafe(nil)); end

  def announce(message); end
  def connection; end
  def copy(destination, sources, options = T.unsafe(nil)); end
  def disable_ddl_transaction; end
  def down; end
  def exec_migration(conn, direction); end
  def method_missing(method, *arguments, &block); end

  # Execute this migration in the named direction
  def migrate(direction); end

  # Returns the value of attribute name.
  def name; end

  # Sets the attribute name
  #
  # @param value the value to set the attribute name to.
  def name=(_arg0); end

  # Determines the version number of the next migration.
  def next_migration_number(number); end

  # Finds the correct table name given an Active Record object.
  # Uses the Active Record object's own table_name, or pre/suffix from the
  # options passed in.
  def proper_table_name(name, options = T.unsafe(nil)); end

  # Used to specify an operation that can be run in one direction or another.
  # Call the methods +up+ and +down+ of the yielded object to run a block
  # only in one given direction.
  # The whole block will be called in the right order within the migration.
  #
  # In the following example, the looping on users will always be done
  # when the three columns 'first_name', 'last_name' and 'full_name' exist,
  # even when migrating down:
  #
  #    class SplitNameMigration < ActiveRecord::Migration[6.0]
  #      def change
  #        add_column :users, :first_name, :string
  #        add_column :users, :last_name, :string
  #
  #        reversible do |dir|
  #          User.reset_column_information
  #          User.all.each do |u|
  #            dir.up   { u.first_name, u.last_name = u.full_name.split(' ') }
  #            dir.down { u.full_name = "#{u.first_name} #{u.last_name}" }
  #            u.save
  #          end
  #        end
  #
  #        revert { add_column :users, :full_name, :string }
  #      end
  #    end
  def reversible; end

  # Reverses the migration commands for the given block and
  # the given migrations.
  #
  # The following migration will remove the table 'horses'
  # and create the table 'apples' on the way up, and the reverse
  # on the way down.
  #
  #   class FixTLMigration < ActiveRecord::Migration[6.0]
  #     def change
  #       revert do
  #         create_table(:horses) do |t|
  #           t.text :content
  #           t.datetime :remind_at
  #         end
  #       end
  #       create_table(:apples) do |t|
  #         t.string :variety
  #       end
  #     end
  #   end
  #
  # Or equivalently, if +TenderloveMigration+ is defined as in the
  # documentation for Migration:
  #
  #   require_relative "20121212123456_tenderlove_migration"
  #
  #   class FixupTLMigration < ActiveRecord::Migration[6.0]
  #     def change
  #       revert TenderloveMigration
  #
  #       create_table(:apples) do |t|
  #         t.string :variety
  #       end
  #     end
  #   end
  #
  # This command can be nested.
  def revert(*migration_classes); end

  # @return [Boolean]
  def reverting?; end

  # Runs the given migration classes.
  # Last argument can specify options:
  # - :direction (default is :up)
  # - :revert (default is false)
  def run(*migration_classes); end

  # Takes a message argument and outputs it as is.
  # A second boolean argument can be passed to specify whether to indent or not.
  def say(message, subitem = T.unsafe(nil)); end

  # Outputs text along with how long it took to run its block.
  # If the block returns an integer it assumes it is the number of rows affected.
  def say_with_time(message); end

  # Takes a block as an argument and suppresses any output generated by the block.
  def suppress_messages; end

  # Builds a hash for use in ActiveRecord::Migration#proper_table_name using
  # the Active Record object's table_name prefix and suffix
  def table_name_options(config = T.unsafe(nil)); end

  def up; end

  # Used to specify an operation that is only run when migrating up
  # (for example, populating a new column with its initial values).
  #
  # In the following example, the new column +published+ will be given
  # the value +true+ for all existing records.
  #
  #    class AddPublishedToPosts < ActiveRecord::Migration[6.0]
  #      def change
  #        add_column :posts, :published, :boolean, default: false
  #        up_only do
  #          execute "update posts set published = 'true'"
  #        end
  #      end
  #    end
  def up_only; end

  def verbose; end
  def verbose=(val); end

  # Returns the value of attribute version.
  def version; end

  # Sets the attribute version
  #
  # @param value the value to set the attribute version to.
  def version=(_arg0); end

  def write(text = T.unsafe(nil)); end

  private

  def command_recorder; end
  def execute_block; end

  class << self
    def [](version); end

    # Raises <tt>ActiveRecord::PendingMigrationError</tt> error if any migrations are pending.
    #
    # @raise [ActiveRecord::PendingMigrationError]
    def check_pending!(connection = T.unsafe(nil)); end

    def current_version; end
    def delegate; end
    def delegate=(_arg0); end
    def disable_ddl_transaction; end

    # Disable the transaction wrapping this migration.
    # You can still create your own transactions even after calling #disable_ddl_transaction!
    #
    # For more details read the {"Transactional Migrations" section above}[rdoc-ref:Migration].
    def disable_ddl_transaction!; end

    def disable_ddl_transaction=(_arg0); end
    def inherited(subclass); end
    def load_schema_if_pending!; end
    def maintain_test_schema!; end
    def method_missing(name, *args, &block); end
    def migrate(direction); end
    def nearest_delegate; end
    def verbose; end
    def verbose=(val); end
  end
end

# This class is used to verify that all migrations have been run before
# loading a web page if <tt>config.active_record.migration_error</tt> is set to :page_load
class ActiveRecord::Migration::CheckPending
  # @return [CheckPending] a new instance of CheckPending
  def initialize(app, file_watcher: T.unsafe(nil)); end

  def call(env); end

  private

  def build_watcher(&block); end
  def connection; end
end

# <tt>ActiveRecord::Migration::CommandRecorder</tt> records commands done during
# a migration and knows how to reverse those commands. The CommandRecorder
# knows how to invert the following commands:
#
# * add_column
# * add_foreign_key
# * add_check_constraint
# * add_index
# * add_reference
# * add_timestamps
# * change_column
# * change_column_default (must supply a :from and :to option)
# * change_column_null
# * change_column_comment (must supply a :from and :to option)
# * change_table_comment (must supply a :from and :to option)
# * create_join_table
# * create_table
# * disable_extension
# * drop_join_table
# * drop_table (must supply a block)
# * enable_extension
# * remove_column (must supply a type)
# * remove_columns (must specify at least one column name or more)
# * remove_foreign_key (must supply a second table)
# * remove_check_constraint
# * remove_index
# * remove_reference
# * remove_timestamps
# * rename_column
# * rename_index
# * rename_table
class ActiveRecord::Migration::CommandRecorder
  include ::ActiveRecord::Migration::JoinTable
  include ::ActiveRecord::Migration::CommandRecorder::StraightReversions

  # @return [CommandRecorder] a new instance of CommandRecorder
  def initialize(delegate = T.unsafe(nil)); end

  def add_belongs_to(*args, &block); end
  def add_check_constraint(*args, &block); end
  def add_column(*args, &block); end
  def add_foreign_key(*args, &block); end
  def add_index(*args, &block); end
  def add_reference(*args, &block); end
  def add_timestamps(*args, &block); end
  def change_column(*args, &block); end
  def change_column_comment(*args, &block); end
  def change_column_default(*args, &block); end
  def change_column_null(*args, &block); end

  # @yield [delegate.update_table_definition(table_name, self)]
  def change_table(table_name, **options); end

  def change_table_comment(*args, &block); end

  # Returns the value of attribute commands.
  def commands; end

  # Sets the attribute commands
  #
  # @param value the value to set the attribute commands to.
  def commands=(_arg0); end

  def create_join_table(*args, &block); end
  def create_table(*args, &block); end

  # Returns the value of attribute delegate.
  def delegate; end

  # Sets the attribute delegate
  #
  # @param value the value to set the attribute delegate to.
  def delegate=(_arg0); end

  def disable_extension(*args, &block); end
  def drop_join_table(*args, &block); end
  def drop_table(*args, &block); end
  def enable_extension(*args, &block); end
  def execute(*args, &block); end
  def execute_block(*args, &block); end

  # Returns the inverse of the given command. For example:
  #
  #   recorder.inverse_of(:rename_table, [:old, :new])
  #   # => [:rename_table, [:new, :old]]
  #
  # If the inverse of a command requires several commands, returns array of commands.
  #
  #   recorder.inverse_of(:remove_columns, [:some_table, :foo, :bar, type: :string])
  #   # => [[:add_column, :some_table, :foo, :string], [:add_column, :some_table, :bar, :string]]
  #
  # This method will raise an +IrreversibleMigration+ exception if it cannot
  # invert the +command+.
  #
  # @raise [IrreversibleMigration]
  def inverse_of(command, args, &block); end

  def invert_add_belongs_to(args, &block); end
  def invert_remove_belongs_to(args, &block); end

  # Record +command+. +command+ should be a method name and arguments.
  # For example:
  #
  #   recorder.record(:method_name, [:arg1, :arg2])
  def record(*command, &block); end

  def remove_belongs_to(*args, &block); end
  def remove_check_constraint(*args, &block); end
  def remove_column(*args, &block); end
  def remove_columns(*args, &block); end
  def remove_foreign_key(*args, &block); end
  def remove_index(*args, &block); end
  def remove_reference(*args, &block); end
  def remove_timestamps(*args, &block); end
  def rename_column(*args, &block); end
  def rename_index(*args, &block); end
  def rename_table(*args, &block); end
  def replay(migration); end

  # While executing the given block, the recorded will be in reverting mode.
  # All commands recorded will end up being recorded reverted
  # and in reverse order.
  # For example:
  #
  #   recorder.revert{ recorder.record(:rename_table, [:old, :new]) }
  #   # same effect as recorder.record(:rename_table, [:new, :old])
  def revert; end

  # Returns the value of attribute reverting.
  def reverting; end

  # Sets the attribute reverting
  #
  # @param value the value to set the attribute reverting to.
  def reverting=(_arg0); end

  def transaction(*args, &block); end

  private

  def invert_change_column_comment(args); end
  def invert_change_column_default(args); end
  def invert_change_column_null(args); end
  def invert_change_table_comment(args); end
  def invert_drop_table(args, &block); end

  # @raise [ActiveRecord::IrreversibleMigration]
  def invert_remove_check_constraint(args); end

  # @raise [ActiveRecord::IrreversibleMigration]
  def invert_remove_column(args); end

  def invert_remove_columns(args); end

  # @raise [ActiveRecord::IrreversibleMigration]
  def invert_remove_foreign_key(args); end

  def invert_remove_index(args); end
  def invert_rename_column(args); end
  def invert_rename_index(args); end
  def invert_rename_table(args); end
  def invert_transaction(args); end

  # Forwards any missing method call to the \target.
  def method_missing(method, *args, &block); end

  # @return [Boolean]
  def respond_to_missing?(method, _); end
end

ActiveRecord::Migration::CommandRecorder::ReversibleAndIrreversibleMethods = T.let(T.unsafe(nil), Array)

module ActiveRecord::Migration::CommandRecorder::StraightReversions
  def invert_add_check_constraint(args, &block); end
  def invert_add_column(args, &block); end
  def invert_add_foreign_key(args, &block); end
  def invert_add_index(args, &block); end
  def invert_add_reference(args, &block); end
  def invert_add_timestamps(args, &block); end
  def invert_create_join_table(args, &block); end
  def invert_create_table(args, &block); end
  def invert_disable_extension(args, &block); end
  def invert_drop_join_table(args, &block); end
  def invert_drop_table(args, &block); end
  def invert_enable_extension(args, &block); end
  def invert_execute_block(args, &block); end
  def invert_remove_check_constraint(args, &block); end
  def invert_remove_column(args, &block); end
  def invert_remove_foreign_key(args, &block); end
  def invert_remove_index(args, &block); end
  def invert_remove_reference(args, &block); end
  def invert_remove_timestamps(args, &block); end
end

module ActiveRecord::Migration::Compatibility
  class << self
    def find(version); end
  end
end

class ActiveRecord::Migration::Compatibility::V4_2 < ::ActiveRecord::Migration::Compatibility::V5_0
  def add_belongs_to(table_name, ref_name, **options); end
  def add_reference(table_name, ref_name, **options); end
  def add_timestamps(table_name, **options); end

  # @return [Boolean]
  def index_exists?(table_name, column_name, **options); end

  def remove_index(table_name, column_name = T.unsafe(nil), **options); end

  private

  def compatible_table_definition(t); end
  def index_name_for_remove(table_name, column_name, options); end
end

module ActiveRecord::Migration::Compatibility::V4_2::TableDefinition
  def belongs_to(*_arg0, **options); end
  def references(*_arg0, **options); end
  def timestamps(**options); end
end

class ActiveRecord::Migration::Compatibility::V5_0 < ::ActiveRecord::Migration::Compatibility::V5_1
  def add_belongs_to(table_name, ref_name, **options); end
  def add_column(table_name, column_name, type, **options); end
  def add_reference(table_name, ref_name, **options); end
  def create_join_table(table_1, table_2, column_options: T.unsafe(nil), **options); end
  def create_table(table_name, **options); end

  private

  def compatible_table_definition(t); end
end

module ActiveRecord::Migration::Compatibility::V5_0::TableDefinition
  def belongs_to(*args, **options); end
  def primary_key(name, type = T.unsafe(nil), **options); end
  def references(*args, **options); end
end

class ActiveRecord::Migration::Compatibility::V5_1 < ::ActiveRecord::Migration::Compatibility::V5_2
  def change_column(table_name, column_name, type, **options); end
  def create_table(table_name, **options); end
end

class ActiveRecord::Migration::Compatibility::V5_2 < ::ActiveRecord::Migration::Compatibility::V6_0
  def add_timestamps(table_name, **options); end
  def change_table(table_name, **options); end
  def create_join_table(table_1, table_2, **options); end
  def create_table(table_name, **options); end

  private

  def command_recorder; end
  def compatible_table_definition(t); end
end

module ActiveRecord::Migration::Compatibility::V5_2::CommandRecorder
  def invert_change_column_comment(args); end
  def invert_change_table_comment(args); end
  def invert_transaction(args, &block); end
end

module ActiveRecord::Migration::Compatibility::V5_2::TableDefinition
  def timestamps(**options); end
end

class ActiveRecord::Migration::Compatibility::V6_0 < ::ActiveRecord::Migration::Current
  def add_belongs_to(table_name, ref_name, **options); end
  def add_reference(table_name, ref_name, **options); end
  def change_table(table_name, **options); end
  def create_join_table(table_1, table_2, **options); end
  def create_table(table_name, **options); end

  private

  def compatible_table_definition(t); end
end

class ActiveRecord::Migration::Compatibility::V6_0::ReferenceDefinition < ::ActiveRecord::ConnectionAdapters::ReferenceDefinition
  def index_options(table_name); end
end

module ActiveRecord::Migration::Compatibility::V6_0::SQLite3; end

module ActiveRecord::Migration::Compatibility::V6_0::SQLite3::TableDefinition
  def belongs_to(*args, **options); end
  def column(name, type, index: T.unsafe(nil), **options); end
  def references(*args, **options); end
end

module ActiveRecord::Migration::Compatibility::V6_0::TableDefinition
  def belongs_to(*args, **options); end
  def references(*args, **options); end
end

ActiveRecord::Migration::Compatibility::V6_1 = ActiveRecord::Migration::Current

# This must be defined before the inherited hook, below
class ActiveRecord::Migration::Current < ::ActiveRecord::Migration; end

module ActiveRecord::Migration::JoinTable
  private

  def find_join_table_name(table_1, table_2, options = T.unsafe(nil)); end
  def join_table_name(table_1, table_2); end
end

ActiveRecord::Migration::MigrationFilenameRegexp = T.let(T.unsafe(nil), Regexp)

class ActiveRecord::Migration::ReversibleBlockHelper < ::Struct
  def down; end

  # Returns the value of attribute reverting
  #
  # @return [Object] the current value of reverting
  def reverting; end

  # Sets the attribute reverting
  #
  # @param value [Object] the value to set the attribute reverting to.
  # @return [Object] the newly set value
  def reverting=(_); end

  def up; end

  class << self
    def [](*_arg0); end
    def inspect; end
    def members; end
    def new(*_arg0); end
  end
end

class ActiveRecord::MigrationContext
  # @return [MigrationContext] a new instance of MigrationContext
  def initialize(migrations_paths, schema_migration); end

  # @return [Boolean]
  def any_migrations?; end

  def current_environment; end
  def current_version; end
  def down(target_version = T.unsafe(nil)); end
  def forward(steps = T.unsafe(nil)); end
  def get_all_versions; end

  # @raise [NoEnvironmentInSchemaError]
  def last_stored_environment; end

  def migrate(target_version = T.unsafe(nil), &block); end
  def migrations; end

  # Returns the value of attribute migrations_paths.
  def migrations_paths; end

  def migrations_status; end

  # @return [Boolean]
  def needs_migration?; end

  def open; end

  # @return [Boolean]
  def protected_environment?; end

  def rollback(steps = T.unsafe(nil)); end
  def run(direction, target_version); end

  # Returns the value of attribute schema_migration.
  def schema_migration; end

  def up(target_version = T.unsafe(nil)); end

  private

  def migration_files; end
  def move(direction, steps); end
  def parse_migration_filename(filename); end
end

class ActiveRecord::MigrationError < ::ActiveRecord::ActiveRecordError
  # @return [MigrationError] a new instance of MigrationError
  def initialize(message = T.unsafe(nil)); end
end

# MigrationProxy is used to defer loading of the actual migration classes
# until they are needed
class ActiveRecord::MigrationProxy < ::Struct
  # @return [MigrationProxy] a new instance of MigrationProxy
  def initialize(name, version, filename, scope); end

  def announce(*_arg0, &_arg1); end
  def basename; end
  def disable_ddl_transaction(*_arg0, &_arg1); end

  # Returns the value of attribute filename
  #
  # @return [Object] the current value of filename
  def filename; end

  # Sets the attribute filename
  #
  # @param value [Object] the value to set the attribute filename to.
  # @return [Object] the newly set value
  def filename=(_); end

  def migrate(*_arg0, &_arg1); end

  # Returns the value of attribute name
  #
  # @return [Object] the current value of name
  def name; end

  # Sets the attribute name
  #
  # @param value [Object] the value to set the attribute name to.
  # @return [Object] the newly set value
  def name=(_); end

  # Returns the value of attribute scope
  #
  # @return [Object] the current value of scope
  def scope; end

  # Sets the attribute scope
  #
  # @param value [Object] the value to set the attribute scope to.
  # @return [Object] the newly set value
  def scope=(_); end

  # Returns the value of attribute version
  #
  # @return [Object] the current value of version
  def version; end

  # Sets the attribute version
  #
  # @param value [Object] the value to set the attribute version to.
  # @return [Object] the newly set value
  def version=(_); end

  def write(*_arg0, &_arg1); end

  private

  def load_migration; end
  def migration; end

  class << self
    def [](*_arg0); end
    def inspect; end
    def members; end
    def new(*_arg0); end
  end
end

class ActiveRecord::Migrator
  # @return [Migrator] a new instance of Migrator
  def initialize(direction, migrations, schema_migration, target_version = T.unsafe(nil)); end

  def current; end
  def current_migration; end
  def current_version; end
  def load_migrated; end
  def migrate; end
  def migrated; end
  def migrations; end
  def pending_migrations; end
  def run; end
  def runnable; end

  private

  # Wrap the migration in a transaction only if supported by the adapter.
  def ddl_transaction(migration); end

  # @return [Boolean]
  def down?; end

  def execute_migration_in_transaction(migration); end
  def finish; end
  def generate_migrator_advisory_lock_id; end

  # Return true if a valid version is not provided.
  #
  # @return [Boolean]
  def invalid_target?; end

  # Used for running multiple migrations up to or down to a certain value.
  def migrate_without_lock; end

  # @return [Boolean]
  def ran?(migration); end

  # Stores the current environment in the database.
  def record_environment; end

  def record_version_state_after_migrating(version); end

  # Used for running a specific migration.
  #
  # @raise [UnknownMigrationVersionError]
  def run_without_lock; end

  def start; end
  def target; end

  # @return [Boolean]
  def up?; end

  # @return [Boolean]
  def use_advisory_lock?; end

  # @return [Boolean]
  def use_transaction?(migration); end

  # @raise [DuplicateMigrationNameError]
  def validate(migrations); end

  def with_advisory_lock; end
  def with_advisory_lock_connection; end

  class << self
    # For cases where a table doesn't exist like loading from schema cache
    def current_version; end

    # Returns the value of attribute migrations_paths.
    def migrations_paths; end

    # Sets the attribute migrations_paths
    #
    # @param value the value to set the attribute migrations_paths to.
    def migrations_paths=(_arg0); end
  end
end

ActiveRecord::Migrator::MIGRATOR_SALT = T.let(T.unsafe(nil), Integer)

# Raised when a foreign key constraint cannot be added because the column type does not match the referenced column type.
class ActiveRecord::MismatchedForeignKey < ::ActiveRecord::StatementInvalid
  # @return [MismatchedForeignKey] a new instance of MismatchedForeignKey
  def initialize(message: T.unsafe(nil), sql: T.unsafe(nil), binds: T.unsafe(nil), table: T.unsafe(nil), foreign_key: T.unsafe(nil), target_table: T.unsafe(nil), primary_key: T.unsafe(nil), primary_key_column: T.unsafe(nil)); end
end

module ActiveRecord::ModelSchema
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods

  mixes_in_class_methods GeneratedClassMethods

  class << self
    # Derives the join table name for +first_table+ and +second_table+. The
    # table names appear in alphabetical order. A common prefix is removed
    # (useful for namespaced models like Music::Artist and Music::Record):
    #
    #   artists, records => artists_records
    #   records, artists => artists_records
    #   music_artists, music_records => music_artists_records
    def derive_join_table_name(first_table, second_table); end
  end

  module GeneratedClassMethods
    def immutable_strings_by_default; end
    def immutable_strings_by_default=(value); end
    def immutable_strings_by_default?; end
    def implicit_order_column; end
    def implicit_order_column=(value); end
    def implicit_order_column?; end
    def internal_metadata_table_name; end
    def internal_metadata_table_name=(value); end
    def internal_metadata_table_name?; end
    def pluralize_table_names; end
    def pluralize_table_names=(value); end
    def pluralize_table_names?; end
    def schema_migrations_table_name; end
    def schema_migrations_table_name=(value); end
    def schema_migrations_table_name?; end
    def table_name_prefix; end
    def table_name_prefix=(value); end
    def table_name_prefix?; end
    def table_name_suffix; end
    def table_name_suffix=(value); end
    def table_name_suffix?; end
  end

  module GeneratedInstanceMethods
    def pluralize_table_names; end
    def pluralize_table_names?; end
    def table_name_prefix; end
    def table_name_prefix?; end
    def table_name_suffix; end
    def table_name_suffix?; end
  end
end

module ActiveRecord::ModelSchema::ClassMethods
  def _default_attributes; end
  def attribute_types; end
  def attributes_builder; end

  # Returns a hash where the keys are column names and the values are
  # default values when instantiating the Active Record object for this table.
  def column_defaults; end

  # Returns the column object for the named attribute.
  # Returns an +ActiveRecord::ConnectionAdapters::NullColumn+ if the
  # named attribute does not exist.
  #
  #   class Person < ActiveRecord::Base
  #   end
  #
  #   person = Person.new
  #   person.column_for_attribute(:name) # the result depends on the ConnectionAdapter
  #   # => #<ActiveRecord::ConnectionAdapters::Column:0x007ff4ab083980 @name="name", @sql_type="varchar(255)", @null=true, ...>
  #
  #   person.column_for_attribute(:nothing)
  #   # => #<ActiveRecord::ConnectionAdapters::NullColumn:0xXXX @name=nil, @sql_type=nil, @cast_type=#<Type::Value>, ...>
  def column_for_attribute(name); end

  # Returns an array of column names as strings.
  def column_names; end

  def columns; end
  def columns_hash; end

  # Returns an array of column objects where the primary id, all columns ending in "_id" or "_count",
  # and columns used for single table inheritance have been removed.
  def content_columns; end

  def full_table_name_prefix; end
  def full_table_name_suffix; end

  # The list of columns names the model should ignore. Ignored columns won't have attribute
  # accessors defined, and won't be referenced in SQL queries.
  def ignored_columns; end

  # Sets the columns names the model should ignore. Ignored columns won't have attribute
  # accessors defined, and won't be referenced in SQL queries.
  #
  # A common usage pattern for this method is to ensure all references to an attribute
  # have been removed and deployed, before a migration to drop the column from the database
  # has been deployed and run. Using this two step approach to dropping columns ensures there
  # is no code that raises errors due to having a cached schema in memory at the time the
  # schema migration is run.
  #
  # For example, given a model where you want to drop the "category" attribute, first mark it
  # as ignored:
  #
  #   class Project < ActiveRecord::Base
  #     # schema:
  #     #   id         :bigint
  #     #   name       :string, limit: 255
  #     #   category   :string, limit: 255
  #
  #     self.ignored_columns = [:category]
  #   end
  #
  # The schema still contains "category", but now the model omits it, so any meta-driven code or
  # schema caching will not attempt to use the column:
  #
  #   Project.columns_hash["category"] => nil
  #
  # You will get an error if accessing that attribute directly, so ensure all usages of the
  # column are removed (automated tests can help you find any usages).
  #
  #   user = Project.create!(name: "First Project")
  #   user.category # => raises NoMethodError
  def ignored_columns=(columns); end

  # Defines the name of the table column which will store the class name on single-table
  # inheritance situations.
  #
  # The default inheritance column name is +type+, which means it's a
  # reserved word inside Active Record. To be able to use single-table
  # inheritance with another column name, or to use the column +type+ in
  # your own model for something else, you can set +inheritance_column+:
  #
  #     self.inheritance_column = 'zoink'
  def inheritance_column; end

  # Sets the value of inheritance_column
  def inheritance_column=(value); end

  # Returns the next value that will be used as the primary key on
  # an insert statement.
  def next_sequence_value; end

  # Determines if the primary key values should be selected from their
  # corresponding sequence before the insert statement.
  #
  # @return [Boolean]
  def prefetch_primary_key?; end

  # The array of names of environments where destructive actions should be prohibited. By default,
  # the value is <tt>["production"]</tt>.
  def protected_environments; end

  # Sets an array of names of environments where destructive actions should be prohibited.
  def protected_environments=(environments); end

  # Returns a quoted version of the table name, used to construct SQL statements.
  def quoted_table_name; end

  # Resets all the cached information about columns, which will cause them
  # to be reloaded on the next request.
  #
  # The most common usage pattern for this method is probably in a migration,
  # when just after creating a table you want to populate it with some default
  # values, eg:
  #
  #  class CreateJobLevels < ActiveRecord::Migration[6.0]
  #    def up
  #      create_table :job_levels do |t|
  #        t.integer :id
  #        t.string :name
  #
  #        t.timestamps
  #      end
  #
  #      JobLevel.reset_column_information
  #      %w{assistant executive manager director}.each do |type|
  #        JobLevel.create(name: type)
  #      end
  #    end
  #
  #    def down
  #      drop_table :job_levels
  #    end
  #  end
  def reset_column_information; end

  def reset_sequence_name; end

  # Computes the table name, (re)sets it internally, and returns it.
  def reset_table_name; end

  def sequence_name; end

  # Sets the name of the sequence to use when generating ids to the given
  # value, or (if the value is +nil+ or +false+) to the value returned by the
  # given block. This is required for Oracle and is useful for any
  # database which relies on sequences for primary key generation.
  #
  # If a sequence name is not explicitly set when using Oracle,
  # it will default to the commonly used pattern of: #{table_name}_seq
  #
  # If a sequence name is not explicitly set when using PostgreSQL, it
  # will discover the sequence corresponding to your primary key for you.
  #
  #   class Project < ActiveRecord::Base
  #     self.sequence_name = "projectseq"   # default would have been "project_seq"
  #   end
  def sequence_name=(value); end

  def symbol_column_to_string(name_symbol); end

  # Indicates whether the table associated with this class exists
  #
  # @return [Boolean]
  def table_exists?; end

  # Guesses the table name (in forced lower-case) based on the name of the class in the
  # inheritance hierarchy descending directly from ActiveRecord::Base. So if the hierarchy
  # looks like: Reply < Message < ActiveRecord::Base, then Message is used
  # to guess the table name even when called on Reply. The rules used to do the guess
  # are handled by the Inflector class in Active Support, which knows almost all common
  # English inflections. You can add new inflections in config/initializers/inflections.rb.
  #
  # Nested classes are given table names prefixed by the singular form of
  # the parent's table name. Enclosing modules are not considered.
  #
  # ==== Examples
  #
  #   class Invoice < ActiveRecord::Base
  #   end
  #
  #   file                  class               table_name
  #   invoice.rb            Invoice             invoices
  #
  #   class Invoice < ActiveRecord::Base
  #     class Lineitem < ActiveRecord::Base
  #     end
  #   end
  #
  #   file                  class               table_name
  #   invoice.rb            Invoice::Lineitem   invoice_lineitems
  #
  #   module Invoice
  #     class Lineitem < ActiveRecord::Base
  #     end
  #   end
  #
  #   file                  class               table_name
  #   invoice/lineitem.rb   Invoice::Lineitem   lineitems
  #
  # Additionally, the class-level +table_name_prefix+ is prepended and the
  # +table_name_suffix+ is appended. So if you have "myapp_" as a prefix,
  # the table name guess for an Invoice class becomes "myapp_invoices".
  # Invoice::Lineitem becomes "myapp_invoice_lineitems".
  #
  # You can also set your own table name explicitly:
  #
  #   class Mouse < ActiveRecord::Base
  #     self.table_name = "mice"
  #   end
  def table_name; end

  # Sets the table name explicitly. Example:
  #
  #   class Project < ActiveRecord::Base
  #     self.table_name = "project"
  #   end
  def table_name=(value); end

  # Returns the type of the attribute with the given name, after applying
  # all modifiers. This method is the only valid source of information for
  # anything related to the types of a model's attributes. This method will
  # access the database and load the model's schema if it is required.
  #
  # The return value of this method will implement the interface described
  # by ActiveModel::Type::Value (though the object itself may not subclass
  # it).
  #
  # +attr_name+ The name of the attribute to retrieve the type for. Must be
  # a string or a symbol.
  def type_for_attribute(attr_name, &block); end

  def yaml_encoder; end

  protected

  def initialize_load_schema_monitor; end

  private

  def _convert_type_from_options(type); end

  # Computes and returns a table name according to default conventions.
  def compute_table_name; end

  def inherited(child_class); end
  def load_schema; end
  def load_schema!; end
  def reload_schema_from_cache; end

  # @return [Boolean]
  def schema_loaded?; end

  # Guesses the table name, but does not decorate it with prefix and suffix information.
  def undecorated_table_name(class_name = T.unsafe(nil)); end

  def warn_if_deprecated_type(column); end
end

# Raised when there are multiple errors while doing a mass assignment through the
# {ActiveRecord::Base#attributes=}[rdoc-ref:AttributeAssignment#attributes=]
# method. The exception has an +errors+ property that contains an array of AttributeAssignmentError
# objects, each corresponding to the error while assigning to an attribute.
class ActiveRecord::MultiparameterAssignmentErrors < ::ActiveRecord::ActiveRecordError
  # @return [MultiparameterAssignmentErrors] a new instance of MultiparameterAssignmentErrors
  def initialize(errors = T.unsafe(nil)); end

  # Returns the value of attribute errors.
  def errors; end
end

module ActiveRecord::NestedAttributes
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::ActiveRecord::NestedAttributes::ClassMethods

  # Returns ActiveRecord::AutosaveAssociation::marked_for_destruction? It's
  # used in conjunction with fields_for to build a form element for the
  # destruction of this association.
  #
  # See ActionView::Helpers::FormHelper::fields_for for more info.
  def _destroy; end

  private

  # @return [Boolean]
  def allow_destroy?(association_name); end

  # Assigns the given attributes to the collection association.
  #
  # Hashes with an <tt>:id</tt> value matching an existing associated record
  # will update that record. Hashes without an <tt>:id</tt> value will build
  # a new record for the association. Hashes with a matching <tt>:id</tt>
  # value and a <tt>:_destroy</tt> key set to a truthy value will mark the
  # matched record for destruction.
  #
  # For example:
  #
  #   assign_nested_attributes_for_collection_association(:people, {
  #     '1' => { id: '1', name: 'Peter' },
  #     '2' => { name: 'John' },
  #     '3' => { id: '2', _destroy: true }
  #   })
  #
  # Will update the name of the Person with ID 1, build a new associated
  # person with the name 'John', and mark the associated Person with ID 2
  # for destruction.
  #
  # Also accepts an Array of attribute hashes:
  #
  #   assign_nested_attributes_for_collection_association(:people, [
  #     { id: '1', name: 'Peter' },
  #     { name: 'John' },
  #     { id: '2', _destroy: true }
  #   ])
  def assign_nested_attributes_for_collection_association(association_name, attributes_collection); end

  # Assigns the given attributes to the association.
  #
  # If an associated record does not yet exist, one will be instantiated. If
  # an associated record already exists, the method's behavior depends on
  # the value of the update_only option. If update_only is +false+ and the
  # given attributes include an <tt>:id</tt> that matches the existing record's
  # id, then the existing record will be modified. If no <tt>:id</tt> is provided
  # it will be replaced with a new record. If update_only is +true+ the existing
  # record will be modified regardless of whether an <tt>:id</tt> is provided.
  #
  # If the given attributes include a matching <tt>:id</tt> attribute, or
  # update_only is true, and a <tt>:_destroy</tt> key set to a truthy value,
  # then the existing record will be marked for destruction.
  def assign_nested_attributes_for_one_to_one_association(association_name, attributes); end

  # Updates a record with the +attributes+ or marks it for destruction if
  # +allow_destroy+ is +true+ and has_destroy_flag? returns +true+.
  def assign_to_or_mark_for_destruction(record, attributes, allow_destroy); end

  # Determines if a record with the particular +attributes+ should be
  # rejected by calling the reject_if Symbol or Proc (if defined).
  # The reject_if option is defined by +accepts_nested_attributes_for+.
  #
  # Returns false if there is a +destroy_flag+ on the attributes.
  def call_reject_if(association_name, attributes); end

  # Takes in a limit and checks if the attributes_collection has too many
  # records. It accepts limit in the form of symbol, proc, or
  # number-like object (anything that can be compared with an integer).
  #
  # Raises TooManyRecords error if the attributes_collection is
  # larger than the limit.
  def check_record_limit!(limit, attributes_collection); end

  # Determines if a hash contains a truthy _destroy key.
  #
  # @return [Boolean]
  def has_destroy_flag?(hash); end

  # @raise [RecordNotFound]
  def raise_nested_attributes_record_not_found!(association_name, record_id); end

  # Determines if a new record should be rejected by checking
  # has_destroy_flag? or if a <tt>:reject_if</tt> proc exists for this
  # association and evaluates to +true+.
  #
  # @return [Boolean]
  def reject_new_record?(association_name, attributes); end

  # Only take into account the destroy flag if <tt>:allow_destroy</tt> is true
  #
  # @return [Boolean]
  def will_be_destroyed?(association_name, attributes); end

  module GeneratedClassMethods
    def nested_attributes_options; end
    def nested_attributes_options=(value); end
    def nested_attributes_options?; end
  end

  module GeneratedInstanceMethods
    def nested_attributes_options; end
    def nested_attributes_options?; end
  end
end

# = Active Record Nested Attributes
#
# Nested attributes allow you to save attributes on associated records
# through the parent. By default nested attribute updating is turned off
# and you can enable it using the accepts_nested_attributes_for class
# method. When you enable nested attributes an attribute writer is
# defined on the model.
#
# The attribute writer is named after the association, which means that
# in the following example, two new methods are added to your model:
#
# <tt>author_attributes=(attributes)</tt> and
# <tt>pages_attributes=(attributes)</tt>.
#
#   class Book < ActiveRecord::Base
#     has_one :author
#     has_many :pages
#
#     accepts_nested_attributes_for :author, :pages
#   end
#
# Note that the <tt>:autosave</tt> option is automatically enabled on every
# association that accepts_nested_attributes_for is used for.
#
# === One-to-one
#
# Consider a Member model that has one Avatar:
#
#   class Member < ActiveRecord::Base
#     has_one :avatar
#     accepts_nested_attributes_for :avatar
#   end
#
# Enabling nested attributes on a one-to-one association allows you to
# create the member and avatar in one go:
#
#   params = { member: { name: 'Jack', avatar_attributes: { icon: 'smiling' } } }
#   member = Member.create(params[:member])
#   member.avatar.id # => 2
#   member.avatar.icon # => 'smiling'
#
# It also allows you to update the avatar through the member:
#
#   params = { member: { avatar_attributes: { id: '2', icon: 'sad' } } }
#   member.update params[:member]
#   member.avatar.icon # => 'sad'
#
# If you want to update the current avatar without providing the id, you must add <tt>:update_only</tt> option.
#
#   class Member < ActiveRecord::Base
#     has_one :avatar
#     accepts_nested_attributes_for :avatar, update_only: true
#   end
#
#   params = { member: { avatar_attributes: { icon: 'sad' } } }
#   member.update params[:member]
#   member.avatar.id # => 2
#   member.avatar.icon # => 'sad'
#
# By default you will only be able to set and update attributes on the
# associated model. If you want to destroy the associated model through the
# attributes hash, you have to enable it first using the
# <tt>:allow_destroy</tt> option.
#
#   class Member < ActiveRecord::Base
#     has_one :avatar
#     accepts_nested_attributes_for :avatar, allow_destroy: true
#   end
#
# Now, when you add the <tt>_destroy</tt> key to the attributes hash, with a
# value that evaluates to +true+, you will destroy the associated model:
#
#   member.avatar_attributes = { id: '2', _destroy: '1' }
#   member.avatar.marked_for_destruction? # => true
#   member.save
#   member.reload.avatar # => nil
#
# Note that the model will _not_ be destroyed until the parent is saved.
#
# Also note that the model will not be destroyed unless you also specify
# its id in the updated hash.
#
# === One-to-many
#
# Consider a member that has a number of posts:
#
#   class Member < ActiveRecord::Base
#     has_many :posts
#     accepts_nested_attributes_for :posts
#   end
#
# You can now set or update attributes on the associated posts through
# an attribute hash for a member: include the key +:posts_attributes+
# with an array of hashes of post attributes as a value.
#
# For each hash that does _not_ have an <tt>id</tt> key a new record will
# be instantiated, unless the hash also contains a <tt>_destroy</tt> key
# that evaluates to +true+.
#
#   params = { member: {
#     name: 'joe', posts_attributes: [
#       { title: 'Kari, the awesome Ruby documentation browser!' },
#       { title: 'The egalitarian assumption of the modern citizen' },
#       { title: '', _destroy: '1' } # this will be ignored
#     ]
#   }}
#
#   member = Member.create(params[:member])
#   member.posts.length # => 2
#   member.posts.first.title # => 'Kari, the awesome Ruby documentation browser!'
#   member.posts.second.title # => 'The egalitarian assumption of the modern citizen'
#
# You may also set a +:reject_if+ proc to silently ignore any new record
# hashes if they fail to pass your criteria. For example, the previous
# example could be rewritten as:
#
#   class Member < ActiveRecord::Base
#     has_many :posts
#     accepts_nested_attributes_for :posts, reject_if: proc { |attributes| attributes['title'].blank? }
#   end
#
#   params = { member: {
#     name: 'joe', posts_attributes: [
#       { title: 'Kari, the awesome Ruby documentation browser!' },
#       { title: 'The egalitarian assumption of the modern citizen' },
#       { title: '' } # this will be ignored because of the :reject_if proc
#     ]
#   }}
#
#   member = Member.create(params[:member])
#   member.posts.length # => 2
#   member.posts.first.title # => 'Kari, the awesome Ruby documentation browser!'
#   member.posts.second.title # => 'The egalitarian assumption of the modern citizen'
#
# Alternatively, +:reject_if+ also accepts a symbol for using methods:
#
#   class Member < ActiveRecord::Base
#     has_many :posts
#     accepts_nested_attributes_for :posts, reject_if: :new_record?
#   end
#
#   class Member < ActiveRecord::Base
#     has_many :posts
#     accepts_nested_attributes_for :posts, reject_if: :reject_posts
#
#     def reject_posts(attributes)
#       attributes['title'].blank?
#     end
#   end
#
# If the hash contains an <tt>id</tt> key that matches an already
# associated record, the matching record will be modified:
#
#   member.attributes = {
#     name: 'Joe',
#     posts_attributes: [
#       { id: 1, title: '[UPDATED] An, as of yet, undisclosed awesome Ruby documentation browser!' },
#       { id: 2, title: '[UPDATED] other post' }
#     ]
#   }
#
#   member.posts.first.title # => '[UPDATED] An, as of yet, undisclosed awesome Ruby documentation browser!'
#   member.posts.second.title # => '[UPDATED] other post'
#
# However, the above applies if the parent model is being updated as well.
# For example, If you wanted to create a +member+ named _joe_ and wanted to
# update the +posts+ at the same time, that would give an
# ActiveRecord::RecordNotFound error.
#
# By default the associated records are protected from being destroyed. If
# you want to destroy any of the associated records through the attributes
# hash, you have to enable it first using the <tt>:allow_destroy</tt>
# option. This will allow you to also use the <tt>_destroy</tt> key to
# destroy existing records:
#
#   class Member < ActiveRecord::Base
#     has_many :posts
#     accepts_nested_attributes_for :posts, allow_destroy: true
#   end
#
#   params = { member: {
#     posts_attributes: [{ id: '2', _destroy: '1' }]
#   }}
#
#   member.attributes = params[:member]
#   member.posts.detect { |p| p.id == 2 }.marked_for_destruction? # => true
#   member.posts.length # => 2
#   member.save
#   member.reload.posts.length # => 1
#
# Nested attributes for an associated collection can also be passed in
# the form of a hash of hashes instead of an array of hashes:
#
#   Member.create(
#     name: 'joe',
#     posts_attributes: {
#       first:  { title: 'Foo' },
#       second: { title: 'Bar' }
#     }
#   )
#
# has the same effect as
#
#   Member.create(
#     name: 'joe',
#     posts_attributes: [
#       { title: 'Foo' },
#       { title: 'Bar' }
#     ]
#   )
#
# The keys of the hash which is the value for +:posts_attributes+ are
# ignored in this case.
# However, it is not allowed to use <tt>'id'</tt> or <tt>:id</tt> for one of
# such keys, otherwise the hash will be wrapped in an array and
# interpreted as an attribute hash for a single post.
#
# Passing attributes for an associated collection in the form of a hash
# of hashes can be used with hashes generated from HTTP/HTML parameters,
# where there may be no natural way to submit an array of hashes.
#
# === Saving
#
# All changes to models, including the destruction of those marked for
# destruction, are saved and destroyed automatically and atomically when
# the parent model is saved. This happens inside the transaction initiated
# by the parent's save method. See ActiveRecord::AutosaveAssociation.
#
# === Validating the presence of a parent model
#
# If you want to validate that a child record is associated with a parent
# record, you can use the +validates_presence_of+ method and the +:inverse_of+
# key as this example illustrates:
#
#   class Member < ActiveRecord::Base
#     has_many :posts, inverse_of: :member
#     accepts_nested_attributes_for :posts
#   end
#
#   class Post < ActiveRecord::Base
#     belongs_to :member, inverse_of: :posts
#     validates_presence_of :member
#   end
#
# Note that if you do not specify the +:inverse_of+ option, then
# Active Record will try to automatically guess the inverse association
# based on heuristics.
#
# For one-to-one nested associations, if you build the new (in-memory)
# child object yourself before assignment, then this module will not
# overwrite it, e.g.:
#
#   class Member < ActiveRecord::Base
#     has_one :avatar
#     accepts_nested_attributes_for :avatar
#
#     def avatar
#       super || build_avatar(width: 200)
#     end
#   end
#
#   member = Member.new
#   member.avatar_attributes = {icon: 'sad'}
#   member.avatar.width # => 200
module ActiveRecord::NestedAttributes::ClassMethods
  # Defines an attributes writer for the specified association(s).
  #
  # Supported options:
  # [:allow_destroy]
  #   If true, destroys any members from the attributes hash with a
  #   <tt>_destroy</tt> key and a value that evaluates to +true+
  #   (e.g. 1, '1', true, or 'true'). This option is off by default.
  # [:reject_if]
  #   Allows you to specify a Proc or a Symbol pointing to a method
  #   that checks whether a record should be built for a certain attribute
  #   hash. The hash is passed to the supplied Proc or the method
  #   and it should return either +true+ or +false+. When no +:reject_if+
  #   is specified, a record will be built for all attribute hashes that
  #   do not have a <tt>_destroy</tt> value that evaluates to true.
  #   Passing <tt>:all_blank</tt> instead of a Proc will create a proc
  #   that will reject a record where all the attributes are blank excluding
  #   any value for +_destroy+.
  # [:limit]
  #   Allows you to specify the maximum number of associated records that
  #   can be processed with the nested attributes. Limit also can be specified
  #   as a Proc or a Symbol pointing to a method that should return a number.
  #   If the size of the nested attributes array exceeds the specified limit,
  #   NestedAttributes::TooManyRecords exception is raised. If omitted, any
  #   number of associations can be processed.
  #   Note that the +:limit+ option is only applicable to one-to-many
  #   associations.
  # [:update_only]
  #   For a one-to-one association, this option allows you to specify how
  #   nested attributes are going to be used when an associated record already
  #   exists. In general, an existing record may either be updated with the
  #   new set of attribute values or be replaced by a wholly new record
  #   containing those values. By default the +:update_only+ option is +false+
  #   and the nested attributes are used to update the existing record only
  #   if they include the record's <tt>:id</tt> value. Otherwise a new
  #   record will be instantiated and used to replace the existing one.
  #   However if the +:update_only+ option is +true+, the nested attributes
  #   are used to update the record's attributes always, regardless of
  #   whether the <tt>:id</tt> is present. The option is ignored for collection
  #   associations.
  #
  # Examples:
  #   # creates avatar_attributes=
  #   accepts_nested_attributes_for :avatar, reject_if: proc { |attributes| attributes['name'].blank? }
  #   # creates avatar_attributes=
  #   accepts_nested_attributes_for :avatar, reject_if: :all_blank
  #   # creates avatar_attributes= and posts_attributes=
  #   accepts_nested_attributes_for :avatar, :posts, allow_destroy: true
  def accepts_nested_attributes_for(*attr_names); end

  private

  # Generates a writer method for this association. Serves as a point for
  # accessing the objects in the association. For example, this method
  # could generate the following:
  #
  #   def pirate_attributes=(attributes)
  #     assign_nested_attributes_for_one_to_one_association(:pirate, attributes)
  #   end
  #
  # This redirects the attempts to write objects in an association through
  # the helper methods defined below. Makes it seem like the nested
  # associations are just regular associations.
  def generate_association_writer(association_name, type); end
end

ActiveRecord::NestedAttributes::ClassMethods::REJECT_ALL_BLANK_PROC = T.let(T.unsafe(nil), Proc)
class ActiveRecord::NestedAttributes::TooManyRecords < ::ActiveRecord::ActiveRecordError; end

# Attribute hash keys that should not be assigned as normal attributes.
# These hash keys are nested attributes implementation details.
ActiveRecord::NestedAttributes::UNASSIGNABLE_KEYS = T.let(T.unsafe(nil), Array)

# Raised when a given database does not exist.
class ActiveRecord::NoDatabaseError < ::ActiveRecord::StatementInvalid; end

class ActiveRecord::NoEnvironmentInSchemaError < ::ActiveRecord::MigrationError
  # @return [NoEnvironmentInSchemaError] a new instance of NoEnvironmentInSchemaError
  def initialize; end
end

# = Active Record No Touching
module ActiveRecord::NoTouching
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::ActiveRecord::NoTouching::ClassMethods

  # Returns +true+ if the class has +no_touching+ set, +false+ otherwise.
  #
  #   Project.no_touching do
  #     Project.first.no_touching? # true
  #     Message.first.no_touching? # false
  #   end
  #
  # @return [Boolean]
  def no_touching?; end

  def touch(*_arg0, **_arg1); end
  def touch_later(*_arg0); end

  class << self
    # @return [Boolean]
    def applied_to?(klass); end

    def apply_to(klass); end

    private

    def klasses; end
  end
end

module ActiveRecord::NoTouching::ClassMethods
  # Lets you selectively disable calls to +touch+ for the
  # duration of a block.
  #
  # ==== Examples
  #   ActiveRecord::Base.no_touching do
  #     Project.first.touch  # does nothing
  #     Message.first.touch  # does nothing
  #   end
  #
  #   Project.no_touching do
  #     Project.first.touch  # does nothing
  #     Message.first.touch  # works, but does not touch the associated project
  #   end
  def no_touching(&block); end
end

# Raised when a record cannot be inserted or updated because it would violate a not null constraint.
class ActiveRecord::NotNullViolation < ::ActiveRecord::StatementInvalid; end

module ActiveRecord::NullRelation
  # @return [Boolean]
  def any?; end

  def calculate(operation, _column_name); end
  def delete(_id_or_array); end
  def delete_all; end

  # @return [Boolean]
  def empty?; end

  # @return [Boolean]
  def exists?(_conditions = T.unsafe(nil)); end

  # @return [Boolean]
  def many?; end

  # @return [Boolean]
  def none?; end

  # @return [Boolean]
  def one?; end

  def or(other); end
  def pluck(*column_names); end
  def to_sql; end
  def update_all(_updates); end

  private

  def exec_queries; end
end

class ActiveRecord::PendingMigrationError < ::ActiveRecord::MigrationError
  include ::ActiveSupport::ActionableError
  extend ::ActiveSupport::ActionableError::ClassMethods

  # @return [PendingMigrationError] a new instance of PendingMigrationError
  def initialize(message = T.unsafe(nil)); end

  def _actions; end
  def _actions=(_arg0); end
  def _actions?; end

  private

  def detailed_migration_message; end

  class << self
    def _actions; end
    def _actions=(value); end
    def _actions?; end
  end
end

# = Active Record \Persistence
module ActiveRecord::Persistence
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::ActiveRecord::Persistence::ClassMethods

  # Returns an instance of the specified +klass+ with the attributes of the
  # current record. This is mostly useful in relation to single-table
  # inheritance structures where you want a subclass to appear as the
  # superclass. This can be used along with record identification in
  # Action Pack to allow, say, <tt>Client < Company</tt> to do something
  # like render <tt>partial: @client.becomes(Company)</tt> to render that
  # instance using the companies/company partial instead of clients/client.
  #
  # Note: The new instance will share a link to the same attributes as the original class.
  # Therefore the sti column value will still be the same.
  # Any change to the attributes on either instance will affect both instances.
  # If you want to change the sti column as well, use #becomes! instead.
  def becomes(klass); end

  # Wrapper around #becomes that also changes the instance's sti column value.
  # This is especially useful if you want to persist the changed class in your
  # database.
  #
  # Note: The old instance's sti column value will be changed too, as both objects
  # share the same set of attributes.
  def becomes!(klass); end

  # Initializes +attribute+ to zero if +nil+ and subtracts the value passed as +by+ (default is 1).
  # The decrement is performed directly on the underlying attribute, no setter is invoked.
  # Only makes sense for number-based attributes. Returns +self+.
  def decrement(attribute, by = T.unsafe(nil)); end

  # Wrapper around #decrement that writes the update to the database.
  # Only +attribute+ is updated; the record itself is not saved.
  # This means that any other modified attributes will still be dirty.
  # Validations and callbacks are skipped. Supports the +touch+ option from
  # +update_counters+, see that for more.
  # Returns +self+.
  def decrement!(attribute, by = T.unsafe(nil), touch: T.unsafe(nil)); end

  # Deletes the record in the database and freezes this instance to
  # reflect that no changes should be made (since they can't be
  # persisted). Returns the frozen instance.
  #
  # The row is simply removed with an SQL +DELETE+ statement on the
  # record's primary key, and no callbacks are executed.
  #
  # Note that this will also delete records marked as {#readonly?}[rdoc-ref:Core#readonly?].
  #
  # To enforce the object's +before_destroy+ and +after_destroy+
  # callbacks or any <tt>:dependent</tt> association
  # options, use #destroy.
  def delete; end

  # Deletes the record in the database and freezes this instance to reflect
  # that no changes should be made (since they can't be persisted).
  #
  # There's a series of callbacks associated with #destroy. If the
  # <tt>before_destroy</tt> callback throws +:abort+ the action is cancelled
  # and #destroy returns +false+.
  # See ActiveRecord::Callbacks for further details.
  def destroy; end

  # Deletes the record in the database and freezes this instance to reflect
  # that no changes should be made (since they can't be persisted).
  #
  # There's a series of callbacks associated with #destroy!. If the
  # <tt>before_destroy</tt> callback throws +:abort+ the action is cancelled
  # and #destroy! raises ActiveRecord::RecordNotDestroyed.
  # See ActiveRecord::Callbacks for further details.
  def destroy!; end

  # Returns true if this object has been destroyed, otherwise returns false.
  #
  # @return [Boolean]
  def destroyed?; end

  # Initializes +attribute+ to zero if +nil+ and adds the value passed as +by+ (default is 1).
  # The increment is performed directly on the underlying attribute, no setter is invoked.
  # Only makes sense for number-based attributes. Returns +self+.
  def increment(attribute, by = T.unsafe(nil)); end

  # Wrapper around #increment that writes the update to the database.
  # Only +attribute+ is updated; the record itself is not saved.
  # This means that any other modified attributes will still be dirty.
  # Validations and callbacks are skipped. Supports the +touch+ option from
  # +update_counters+, see that for more.
  # Returns +self+.
  def increment!(attribute, by = T.unsafe(nil), touch: T.unsafe(nil)); end

  # Returns true if this object hasn't been saved yet -- that is, a record
  # for the object doesn't exist in the database yet; otherwise, returns false.
  #
  # @return [Boolean]
  def new_record?; end

  # Returns true if the record is persisted, i.e. it's not a new record and it was
  # not destroyed, otherwise returns false.
  #
  # @return [Boolean]
  def persisted?; end

  # Returns true if this object was just created -- that is, prior to the last
  # save, the object didn't exist in the database and new_record? would have
  # returned true.
  #
  # @return [Boolean]
  def previously_new_record?; end

  # Reloads the record from the database.
  #
  # This method finds the record by its primary key (which could be assigned
  # manually) and modifies the receiver in-place:
  #
  #   account = Account.new
  #   # => #<Account id: nil, email: nil>
  #   account.id = 1
  #   account.reload
  #   # Account Load (1.2ms)  SELECT "accounts".* FROM "accounts" WHERE "accounts"."id" = $1 LIMIT 1  [["id", 1]]
  #   # => #<Account id: 1, email: 'account@example.com'>
  #
  # Attributes are reloaded from the database, and caches busted, in
  # particular the associations cache and the QueryCache.
  #
  # If the record no longer exists in the database ActiveRecord::RecordNotFound
  # is raised. Otherwise, in addition to the in-place modification the method
  # returns +self+ for convenience.
  #
  # The optional <tt>:lock</tt> flag option allows you to lock the reloaded record:
  #
  #   reload(lock: true) # reload with pessimistic locking
  #
  # Reloading is commonly used in test suites to test something is actually
  # written to the database, or when some action modifies the corresponding
  # row in the database but not the object in memory:
  #
  #   assert account.deposit!(25)
  #   assert_equal 25, account.credit        # check it is updated in memory
  #   assert_equal 25, account.reload.credit # check it is also persisted
  #
  # Another common use case is optimistic locking handling:
  #
  #   def with_optimistic_retry
  #     begin
  #       yield
  #     rescue ActiveRecord::StaleObjectError
  #       begin
  #         # Reload lock_version in particular.
  #         reload
  #       rescue ActiveRecord::RecordNotFound
  #         # If the record is gone there is nothing to do.
  #       else
  #         retry
  #       end
  #     end
  #   end
  def reload(options = T.unsafe(nil)); end

  # :call-seq:
  #   save(**options)
  #
  # Saves the model.
  #
  # If the model is new, a record gets created in the database, otherwise
  # the existing record gets updated.
  #
  # By default, save always runs validations. If any of them fail the action
  # is cancelled and #save returns +false+, and the record won't be saved. However, if you supply
  # <tt>validate: false</tt>, validations are bypassed altogether. See
  # ActiveRecord::Validations for more information.
  #
  # By default, #save also sets the +updated_at+/+updated_on+ attributes to
  # the current time. However, if you supply <tt>touch: false</tt>, these
  # timestamps will not be updated.
  #
  # There's a series of callbacks associated with #save. If any of the
  # <tt>before_*</tt> callbacks throws +:abort+ the action is cancelled and
  # #save returns +false+. See ActiveRecord::Callbacks for further
  # details.
  #
  # Attributes marked as readonly are silently ignored if the record is
  # being updated.
  def save(**options, &block); end

  # :call-seq:
  #   save!(**options)
  #
  # Saves the model.
  #
  # If the model is new, a record gets created in the database, otherwise
  # the existing record gets updated.
  #
  # By default, #save! always runs validations. If any of them fail
  # ActiveRecord::RecordInvalid gets raised, and the record won't be saved. However, if you supply
  # <tt>validate: false</tt>, validations are bypassed altogether. See
  # ActiveRecord::Validations for more information.
  #
  # By default, #save! also sets the +updated_at+/+updated_on+ attributes to
  # the current time. However, if you supply <tt>touch: false</tt>, these
  # timestamps will not be updated.
  #
  # There's a series of callbacks associated with #save!. If any of
  # the <tt>before_*</tt> callbacks throws +:abort+ the action is cancelled
  # and #save! raises ActiveRecord::RecordNotSaved. See
  # ActiveRecord::Callbacks for further details.
  #
  # Attributes marked as readonly are silently ignored if the record is
  # being updated.
  #
  # Unless an error is raised, returns true.
  def save!(**options, &block); end

  # Assigns to +attribute+ the boolean opposite of <tt>attribute?</tt>. So
  # if the predicate returns +true+ the attribute will become +false+. This
  # method toggles directly the underlying value without calling any setter.
  # Returns +self+.
  #
  # Example:
  #
  #   user = User.first
  #   user.banned? # => false
  #   user.toggle(:banned)
  #   user.banned? # => true
  def toggle(attribute); end

  # Wrapper around #toggle that saves the record. This method differs from
  # its non-bang version in the sense that it passes through the attribute setter.
  # Saving is not subjected to validation checks. Returns +true+ if the
  # record could be saved.
  def toggle!(attribute); end

  # Saves the record with the updated_at/on attributes set to the current time
  # or the time specified.
  # Please note that no validation is performed and only the +after_touch+,
  # +after_commit+ and +after_rollback+ callbacks are executed.
  #
  # This method can be passed attribute names and an optional time argument.
  # If attribute names are passed, they are updated along with updated_at/on
  # attributes. If no time argument is passed, the current time is used as default.
  #
  #   product.touch                         # updates updated_at/on with current time
  #   product.touch(time: Time.new(2015, 2, 16, 0, 0, 0)) # updates updated_at/on with specified time
  #   product.touch(:designed_at)           # updates the designed_at attribute and updated_at/on
  #   product.touch(:started_at, :ended_at) # updates started_at, ended_at and updated_at/on attributes
  #
  # If used along with {belongs_to}[rdoc-ref:Associations::ClassMethods#belongs_to]
  # then +touch+ will invoke +touch+ method on associated object.
  #
  #   class Brake < ActiveRecord::Base
  #     belongs_to :car, touch: true
  #   end
  #
  #   class Car < ActiveRecord::Base
  #     belongs_to :corporation, touch: true
  #   end
  #
  #   # triggers @brake.car.touch and @brake.car.corporation.touch
  #   @brake.touch
  #
  # Note that +touch+ must be used on a persisted object, or else an
  # ActiveRecordError will be thrown. For example:
  #
  #   ball = Ball.new
  #   ball.touch(:updated_at)   # => raises ActiveRecordError
  def touch(*names, time: T.unsafe(nil)); end

  # Updates the attributes of the model from the passed-in hash and saves the
  # record, all wrapped in a transaction. If the object is invalid, the saving
  # will fail and false will be returned.
  def update(attributes); end

  # Updates its receiver just like #update but calls #save! instead
  # of +save+, so an exception is raised if the record is invalid and saving will fail.
  def update!(attributes); end

  # Updates a single attribute and saves the record.
  # This is especially useful for boolean flags on existing records. Also note that
  #
  # * Validation is skipped.
  # * \Callbacks are invoked.
  # * updated_at/updated_on column is updated if that column is available.
  # * Updates all the attributes that are dirty in this object.
  #
  # This method raises an ActiveRecord::ActiveRecordError  if the
  # attribute is marked as readonly.
  #
  # Also see #update_column.
  def update_attribute(name, value); end

  # Equivalent to <code>update_columns(name => value)</code>.
  def update_column(name, value); end

  # Updates the attributes directly in the database issuing an UPDATE SQL
  # statement and sets them in the receiver:
  #
  #   user.update_columns(last_request_at: Time.current)
  #
  # This is the fastest way to update attributes because it goes straight to
  # the database, but take into account that in consequence the regular update
  # procedures are totally bypassed. In particular:
  #
  # * \Validations are skipped.
  # * \Callbacks are skipped.
  # * +updated_at+/+updated_on+ are not updated.
  # * However, attributes are serialized with the same rules as ActiveRecord::Relation#update_all
  #
  # This method raises an ActiveRecord::ActiveRecordError when called on new
  # objects, or when at least one of the attributes is marked as readonly.
  #
  # @raise [ActiveRecordError]
  def update_columns(attributes); end

  private

  # Creates a record with values matching those of the instance attributes
  # and returns its id.
  #
  # @yield [_self]
  # @yieldparam _self [ActiveRecord::Persistence] the object that the method was called on
  def _create_record(attribute_names = T.unsafe(nil)); end

  def _delete_row; end

  # @raise [ReadOnlyRecord]
  def _raise_readonly_record_error; end

  def _raise_record_not_destroyed; end

  # @raise [ActiveRecordError]
  def _raise_record_not_touched_error; end

  def _touch_row(attribute_names, time); end

  # Updates the associated record with values matching those of the instance attributes.
  # Returns the number of affected rows.
  #
  # @yield [_self]
  # @yieldparam _self [ActiveRecord::Persistence] the object that the method was called on
  def _update_record(attribute_names = T.unsafe(nil)); end

  def _update_row(attribute_names, attempted_action = T.unsafe(nil)); end

  # The name of the method used to touch a +belongs_to+ association when the
  # +:touch+ option is used.
  def belongs_to_touch_method; end

  def create_or_update(**_arg0, &block); end

  # A hook to be overridden by association modules.
  def destroy_associations; end

  def destroy_row; end

  # @raise [ActiveRecordError]
  def verify_readonly_attribute(name); end
end

module ActiveRecord::Persistence::ClassMethods
  def _delete_record(constraints); end
  def _insert_record(values); end
  def _update_record(values, constraints); end

  # Creates an object (or multiple objects) and saves it to the database, if validations pass.
  # The resulting object is returned whether the object was saved successfully to the database or not.
  #
  # The +attributes+ parameter can be either a Hash or an Array of Hashes. These Hashes describe the
  # attributes on the objects that are to be created.
  #
  # ==== Examples
  #   # Create a single new object
  #   User.create(first_name: 'Jamie')
  #
  #   # Create an Array of new objects
  #   User.create([{ first_name: 'Jamie' }, { first_name: 'Jeremy' }])
  #
  #   # Create a single object and pass it into a block to set other attributes.
  #   User.create(first_name: 'Jamie') do |u|
  #     u.is_admin = false
  #   end
  #
  #   # Creating an Array of new objects using a block, where the block is executed for each object:
  #   User.create([{ first_name: 'Jamie' }, { first_name: 'Jeremy' }]) do |u|
  #     u.is_admin = false
  #   end
  def create(attributes = T.unsafe(nil), &block); end

  # Creates an object (or multiple objects) and saves it to the database,
  # if validations pass. Raises a RecordInvalid error if validations fail,
  # unlike Base#create.
  #
  # The +attributes+ parameter can be either a Hash or an Array of Hashes.
  # These describe which attributes to be created on the object, or
  # multiple objects when given an Array of Hashes.
  def create!(attributes = T.unsafe(nil), &block); end

  # Deletes the row with a primary key matching the +id+ argument, using an
  # SQL +DELETE+ statement, and returns the number of rows deleted. Active
  # Record objects are not instantiated, so the object's callbacks are not
  # executed, including any <tt>:dependent</tt> association options.
  #
  # You can delete multiple rows at once by passing an Array of <tt>id</tt>s.
  #
  # Note: Although it is often much faster than the alternative, #destroy,
  # skipping callbacks might bypass business logic in your application
  # that ensures referential integrity or performs other essential jobs.
  #
  # ==== Examples
  #
  #   # Delete a single row
  #   Todo.delete(1)
  #
  #   # Delete multiple rows
  #   Todo.delete([2,3,4])
  def delete(id_or_array); end

  # Destroy an object (or multiple objects) that has the given id. The object is instantiated first,
  # therefore all callbacks and filters are fired off before the object is deleted. This method is
  # less efficient than #delete but allows cleanup methods and other actions to be run.
  #
  # This essentially finds the object (or multiple objects) with the given id, creates a new object
  # from the attributes, and then calls destroy on it.
  #
  # ==== Parameters
  #
  # * +id+ - This should be the id or an array of ids to be destroyed.
  #
  # ==== Examples
  #
  #   # Destroy a single object
  #   Todo.destroy(1)
  #
  #   # Destroy multiple objects
  #   todos = [1,2,3]
  #   Todo.destroy(todos)
  def destroy(id); end

  # Inserts a single record into the database in a single SQL INSERT
  # statement. It does not instantiate any models nor does it trigger
  # Active Record callbacks or validations. Though passed values
  # go through Active Record's type casting and serialization.
  #
  # See <tt>ActiveRecord::Persistence#insert_all</tt> for documentation.
  def insert(attributes, returning: T.unsafe(nil), unique_by: T.unsafe(nil)); end

  # Inserts a single record into the database in a single SQL INSERT
  # statement. It does not instantiate any models nor does it trigger
  # Active Record callbacks or validations. Though passed values
  # go through Active Record's type casting and serialization.
  #
  # See <tt>ActiveRecord::Persistence#insert_all!</tt> for more.
  def insert!(attributes, returning: T.unsafe(nil)); end

  # Inserts multiple records into the database in a single SQL INSERT
  # statement. It does not instantiate any models nor does it trigger
  # Active Record callbacks or validations. Though passed values
  # go through Active Record's type casting and serialization.
  #
  # The +attributes+ parameter is an Array of Hashes. Every Hash determines
  # the attributes for a single row and must have the same keys.
  #
  # Rows are considered to be unique by every unique index on the table. Any
  # duplicate rows are skipped.
  # Override with <tt>:unique_by</tt> (see below).
  #
  # Returns an <tt>ActiveRecord::Result</tt> with its contents based on
  # <tt>:returning</tt> (see below).
  #
  # ==== Options
  #
  # [:returning]
  #   (PostgreSQL only) An array of attributes to return for all successfully
  #   inserted records, which by default is the primary key.
  #   Pass <tt>returning: %w[ id name ]</tt> for both id and name
  #   or <tt>returning: false</tt> to omit the underlying <tt>RETURNING</tt> SQL
  #   clause entirely.
  #
  # [:unique_by]
  #   (PostgreSQL and SQLite only) By default rows are considered to be unique
  #   by every unique index on the table. Any duplicate rows are skipped.
  #
  #   To skip rows according to just one unique index pass <tt>:unique_by</tt>.
  #
  #   Consider a Book model where no duplicate ISBNs make sense, but if any
  #   row has an existing id, or is not unique by another unique index,
  #   <tt>ActiveRecord::RecordNotUnique</tt> is raised.
  #
  #   Unique indexes can be identified by columns or name:
  #
  #     unique_by: :isbn
  #     unique_by: %i[ author_id name ]
  #     unique_by: :index_books_on_isbn
  #
  # Because it relies on the index information from the database
  # <tt>:unique_by</tt> is recommended to be paired with
  # Active Record's schema_cache.
  #
  # ==== Example
  #
  #   # Insert records and skip inserting any duplicates.
  #   # Here "Eloquent Ruby" is skipped because its id is not unique.
  #
  #   Book.insert_all([
  #     { id: 1, title: "Rework", author: "David" },
  #     { id: 1, title: "Eloquent Ruby", author: "Russ" }
  #   ])
  def insert_all(attributes, returning: T.unsafe(nil), unique_by: T.unsafe(nil)); end

  # Inserts multiple records into the database in a single SQL INSERT
  # statement. It does not instantiate any models nor does it trigger
  # Active Record callbacks or validations. Though passed values
  # go through Active Record's type casting and serialization.
  #
  # The +attributes+ parameter is an Array of Hashes. Every Hash determines
  # the attributes for a single row and must have the same keys.
  #
  # Raises <tt>ActiveRecord::RecordNotUnique</tt> if any rows violate a
  # unique index on the table. In that case, no rows are inserted.
  #
  # To skip duplicate rows, see <tt>ActiveRecord::Persistence#insert_all</tt>.
  # To replace them, see <tt>ActiveRecord::Persistence#upsert_all</tt>.
  #
  # Returns an <tt>ActiveRecord::Result</tt> with its contents based on
  # <tt>:returning</tt> (see below).
  #
  # ==== Options
  #
  # [:returning]
  #   (PostgreSQL only) An array of attributes to return for all successfully
  #   inserted records, which by default is the primary key.
  #   Pass <tt>returning: %w[ id name ]</tt> for both id and name
  #   or <tt>returning: false</tt> to omit the underlying <tt>RETURNING</tt> SQL
  #   clause entirely.
  #
  # ==== Examples
  #
  #   # Insert multiple records
  #   Book.insert_all!([
  #     { title: "Rework", author: "David" },
  #     { title: "Eloquent Ruby", author: "Russ" }
  #   ])
  #
  #   # Raises ActiveRecord::RecordNotUnique because "Eloquent Ruby"
  #   # does not have a unique id.
  #   Book.insert_all!([
  #     { id: 1, title: "Rework", author: "David" },
  #     { id: 1, title: "Eloquent Ruby", author: "Russ" }
  #   ])
  def insert_all!(attributes, returning: T.unsafe(nil)); end

  # Given an attributes hash, +instantiate+ returns a new instance of
  # the appropriate class. Accepts only keys as strings.
  #
  # For example, +Post.all+ may return Comments, Messages, and Emails
  # by storing the record's subclass in a +type+ attribute. By calling
  # +instantiate+ instead of +new+, finder methods ensure they get new
  # instances of the appropriate class for each record.
  #
  # See <tt>ActiveRecord::Inheritance#discriminate_class_for_record</tt> to see
  # how this "single-table" inheritance mapping is implemented.
  def instantiate(attributes, column_types = T.unsafe(nil), &block); end

  # Updates an object (or multiple objects) and saves it to the database, if validations pass.
  # The resulting object is returned whether the object was saved successfully to the database or not.
  #
  # ==== Parameters
  #
  # * +id+ - This should be the id or an array of ids to be updated.
  # * +attributes+ - This should be a hash of attributes or an array of hashes.
  #
  # ==== Examples
  #
  #   # Updates one record
  #   Person.update(15, user_name: "Samuel", group: "expert")
  #
  #   # Updates multiple records
  #   people = { 1 => { "first_name" => "David" }, 2 => { "first_name" => "Jeremy" } }
  #   Person.update(people.keys, people.values)
  #
  #   # Updates multiple records from the result of a relation
  #   people = Person.where(group: "expert")
  #   people.update(group: "masters")
  #
  # Note: Updating a large number of records will run an UPDATE
  # query for each record, which may cause a performance issue.
  # When running callbacks is not needed for each record update,
  # it is preferred to use {update_all}[rdoc-ref:Relation#update_all]
  # for updating all records in a single query.
  def update(id = T.unsafe(nil), attributes); end

  # Updates or inserts (upserts) a single record into the database in a
  # single SQL INSERT statement. It does not instantiate any models nor does
  # it trigger Active Record callbacks or validations. Though passed values
  # go through Active Record's type casting and serialization.
  #
  # See <tt>ActiveRecord::Persistence#upsert_all</tt> for documentation.
  def upsert(attributes, returning: T.unsafe(nil), unique_by: T.unsafe(nil)); end

  # Updates or inserts (upserts) multiple records into the database in a
  # single SQL INSERT statement. It does not instantiate any models nor does
  # it trigger Active Record callbacks or validations. Though passed values
  # go through Active Record's type casting and serialization.
  #
  # The +attributes+ parameter is an Array of Hashes. Every Hash determines
  # the attributes for a single row and must have the same keys.
  #
  # Returns an <tt>ActiveRecord::Result</tt> with its contents based on
  # <tt>:returning</tt> (see below).
  #
  # ==== Options
  #
  # [:returning]
  #   (PostgreSQL only) An array of attributes to return for all successfully
  #   inserted records, which by default is the primary key.
  #   Pass <tt>returning: %w[ id name ]</tt> for both id and name
  #   or <tt>returning: false</tt> to omit the underlying <tt>RETURNING</tt> SQL
  #   clause entirely.
  #
  # [:unique_by]
  #   (PostgreSQL and SQLite only) By default rows are considered to be unique
  #   by every unique index on the table. Any duplicate rows are skipped.
  #
  #   To skip rows according to just one unique index pass <tt>:unique_by</tt>.
  #
  #   Consider a Book model where no duplicate ISBNs make sense, but if any
  #   row has an existing id, or is not unique by another unique index,
  #   <tt>ActiveRecord::RecordNotUnique</tt> is raised.
  #
  #   Unique indexes can be identified by columns or name:
  #
  #     unique_by: :isbn
  #     unique_by: %i[ author_id name ]
  #     unique_by: :index_books_on_isbn
  #
  # Because it relies on the index information from the database
  # <tt>:unique_by</tt> is recommended to be paired with
  # Active Record's schema_cache.
  #
  # ==== Examples
  #
  #   # Inserts multiple records, performing an upsert when records have duplicate ISBNs.
  #   # Here "Eloquent Ruby" overwrites "Rework" because its ISBN is duplicate.
  #
  #   Book.upsert_all([
  #     { title: "Rework", author: "David", isbn: "1" },
  #     { title: "Eloquent Ruby", author: "Russ", isbn: "1" }
  #   ], unique_by: :isbn)
  #
  #   Book.find_by(isbn: "1").title # => "Eloquent Ruby"
  def upsert_all(attributes, returning: T.unsafe(nil), unique_by: T.unsafe(nil)); end

  private

  def _substitute_values(values); end

  # Called by +instantiate+ to decide which class to use for a new
  # record instance.
  #
  # See +ActiveRecord::Inheritance#discriminate_class_for_record+ for
  # the single-table inheritance discriminator.
  def discriminate_class_for_record(record); end

  # Given a class, an attributes hash, +instantiate_instance_of+ returns a
  # new instance of the class. Accepts only keys as strings.
  def instantiate_instance_of(klass, attributes, column_types = T.unsafe(nil), &block); end
end

class ActiveRecord::Point < ::Struct
  # Returns the value of attribute x
  #
  # @return [Object] the current value of x
  def x; end

  # Sets the attribute x
  #
  # @param value [Object] the value to set the attribute x to.
  # @return [Object] the newly set value
  def x=(_); end

  # Returns the value of attribute y
  #
  # @return [Object] the current value of y
  def y; end

  # Sets the attribute y
  #
  # @param value [Object] the value to set the attribute y to.
  # @return [Object] the newly set value
  def y=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def members; end
    def new(*_arg0); end
  end
end

class ActiveRecord::PredicateBuilder
  # @return [PredicateBuilder] a new instance of PredicateBuilder
  def initialize(table); end

  def [](attr_name, value, operator = T.unsafe(nil)); end
  def build(attribute, value, operator = T.unsafe(nil)); end
  def build_bind_attribute(column_name, value); end
  def build_from_hash(attributes, &block); end

  # Define how a class is converted to Arel nodes when passed to +where+.
  # The handler can be any object that responds to +call+, and will be used
  # for any value that +===+ the class given. For example:
  #
  #     MyCustomDateRange = Struct.new(:start, :end)
  #     handler = proc do |column, range|
  #       Arel::Nodes::Between.new(column,
  #         Arel::Nodes::And.new([range.start, range.end])
  #       )
  #     end
  #     ActiveRecord::PredicateBuilder.new("users").register_handler(MyCustomDateRange, handler)
  def register_handler(klass, handler); end

  def resolve_arel_attribute(table_name, column_name, &block); end

  protected

  def expand_from_hash(attributes, &block); end

  private

  def convert_dot_notation_to_hash(attributes); end
  def grouping_queries(queries); end
  def handler_for(object); end

  # Returns the value of attribute table.
  def table; end

  class << self
    def references(attributes); end
  end
end

class ActiveRecord::PredicateBuilder::ArrayHandler
  # @return [ArrayHandler] a new instance of ArrayHandler
  def initialize(predicate_builder); end

  def call(attribute, value); end

  private

  # Returns the value of attribute predicate_builder.
  def predicate_builder; end
end

module ActiveRecord::PredicateBuilder::ArrayHandler::NullPredicate
  class << self
    def or(other); end
  end
end

class ActiveRecord::PredicateBuilder::AssociationQueryValue
  # @return [AssociationQueryValue] a new instance of AssociationQueryValue
  def initialize(associated_table, value); end

  def queries; end

  private

  # Returns the value of attribute associated_table.
  def associated_table; end

  def convert_to_id(value); end
  def ids; end
  def primary_key; end

  # Returns the value of attribute value.
  def value; end
end

# No-op BaseHandler to work Mashal.load(File.read("legacy_relation.dump")).
# TODO: Remove the constant alias once Rails 6.1 has released.
ActiveRecord::PredicateBuilder::BaseHandler = ActiveRecord::PredicateBuilder::BasicObjectHandler

class ActiveRecord::PredicateBuilder::BasicObjectHandler
  # @return [BasicObjectHandler] a new instance of BasicObjectHandler
  def initialize(predicate_builder); end

  def call(attribute, value); end

  private

  # Returns the value of attribute predicate_builder.
  def predicate_builder; end
end

class ActiveRecord::PredicateBuilder::PolymorphicArrayValue
  # @return [PolymorphicArrayValue] a new instance of PolymorphicArrayValue
  def initialize(associated_table, values); end

  def queries; end

  private

  # Returns the value of attribute associated_table.
  def associated_table; end

  def convert_to_id(value); end
  def klass(value); end
  def primary_key(value); end
  def type_to_ids_mapping; end

  # Returns the value of attribute values.
  def values; end
end

class ActiveRecord::PredicateBuilder::RangeHandler
  # @return [RangeHandler] a new instance of RangeHandler
  def initialize(predicate_builder); end

  def call(attribute, value); end

  private

  # Returns the value of attribute predicate_builder.
  def predicate_builder; end
end

class ActiveRecord::PredicateBuilder::RangeHandler::RangeWithBinds < ::Struct
  # Returns the value of attribute begin
  #
  # @return [Object] the current value of begin
  def begin; end

  # Sets the attribute begin
  #
  # @param value [Object] the value to set the attribute begin to.
  # @return [Object] the newly set value
  def begin=(_); end

  # Returns the value of attribute end
  #
  # @return [Object] the current value of end
  def end; end

  # Sets the attribute end
  #
  # @param value [Object] the value to set the attribute end to.
  # @return [Object] the newly set value
  def end=(_); end

  # Returns the value of attribute exclude_end?
  #
  # @return [Object] the current value of exclude_end?
  def exclude_end?; end

  class << self
    def [](*_arg0); end
    def inspect; end
    def members; end
    def new(*_arg0); end
  end
end

class ActiveRecord::PredicateBuilder::RelationHandler
  def call(attribute, value); end
end

# Raised when PostgreSQL returns 'cached plan must not change result type' and
# we cannot retry gracefully (e.g. inside a transaction)
class ActiveRecord::PreparedStatementCacheExpired < ::ActiveRecord::StatementInvalid; end

# Raised when the number of placeholders in an SQL fragment passed to
# {ActiveRecord::Base.where}[rdoc-ref:QueryMethods#where]
# does not match the number of values supplied.
#
# For example, when there are two placeholders with only one value supplied:
#
#   Location.where("lat = ? AND lng = ?", 53.7362)
class ActiveRecord::PreparedStatementInvalid < ::ActiveRecord::ActiveRecordError; end

class ActiveRecord::ProtectedEnvironmentError < ::ActiveRecord::ActiveRecordError
  # @return [ProtectedEnvironmentError] a new instance of ProtectedEnvironmentError
  def initialize(env = T.unsafe(nil)); end
end

# Superclass for errors that have been aborted (either by client or server).
class ActiveRecord::QueryAborted < ::ActiveRecord::StatementInvalid; end

# = Active Record Query Cache
class ActiveRecord::QueryCache
  class << self
    def complete(pools); end
    def install_executor_hooks(executor = T.unsafe(nil)); end
    def run; end
  end
end

module ActiveRecord::QueryCache::ClassMethods
  # Enable the query cache within the block if Active Record is configured.
  # If it's not, it will execute the given block.
  def cache(&block); end

  # Disable the query cache within the block if Active Record is configured.
  # If it's not, it will execute the given block.
  def uncached(&block); end
end

# QueryCanceled will be raised when canceling statement due to user request.
class ActiveRecord::QueryCanceled < ::ActiveRecord::QueryAborted; end

module ActiveRecord::QueryMethods
  include ::ActiveModel::ForbiddenAttributesProtection
  extend ::ActiveSupport::Concern

  def _select!(*fields); end

  # Returns a new relation, which is the logical intersection of this relation and the one passed
  # as an argument.
  #
  # The two relations must be structurally compatible: they must be scoping the same model, and
  # they must differ only by #where (if no #group has been defined) or #having (if a #group is
  # present).
  #
  #    Post.where(id: [1, 2]).and(Post.where(id: [2, 3]))
  #    # SELECT `posts`.* FROM `posts` WHERE `posts`.`id` IN (1, 2) AND `posts`.`id` IN (2, 3)
  def and(other); end

  def and!(other); end

  # Adds an SQL comment to queries generated from this relation. For example:
  #
  #   User.annotate("selecting user names").select(:name)
  #   # SELECT "users"."name" FROM "users" /* selecting user names */
  #
  #   User.annotate("selecting", "user", "names").select(:name)
  #   # SELECT "users"."name" FROM "users" /* selecting */ /* user */ /* names */
  #
  # The SQL block comment delimiters, "/*" and "*/", will be added automatically.
  def annotate(*args); end

  # Like #annotate, but modifies relation in place.
  def annotate!(*args); end

  def annotate_values; end
  def annotate_values=(value); end

  # Returns the Arel object associated with the relation.
  def arel(aliases = T.unsafe(nil)); end

  def construct_join_dependency(associations, join_type); end

  # Sets attributes to be used when creating new records from a
  # relation object.
  #
  #   users = User.where(name: 'Oscar')
  #   users.new.name # => 'Oscar'
  #
  #   users = users.create_with(name: 'DHH')
  #   users.new.name # => 'DHH'
  #
  # You can pass +nil+ to #create_with to reset attributes:
  #
  #   users = users.create_with(nil)
  #   users.new.name # => 'Oscar'
  def create_with(value); end

  def create_with!(value); end
  def create_with_value; end
  def create_with_value=(value); end

  # Specifies whether the records should be unique or not. For example:
  #
  #   User.select(:name)
  #   # Might return two records with the same name
  #
  #   User.select(:name).distinct
  #   # Returns 1 record per distinct name
  #
  #   User.select(:name).distinct.distinct(false)
  #   # You can also remove the uniqueness
  def distinct(value = T.unsafe(nil)); end

  # Like #distinct, but modifies relation in place.
  def distinct!(value = T.unsafe(nil)); end

  def distinct_value; end
  def distinct_value=(value); end

  # Forces eager loading by performing a LEFT OUTER JOIN on +args+:
  #
  #   User.eager_load(:posts)
  #   # SELECT "users"."id" AS t0_r0, "users"."name" AS t0_r1, ...
  #   # FROM "users" LEFT OUTER JOIN "posts" ON "posts"."user_id" =
  #   # "users"."id"
  def eager_load(*args); end

  def eager_load!(*args); end
  def eager_load_values; end
  def eager_load_values=(value); end

  # Used to extend a scope with additional methods, either through
  # a module or through a block provided.
  #
  # The object returned is a relation, which can be further extended.
  #
  # === Using a module
  #
  #   module Pagination
  #     def page(number)
  #       # pagination code goes here
  #     end
  #   end
  #
  #   scope = Model.all.extending(Pagination)
  #   scope.page(params[:page])
  #
  # You can also pass a list of modules:
  #
  #   scope = Model.all.extending(Pagination, SomethingElse)
  #
  # === Using a block
  #
  #   scope = Model.all.extending do
  #     def page(number)
  #       # pagination code goes here
  #     end
  #   end
  #   scope.page(params[:page])
  #
  # You can also use a block and a module list:
  #
  #   scope = Model.all.extending(Pagination) do
  #     def per_page(number)
  #       # pagination code goes here
  #     end
  #   end
  def extending(*modules, &block); end

  def extending!(*modules, &block); end
  def extending_values; end
  def extending_values=(value); end
  def extensions; end

  # Extracts a named +association+ from the relation. The named association is first preloaded,
  # then the individual association records are collected from the relation. Like so:
  #
  #   account.memberships.extract_associated(:user)
  #   # => Returns collection of User records
  #
  # This is short-hand for:
  #
  #   account.memberships.preload(:user).collect(&:user)
  def extract_associated(association); end

  # Specifies table from which the records will be fetched. For example:
  #
  #   Topic.select('title').from('posts')
  #   # SELECT title FROM posts
  #
  # Can accept other relation objects. For example:
  #
  #   Topic.select('title').from(Topic.approved)
  #   # SELECT title FROM (SELECT * FROM topics WHERE approved = 't') subquery
  #
  #   Topic.select('a.title').from(Topic.approved, :a)
  #   # SELECT a.title FROM (SELECT * FROM topics WHERE approved = 't') a
  def from(value, subquery_name = T.unsafe(nil)); end

  def from!(value, subquery_name = T.unsafe(nil)); end
  def from_clause; end
  def from_clause=(value); end

  # Allows to specify a group attribute:
  #
  #   User.group(:name)
  #   # SELECT "users".* FROM "users" GROUP BY name
  #
  # Returns an array with distinct records based on the +group+ attribute:
  #
  #   User.select([:id, :name])
  #   # => [#<User id: 1, name: "Oscar">, #<User id: 2, name: "Oscar">, #<User id: 3, name: "Foo">]
  #
  #   User.group(:name)
  #   # => [#<User id: 3, name: "Foo", ...>, #<User id: 2, name: "Oscar", ...>]
  #
  #   User.group('name AS grouped_name, age')
  #   # => [#<User id: 3, name: "Foo", age: 21, ...>, #<User id: 2, name: "Oscar", age: 21, ...>, #<User id: 5, name: "Foo", age: 23, ...>]
  #
  # Passing in an array of attributes to group by is also supported.
  #
  #   User.select([:id, :first_name]).group(:id, :first_name).first(3)
  #   # => [#<User id: 1, first_name: "Bill">, #<User id: 2, first_name: "Earl">, #<User id: 3, first_name: "Beto">]
  def group(*args); end

  def group!(*args); end
  def group_values; end
  def group_values=(value); end

  # Allows to specify a HAVING clause. Note that you can't use HAVING
  # without also specifying a GROUP clause.
  #
  #   Order.having('SUM(price) > 30').group('user_id')
  def having(opts, *rest); end

  def having!(opts, *rest); end
  def having_clause; end
  def having_clause=(value); end

  # Specify relationships to be included in the result set. For
  # example:
  #
  #   users = User.includes(:address)
  #   users.each do |user|
  #     user.address.city
  #   end
  #
  # allows you to access the +address+ attribute of the +User+ model without
  # firing an additional query. This will often result in a
  # performance improvement over a simple join.
  #
  # You can also specify multiple relationships, like this:
  #
  #   users = User.includes(:address, :friends)
  #
  # Loading nested relationships is possible using a Hash:
  #
  #   users = User.includes(:address, friends: [:address, :followers])
  #
  # === conditions
  #
  # If you want to add string conditions to your included models, you'll have
  # to explicitly reference them. For example:
  #
  #   User.includes(:posts).where('posts.name = ?', 'example')
  #
  # Will throw an error, but this will work:
  #
  #   User.includes(:posts).where('posts.name = ?', 'example').references(:posts)
  #
  # Note that #includes works with association names while #references needs
  # the actual table name.
  #
  # If you pass the conditions via hash, you don't need to call #references
  # explicitly, as #where references the tables for you. For example, this
  # will work correctly:
  #
  #   User.includes(:posts).where(posts: { name: 'example' })
  def includes(*args); end

  def includes!(*args); end
  def includes_values; end
  def includes_values=(value); end

  # Performs a joins on +args+. The given symbol(s) should match the name of
  # the association(s).
  #
  #   User.joins(:posts)
  #   # SELECT "users".*
  #   # FROM "users"
  #   # INNER JOIN "posts" ON "posts"."user_id" = "users"."id"
  #
  # Multiple joins:
  #
  #   User.joins(:posts, :account)
  #   # SELECT "users".*
  #   # FROM "users"
  #   # INNER JOIN "posts" ON "posts"."user_id" = "users"."id"
  #   # INNER JOIN "accounts" ON "accounts"."id" = "users"."account_id"
  #
  # Nested joins:
  #
  #   User.joins(posts: [:comments])
  #   # SELECT "users".*
  #   # FROM "users"
  #   # INNER JOIN "posts" ON "posts"."user_id" = "users"."id"
  #   # INNER JOIN "comments" ON "comments"."post_id" = "posts"."id"
  #
  # You can use strings in order to customize your joins:
  #
  #   User.joins("LEFT JOIN bookmarks ON bookmarks.bookmarkable_type = 'Post' AND bookmarks.user_id = users.id")
  #   # SELECT "users".* FROM "users" LEFT JOIN bookmarks ON bookmarks.bookmarkable_type = 'Post' AND bookmarks.user_id = users.id
  def joins(*args); end

  def joins!(*args); end
  def joins_values; end
  def joins_values=(value); end

  # Performs a left outer joins on +args+:
  #
  #   User.left_outer_joins(:posts)
  #   => SELECT "users".* FROM "users" LEFT OUTER JOIN "posts" ON "posts"."user_id" = "users"."id"
  def left_joins(*args); end

  # Performs a left outer joins on +args+:
  #
  #   User.left_outer_joins(:posts)
  #   => SELECT "users".* FROM "users" LEFT OUTER JOIN "posts" ON "posts"."user_id" = "users"."id"
  def left_outer_joins(*args); end

  def left_outer_joins!(*args); end
  def left_outer_joins_values; end
  def left_outer_joins_values=(value); end

  # Specifies a limit for the number of records to retrieve.
  #
  #   User.limit(10) # generated SQL has 'LIMIT 10'
  #
  #   User.limit(10).limit(20) # generated SQL has 'LIMIT 20'
  def limit(value); end

  def limit!(value); end
  def limit_value; end
  def limit_value=(value); end

  # Specifies locking settings (default to +true+). For more information
  # on locking, please see ActiveRecord::Locking.
  def lock(locks = T.unsafe(nil)); end

  def lock!(locks = T.unsafe(nil)); end
  def lock_value; end
  def lock_value=(value); end

  # Returns a chainable relation with zero records.
  #
  # The returned relation implements the Null Object pattern. It is an
  # object with defined null behavior and always returns an empty array of
  # records without querying the database.
  #
  # Any subsequent condition chained to the returned relation will continue
  # generating an empty relation and will not fire any query to the database.
  #
  # Used in cases where a method or scope could return zero records but the
  # result needs to be chainable.
  #
  # For example:
  #
  #   @posts = current_user.visible_posts.where(name: params[:name])
  #   # the visible_posts method is expected to return a chainable Relation
  #
  #   def visible_posts
  #     case role
  #     when 'Country Manager'
  #       Post.where(country: country)
  #     when 'Reviewer'
  #       Post.published
  #     when 'Bad User'
  #       Post.none # It can't be chained if [] is returned.
  #     end
  #   end
  def none; end

  def none!; end

  # Specifies the number of rows to skip before returning rows.
  #
  #   User.offset(10) # generated SQL has "OFFSET 10"
  #
  # Should be used with order.
  #
  #   User.offset(10).order("name ASC")
  def offset(value); end

  def offset!(value); end
  def offset_value; end
  def offset_value=(value); end

  # Specify optimizer hints to be used in the SELECT statement.
  #
  # Example (for MySQL):
  #
  #   Topic.optimizer_hints("MAX_EXECUTION_TIME(50000)", "NO_INDEX_MERGE(topics)")
  #   # SELECT /*+ MAX_EXECUTION_TIME(50000) NO_INDEX_MERGE(topics) */ `topics`.* FROM `topics`
  #
  # Example (for PostgreSQL with pg_hint_plan):
  #
  #   Topic.optimizer_hints("SeqScan(topics)", "Parallel(topics 8)")
  #   # SELECT /*+ SeqScan(topics) Parallel(topics 8) */ "topics".* FROM "topics"
  def optimizer_hints(*args); end

  def optimizer_hints!(*args); end
  def optimizer_hints_values; end
  def optimizer_hints_values=(value); end

  # Returns a new relation, which is the logical union of this relation and the one passed as an
  # argument.
  #
  # The two relations must be structurally compatible: they must be scoping the same model, and
  # they must differ only by #where (if no #group has been defined) or #having (if a #group is
  # present).
  #
  #    Post.where("id = 1").or(Post.where("author_id = 3"))
  #    # SELECT `posts`.* FROM `posts` WHERE ((id = 1) OR (author_id = 3))
  def or(other); end

  def or!(other); end

  # Allows to specify an order attribute:
  #
  #   User.order(:name)
  #   # SELECT "users".* FROM "users" ORDER BY "users"."name" ASC
  #
  #   User.order(email: :desc)
  #   # SELECT "users".* FROM "users" ORDER BY "users"."email" DESC
  #
  #   User.order(:name, email: :desc)
  #   # SELECT "users".* FROM "users" ORDER BY "users"."name" ASC, "users"."email" DESC
  #
  #   User.order('name')
  #   # SELECT "users".* FROM "users" ORDER BY name
  #
  #   User.order('name DESC')
  #   # SELECT "users".* FROM "users" ORDER BY name DESC
  #
  #   User.order('name DESC, email')
  #   # SELECT "users".* FROM "users" ORDER BY name DESC, email
  def order(*args); end

  # Same as #order but operates on relation in-place instead of copying.
  def order!(*args); end

  def order_values; end
  def order_values=(value); end

  # Allows preloading of +args+, in the same way that #includes does:
  #
  #   User.preload(:posts)
  #   # SELECT "posts".* FROM "posts" WHERE "posts"."user_id" IN (1, 2, 3)
  def preload(*args); end

  def preload!(*args); end
  def preload_values; end
  def preload_values=(value); end

  # Sets readonly attributes for the returned relation. If value is
  # true (default), attempting to update a record will result in an error.
  #
  #   users = User.readonly
  #   users.first.save
  #   => ActiveRecord::ReadOnlyRecord: User is marked as readonly
  def readonly(value = T.unsafe(nil)); end

  def readonly!(value = T.unsafe(nil)); end
  def readonly_value; end
  def readonly_value=(value); end

  # Use to indicate that the given +table_names+ are referenced by an SQL string,
  # and should therefore be JOINed in any query rather than loaded separately.
  # This method only works in conjunction with #includes.
  # See #includes for more details.
  #
  #   User.includes(:posts).where("posts.name = 'foo'")
  #   # Doesn't JOIN the posts table, resulting in an error.
  #
  #   User.includes(:posts).where("posts.name = 'foo'").references(:posts)
  #   # Query now knows the string references posts, so adds a JOIN
  def references(*table_names); end

  def references!(*table_names); end
  def references_values; end
  def references_values=(value); end

  # Replaces any existing order defined on the relation with the specified order.
  #
  #   User.order('email DESC').reorder('id ASC') # generated SQL has 'ORDER BY id ASC'
  #
  # Subsequent calls to order on the same relation will be appended. For example:
  #
  #   User.order('email DESC').reorder('id ASC').order('name ASC')
  #
  # generates a query with 'ORDER BY id ASC, name ASC'.
  def reorder(*args); end

  # Same as #reorder but operates on relation in-place instead of copying.
  def reorder!(*args); end

  def reordering_value; end
  def reordering_value=(value); end

  # Allows you to change a previously set select statement.
  #
  #   Post.select(:title, :body)
  #   # SELECT `posts`.`title`, `posts`.`body` FROM `posts`
  #
  #   Post.select(:title, :body).reselect(:created_at)
  #   # SELECT `posts`.`created_at` FROM `posts`
  #
  # This is short-hand for <tt>unscope(:select).select(fields)</tt>.
  # Note that we're unscoping the entire select statement.
  def reselect(*args); end

  # Same as #reselect but operates on relation in-place instead of copying.
  def reselect!(*args); end

  # Reverse the existing order clause on the relation.
  #
  #   User.order('name ASC').reverse_order # generated SQL has 'ORDER BY name DESC'
  def reverse_order; end

  def reverse_order!; end
  def reverse_order_value; end
  def reverse_order_value=(value); end

  # Allows you to change a previously set where condition for a given attribute, instead of appending to that condition.
  #
  #   Post.where(trashed: true).where(trashed: false)
  #   # WHERE `trashed` = 1 AND `trashed` = 0
  #
  #   Post.where(trashed: true).rewhere(trashed: false)
  #   # WHERE `trashed` = 0
  #
  #   Post.where(active: true).where(trashed: true).rewhere(trashed: false)
  #   # WHERE `active` = 1 AND `trashed` = 0
  #
  # This is short-hand for <tt>unscope(where: conditions.keys).where(conditions)</tt>.
  # Note that unlike reorder, we're only unscoping the named conditions -- not the entire where statement.
  def rewhere(conditions); end

  # Works in two unique ways.
  #
  # First: takes a block so it can be used just like <tt>Array#select</tt>.
  #
  #   Model.all.select { |m| m.field == value }
  #
  # This will build an array of objects from the database for the scope,
  # converting them into an array and iterating through them using
  # <tt>Array#select</tt>.
  #
  # Second: Modifies the SELECT statement for the query so that only certain
  # fields are retrieved:
  #
  #   Model.select(:field)
  #   # => [#<Model id: nil, field: "value">]
  #
  # Although in the above example it looks as though this method returns an
  # array, it actually returns a relation object and can have other query
  # methods appended to it, such as the other methods in ActiveRecord::QueryMethods.
  #
  # The argument to the method can also be an array of fields.
  #
  #   Model.select(:field, :other_field, :and_one_more)
  #   # => [#<Model id: nil, field: "value", other_field: "value", and_one_more: "value">]
  #
  # You can also use one or more strings, which will be used unchanged as SELECT fields.
  #
  #   Model.select('field AS field_one', 'other_field AS field_two')
  #   # => [#<Model id: nil, field: "value", other_field: "value">]
  #
  # If an alias was specified, it will be accessible from the resulting objects:
  #
  #   Model.select('field AS field_one').first.field_one
  #   # => "value"
  #
  # Accessing attributes of an object that do not have fields retrieved by a select
  # except +id+ will throw ActiveModel::MissingAttributeError:
  #
  #   Model.select(:field).first.other_field
  #   # => ActiveModel::MissingAttributeError: missing attribute: other_field
  def select(*fields); end

  def select_values; end
  def select_values=(value); end
  def skip_preloading!; end
  def skip_query_cache!(value = T.unsafe(nil)); end
  def skip_query_cache_value; end
  def skip_query_cache_value=(value); end

  # Sets the returned relation to strict_loading mode. This will raise an error
  # if the record tries to lazily load an association.
  #
  #   user = User.strict_loading.first
  #   user.comments.to_a
  #   => ActiveRecord::StrictLoadingViolationError
  def strict_loading(value = T.unsafe(nil)); end

  def strict_loading!(value = T.unsafe(nil)); end
  def strict_loading_value; end
  def strict_loading_value=(value); end

  # Deduplicate multiple values.
  def uniq!(name); end

  # Removes an unwanted relation that is already defined on a chain of relations.
  # This is useful when passing around chains of relations and would like to
  # modify the relations without reconstructing the entire chain.
  #
  #   User.order('email DESC').unscope(:order) == User.all
  #
  # The method arguments are symbols which correspond to the names of the methods
  # which should be unscoped. The valid arguments are given in VALID_UNSCOPING_VALUES.
  # The method can also be called with multiple arguments. For example:
  #
  #   User.order('email DESC').select('id').where(name: "John")
  #       .unscope(:order, :select, :where) == User.all
  #
  # One can additionally pass a hash as an argument to unscope specific +:where+ values.
  # This is done by passing a hash with a single key-value pair. The key should be
  # +:where+ and the value should be the where value to unscope. For example:
  #
  #   User.where(name: "John", active: true).unscope(where: :name)
  #       == User.where(active: true)
  #
  # This method is similar to #except, but unlike
  # #except, it persists across merges:
  #
  #   User.order('email').merge(User.except(:order))
  #       == User.order('email')
  #
  #   User.order('email').merge(User.unscope(:order))
  #       == User.all
  #
  # This means it can be used in association definitions:
  #
  #   has_many :comments, -> { unscope(where: :trashed) }
  def unscope(*args); end

  def unscope!(*args); end
  def unscope_values; end
  def unscope_values=(value); end

  # Returns a new relation, which is the result of filtering the current relation
  # according to the conditions in the arguments.
  #
  # #where accepts conditions in one of several formats. In the examples below, the resulting
  # SQL is given as an illustration; the actual query generated may be different depending
  # on the database adapter.
  #
  # === string
  #
  # A single string, without additional arguments, is passed to the query
  # constructor as an SQL fragment, and used in the where clause of the query.
  #
  #    Client.where("orders_count = '2'")
  #    # SELECT * from clients where orders_count = '2';
  #
  # Note that building your own string from user input may expose your application
  # to injection attacks if not done properly. As an alternative, it is recommended
  # to use one of the following methods.
  #
  # === array
  #
  # If an array is passed, then the first element of the array is treated as a template, and
  # the remaining elements are inserted into the template to generate the condition.
  # Active Record takes care of building the query to avoid injection attacks, and will
  # convert from the ruby type to the database type where needed. Elements are inserted
  # into the string in the order in which they appear.
  #
  #   User.where(["name = ? and email = ?", "Joe", "joe@example.com"])
  #   # SELECT * FROM users WHERE name = 'Joe' AND email = 'joe@example.com';
  #
  # Alternatively, you can use named placeholders in the template, and pass a hash as the
  # second element of the array. The names in the template are replaced with the corresponding
  # values from the hash.
  #
  #   User.where(["name = :name and email = :email", { name: "Joe", email: "joe@example.com" }])
  #   # SELECT * FROM users WHERE name = 'Joe' AND email = 'joe@example.com';
  #
  # This can make for more readable code in complex queries.
  #
  # Lastly, you can use sprintf-style % escapes in the template. This works slightly differently
  # than the previous methods; you are responsible for ensuring that the values in the template
  # are properly quoted. The values are passed to the connector for quoting, but the caller
  # is responsible for ensuring they are enclosed in quotes in the resulting SQL. After quoting,
  # the values are inserted using the same escapes as the Ruby core method +Kernel::sprintf+.
  #
  #   User.where(["name = '%s' and email = '%s'", "Joe", "joe@example.com"])
  #   # SELECT * FROM users WHERE name = 'Joe' AND email = 'joe@example.com';
  #
  # If #where is called with multiple arguments, these are treated as if they were passed as
  # the elements of a single array.
  #
  #   User.where("name = :name and email = :email", { name: "Joe", email: "joe@example.com" })
  #   # SELECT * FROM users WHERE name = 'Joe' AND email = 'joe@example.com';
  #
  # When using strings to specify conditions, you can use any operator available from
  # the database. While this provides the most flexibility, you can also unintentionally introduce
  # dependencies on the underlying database. If your code is intended for general consumption,
  # test with multiple database backends.
  #
  # === hash
  #
  # #where will also accept a hash condition, in which the keys are fields and the values
  # are values to be searched for.
  #
  # Fields can be symbols or strings. Values can be single values, arrays, or ranges.
  #
  #    User.where({ name: "Joe", email: "joe@example.com" })
  #    # SELECT * FROM users WHERE name = 'Joe' AND email = 'joe@example.com'
  #
  #    User.where({ name: ["Alice", "Bob"]})
  #    # SELECT * FROM users WHERE name IN ('Alice', 'Bob')
  #
  #    User.where({ created_at: (Time.now.midnight - 1.day)..Time.now.midnight })
  #    # SELECT * FROM users WHERE (created_at BETWEEN '2012-06-09 07:00:00.000000' AND '2012-06-10 07:00:00.000000')
  #
  # In the case of a belongs_to relationship, an association key can be used
  # to specify the model if an ActiveRecord object is used as the value.
  #
  #    author = Author.find(1)
  #
  #    # The following queries will be equivalent:
  #    Post.where(author: author)
  #    Post.where(author_id: author)
  #
  # This also works with polymorphic belongs_to relationships:
  #
  #    treasure = Treasure.create(name: 'gold coins')
  #    treasure.price_estimates << PriceEstimate.create(price: 125)
  #
  #    # The following queries will be equivalent:
  #    PriceEstimate.where(estimate_of: treasure)
  #    PriceEstimate.where(estimate_of_type: 'Treasure', estimate_of_id: treasure)
  #
  # === Joins
  #
  # If the relation is the result of a join, you may create a condition which uses any of the
  # tables in the join. For string and array conditions, use the table name in the condition.
  #
  #    User.joins(:posts).where("posts.created_at < ?", Time.now)
  #
  # For hash conditions, you can either use the table name in the key, or use a sub-hash.
  #
  #    User.joins(:posts).where({ "posts.published" => true })
  #    User.joins(:posts).where({ posts: { published: true } })
  #
  # === no argument
  #
  # If no argument is passed, #where returns a new instance of WhereChain, that
  # can be chained with #not to return a new relation that negates the where clause.
  #
  #    User.where.not(name: "Jon")
  #    # SELECT * FROM users WHERE name != 'Jon'
  #
  # See WhereChain for more details on #not.
  #
  # === blank condition
  #
  # If the condition is any blank-ish object, then #where is a no-op and returns
  # the current relation.
  def where(*args); end

  def where!(opts, *rest); end
  def where_clause; end
  def where_clause=(value); end

  protected

  def build_having_clause(opts, rest = T.unsafe(nil)); end
  def build_subquery(subquery_alias, select_value); end
  def build_where_clause(opts, rest = T.unsafe(nil)); end

  private

  def arel_column(field); end
  def arel_columns(columns); end

  # @raise [ImmutableRelation]
  def assert_mutability!; end

  def build_arel(aliases = T.unsafe(nil)); end
  def build_cast_value(name, value); end
  def build_from; end
  def build_join_buckets; end
  def build_join_dependencies; end
  def build_joins(join_sources, aliases = T.unsafe(nil)); end
  def build_order(arel); end
  def build_select(arel); end

  # Checks to make sure that the arguments are not blank. Note that if some
  # blank-like object were initially passed into the query method, then this
  # method will not raise an error.
  #
  # Example:
  #
  #    Post.references()   # raises an error
  #    Post.references([]) # does not raise an error
  #
  # This particular method should be called with a method_name and the args
  # passed into that method as an input. For example:
  #
  # def references(*args)
  #   check_if_method_has_arguments!("references", args)
  #   ...
  # end
  def check_if_method_has_arguments!(method_name, args, message = T.unsafe(nil)); end

  def column_references(order_args); end

  # @return [Boolean]
  def does_not_support_reverse?(order); end

  def each_join_dependencies(join_dependencies = T.unsafe(nil)); end
  def lookup_table_klass_from_join_dependencies(table_name); end
  def order_column(field); end
  def preprocess_order_args(order_args); end
  def resolve_arel_attributes(attrs); end
  def reverse_sql_order(order_query); end
  def sanitize_order_arguments(order_args); end
  def select_association_list(associations, stashed_joins = T.unsafe(nil)); end
  def structurally_incompatible_values_for(other); end

  # @return [Boolean]
  def table_name_matches?(from); end

  def validate_order_args(args); end
end

ActiveRecord::QueryMethods::FROZEN_EMPTY_ARRAY = T.let(T.unsafe(nil), Array)
ActiveRecord::QueryMethods::FROZEN_EMPTY_HASH = T.let(T.unsafe(nil), Hash)
ActiveRecord::QueryMethods::STRUCTURAL_VALUE_METHODS = T.let(T.unsafe(nil), Array)
ActiveRecord::QueryMethods::VALID_DIRECTIONS = T.let(T.unsafe(nil), Set)
ActiveRecord::QueryMethods::VALID_UNSCOPING_VALUES = T.let(T.unsafe(nil), Set)

# WhereChain objects act as placeholder for queries in which #where does not have any parameter.
# In this case, #where must be chained with #not to return a new relation.
class ActiveRecord::QueryMethods::WhereChain
  # @return [WhereChain] a new instance of WhereChain
  def initialize(scope); end

  # Returns a new relation with left outer joins and where clause to identify
  # missing relations.
  #
  # For example, posts that are missing a related author:
  #
  #    Post.where.missing(:author)
  #    # SELECT "posts".* FROM "posts"
  #    # LEFT OUTER JOIN "authors" ON "authors"."id" = "posts"."author_id"
  #    # WHERE "authors"."id" IS NULL
  #
  # Additionally, multiple relations can be combined. This will return posts
  # that are missing both an author and any comments:
  #
  #    Post.where.missing(:author, :comments)
  #    # SELECT "posts".* FROM "posts"
  #    # LEFT OUTER JOIN "authors" ON "authors"."id" = "posts"."author_id"
  #    # LEFT OUTER JOIN "comments" ON "comments"."post_id" = "posts"."id"
  #    # WHERE "authors"."id" IS NULL AND "comments"."id" IS NULL
  def missing(*args); end

  # Returns a new relation expressing WHERE + NOT condition according to
  # the conditions in the arguments.
  #
  # #not accepts conditions as a string, array, or hash. See QueryMethods#where for
  # more details on each format.
  #
  #    User.where.not("name = 'Jon'")
  #    # SELECT * FROM users WHERE NOT (name = 'Jon')
  #
  #    User.where.not(["name = ?", "Jon"])
  #    # SELECT * FROM users WHERE NOT (name = 'Jon')
  #
  #    User.where.not(name: "Jon")
  #    # SELECT * FROM users WHERE name != 'Jon'
  #
  #    User.where.not(name: nil)
  #    # SELECT * FROM users WHERE name IS NOT NULL
  #
  #    User.where.not(name: %w(Ko1 Nobu))
  #    # SELECT * FROM users WHERE name NOT IN ('Ko1', 'Nobu')
  #
  #    User.where.not(name: "Jon", role: "admin")
  #    # SELECT * FROM users WHERE NOT (name == 'Jon' AND role == 'admin')
  def not(opts, *rest); end
end

module ActiveRecord::Querying
  def and(*_arg0, &_arg1); end
  def annotate(*_arg0, &_arg1); end
  def any?(*_arg0, &_arg1); end
  def average(*_arg0, &_arg1); end
  def calculate(*_arg0, &_arg1); end
  def count(*_arg0, &_arg1); end

  # Returns the result of an SQL statement that should only include a COUNT(*) in the SELECT part.
  # The use of this method should be restricted to complicated SQL queries that can't be executed
  # using the ActiveRecord::Calculations class methods. Look into those before using this method,
  # as it could lock you into a specific database engine or require a code change to switch
  # database engines.
  #
  #   Product.count_by_sql "SELECT COUNT(*) FROM sales s, customers c WHERE s.customer_id = c.id"
  #   # => 12
  #
  # ==== Parameters
  #
  # * +sql+ - An SQL statement which should return a count query from the database, see the example above.
  def count_by_sql(sql); end

  def create_or_find_by(*_arg0, &_arg1); end
  def create_or_find_by!(*_arg0, &_arg1); end
  def create_with(*_arg0, &_arg1); end
  def delete_all(*_arg0, &_arg1); end
  def delete_by(*_arg0, &_arg1); end
  def destroy_all(*_arg0, &_arg1); end
  def destroy_by(*_arg0, &_arg1); end
  def distinct(*_arg0, &_arg1); end
  def eager_load(*_arg0, &_arg1); end
  def except(*_arg0, &_arg1); end
  def exists?(*_arg0, &_arg1); end
  def extending(*_arg0, &_arg1); end
  def extract_associated(*_arg0, &_arg1); end
  def fifth(*_arg0, &_arg1); end
  def fifth!(*_arg0, &_arg1); end
  def find(*_arg0, &_arg1); end
  def find_by(*_arg0, &_arg1); end
  def find_by!(*_arg0, &_arg1); end

  # Executes a custom SQL query against your database and returns all the results. The results will
  # be returned as an array, with the requested columns encapsulated as attributes of the model you call
  # this method from. For example, if you call <tt>Product.find_by_sql</tt>, then the results will be returned in
  # a +Product+ object with the attributes you specified in the SQL query.
  #
  # If you call a complicated SQL query which spans multiple tables, the columns specified by the
  # SELECT will be attributes of the model, whether or not they are columns of the corresponding
  # table.
  #
  # The +sql+ parameter is a full SQL query as a string. It will be called as is; there will be
  # no database agnostic conversions performed. This should be a last resort because using
  # database-specific terms will lock you into using that particular database engine, or require you to
  # change your call if you switch engines.
  #
  #   # A simple SQL query spanning multiple tables
  #   Post.find_by_sql "SELECT p.title, c.author FROM posts p, comments c WHERE p.id = c.post_id"
  #   # => [#<Post:0x36bff9c @attributes={"title"=>"Ruby Meetup", "author"=>"Quentin"}>, ...]
  #
  # You can use the same string replacement techniques as you can with <tt>ActiveRecord::QueryMethods#where</tt>:
  #
  #   Post.find_by_sql ["SELECT title FROM posts WHERE author = ? AND created > ?", author_id, start_date]
  #   Post.find_by_sql ["SELECT body FROM comments WHERE author = :user_id OR approved_by = :user_id", { :user_id => user_id }]
  def find_by_sql(sql, binds = T.unsafe(nil), preparable: T.unsafe(nil), &block); end

  def find_each(*_arg0, &_arg1); end
  def find_in_batches(*_arg0, &_arg1); end
  def find_or_create_by(*_arg0, &_arg1); end
  def find_or_create_by!(*_arg0, &_arg1); end
  def find_or_initialize_by(*_arg0, &_arg1); end
  def first(*_arg0, &_arg1); end
  def first!(*_arg0, &_arg1); end
  def first_or_create(*_arg0, &_arg1); end
  def first_or_create!(*_arg0, &_arg1); end
  def first_or_initialize(*_arg0, &_arg1); end
  def forty_two(*_arg0, &_arg1); end
  def forty_two!(*_arg0, &_arg1); end
  def fourth(*_arg0, &_arg1); end
  def fourth!(*_arg0, &_arg1); end
  def from(*_arg0, &_arg1); end
  def group(*_arg0, &_arg1); end
  def having(*_arg0, &_arg1); end
  def ids(*_arg0, &_arg1); end
  def in_batches(*_arg0, &_arg1); end
  def includes(*_arg0, &_arg1); end
  def joins(*_arg0, &_arg1); end
  def last(*_arg0, &_arg1); end
  def last!(*_arg0, &_arg1); end
  def left_joins(*_arg0, &_arg1); end
  def left_outer_joins(*_arg0, &_arg1); end
  def limit(*_arg0, &_arg1); end
  def lock(*_arg0, &_arg1); end
  def many?(*_arg0, &_arg1); end
  def maximum(*_arg0, &_arg1); end
  def merge(*_arg0, &_arg1); end
  def minimum(*_arg0, &_arg1); end
  def none(*_arg0, &_arg1); end
  def none?(*_arg0, &_arg1); end
  def offset(*_arg0, &_arg1); end
  def one?(*_arg0, &_arg1); end
  def only(*_arg0, &_arg1); end
  def optimizer_hints(*_arg0, &_arg1); end
  def or(*_arg0, &_arg1); end
  def order(*_arg0, &_arg1); end
  def pick(*_arg0, &_arg1); end
  def pluck(*_arg0, &_arg1); end
  def preload(*_arg0, &_arg1); end
  def readonly(*_arg0, &_arg1); end
  def references(*_arg0, &_arg1); end
  def reorder(*_arg0, &_arg1); end
  def reselect(*_arg0, &_arg1); end
  def rewhere(*_arg0, &_arg1); end
  def second(*_arg0, &_arg1); end
  def second!(*_arg0, &_arg1); end
  def second_to_last(*_arg0, &_arg1); end
  def second_to_last!(*_arg0, &_arg1); end
  def select(*_arg0, &_arg1); end
  def strict_loading(*_arg0, &_arg1); end
  def sum(*_arg0, &_arg1); end
  def take(*_arg0, &_arg1); end
  def take!(*_arg0, &_arg1); end
  def third(*_arg0, &_arg1); end
  def third!(*_arg0, &_arg1); end
  def third_to_last(*_arg0, &_arg1); end
  def third_to_last!(*_arg0, &_arg1); end
  def touch_all(*_arg0, &_arg1); end
  def unscope(*_arg0, &_arg1); end
  def update_all(*_arg0, &_arg1); end
  def where(*_arg0, &_arg1); end
end

ActiveRecord::Querying::QUERYING_METHODS = T.let(T.unsafe(nil), Array)

# Raised when values that executed are out of range.
class ActiveRecord::RangeError < ::ActiveRecord::StatementInvalid; end

# Raised when a write to the database is attempted on a read only connection.
class ActiveRecord::ReadOnlyError < ::ActiveRecord::ActiveRecordError; end

# Raised on attempt to update record that is instantiated as read only.
class ActiveRecord::ReadOnlyRecord < ::ActiveRecord::ActiveRecordError; end

module ActiveRecord::ReadonlyAttributes
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::ActiveRecord::ReadonlyAttributes::ClassMethods

  module GeneratedClassMethods
    def _attr_readonly; end
    def _attr_readonly=(value); end
    def _attr_readonly?; end
  end

  module GeneratedInstanceMethods; end
end

module ActiveRecord::ReadonlyAttributes::ClassMethods
  # Attributes listed as readonly will be used to create a new record but update operations will
  # ignore these fields.
  def attr_readonly(*attributes); end

  # @return [Boolean]
  def readonly_attribute?(name); end

  # Returns an array of all the attributes that have been specified as readonly.
  def readonly_attributes; end
end

# = Active Record \RecordInvalid
#
# Raised by {ActiveRecord::Base#save!}[rdoc-ref:Persistence#save!] and
# {ActiveRecord::Base#create!}[rdoc-ref:Persistence::ClassMethods#create!] when the record is invalid.
# Use the #record method to retrieve the record which did not validate.
#
#   begin
#     complex_operation_that_internally_calls_save!
#   rescue ActiveRecord::RecordInvalid => invalid
#     puts invalid.record.errors
#   end
class ActiveRecord::RecordInvalid < ::ActiveRecord::ActiveRecordError
  # @return [RecordInvalid] a new instance of RecordInvalid
  def initialize(record = T.unsafe(nil)); end

  # Returns the value of attribute record.
  def record; end
end

# Raised by {ActiveRecord::Base#destroy!}[rdoc-ref:Persistence#destroy!]
# when a call to {#destroy}[rdoc-ref:Persistence#destroy!]
# would return false.
#
#   begin
#     complex_operation_that_internally_calls_destroy!
#   rescue ActiveRecord::RecordNotDestroyed => invalid
#     puts invalid.record.errors
#   end
class ActiveRecord::RecordNotDestroyed < ::ActiveRecord::ActiveRecordError
  # @return [RecordNotDestroyed] a new instance of RecordNotDestroyed
  def initialize(message = T.unsafe(nil), record = T.unsafe(nil)); end

  # Returns the value of attribute record.
  def record; end
end

# Raised when Active Record cannot find a record by given id or set of ids.
class ActiveRecord::RecordNotFound < ::ActiveRecord::ActiveRecordError
  # @return [RecordNotFound] a new instance of RecordNotFound
  def initialize(message = T.unsafe(nil), model = T.unsafe(nil), primary_key = T.unsafe(nil), id = T.unsafe(nil)); end

  # Returns the value of attribute id.
  def id; end

  # Returns the value of attribute model.
  def model; end

  # Returns the value of attribute primary_key.
  def primary_key; end
end

# Raised by {ActiveRecord::Base#save!}[rdoc-ref:Persistence#save!] and
# {ActiveRecord::Base.create!}[rdoc-ref:Persistence::ClassMethods#create!]
# methods when a record is invalid and cannot be saved.
class ActiveRecord::RecordNotSaved < ::ActiveRecord::ActiveRecordError
  # @return [RecordNotSaved] a new instance of RecordNotSaved
  def initialize(message = T.unsafe(nil), record = T.unsafe(nil)); end

  # Returns the value of attribute record.
  def record; end
end

# Raised when a record cannot be inserted or updated because it would violate a uniqueness constraint.
class ActiveRecord::RecordNotUnique < ::ActiveRecord::WrappedDatabaseException; end

# = Active Record Reflection
module ActiveRecord::Reflection
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::ActiveRecord::Reflection::ClassMethods

  class << self
    def add_aggregate_reflection(ar, name, reflection); end
    def add_reflection(ar, name, reflection); end
    def create(macro, name, scope, options, ar); end

    private

    def reflection_class_for(macro); end
  end

  module GeneratedClassMethods
    def _reflections; end
    def _reflections=(value); end
    def _reflections?; end
    def aggregate_reflections; end
    def aggregate_reflections=(value); end
    def aggregate_reflections?; end
  end

  module GeneratedInstanceMethods
    def _reflections; end
    def _reflections?; end
    def aggregate_reflections; end
    def aggregate_reflections?; end
  end
end

# Holds all the methods that are shared between MacroReflection and ThroughReflection.
#
#   AbstractReflection
#     MacroReflection
#       AggregateReflection
#       AssociationReflection
#         HasManyReflection
#         HasOneReflection
#         BelongsToReflection
#         HasAndBelongsToManyReflection
#     ThroughReflection
#     PolymorphicReflection
#     RuntimeReflection
class ActiveRecord::Reflection::AbstractReflection
  def alias_candidate(name); end

  # Returns a new, unsaved instance of the associated class. +attributes+ will
  # be passed to the class's constructor.
  def build_association(attributes, &block); end

  def build_scope(table, predicate_builder = T.unsafe(nil), klass = T.unsafe(nil)); end
  def chain; end
  def check_validity_of_inverse!; end

  # Returns the class name for the macro.
  #
  # <tt>composed_of :balance, class_name: 'Money'</tt> returns <tt>'Money'</tt>
  # <tt>has_many :clients</tt> returns <tt>'Client'</tt>
  def class_name; end

  def constraints; end
  def counter_cache_column; end

  # @return [Boolean]
  def counter_must_be_updated_by_has_many?; end

  # Returns whether a counter cache should be used for this association.
  #
  # The counter_cache option must be given on either the owner or inverse
  # association, and the column must be present on the owner.
  #
  # @return [Boolean]
  def has_cached_counter?; end

  def inverse_of; end

  # This shit is nasty. We need to avoid the following situation:
  #
  #   * An associated record is deleted via record.destroy
  #   * Hence the callbacks run, and they find a belongs_to on the record with a
  #     :counter_cache options which points back at our owner. So they update the
  #     counter cache.
  #   * In which case, we must make sure to *not* update the counter cache, or else
  #     it will be decremented twice.
  #
  # Hence this method.
  def inverse_updates_counter_cache?; end

  # @return [Boolean]
  def inverse_updates_counter_in_memory?; end

  # This shit is nasty. We need to avoid the following situation:
  #
  #   * An associated record is deleted via record.destroy
  #   * Hence the callbacks run, and they find a belongs_to on the record with a
  #     :counter_cache options which points back at our owner. So they update the
  #     counter cache.
  #   * In which case, we must make sure to *not* update the counter cache, or else
  #     it will be decremented twice.
  #
  # Hence this method.
  def inverse_which_updates_counter_cache; end

  def join_scope(table, foreign_table, foreign_klass); end
  def join_scopes(table, predicate_builder, klass = T.unsafe(nil)); end
  def klass_join_scope(table, predicate_builder); end

  # Returns a list of scopes that should be applied for this Reflection
  # object when querying the database.
  def scopes; end

  # @return [Boolean]
  def strict_loading?; end

  def table_name; end

  # @return [Boolean]
  def through_reflection?; end

  protected

  # FIXME: this is a horrible name
  def actual_source_reflection; end

  private

  def predicate_builder(table); end
  def primary_key(klass); end
end

# Holds all the metadata about an aggregation as it was specified in the
# Active Record class.
class ActiveRecord::Reflection::AggregateReflection < ::ActiveRecord::Reflection::MacroReflection
  def mapping; end
end

# Holds all the metadata about an association as it was specified in the
# Active Record class.
class ActiveRecord::Reflection::AssociationReflection < ::ActiveRecord::Reflection::MacroReflection
  # @return [AssociationReflection] a new instance of AssociationReflection
  def initialize(name, scope, options, active_record); end

  def active_record_primary_key; end
  def add_as_polymorphic_through(reflection, seed); end
  def add_as_source(seed); end
  def add_as_through(seed); end

  # @raise [NotImplementedError]
  def association_class; end

  def association_foreign_key; end
  def association_primary_key(klass = T.unsafe(nil)); end
  def association_scope_cache(klass, owner, &block); end

  # Returns +true+ if +self+ is a +belongs_to+ reflection.
  #
  # @return [Boolean]
  def belongs_to?; end

  def check_eager_loadable!; end
  def check_preloadable!; end
  def check_validity!; end

  # This is for clearing cache on the reflection. Useful for tests that need to compare
  # SQL queries on associations.
  def clear_association_scope_cache; end

  # A chain of reflections from this one back to the owner. For more see the explanation in
  # ThroughReflection.
  def collect_join_chain; end

  # Returns whether or not this association reflection is for a collection
  # association. Returns +true+ if the +macro+ is either +has_many+ or
  # +has_and_belongs_to_many+, +false+ otherwise.
  #
  # @return [Boolean]
  def collection?; end

  def compute_class(name); end

  # @return [Boolean]
  def constructable?; end

  def extensions; end
  def foreign_key; end

  # Returns the value of attribute foreign_type.
  def foreign_type; end

  # @return [Boolean]
  def has_inverse?; end

  # Returns +true+ if +self+ is a +has_one+ reflection.
  #
  # @return [Boolean]
  def has_one?; end

  # @return [Boolean]
  def has_scope?; end

  def join_foreign_key; end
  def join_id_for(owner); end
  def join_primary_key(klass = T.unsafe(nil)); end
  def join_table; end

  # Returns the macro type.
  #
  # <tt>has_many :clients</tt> returns <tt>:has_many</tt>
  #
  # @raise [NotImplementedError]
  def macro; end

  # @return [Boolean]
  def nested?; end

  # Reflection
  def parent_reflection; end

  # Reflection
  def parent_reflection=(_arg0); end

  # @return [Boolean]
  def polymorphic?; end

  def polymorphic_inverse_of(associated_class); end
  def source_reflection; end
  def through_reflection; end

  # Returns the value of attribute type.
  def type; end

  # Returns whether or not the association should be validated as part of
  # the parent's validation.
  #
  # Unless you explicitly disable validation with
  # <tt>validate: false</tt>, validation will take place when:
  #
  # * you explicitly enable validation; <tt>validate: true</tt>
  # * you use autosave; <tt>autosave: true</tt>
  # * the association is a +has_many+ association
  #
  # @return [Boolean]
  def validate?; end

  private

  # returns either +nil+ or the inverse association name that it finds.
  def automatic_inverse_of; end

  def calculate_constructable(macro, options); end

  # Checks to see if the reflection doesn't have any options that prevent
  # us from being able to guess the inverse automatically. First, the
  # <tt>inverse_of</tt> option cannot be set to false. Second, we must
  # have <tt>has_many</tt>, <tt>has_one</tt>, <tt>belongs_to</tt> associations.
  # Third, we must not have options such as <tt>:foreign_key</tt>
  # which prevent us from correctly guessing the inverse association.
  #
  # Anything with a scope can additionally ruin our attempt at finding an
  # inverse, so we exclude reflections with scopes.
  #
  # @return [Boolean]
  def can_find_inverse_of_automatically?(reflection); end

  def derive_class_name; end
  def derive_foreign_key; end
  def derive_join_table; end

  # Attempts to find the inverse association name automatically.
  # If it cannot find a suitable inverse association name, it returns
  # +nil+.
  def inverse_name; end

  # Checks if the inverse reflection that is returned from the
  # +automatic_inverse_of+ method is a valid reflection. We must
  # make sure that the reflection's active_record name matches up
  # with the current reflection's klass name.
  #
  # @return [Boolean]
  def valid_inverse_reflection?(reflection); end
end

ActiveRecord::Reflection::AssociationReflection::INVALID_AUTOMATIC_INVERSE_OPTIONS = T.let(T.unsafe(nil), Array)
ActiveRecord::Reflection::AssociationReflection::VALID_AUTOMATIC_INVERSE_MACROS = T.let(T.unsafe(nil), Array)

class ActiveRecord::Reflection::BelongsToReflection < ::ActiveRecord::Reflection::AssociationReflection
  def association_class; end

  # klass option is necessary to support loading polymorphic associations
  def association_primary_key(klass = T.unsafe(nil)); end

  # @return [Boolean]
  def belongs_to?; end

  def join_foreign_key; end
  def join_foreign_type; end
  def join_primary_key(klass = T.unsafe(nil)); end
  def macro; end

  private

  def calculate_constructable(macro, options); end

  # @return [Boolean]
  def can_find_inverse_of_automatically?(_); end
end

# \Reflection enables the ability to examine the associations and aggregations of
# Active Record classes and objects. This information, for example,
# can be used in a form builder that takes an Active Record object
# and creates input fields for all of the attributes depending on their type
# and displays the associations to other objects.
#
# MacroReflection class has info for AggregateReflection and AssociationReflection
# classes.
module ActiveRecord::Reflection::ClassMethods
  def _reflect_on_association(association); end
  def clear_reflections_cache; end

  # Returns the AggregateReflection object for the named +aggregation+ (use the symbol).
  #
  #   Account.reflect_on_aggregation(:balance) # => the balance AggregateReflection
  def reflect_on_aggregation(aggregation); end

  # Returns an array of AggregateReflection objects for all the aggregations in the class.
  def reflect_on_all_aggregations; end

  # Returns an array of AssociationReflection objects for all the
  # associations in the class. If you only want to reflect on a certain
  # association type, pass in the symbol (<tt>:has_many</tt>, <tt>:has_one</tt>,
  # <tt>:belongs_to</tt>) as the first parameter.
  #
  # Example:
  #
  #   Account.reflect_on_all_associations             # returns an array of all associations
  #   Account.reflect_on_all_associations(:has_many)  # returns an array of all has_many associations
  def reflect_on_all_associations(macro = T.unsafe(nil)); end

  # Returns an array of AssociationReflection objects for all associations which have <tt>:autosave</tt> enabled.
  def reflect_on_all_autosave_associations; end

  # Returns the AssociationReflection object for the +association+ (use the symbol).
  #
  #   Account.reflect_on_association(:owner)             # returns the owner AssociationReflection
  #   Invoice.reflect_on_association(:line_items).macro  # returns :has_many
  def reflect_on_association(association); end

  # Returns a Hash of name of the reflection as the key and an AssociationReflection as the value.
  #
  #   Account.reflections # => {"balance" => AggregateReflection}
  def reflections; end
end

class ActiveRecord::Reflection::HasAndBelongsToManyReflection < ::ActiveRecord::Reflection::AssociationReflection
  # @return [Boolean]
  def collection?; end

  def macro; end
end

class ActiveRecord::Reflection::HasManyReflection < ::ActiveRecord::Reflection::AssociationReflection
  def association_class; end

  # @return [Boolean]
  def collection?; end

  def macro; end
end

class ActiveRecord::Reflection::HasOneReflection < ::ActiveRecord::Reflection::AssociationReflection
  def association_class; end

  # @return [Boolean]
  def has_one?; end

  def macro; end

  private

  def calculate_constructable(macro, options); end
end

# Base class for AggregateReflection and AssociationReflection. Objects of
# AggregateReflection and AssociationReflection are returned by the Reflection::ClassMethods.
class ActiveRecord::Reflection::MacroReflection < ::ActiveRecord::Reflection::AbstractReflection
  # @return [MacroReflection] a new instance of MacroReflection
  def initialize(name, scope, options, active_record); end

  # Returns +true+ if +self+ and +other_aggregation+ have the same +name+ attribute, +active_record+ attribute,
  # and +other_aggregation+ has an options hash assigned to it.
  def ==(other_aggregation); end

  # Returns the value of attribute active_record.
  def active_record; end

  def autosave=(autosave); end
  def compute_class(name); end

  # Returns the class for the macro.
  #
  # <tt>composed_of :balance, class_name: 'Money'</tt> returns the Money class
  # <tt>has_many :clients</tt> returns the Client class
  #
  #   class Company < ActiveRecord::Base
  #     has_many :clients
  #   end
  #
  #   Company.reflect_on_association(:clients).klass
  #   # => Client
  #
  # <b>Note:</b> Do not call +klass.new+ or +klass.create+ to instantiate
  # a new association object. Use +build_association+ or +create_association+
  # instead. This allows plugins to hook into association object creation.
  def klass; end

  # Returns the name of the macro.
  #
  # <tt>composed_of :balance, class_name: 'Money'</tt> returns <tt>:balance</tt>
  # <tt>has_many :clients</tt> returns <tt>:clients</tt>
  def name; end

  # Returns the hash of options used for the macro.
  #
  # <tt>composed_of :balance, class_name: 'Money'</tt> returns <tt>{ class_name: "Money" }</tt>
  # <tt>has_many :clients</tt> returns <tt>{}</tt>
  def options; end

  def plural_name; end

  # Returns the value of attribute scope.
  def scope; end

  def scope_for(relation, owner = T.unsafe(nil)); end

  private

  def derive_class_name; end
end

class ActiveRecord::Reflection::PolymorphicReflection < ::ActiveRecord::Reflection::AbstractReflection
  # @return [PolymorphicReflection] a new instance of PolymorphicReflection
  def initialize(reflection, previous_reflection); end

  def constraints; end
  def join_foreign_key(*_arg0, &_arg1); end
  def join_primary_key(*_arg0, &_arg1); end
  def join_scopes(table, predicate_builder, klass = T.unsafe(nil)); end
  def klass(*_arg0, &_arg1); end
  def name(*_arg0, &_arg1); end
  def plural_name(*_arg0, &_arg1); end
  def scope(*_arg0, &_arg1); end
  def scope_for(*_arg0, &_arg1); end
  def type(*_arg0, &_arg1); end

  private

  def source_type_scope; end
end

class ActiveRecord::Reflection::RuntimeReflection < ::ActiveRecord::Reflection::AbstractReflection
  # @return [RuntimeReflection] a new instance of RuntimeReflection
  def initialize(reflection, association); end

  def aliased_table; end
  def all_includes; end
  def constraints(*_arg0, &_arg1); end
  def join_foreign_key(*_arg0, &_arg1); end
  def join_primary_key(klass = T.unsafe(nil)); end
  def klass; end
  def scope(*_arg0, &_arg1); end
  def type(*_arg0, &_arg1); end
end

# Holds all the metadata about a :through association as it was specified
# in the Active Record class.
class ActiveRecord::Reflection::ThroughReflection < ::ActiveRecord::Reflection::AbstractReflection
  # @return [ThroughReflection] a new instance of ThroughReflection
  def initialize(delegate_reflection); end

  def active_record(*_arg0, &_arg1); end
  def active_record_primary_key(*_arg0, &_arg1); end
  def add_as_polymorphic_through(reflection, seed); end
  def add_as_source(seed); end
  def add_as_through(seed); end
  def association_class(*_arg0, &_arg1); end
  def association_foreign_key(*_arg0, &_arg1); end

  # We want to use the klass from this reflection, rather than just delegate straight to
  # the source_reflection, because the source_reflection may be polymorphic. We still
  # need to respect the source_reflection's :primary_key option, though.
  def association_primary_key(klass = T.unsafe(nil)); end

  def association_scope_cache(*_arg0, &_arg1); end
  def autosave=(arg); end
  def belongs_to?(*_arg0, &_arg1); end
  def check_eager_loadable!(*_arg0, &_arg1); end
  def check_preloadable!(*_arg0, &_arg1); end
  def check_validity!; end

  # This is for clearing cache on the reflection. Useful for tests that need to compare
  # SQL queries on associations.
  def clear_association_scope_cache; end

  # Returns an array of reflections which are involved in this association. Each item in the
  # array corresponds to a table which will be part of the query for this association.
  #
  # The chain is built by recursively calling #chain on the source reflection and the through
  # reflection. The base case for the recursion is a normal association, which just returns
  # [self] as its #chain.
  #
  #   class Post < ActiveRecord::Base
  #     has_many :taggings
  #     has_many :tags, through: :taggings
  #   end
  #
  #   tags_reflection = Post.reflect_on_association(:tags)
  #   tags_reflection.chain
  #   # => [<ActiveRecord::Reflection::ThroughReflection: @delegate_reflection=#<ActiveRecord::Reflection::HasManyReflection: @name=:tags...>,
  #         <ActiveRecord::Reflection::HasManyReflection: @name=:taggings, @options={}, @active_record=Post>]
  def collect_join_chain; end

  def collection?(*_arg0, &_arg1); end
  def compute_class(*_arg0, &_arg1); end
  def constraints; end
  def constructable?(*_arg0, &_arg1); end
  def extensions(*_arg0, &_arg1); end
  def foreign_key(*_arg0, &_arg1); end
  def foreign_type(*_arg0, &_arg1); end
  def has_inverse?(*_arg0, &_arg1); end
  def has_one?(*_arg0, &_arg1); end

  # @return [Boolean]
  def has_scope?; end

  def join_foreign_key(*_arg0, &_arg1); end
  def join_id_for(*_arg0, &_arg1); end
  def join_primary_key(klass = T.unsafe(nil)); end
  def join_scopes(table, predicate_builder, klass = T.unsafe(nil)); end
  def join_table(*_arg0, &_arg1); end
  def klass; end
  def macro(*_arg0, &_arg1); end
  def name(*_arg0, &_arg1); end

  # A through association is nested if there would be more than one join table
  #
  # @return [Boolean]
  def nested?; end

  def options(*_arg0, &_arg1); end
  def parent_reflection(*_arg0, &_arg1); end
  def parent_reflection=(arg); end
  def plural_name(*_arg0, &_arg1); end
  def polymorphic?(*_arg0, &_arg1); end
  def polymorphic_inverse_of(*_arg0, &_arg1); end
  def scope(*_arg0, &_arg1); end
  def scope_for(*_arg0, &_arg1); end
  def scopes; end
  def source_options; end

  # Returns the source of the through reflection. It checks both a singularized
  # and pluralized form for <tt>:belongs_to</tt> or <tt>:has_many</tt>.
  #
  #   class Post < ActiveRecord::Base
  #     has_many :taggings
  #     has_many :tags, through: :taggings
  #   end
  #
  #   class Tagging < ActiveRecord::Base
  #     belongs_to :post
  #     belongs_to :tag
  #   end
  #
  #   tags_reflection = Post.reflect_on_association(:tags)
  #   tags_reflection.source_reflection
  #   # => <ActiveRecord::Reflection::BelongsToReflection: @name=:tag, @active_record=Tagging, @plural_name="tags">
  def source_reflection; end

  def source_reflection_name; end

  # Gets an array of possible <tt>:through</tt> source reflection names in both singular and plural form.
  #
  #   class Post < ActiveRecord::Base
  #     has_many :taggings
  #     has_many :tags, through: :taggings
  #   end
  #
  #   tags_reflection = Post.reflect_on_association(:tags)
  #   tags_reflection.source_reflection_names
  #   # => [:tag, :tags]
  def source_reflection_names; end

  def through_options; end

  # Returns the AssociationReflection object specified in the <tt>:through</tt> option
  # of a HasManyThrough or HasOneThrough association.
  #
  #   class Post < ActiveRecord::Base
  #     has_many :taggings
  #     has_many :tags, through: :taggings
  #   end
  #
  #   tags_reflection = Post.reflect_on_association(:tags)
  #   tags_reflection.through_reflection
  #   # => <ActiveRecord::Reflection::HasManyReflection: @name=:taggings, @active_record=Post, @plural_name="taggings">
  def through_reflection; end

  # @return [Boolean]
  def through_reflection?; end

  def type(*_arg0, &_arg1); end
  def validate?(*_arg0, &_arg1); end

  protected

  # FIXME: this is a horrible name
  def actual_source_reflection; end

  private

  def collect_join_reflections(seed); end

  # Returns the value of attribute delegate_reflection.
  def delegate_reflection; end

  def derive_class_name; end
  def inverse_name; end
end

# = Active Record \Relation
class ActiveRecord::Relation
  include ::ActiveRecordExplainAnalyze::Relation
  include ::Enumerable
  include ::ActiveRecord::Delegation
  include ::ActiveRecord::Explain
  include ::ActiveRecord::Batches
  include ::ActiveModel::ForbiddenAttributesProtection
  include ::ActiveRecord::QueryMethods
  include ::ActiveRecord::SpawnMethods
  include ::ActiveRecord::Calculations
  include ::ActiveRecord::FinderMethods
  extend ::ActiveRecord::Delegation::ClassMethods

  # @return [Relation] a new instance of Relation
  def initialize(klass, table: T.unsafe(nil), predicate_builder: T.unsafe(nil), values: T.unsafe(nil)); end

  # Compares two relations for equality.
  def ==(other); end

  def _exec_scope(*args, &block); end
  def alias_tracker(joins = T.unsafe(nil), aliases = T.unsafe(nil)); end

  # Returns true if there are any records.
  #
  # @return [Boolean]
  def any?; end

  def arel_attribute(*args, &block); end

  # @yield [attr, bind]
  def bind_attribute(name, value); end

  # Returns true if relation is blank.
  #
  # @return [Boolean]
  def blank?; end

  # Initializes new record from relation while maintaining the current
  # scope.
  #
  # Expects arguments in the same format as {ActiveRecord::Base.new}[rdoc-ref:Core.new].
  #
  #   users = User.where(name: 'DHH')
  #   user = users.new # => #<User id: nil, name: "DHH", created_at: nil, updated_at: nil>
  #
  # You can also pass a block to new with the new record as argument:
  #
  #   user = users.new { |user| user.name = 'Oscar' }
  #   user.name # => Oscar
  def build(attributes = T.unsafe(nil), &block); end

  # Returns a stable cache key that can be used to identify this query.
  # The cache key is built with a fingerprint of the SQL query.
  #
  #    Product.where("name like ?", "%Cosmic Encounter%").cache_key
  #    # => "products/query-1850ab3d302391b85b8693e941286659"
  #
  # If ActiveRecord::Base.collection_cache_versioning is turned off, as it was
  # in Rails 6.0 and earlier, the cache key will also include a version.
  #
  #    ActiveRecord::Base.collection_cache_versioning = false
  #    Product.where("name like ?", "%Cosmic Encounter%").cache_key
  #    # => "products/query-1850ab3d302391b85b8693e941286659-1-20150714212553907087000"
  #
  # You can also pass a custom timestamp column to fetch the timestamp of the
  # last updated record.
  #
  #   Product.where("name like ?", "%Game%").cache_key(:last_reviewed_at)
  def cache_key(timestamp_column = T.unsafe(nil)); end

  # Returns a cache key along with the version.
  def cache_key_with_version; end

  # Returns a cache version that can be used together with the cache key to form
  # a recyclable caching scheme. The cache version is built with the number of records
  # matching the query, and the timestamp of the last updated record. When a new record
  # comes to match the query, or any of the existing records is updated or deleted,
  # the cache version changes.
  #
  # If the collection is loaded, the method will iterate through the records
  # to generate the timestamp, otherwise it will trigger one SQL query like:
  #
  #    SELECT COUNT(*), MAX("products"."updated_at") FROM "products" WHERE (name like '%Cosmic Encounter%')
  def cache_version(timestamp_column = T.unsafe(nil)); end

  # Tries to create a new record with the same scoped attributes
  # defined in the relation. Returns the initialized object if validation fails.
  #
  # Expects arguments in the same format as
  # {ActiveRecord::Base.create}[rdoc-ref:Persistence::ClassMethods#create].
  #
  # ==== Examples
  #
  #   users = User.where(name: 'Oscar')
  #   users.create # => #<User id: 3, name: "Oscar", ...>
  #
  #   users.create(name: 'fxn')
  #   users.create # => #<User id: 4, name: "fxn", ...>
  #
  #   users.create { |user| user.name = 'tenderlove' }
  #   # => #<User id: 5, name: "tenderlove", ...>
  #
  #   users.create(name: nil) # validation on name
  #   # => #<User id: nil, name: nil, ...>
  def create(attributes = T.unsafe(nil), &block); end

  # Similar to #create, but calls
  # {create!}[rdoc-ref:Persistence::ClassMethods#create!]
  # on the base class. Raises an exception if a validation error occurs.
  #
  # Expects arguments in the same format as
  # {ActiveRecord::Base.create!}[rdoc-ref:Persistence::ClassMethods#create!].
  def create!(attributes = T.unsafe(nil), &block); end

  # Attempts to create a record with the given attributes in a table that has a unique constraint
  # on one or several of its columns. If a row already exists with one or several of these
  # unique constraints, the exception such an insertion would normally raise is caught,
  # and the existing record with those attributes is found using #find_by!.
  #
  # This is similar to #find_or_create_by, but avoids the problem of stale reads between the SELECT
  # and the INSERT, as that method needs to first query the table, then attempt to insert a row
  # if none is found.
  #
  # There are several drawbacks to #create_or_find_by, though:
  #
  # * The underlying table must have the relevant columns defined with unique constraints.
  # * A unique constraint violation may be triggered by only one, or at least less than all,
  #   of the given attributes. This means that the subsequent #find_by! may fail to find a
  #   matching record, which will then raise an <tt>ActiveRecord::RecordNotFound</tt> exception,
  #   rather than a record with the given attributes.
  # * While we avoid the race condition between SELECT -> INSERT from #find_or_create_by,
  #   we actually have another race condition between INSERT -> SELECT, which can be triggered
  #   if a DELETE between those two statements is run by another client. But for most applications,
  #   that's a significantly less likely condition to hit.
  # * It relies on exception handling to handle control flow, which may be marginally slower.
  # * The primary key may auto-increment on each create, even if it fails. This can accelerate
  #   the problem of running out of integers, if the underlying table is still stuck on a primary
  #   key of type int (note: All Rails apps since 5.1+ have defaulted to bigint, which is not liable
  #   to this problem).
  #
  # This method will return a record if all given attributes are covered by unique constraints
  # (unless the INSERT -> DELETE -> SELECT race condition is triggered), but if creation was attempted
  # and failed due to validation errors it won't be persisted, you get what #create returns in
  # such situation.
  def create_or_find_by(attributes, &block); end

  # Like #create_or_find_by, but calls
  # {create!}[rdoc-ref:Persistence::ClassMethods#create!] so an exception
  # is raised if the created record is invalid.
  def create_or_find_by!(attributes, &block); end

  # Deletes the records without instantiating the records
  # first, and hence not calling the {#destroy}[rdoc-ref:Persistence#destroy]
  # method nor invoking callbacks.
  # This is a single SQL DELETE statement that goes straight to the database, much more
  # efficient than #destroy_all. Be careful with relations though, in particular
  # <tt>:dependent</tt> rules defined on associations are not honored. Returns the
  # number of rows affected.
  #
  #   Post.where(person_id: 5).where(category: ['Something', 'Else']).delete_all
  #
  # Both calls delete the affected posts all at once with a single DELETE statement.
  # If you need to destroy dependent associations or call your <tt>before_*</tt> or
  # +after_destroy+ callbacks, use the #destroy_all method instead.
  #
  # If an invalid method is supplied, #delete_all raises an ActiveRecordError:
  #
  #   Post.distinct.delete_all
  #   # => ActiveRecord::ActiveRecordError: delete_all doesn't support distinct
  def delete_all; end

  # Finds and deletes all records matching the specified conditions.
  # This is short-hand for <tt>relation.where(condition).delete_all</tt>.
  # Returns the number of rows affected.
  #
  # If no record is found, returns <tt>0</tt> as zero rows were affected.
  #
  #   Person.delete_by(id: 13)
  #   Person.delete_by(name: 'Spartacus', rating: 4)
  #   Person.delete_by("published_at < ?", 2.weeks.ago)
  def delete_by(*args); end

  # Destroys the records by instantiating each
  # record and calling its {#destroy}[rdoc-ref:Persistence#destroy] method.
  # Each object's callbacks are executed (including <tt>:dependent</tt> association options).
  # Returns the collection of objects that were destroyed; each will be frozen, to
  # reflect that no changes should be made (since they can't be persisted).
  #
  # Note: Instantiation, callback execution, and deletion of each
  # record can be time consuming when you're removing many records at
  # once. It generates at least one SQL +DELETE+ query per record (or
  # possibly more, to enforce your callbacks). If you want to delete many
  # rows quickly, without concern for their associations or callbacks, use
  # #delete_all instead.
  #
  # ==== Examples
  #
  #   Person.where(age: 0..18).destroy_all
  def destroy_all; end

  # Finds and destroys all records matching the specified conditions.
  # This is short-hand for <tt>relation.where(condition).destroy_all</tt>.
  # Returns the collection of objects that were destroyed.
  #
  # If no record is found, returns empty array.
  #
  #   Person.destroy_by(id: 13)
  #   Person.destroy_by(name: 'Spartacus', rating: 4)
  #   Person.destroy_by("published_at < ?", 2.weeks.ago)
  def destroy_by(*args); end

  # Returns true if relation needs eager loading.
  #
  # @return [Boolean]
  def eager_loading?; end

  # Returns true if there are no records.
  #
  # @return [Boolean]
  def empty?; end

  # @return [Boolean]
  def empty_scope?; end

  # Serializes the relation objects Array.
  def encode_with(coder); end

  # Runs EXPLAIN on the query or queries triggered by this relation and
  # returns the result as a string. The string is formatted imitating the
  # ones printed by the database shell.
  #
  # Note that this method actually runs the queries, since the results of some
  # are needed by the next ones when eager loading is going on.
  #
  # Please see further details in the
  # {Active Record Query Interface guide}[https://guides.rubyonrails.org/active_record_querying.html#running-explain].
  def explain(analyze: T.unsafe(nil), format: T.unsafe(nil)); end

  # Finds the first record with the given attributes, or creates a record
  # with the attributes if one is not found:
  #
  #   # Find the first user named "Penélope" or create a new one.
  #   User.find_or_create_by(first_name: 'Penélope')
  #   # => #<User id: 1, first_name: "Penélope", last_name: nil>
  #
  #   # Find the first user named "Penélope" or create a new one.
  #   # We already have one so the existing record will be returned.
  #   User.find_or_create_by(first_name: 'Penélope')
  #   # => #<User id: 1, first_name: "Penélope", last_name: nil>
  #
  #   # Find the first user named "Scarlett" or create a new one with
  #   # a particular last name.
  #   User.create_with(last_name: 'Johansson').find_or_create_by(first_name: 'Scarlett')
  #   # => #<User id: 2, first_name: "Scarlett", last_name: "Johansson">
  #
  # This method accepts a block, which is passed down to #create. The last example
  # above can be alternatively written this way:
  #
  #   # Find the first user named "Scarlett" or create a new one with a
  #   # different last name.
  #   User.find_or_create_by(first_name: 'Scarlett') do |user|
  #     user.last_name = 'Johansson'
  #   end
  #   # => #<User id: 2, first_name: "Scarlett", last_name: "Johansson">
  #
  # This method always returns a record, but if creation was attempted and
  # failed due to validation errors it won't be persisted, you get what
  # #create returns in such situation.
  #
  # Please note <b>this method is not atomic</b>, it runs first a SELECT, and if
  # there are no results an INSERT is attempted. If there are other threads
  # or processes there is a race condition between both calls and it could
  # be the case that you end up with two similar records.
  #
  # If this might be a problem for your application, please see #create_or_find_by.
  def find_or_create_by(attributes, &block); end

  # Like #find_or_create_by, but calls
  # {create!}[rdoc-ref:Persistence::ClassMethods#create!] so an exception
  # is raised if the created record is invalid.
  def find_or_create_by!(attributes, &block); end

  # Like #find_or_create_by, but calls {new}[rdoc-ref:Core#new]
  # instead of {create}[rdoc-ref:Persistence::ClassMethods#create].
  def find_or_initialize_by(attributes, &block); end

  def first_or_create(attributes = T.unsafe(nil), &block); end
  def first_or_create!(attributes = T.unsafe(nil), &block); end
  def first_or_initialize(attributes = T.unsafe(nil), &block); end

  # @return [Boolean]
  def has_limit_or_offset?; end

  def inspect; end

  # Joins that are also marked for preloading. In which case we should just eager load them.
  # Note that this is a naive implementation because we could have strings and symbols which
  # represent the same association, but that aren't matched by this. Also, we could have
  # nested hashes which partially match, e.g. { a: :b } & { a: [:b, :c] }
  def joined_includes_values; end

  # Returns the value of attribute klass.
  def klass; end

  # Causes the records to be loaded from the database if they have not
  # been loaded already. You can use this if for some reason you need
  # to explicitly load some records before actually using them. The
  # return value is the relation itself, not the records.
  #
  #   Post.where(published: true).load # => #<ActiveRecord::Relation>
  def load(&block); end

  # Returns the value of attribute loaded.
  def loaded; end

  # Returns the value of attribute loaded.
  def loaded?; end

  def locked?; end

  # Returns true if there is more than one record.
  #
  # @return [Boolean]
  def many?; end

  # Returns the value of attribute klass.
  def model; end

  # Initializes new record from relation while maintaining the current
  # scope.
  #
  # Expects arguments in the same format as {ActiveRecord::Base.new}[rdoc-ref:Core.new].
  #
  #   users = User.where(name: 'DHH')
  #   user = users.new # => #<User id: nil, name: "DHH", created_at: nil, updated_at: nil>
  #
  # You can also pass a block to new with the new record as argument:
  #
  #   user = users.new { |user| user.name = 'Oscar' }
  #   user.name # => Oscar
  def new(attributes = T.unsafe(nil), &block); end

  # Returns true if there are no records.
  #
  # @return [Boolean]
  def none?; end

  # Returns true if there is exactly one record.
  #
  # @return [Boolean]
  def one?; end

  # Returns the value of attribute predicate_builder.
  def predicate_builder; end

  def preload_associations(records); end
  def pretty_print(q); end
  def records; end

  # Forces reloading of relation.
  def reload; end

  def reset; end
  def scope_for_create; end

  # Scope all queries to the current scope.
  #
  #   Comment.where(post_id: 1).scoping do
  #     Comment.first
  #   end
  #   # => SELECT "comments".* FROM "comments" WHERE "comments"."post_id" = 1 ORDER BY "comments"."id" ASC LIMIT 1
  #
  # Please check unscoped if you want to remove all previous scopes (including
  # the default_scope) during the execution of a block.
  def scoping; end

  # Returns size of the records.
  def size; end

  # Returns the value of attribute skip_preloading_value.
  def skip_preloading_value; end

  # Sets the attribute skip_preloading_value
  #
  # @param value the value to set the attribute skip_preloading_value to.
  def skip_preloading_value=(_arg0); end

  # Returns the value of attribute table.
  def table; end

  # Converts relation objects to Array.
  def to_a; end

  # Converts relation objects to Array.
  def to_ary; end

  # Returns sql statement for the relation.
  #
  #   User.where(name: 'Oscar').to_sql
  #   # => SELECT "users".* FROM "users"  WHERE "users"."name" = 'Oscar'
  def to_sql; end

  # Touches all records in the current relation, setting the +updated_at+/+updated_on+ attributes to the current time or the time specified.
  # It does not instantiate the involved models, and it does not trigger Active Record callbacks or validations.
  # This method can be passed attribute names and an optional time argument.
  # If attribute names are passed, they are updated along with +updated_at+/+updated_on+ attributes.
  # If no time argument is passed, the current time is used as default.
  #
  # === Examples
  #
  #   # Touch all records
  #   Person.all.touch_all
  #   # => "UPDATE \"people\" SET \"updated_at\" = '2018-01-04 22:55:23.132670'"
  #
  #   # Touch multiple records with a custom attribute
  #   Person.all.touch_all(:created_at)
  #   # => "UPDATE \"people\" SET \"updated_at\" = '2018-01-04 22:55:23.132670', \"created_at\" = '2018-01-04 22:55:23.132670'"
  #
  #   # Touch multiple records with a specified time
  #   Person.all.touch_all(time: Time.new(2020, 5, 16, 0, 0, 0))
  #   # => "UPDATE \"people\" SET \"updated_at\" = '2020-05-16 00:00:00'"
  #
  #   # Touch records with scope
  #   Person.where(name: 'David').touch_all
  #   # => "UPDATE \"people\" SET \"updated_at\" = '2018-01-04 22:55:23.132670' WHERE \"people\".\"name\" = 'David'"
  def touch_all(*names, time: T.unsafe(nil)); end

  def update(id = T.unsafe(nil), attributes); end

  # Updates all records in the current relation with details given. This method constructs a single SQL UPDATE
  # statement and sends it straight to the database. It does not instantiate the involved models and it does not
  # trigger Active Record callbacks or validations. However, values passed to #update_all will still go through
  # Active Record's normal type casting and serialization. Returns the number of rows affected.
  #
  # Note: As Active Record callbacks are not triggered, this method will not automatically update +updated_at+/+updated_on+ columns.
  #
  # ==== Parameters
  #
  # * +updates+ - A string, array, or hash representing the SET part of an SQL statement.
  #
  # ==== Examples
  #
  #   # Update all customers with the given attributes
  #   Customer.update_all wants_email: true
  #
  #   # Update all books with 'Rails' in their title
  #   Book.where('title LIKE ?', '%Rails%').update_all(author: 'David')
  #
  #   # Update all books that match conditions, but limit it to 5 ordered by date
  #   Book.where('title LIKE ?', '%Rails%').order(:created_at).limit(5).update_all(author: 'David')
  #
  #   # Update all invoices and set the number column to its id value.
  #   Invoice.update_all('number = id')
  #
  # @raise [ArgumentError]
  def update_all(updates); end

  # Updates the counters of the records in the current relation.
  #
  # ==== Parameters
  #
  # * +counter+ - A Hash containing the names of the fields to update as keys and the amount to update as values.
  # * <tt>:touch</tt> option - Touch the timestamp columns when updating.
  # * If attributes names are passed, they are updated along with update_at/on attributes.
  #
  # ==== Examples
  #
  #   # For Posts by a given author increment the comment_count by 1.
  #   Post.where(author_id: author.id).update_counters(comment_count: 1)
  def update_counters(counters); end

  def values; end

  # Returns a hash of where conditions.
  #
  #   User.where(name: 'Oscar').where_values_hash
  #   # => {name: "Oscar"}
  def where_values_hash(relation_table_name = T.unsafe(nil)); end

  protected

  def load_records(records); end

  # @return [Boolean]
  def null_relation?; end

  private

  def _create(attributes, &block); end
  def _create!(attributes, &block); end
  def _increment_attribute(attribute, value = T.unsafe(nil)); end
  def _new(attributes, &block); end
  def _scoping(scope); end
  def _substitute_values(values); end

  # @return [Boolean]
  def already_in_scope?; end

  def build_preloader; end
  def compute_cache_key(timestamp_column = T.unsafe(nil)); end
  def compute_cache_version(timestamp_column); end
  def current_scope_restoring_block(&block); end
  def exec_queries(&block); end
  def initialize_copy(other); end

  # @return [Boolean]
  def references_eager_loaded_tables?; end

  def skip_query_cache_if_necessary; end
  def tables_in_string(string); end
end

ActiveRecord::Relation::CLAUSE_METHODS = T.let(T.unsafe(nil), Array)

class ActiveRecord::Relation::FromClause
  # @return [FromClause] a new instance of FromClause
  def initialize(value, name); end

  def ==(other); end

  # @return [Boolean]
  def empty?; end

  def merge(other); end

  # Returns the value of attribute name.
  def name; end

  # Returns the value of attribute value.
  def value; end

  class << self
    def empty; end
  end
end

class ActiveRecord::Relation::HashMerger
  # @return [HashMerger] a new instance of HashMerger
  def initialize(relation, hash, rewhere = T.unsafe(nil)); end

  # Returns the value of attribute hash.
  def hash; end

  def merge; end

  # Applying values to a relation has some side effects. E.g.
  # interpolation might take place for where values. So we should
  # build a relation to merge in rather than directly merging
  # the values.
  def other; end

  # Returns the value of attribute relation.
  def relation; end
end

ActiveRecord::Relation::INVALID_METHODS_FOR_DELETE_ALL = T.let(T.unsafe(nil), Array)
ActiveRecord::Relation::MULTI_VALUE_METHODS = T.let(T.unsafe(nil), Array)

class ActiveRecord::Relation::Merger
  # @return [Merger] a new instance of Merger
  def initialize(relation, other, rewhere = T.unsafe(nil)); end

  def merge; end
  def normal_values; end

  # Returns the value of attribute other.
  def other; end

  # Returns the value of attribute relation.
  def relation; end

  # Returns the value of attribute values.
  def values; end

  private

  def merge_clauses; end
  def merge_joins; end
  def merge_multi_values; end
  def merge_outer_joins; end
  def merge_preloads; end
  def merge_single_values; end

  # @return [Boolean]
  def replace_from_clause?; end
end

ActiveRecord::Relation::Merger::NORMAL_VALUES = T.let(T.unsafe(nil), Array)

class ActiveRecord::Relation::QueryAttribute < ::ActiveModel::Attribute
  # @return [Boolean]
  def infinite?; end

  # @return [Boolean]
  def nil?; end

  def type_cast(value); end

  # @return [Boolean]
  def unboundable?; end

  def value_for_database; end
  def with_cast_value(value); end

  private

  # @return [Boolean]
  def infinity?(value); end
end

ActiveRecord::Relation::SINGLE_VALUE_METHODS = T.let(T.unsafe(nil), Array)

class ActiveRecord::Relation::StrictLoadingScope
  class << self
    # @return [Boolean]
    def empty_scope?; end

    def strict_loading_value; end
  end
end

ActiveRecord::Relation::VALUE_METHODS = T.let(T.unsafe(nil), Array)

class ActiveRecord::Relation::WhereClause
  # @return [WhereClause] a new instance of WhereClause
  def initialize(predicates); end

  def +(other); end
  def -(other); end
  def ==(other); end
  def any?(*_arg0, &_arg1); end
  def ast; end

  # @return [Boolean]
  def contradiction?; end

  def empty?(*_arg0, &_arg1); end
  def except(*columns); end
  def extract_attributes; end
  def invert; end
  def merge(other, rewhere = T.unsafe(nil)); end
  def or(other); end
  def to_h(table_name = T.unsafe(nil), equality_only: T.unsafe(nil)); end
  def |(other); end

  protected

  # Returns the value of attribute predicates.
  def predicates; end

  def referenced_columns; end

  private

  def each_attributes; end
  def equalities(predicates, equality_only); end

  # @return [Boolean]
  def equality_node?(node); end

  def except_predicates(columns); end
  def extract_attribute(node); end
  def extract_node_value(node); end
  def invert_predicate(node); end
  def non_empty_predicates; end
  def predicates_unreferenced_by(other); end
  def predicates_with_wrapped_sql_literals; end
  def wrap_sql_literal(node); end

  class << self
    def empty; end
  end
end

ActiveRecord::Relation::WhereClause::ARRAY_WITH_EMPTY_STRING = T.let(T.unsafe(nil), Array)

# No-op WhereClauseFactory to work Mashal.load(File.read("legacy_relation.dump")).
# TODO: Remove the class once Rails 6.1 has released.
class ActiveRecord::Relation::WhereClauseFactory; end

# This class encapsulates a result returned from calling
# {#exec_query}[rdoc-ref:ConnectionAdapters::DatabaseStatements#exec_query]
# on any database connection adapter. For example:
#
#   result = ActiveRecord::Base.connection.exec_query('SELECT id, title, body FROM posts')
#   result # => #<ActiveRecord::Result:0xdeadbeef>
#
#   # Get the column names of the result:
#   result.columns
#   # => ["id", "title", "body"]
#
#   # Get the record values of the result:
#   result.rows
#   # => [[1, "title_1", "body_1"],
#         [2, "title_2", "body_2"],
#         ...
#        ]
#
#   # Get an array of hashes representing the result (column => value):
#   result.to_a
#   # => [{"id" => 1, "title" => "title_1", "body" => "body_1"},
#         {"id" => 2, "title" => "title_2", "body" => "body_2"},
#         ...
#        ]
#
#   # ActiveRecord::Result also includes Enumerable.
#   result.each do |row|
#     puts row['title'] + " " + row['body']
#   end
class ActiveRecord::Result
  include ::Enumerable

  # @return [Result] a new instance of Result
  def initialize(columns, rows, column_types = T.unsafe(nil)); end

  def [](idx); end
  def cast_values(type_overrides = T.unsafe(nil)); end
  def collect!(*args, &block); end

  # Returns the value of attribute column_types.
  def column_types; end

  # Returns the value of attribute columns.
  def columns; end

  # Calls the given block once for each element in row collection, passing
  # row as parameter.
  #
  # Returns an +Enumerator+ if no block is given.
  def each; end

  # Returns true if there are no records, otherwise false.
  #
  # @return [Boolean]
  def empty?; end

  # Returns true if this result set includes the column named +name+
  #
  # @return [Boolean]
  def includes_column?(name); end

  # Returns the last record from the rows collection.
  def last(n = T.unsafe(nil)); end

  # Returns the number of elements in the rows array.
  def length; end

  def map!(*args, &block); end

  # Returns the value of attribute rows.
  def rows; end

  # Returns an array of hashes representing each row record.
  def to_a; end

  # Returns an array of hashes representing each row record.
  def to_ary; end

  private

  def column_type(name, type_overrides = T.unsafe(nil)); end
  def hash_rows; end
  def initialize_copy(other); end
end

# {ActiveRecord::Base.transaction}[rdoc-ref:Transactions::ClassMethods#transaction]
# uses this exception to distinguish a deliberate rollback from other exceptional situations.
# Normally, raising an exception will cause the
# {.transaction}[rdoc-ref:Transactions::ClassMethods#transaction] method to rollback
# the database transaction *and* pass on the exception. But if you raise an
# ActiveRecord::Rollback exception, then the database transaction will be rolled back,
# without passing on the exception.
#
# For example, you could do this in your controller to rollback a transaction:
#
#   class BooksController < ActionController::Base
#     def create
#       Book.transaction do
#         book = Book.new(params[:book])
#         book.save!
#         if today_is_friday?
#           # The system must fail on Friday so that our support department
#           # won't be out of job. We silently rollback this transaction
#           # without telling the user.
#           raise ActiveRecord::Rollback, "Call tech support!"
#         end
#       end
#       # ActiveRecord::Rollback is the only exception that won't be passed on
#       # by ActiveRecord::Base.transaction, so this line will still be reached
#       # even on Friday.
#       redirect_to root_url
#     end
#   end
class ActiveRecord::Rollback < ::ActiveRecord::ActiveRecordError; end

# This is a thread locals registry for Active Record. For example:
#
#   ActiveRecord::RuntimeRegistry.connection_handler
#
# returns the connection handler local to the current thread.
#
# See the documentation of ActiveSupport::PerThreadRegistry
# for further details.
class ActiveRecord::RuntimeRegistry
  extend ::ActiveSupport::PerThreadRegistry

  # Returns the value of attribute sql_runtime.
  def sql_runtime; end

  # Sets the attribute sql_runtime
  #
  # @param value the value to set the attribute sql_runtime to.
  def sql_runtime=(_arg0); end

  class << self
    def sql_runtime; end
    def sql_runtime=(x); end
  end
end

module ActiveRecord::Sanitization
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::ActiveRecord::Sanitization::ClassMethods
end

module ActiveRecord::Sanitization::ClassMethods
  def disallow_raw_sql!(args, permit: T.unsafe(nil)); end

  # Accepts an array or string of SQL conditions and sanitizes
  # them into a valid SQL fragment for a WHERE clause.
  #
  #   sanitize_sql_for_conditions(["name=? and group_id=?", "foo'bar", 4])
  #   # => "name='foo''bar' and group_id=4"
  #
  #   sanitize_sql_for_conditions(["name=:name and group_id=:group_id", name: "foo'bar", group_id: 4])
  #   # => "name='foo''bar' and group_id='4'"
  #
  #   sanitize_sql_for_conditions(["name='%s' and group_id='%s'", "foo'bar", 4])
  #   # => "name='foo''bar' and group_id='4'"
  #
  #   sanitize_sql_for_conditions("name='foo''bar' and group_id='4'")
  #   # => "name='foo''bar' and group_id='4'"
  def sanitize_sql(condition); end

  # Accepts an array of conditions. The array has each value
  # sanitized and interpolated into the SQL statement.
  #
  #   sanitize_sql_array(["name=? and group_id=?", "foo'bar", 4])
  #   # => "name='foo''bar' and group_id=4"
  #
  #   sanitize_sql_array(["name=:name and group_id=:group_id", name: "foo'bar", group_id: 4])
  #   # => "name='foo''bar' and group_id=4"
  #
  #   sanitize_sql_array(["name='%s' and group_id='%s'", "foo'bar", 4])
  #   # => "name='foo''bar' and group_id='4'"
  def sanitize_sql_array(ary); end

  # Accepts an array, hash, or string of SQL conditions and sanitizes
  # them into a valid SQL fragment for a SET clause.
  #
  #   sanitize_sql_for_assignment(["name=? and group_id=?", nil, 4])
  #   # => "name=NULL and group_id=4"
  #
  #   sanitize_sql_for_assignment(["name=:name and group_id=:group_id", name: nil, group_id: 4])
  #   # => "name=NULL and group_id=4"
  #
  #   Post.sanitize_sql_for_assignment({ name: nil, group_id: 4 })
  #   # => "`posts`.`name` = NULL, `posts`.`group_id` = 4"
  #
  #   sanitize_sql_for_assignment("name=NULL and group_id='4'")
  #   # => "name=NULL and group_id='4'"
  def sanitize_sql_for_assignment(assignments, default_table_name = T.unsafe(nil)); end

  # Accepts an array or string of SQL conditions and sanitizes
  # them into a valid SQL fragment for a WHERE clause.
  #
  #   sanitize_sql_for_conditions(["name=? and group_id=?", "foo'bar", 4])
  #   # => "name='foo''bar' and group_id=4"
  #
  #   sanitize_sql_for_conditions(["name=:name and group_id=:group_id", name: "foo'bar", group_id: 4])
  #   # => "name='foo''bar' and group_id='4'"
  #
  #   sanitize_sql_for_conditions(["name='%s' and group_id='%s'", "foo'bar", 4])
  #   # => "name='foo''bar' and group_id='4'"
  #
  #   sanitize_sql_for_conditions("name='foo''bar' and group_id='4'")
  #   # => "name='foo''bar' and group_id='4'"
  def sanitize_sql_for_conditions(condition); end

  # Accepts an array, or string of SQL conditions and sanitizes
  # them into a valid SQL fragment for an ORDER clause.
  #
  #   sanitize_sql_for_order(["field(id, ?)", [1,3,2]])
  #   # => "field(id, 1,3,2)"
  #
  #   sanitize_sql_for_order("id ASC")
  #   # => "id ASC"
  def sanitize_sql_for_order(condition); end

  # Sanitizes a hash of attribute/value pairs into SQL conditions for a SET clause.
  #
  #   sanitize_sql_hash_for_assignment({ status: nil, group_id: 1 }, "posts")
  #   # => "`posts`.`status` = NULL, `posts`.`group_id` = 1"
  def sanitize_sql_hash_for_assignment(attrs, table); end

  # Sanitizes a +string+ so that it is safe to use within an SQL
  # LIKE statement. This method uses +escape_character+ to escape all occurrences of "\", "_" and "%".
  #
  #   sanitize_sql_like("100%")
  #   # => "100\\%"
  #
  #   sanitize_sql_like("snake_cased_string")
  #   # => "snake\\_cased\\_string"
  #
  #   sanitize_sql_like("100%", "!")
  #   # => "100!%"
  #
  #   sanitize_sql_like("snake_cased_string", "!")
  #   # => "snake!_cased!_string"
  def sanitize_sql_like(string, escape_character = T.unsafe(nil)); end

  private

  def quote_bound_value(value, c = T.unsafe(nil)); end
  def raise_if_bind_arity_mismatch(statement, expected, provided); end
  def replace_bind_variable(value, c = T.unsafe(nil)); end
  def replace_bind_variables(statement, values); end
  def replace_named_bind_variables(statement, bind_vars); end
end

# = Active Record \Schema
#
# Allows programmers to programmatically define a schema in a portable
# DSL. This means you can define tables, indexes, etc. without using SQL
# directly, so your applications can more easily support multiple
# databases.
#
# Usage:
#
#   ActiveRecord::Schema.define do
#     create_table :authors do |t|
#       t.string :name, null: false
#     end
#
#     add_index :authors, :name, :unique
#
#     create_table :posts do |t|
#       t.integer :author_id, null: false
#       t.string :subject
#       t.text :body
#       t.boolean :private, default: false
#     end
#
#     add_index :posts, :author_id
#   end
#
# ActiveRecord::Schema is only supported by database adapters that also
# support migrations, the two features being very similar.
class ActiveRecord::Schema < ::ActiveRecord::Migration::Current
  def define(info, &block); end

  class << self
    # Eval the given block. All methods available to the current connection
    # adapter are available within the block, so you can easily use the
    # database definition DSL to build up your schema (
    # {create_table}[rdoc-ref:ConnectionAdapters::SchemaStatements#create_table],
    # {add_index}[rdoc-ref:ConnectionAdapters::SchemaStatements#add_index], etc.).
    #
    # The +info+ hash is optional, and if given is used to define metadata
    # about the current schema (currently, only the schema's version):
    #
    #   ActiveRecord::Schema.define(version: 2038_01_19_000001) do
    #     ...
    #   end
    def define(info = T.unsafe(nil), &block); end
  end
end

# = Active Record Schema Dumper
#
# This class is used to dump the database schema for some connection to some
# output format (i.e., ActiveRecord::Schema).
class ActiveRecord::SchemaDumper
  # @return [SchemaDumper] a new instance of SchemaDumper
  def initialize(connection, options = T.unsafe(nil)); end

  # :singleton-method:
  # Specify a custom regular expression matching check constraints which name
  # should not be dumped to db/schema.rb.
  def chk_ignore_pattern; end

  def chk_ignore_pattern=(val); end
  def dump(stream); end

  # :singleton-method:
  # Specify a custom regular expression matching foreign keys which name
  # should not be dumped to db/schema.rb.
  def fk_ignore_pattern; end

  def fk_ignore_pattern=(val); end

  # :singleton-method:
  # A list of tables which should not be dumped to the schema.
  # Acceptable values are strings as well as regexp if ActiveRecord::Base.schema_format == :ruby.
  # Only strings are accepted if ActiveRecord::Base.schema_format == :sql.
  def ignore_tables; end

  def ignore_tables=(val); end

  private

  def check_constraints_in_create(table, stream); end
  def define_params; end

  # extensions are only supported by PostgreSQL
  def extensions(stream); end

  def foreign_keys(table, stream); end
  def format_colspec(colspec); end
  def format_index_parts(options); end
  def format_options(options); end

  # turns 20170404131909 into "2017_04_04_131909"
  def formatted_version; end

  def header(stream); end

  # @return [Boolean]
  def ignored?(table_name); end

  def index_parts(index); end

  # Keep it for indexing materialized views
  def indexes(table, stream); end

  def indexes_in_create(table, stream); end
  def remove_prefix_and_suffix(table); end
  def table(table, stream); end

  # Returns the value of attribute table_name.
  def table_name; end

  # Sets the attribute table_name
  #
  # @param value the value to set the attribute table_name to.
  def table_name=(_arg0); end

  def tables(stream); end
  def trailer(stream); end

  class << self
    def chk_ignore_pattern; end
    def chk_ignore_pattern=(val); end
    def dump(connection = T.unsafe(nil), stream = T.unsafe(nil), config = T.unsafe(nil)); end
    def fk_ignore_pattern; end
    def fk_ignore_pattern=(val); end
    def ignore_tables; end
    def ignore_tables=(val); end

    private

    def generate_options(config); end
  end
end

# This class is used to create a table that keeps track of which migrations
# have been applied to a given database. When a migration is run, its schema
# number is inserted in to the `SchemaMigration.table_name` so it doesn't need
# to be executed the next time.
class ActiveRecord::SchemaMigration < ::ActiveRecord::Base
  include ::ActiveRecord::SchemaMigration::GeneratedAttributeMethods
  include ::ActiveRecord::SchemaMigration::GeneratedAssociationMethods

  def version; end

  class << self
    # @return [Boolean]
    def _internal?; end

    def _validators; end
    def all_versions; end
    def create_table; end
    def defined_enums; end
    def drop_table; end
    def normalize_migration_number(number); end
    def normalized_versions; end
    def primary_key; end
    def table_name; end
  end
end

module ActiveRecord::SchemaMigration::GeneratedAssociationMethods; end
module ActiveRecord::SchemaMigration::GeneratedAttributeMethods; end

# = Active Record \Named \Scopes
module ActiveRecord::Scoping
  extend ::ActiveSupport::Concern
  extend ::ActiveSupport::Autoload
  include GeneratedInstanceMethods
  include ::ActiveRecord::Scoping::Default
  include ::ActiveRecord::Scoping::Named

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::ActiveRecord::Scoping::ClassMethods
  mixes_in_class_methods ::ActiveRecord::Scoping::Default::ClassMethods
  mixes_in_class_methods ::ActiveRecord::Scoping::Named::ClassMethods

  def initialize_internals_callback; end
  def populate_with_current_scope_attributes; end

  module GeneratedClassMethods
    def default_scope_override; end
    def default_scope_override=(value); end
    def default_scopes; end
    def default_scopes=(value); end
  end

  module GeneratedInstanceMethods
    def default_scope_override; end
    def default_scopes; end
  end
end

module ActiveRecord::Scoping::ClassMethods
  def current_scope(skip_inherited_scope = T.unsafe(nil)); end
  def current_scope=(scope); end

  # Collects attributes from scopes that should be applied when creating
  # an AR instance for the particular class this is called on.
  def scope_attributes; end

  # Are there attributes associated with this scope?
  #
  # @return [Boolean]
  def scope_attributes?; end
end

module ActiveRecord::Scoping::Default
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::ActiveRecord::Scoping::Default::ClassMethods

  module GeneratedClassMethods
    def default_scope_override; end
    def default_scope_override=(value); end
    def default_scopes; end
    def default_scopes=(value); end
  end

  module GeneratedInstanceMethods
    def default_scope_override; end
    def default_scopes; end
  end
end

module ActiveRecord::Scoping::Default::ClassMethods
  def before_remove_const; end

  # Are there attributes associated with this scope?
  #
  # @return [Boolean]
  def scope_attributes?; end

  # Returns a scope for the model without the previously set scopes.
  #
  #   class Post < ActiveRecord::Base
  #     def self.default_scope
  #       where(published: true)
  #     end
  #   end
  #
  #   Post.all                                  # Fires "SELECT * FROM posts WHERE published = true"
  #   Post.unscoped.all                         # Fires "SELECT * FROM posts"
  #   Post.where(published: false).unscoped.all # Fires "SELECT * FROM posts"
  #
  # This method also accepts a block. All queries inside the block will
  # not use the previously set scopes.
  #
  #   Post.unscoped {
  #     Post.limit(10) # Fires "SELECT * FROM posts LIMIT 10"
  #   }
  def unscoped; end

  private

  def build_default_scope(relation = T.unsafe(nil)); end

  # Use this macro in your model to set a default scope for all operations on
  # the model.
  #
  #   class Article < ActiveRecord::Base
  #     default_scope { where(published: true) }
  #   end
  #
  #   Article.all # => SELECT * FROM articles WHERE published = true
  #
  # The #default_scope is also applied while creating/building a record.
  # It is not applied while updating a record.
  #
  #   Article.new.published    # => true
  #   Article.create.published # => true
  #
  # (You can also pass any object which responds to +call+ to the
  # +default_scope+ macro, and it will be called when building the
  # default scope.)
  #
  # If you use multiple #default_scope declarations in your model then
  # they will be merged together:
  #
  #   class Article < ActiveRecord::Base
  #     default_scope { where(published: true) }
  #     default_scope { where(rating: 'G') }
  #   end
  #
  #   Article.all # => SELECT * FROM articles WHERE published = true AND rating = 'G'
  #
  # This is also the case with inheritance and module includes where the
  # parent or module defines a #default_scope and the child or including
  # class defines a second one.
  #
  # If you need to do more complex things with a default scope, you can
  # alternatively define it as a class method:
  #
  #   class Article < ActiveRecord::Base
  #     def self.default_scope
  #       # Should return a scope, you can call 'super' here etc.
  #     end
  #   end
  def default_scope(scope = T.unsafe(nil), &block); end

  # The ignore_default_scope flag is used to prevent an infinite recursion
  # situation where a default scope references a scope which has a default
  # scope which references a scope...
  def evaluate_default_scope; end

  def ignore_default_scope=(ignore); end

  # @return [Boolean]
  def ignore_default_scope?; end
end

module ActiveRecord::Scoping::Named
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::ActiveRecord::Scoping::Named::ClassMethods
end

module ActiveRecord::Scoping::Named::ClassMethods
  # Returns an ActiveRecord::Relation scope object.
  #
  #   posts = Post.all
  #   posts.size # Fires "select count(*) from  posts" and returns the count
  #   posts.each {|p| puts p.name } # Fires "select * from posts" and loads post objects
  #
  #   fruits = Fruit.all
  #   fruits = fruits.where(color: 'red') if options[:red_only]
  #   fruits = fruits.limit(10) if limited?
  #
  # You can define a scope that applies to all finders using
  # {default_scope}[rdoc-ref:Scoping::Default::ClassMethods#default_scope].
  def all; end

  def default_extensions; end

  # Returns a scope for the model with default scopes.
  def default_scoped(scope = T.unsafe(nil)); end

  # Adds a class method for retrieving and querying objects.
  # The method is intended to return an ActiveRecord::Relation
  # object, which is composable with other scopes.
  # If it returns +nil+ or +false+, an
  # {all}[rdoc-ref:Scoping::Named::ClassMethods#all] scope is returned instead.
  #
  # A \scope represents a narrowing of a database query, such as
  # <tt>where(color: :red).select('shirts.*').includes(:washing_instructions)</tt>.
  #
  #   class Shirt < ActiveRecord::Base
  #     scope :red, -> { where(color: 'red') }
  #     scope :dry_clean_only, -> { joins(:washing_instructions).where('washing_instructions.dry_clean_only = ?', true) }
  #   end
  #
  # The above calls to #scope define class methods <tt>Shirt.red</tt> and
  # <tt>Shirt.dry_clean_only</tt>. <tt>Shirt.red</tt>, in effect,
  # represents the query <tt>Shirt.where(color: 'red')</tt>.
  #
  # Note that this is simply 'syntactic sugar' for defining an actual
  # class method:
  #
  #   class Shirt < ActiveRecord::Base
  #     def self.red
  #       where(color: 'red')
  #     end
  #   end
  #
  # Unlike <tt>Shirt.find(...)</tt>, however, the object returned by
  # <tt>Shirt.red</tt> is not an Array but an ActiveRecord::Relation,
  # which is composable with other scopes; it resembles the association object
  # constructed by a {has_many}[rdoc-ref:Associations::ClassMethods#has_many]
  # declaration. For instance, you can invoke <tt>Shirt.red.first</tt>, <tt>Shirt.red.count</tt>,
  # <tt>Shirt.red.where(size: 'small')</tt>. Also, just as with the
  # association objects, named \scopes act like an Array, implementing
  # Enumerable; <tt>Shirt.red.each(&block)</tt>, <tt>Shirt.red.first</tt>,
  # and <tt>Shirt.red.inject(memo, &block)</tt> all behave as if
  # <tt>Shirt.red</tt> really was an array.
  #
  # These named \scopes are composable. For instance,
  # <tt>Shirt.red.dry_clean_only</tt> will produce all shirts that are
  # both red and dry clean only. Nested finds and calculations also work
  # with these compositions: <tt>Shirt.red.dry_clean_only.count</tt>
  # returns the number of garments for which these criteria obtain.
  # Similarly with <tt>Shirt.red.dry_clean_only.average(:thread_count)</tt>.
  #
  # All scopes are available as class methods on the ActiveRecord::Base
  # descendant upon which the \scopes were defined. But they are also
  # available to {has_many}[rdoc-ref:Associations::ClassMethods#has_many]
  # associations. If,
  #
  #   class Person < ActiveRecord::Base
  #     has_many :shirts
  #   end
  #
  # then <tt>elton.shirts.red.dry_clean_only</tt> will return all of
  # Elton's red, dry clean only shirts.
  #
  # \Named scopes can also have extensions, just as with
  # {has_many}[rdoc-ref:Associations::ClassMethods#has_many] declarations:
  #
  #   class Shirt < ActiveRecord::Base
  #     scope :red, -> { where(color: 'red') } do
  #       def dom_id
  #         'red_shirts'
  #       end
  #     end
  #   end
  #
  # Scopes can also be used while creating/building a record.
  #
  #   class Article < ActiveRecord::Base
  #     scope :published, -> { where(published: true) }
  #   end
  #
  #   Article.published.new.published    # => true
  #   Article.published.create.published # => true
  #
  # \Class methods on your model are automatically available
  # on scopes. Assuming the following setup:
  #
  #   class Article < ActiveRecord::Base
  #     scope :published, -> { where(published: true) }
  #     scope :featured, -> { where(featured: true) }
  #
  #     def self.latest_article
  #       order('published_at desc').first
  #     end
  #
  #     def self.titles
  #       pluck(:title)
  #     end
  #   end
  #
  # We are able to call the methods like this:
  #
  #   Article.published.featured.latest_article
  #   Article.featured.titles
  def scope(name, body, &block); end

  def scope_for_association(scope = T.unsafe(nil)); end

  private

  def singleton_method_added(name); end

  # @return [Boolean]
  def valid_scope_name?(name); end
end

# This class stores the +:current_scope+ and +:ignore_default_scope+ values
# for different classes. The registry is stored as a thread local, which is
# accessed through +ScopeRegistry.current+.
#
# This class allows you to store and get the scope values on different
# classes and different types of scopes. For example, if you are attempting
# to get the current_scope for the +Board+ model, then you would use the
# following code:
#
#   registry = ActiveRecord::Scoping::ScopeRegistry
#   registry.set_value_for(:current_scope, Board, some_new_scope)
#
# Now when you run:
#
#   registry.value_for(:current_scope, Board)
#
# You will obtain whatever was defined in +some_new_scope+. The #value_for
# and #set_value_for methods are delegated to the current ScopeRegistry
# object, so the above example code can also be called as:
#
#   ActiveRecord::Scoping::ScopeRegistry.set_value_for(:current_scope,
#       Board, some_new_scope)
class ActiveRecord::Scoping::ScopeRegistry
  extend ::ActiveSupport::PerThreadRegistry

  # @return [ScopeRegistry] a new instance of ScopeRegistry
  def initialize; end

  # Sets the +value+ for a given +scope_type+ and +model+.
  def set_value_for(scope_type, model, value); end

  # Obtains the value for a given +scope_type+ and +model+.
  def value_for(scope_type, model, skip_inherited_scope = T.unsafe(nil)); end

  private

  def raise_invalid_scope_type!(scope_type); end
end

ActiveRecord::Scoping::ScopeRegistry::VALID_SCOPE_TYPES = T.let(T.unsafe(nil), Array)

module ActiveRecord::SecureToken
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::ActiveRecord::SecureToken::ClassMethods
end

module ActiveRecord::SecureToken::ClassMethods
  def generate_unique_secure_token(length: T.unsafe(nil)); end

  # Example using #has_secure_token
  #
  #   # Schema: User(token:string, auth_token:string)
  #   class User < ActiveRecord::Base
  #     has_secure_token
  #     has_secure_token :auth_token, length: 36
  #   end
  #
  #   user = User.new
  #   user.save
  #   user.token # => "pX27zsMN2ViQKta1bGfLmVJE"
  #   user.auth_token # => "tU9bLuZseefXQ4yQxQo8wjtBvsAfPc78os6R"
  #   user.regenerate_token # => true
  #   user.regenerate_auth_token # => true
  #
  # <tt>SecureRandom::base58</tt> is used to generate at minimum a 24-character unique token, so collisions are highly unlikely.
  #
  # Note that it's still possible to generate a race condition in the database in the same way that
  # {validates_uniqueness_of}[rdoc-ref:Validations::ClassMethods#validates_uniqueness_of] can.
  # You're encouraged to add a unique index in the database to deal with this even more unlikely scenario.
  def has_secure_token(attribute = T.unsafe(nil), length: T.unsafe(nil)); end
end

ActiveRecord::SecureToken::MINIMUM_TOKEN_LENGTH = T.let(T.unsafe(nil), Integer)
class ActiveRecord::SecureToken::MinimumLengthError < ::StandardError; end

# = Active Record \Serialization
module ActiveRecord::Serialization
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods
  include ::ActiveModel::Serializers::JSON

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::ActiveModel::Naming

  def serializable_hash(options = T.unsafe(nil)); end

  module GeneratedClassMethods
    def include_root_in_json; end
    def include_root_in_json=(value); end
    def include_root_in_json?; end
  end

  module GeneratedInstanceMethods
    def include_root_in_json; end
    def include_root_in_json?; end
  end
end

# SerializationFailure will be raised when a transaction is rolled
# back by the database due to a serialization failure.
class ActiveRecord::SerializationFailure < ::ActiveRecord::TransactionRollbackError; end

# Raised when unserialized object's type mismatches one specified for serializable field.
class ActiveRecord::SerializationTypeMismatch < ::ActiveRecord::ActiveRecordError; end

# = Active Record Signed Id
module ActiveRecord::SignedId
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::ActiveRecord::SignedId::ClassMethods

  # Returns a signed id that's generated using a preconfigured +ActiveSupport::MessageVerifier+ instance.
  # This signed id is tamper proof, so it's safe to send in an email or otherwise share with the outside world.
  # It can further more be set to expire (the default is not to expire), and scoped down with a specific purpose.
  # If the expiration date has been exceeded before +find_signed+ is called, the id won't find the designated
  # record. If a purpose is set, this too must match.
  #
  # If you accidentally let a signed id out in the wild that you wish to retract sooner than its expiration date
  # (or maybe you forgot to set an expiration date while meaning to!), you can use the purpose to essentially
  # version the signed_id, like so:
  #
  #   user.signed_id purpose: :v2
  #
  # And you then change your +find_signed+ calls to require this new purpose. Any old signed ids that were not
  # created with the purpose will no longer find the record.
  def signed_id(expires_in: T.unsafe(nil), purpose: T.unsafe(nil)); end
end

module ActiveRecord::SignedId::ClassMethods
  def combine_signed_id_purposes(purpose); end

  # Lets you find a record based on a signed id that's safe to put into the world without risk of tampering.
  # This is particularly useful for things like password reset or email verification, where you want
  # the bearer of the signed id to be able to interact with the underlying record, but usually only within
  # a certain time period.
  #
  # You set the time period that the signed id is valid for during generation, using the instance method
  # <tt>signed_id(expires_in: 15.minutes)</tt>. If the time has elapsed before a signed find is attempted,
  # the signed id will no longer be valid, and nil is returned.
  #
  # It's possible to further restrict the use of a signed id with a purpose. This helps when you have a
  # general base model, like a User, which might have signed ids for several things, like password reset
  # or email verification. The purpose that was set during generation must match the purpose set when
  # finding. If there's a mismatch, nil is again returned.
  #
  # ==== Examples
  #
  #   signed_id = User.first.signed_id expires_in: 15.minutes, purpose: :password_reset
  #
  #   User.find_signed signed_id # => nil, since the purpose does not match
  #
  #   travel 16.minutes
  #   User.find_signed signed_id, purpose: :password_reset # => nil, since the signed id has expired
  #
  #   travel_back
  #   User.find_signed signed_id, purpose: :password_reset # => User.first
  #
  # @raise [UnknownPrimaryKey]
  def find_signed(signed_id, purpose: T.unsafe(nil)); end

  # Works like +find_signed+, but will raise an +ActiveSupport::MessageVerifier::InvalidSignature+
  # exception if the +signed_id+ has either expired, has a purpose mismatch, is for another record,
  # or has been tampered with. It will also raise an +ActiveRecord::RecordNotFound+ exception if
  # the valid signed id can't find a record.
  #
  # === Examples
  #
  #   User.find_signed! "bad data" # => ActiveSupport::MessageVerifier::InvalidSignature
  #
  #   signed_id = User.first.signed_id
  #   User.first.destroy
  #   User.find_signed! signed_id # => ActiveRecord::RecordNotFound
  def find_signed!(signed_id, purpose: T.unsafe(nil)); end

  # The verifier instance that all signed ids are generated and verified from. By default, it'll be initialized
  # with the class-level +signed_id_verifier_secret+, which within Rails comes from the
  # Rails.application.key_generator. By default, it's SHA256 for the digest and JSON for the serialization.
  def signed_id_verifier; end

  # Allows you to pass in a custom verifier used for the signed ids. This also allows you to use different
  # verifiers for different classes. This is also helpful if you need to rotate keys, as you can prepare
  # your custom verifier for that in advance. See +ActiveSupport::MessageVerifier+ for details.
  def signed_id_verifier=(verifier); end
end

module ActiveRecord::SpawnMethods
  # Removes from the query the condition(s) specified in +skips+.
  #
  #   Post.order('id asc').except(:order)                  # discards the order condition
  #   Post.where('id > 10').order('id asc').except(:where) # discards the where condition but keeps the order
  def except(*skips); end

  # Merges in the conditions from <tt>other</tt>, if <tt>other</tt> is an ActiveRecord::Relation.
  # Returns an array representing the intersection of the resulting records with <tt>other</tt>, if <tt>other</tt> is an array.
  #
  #   Post.where(published: true).joins(:comments).merge( Comment.where(spam: false) )
  #   # Performs a single join query with both where conditions.
  #
  #   recent_posts = Post.order('created_at DESC').first(5)
  #   Post.where(published: true).merge(recent_posts)
  #   # Returns the intersection of all published posts with the 5 most recently created posts.
  #   # (This is just an example. You'd probably want to do this with a single query!)
  #
  # Procs will be evaluated by merge:
  #
  #   Post.where(published: true).merge(-> { joins(:comments) })
  #   # => Post.where(published: true).joins(:comments)
  #
  # This is mainly intended for sharing common conditions between multiple associations.
  def merge(other, *rest); end

  def merge!(other, *rest); end

  # Removes any condition from the query other than the one(s) specified in +onlies+.
  #
  #   Post.order('id asc').only(:where)         # discards the order condition
  #   Post.order('id asc').only(:where, :order) # uses the specified order
  def only(*onlies); end

  # This is overridden by Associations::CollectionProxy
  def spawn; end

  private

  def relation_with(values); end
end

# Raised on attempt to save stale record. Record is stale when it's being saved in another query after
# instantiation, for example, when two users edit the same wiki page and one starts editing and saves
# the page before the other.
#
# Read more about optimistic locking in ActiveRecord::Locking module
# documentation.
class ActiveRecord::StaleObjectError < ::ActiveRecord::ActiveRecordError
  # @return [StaleObjectError] a new instance of StaleObjectError
  def initialize(record = T.unsafe(nil), attempted_action = T.unsafe(nil)); end

  # Returns the value of attribute attempted_action.
  def attempted_action; end

  # Returns the value of attribute record.
  def record; end
end

# Statement cache is used to cache a single statement in order to avoid creating the AST again.
# Initializing the cache is done by passing the statement in the create block:
#
#   cache = StatementCache.create(Book.connection) do |params|
#     Book.where(name: "my book").where("author_id > 3")
#   end
#
# The cached statement is executed by using the
# {connection.execute}[rdoc-ref:ConnectionAdapters::DatabaseStatements#execute] method:
#
#   cache.execute([], Book.connection)
#
# The relation returned by the block is cached, and for each
# {execute}[rdoc-ref:ConnectionAdapters::DatabaseStatements#execute]
# call the cached relation gets duped. Database is queried when +to_a+ is called on the relation.
#
# If you want to cache the statement without the values you can use the +bind+ method of the
# block parameter.
#
#   cache = StatementCache.create(Book.connection) do |params|
#     Book.where(name: params.bind)
#   end
#
# And pass the bind values as the first argument of +execute+ call.
#
#   cache.execute(["my book"], Book.connection)
class ActiveRecord::StatementCache
  # @return [StatementCache] a new instance of StatementCache
  def initialize(query_builder, bind_map, klass); end

  def execute(params, connection, &block); end

  private

  # Returns the value of attribute bind_map.
  def bind_map; end

  # Returns the value of attribute klass.
  def klass; end

  # Returns the value of attribute query_builder.
  def query_builder; end

  class << self
    def create(connection, callable = T.unsafe(nil), &block); end
    def partial_query(values); end
    def partial_query_collector; end
    def query(sql); end

    # @return [Boolean]
    def unsupported_value?(value); end
  end
end

class ActiveRecord::StatementCache::BindMap
  # @return [BindMap] a new instance of BindMap
  def initialize(bound_attributes); end

  def bind(values); end
end

class ActiveRecord::StatementCache::Params
  def bind; end
end

class ActiveRecord::StatementCache::PartialQuery < ::ActiveRecord::StatementCache::Query
  # @return [PartialQuery] a new instance of PartialQuery
  def initialize(values); end

  def sql_for(binds, connection); end
end

class ActiveRecord::StatementCache::PartialQueryCollector
  # @return [PartialQueryCollector] a new instance of PartialQueryCollector
  def initialize; end

  def <<(str); end
  def add_bind(obj); end
  def add_binds(binds, proc_for_binds = T.unsafe(nil)); end

  # Returns the value of attribute preparable.
  def preparable; end

  # Sets the attribute preparable
  #
  # @param value the value to set the attribute preparable to.
  def preparable=(_arg0); end

  def value; end
end

class ActiveRecord::StatementCache::Query
  # @return [Query] a new instance of Query
  def initialize(sql); end

  def sql_for(binds, connection); end
end

class ActiveRecord::StatementCache::Substitute; end

# Superclass for all database execution errors.
#
# Wraps the underlying database error as +cause+.
class ActiveRecord::StatementInvalid < ::ActiveRecord::ActiveRecordError
  # @return [StatementInvalid] a new instance of StatementInvalid
  def initialize(message = T.unsafe(nil), sql: T.unsafe(nil), binds: T.unsafe(nil)); end

  # Returns the value of attribute binds.
  def binds; end

  # Returns the value of attribute sql.
  def sql; end
end

# StatementTimeout will be raised when statement timeout exceeded.
class ActiveRecord::StatementTimeout < ::ActiveRecord::QueryAborted; end

# Store gives you a thin wrapper around serialize for the purpose of storing hashes in a single column.
# It's like a simple key/value store baked into your record when you don't care about being able to
# query that store outside the context of a single record.
#
# You can then declare accessors to this store that are then accessible just like any other attribute
# of the model. This is very helpful for easily exposing store keys to a form or elsewhere that's
# already built around just accessing attributes on the model.
#
# Every accessor comes with dirty tracking methods (+key_changed?+, +key_was+ and +key_change+) and
# methods to access the changes made during the last save (+saved_change_to_key?+, +saved_change_to_key+ and
# +key_before_last_save+).
#
# NOTE: There is no +key_will_change!+ method for accessors, use +store_will_change!+ instead.
#
# Make sure that you declare the database column used for the serialized store as a text, so there's
# plenty of room.
#
# You can set custom coder to encode/decode your serialized attributes to/from different formats.
# JSON, YAML, Marshal are supported out of the box. Generally it can be any wrapper that provides +load+ and +dump+.
#
# NOTE: If you are using structured database data types (e.g. PostgreSQL +hstore+/+json+, or MySQL 5.7+
# +json+) there is no need for the serialization provided by {.store}[rdoc-ref:rdoc-ref:ClassMethods#store].
# Simply use {.store_accessor}[rdoc-ref:ClassMethods#store_accessor] instead to generate
# the accessor methods. Be aware that these columns use a string keyed hash and do not allow access
# using a symbol.
#
# NOTE: The default validations with the exception of +uniqueness+ will work.
# For example, if you want to check for +uniqueness+ with +hstore+ you will
# need to use a custom validation to handle it.
#
# Examples:
#
#   class User < ActiveRecord::Base
#     store :settings, accessors: [ :color, :homepage ], coder: JSON
#     store :parent, accessors: [ :name ], coder: JSON, prefix: true
#     store :spouse, accessors: [ :name ], coder: JSON, prefix: :partner
#     store :settings, accessors: [ :two_factor_auth ], suffix: true
#     store :settings, accessors: [ :login_retry ], suffix: :config
#   end
#
#   u = User.new(color: 'black', homepage: '37signals.com', parent_name: 'Mary', partner_name: 'Lily')
#   u.color                          # Accessor stored attribute
#   u.parent_name                    # Accessor stored attribute with prefix
#   u.partner_name                   # Accessor stored attribute with custom prefix
#   u.two_factor_auth_settings       # Accessor stored attribute with suffix
#   u.login_retry_config             # Accessor stored attribute with custom suffix
#   u.settings[:country] = 'Denmark' # Any attribute, even if not specified with an accessor
#
#   # There is no difference between strings and symbols for accessing custom attributes
#   u.settings[:country]  # => 'Denmark'
#   u.settings['country'] # => 'Denmark'
#
#   # Dirty tracking
#   u.color = 'green'
#   u.color_changed? # => true
#   u.color_was # => 'black'
#   u.color_change # => ['black', 'red']
#
#   # Add additional accessors to an existing store through store_accessor
#   class SuperUser < User
#     store_accessor :settings, :privileges, :servants
#     store_accessor :parent, :birthday, prefix: true
#     store_accessor :settings, :secret_question, suffix: :config
#   end
#
# The stored attribute names can be retrieved using {.stored_attributes}[rdoc-ref:rdoc-ref:ClassMethods#stored_attributes].
#
#   User.stored_attributes[:settings] # [:color, :homepage, :two_factor_auth, :login_retry]
#
# == Overwriting default accessors
#
# All stored values are automatically available through accessors on the Active Record
# object, but sometimes you want to specialize this behavior. This can be done by overwriting
# the default accessors (using the same name as the attribute) and calling <tt>super</tt>
# to actually change things.
#
#   class Song < ActiveRecord::Base
#     # Uses a stored integer to hold the volume adjustment of the song
#     store :settings, accessors: [:volume_adjustment]
#
#     def volume_adjustment=(decibels)
#       super(decibels.to_i)
#     end
#
#     def volume_adjustment
#       super.to_i
#     end
#   end
module ActiveRecord::Store
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::ActiveRecord::Store::ClassMethods

  private

  def read_store_attribute(store_attribute, key); end
  def store_accessor_for(store_attribute); end
  def write_store_attribute(store_attribute, key, value); end
end

module ActiveRecord::Store::ClassMethods
  def _store_accessors_module; end
  def store(store_attribute, options = T.unsafe(nil)); end
  def store_accessor(store_attribute, *keys, prefix: T.unsafe(nil), suffix: T.unsafe(nil)); end
  def stored_attributes; end
end

class ActiveRecord::Store::HashAccessor
  class << self
    def prepare(object, attribute); end
    def read(object, attribute, key); end
    def write(object, attribute, key, value); end
  end
end

class ActiveRecord::Store::IndifferentCoder
  # @return [IndifferentCoder] a new instance of IndifferentCoder
  def initialize(attr_name, coder_or_class_name); end

  def dump(obj); end
  def load(yaml); end

  class << self
    def as_indifferent_hash(obj); end
  end
end

class ActiveRecord::Store::IndifferentHashAccessor < ::ActiveRecord::Store::HashAccessor
  class << self
    def prepare(object, store_attribute); end
  end
end

class ActiveRecord::Store::StringKeyedHashAccessor < ::ActiveRecord::Store::HashAccessor
  class << self
    def read(object, attribute, key); end
    def write(object, attribute, key, value); end
  end
end

# Raised on attempt to lazily load records that are marked as strict loading.
class ActiveRecord::StrictLoadingViolationError < ::ActiveRecord::ActiveRecordError; end

# Raised when the single-table inheritance mechanism fails to locate the subclass
# (for example due to improper usage of column that
# {ActiveRecord::Base.inheritance_column}[rdoc-ref:ModelSchema::ClassMethods#inheritance_column]
# points to).
class ActiveRecord::SubclassNotFound < ::ActiveRecord::ActiveRecordError; end

# ActiveRecord::Suppressor prevents the receiver from being saved during
# a given block.
#
# For example, here's a pattern of creating notifications when new comments
# are posted. (The notification may in turn trigger an email, a push
# notification, or just appear in the UI somewhere):
#
#   class Comment < ActiveRecord::Base
#     belongs_to :commentable, polymorphic: true
#     after_create -> { Notification.create! comment: self,
#       recipients: commentable.recipients }
#   end
#
# That's what you want the bulk of the time. New comment creates a new
# Notification. But there may well be off cases, like copying a commentable
# and its comments, where you don't want that. So you'd have a concern
# something like this:
#
#   module Copyable
#     def copy_to(destination)
#       Notification.suppress do
#         # Copy logic that creates new comments that we do not want
#         # triggering notifications.
#       end
#     end
#   end
module ActiveRecord::Suppressor
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::ActiveRecord::Suppressor::ClassMethods

  def save(**_arg0); end
  def save!(**_arg0); end
end

module ActiveRecord::Suppressor::ClassMethods
  def suppress(&block); end
end

class ActiveRecord::SuppressorRegistry
  extend ::ActiveSupport::PerThreadRegistry

  # @return [SuppressorRegistry] a new instance of SuppressorRegistry
  def initialize; end

  # Returns the value of attribute suppressed.
  def suppressed; end
end

class ActiveRecord::TableMetadata
  # @return [TableMetadata] a new instance of TableMetadata
  def initialize(klass, arel_table, reflection = T.unsafe(nil)); end

  def aggregated_with?(aggregation_name); end

  # Returns the value of attribute arel_table.
  def arel_table; end

  def associated_table(table_name); end

  # @return [Boolean]
  def associated_with?(table_name); end

  # @return [Boolean]
  def has_column?(column_name); end

  def join_foreign_key(*_arg0, &_arg1); end
  def join_foreign_type(*_arg0, &_arg1); end
  def join_primary_key(*_arg0, &_arg1); end

  # @return [Boolean]
  def polymorphic_association?; end

  def predicate_builder; end
  def primary_key; end
  def reflect_on_aggregation(aggregation_name); end

  # @return [Boolean]
  def through_association?; end

  def type(column_name); end

  private

  # Returns the value of attribute klass.
  def klass; end

  # Returns the value of attribute reflection.
  def reflection; end
end

# Raised when a model makes a query but it has not specified an associated table.
class ActiveRecord::TableNotSpecified < ::ActiveRecord::ActiveRecordError; end

module ActiveRecord::Tasks
  extend ::ActiveSupport::Autoload
end

class ActiveRecord::Tasks::DatabaseNotSupported < ::StandardError; end

# ActiveRecord::Tasks::DatabaseTasks is a utility class, which encapsulates
# logic behind common tasks used to manage database and migrations.
#
# The tasks defined here are used with Rails commands provided by Active Record.
#
# In order to use DatabaseTasks, a few config values need to be set. All the needed
# config values are set by Rails already, so it's necessary to do it only if you
# want to change the defaults or when you want to use Active Record outside of Rails
# (in such case after configuring the database tasks, you can also use the rake tasks
# defined in Active Record).
#
# The possible config values are:
#
# * +env+: current environment (like Rails.env).
# * +database_configuration+: configuration of your databases (as in +config/database.yml+).
# * +db_dir+: your +db+ directory.
# * +fixtures_path+: a path to fixtures directory.
# * +migrations_paths+: a list of paths to directories with migrations.
# * +seed_loader+: an object which will load seeds, it needs to respond to the +load_seed+ method.
# * +root+: a path to the root of the application.
#
# Example usage of DatabaseTasks outside Rails could look as such:
#
#   include ActiveRecord::Tasks
#   DatabaseTasks.database_configuration = YAML.load_file('my_database_config.yml')
#   DatabaseTasks.db_dir = 'db'
#   # other settings...
#
#   DatabaseTasks.create_current('production')
module ActiveRecord::Tasks::DatabaseTasks
  extend ::ActiveRecord::Tasks::DatabaseTasks

  def cache_dump_filename(db_config_name, schema_cache_path: T.unsafe(nil)); end
  def charset(configuration, *arguments); end
  def charset_current(env_name = T.unsafe(nil), db_name = T.unsafe(nil)); end
  def check_protected_environments!; end
  def check_schema_file(filename); end
  def check_target_version; end
  def clear_schema_cache(filename); end
  def collation(configuration, *arguments); end
  def collation_current(env_name = T.unsafe(nil), db_name = T.unsafe(nil)); end
  def create(configuration, *arguments); end
  def create_all; end
  def create_current(environment = T.unsafe(nil), name = T.unsafe(nil)); end
  def current_config(*args, &block); end

  # Sets the attribute current_config
  #
  # @param value the value to set the attribute current_config to.
  def current_config=(*args, &block); end

  # Returns the value of attribute database_configuration.
  def database_configuration; end

  # Sets the attribute database_configuration
  #
  # @param value the value to set the attribute database_configuration to.
  def database_configuration=(_arg0); end

  def db_dir; end

  # Sets the attribute db_dir
  #
  # @param value the value to set the attribute db_dir to.
  def db_dir=(_arg0); end

  def drop(configuration, *arguments); end
  def drop_all; end
  def drop_current(environment = T.unsafe(nil)); end
  def dump_filename(db_config_name, format = T.unsafe(nil)); end
  def dump_schema(db_config, format = T.unsafe(nil)); end

  # Dumps the schema cache in YAML format for the connection into the file
  #
  # ==== Examples:
  #   ActiveRecord::Tasks::DatabaseTasks.dump_schema_cache(ActiveRecord::Base.connection, "tmp/schema_dump.yaml")
  def dump_schema_cache(conn, filename); end

  def env; end

  # Sets the attribute env
  #
  # @param value the value to set the attribute env to.
  def env=(_arg0); end

  def fixtures_path; end

  # Sets the attribute fixtures_path
  #
  # @param value the value to set the attribute fixtures_path to.
  def fixtures_path=(_arg0); end

  def for_each(databases); end
  def load_schema(db_config, format = T.unsafe(nil), file = T.unsafe(nil)); end
  def load_schema_current(format = T.unsafe(nil), file = T.unsafe(nil), environment = T.unsafe(nil)); end
  def load_seed; end
  def migrate; end
  def migrate_status; end
  def migrations_paths; end

  # Sets the attribute migrations_paths
  #
  # @param value the value to set the attribute migrations_paths to.
  def migrations_paths=(_arg0); end

  def name; end
  def purge(configuration); end
  def purge_all; end
  def purge_current(environment = T.unsafe(nil)); end
  def raise_for_multi_db(environment = T.unsafe(nil), command:); end
  def reconstruct_from_schema(db_config, format = T.unsafe(nil), file = T.unsafe(nil)); end
  def register_task(pattern, task); end
  def root; end

  # Sets the attribute root
  #
  # @param value the value to set the attribute root to.
  def root=(_arg0); end

  def schema_file(format = T.unsafe(nil)); end
  def schema_file_type(format = T.unsafe(nil)); end

  # @return [Boolean]
  def schema_up_to_date?(configuration, format = T.unsafe(nil), file = T.unsafe(nil), environment = T.unsafe(nil), name = T.unsafe(nil)); end

  def seed_loader; end

  # Sets the attribute seed_loader
  #
  # @param value the value to set the attribute seed_loader to.
  def seed_loader=(_arg0); end

  def setup_initial_database_yaml; end
  def spec(*args, &block); end
  def structure_dump(configuration, *arguments); end
  def structure_load(configuration, *arguments); end
  def target_version; end
  def truncate_all(environment = T.unsafe(nil)); end

  private

  def class_for_adapter(adapter); end

  # Create a new instance for the specified db configuration object
  # For classes that have been converted to use db_config objects, pass a
  # `DatabaseConfig`, otherwise pass a `Hash`
  def database_adapter_for(db_config, *arguments); end

  def each_current_configuration(environment, name = T.unsafe(nil)); end
  def each_local_configuration; end

  # @return [Boolean]
  def local_database?(db_config); end

  def resolve_configuration(configuration); end
  def schema_sha1(file); end
  def truncate_tables(db_config); end

  # @return [Boolean]
  def verbose?; end

  class << self
    def structure_dump_flags; end
    def structure_dump_flags=(val); end
    def structure_load_flags; end
    def structure_load_flags=(val); end
  end
end

ActiveRecord::Tasks::DatabaseTasks::LOCAL_HOSTS = T.let(T.unsafe(nil), Array)

class ActiveRecord::Tasks::MySQLDatabaseTasks
  # @return [MySQLDatabaseTasks] a new instance of MySQLDatabaseTasks
  def initialize(db_config); end

  def charset; end
  def collation; end
  def connection(*_arg0, &_arg1); end
  def create; end
  def drop; end
  def establish_connection(*_arg0, &_arg1); end
  def purge; end
  def structure_dump(filename, extra_flags); end
  def structure_load(filename, extra_flags); end

  private

  # Returns the value of attribute configuration_hash.
  def configuration_hash; end

  def configuration_hash_without_database; end
  def creation_options; end

  # Returns the value of attribute db_config.
  def db_config; end

  def prepare_command_options; end
  def run_cmd(cmd, args, action); end
  def run_cmd_error(cmd, args, action); end

  class << self
    # @return [Boolean]
    def using_database_configurations?; end
  end
end

ActiveRecord::Tasks::MySQLDatabaseTasks::ER_DB_CREATE_EXISTS = T.let(T.unsafe(nil), Integer)

class ActiveRecord::Tasks::PostgreSQLDatabaseTasks
  # @return [PostgreSQLDatabaseTasks] a new instance of PostgreSQLDatabaseTasks
  def initialize(db_config); end

  def charset; end
  def clear_active_connections!(*_arg0, &_arg1); end
  def collation; end
  def connection(*_arg0, &_arg1); end
  def create(master_established = T.unsafe(nil)); end
  def drop; end
  def establish_connection(*_arg0, &_arg1); end
  def purge; end
  def structure_dump(filename, extra_flags); end
  def structure_load(filename, extra_flags); end

  private

  # Returns the value of attribute configuration_hash.
  def configuration_hash; end

  # Returns the value of attribute db_config.
  def db_config; end

  def encoding; end
  def establish_master_connection; end
  def remove_sql_header_comments(filename); end
  def run_cmd(cmd, args, action); end
  def run_cmd_error(cmd, args, action); end
  def set_psql_env; end

  class << self
    # @return [Boolean]
    def using_database_configurations?; end
  end
end

ActiveRecord::Tasks::PostgreSQLDatabaseTasks::DEFAULT_ENCODING = T.let(T.unsafe(nil), String)
ActiveRecord::Tasks::PostgreSQLDatabaseTasks::ON_ERROR_STOP_1 = T.let(T.unsafe(nil), String)
ActiveRecord::Tasks::PostgreSQLDatabaseTasks::SQL_COMMENT_BEGIN = T.let(T.unsafe(nil), String)

class ActiveRecord::Tasks::SQLiteDatabaseTasks
  # @return [SQLiteDatabaseTasks] a new instance of SQLiteDatabaseTasks
  def initialize(db_config, root = T.unsafe(nil)); end

  def charset; end
  def connection(*_arg0, &_arg1); end

  # @raise [DatabaseAlreadyExists]
  def create; end

  def drop; end
  def establish_connection(*_arg0, &_arg1); end
  def purge; end
  def structure_dump(filename, extra_flags); end
  def structure_load(filename, extra_flags); end

  private

  # Returns the value of attribute db_config.
  def db_config; end

  # Returns the value of attribute root.
  def root; end

  def run_cmd(cmd, args, out); end
  def run_cmd_error(cmd, args); end

  class << self
    # @return [Boolean]
    def using_database_configurations?; end
  end
end

module ActiveRecord::TestDatabases
  class << self
    def create_and_load_schema(i, env_name:); end
  end
end

module ActiveRecord::TestFixtures
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::ActiveRecord::TestFixtures::ClassMethods

  def after_teardown; end
  def before_setup; end
  def enlist_fixture_connections; end

  # @return [Boolean]
  def run_in_transaction?; end

  def setup_fixtures(config = T.unsafe(nil)); end
  def teardown_fixtures; end

  private

  def instantiate_fixtures; end
  def load_fixtures(config); end

  # @return [Boolean]
  def load_instances?; end

  # Shares the writing connection pool with connections on
  # other handlers.
  #
  # In an application with a primary and replica the test fixtures
  # need to share a connection pool so that the reading connection
  # can see data in the open transaction on the writing connection.
  def setup_shared_connection_pool; end

  def teardown_shared_connection_pool; end

  module GeneratedClassMethods
    def fixture_class_names; end
    def fixture_class_names=(value); end
    def fixture_class_names?; end
    def fixture_path; end
    def fixture_path=(value); end
    def fixture_path?; end
    def fixture_table_names; end
    def fixture_table_names=(value); end
    def fixture_table_names?; end
    def lock_threads; end
    def lock_threads=(value); end
    def lock_threads?; end
    def pre_loaded_fixtures; end
    def pre_loaded_fixtures=(value); end
    def pre_loaded_fixtures?; end
    def use_instantiated_fixtures; end
    def use_instantiated_fixtures=(value); end
    def use_instantiated_fixtures?; end
    def use_transactional_tests; end
    def use_transactional_tests=(value); end
    def use_transactional_tests?; end
  end

  module GeneratedInstanceMethods
    def fixture_class_names; end
    def fixture_class_names=(value); end
    def fixture_class_names?; end
    def fixture_path; end
    def fixture_path?; end
    def fixture_table_names; end
    def fixture_table_names=(value); end
    def fixture_table_names?; end
    def lock_threads; end
    def lock_threads=(value); end
    def lock_threads?; end
    def pre_loaded_fixtures; end
    def pre_loaded_fixtures=(value); end
    def pre_loaded_fixtures?; end
    def use_instantiated_fixtures; end
    def use_instantiated_fixtures=(value); end
    def use_instantiated_fixtures?; end
    def use_transactional_tests; end
    def use_transactional_tests=(value); end
    def use_transactional_tests?; end
  end
end

module ActiveRecord::TestFixtures::ClassMethods
  def fixtures(*fixture_set_names); end

  # Sets the model class for a fixture when the class name cannot be inferred from the fixture name.
  #
  # Examples:
  #
  #   set_fixture_class some_fixture:        SomeModel,
  #                     'namespaced/fixture' => Another::Model
  #
  # The keys must be the fixture names, that coincide with the short paths to the fixture files.
  def set_fixture_class(class_names = T.unsafe(nil)); end

  def setup_fixture_accessors(fixture_set_names = T.unsafe(nil)); end
  def uses_transaction(*methods); end

  # @return [Boolean]
  def uses_transaction?(method); end
end

class ActiveRecord::ThroughCantAssociateThroughHasOneOrManyReflection < ::ActiveRecord::ActiveRecordError
  # @return [ThroughCantAssociateThroughHasOneOrManyReflection] a new instance of ThroughCantAssociateThroughHasOneOrManyReflection
  def initialize(owner = T.unsafe(nil), reflection = T.unsafe(nil)); end
end

class ActiveRecord::ThroughNestedAssociationsAreReadonly < ::ActiveRecord::ActiveRecordError
  # @return [ThroughNestedAssociationsAreReadonly] a new instance of ThroughNestedAssociationsAreReadonly
  def initialize(owner = T.unsafe(nil), reflection = T.unsafe(nil)); end
end

# = Active Record \Timestamp
#
# Active Record automatically timestamps create and update operations if the
# table has fields named <tt>created_at/created_on</tt> or
# <tt>updated_at/updated_on</tt>.
#
# Timestamping can be turned off by setting:
#
#   config.active_record.record_timestamps = false
#
# Timestamps are in UTC by default but you can use the local timezone by setting:
#
#   config.active_record.default_timezone = :local
#
# == Time Zone aware attributes
#
# Active Record keeps all the <tt>datetime</tt> and <tt>time</tt> columns
# timezone aware. By default, these values are stored in the database as UTC
# and converted back to the current <tt>Time.zone</tt> when pulled from the database.
#
# This feature can be turned off completely by setting:
#
#   config.active_record.time_zone_aware_attributes = false
#
# You can also specify that only <tt>datetime</tt> columns should be time-zone
# aware (while <tt>time</tt> should not) by setting:
#
#   ActiveRecord::Base.time_zone_aware_types = [:datetime]
#
# You can also add database specific timezone aware types. For example, for PostgreSQL:
#
#   ActiveRecord::Base.time_zone_aware_types += [:tsrange, :tstzrange]
#
# Finally, you can indicate specific attributes of a model for which time zone
# conversion should not applied, for instance by setting:
#
#   class Topic < ActiveRecord::Base
#     self.skip_time_zone_conversion_for_attributes = [:written_on]
#   end
module ActiveRecord::Timestamp
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::ActiveRecord::Timestamp::ClassMethods

  private

  def _create_record; end
  def _update_record; end
  def all_timestamp_attributes_in_model; end

  # Clear attributes and changed_attributes
  def clear_timestamp_attributes; end

  def create_or_update(touch: T.unsafe(nil), **_arg1); end
  def current_time_from_proper_timezone; end
  def initialize_dup(other); end
  def max_updated_column_timestamp; end

  # @return [Boolean]
  def should_record_timestamps?; end

  def timestamp_attributes_for_create_in_model; end
  def timestamp_attributes_for_update_in_model; end

  module GeneratedClassMethods
    def record_timestamps; end
    def record_timestamps=(value); end
    def record_timestamps?; end
  end

  module GeneratedInstanceMethods
    def record_timestamps; end
    def record_timestamps=(value); end
    def record_timestamps?; end
  end
end

module ActiveRecord::Timestamp::ClassMethods
  def all_timestamp_attributes_in_model; end
  def current_time_from_proper_timezone; end
  def timestamp_attributes_for_create_in_model; end
  def timestamp_attributes_for_update_in_model; end
  def touch_attributes_with_time(*names, time: T.unsafe(nil)); end

  private

  def reload_schema_from_cache; end
  def timestamp_attributes_for_create; end
  def timestamp_attributes_for_update; end
end

# = Active Record Touch Later
module ActiveRecord::TouchLater
  def before_committed!; end
  def touch(*names, time: T.unsafe(nil)); end
  def touch_later(*names); end

  private

  def belongs_to_touch_method; end

  # @return [Boolean]
  def has_defer_touch_attrs?; end

  def surreptitiously_touch(attr_names); end
  def touch_deferred_attributes; end
end

# TransactionIsolationError will be raised under the following conditions:
#
# * The adapter does not support setting the isolation level
# * You are joining an existing open transaction
# * You are creating a nested (savepoint) transaction
#
# The mysql2 and postgresql adapters support setting the transaction isolation level.
class ActiveRecord::TransactionIsolationError < ::ActiveRecord::ActiveRecordError; end

# TransactionRollbackError will be raised when a transaction is rolled
# back by the database due to a serialization failure or a deadlock.
#
# See the following:
#
# * https://www.postgresql.org/docs/current/static/transaction-iso.html
# * https://dev.mysql.com/doc/mysql-errors/en/server-error-reference.html#error_er_lock_deadlock
class ActiveRecord::TransactionRollbackError < ::ActiveRecord::StatementInvalid; end

# See ActiveRecord::Transactions::ClassMethods for documentation.
module ActiveRecord::Transactions
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::ActiveRecord::Transactions::ClassMethods

  def before_committed!; end

  # Call the #after_commit callbacks.
  #
  # Ensure that it is not called if the object was never persisted (failed create),
  # but call it after the commit of a destroyed object.
  def committed!(should_run_callbacks: T.unsafe(nil)); end

  def destroy; end

  # Call the #after_rollback callbacks. The +force_restore_state+ argument indicates if the record
  # state should be rolled back to the beginning or just to the last savepoint.
  def rolledback!(force_restore_state: T.unsafe(nil), should_run_callbacks: T.unsafe(nil)); end

  def save(**_arg0); end
  def save!(**_arg0); end
  def touch(*_arg0, **_arg1); end

  # See ActiveRecord::Transactions::ClassMethods for detailed documentation.
  def transaction(**options, &block); end

  # @return [Boolean]
  def trigger_transactional_callbacks?; end

  # Executes +method+ within a transaction and captures its return value as a
  # status flag. If the status is true the transaction is committed, otherwise
  # a ROLLBACK is issued. In any case the status flag is returned.
  #
  # This method is available within the context of an ActiveRecord::Base
  # instance.
  def with_transaction_returning_status; end

  private

  # Returns the value of attribute _committed_already_called.
  def _committed_already_called; end

  # Returns the value of attribute _trigger_destroy_callback.
  def _trigger_destroy_callback; end

  # Returns the value of attribute _trigger_update_callback.
  def _trigger_update_callback; end

  # Add the record to the current transaction so that the #after_rollback and #after_commit
  # callbacks can be called.
  def add_to_transaction(ensure_finalize = T.unsafe(nil)); end

  # Clear the new record state and id of a record.
  def clear_transaction_record_state; end

  # Force to clear the transaction record state.
  def force_clear_transaction_record_state; end

  # @return [Boolean]
  def has_transactional_callbacks?; end

  # Save the new record state and id of a record so it can be restored later if a transaction fails.
  def remember_transaction_record_state; end

  # Restore the new record state and id of a record that was previously saved by a call to save_record_state.
  def restore_transaction_record_state(force_restore_state = T.unsafe(nil)); end

  # Determine if a transaction included an action for :create, :update, or :destroy. Used in filtering callbacks.
  #
  # @return [Boolean]
  def transaction_include_any_action?(actions); end
end

ActiveRecord::Transactions::ACTIONS = T.let(T.unsafe(nil), Array)

# = Active Record Transactions
#
# \Transactions are protective blocks where SQL statements are only permanent
# if they can all succeed as one atomic action. The classic example is a
# transfer between two accounts where you can only have a deposit if the
# withdrawal succeeded and vice versa. \Transactions enforce the integrity of
# the database and guard the data against program errors or database
# break-downs. So basically you should use transaction blocks whenever you
# have a number of statements that must be executed together or not at all.
#
# For example:
#
#   ActiveRecord::Base.transaction do
#     david.withdrawal(100)
#     mary.deposit(100)
#   end
#
# This example will only take money from David and give it to Mary if neither
# +withdrawal+ nor +deposit+ raise an exception. Exceptions will force a
# ROLLBACK that returns the database to the state before the transaction
# began. Be aware, though, that the objects will _not_ have their instance
# data returned to their pre-transactional state.
#
# == Different Active Record classes in a single transaction
#
# Though the #transaction class method is called on some Active Record class,
# the objects within the transaction block need not all be instances of
# that class. This is because transactions are per-database connection, not
# per-model.
#
# In this example a +balance+ record is transactionally saved even
# though #transaction is called on the +Account+ class:
#
#   Account.transaction do
#     balance.save!
#     account.save!
#   end
#
# The #transaction method is also available as a model instance method.
# For example, you can also do this:
#
#   balance.transaction do
#     balance.save!
#     account.save!
#   end
#
# == Transactions are not distributed across database connections
#
# A transaction acts on a single database connection. If you have
# multiple class-specific databases, the transaction will not protect
# interaction among them. One workaround is to begin a transaction
# on each class whose models you alter:
#
#   Student.transaction do
#     Course.transaction do
#       course.enroll(student)
#       student.units += course.units
#     end
#   end
#
# This is a poor solution, but fully distributed transactions are beyond
# the scope of Active Record.
#
# == +save+ and +destroy+ are automatically wrapped in a transaction
#
# Both {#save}[rdoc-ref:Persistence#save] and
# {#destroy}[rdoc-ref:Persistence#destroy] come wrapped in a transaction that ensures
# that whatever you do in validations or callbacks will happen under its
# protected cover. So you can use validations to check for values that
# the transaction depends on or you can raise exceptions in the callbacks
# to rollback, including <tt>after_*</tt> callbacks.
#
# As a consequence changes to the database are not seen outside your connection
# until the operation is complete. For example, if you try to update the index
# of a search engine in +after_save+ the indexer won't see the updated record.
# The #after_commit callback is the only one that is triggered once the update
# is committed. See below.
#
# == Exception handling and rolling back
#
# Also have in mind that exceptions thrown within a transaction block will
# be propagated (after triggering the ROLLBACK), so you should be ready to
# catch those in your application code.
#
# One exception is the ActiveRecord::Rollback exception, which will trigger
# a ROLLBACK when raised, but not be re-raised by the transaction block.
#
# *Warning*: one should not catch ActiveRecord::StatementInvalid exceptions
# inside a transaction block. ActiveRecord::StatementInvalid exceptions indicate that an
# error occurred at the database level, for example when a unique constraint
# is violated. On some database systems, such as PostgreSQL, database errors
# inside a transaction cause the entire transaction to become unusable
# until it's restarted from the beginning. Here is an example which
# demonstrates the problem:
#
#   # Suppose that we have a Number model with a unique column called 'i'.
#   Number.transaction do
#     Number.create(i: 0)
#     begin
#       # This will raise a unique constraint error...
#       Number.create(i: 0)
#     rescue ActiveRecord::StatementInvalid
#       # ...which we ignore.
#     end
#
#     # On PostgreSQL, the transaction is now unusable. The following
#     # statement will cause a PostgreSQL error, even though the unique
#     # constraint is no longer violated:
#     Number.create(i: 1)
#     # => "PG::Error: ERROR:  current transaction is aborted, commands
#     #     ignored until end of transaction block"
#   end
#
# One should restart the entire transaction if an
# ActiveRecord::StatementInvalid occurred.
#
# == Nested transactions
#
# #transaction calls can be nested. By default, this makes all database
# statements in the nested transaction block become part of the parent
# transaction. For example, the following behavior may be surprising:
#
#   User.transaction do
#     User.create(username: 'Kotori')
#     User.transaction do
#       User.create(username: 'Nemu')
#       raise ActiveRecord::Rollback
#     end
#   end
#
# creates both "Kotori" and "Nemu". Reason is the ActiveRecord::Rollback
# exception in the nested block does not issue a ROLLBACK. Since these exceptions
# are captured in transaction blocks, the parent block does not see it and the
# real transaction is committed.
#
# In order to get a ROLLBACK for the nested transaction you may ask for a real
# sub-transaction by passing <tt>requires_new: true</tt>. If anything goes wrong,
# the database rolls back to the beginning of the sub-transaction without rolling
# back the parent transaction. If we add it to the previous example:
#
#   User.transaction do
#     User.create(username: 'Kotori')
#     User.transaction(requires_new: true) do
#       User.create(username: 'Nemu')
#       raise ActiveRecord::Rollback
#     end
#   end
#
# only "Kotori" is created.
#
# Most databases don't support true nested transactions. At the time of
# writing, the only database that we're aware of that supports true nested
# transactions, is MS-SQL. Because of this, Active Record emulates nested
# transactions by using savepoints. See
# https://dev.mysql.com/doc/refman/en/savepoint.html
# for more information about savepoints.
#
# === \Callbacks
#
# There are two types of callbacks associated with committing and rolling back transactions:
# #after_commit and #after_rollback.
#
# #after_commit callbacks are called on every record saved or destroyed within a
# transaction immediately after the transaction is committed. #after_rollback callbacks
# are called on every record saved or destroyed within a transaction immediately after the
# transaction or savepoint is rolled back.
#
# These callbacks are useful for interacting with other systems since you will be guaranteed
# that the callback is only executed when the database is in a permanent state. For example,
# #after_commit is a good spot to put in a hook to clearing a cache since clearing it from
# within a transaction could trigger the cache to be regenerated before the database is updated.
#
# === Caveats
#
# If you're on MySQL, then do not use Data Definition Language (DDL) operations in nested
# transactions blocks that are emulated with savepoints. That is, do not execute statements
# like 'CREATE TABLE' inside such blocks. This is because MySQL automatically
# releases all savepoints upon executing a DDL operation. When +transaction+
# is finished and tries to release the savepoint it created earlier, a
# database error will occur because the savepoint has already been
# automatically released. The following example demonstrates the problem:
#
#   Model.connection.transaction do                           # BEGIN
#     Model.connection.transaction(requires_new: true) do     # CREATE SAVEPOINT active_record_1
#       Model.connection.create_table(...)                    # active_record_1 now automatically released
#     end                                                     # RELEASE SAVEPOINT active_record_1
#                                                             # ^^^^ BOOM! database error!
#   end
#
# Note that "TRUNCATE" is also a MySQL DDL statement!
module ActiveRecord::Transactions::ClassMethods
  # This callback is called after a record has been created, updated, or destroyed.
  #
  # You can specify that the callback should only be fired by a certain action with
  # the +:on+ option:
  #
  #   after_commit :do_foo, on: :create
  #   after_commit :do_bar, on: :update
  #   after_commit :do_baz, on: :destroy
  #
  #   after_commit :do_foo_bar, on: [:create, :update]
  #   after_commit :do_bar_baz, on: [:update, :destroy]
  def after_commit(*args, &block); end

  # Shortcut for <tt>after_commit :hook, on: :create</tt>.
  def after_create_commit(*args, &block); end

  # Shortcut for <tt>after_commit :hook, on: :destroy</tt>.
  def after_destroy_commit(*args, &block); end

  # This callback is called after a create, update, or destroy are rolled back.
  #
  # Please check the documentation of #after_commit for options.
  def after_rollback(*args, &block); end

  # Shortcut for <tt>after_commit :hook, on: [ :create, :update ]</tt>.
  def after_save_commit(*args, &block); end

  # Shortcut for <tt>after_commit :hook, on: :update</tt>.
  def after_update_commit(*args, &block); end

  def before_commit(*args, &block); end

  # See the ConnectionAdapters::DatabaseStatements#transaction API docs.
  def transaction(**options, &block); end

  private

  def assert_valid_transaction_action(actions); end
  def set_options_for_callbacks!(args, enforced_options = T.unsafe(nil)); end
end

module ActiveRecord::Translation
  include ::ActiveModel::Naming
  include ::ActiveModel::Translation

  # Set the i18n scope to overwrite ActiveModel.
  def i18n_scope; end

  # Set the lookup ancestors for ActiveModel.
  def lookup_ancestors; end
end

# :stopdoc:
module ActiveRecord::Type
  class << self
    def adapter_name_from(model); end
    def add_modifier(*_arg0, &_arg1); end
    def default_value; end
    def lookup(*args, adapter: T.unsafe(nil), **kwargs); end

    # Add a new type to the registry, allowing it to be referenced as a
    # symbol by {ActiveRecord::Base.attribute}[rdoc-ref:Attributes::ClassMethods#attribute].
    # If your type is only meant to be used with a specific database adapter, you can
    # do so by passing <tt>adapter: :postgresql</tt>. If your type has the same
    # name as a native type for the current adapter, an exception will be
    # raised unless you specify an +:override+ option. <tt>override: true</tt> will
    # cause your type to be used instead of the native type. <tt>override:
    # false</tt> will cause the native type to be used over yours if one exists.
    def register(type_name, klass = T.unsafe(nil), **options, &block); end

    def registry; end
    def registry=(_arg0); end

    private

    def current_adapter_name; end
  end
end

class ActiveRecord::Type::AdapterSpecificRegistry < ::ActiveModel::Type::Registry
  def add_modifier(options, klass, **args); end

  private

  def find_registration(symbol, *args, **kwargs); end
  def registration_klass; end
end

ActiveRecord::Type::BigInteger = ActiveModel::Type::BigInteger
ActiveRecord::Type::Binary = ActiveModel::Type::Binary
ActiveRecord::Type::Boolean = ActiveModel::Type::Boolean

class ActiveRecord::Type::Date < ::ActiveModel::Type::Date
  include ::ActiveRecord::Type::Internal::Timezone
end

class ActiveRecord::Type::DateTime < ::ActiveModel::Type::DateTime
  include ::ActiveRecord::Type::Internal::Timezone
end

ActiveRecord::Type::Decimal = ActiveModel::Type::Decimal

class ActiveRecord::Type::DecimalWithoutScale < ::ActiveModel::Type::BigInteger
  def type; end
  def type_cast_for_schema(value); end
end

class ActiveRecord::Type::DecorationRegistration < ::ActiveRecord::Type::Registration
  # @return [DecorationRegistration] a new instance of DecorationRegistration
  def initialize(options, klass, adapter: T.unsafe(nil)); end

  def call(registry, *args, **kwargs); end

  # @return [Boolean]
  def matches?(*args, **kwargs); end

  def priority; end

  private

  # Returns the value of attribute klass.
  def klass; end

  # @return [Boolean]
  def matches_options?(**kwargs); end

  # Returns the value of attribute options.
  def options; end
end

ActiveRecord::Type::Float = ActiveModel::Type::Float

class ActiveRecord::Type::HashLookupTypeMap < ::ActiveRecord::Type::TypeMap
  def alias_type(type, alias_type); end

  # @return [Boolean]
  def key?(key); end

  def keys; end

  private

  def perform_fetch(type, *args, &block); end
end

ActiveRecord::Type::ImmutableString = ActiveModel::Type::ImmutableString
ActiveRecord::Type::Integer = ActiveModel::Type::Integer
module ActiveRecord::Type::Internal; end

module ActiveRecord::Type::Internal::Timezone
  def default_timezone; end

  # @return [Boolean]
  def is_utc?; end
end

class ActiveRecord::Type::Json < ::ActiveModel::Type::Value
  include ::ActiveModel::Type::Helpers::Mutable

  def accessor; end

  # @return [Boolean]
  def changed_in_place?(raw_old_value, new_value); end

  def deserialize(value); end
  def serialize(value); end
  def type; end
end

class ActiveRecord::Type::Registration
  # @return [Registration] a new instance of Registration
  def initialize(name, block, adapter: T.unsafe(nil), override: T.unsafe(nil)); end

  def <=>(other); end
  def call(_registry, *args, adapter: T.unsafe(nil), **kwargs); end

  # @return [Boolean]
  def matches?(type_name, *args, **kwargs); end

  protected

  # Returns the value of attribute adapter.
  def adapter; end

  # Returns the value of attribute block.
  def block; end

  # Returns the value of attribute name.
  def name; end

  # Returns the value of attribute override.
  def override; end

  def priority; end
  def priority_except_adapter; end

  private

  # @return [Boolean]
  def conflicts_with?(other); end

  # @return [Boolean]
  def has_adapter_conflict?(other); end

  # @return [Boolean]
  def matches_adapter?(adapter: T.unsafe(nil), **_arg1); end

  # @return [Boolean]
  def same_priority_except_adapter?(other); end
end

class ActiveRecord::Type::Serialized
  include ::ActiveModel::Type::Helpers::Mutable

  # @return [Serialized] a new instance of Serialized
  def initialize(subtype, coder); end

  def accessor; end
  def assert_valid_value(value); end

  # @return [Boolean]
  def changed_in_place?(raw_old_value, value); end

  # Returns the value of attribute coder.
  def coder; end

  def deserialize(value); end

  # @return [Boolean]
  def force_equality?(value); end

  def inspect; end
  def serialize(value); end

  # Returns the value of attribute subtype.
  def subtype; end

  private

  # @return [Boolean]
  def default_value?(value); end

  def encoded(value); end
end

ActiveRecord::Type::String = ActiveModel::Type::String

class ActiveRecord::Type::Text < ::ActiveModel::Type::String
  def type; end
end

class ActiveRecord::Type::Time < ::ActiveModel::Type::Time
  include ::ActiveRecord::Type::Internal::Timezone

  def serialize(value); end

  private

  def cast_value(value); end
end

class ActiveRecord::Type::Time::Value; end

class ActiveRecord::Type::TypeMap
  # @return [TypeMap] a new instance of TypeMap
  def initialize; end

  def alias_type(key, target_key); end
  def clear; end
  def fetch(lookup_key, *args, &block); end
  def lookup(lookup_key, *args); end

  # @raise [::ArgumentError]
  def register_type(key, value = T.unsafe(nil), &block); end

  private

  def perform_fetch(lookup_key, *args); end
end

class ActiveRecord::Type::UnsignedInteger < ::ActiveModel::Type::Integer
  private

  def max_value; end
  def min_value; end
end

ActiveRecord::Type::Value = ActiveModel::Type::Value
module ActiveRecord::TypeCaster; end

class ActiveRecord::TypeCaster::Connection
  # @return [Connection] a new instance of Connection
  def initialize(klass, table_name); end

  def type_cast_for_database(attr_name, value); end
  def type_for_attribute(attr_name); end

  private

  def connection(*_arg0, &_arg1); end

  # Returns the value of attribute table_name.
  def table_name; end
end

class ActiveRecord::TypeCaster::Map
  # @return [Map] a new instance of Map
  def initialize(klass); end

  def type_cast_for_database(attr_name, value); end
  def type_for_attribute(name); end

  private

  # Returns the value of attribute klass.
  def klass; end
end

class ActiveRecord::TypeConflictError < ::StandardError; end

# Raised when unknown attributes are supplied via mass assignment.
ActiveRecord::UnknownAttributeError = ActiveModel::UnknownAttributeError

# UnknownAttributeReference is raised when an unknown and potentially unsafe
# value is passed to a query method. For example, passing a non column name
# value to a relation's #order method might cause this exception.
#
# When working around this exception, caution should be taken to avoid SQL
# injection vulnerabilities when passing user-provided values to query
# methods. Known-safe values can be passed to query methods by wrapping them
# in Arel.sql.
#
# For example, the following code would raise this exception:
#
#   Post.order("length(title)").first
#
# The desired result can be accomplished by wrapping the known-safe string
# in Arel.sql:
#
#   Post.order(Arel.sql("length(title)")).first
#
# Again, such a workaround should *not* be used when passing user-provided
# values, such as request parameters or model attributes to query methods.
class ActiveRecord::UnknownAttributeReference < ::ActiveRecord::ActiveRecordError; end

class ActiveRecord::UnknownMigrationVersionError < ::ActiveRecord::MigrationError
  # @return [UnknownMigrationVersionError] a new instance of UnknownMigrationVersionError
  def initialize(version = T.unsafe(nil)); end
end

# Raised when a primary key is needed, but not specified in the schema or model.
class ActiveRecord::UnknownPrimaryKey < ::ActiveRecord::ActiveRecordError
  # @return [UnknownPrimaryKey] a new instance of UnknownPrimaryKey
  def initialize(model = T.unsafe(nil), description = T.unsafe(nil)); end

  # Returns the value of attribute model.
  def model; end
end

module ActiveRecord::VERSION; end
ActiveRecord::VERSION::MAJOR = T.let(T.unsafe(nil), Integer)
ActiveRecord::VERSION::MINOR = T.let(T.unsafe(nil), Integer)
ActiveRecord::VERSION::PRE = T.let(T.unsafe(nil), String)
ActiveRecord::VERSION::STRING = T.let(T.unsafe(nil), String)
ActiveRecord::VERSION::TINY = T.let(T.unsafe(nil), Integer)

# = Active Record \Validations
#
# Active Record includes the majority of its validations from ActiveModel::Validations
# all of which accept the <tt>:on</tt> argument to define the context where the
# validations are active. Active Record will always supply either the context of
# <tt>:create</tt> or <tt>:update</tt> dependent on whether the model is a
# {new_record?}[rdoc-ref:Persistence#new_record?].
module ActiveRecord::Validations
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods
  include ::ActiveSupport::Callbacks
  include ::ActiveModel::Validations::HelperMethods
  include ::ActiveModel::Validations

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::ActiveModel::Validations::ClassMethods
  mixes_in_class_methods ::ActiveModel::Callbacks
  mixes_in_class_methods ::ActiveSupport::Callbacks::ClassMethods
  mixes_in_class_methods ::ActiveSupport::DescendantsTracker
  mixes_in_class_methods ::ActiveModel::Translation
  mixes_in_class_methods ::ActiveModel::Validations::HelperMethods
  mixes_in_class_methods ::ActiveRecord::Validations::ClassMethods

  # The validation process on save can be skipped by passing <tt>validate: false</tt>.
  # The validation context can be changed by passing <tt>context: context</tt>.
  # The regular {ActiveRecord::Base#save}[rdoc-ref:Persistence#save] method is replaced
  # with this when the validations module is mixed in, which it is by default.
  def save(**options); end

  # Attempts to save the record just like {ActiveRecord::Base#save}[rdoc-ref:Base#save] but
  # will raise an ActiveRecord::RecordInvalid exception instead of returning +false+ if the record is not valid.
  def save!(**options); end

  # Runs all the validations within the specified context. Returns +true+ if
  # no errors are found, +false+ otherwise.
  #
  # Aliased as #validate.
  #
  # If the argument is +false+ (default is +nil+), the context is set to <tt>:create</tt> if
  # {new_record?}[rdoc-ref:Persistence#new_record?] is +true+, and to <tt>:update</tt> if it is not.
  #
  # \Validations with no <tt>:on</tt> option will run no matter the context. \Validations with
  # some <tt>:on</tt> option will only run in the specified context.
  #
  # @return [Boolean]
  def valid?(context = T.unsafe(nil)); end

  # Runs all the validations within the specified context. Returns +true+ if
  # no errors are found, +false+ otherwise.
  #
  # Aliased as #validate.
  #
  # If the argument is +false+ (default is +nil+), the context is set to <tt>:create</tt> if
  # {new_record?}[rdoc-ref:Persistence#new_record?] is +true+, and to <tt>:update</tt> if it is not.
  #
  # \Validations with no <tt>:on</tt> option will run no matter the context. \Validations with
  # some <tt>:on</tt> option will only run in the specified context.
  #
  # @return [Boolean]
  def validate(context = T.unsafe(nil)); end

  private

  def default_validation_context; end
  def perform_validations(options = T.unsafe(nil)); end

  # @raise [RecordInvalid]
  def raise_validation_error; end

  module GeneratedClassMethods
    def __callbacks; end
    def __callbacks=(value); end
    def __callbacks?; end
    def _validators; end
    def _validators=(value); end
    def _validators?; end
  end

  module GeneratedInstanceMethods
    def __callbacks; end
    def __callbacks?; end
    def _validators; end
    def _validators?; end
  end
end

class ActiveRecord::Validations::AbsenceValidator < ::ActiveModel::Validations::AbsenceValidator
  def validate_each(record, attribute, association_or_value); end
end

class ActiveRecord::Validations::AssociatedValidator < ::ActiveModel::EachValidator
  def validate_each(record, attribute, value); end

  private

  # @return [Boolean]
  def valid_object?(record); end
end

module ActiveRecord::Validations::ClassMethods
  # Validates that the specified attributes are not present (as defined by
  # Object#present?). If the attribute is an association, the associated object
  # is considered absent if it was marked for destruction.
  #
  # See ActiveModel::Validations::HelperMethods.validates_absence_of for more information.
  def validates_absence_of(*attr_names); end

  # Validates whether the associated object or objects are all valid.
  # Works with any kind of association.
  #
  #   class Book < ActiveRecord::Base
  #     has_many :pages
  #     belongs_to :library
  #
  #     validates_associated :pages, :library
  #   end
  #
  # WARNING: This validation must not be used on both ends of an association.
  # Doing so will lead to a circular dependency and cause infinite recursion.
  #
  # NOTE: This validation will not fail if the association hasn't been
  # assigned. If you want to ensure that the association is both present and
  # guaranteed to be valid, you also need to use
  # {validates_presence_of}[rdoc-ref:Validations::ClassMethods#validates_presence_of].
  #
  # Configuration options:
  #
  # * <tt>:message</tt> - A custom error message (default is: "is invalid").
  # * <tt>:on</tt> - Specifies the contexts where this validation is active.
  #   Runs in all validation contexts by default +nil+. You can pass a symbol
  #   or an array of symbols. (e.g. <tt>on: :create</tt> or
  #   <tt>on: :custom_validation_context</tt> or
  #   <tt>on: [:create, :custom_validation_context]</tt>)
  # * <tt>:if</tt> - Specifies a method, proc or string to call to determine
  #   if the validation should occur (e.g. <tt>if: :allow_validation</tt>,
  #   or <tt>if: Proc.new { |user| user.signup_step > 2 }</tt>). The method,
  #   proc or string should return or evaluate to a +true+ or +false+ value.
  # * <tt>:unless</tt> - Specifies a method, proc or string to call to
  #   determine if the validation should not occur (e.g. <tt>unless: :skip_validation</tt>,
  #   or <tt>unless: Proc.new { |user| user.signup_step <= 2 }</tt>). The
  #   method, proc or string should return or evaluate to a +true+ or +false+
  #   value.
  def validates_associated(*attr_names); end

  # Validates that the specified attributes match the length restrictions supplied.
  # If the attribute is an association, records that are marked for destruction are not counted.
  #
  # See ActiveModel::Validations::HelperMethods.validates_length_of for more information.
  def validates_length_of(*attr_names); end

  # Validates whether the value of the specified attribute is numeric by
  # trying to convert it to a float with Kernel.Float (if <tt>only_integer</tt>
  # is +false+) or applying it to the regular expression <tt>/\A[\+\-]?\d+\z/</tt>
  # (if <tt>only_integer</tt> is set to +true+). Kernel.Float precision
  # defaults to the column's precision value or 15.
  #
  # See ActiveModel::Validations::HelperMethods.validates_numericality_of for more information.
  def validates_numericality_of(*attr_names); end

  # Validates that the specified attributes are not blank (as defined by
  # Object#blank?), and, if the attribute is an association, that the
  # associated object is not marked for destruction. Happens by default
  # on save.
  #
  #   class Person < ActiveRecord::Base
  #     has_one :face
  #     validates_presence_of :face
  #   end
  #
  # The face attribute must be in the object and it cannot be blank or marked
  # for destruction.
  #
  # If you want to validate the presence of a boolean field (where the real values
  # are true and false), you will want to use
  # <tt>validates_inclusion_of :field_name, in: [true, false]</tt>.
  #
  # This is due to the way Object#blank? handles boolean values:
  # <tt>false.blank? # => true</tt>.
  #
  # This validator defers to the Active Model validation for presence, adding the
  # check to see that an associated object is not marked for destruction. This
  # prevents the parent object from validating successfully and saving, which then
  # deletes the associated object, thus putting the parent object into an invalid
  # state.
  #
  # NOTE: This validation will not fail while using it with an association
  # if the latter was assigned but not valid. If you want to ensure that
  # it is both present and valid, you also need to use
  # {validates_associated}[rdoc-ref:Validations::ClassMethods#validates_associated].
  #
  # Configuration options:
  # * <tt>:message</tt> - A custom error message (default is: "can't be blank").
  # * <tt>:on</tt> - Specifies the contexts where this validation is active.
  #   Runs in all validation contexts by default +nil+. You can pass a symbol
  #   or an array of symbols. (e.g. <tt>on: :create</tt> or
  #   <tt>on: :custom_validation_context</tt> or
  #   <tt>on: [:create, :custom_validation_context]</tt>)
  # * <tt>:if</tt> - Specifies a method, proc or string to call to determine if
  #   the validation should occur (e.g. <tt>if: :allow_validation</tt>, or
  #   <tt>if: Proc.new { |user| user.signup_step > 2 }</tt>). The method, proc
  #   or string should return or evaluate to a +true+ or +false+ value.
  # * <tt>:unless</tt> - Specifies a method, proc or string to call to determine
  #   if the validation should not occur (e.g. <tt>unless: :skip_validation</tt>,
  #   or <tt>unless: Proc.new { |user| user.signup_step <= 2 }</tt>). The method,
  #   proc or string should return or evaluate to a +true+ or +false+ value.
  # * <tt>:strict</tt> - Specifies whether validation should be strict.
  #   See ActiveModel::Validations#validates! for more information.
  def validates_presence_of(*attr_names); end

  # Validates that the specified attributes match the length restrictions supplied.
  # If the attribute is an association, records that are marked for destruction are not counted.
  #
  # See ActiveModel::Validations::HelperMethods.validates_length_of for more information.
  def validates_size_of(*attr_names); end

  # Validates whether the value of the specified attributes are unique
  # across the system. Useful for making sure that only one user
  # can be named "davidhh".
  #
  #   class Person < ActiveRecord::Base
  #     validates_uniqueness_of :user_name
  #   end
  #
  # It can also validate whether the value of the specified attributes are
  # unique based on a <tt>:scope</tt> parameter:
  #
  #   class Person < ActiveRecord::Base
  #     validates_uniqueness_of :user_name, scope: :account_id
  #   end
  #
  # Or even multiple scope parameters. For example, making sure that a
  # teacher can only be on the schedule once per semester for a particular
  # class.
  #
  #   class TeacherSchedule < ActiveRecord::Base
  #     validates_uniqueness_of :teacher_id, scope: [:semester_id, :class_id]
  #   end
  #
  # It is also possible to limit the uniqueness constraint to a set of
  # records matching certain conditions. In this example archived articles
  # are not being taken into consideration when validating uniqueness
  # of the title attribute:
  #
  #   class Article < ActiveRecord::Base
  #     validates_uniqueness_of :title, conditions: -> { where.not(status: 'archived') }
  #   end
  #
  # To build conditions based on the record's state, define the conditions
  # callable with a parameter, which will be the record itself. This
  # example validates the title is unique for the year of publication:
  #
  #   class Article < ActiveRecord::Base
  #     validates_uniqueness_of :title, conditions: ->(article) {
  #       published_at = article.published_at
  #       where(published_at: published_at.beginning_of_year..published_at.end_of_year)
  #     }
  #   end
  #
  # When the record is created, a check is performed to make sure that no
  # record exists in the database with the given value for the specified
  # attribute (that maps to a column). When the record is updated,
  # the same check is made but disregarding the record itself.
  #
  # Configuration options:
  #
  # * <tt>:message</tt> - Specifies a custom error message (default is:
  #   "has already been taken").
  # * <tt>:scope</tt> - One or more columns by which to limit the scope of
  #   the uniqueness constraint.
  # * <tt>:conditions</tt> - Specify the conditions to be included as a
  #   <tt>WHERE</tt> SQL fragment to limit the uniqueness constraint lookup
  #   (e.g. <tt>conditions: -> { where(status: 'active') }</tt>).
  # * <tt>:case_sensitive</tt> - Looks for an exact match. Ignored by
  #   non-text columns (+true+ by default).
  # * <tt>:allow_nil</tt> - If set to +true+, skips this validation if the
  #   attribute is +nil+ (default is +false+).
  # * <tt>:allow_blank</tt> - If set to +true+, skips this validation if the
  #   attribute is blank (default is +false+).
  # * <tt>:if</tt> - Specifies a method, proc or string to call to determine
  #   if the validation should occur (e.g. <tt>if: :allow_validation</tt>,
  #   or <tt>if: Proc.new { |user| user.signup_step > 2 }</tt>). The method,
  #   proc or string should return or evaluate to a +true+ or +false+ value.
  # * <tt>:unless</tt> - Specifies a method, proc or string to call to
  #   determine if the validation should not occur (e.g. <tt>unless: :skip_validation</tt>,
  #   or <tt>unless: Proc.new { |user| user.signup_step <= 2 }</tt>). The
  #   method, proc or string should return or evaluate to a +true+ or +false+
  #   value.
  #
  # === Concurrency and integrity
  #
  # Using this validation method in conjunction with
  # {ActiveRecord::Base#save}[rdoc-ref:Persistence#save]
  # does not guarantee the absence of duplicate record insertions, because
  # uniqueness checks on the application level are inherently prone to race
  # conditions. For example, suppose that two users try to post a Comment at
  # the same time, and a Comment's title must be unique. At the database-level,
  # the actions performed by these users could be interleaved in the following manner:
  #
  #               User 1                 |               User 2
  #  ------------------------------------+--------------------------------------
  #  # User 1 checks whether there's     |
  #  # already a comment with the title  |
  #  # 'My Post'. This is not the case.  |
  #  SELECT * FROM comments              |
  #  WHERE title = 'My Post'             |
  #                                      |
  #                                      | # User 2 does the same thing and also
  #                                      | # infers that their title is unique.
  #                                      | SELECT * FROM comments
  #                                      | WHERE title = 'My Post'
  #                                      |
  #  # User 1 inserts their comment.     |
  #  INSERT INTO comments                |
  #  (title, content) VALUES             |
  #  ('My Post', 'hi!')                  |
  #                                      |
  #                                      | # User 2 does the same thing.
  #                                      | INSERT INTO comments
  #                                      | (title, content) VALUES
  #                                      | ('My Post', 'hello!')
  #                                      |
  #                                      | # ^^^^^^
  #                                      | # Boom! We now have a duplicate
  #                                      | # title!
  #
  # The best way to work around this problem is to add a unique index to the database table using
  # {connection.add_index}[rdoc-ref:ConnectionAdapters::SchemaStatements#add_index].
  # In the rare case that a race condition occurs, the database will guarantee
  # the field's uniqueness.
  #
  # When the database catches such a duplicate insertion,
  # {ActiveRecord::Base#save}[rdoc-ref:Persistence#save] will raise an ActiveRecord::StatementInvalid
  # exception. You can either choose to let this error propagate (which
  # will result in the default Rails exception page being shown), or you
  # can catch it and restart the transaction (e.g. by telling the user
  # that the title already exists, and asking them to re-enter the title).
  # This technique is also known as
  # {optimistic concurrency control}[https://en.wikipedia.org/wiki/Optimistic_concurrency_control].
  #
  # The bundled ActiveRecord::ConnectionAdapters distinguish unique index
  # constraint errors from other types of database errors by throwing an
  # ActiveRecord::RecordNotUnique exception. For other adapters you will
  # have to parse the (database-specific) exception message to detect such
  # a case.
  #
  # The following bundled adapters throw the ActiveRecord::RecordNotUnique exception:
  #
  # * ActiveRecord::ConnectionAdapters::Mysql2Adapter.
  # * ActiveRecord::ConnectionAdapters::SQLite3Adapter.
  # * ActiveRecord::ConnectionAdapters::PostgreSQLAdapter.
  def validates_uniqueness_of(*attr_names); end
end

class ActiveRecord::Validations::LengthValidator < ::ActiveModel::Validations::LengthValidator
  def validate_each(record, attribute, association_or_value); end
end

class ActiveRecord::Validations::NumericalityValidator < ::ActiveModel::Validations::NumericalityValidator
  def validate_each(record, attribute, value, precision: T.unsafe(nil), scale: T.unsafe(nil)); end

  private

  def column_precision_for(record, attribute); end
  def column_scale_for(record, attribute); end
end

class ActiveRecord::Validations::PresenceValidator < ::ActiveModel::Validations::PresenceValidator
  def validate_each(record, attribute, association_or_value); end
end

class ActiveRecord::Validations::UniquenessValidator < ::ActiveModel::EachValidator
  # @return [UniquenessValidator] a new instance of UniquenessValidator
  def initialize(options); end

  def validate_each(record, attribute, value); end

  private

  def build_relation(klass, attribute, value); end

  # The check for an existing value should be run from a class that
  # isn't abstract. This means working down from the current class
  # (self), to the first non-abstract class. Since classes don't know
  # their subclasses, we have to build the hierarchy between self and
  # the record's class.
  def find_finder_class_for(record); end

  def map_enum_attribute(klass, attribute, value); end
  def scope_relation(record, relation); end
end

# Raised when a record cannot be inserted or updated because a value too long for a column type.
class ActiveRecord::ValueTooLong < ::ActiveRecord::StatementInvalid; end

# Defunct wrapper class kept for compatibility.
# StatementInvalid wraps the original exception now.
class ActiveRecord::WrappedDatabaseException < ::ActiveRecord::StatementInvalid; end

module Arel
  class << self
    # @return [Boolean]
    def arel_node?(value); end

    def fetch_attribute(value, &block); end

    # Wrap a known-safe SQL string for passing to query methods, e.g.
    #
    #   Post.order(Arel.sql("length(title)")).last
    #
    # Great caution should be taken to avoid SQL injection vulnerabilities.
    # This method should not be used with unsafe values such as request
    # parameters or model attributes.
    def sql(raw_sql); end

    def star; end
  end
end

module Arel::AliasPredication
  def as(other); end
end

class Arel::ArelError < ::StandardError; end
Arel::Attribute = Arel::Attributes::Attribute
module Arel::Attributes; end

class Arel::Attributes::Attribute < ::Struct
  include ::Arel::Expressions
  include ::Arel::Predications
  include ::Arel::AliasPredication
  include ::Arel::OrderPredications
  include ::Arel::Math

  # @return [Boolean]
  def able_to_type_cast?; end

  # Create a node for lowering this attribute
  def lower; end

  def type_cast_for_database(value); end
  def type_caster; end
end

class Arel::Attributes::Boolean < ::Arel::Attributes::Attribute; end
class Arel::Attributes::Decimal < ::Arel::Attributes::Attribute; end
class Arel::Attributes::Float < ::Arel::Attributes::Attribute; end
class Arel::Attributes::Integer < ::Arel::Attributes::Attribute; end
class Arel::Attributes::String < ::Arel::Attributes::Attribute; end
class Arel::Attributes::Time < ::Arel::Attributes::Attribute; end
class Arel::Attributes::Undefined < ::Arel::Attributes::Attribute; end
module Arel::Collectors; end

class Arel::Collectors::Bind
  # @return [Bind] a new instance of Bind
  def initialize; end

  def <<(str); end
  def add_bind(bind); end
  def add_binds(binds, proc_for_binds = T.unsafe(nil)); end
  def value; end
end

class Arel::Collectors::Composite
  # @return [Composite] a new instance of Composite
  def initialize(left, right); end

  def <<(str); end
  def add_bind(bind, &block); end
  def add_binds(binds, proc_for_binds = T.unsafe(nil), &block); end

  # Returns the value of attribute preparable.
  def preparable; end

  # Sets the attribute preparable
  #
  # @param value the value to set the attribute preparable to.
  def preparable=(_arg0); end

  def value; end

  private

  # Returns the value of attribute left.
  def left; end

  # Returns the value of attribute right.
  def right; end
end

class Arel::Collectors::PlainString
  # @return [PlainString] a new instance of PlainString
  def initialize; end

  def <<(str); end
  def value; end
end

class Arel::Collectors::SQLString < ::Arel::Collectors::PlainString
  # @return [SQLString] a new instance of SQLString
  def initialize(*_arg0); end

  def add_bind(bind); end
  def add_binds(binds, proc_for_binds = T.unsafe(nil), &block); end

  # Returns the value of attribute preparable.
  def preparable; end

  # Sets the attribute preparable
  #
  # @param value the value to set the attribute preparable to.
  def preparable=(_arg0); end
end

class Arel::Collectors::SubstituteBinds
  # @return [SubstituteBinds] a new instance of SubstituteBinds
  def initialize(quoter, delegate_collector); end

  def <<(str); end
  def add_bind(bind); end
  def add_binds(binds, proc_for_binds = T.unsafe(nil)); end

  # Returns the value of attribute preparable.
  def preparable; end

  # Sets the attribute preparable
  #
  # @param value the value to set the attribute preparable to.
  def preparable=(_arg0); end

  def value; end

  private

  # Returns the value of attribute delegate.
  def delegate; end

  # Returns the value of attribute quoter.
  def quoter; end
end

# FIXME hopefully we can remove this
module Arel::Crud
  def compile_delete; end
  def compile_insert(values); end
  def compile_update(values, pk); end
  def create_insert; end
end

class Arel::DeleteManager < ::Arel::TreeManager
  include ::Arel::TreeManager::StatementMethods

  # @return [DeleteManager] a new instance of DeleteManager
  def initialize; end

  def from(relation); end
end

class Arel::EmptyJoinError < ::Arel::ArelError; end

module Arel::Expressions
  def average; end
  def count(distinct = T.unsafe(nil)); end
  def extract(field); end
  def maximum; end
  def minimum; end
  def sum; end
end

# Methods for creating various nodes
module Arel::FactoryMethods
  def coalesce(*exprs); end
  def create_and(clauses); end
  def create_false; end
  def create_join(to, constraint = T.unsafe(nil), klass = T.unsafe(nil)); end
  def create_on(expr); end
  def create_string_join(to); end
  def create_table_alias(relation, name); end
  def create_true; end
  def grouping(expr); end

  # Create a LOWER() function
  def lower(column); end
end

class Arel::InsertManager < ::Arel::TreeManager
  # @return [InsertManager] a new instance of InsertManager
  def initialize; end

  def columns; end
  def create_values(values); end
  def create_values_list(rows); end
  def insert(fields); end
  def into(table); end
  def select(select); end
  def values=(val); end
end

module Arel::Math
  def &(other); end
  def *(other); end
  def +(other); end
  def -(other); end
  def /(other); end
  def <<(other); end
  def >>(other); end
  def ^(other); end
  def |(other); end
  def ~; end
end

module Arel::Nodes
  class << self
    def build_quoted(other, attribute = T.unsafe(nil)); end
  end
end

class Arel::Nodes::Addition < ::Arel::Nodes::InfixOperation
  # @return [Addition] a new instance of Addition
  def initialize(left, right); end
end

class Arel::Nodes::And < ::Arel::Nodes::NodeExpression
  # @return [And] a new instance of And
  def initialize(children); end

  # @return [Boolean]
  def ==(other); end

  # Returns the value of attribute children.
  def children; end

  # @return [Boolean]
  def eql?(other); end

  def hash; end
  def left; end
  def right; end
end

class Arel::Nodes::As < ::Arel::Nodes::Binary; end

class Arel::Nodes::Ascending < ::Arel::Nodes::Ordering
  # @return [Boolean]
  def ascending?; end

  # @return [Boolean]
  def descending?; end

  def direction; end
  def reverse; end
end

class Arel::Nodes::Assignment < ::Arel::Nodes::Binary; end
class Arel::Nodes::Avg < ::Arel::Nodes::Function; end

class Arel::Nodes::Between < ::Arel::Nodes::Binary
  include ::Arel::Nodes::FetchAttribute
end

class Arel::Nodes::Bin < ::Arel::Nodes::Unary; end

class Arel::Nodes::Binary < ::Arel::Nodes::NodeExpression
  # @return [Binary] a new instance of Binary
  def initialize(left, right); end

  # @return [Boolean]
  def ==(other); end

  # @return [Boolean]
  def eql?(other); end

  def hash; end

  # Returns the value of attribute left.
  def left; end

  # Sets the attribute left
  #
  # @param value the value to set the attribute left to.
  def left=(_arg0); end

  # Returns the value of attribute right.
  def right; end

  # Sets the attribute right
  #
  # @param value the value to set the attribute right to.
  def right=(_arg0); end

  private

  def initialize_copy(other); end
end

class Arel::Nodes::BindParam < ::Arel::Nodes::Node
  # @return [BindParam] a new instance of BindParam
  def initialize(value); end

  # @return [Boolean]
  def ==(other); end

  # @return [Boolean]
  def eql?(other); end

  def hash; end

  # @return [Boolean]
  def infinite?; end

  # @return [Boolean]
  def nil?; end

  # @return [Boolean]
  def unboundable?; end

  # Returns the value of attribute value.
  def value; end

  def value_before_type_cast; end
end

class Arel::Nodes::BitwiseAnd < ::Arel::Nodes::InfixOperation
  # @return [BitwiseAnd] a new instance of BitwiseAnd
  def initialize(left, right); end
end

class Arel::Nodes::BitwiseNot < ::Arel::Nodes::UnaryOperation
  # @return [BitwiseNot] a new instance of BitwiseNot
  def initialize(operand); end
end

class Arel::Nodes::BitwiseOr < ::Arel::Nodes::InfixOperation
  # @return [BitwiseOr] a new instance of BitwiseOr
  def initialize(left, right); end
end

class Arel::Nodes::BitwiseShiftLeft < ::Arel::Nodes::InfixOperation
  # @return [BitwiseShiftLeft] a new instance of BitwiseShiftLeft
  def initialize(left, right); end
end

class Arel::Nodes::BitwiseShiftRight < ::Arel::Nodes::InfixOperation
  # @return [BitwiseShiftRight] a new instance of BitwiseShiftRight
  def initialize(left, right); end
end

class Arel::Nodes::BitwiseXor < ::Arel::Nodes::InfixOperation
  # @return [BitwiseXor] a new instance of BitwiseXor
  def initialize(left, right); end
end

class Arel::Nodes::Case < ::Arel::Nodes::NodeExpression
  # @return [Case] a new instance of Case
  def initialize(expression = T.unsafe(nil), default = T.unsafe(nil)); end

  # @return [Boolean]
  def ==(other); end

  # Returns the value of attribute case.
  def case; end

  # Sets the attribute case
  #
  # @param value the value to set the attribute case to.
  def case=(_arg0); end

  # Returns the value of attribute conditions.
  def conditions; end

  # Sets the attribute conditions
  #
  # @param value the value to set the attribute conditions to.
  def conditions=(_arg0); end

  # Returns the value of attribute default.
  def default; end

  # Sets the attribute default
  #
  # @param value the value to set the attribute default to.
  def default=(_arg0); end

  def else(expression); end

  # @return [Boolean]
  def eql?(other); end

  def hash; end
  def then(expression); end
  def when(condition, expression = T.unsafe(nil)); end

  private

  def initialize_copy(other); end
end

class Arel::Nodes::Casted < ::Arel::Nodes::NodeExpression
  # @return [Casted] a new instance of Casted
  def initialize(value, attribute); end

  # @return [Boolean]
  def ==(other); end

  # Returns the value of attribute attribute.
  def attribute; end

  # @return [Boolean]
  def eql?(other); end

  def hash; end

  # @return [Boolean]
  def nil?; end

  # Returns the value of attribute value.
  def value; end

  # Returns the value of attribute value.
  def value_before_type_cast; end

  def value_for_database; end
end

class Arel::Nodes::Comment < ::Arel::Nodes::Node
  # @return [Comment] a new instance of Comment
  def initialize(values); end

  # @return [Boolean]
  def ==(other); end

  # @return [Boolean]
  def eql?(other); end

  def hash; end

  # Returns the value of attribute values.
  def values; end

  private

  def initialize_copy(other); end
end

class Arel::Nodes::Concat < ::Arel::Nodes::InfixOperation
  # @return [Concat] a new instance of Concat
  def initialize(left, right); end
end

class Arel::Nodes::Contains < ::Arel::Nodes::InfixOperation
  # @return [Contains] a new instance of Contains
  def initialize(left, right); end
end

class Arel::Nodes::Count < ::Arel::Nodes::Function
  # @return [Count] a new instance of Count
  def initialize(expr, distinct = T.unsafe(nil), aliaz = T.unsafe(nil)); end
end

class Arel::Nodes::Cube < ::Arel::Nodes::Unary; end

class Arel::Nodes::CurrentRow < ::Arel::Nodes::Node
  # @return [Boolean]
  def ==(other); end

  # @return [Boolean]
  def eql?(other); end

  def hash; end
end

class Arel::Nodes::DeleteStatement < ::Arel::Nodes::Node
  # @return [DeleteStatement] a new instance of DeleteStatement
  def initialize(relation = T.unsafe(nil), wheres = T.unsafe(nil)); end

  # @return [Boolean]
  def ==(other); end

  # @return [Boolean]
  def eql?(other); end

  def hash; end

  # Returns the value of attribute key.
  def key; end

  # Sets the attribute key
  #
  # @param value the value to set the attribute key to.
  def key=(_arg0); end

  # Returns the value of attribute left.
  def left; end

  # Sets the attribute left
  #
  # @param value the value to set the attribute left to.
  def left=(_arg0); end

  # Returns the value of attribute limit.
  def limit; end

  # Sets the attribute limit
  #
  # @param value the value to set the attribute limit to.
  def limit=(_arg0); end

  # Returns the value of attribute offset.
  def offset; end

  # Sets the attribute offset
  #
  # @param value the value to set the attribute offset to.
  def offset=(_arg0); end

  # Returns the value of attribute orders.
  def orders; end

  # Sets the attribute orders
  #
  # @param value the value to set the attribute orders to.
  def orders=(_arg0); end

  # Returns the value of attribute left.
  def relation; end

  # Sets the attribute left
  #
  # @param value the value to set the attribute left to.
  def relation=(_arg0); end

  # Returns the value of attribute right.
  def right; end

  # Sets the attribute right
  #
  # @param value the value to set the attribute right to.
  def right=(_arg0); end

  # Returns the value of attribute right.
  def wheres; end

  # Sets the attribute right
  #
  # @param value the value to set the attribute right to.
  def wheres=(_arg0); end

  private

  def initialize_copy(other); end
end

class Arel::Nodes::Descending < ::Arel::Nodes::Ordering
  # @return [Boolean]
  def ascending?; end

  # @return [Boolean]
  def descending?; end

  def direction; end
  def reverse; end
end

class Arel::Nodes::Distinct < ::Arel::Nodes::NodeExpression
  # @return [Boolean]
  def ==(other); end

  # @return [Boolean]
  def eql?(other); end

  def hash; end
end

class Arel::Nodes::DistinctOn < ::Arel::Nodes::Unary; end

class Arel::Nodes::Division < ::Arel::Nodes::InfixOperation
  # @return [Division] a new instance of Division
  def initialize(left, right); end
end

class Arel::Nodes::DoesNotMatch < ::Arel::Nodes::Matches; end
class Arel::Nodes::Else < ::Arel::Nodes::Unary; end

class Arel::Nodes::Equality < ::Arel::Nodes::Binary
  include ::Arel::Nodes::FetchAttribute

  # @return [Boolean]
  def equality?; end

  def invert; end
end

class Arel::Nodes::Except < ::Arel::Nodes::Binary; end
class Arel::Nodes::Exists < ::Arel::Nodes::Function; end

class Arel::Nodes::Extract < ::Arel::Nodes::Unary
  # @return [Extract] a new instance of Extract
  def initialize(expr, field); end

  # @return [Boolean]
  def ==(other); end

  # @return [Boolean]
  def eql?(other); end

  # Returns the value of attribute field.
  def field; end

  # Sets the attribute field
  #
  # @param value the value to set the attribute field to.
  def field=(_arg0); end

  def hash; end
end

class Arel::Nodes::False < ::Arel::Nodes::NodeExpression
  # @return [Boolean]
  def ==(other); end

  # @return [Boolean]
  def eql?(other); end

  def hash; end
end

module Arel::Nodes::FetchAttribute
  def fetch_attribute; end
end

class Arel::Nodes::Following < ::Arel::Nodes::Unary
  # @return [Following] a new instance of Following
  def initialize(expr = T.unsafe(nil)); end
end

class Arel::Nodes::FullOuterJoin < ::Arel::Nodes::Join; end

class Arel::Nodes::Function < ::Arel::Nodes::NodeExpression
  include ::Arel::WindowPredications

  # @return [Function] a new instance of Function
  def initialize(expr, aliaz = T.unsafe(nil)); end

  # @return [Boolean]
  def ==(other); end

  # Returns the value of attribute alias.
  def alias; end

  # Sets the attribute alias
  #
  # @param value the value to set the attribute alias to.
  def alias=(_arg0); end

  def as(aliaz); end

  # Returns the value of attribute distinct.
  def distinct; end

  # Sets the attribute distinct
  #
  # @param value the value to set the attribute distinct to.
  def distinct=(_arg0); end

  # @return [Boolean]
  def eql?(other); end

  # Returns the value of attribute expressions.
  def expressions; end

  # Sets the attribute expressions
  #
  # @param value the value to set the attribute expressions to.
  def expressions=(_arg0); end

  def hash; end
end

class Arel::Nodes::GreaterThan < ::Arel::Nodes::Binary
  include ::Arel::Nodes::FetchAttribute

  def invert; end
end

class Arel::Nodes::GreaterThanOrEqual < ::Arel::Nodes::Binary
  include ::Arel::Nodes::FetchAttribute

  def invert; end
end

class Arel::Nodes::Group < ::Arel::Nodes::Unary; end

class Arel::Nodes::Grouping < ::Arel::Nodes::Unary
  def fetch_attribute(&block); end
end

class Arel::Nodes::GroupingElement < ::Arel::Nodes::Unary; end
class Arel::Nodes::GroupingSet < ::Arel::Nodes::Unary; end

class Arel::Nodes::HomogeneousIn < ::Arel::Nodes::Node
  # @return [HomogeneousIn] a new instance of HomogeneousIn
  def initialize(values, attribute, type); end

  # @return [Boolean]
  def ==(other); end

  # Returns the value of attribute attribute.
  def attribute; end

  def casted_values; end
  def column_name; end

  # @return [Boolean]
  def eql?(other); end

  # @return [Boolean]
  def equality?; end

  def fetch_attribute(&block); end
  def hash; end
  def invert; end
  def left; end
  def proc_for_binds; end
  def right; end
  def table_name; end

  # Returns the value of attribute type.
  def type; end

  # Returns the value of attribute values.
  def values; end

  protected

  def ivars; end
end

class Arel::Nodes::In < ::Arel::Nodes::Binary
  include ::Arel::Nodes::FetchAttribute

  # @return [Boolean]
  def equality?; end

  def invert; end
end

class Arel::Nodes::InfixOperation < ::Arel::Nodes::Binary
  # @return [InfixOperation] a new instance of InfixOperation
  def initialize(operator, left, right); end

  # Returns the value of attribute operator.
  def operator; end
end

class Arel::Nodes::InnerJoin < ::Arel::Nodes::Join; end

class Arel::Nodes::InsertStatement < ::Arel::Nodes::Node
  # @return [InsertStatement] a new instance of InsertStatement
  def initialize; end

  # @return [Boolean]
  def ==(other); end

  # Returns the value of attribute columns.
  def columns; end

  # Sets the attribute columns
  #
  # @param value the value to set the attribute columns to.
  def columns=(_arg0); end

  # @return [Boolean]
  def eql?(other); end

  def hash; end

  # Returns the value of attribute relation.
  def relation; end

  # Sets the attribute relation
  #
  # @param value the value to set the attribute relation to.
  def relation=(_arg0); end

  # Returns the value of attribute select.
  def select; end

  # Sets the attribute select
  #
  # @param value the value to set the attribute select to.
  def select=(_arg0); end

  # Returns the value of attribute values.
  def values; end

  # Sets the attribute values
  #
  # @param value the value to set the attribute values to.
  def values=(_arg0); end

  private

  def initialize_copy(other); end
end

class Arel::Nodes::Intersect < ::Arel::Nodes::Binary; end

class Arel::Nodes::IsDistinctFrom < ::Arel::Nodes::Binary
  include ::Arel::Nodes::FetchAttribute

  def invert; end
end

class Arel::Nodes::IsNotDistinctFrom < ::Arel::Nodes::Binary
  include ::Arel::Nodes::FetchAttribute

  def invert; end
end

class Arel::Nodes::Join < ::Arel::Nodes::Binary; end

# Class that represents a join source
#
#   https://www.sqlite.org/syntaxdiagrams.html#join-source
class Arel::Nodes::JoinSource < ::Arel::Nodes::Binary
  # @return [JoinSource] a new instance of JoinSource
  def initialize(single_source, joinop = T.unsafe(nil)); end

  # @return [Boolean]
  def empty?; end
end

class Arel::Nodes::Lateral < ::Arel::Nodes::Unary; end
class Arel::Nodes::LeadingJoin < ::Arel::Nodes::InnerJoin; end

class Arel::Nodes::LessThan < ::Arel::Nodes::Binary
  include ::Arel::Nodes::FetchAttribute

  def invert; end
end

class Arel::Nodes::LessThanOrEqual < ::Arel::Nodes::Binary
  include ::Arel::Nodes::FetchAttribute

  def invert; end
end

class Arel::Nodes::Limit < ::Arel::Nodes::Unary; end
class Arel::Nodes::Lock < ::Arel::Nodes::Unary; end

class Arel::Nodes::Matches < ::Arel::Nodes::Binary
  # @return [Matches] a new instance of Matches
  def initialize(left, right, escape = T.unsafe(nil), case_sensitive = T.unsafe(nil)); end

  # Returns the value of attribute case_sensitive.
  def case_sensitive; end

  # Sets the attribute case_sensitive
  #
  # @param value the value to set the attribute case_sensitive to.
  def case_sensitive=(_arg0); end

  # Returns the value of attribute escape.
  def escape; end
end

class Arel::Nodes::Max < ::Arel::Nodes::Function; end
class Arel::Nodes::Min < ::Arel::Nodes::Function; end

class Arel::Nodes::Multiplication < ::Arel::Nodes::InfixOperation
  # @return [Multiplication] a new instance of Multiplication
  def initialize(left, right); end
end

class Arel::Nodes::NamedFunction < ::Arel::Nodes::Function
  # @return [NamedFunction] a new instance of NamedFunction
  def initialize(name, expr, aliaz = T.unsafe(nil)); end

  # @return [Boolean]
  def ==(other); end

  # @return [Boolean]
  def eql?(other); end

  def hash; end

  # Returns the value of attribute name.
  def name; end

  # Sets the attribute name
  #
  # @param value the value to set the attribute name to.
  def name=(_arg0); end
end

class Arel::Nodes::NamedWindow < ::Arel::Nodes::Window
  # @return [NamedWindow] a new instance of NamedWindow
  def initialize(name); end

  # @return [Boolean]
  def ==(other); end

  # @return [Boolean]
  def eql?(other); end

  def hash; end

  # Returns the value of attribute name.
  def name; end

  # Sets the attribute name
  #
  # @param value the value to set the attribute name to.
  def name=(_arg0); end

  private

  def initialize_copy(other); end
end

# Abstract base class for all AST nodes
class Arel::Nodes::Node
  include ::Arel::FactoryMethods

  # Factory method to create an Nodes::And node.
  def and(right); end

  # @return [Boolean]
  def equality?; end

  def fetch_attribute; end
  def invert; end

  # Factory method to create a Nodes::Not node that has the recipient of
  # the caller as a child.
  def not; end

  # Factory method to create a Nodes::Grouping node that has an Nodes::Or
  # node as a child.
  def or(right); end

  # FIXME: this method should go away.  I don't like people calling
  # to_sql on non-head nodes.  This forces us to walk the AST until we
  # can find a node that has a "relation" member.
  #
  # Maybe we should just use `Table.engine`?  :'(
  def to_sql(engine = T.unsafe(nil)); end
end

class Arel::Nodes::NodeExpression < ::Arel::Nodes::Node
  include ::Arel::Expressions
  include ::Arel::Predications
  include ::Arel::AliasPredication
  include ::Arel::OrderPredications
  include ::Arel::Math
end

class Arel::Nodes::Not < ::Arel::Nodes::Unary; end

class Arel::Nodes::NotEqual < ::Arel::Nodes::Binary
  include ::Arel::Nodes::FetchAttribute

  def invert; end
end

class Arel::Nodes::NotIn < ::Arel::Nodes::Binary
  include ::Arel::Nodes::FetchAttribute

  def invert; end
end

class Arel::Nodes::NotRegexp < ::Arel::Nodes::Regexp; end

class Arel::Nodes::NullsFirst < ::Arel::Nodes::Ordering
  def reverse; end
end

class Arel::Nodes::NullsLast < ::Arel::Nodes::Ordering
  def reverse; end
end

class Arel::Nodes::Offset < ::Arel::Nodes::Unary; end
class Arel::Nodes::On < ::Arel::Nodes::Unary; end
class Arel::Nodes::OptimizerHints < ::Arel::Nodes::Unary; end

class Arel::Nodes::Or < ::Arel::Nodes::Binary
  def fetch_attribute(&block); end
end

class Arel::Nodes::Ordering < ::Arel::Nodes::Unary
  def nulls_first; end
  def nulls_last; end
end

class Arel::Nodes::OuterJoin < ::Arel::Nodes::Join; end

class Arel::Nodes::Over < ::Arel::Nodes::Binary
  # @return [Over] a new instance of Over
  def initialize(left, right = T.unsafe(nil)); end

  def operator; end
end

class Arel::Nodes::Overlaps < ::Arel::Nodes::InfixOperation
  # @return [Overlaps] a new instance of Overlaps
  def initialize(left, right); end
end

class Arel::Nodes::Preceding < ::Arel::Nodes::Unary
  # @return [Preceding] a new instance of Preceding
  def initialize(expr = T.unsafe(nil)); end
end

class Arel::Nodes::Quoted < ::Arel::Nodes::Unary
  # @return [Boolean]
  def infinite?; end

  # @return [Boolean]
  def nil?; end

  def value_before_type_cast; end
  def value_for_database; end
end

class Arel::Nodes::Range < ::Arel::Nodes::Unary
  # @return [Range] a new instance of Range
  def initialize(expr = T.unsafe(nil)); end
end

class Arel::Nodes::Regexp < ::Arel::Nodes::Binary
  # @return [Regexp] a new instance of Regexp
  def initialize(left, right, case_sensitive = T.unsafe(nil)); end

  # Returns the value of attribute case_sensitive.
  def case_sensitive; end

  # Sets the attribute case_sensitive
  #
  # @param value the value to set the attribute case_sensitive to.
  def case_sensitive=(_arg0); end
end

class Arel::Nodes::RightOuterJoin < ::Arel::Nodes::Join; end
class Arel::Nodes::RollUp < ::Arel::Nodes::Unary; end

class Arel::Nodes::Rows < ::Arel::Nodes::Unary
  # @return [Rows] a new instance of Rows
  def initialize(expr = T.unsafe(nil)); end
end

class Arel::Nodes::SelectCore < ::Arel::Nodes::Node
  # @return [SelectCore] a new instance of SelectCore
  def initialize; end

  # @return [Boolean]
  def ==(other); end

  # Returns the value of attribute comment.
  def comment; end

  # Sets the attribute comment
  #
  # @param value the value to set the attribute comment to.
  def comment=(_arg0); end

  # @return [Boolean]
  def eql?(other); end

  def from; end
  def from=(value); end
  def froms; end
  def froms=(value); end

  # Returns the value of attribute groups.
  def groups; end

  # Sets the attribute groups
  #
  # @param value the value to set the attribute groups to.
  def groups=(_arg0); end

  def hash; end

  # Returns the value of attribute havings.
  def havings; end

  # Sets the attribute havings
  #
  # @param value the value to set the attribute havings to.
  def havings=(_arg0); end

  # Returns the value of attribute optimizer_hints.
  def optimizer_hints; end

  # Sets the attribute optimizer_hints
  #
  # @param value the value to set the attribute optimizer_hints to.
  def optimizer_hints=(_arg0); end

  # Returns the value of attribute projections.
  def projections; end

  # Sets the attribute projections
  #
  # @param value the value to set the attribute projections to.
  def projections=(_arg0); end

  # Returns the value of attribute set_quantifier.
  def set_quantifier; end

  # Sets the attribute set_quantifier
  #
  # @param value the value to set the attribute set_quantifier to.
  def set_quantifier=(_arg0); end

  # Returns the value of attribute source.
  def source; end

  # Sets the attribute source
  #
  # @param value the value to set the attribute source to.
  def source=(_arg0); end

  # Returns the value of attribute wheres.
  def wheres; end

  # Sets the attribute wheres
  #
  # @param value the value to set the attribute wheres to.
  def wheres=(_arg0); end

  # Returns the value of attribute windows.
  def windows; end

  # Sets the attribute windows
  #
  # @param value the value to set the attribute windows to.
  def windows=(_arg0); end

  private

  def initialize_copy(other); end
end

class Arel::Nodes::SelectStatement < ::Arel::Nodes::NodeExpression
  # @return [SelectStatement] a new instance of SelectStatement
  def initialize(cores = T.unsafe(nil)); end

  # @return [Boolean]
  def ==(other); end

  # Returns the value of attribute cores.
  def cores; end

  # @return [Boolean]
  def eql?(other); end

  def hash; end

  # Returns the value of attribute limit.
  def limit; end

  # Sets the attribute limit
  #
  # @param value the value to set the attribute limit to.
  def limit=(_arg0); end

  # Returns the value of attribute lock.
  def lock; end

  # Sets the attribute lock
  #
  # @param value the value to set the attribute lock to.
  def lock=(_arg0); end

  # Returns the value of attribute offset.
  def offset; end

  # Sets the attribute offset
  #
  # @param value the value to set the attribute offset to.
  def offset=(_arg0); end

  # Returns the value of attribute orders.
  def orders; end

  # Sets the attribute orders
  #
  # @param value the value to set the attribute orders to.
  def orders=(_arg0); end

  # Returns the value of attribute with.
  def with; end

  # Sets the attribute with
  #
  # @param value the value to set the attribute with to.
  def with=(_arg0); end

  private

  def initialize_copy(other); end
end

class Arel::Nodes::SqlLiteral < ::String
  include ::Arel::Expressions
  include ::Arel::Predications
  include ::Arel::AliasPredication
  include ::Arel::OrderPredications

  def encode_with(coder); end
  def fetch_attribute; end
end

class Arel::Nodes::StringJoin < ::Arel::Nodes::Join
  # @return [StringJoin] a new instance of StringJoin
  def initialize(left, right = T.unsafe(nil)); end
end

class Arel::Nodes::Subtraction < ::Arel::Nodes::InfixOperation
  # @return [Subtraction] a new instance of Subtraction
  def initialize(left, right); end
end

class Arel::Nodes::Sum < ::Arel::Nodes::Function; end

class Arel::Nodes::TableAlias < ::Arel::Nodes::Binary
  def [](name); end

  # @return [Boolean]
  def able_to_type_cast?; end

  def name; end
  def relation; end
  def table_alias; end
  def table_name; end
  def type_cast_for_database(attr_name, value); end
  def type_for_attribute(name); end
end

class Arel::Nodes::True < ::Arel::Nodes::NodeExpression
  # @return [Boolean]
  def ==(other); end

  # @return [Boolean]
  def eql?(other); end

  def hash; end
end

class Arel::Nodes::Unary < ::Arel::Nodes::NodeExpression
  # @return [Unary] a new instance of Unary
  def initialize(expr); end

  # @return [Boolean]
  def ==(other); end

  # @return [Boolean]
  def eql?(other); end

  # Returns the value of attribute expr.
  def expr; end

  # Sets the attribute expr
  #
  # @param value the value to set the attribute expr to.
  def expr=(_arg0); end

  def hash; end

  # Returns the value of attribute expr.
  def value; end
end

class Arel::Nodes::UnaryOperation < ::Arel::Nodes::Unary
  # @return [UnaryOperation] a new instance of UnaryOperation
  def initialize(operator, operand); end

  # Returns the value of attribute operator.
  def operator; end
end

class Arel::Nodes::Union < ::Arel::Nodes::Binary; end
class Arel::Nodes::UnionAll < ::Arel::Nodes::Binary; end

class Arel::Nodes::UnqualifiedColumn < ::Arel::Nodes::Unary
  def attribute; end
  def attribute=(_arg0); end
  def column; end
  def name; end
  def relation; end
end

class Arel::Nodes::UpdateStatement < ::Arel::Nodes::Node
  # @return [UpdateStatement] a new instance of UpdateStatement
  def initialize; end

  # @return [Boolean]
  def ==(other); end

  # @return [Boolean]
  def eql?(other); end

  def hash; end

  # Returns the value of attribute key.
  def key; end

  # Sets the attribute key
  #
  # @param value the value to set the attribute key to.
  def key=(_arg0); end

  # Returns the value of attribute limit.
  def limit; end

  # Sets the attribute limit
  #
  # @param value the value to set the attribute limit to.
  def limit=(_arg0); end

  # Returns the value of attribute offset.
  def offset; end

  # Sets the attribute offset
  #
  # @param value the value to set the attribute offset to.
  def offset=(_arg0); end

  # Returns the value of attribute orders.
  def orders; end

  # Sets the attribute orders
  #
  # @param value the value to set the attribute orders to.
  def orders=(_arg0); end

  # Returns the value of attribute relation.
  def relation; end

  # Sets the attribute relation
  #
  # @param value the value to set the attribute relation to.
  def relation=(_arg0); end

  # Returns the value of attribute values.
  def values; end

  # Sets the attribute values
  #
  # @param value the value to set the attribute values to.
  def values=(_arg0); end

  # Returns the value of attribute wheres.
  def wheres; end

  # Sets the attribute wheres
  #
  # @param value the value to set the attribute wheres to.
  def wheres=(_arg0); end

  private

  def initialize_copy(other); end
end

class Arel::Nodes::ValuesList < ::Arel::Nodes::Unary
  def rows; end
end

class Arel::Nodes::When < ::Arel::Nodes::Binary; end

class Arel::Nodes::Window < ::Arel::Nodes::Node
  # @return [Window] a new instance of Window
  def initialize; end

  # @return [Boolean]
  def ==(other); end

  # @return [Boolean]
  def eql?(other); end

  def frame(expr); end

  # Returns the value of attribute framing.
  def framing; end

  # Sets the attribute framing
  #
  # @param value the value to set the attribute framing to.
  def framing=(_arg0); end

  def hash; end
  def order(*expr); end

  # Returns the value of attribute orders.
  def orders; end

  # Sets the attribute orders
  #
  # @param value the value to set the attribute orders to.
  def orders=(_arg0); end

  def partition(*expr); end

  # Returns the value of attribute partitions.
  def partitions; end

  # Sets the attribute partitions
  #
  # @param value the value to set the attribute partitions to.
  def partitions=(_arg0); end

  def range(expr = T.unsafe(nil)); end
  def rows(expr = T.unsafe(nil)); end

  private

  def initialize_copy(other); end
end

class Arel::Nodes::With < ::Arel::Nodes::Unary
  def children; end
end

class Arel::Nodes::WithRecursive < ::Arel::Nodes::With; end

module Arel::OrderPredications
  def asc; end
  def desc; end
end

module Arel::Predications
  def between(other); end
  def concat(other); end
  def contains(other); end
  def does_not_match(other, escape = T.unsafe(nil), case_sensitive = T.unsafe(nil)); end
  def does_not_match_all(others, escape = T.unsafe(nil)); end
  def does_not_match_any(others, escape = T.unsafe(nil)); end
  def does_not_match_regexp(other, case_sensitive = T.unsafe(nil)); end
  def eq(other); end
  def eq_all(others); end
  def eq_any(others); end
  def gt(right); end
  def gt_all(others); end
  def gt_any(others); end
  def gteq(right); end
  def gteq_all(others); end
  def gteq_any(others); end
  def in(other); end
  def in_all(others); end
  def in_any(others); end
  def is_distinct_from(other); end
  def is_not_distinct_from(other); end
  def lt(right); end
  def lt_all(others); end
  def lt_any(others); end
  def lteq(right); end
  def lteq_all(others); end
  def lteq_any(others); end
  def matches(other, escape = T.unsafe(nil), case_sensitive = T.unsafe(nil)); end
  def matches_all(others, escape = T.unsafe(nil), case_sensitive = T.unsafe(nil)); end
  def matches_any(others, escape = T.unsafe(nil), case_sensitive = T.unsafe(nil)); end
  def matches_regexp(other, case_sensitive = T.unsafe(nil)); end
  def not_between(other); end
  def not_eq(other); end
  def not_eq_all(others); end
  def not_eq_any(others); end
  def not_in(other); end
  def not_in_all(others); end
  def not_in_any(others); end
  def overlaps(other); end
  def quoted_array(others); end
  def when(right); end

  private

  def grouping_all(method_id, others, *extras); end
  def grouping_any(method_id, others, *extras); end

  # @return [Boolean]
  def infinity?(value); end

  # @return [Boolean]
  def open_ended?(value); end

  def quoted_node(other); end

  # @return [Boolean]
  def unboundable?(value); end
end

class Arel::SelectManager < ::Arel::TreeManager
  include ::Arel::Crud

  # @return [SelectManager] a new instance of SelectManager
  def initialize(table = T.unsafe(nil)); end

  def as(other); end
  def comment(*values); end
  def constraints; end
  def distinct(value = T.unsafe(nil)); end
  def distinct_on(value); end
  def except(other); end

  # Produces an Arel::Nodes::Exists node
  def exists; end

  def from(table); end
  def froms; end
  def group(*columns); end
  def having(expr); end
  def intersect(other); end
  def join(relation, klass = T.unsafe(nil)); end
  def join_sources; end
  def lateral(table_name = T.unsafe(nil)); end
  def limit; end
  def limit=(limit); end
  def lock(locking = T.unsafe(nil)); end
  def locked; end
  def minus(other); end
  def offset; end
  def offset=(amount); end
  def on(*exprs); end
  def optimizer_hints(*hints); end
  def order(*expr); end
  def orders; end
  def outer_join(relation); end
  def project(*projections); end
  def projections; end
  def projections=(projections); end
  def skip(amount); end
  def source; end
  def take(limit); end
  def taken; end
  def union(operation, other = T.unsafe(nil)); end
  def where_sql(engine = T.unsafe(nil)); end
  def window(name); end
  def with(*subqueries); end

  private

  def collapse(exprs); end
  def initialize_copy(other); end
end

Arel::SelectManager::STRING_OR_SYMBOL_CLASS = T.let(T.unsafe(nil), Array)

class Arel::Table
  include ::Arel::Crud
  include ::Arel::FactoryMethods
  include ::Arel::AliasPredication

  # @return [Table] a new instance of Table
  def initialize(name, as: T.unsafe(nil), klass: T.unsafe(nil), type_caster: T.unsafe(nil)); end

  # @return [Boolean]
  def ==(other); end

  def [](name, table = T.unsafe(nil)); end

  # @return [Boolean]
  def able_to_type_cast?; end

  def alias(name = T.unsafe(nil)); end

  # @return [Boolean]
  def eql?(other); end

  def from; end
  def group(*columns); end
  def hash; end
  def having(expr); end
  def join(relation, klass = T.unsafe(nil)); end

  # Returns the value of attribute name.
  def name; end

  # Sets the attribute name
  #
  # @param value the value to set the attribute name to.
  def name=(_arg0); end

  def order(*expr); end
  def outer_join(relation); end
  def project(*things); end
  def skip(amount); end

  # Returns the value of attribute table_alias.
  def table_alias; end

  # Sets the attribute table_alias
  #
  # @param value the value to set the attribute table_alias to.
  def table_alias=(_arg0); end

  # Returns the value of attribute name.
  # TableAlias and Table both have a #table_name which is the name of the underlying table
  def table_name; end

  def take(amount); end
  def type_cast_for_database(attr_name, value); end
  def type_for_attribute(name); end
  def where(condition); end

  private

  # Returns the value of attribute type_caster.
  def type_caster; end

  class << self
    # Returns the value of attribute engine.
    def engine; end

    # Sets the attribute engine
    #
    # @param value the value to set the attribute engine to.
    def engine=(_arg0); end
  end
end

class Arel::TreeManager
  include ::Arel::FactoryMethods

  # @return [TreeManager] a new instance of TreeManager
  def initialize; end

  # Returns the value of attribute ast.
  def ast; end

  def to_dot; end
  def to_sql(engine = T.unsafe(nil)); end
  def where(expr); end

  private

  def initialize_copy(other); end
end

module Arel::TreeManager::StatementMethods
  def key; end
  def key=(key); end
  def offset(offset); end
  def order(*expr); end
  def take(limit); end
  def where(expr); end
  def wheres=(exprs); end
end

class Arel::UpdateManager < ::Arel::TreeManager
  include ::Arel::TreeManager::StatementMethods

  # @return [UpdateManager] a new instance of UpdateManager
  def initialize; end

  def set(values); end

  # UPDATE +table+
  def table(table); end
end

Arel::VERSION = T.let(T.unsafe(nil), String)
module Arel::Visitors; end

class Arel::Visitors::Dot < ::Arel::Visitors::Visitor
  # @return [Dot] a new instance of Dot
  def initialize; end

  def accept(object, collector); end

  private

  def binary(o); end
  def edge(name); end
  def extract(o); end
  def function(o); end
  def named_window(o); end
  def nary(o); end
  def quote(string); end
  def to_dot; end
  def unary(o); end
  def visit(o); end
  def visit_ActiveModel_Attribute(o); end
  def visit_Arel_Attribute(o); end
  def visit_Arel_Attributes_Attribute(o); end
  def visit_Arel_Attributes_Boolean(o); end
  def visit_Arel_Attributes_Float(o); end
  def visit_Arel_Attributes_Integer(o); end
  def visit_Arel_Attributes_String(o); end
  def visit_Arel_Attributes_Time(o); end
  def visit_Arel_Nodes_And(o); end
  def visit_Arel_Nodes_As(o); end
  def visit_Arel_Nodes_Assignment(o); end
  def visit_Arel_Nodes_Avg(o); end
  def visit_Arel_Nodes_Between(o); end
  def visit_Arel_Nodes_BindParam(o); end
  def visit_Arel_Nodes_Casted(o); end
  def visit_Arel_Nodes_Comment(o); end
  def visit_Arel_Nodes_Concat(o); end
  def visit_Arel_Nodes_Count(o); end
  def visit_Arel_Nodes_Cube(o); end
  def visit_Arel_Nodes_DeleteStatement(o); end
  def visit_Arel_Nodes_DoesNotMatch(o); end
  def visit_Arel_Nodes_Equality(o); end
  def visit_Arel_Nodes_Exists(o); end
  def visit_Arel_Nodes_Extract(o); end
  def visit_Arel_Nodes_Following(o); end
  def visit_Arel_Nodes_FullOuterJoin(o); end
  def visit_Arel_Nodes_GreaterThan(o); end
  def visit_Arel_Nodes_GreaterThanOrEqual(o); end
  def visit_Arel_Nodes_Group(o); end
  def visit_Arel_Nodes_Grouping(o); end
  def visit_Arel_Nodes_GroupingElement(o); end
  def visit_Arel_Nodes_GroupingSet(o); end
  def visit_Arel_Nodes_Having(o); end
  def visit_Arel_Nodes_HomogeneousIn(o); end
  def visit_Arel_Nodes_In(o); end
  def visit_Arel_Nodes_InnerJoin(o); end
  def visit_Arel_Nodes_InsertStatement(o); end
  def visit_Arel_Nodes_IsDistinctFrom(o); end
  def visit_Arel_Nodes_IsNotDistinctFrom(o); end
  def visit_Arel_Nodes_JoinSource(o); end
  def visit_Arel_Nodes_LessThan(o); end
  def visit_Arel_Nodes_LessThanOrEqual(o); end
  def visit_Arel_Nodes_Limit(o); end
  def visit_Arel_Nodes_Matches(o); end
  def visit_Arel_Nodes_Max(o); end
  def visit_Arel_Nodes_Min(o); end
  def visit_Arel_Nodes_NamedFunction(o); end
  def visit_Arel_Nodes_NamedWindow(o); end
  def visit_Arel_Nodes_Not(o); end
  def visit_Arel_Nodes_NotEqual(o); end
  def visit_Arel_Nodes_NotIn(o); end
  def visit_Arel_Nodes_Offset(o); end
  def visit_Arel_Nodes_On(o); end
  def visit_Arel_Nodes_OptimizerHints(o); end
  def visit_Arel_Nodes_Or(o); end
  def visit_Arel_Nodes_Ordering(o); end
  def visit_Arel_Nodes_OuterJoin(o); end
  def visit_Arel_Nodes_Over(o); end
  def visit_Arel_Nodes_Preceding(o); end
  def visit_Arel_Nodes_Range(o); end
  def visit_Arel_Nodes_RightOuterJoin(o); end
  def visit_Arel_Nodes_RollUp(o); end
  def visit_Arel_Nodes_Rows(o); end
  def visit_Arel_Nodes_SelectCore(o); end
  def visit_Arel_Nodes_SelectStatement(o); end
  def visit_Arel_Nodes_SqlLiteral(o); end
  def visit_Arel_Nodes_StringJoin(o); end
  def visit_Arel_Nodes_Sum(o); end
  def visit_Arel_Nodes_TableAlias(o); end
  def visit_Arel_Nodes_UnqualifiedColumn(o); end
  def visit_Arel_Nodes_UpdateStatement(o); end
  def visit_Arel_Nodes_ValuesList(o); end
  def visit_Arel_Nodes_Window(o); end
  def visit_Arel_Table(o); end
  def visit_Array(o); end
  def visit_BigDecimal(o); end
  def visit_Date(o); end
  def visit_DateTime(o); end
  def visit_FalseClass(o); end
  def visit_Float(o); end
  def visit_Hash(o); end
  def visit_Integer(o); end
  def visit_NilClass(o); end
  def visit_Set(o); end
  def visit_String(o); end
  def visit_Symbol(o); end
  def visit_Time(o); end
  def visit_TrueClass(o); end
  def visit_edge(o, method); end
  def window(o); end
  def with_node(node); end
end

class Arel::Visitors::Dot::Edge < ::Struct; end

class Arel::Visitors::Dot::Node
  # @return [Node] a new instance of Node
  def initialize(name, id, fields = T.unsafe(nil)); end

  # Returns the value of attribute fields.
  def fields; end

  # Sets the attribute fields
  #
  # @param value the value to set the attribute fields to.
  def fields=(_arg0); end

  # Returns the value of attribute id.
  def id; end

  # Sets the attribute id
  #
  # @param value the value to set the attribute id to.
  def id=(_arg0); end

  # Returns the value of attribute name.
  def name; end

  # Sets the attribute name
  #
  # @param value the value to set the attribute name to.
  def name=(_arg0); end
end

class Arel::Visitors::MySQL < ::Arel::Visitors::ToSql
  private

  # MySQL is too stupid to create a temporary table for use subquery, so we have
  # to give it some prompting in the form of a subsubquery.
  def build_subselect(key, o); end

  # In the simple case, MySQL allows us to place JOINs directly into the UPDATE
  # query. However, this does not allow for LIMIT, OFFSET and ORDER. To support
  # these, we must use a subquery.
  def prepare_delete_statement(o); end

  # In the simple case, MySQL allows us to place JOINs directly into the UPDATE
  # query. However, this does not allow for LIMIT, OFFSET and ORDER. To support
  # these, we must use a subquery.
  def prepare_update_statement(o); end

  def visit_Arel_Nodes_Bin(o, collector); end
  def visit_Arel_Nodes_Concat(o, collector); end
  def visit_Arel_Nodes_IsDistinctFrom(o, collector); end
  def visit_Arel_Nodes_IsNotDistinctFrom(o, collector); end
  def visit_Arel_Nodes_NotRegexp(o, collector); end
  def visit_Arel_Nodes_Regexp(o, collector); end
  def visit_Arel_Nodes_SelectCore(o, collector); end

  # :'(
  # To retrieve all rows from a certain offset up to the end of the result set,
  # you can use some large number for the second parameter.
  # https://dev.mysql.com/doc/refman/en/select.html
  def visit_Arel_Nodes_SelectStatement(o, collector); end

  def visit_Arel_Nodes_UnqualifiedColumn(o, collector); end
end

class Arel::Visitors::PostgreSQL < ::Arel::Visitors::ToSql
  private

  def bind_block; end

  # Utilized by GroupingSet, Cube & RollUp visitors to
  # handle grouping aggregation semantics
  def grouping_array_or_grouping_element(o, collector); end

  # Used by Lateral visitor to enclose select queries in parentheses
  def grouping_parentheses(o, collector); end

  def visit_Arel_Nodes_Cube(o, collector); end
  def visit_Arel_Nodes_DistinctOn(o, collector); end
  def visit_Arel_Nodes_DoesNotMatch(o, collector); end
  def visit_Arel_Nodes_GroupingElement(o, collector); end
  def visit_Arel_Nodes_GroupingSet(o, collector); end
  def visit_Arel_Nodes_IsDistinctFrom(o, collector); end
  def visit_Arel_Nodes_IsNotDistinctFrom(o, collector); end
  def visit_Arel_Nodes_Lateral(o, collector); end
  def visit_Arel_Nodes_Matches(o, collector); end
  def visit_Arel_Nodes_NotRegexp(o, collector); end
  def visit_Arel_Nodes_NullsFirst(o, collector); end
  def visit_Arel_Nodes_NullsLast(o, collector); end
  def visit_Arel_Nodes_Regexp(o, collector); end
  def visit_Arel_Nodes_RollUp(o, collector); end
end

Arel::Visitors::PostgreSQL::BIND_BLOCK = T.let(T.unsafe(nil), Proc)

class Arel::Visitors::SQLite < ::Arel::Visitors::ToSql
  private

  def visit_Arel_Nodes_False(o, collector); end
  def visit_Arel_Nodes_IsDistinctFrom(o, collector); end
  def visit_Arel_Nodes_IsNotDistinctFrom(o, collector); end

  # Locks are not supported in SQLite
  def visit_Arel_Nodes_Lock(o, collector); end

  def visit_Arel_Nodes_SelectStatement(o, collector); end
  def visit_Arel_Nodes_True(o, collector); end
end

class Arel::Visitors::ToSql < ::Arel::Visitors::Visitor
  # @return [ToSql] a new instance of ToSql
  def initialize(connection); end

  def compile(node, collector = T.unsafe(nil)); end

  private

  def aggregate(name, o, collector); end
  def bind_block; end

  # FIXME: we should probably have a 2-pass visitor for this
  def build_subselect(key, o); end

  def collect_ctes(children, collector); end
  def collect_nodes_for(nodes, collector, spacer, connector = T.unsafe(nil)); end
  def collect_optimizer_hints(o, collector); end

  # @return [Boolean]
  def has_join_sources?(o); end

  # @return [Boolean]
  def has_limit_or_offset_or_orders?(o); end

  def infix_value(o, collector, value); end
  def infix_value_with_paren(o, collector, value, suppress_parens = T.unsafe(nil)); end
  def inject_join(list, collector, join_str); end
  def is_distinct_from(o, collector); end
  def maybe_visit(thing, collector); end

  # The default strategy for an UPDATE with joins is to use a subquery. This doesn't work
  # on MySQL (even when aliasing the tables), but MySQL allows using JOIN directly in
  # an UPDATE statement, so in the MySQL visitor we redefine this to do that.
  def prepare_delete_statement(o); end

  # The default strategy for an UPDATE with joins is to use a subquery. This doesn't work
  # on MySQL (even when aliasing the tables), but MySQL allows using JOIN directly in
  # an UPDATE statement, so in the MySQL visitor we redefine this to do that.
  def prepare_update_statement(o); end

  def quote(value); end
  def quote_column_name(name); end
  def quote_table_name(name); end
  def sanitize_as_sql_comment(value); end

  # @return [Boolean]
  def unboundable?(value); end

  # @raise [UnsupportedVisitError]
  def unsupported(o, collector); end

  # @raise [UnsupportedVisitError]
  def visit_ActiveSupport_Multibyte_Chars(o, collector); end

  # @raise [UnsupportedVisitError]
  def visit_ActiveSupport_StringInquirer(o, collector); end

  def visit_Arel_Attributes_Attribute(o, collector); end
  def visit_Arel_Nodes_And(o, collector); end
  def visit_Arel_Nodes_As(o, collector); end
  def visit_Arel_Nodes_Ascending(o, collector); end
  def visit_Arel_Nodes_Assignment(o, collector); end
  def visit_Arel_Nodes_Avg(o, collector); end
  def visit_Arel_Nodes_Between(o, collector); end
  def visit_Arel_Nodes_Bin(o, collector); end
  def visit_Arel_Nodes_BindParam(o, collector); end
  def visit_Arel_Nodes_Case(o, collector); end
  def visit_Arel_Nodes_Casted(o, collector); end
  def visit_Arel_Nodes_Comment(o, collector); end
  def visit_Arel_Nodes_Count(o, collector); end
  def visit_Arel_Nodes_CurrentRow(o, collector); end
  def visit_Arel_Nodes_DeleteStatement(o, collector); end
  def visit_Arel_Nodes_Descending(o, collector); end
  def visit_Arel_Nodes_Distinct(o, collector); end

  # @raise [NotImplementedError]
  def visit_Arel_Nodes_DistinctOn(o, collector); end

  def visit_Arel_Nodes_DoesNotMatch(o, collector); end
  def visit_Arel_Nodes_Else(o, collector); end
  def visit_Arel_Nodes_Equality(o, collector); end
  def visit_Arel_Nodes_Except(o, collector); end
  def visit_Arel_Nodes_Exists(o, collector); end
  def visit_Arel_Nodes_Extract(o, collector); end
  def visit_Arel_Nodes_False(o, collector); end
  def visit_Arel_Nodes_Following(o, collector); end
  def visit_Arel_Nodes_FullOuterJoin(o, collector); end
  def visit_Arel_Nodes_GreaterThan(o, collector); end
  def visit_Arel_Nodes_GreaterThanOrEqual(o, collector); end
  def visit_Arel_Nodes_Group(o, collector); end
  def visit_Arel_Nodes_Grouping(o, collector); end
  def visit_Arel_Nodes_HomogeneousIn(o, collector); end
  def visit_Arel_Nodes_In(o, collector); end
  def visit_Arel_Nodes_InfixOperation(o, collector); end
  def visit_Arel_Nodes_InnerJoin(o, collector); end
  def visit_Arel_Nodes_InsertStatement(o, collector); end
  def visit_Arel_Nodes_Intersect(o, collector); end
  def visit_Arel_Nodes_IsDistinctFrom(o, collector); end
  def visit_Arel_Nodes_IsNotDistinctFrom(o, collector); end
  def visit_Arel_Nodes_JoinSource(o, collector); end
  def visit_Arel_Nodes_LessThan(o, collector); end
  def visit_Arel_Nodes_LessThanOrEqual(o, collector); end
  def visit_Arel_Nodes_Limit(o, collector); end
  def visit_Arel_Nodes_Lock(o, collector); end
  def visit_Arel_Nodes_Matches(o, collector); end
  def visit_Arel_Nodes_Max(o, collector); end
  def visit_Arel_Nodes_Min(o, collector); end
  def visit_Arel_Nodes_NamedFunction(o, collector); end
  def visit_Arel_Nodes_NamedWindow(o, collector); end
  def visit_Arel_Nodes_Not(o, collector); end
  def visit_Arel_Nodes_NotEqual(o, collector); end
  def visit_Arel_Nodes_NotIn(o, collector); end

  # @raise [NotImplementedError]
  def visit_Arel_Nodes_NotRegexp(o, collector); end

  def visit_Arel_Nodes_Offset(o, collector); end
  def visit_Arel_Nodes_On(o, collector); end
  def visit_Arel_Nodes_OptimizerHints(o, collector); end
  def visit_Arel_Nodes_Or(o, collector); end
  def visit_Arel_Nodes_OuterJoin(o, collector); end
  def visit_Arel_Nodes_Over(o, collector); end
  def visit_Arel_Nodes_Preceding(o, collector); end
  def visit_Arel_Nodes_Quoted(o, collector); end
  def visit_Arel_Nodes_Range(o, collector); end

  # @raise [NotImplementedError]
  def visit_Arel_Nodes_Regexp(o, collector); end

  def visit_Arel_Nodes_RightOuterJoin(o, collector); end
  def visit_Arel_Nodes_Rows(o, collector); end
  def visit_Arel_Nodes_SelectCore(o, collector); end
  def visit_Arel_Nodes_SelectOptions(o, collector); end
  def visit_Arel_Nodes_SelectStatement(o, collector); end
  def visit_Arel_Nodes_SqlLiteral(o, collector); end
  def visit_Arel_Nodes_StringJoin(o, collector); end
  def visit_Arel_Nodes_Sum(o, collector); end
  def visit_Arel_Nodes_TableAlias(o, collector); end
  def visit_Arel_Nodes_True(o, collector); end
  def visit_Arel_Nodes_UnaryOperation(o, collector); end
  def visit_Arel_Nodes_Union(o, collector); end
  def visit_Arel_Nodes_UnionAll(o, collector); end
  def visit_Arel_Nodes_UnqualifiedColumn(o, collector); end
  def visit_Arel_Nodes_UpdateStatement(o, collector); end
  def visit_Arel_Nodes_ValuesList(o, collector); end
  def visit_Arel_Nodes_When(o, collector); end
  def visit_Arel_Nodes_Window(o, collector); end
  def visit_Arel_Nodes_With(o, collector); end
  def visit_Arel_Nodes_WithRecursive(o, collector); end
  def visit_Arel_SelectManager(o, collector); end
  def visit_Arel_Table(o, collector); end
  def visit_Array(o, collector); end

  # @raise [UnsupportedVisitError]
  def visit_BigDecimal(o, collector); end

  # @raise [UnsupportedVisitError]
  def visit_Class(o, collector); end

  # @raise [UnsupportedVisitError]
  def visit_Date(o, collector); end

  # @raise [UnsupportedVisitError]
  def visit_DateTime(o, collector); end

  # @raise [UnsupportedVisitError]
  def visit_FalseClass(o, collector); end

  # @raise [UnsupportedVisitError]
  def visit_Float(o, collector); end

  # @raise [UnsupportedVisitError]
  def visit_Hash(o, collector); end

  def visit_Integer(o, collector); end

  # @raise [UnsupportedVisitError]
  def visit_NilClass(o, collector); end

  def visit_Set(o, collector); end

  # @raise [UnsupportedVisitError]
  def visit_String(o, collector); end

  # @raise [UnsupportedVisitError]
  def visit_Symbol(o, collector); end

  # @raise [UnsupportedVisitError]
  def visit_Time(o, collector); end

  # @raise [UnsupportedVisitError]
  def visit_TrueClass(o, collector); end
end

Arel::Visitors::ToSql::BIND_BLOCK = T.let(T.unsafe(nil), Proc)

class Arel::Visitors::UnsupportedVisitError < ::StandardError
  # @return [UnsupportedVisitError] a new instance of UnsupportedVisitError
  def initialize(object); end
end

class Arel::Visitors::Visitor
  # @return [Visitor] a new instance of Visitor
  def initialize; end

  def accept(object, collector = T.unsafe(nil)); end

  private

  # Returns the value of attribute dispatch.
  def dispatch; end

  def get_dispatch_cache; end
  def visit(object, collector = T.unsafe(nil)); end

  class << self
    def dispatch_cache; end
  end
end

module Arel::WindowPredications
  def over(expr = T.unsafe(nil)); end
end

class PG::SimpleCoder < ::PG::Coder; end
class PG::SimpleDecoder < ::PG::SimpleCoder; end
