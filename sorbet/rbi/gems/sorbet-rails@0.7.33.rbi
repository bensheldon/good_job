# typed: false

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `sorbet-rails` gem.
# Please instead update this file by running `bin/tapioca gem sorbet-rails`.

# @abstract Subclasses must implement the `abstract` methods below.
module ITypeAssert
  extend T::Generic

  abstract!

  Elem = type_member(:out)

  # @abstract
  sig { abstract.params(val: T.untyped).returns(Elem) }
  def assert(val); end

  def get_type; end
end

module SorbetRails
  class << self
    sig { returns(::SorbetRails::Config) }
    def config; end

    # @yield [config]
    sig { params(blk: T.proc.params(arg0: ::SorbetRails::Config).void).void }
    def configure(&blk); end

    sig { void }
    def register_configured_plugins; end
  end
end

class SorbetRails::Config
  sig { void }
  def initialize; end

  sig { returns(T::Array[::Symbol]) }
  def enabled_gem_plugins; end

  # @return [Array<Symbol>]
  def enabled_gem_plugins=(_arg0); end

  sig { returns(T::Array[::Symbol]) }
  def enabled_model_plugins; end

  # @return [Array<Symbol>]
  def enabled_model_plugins=(_arg0); end

  sig { returns(T::Array[::Symbol]) }
  def enabled_plugins; end

  sig { returns(T::Array[::String]) }
  def extra_helper_includes; end

  # @return [Array<String>]
  def extra_helper_includes=(_arg0); end

  sig { returns(T.class_of(SorbetRails::JobRbiFormatter)) }
  def job_generator_class; end

  # @return [T.class_of(SorbetRails::JobRbiFormatter)]
  def job_generator_class=(_arg0); end

  sig { returns(T.class_of(SorbetRails::MailerRbiFormatter)) }
  def mailer_generator_class; end

  # @return [T.class_of(SorbetRails::MailerRbiFormatter)]
  def mailer_generator_class=(_arg0); end
end

class SorbetRails::JobRbiFormatter
  sig { params(job_class: T.class_of(ActiveJob::Base)).void }
  def initialize(job_class); end

  sig { returns(::String) }
  def generate_rbi; end

  sig { returns(T.class_of(ActiveJob::Base)) }
  def job_class; end

  sig { void }
  def populate_rbi; end

  sig { returns(::Parlour::RbiGenerator) }
  def rbi_generator; end
end

SorbetRails::JobRbiFormatter::Parameter = Parlour::RbiGenerator::Parameter

class SorbetRails::MailerRbiFormatter
  # @param mailer_class [T.class_of(ActionMailer::Base)]
  # @return [void]
  def initialize(*args, &blk); end

  sig { returns(::String) }
  def generate_rbi; end

  # @return [T.class_of(ActionMailer::Base)]
  def mailer_class(*args, &blk); end

  sig { void }
  def populate_rbi; end

  sig { returns(::Parlour::RbiGenerator) }
  def rbi_generator; end
end

SorbetRails::MailerRbiFormatter::Parameter = Parlour::RbiGenerator::Parameter

# @abstract Subclasses must implement the `abstract` methods below.
module SorbetRails::ModelColumnUtils
  abstract!

  sig { params(klass: ::Object, time_zone_aware: T::Boolean).returns(T.any(::Class, ::String)) }
  def active_record_type_to_sorbet_type(klass, time_zone_aware: T.unsafe(nil)); end

  sig { params(attribute: T.any(::String, ::Symbol)).returns(T::Boolean) }
  def attribute_has_unconditional_presence_validation?(attribute); end

  # if we're a HABTM class then model_class is an anonymous class (see the rails link below) and
  # i'm not sure how to explain that to sorbet other than T.class_of(Class).
  #
  # @abstract
  sig { abstract.returns(T.any(T.class_of(ActiveRecord::Base), T.class_of(Class))) }
  def model_class; end

  sig { params(column_def: T.untyped).returns(T::Boolean) }
  def nilable_column?(column_def); end

  # True if this column is "time zone aware", which means it'll be converted on
  # access from its original class (e.g. `DateTime`) to something with better
  # support for time zones (usually `ActiveSupport::TimeWithZone`)
  sig { params(column_def: T.untyped, cast_type: T.untyped).returns(T::Boolean) }
  def time_zone_aware_column?(column_def, cast_type); end

  sig { params(column_def: T.untyped).returns(::SorbetRails::ModelColumnUtils::ColumnType) }
  def type_for_column_def(column_def); end
end

class SorbetRails::ModelColumnUtils::ColumnType < ::T::Struct
  const :array_type, T.nilable(T::Boolean)
  const :base_type, T.any(::Class, ::String)
  const :nilable, T.nilable(T::Boolean)

  sig { returns(::String) }
  def to_s; end

  class << self
    def inherited(s); end
  end
end

module SorbetRails::ModelPlugins
  sig { params(plugin_name: ::Symbol).returns(T.class_of(SorbetRails::ModelPlugins::Base)) }
  def get_plugin_by_name(plugin_name); end

  sig { returns(T::Array[T.class_of(SorbetRails::ModelPlugins::Base)]) }
  def get_plugins; end

  sig { params(plugin: T.class_of(SorbetRails::ModelPlugins::Base)).void }
  def register_plugin(plugin); end

  sig { params(plugin_name: ::Symbol).void }
  def register_plugin_by_name(plugin_name); end

  sig { params(plugins: T::Array[T.class_of(SorbetRails::ModelPlugins::Base)]).void }
  def set_plugins(plugins); end
end

class SorbetRails::ModelPlugins::ActiveRecordAssoc < ::SorbetRails::ModelPlugins::Base
  sig { params(model_class: T.class_of(ActiveRecord::Base), available_classes: T::Set[::String]).void }
  def initialize(model_class, available_classes); end

  sig { params(reflection: T.untyped).returns(T.nilable(T::Boolean)) }
  def assoc_should_be_untyped?(reflection); end

  sig { override.params(root: ::Parlour::RbiGenerator::Namespace).void }
  def generate(root); end

  sig { params(reflection: T.untyped).returns(T.nilable(T::Boolean)) }
  def polymorphic_assoc?(reflection); end

  sig { params(assoc_module_rbi: T.untyped, assoc_name: T.untyped, reflection: T.untyped).void }
  def populate_collection_assoc_getter_setter(assoc_module_rbi, assoc_name, reflection); end

  sig { params(assoc_module_rbi: T.untyped, assoc_name: T.untyped, reflection: T.untyped).void }
  def populate_single_assoc_getter_setter(assoc_module_rbi, assoc_name, reflection); end

  sig { params(reflection: T.untyped).returns(T.nilable(T::Boolean)) }
  def relation_should_be_untyped?(reflection); end

  private

  sig { params(reflection: T.untyped).returns(T::Boolean) }
  def belongs_to_and_required?(reflection); end

  sig { params(reflection: T.untyped).returns(T::Boolean) }
  def has_one_and_required?(reflection); end
end

class SorbetRails::ModelPlugins::ActiveRecordAttribute < ::SorbetRails::ModelPlugins::Base
  sig { override.params(root: ::Parlour::RbiGenerator::Namespace).void }
  def generate(root); end

  sig do
    params(
      root: ::Parlour::RbiGenerator::Namespace,
      model_class_rbi: ::Parlour::RbiGenerator::Namespace,
      attribute_module_rbi: ::Parlour::RbiGenerator::Namespace,
      model_defined_enums: T::Hash[::String, T::Hash[::String, T.untyped]],
      column_name: ::String,
      column_def: T.untyped
    ).void
  end
  def generate_enum_methods(root, model_class_rbi, attribute_module_rbi, model_defined_enums, column_name, column_def); end

  sig { params(column_type: ::SorbetRails::ModelColumnUtils::ColumnType).returns(::String) }
  def value_type_for_attr_writer(column_type); end
end

class SorbetRails::ModelPlugins::ActiveRecordEnum < ::SorbetRails::ModelPlugins::Base
  sig { override.params(root: ::Parlour::RbiGenerator::Namespace).void }
  def generate(root); end
end

class SorbetRails::ModelPlugins::ActiveRecordNamedScope < ::SorbetRails::ModelPlugins::Base
  sig { override.params(root: ::Parlour::RbiGenerator::Namespace).void }
  def generate(root); end
end

class SorbetRails::ModelPlugins::ActiveRecordQuerying < ::SorbetRails::ModelPlugins::Base
  sig { override.params(root: ::Parlour::RbiGenerator::Namespace).void }
  def generate(root); end

  private

  sig { params(root: ::Parlour::RbiGenerator::Namespace, inner_type: ::String).void }
  def create_in_batches_method(root, inner_type:); end
end

class SorbetRails::ModelPlugins::ActiveRecordSerializedAttribute < ::SorbetRails::ModelPlugins::Base
  sig { params(columns_hash: T::Hash[::String, ::ActiveRecord::ConnectionAdapters::Column]).returns(T::Boolean) }
  def any_serialized_columns?(columns_hash); end

  sig { params(serialization_coder: T.nilable(::Class)).returns(::String) }
  def attr_types_for_coder(serialization_coder); end

  sig { override.params(root: ::Parlour::RbiGenerator::Namespace).void }
  def generate(root); end
end

class SorbetRails::ModelPlugins::ActiveRelationWhereNot < ::SorbetRails::ModelPlugins::Base
  sig { override.params(root: ::Parlour::RbiGenerator::Namespace).void }
  def generate(root); end
end

class SorbetRails::ModelPlugins::ActiveStorageMethods < ::SorbetRails::ModelPlugins::Base
  sig { params(model_class: T.class_of(ActiveRecord::Base), available_classes: T::Set[::String]).void }
  def initialize(model_class, available_classes); end

  sig { params(assoc_name: ::String, mod: ::Parlour::RbiGenerator::Namespace).void }
  def create_has_many_methods(assoc_name, mod); end

  sig { params(assoc_name: ::String, mod: ::Parlour::RbiGenerator::Namespace).void }
  def create_has_one_methods(assoc_name, mod); end

  sig { override.params(root: ::Parlour::RbiGenerator::Namespace).void }
  def generate(root); end
end

# @abstract It cannont be directly instantiated. Subclasses must implement the `abstract` methods below.
class SorbetRails::ModelPlugins::Base < ::Parlour::Plugin
  include ::SorbetRails::ModelColumnUtils
  include ::SorbetRails::ModelUtils

  abstract!

  sig { params(model_class: T.class_of(ActiveRecord::Base), available_classes: T::Set[::String]).void }
  def initialize(model_class, available_classes); end

  sig { returns(T::Set[::String]) }
  def available_classes; end

  sig { override.returns(T.class_of(ActiveRecord::Base)) }
  def model_class; end

  sig { params(column_name: ::String).returns(T.nilable(::Class)) }
  def serialization_coder_for_column(column_name); end
end

# convenient rename
SorbetRails::ModelPlugins::Base::Parameter = Parlour::RbiGenerator::Parameter

class SorbetRails::ModelPlugins::CustomFinderMethods < ::SorbetRails::ModelPlugins::Base
  sig { override.params(root: ::Parlour::RbiGenerator::Namespace).void }
  def generate(root); end
end

class SorbetRails::ModelPlugins::EnumerableCollections < ::SorbetRails::ModelPlugins::Base
  sig { override.params(root: ::Parlour::RbiGenerator::Namespace).void }
  def generate(root); end
end

class SorbetRails::ModelPlugins::UnrecognizedPluginName < ::StandardError; end

class SorbetRails::ModelRbiFormatter
  include ::SorbetRails::ModelColumnUtils
  include ::SorbetRails::ModelUtils
  extend ::SorbetRails::ModelPlugins

  sig { params(model_class: T.class_of(ActiveRecord::Base), available_classes: T::Set[::String]).void }
  def initialize(model_class, available_classes); end

  sig { returns(T::Set[::String]) }
  def available_classes; end

  sig { params(root: ::Parlour::RbiGenerator::Namespace).void }
  def generate_base_rbi(root); end

  sig { returns(::String) }
  def generate_rbi; end

  sig { override.returns(T.class_of(ActiveRecord::Base)) }
  def model_class; end

  sig { params(plugins: T::Array[::Parlour::Plugin], generator: ::Parlour::RbiGenerator).void }
  def run_plugins(plugins, generator); end
end

# @abstract Subclasses must implement the `abstract` methods below.
module SorbetRails::ModelUtils
  include ::SorbetRails::ModelColumnUtils

  abstract!

  sig do
    params(
      root: ::Parlour::RbiGenerator::Namespace,
      method_name: ::String,
      parameters: T.nilable(T::Array[::Parlour::RbiGenerator::Parameter]),
      builtin_query_method: T::Boolean,
      custom_return_value: T.nilable(::String)
    ).void
  end
  def add_relation_query_method(root, method_name, parameters: T.unsafe(nil), builtin_query_method: T.unsafe(nil), custom_return_value: T.unsafe(nil)); end

  sig { params(method_name: T.any(::String, ::Symbol)).returns(T::Boolean) }
  def exists_class_method?(method_name); end

  sig { params(method_name: T.any(::String, ::Symbol)).returns(T::Boolean) }
  def exists_instance_method?(method_name); end

  # if we're a HABTM class then model_class is an anonymous class (see the rails link below) and
  # i'm not sure how to explain that to sorbet other than T.class_of(Class).
  # This is also defined in ModelColumnUtils
  # sig { abstract.returns(T.any(T.class_of(ActiveRecord::Base), T.class_of(Class))) }
  # def model_class; end
  sig { returns(T::Boolean) }
  def habtm_class?; end

  sig { returns(::String) }
  def model_assoc_proxy_class_name; end

  sig { returns(::String) }
  def model_assoc_relation_class_name; end

  sig { returns(::String) }
  def model_class_name; end

  sig { params(module_name: ::String).returns(::String) }
  def model_module_name(module_name); end

  sig { returns(::String) }
  def model_query_methods_returning_assoc_relation_module_name; end

  sig { returns(::String) }
  def model_query_methods_returning_relation_module_name; end

  sig { returns(::String) }
  def model_relation_class_name; end

  sig { returns(::String) }
  def model_relation_type_alias; end

  sig { returns(::String) }
  def model_relation_type_class_name; end
end

class SorbetRails::Railtie < ::Rails::Railtie; end

module SorbetRails::SorbetUtils
  class << self
    sig do
      params(
        parsed_params: T::Array[::SorbetRails::SorbetUtils::ParsedParamDef],
        method_def: ::UnboundMethod
      ).void
    end
    def extract_default_value_for_params!(parsed_params, method_def); end

    sig do
      params(
        signature: ::T::Private::Methods::Signature
      ).returns(T::Array[::SorbetRails::SorbetUtils::ParsedParamDef])
    end
    def get_ordered_parameters_with_type(signature); end

    # Given an AST node, returns the source code from which it was constructed.
    # If the given AST node is nil, this returns nil.
    # Taken from https://github.com/AaronC81/parlour/blob/master/lib/parlour/type_parser.rb#L506
    sig { params(node: T.nilable(::Parser::AST::Node)).returns(T.nilable(::String)) }
    def node_to_s(node); end

    sig { params(method_def: ::UnboundMethod).returns(T::Array[::Parlour::RbiGenerator::Parameter]) }
    def parameters_from_method_def(method_def); end
  end
end

class SorbetRails::SorbetUtils::ParsedParamDef < ::T::Struct
  prop :default, T.nilable(::String), default: T.unsafe(nil)
  const :kind, ::Symbol
  const :name, ::Symbol
  prop :prefix, T.nilable(::String)
  prop :suffix, T.nilable(::String)
  const :type_str, ::String

  class << self
    def inherited(s); end
  end
end

class SorbetRails::SorbetUtils::UnexpectedParam < ::StandardError; end

module SorbetRails::Utils
  class << self
    sig { void }
    def rails_eager_load_all!; end

    sig { params(method_name: ::String).returns(T::Boolean) }
    def valid_method_name?(method_name); end
  end
end

class TA
  extend T::Generic
  include ::TypeAssertImpl
  include ::ITypeAssert

  Elem = type_member

  sig { override.params(val: T.untyped).returns(Elem) }
  def assert(val); end

  class << self
    def [](type); end
  end
end

# Make this type visible even when the concrete
# implementation cannot be loaded.
module TypeAssertImpl
  class << self
    # @private
    def included(klass); end
  end
end
