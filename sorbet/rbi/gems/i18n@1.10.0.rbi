# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `i18n` gem.
# Please instead update this file by running `bin/tapioca gem i18n`.

module GetText; end

class GetText::PoParser < ::Racc::Parser
  def _(x); end
  def _reduce_10(val, _values, result); end
  def _reduce_12(val, _values, result); end
  def _reduce_13(val, _values, result); end
  def _reduce_14(val, _values, result); end
  def _reduce_15(val, _values, result); end
  def _reduce_5(val, _values, result); end
  def _reduce_8(val, _values, result); end
  def _reduce_9(val, _values, result); end
  def _reduce_none(val, _values, result); end
  def next_token; end
  def on_comment(comment); end
  def on_message(msgid, msgstr); end
  def parse(str, data, ignore_fuzzy = T.unsafe(nil)); end
  def unescape(orig); end
end

GetText::PoParser::Racc_arg = T.let(T.unsafe(nil), Array)
GetText::PoParser::Racc_debug_parser = T.let(T.unsafe(nil), TrueClass)
GetText::PoParser::Racc_token_to_s_table = T.let(T.unsafe(nil), Array)

# Simple Locale tag implementation that computes subtags by simply splitting
# the locale tag at '-' occurences.
module I18n
  extend ::I18n::Base

  class << self
    def cache_key_digest; end
    def cache_key_digest=(key_digest); end
    def cache_namespace; end
    def cache_namespace=(namespace); end
    def cache_store; end
    def cache_store=(store); end

    # Returns the current fallbacks implementation. Defaults to +I18n::Locale::Fallbacks+.
    def fallbacks; end

    # Sets the current fallbacks implementation. Use this to set a different fallbacks implementation.
    def fallbacks=(fallbacks); end

    # Return String or raises MissingInterpolationArgument exception.
    # Missing argument's logic is handled by I18n.config.missing_interpolation_argument_handler.
    #
    # @raise [ReservedInterpolationKey]
    def interpolate(string, values); end

    def interpolate_hash(string, values); end
    def new_double_nested_cache; end

    # @return [Boolean]
    def perform_caching?; end

    # Marks a key as reserved. Reserved keys are used internally,
    # and can't also be used for interpolation. If you are using any
    # extra keys as I18n options, you should call I18n.reserve_key
    # before any I18n.translate (etc) calls are made.
    def reserve_key(key); end

    def reserved_keys_pattern; end
  end
end

class I18n::ArgumentError < ::ArgumentError; end
module I18n::Backend; end

module I18n::Backend::Base
  include ::I18n::Backend::Transliterator

  # Returns an array of locales for which translations are available
  # ignoring the reserved translation meta data key :i18n.
  #
  # @raise [NotImplementedError]
  def available_locales; end

  def eager_load!; end

  # @return [Boolean]
  def exists?(locale, key, options = T.unsafe(nil)); end

  # Accepts a list of paths to translation files. Loads translations from
  # plain Ruby (*.rb), YAML files (*.yml), or JSON files (*.json). See #load_rb, #load_yml, and #load_json
  # for details.
  def load_translations(*filenames); end

  # Acts the same as +strftime+, but uses a localized version of the
  # format string. Takes a key from the date/time formats translations as
  # a format argument (<em>e.g.</em>, <tt>:short</tt> in <tt>:'date.formats'</tt>).
  #
  # @raise [ArgumentError]
  def localize(locale, object, format = T.unsafe(nil), options = T.unsafe(nil)); end

  def reload!; end

  # This method receives a locale, a data hash and options for storing translations.
  # Should be implemented
  #
  # @raise [NotImplementedError]
  def store_translations(locale, data, options = T.unsafe(nil)); end

  # @raise [I18n::ArgumentError]
  def translate(locale, key, options = T.unsafe(nil)); end

  protected

  # Deep interpolation
  #
  #   deep_interpolate { people: { ann: "Ann is %{ann}", john: "John is %{john}" } },
  #                    ann: 'good', john: 'big'
  #   #=> { people: { ann: "Ann is good", john: "John is big" } }
  def deep_interpolate(locale, data, values = T.unsafe(nil)); end

  # Evaluates defaults.
  # If given subject is an Array, it walks the array and returns the
  # first translation that can be resolved. Otherwise it tries to resolve
  # the translation directly.
  def default(locale, object, subject, options = T.unsafe(nil)); end

  # @return [Boolean]
  def eager_loaded?; end

  # Interpolates values into a given subject.
  #
  #   if the given subject is a string then:
  #   method interpolates "file %{file} opened by %%{user}", :file => 'test.txt', :user => 'Mr. X'
  #   # => "file test.txt opened by %{user}"
  #
  #   if the given subject is an array then:
  #   each element of the array is recursively interpolated (until it finds a string)
  #   method interpolates ["yes, %{user}", ["maybe no, %{user}, "no, %{user}"]], :user => "bartuz"
  #   # => "["yes, bartuz",["maybe no, bartuz", "no, bartuz"]]"
  def interpolate(locale, subject, values = T.unsafe(nil)); end

  # Loads a single translations file by delegating to #load_rb or
  # #load_yml depending on the file extension and directly merges the
  # data to the existing translations. Raises I18n::UnknownFileType
  # for all other file extensions.
  #
  # @raise [UnknownFileType]
  def load_file(filename); end

  # Loads a JSON translations file. The data must have locales as
  # toplevel keys.
  def load_json(filename); end

  # Loads a plain Ruby translations file. eval'ing the file must yield
  # a Hash containing translation data with locales as toplevel keys.
  def load_rb(filename); end

  # Loads a YAML translations file. The data must have locales as
  # toplevel keys.
  def load_yaml(filename); end

  # Loads a YAML translations file. The data must have locales as
  # toplevel keys.
  def load_yml(filename); end

  # The method which actually looks up for the translation in the store.
  #
  # @raise [NotImplementedError]
  def lookup(locale, key, scope = T.unsafe(nil), options = T.unsafe(nil)); end

  def pluralization_key(entry, count); end

  # Picks a translation from a pluralized mnemonic subkey according to English
  # pluralization rules :
  # - It will pick the :one subkey if count is equal to 1.
  # - It will pick the :other subkey otherwise.
  # - It will pick the :zero subkey in the special case where count is
  #   equal to 0 and there is a :zero subkey present. This behaviour is
  #   not standard with regards to the CLDR pluralization rules.
  # Other backends can implement more flexible or complex pluralization rules.
  #
  # @raise [InvalidPluralizationData]
  def pluralize(locale, entry, count); end

  # Resolves a translation.
  # If the given subject is a Symbol, it will be translated with the
  # given options. If it is a Proc then it will be evaluated. All other
  # subjects will be returned directly.
  def resolve(locale, object, subject, options = T.unsafe(nil)); end

  # Resolves a translation.
  # If the given subject is a Symbol, it will be translated with the
  # given options. If it is a Proc then it will be evaluated. All other
  # subjects will be returned directly.
  def resolve_entry(locale, object, subject, options = T.unsafe(nil)); end

  # @return [Boolean]
  def subtrees?; end

  def translate_localization_format(locale, object, format, options); end
end

# TODO Should the cache be cleared if new translations are stored?
module I18n::Backend::Cache
  def translate(locale, key, options = T.unsafe(nil)); end

  protected

  def _fetch(cache_key, &block); end
  def cache_key(locale, key, options); end
  def fetch(cache_key, &block); end

  private

  def digest_item(key); end
end

# Overwrites the Base load_file method to cache loaded file contents.
module I18n::Backend::CacheFile
  # Optionally provide path_roots array to normalize filename paths,
  # to make the cached i18n data portable across environments.
  def path_roots; end

  # Optionally provide path_roots array to normalize filename paths,
  # to make the cached i18n data portable across environments.
  def path_roots=(_arg0); end

  protected

  # Track loaded translation files in the `i18n.load_file` scope,
  # and skip loading the file if its contents are still up-to-date.
  def load_file(filename); end

  # Translate absolute filename to relative path for i18n key.
  def normalized_path(file); end
end

module I18n::Backend::Cascade
  def lookup(locale, key, scope = T.unsafe(nil), options = T.unsafe(nil)); end
end

# Backend that chains multiple other backends and checks each of them when
# a translation needs to be looked up. This is useful when you want to use
# standard translations with a Simple backend but store custom application
# translations in a database or other backends.
#
# To use the Chain backend instantiate it and set it to the I18n module.
# You can add chained backends through the initializer or backends
# accessor:
#
#   # preserves the existing Simple backend set to I18n.backend
#   I18n.backend = I18n::Backend::Chain.new(I18n::Backend::ActiveRecord.new, I18n.backend)
#
# The implementation assumes that all backends added to the Chain implement
# a lookup method with the same API as Simple backend does.
class I18n::Backend::Chain
  include ::I18n::Backend::Transliterator
  include ::I18n::Backend::Base
  include ::I18n::Backend::Chain::Implementation
end

module I18n::Backend::Chain::Implementation
  include ::I18n::Backend::Transliterator
  include ::I18n::Backend::Base

  def initialize(*backends); end

  def available_locales; end

  # Returns the value of attribute backends.
  def backends; end

  # Sets the attribute backends
  #
  # @param value the value to set the attribute backends to.
  def backends=(_arg0); end

  def eager_load!; end

  # @return [Boolean]
  def exists?(locale, key, options = T.unsafe(nil)); end

  # @return [Boolean]
  def initialized?; end

  def localize(locale, object, format = T.unsafe(nil), options = T.unsafe(nil)); end
  def reload!; end
  def store_translations(locale, data, options = T.unsafe(nil)); end
  def translate(locale, key, default_options = T.unsafe(nil)); end

  protected

  def init_translations; end

  # @return [Boolean]
  def namespace_lookup?(result, options); end

  def translations; end

  private

  # This is approximately what gets used in ActiveSupport.
  # However since we are not guaranteed to run in an ActiveSupport context
  # it is wise to have our own copy. We underscore it
  # to not pollute the namespace of the including class.
  def _deep_merge(hash, other_hash); end
end

module I18n::Backend::Fallbacks
  # @return [Boolean]
  def exists?(locale, key, options = T.unsafe(nil)); end

  def extract_non_symbol_default!(options); end
  def resolve_entry(locale, object, subject, options = T.unsafe(nil)); end

  # Overwrites the Base backend translate method so that it will try each
  # locale given by I18n.fallbacks for the given locale. E.g. for the
  # locale :"de-DE" it might try the locales :"de-DE", :de and :en
  # (depends on the fallbacks implementation) until it finds a result with
  # the given options. If it does not find any result for any of the
  # locales it will then throw MissingTranslation as usual.
  #
  # The default option takes precedence over fallback locales only when
  # it's a Symbol. When the default contains a String, Proc or Hash
  # it is evaluated last after all the fallback locales have been tried.
  def translate(locale, key, options = T.unsafe(nil)); end

  private

  # Overwrite on_fallback to add specified logic when the fallback succeeds.
  def on_fallback(_original_locale, _fallback_locale, _key, _optoins); end
end

# This module contains several helpers to assist flattening translations.
# You may want to flatten translations for:
#
#   1) speed up lookups, as in the Memoize backend;
#   2) In case you want to store translations in a data store, as in ActiveRecord backend;
#
# You can check both backends above for some examples.
# This module also keeps all links in a hash so they can be properly resolved when flattened.
module I18n::Backend::Flatten
  # Flatten keys for nested Hashes by chaining up keys:
  #
  #   >> { "a" => { "b" => { "c" => "d", "e" => "f" }, "g" => "h" }, "i" => "j"}.wind
  #   => { "a.b.c" => "d", "a.b.e" => "f", "a.g" => "h", "i" => "j" }
  def flatten_keys(hash, escape, prev_key = T.unsafe(nil), &block); end

  # Receives a hash of translations (where the key is a locale and
  # the value is another hash) and return a hash with all
  # translations flattened.
  #
  # Nested hashes are included in the flattened hash just if subtree
  # is true and Symbols are automatically stored as links.
  def flatten_translations(locale, data, escape, subtree); end

  # Store flattened links.
  def links; end

  # Shortcut to I18n::Backend::Flatten.normalize_flat_keys
  # and then resolve_links.
  def normalize_flat_keys(locale, key, scope, separator); end

  protected

  def escape_default_separator(key); end
  def find_link(locale, key); end
  def resolve_link(locale, key); end
  def store_link(locale, key, link); end

  class << self
    # Receives a string and escape the default separator.
    def escape_default_separator(key); end

    # normalize_keys the flatten way. This method is significantly faster
    # and creates way less objects than the one at I18n.normalize_keys.
    # It also handles escaping the translation keys.
    def normalize_flat_keys(locale, key, scope, separator); end
  end
end

I18n::Backend::Flatten::FLATTEN_SEPARATOR = T.let(T.unsafe(nil), String)
I18n::Backend::Flatten::SEPARATOR_ESCAPE_CHAR = T.let(T.unsafe(nil), String)

# Experimental support for using Gettext po files to store translations.
#
# To use this you can simply include the module to the Simple backend - or
# whatever other backend you are using.
#
#  I18n::Backend::Simple.include(I18n::Backend::Gettext)
#
# Now you should be able to include your Gettext translation (*.po) files to
# the +I18n.load_path+ so they're loaded to the backend and you can use them as
# usual:
#
#  I18n.load_path += Dir["path/to/locales/*.po"]
#
# Following the Gettext convention this implementation expects that your
# translation files are named by their locales. E.g. the file en.po would
# contain the translations for the English locale.
#
# To translate text <b>you must use</b> one of the translate methods provided by
# I18n::Gettext::Helpers.
#
#  include I18n::Gettext::Helpers
#  puts _("some string")
#
# Without it strings containing periods (".") will not be translated.
module I18n::Backend::Gettext
  protected

  def load_po(filename); end
  def normalize(locale, data); end
  def normalize_pluralization(locale, key, value); end
  def parse(filename); end
end

class I18n::Backend::Gettext::PoData < ::Hash
  def set_comment(msgid_or_sym, comment); end
end

module I18n::Backend::InterpolationCompiler
  def interpolate(locale, string, values); end
  def store_translations(locale, data, options = T.unsafe(nil)); end

  protected

  def compile_all_strings_in(data); end
end

module I18n::Backend::InterpolationCompiler::Compiler
  extend ::I18n::Backend::InterpolationCompiler::Compiler

  def compile_if_an_interpolation(string); end

  # @return [Boolean]
  def interpolated_str?(str); end

  protected

  def compile_interpolation_token(key); end
  def compiled_interpolation_body(str); end
  def direct_key(key); end
  def escape_key_sym(key); end
  def escape_plain_str(str); end
  def handle_interpolation_token(interpolation, matchdata); end
  def interpolate_key(key); end
  def interpolate_or_raise_missing(key); end
  def missing_key(key); end
  def nil_key(key); end
  def reserved_key(key); end

  # tokenize("foo %{bar} baz %%{buz}") # => ["foo ", "%{bar}", " baz ", "%%{buz}"]
  def tokenize(str); end
end

I18n::Backend::InterpolationCompiler::Compiler::INTERPOLATION_SYNTAX_PATTERN = T.let(T.unsafe(nil), Regexp)
I18n::Backend::InterpolationCompiler::Compiler::TOKENIZER = T.let(T.unsafe(nil), Regexp)

# This is a basic backend for key value stores. It receives on
# initialization the store, which should respond to three methods:
#
# * store#[](key)         - Used to get a value
# * store#[]=(key, value) - Used to set a value
# * store#keys            - Used to get all keys
#
# Since these stores only supports string, all values are converted
# to JSON before being stored, allowing it to also store booleans,
# hashes and arrays. However, this store does not support Procs.
#
# As the ActiveRecord backend, Symbols are just supported when loading
# translations from the filesystem or through explicit store translations.
#
# Also, avoid calling I18n.available_locales since it's a somehow
# expensive operation in most stores.
#
# == Example
#
# To setup I18n to use TokyoCabinet in memory is quite straightforward:
#
#   require 'rufus/tokyo/cabinet' # gem install rufus-tokyo
#   I18n.backend = I18n::Backend::KeyValue.new(Rufus::Tokyo::Cabinet.new('*'))
#
# == Performance
#
# You may make this backend even faster by including the Memoize module.
# However, notice that you should properly clear the cache if you change
# values directly in the key-store.
#
# == Subtrees
#
# In most backends, you are allowed to retrieve part of a translation tree:
#
#   I18n.backend.store_translations :en, :foo => { :bar => :baz }
#   I18n.t "foo" #=> { :bar => :baz }
#
# This backend supports this feature by default, but it slows down the storage
# of new data considerably and makes hard to delete entries. That said, you are
# allowed to disable the storage of subtrees on initialization:
#
#   I18n::Backend::KeyValue.new(@store, false)
#
# This is useful if you are using a KeyValue backend chained to a Simple backend.
class I18n::Backend::KeyValue
  include ::I18n::Backend::Flatten
  include ::I18n::Backend::Transliterator
  include ::I18n::Backend::Base
  include ::I18n::Backend::KeyValue::Implementation
end

module I18n::Backend::KeyValue::Implementation
  include ::I18n::Backend::Flatten
  include ::I18n::Backend::Transliterator
  include ::I18n::Backend::Base

  def initialize(store, subtrees = T.unsafe(nil)); end

  def available_locales; end

  # @return [Boolean]
  def initialized?; end

  # Returns the value of attribute store.
  def store; end

  # Sets the attribute store
  #
  # @param value the value to set the attribute store to.
  def store=(_arg0); end

  def store_translations(locale, data, options = T.unsafe(nil)); end

  protected

  def init_translations; end
  def lookup(locale, key, scope = T.unsafe(nil), options = T.unsafe(nil)); end
  def pluralize(locale, entry, count); end

  # @return [Boolean]
  def subtrees?; end

  # Queries the translations from the key-value store and converts
  # them into a hash such as the one returned from loading the
  # haml files
  def translations; end
end

class I18n::Backend::KeyValue::SubtreeProxy
  # @return [SubtreeProxy] a new instance of SubtreeProxy
  def initialize(master_key, store); end

  def [](key); end

  # @return [Boolean]
  def has_key?(key); end

  def inspect; end

  # @return [Boolean]
  def instance_of?(klass); end

  # @return [Boolean]
  def is_a?(klass); end

  # @return [Boolean]
  def kind_of?(klass); end

  # @return [Boolean]
  def nil?; end
end

class I18n::Backend::LazyLoadable < ::I18n::Backend::Simple
  # @return [LazyLoadable] a new instance of LazyLoadable
  def initialize(lazy_load: T.unsafe(nil)); end

  # Parse the load path and extract all locales.
  def available_locales; end

  # Eager loading is not supported in the lazy context.
  def eager_load!; end

  # Returns whether the current locale is initialized.
  #
  # @return [Boolean]
  def initialized?; end

  def lookup(locale, key, scope = T.unsafe(nil), options = T.unsafe(nil)); end

  # Clean up translations and uninitialize all locales.
  def reload!; end

  protected

  # Load translations from files that belong to the current locale.
  #
  # @raise [InvalidFilenames]
  def init_translations; end

  def initialized_locales; end

  private

  # Checks if a filename is named in correspondence to the translations it loaded.
  # The locale extracted from the path must be the single locale loaded in the translations.
  #
  # @raise [FilenameIncorrect]
  def assert_file_named_correctly!(file, translations); end

  # Select all files from I18n load path that belong to current locale.
  # These files must start with the locale identifier (ie. "en", "pt-BR"),
  # followed by an "_" demarcation to separate proceeding text.
  def filenames_for_current_locale; end

  # @return [Boolean]
  def lazy_load?; end

  # Loads each file supplied and asserts that the file only loads
  # translations as expected by the name. The method returns a list of
  # errors corresponding to offending files.
  def load_translations_and_collect_file_errors(files); end
end

class I18n::Backend::LazyLoadable::FilenameIncorrect < ::StandardError
  # @return [FilenameIncorrect] a new instance of FilenameIncorrect
  def initialize(file, expected_locale, unexpected_locales); end
end

# Backend that lazy loads translations based on the current locale. This
# implementation avoids loading all translations up front. Instead, it only
# loads the translations that belong to the current locale. This offers a
# performance incentive in local development and test environments for
# applications with many translations for many different locales. It's
# particularly useful when the application only refers to a single locales'
# translations at a time (ex. A Rails workload).  The implementation
# identifies which translation files from the load path belong to the
# current locale by pattern matching against their path name.
#
# Specifically, a translation file is considered to belong to a locale if:
# a) the filename is in the I18n load path
# b) the filename ends in a supported extension (ie. .yml, .json, .po, .rb)
# c) the filename starts with the locale identifier
# d) the locale identifier and optional proceeding text is separated by an underscore, ie. "_".
#
# Examples:
# Valid files that will be selected by this backend:
#
# "files/locales/en_translation.yml" (Selected for locale "en")
# "files/locales/fr.po"  (Selected for locale "fr")
#
# Invalid files that won't be selected by this backend:
#
# "files/locales/translation-file"
# "files/locales/en-translation.unsupported"
# "files/locales/french/translation.yml"
# "files/locales/fr/translation.yml"
#
# The implementation uses this assumption to defer the loading of
# translation files until the current locale actually requires them.
#
# The backend has two working modes: lazy_load and eager_load.
#
# Note: This backend should only be enabled in test environments!
# When the mode is set to false, the backend behaves exactly like the
# Simple backend, with an additional check that the paths being loaded
# abide by the format. If paths can't be matched to the format, an error is raised.
#
# You can configure lazy loaded backends through the initializer or backends
# accessor:
#
#   # In test environments
#
#   I18n.backend = I18n::Backend::LazyLoadable.new(lazy_load: true)
#
#   # In other environments, such as production and CI
#
#   I18n.backend = I18n::Backend::LazyLoadable.new(lazy_load: false) # default
class I18n::Backend::LocaleExtractor
  class << self
    def locale_from_path(path); end
  end
end

module I18n::Backend::Memoize
  def available_locales; end
  def eager_load!; end
  def reload!; end
  def store_translations(locale, data, options = T.unsafe(nil)); end

  protected

  def lookup(locale, key, scope = T.unsafe(nil), options = T.unsafe(nil)); end
  def memoized_lookup; end
  def reset_memoizations!(locale = T.unsafe(nil)); end
end

module I18n::Backend::Metadata
  def interpolate(locale, entry, values = T.unsafe(nil)); end
  def pluralize(locale, entry, count); end
  def translate(locale, key, options = T.unsafe(nil)); end

  protected

  def with_metadata(metadata, &block); end

  class << self
    # @private
    def included(base); end
  end
end

module I18n::Backend::Pluralization
  # Overwrites the Base backend translate method so that it will check the
  # translation meta data space (:i18n) for a locale specific pluralization
  # rule and use it to pluralize the given entry. I.e. the library expects
  # pluralization rules to be stored at I18n.t(:'i18n.plural.rule')
  #
  # Pluralization rules are expected to respond to #call(count) and
  # return a pluralization key. Valid keys depend on the translation data
  # hash (entry) but it is generally recommended to follow CLDR's style,
  # i.e., return one of the keys :zero, :one, :few, :many, :other.
  #
  # The :zero key is always picked directly when count equals 0 AND the
  # translation data has the key :zero. This way translators are free to
  # either pick a special :zero translation even for languages where the
  # pluralizer does not return a :zero key.
  def pluralize(locale, entry, count); end

  protected

  def pluralizer(locale); end
  def pluralizers; end
end

# A simple backend that reads translations from YAML files and stores them in
# an in-memory hash. Relies on the Base backend.
#
# The implementation is provided by a Implementation module allowing to easily
# extend Simple backend's behavior by including modules. E.g.:
#
# module I18n::Backend::Pluralization
#   def pluralize(*args)
#     # extended pluralization logic
#     super
#   end
# end
#
# I18n::Backend::Simple.include(I18n::Backend::Pluralization)
class I18n::Backend::Simple
  include ::I18n::Backend::Transliterator
  include ::I18n::Backend::Base
  include ::I18n::Backend::Simple::Implementation
end

module I18n::Backend::Simple::Implementation
  include ::I18n::Backend::Transliterator
  include ::I18n::Backend::Base

  # Get available locales from the translations hash
  def available_locales; end

  def eager_load!; end

  # @return [Boolean]
  def initialized?; end

  # Clean up translations hash and set initialized to false on reload!
  def reload!; end

  # Stores translations for the given locale in memory.
  # This uses a deep merge for the translations hash, so existing
  # translations will be overwritten by new ones only at the deepest
  # level of the hash.
  def store_translations(locale, data, options = T.unsafe(nil)); end

  def translations(do_init: T.unsafe(nil)); end

  protected

  def init_translations; end

  # Looks up a translation from the translations hash. Returns nil if
  # either key is nil, or locale, scope or key do not exist as a key in the
  # nested translations hash. Splits keys or scopes containing dots
  # into multiple keys, i.e. <tt>currency.format</tt> is regarded the same as
  # <tt>%w(currency format)</tt>.
  def lookup(locale, key, scope = T.unsafe(nil), options = T.unsafe(nil)); end
end

module I18n::Backend::Transliterator
  # Given a locale and a UTF-8 string, return the locale's ASCII
  # approximation for the string.
  def transliterate(locale, string, replacement = T.unsafe(nil)); end

  class << self
    # Get a transliterator instance.
    def get(rule = T.unsafe(nil)); end
  end
end

I18n::Backend::Transliterator::DEFAULT_REPLACEMENT_CHAR = T.let(T.unsafe(nil), String)

# A transliterator which accepts a Hash of characters as its translation
# rule.
class I18n::Backend::Transliterator::HashTransliterator
  # @return [HashTransliterator] a new instance of HashTransliterator
  def initialize(rule = T.unsafe(nil)); end

  def transliterate(string, replacement = T.unsafe(nil)); end

  private

  # Add transliteration rules to the approximations hash.
  def add(hash); end

  def add_default_approximations; end
  def approximations; end
end

I18n::Backend::Transliterator::HashTransliterator::DEFAULT_APPROXIMATIONS = T.let(T.unsafe(nil), Hash)

# A transliterator which accepts a Proc as its transliteration rule.
class I18n::Backend::Transliterator::ProcTransliterator
  # @return [ProcTransliterator] a new instance of ProcTransliterator
  def initialize(rule); end

  def transliterate(string, replacement = T.unsafe(nil)); end
end

module I18n::Base
  def available_locales; end
  def available_locales=(value); end

  # @return [Boolean]
  def available_locales_initialized?; end

  def backend; end
  def backend=(value); end

  # Gets I18n configuration object.
  def config; end

  # Sets I18n configuration object.
  def config=(value); end

  def default_locale; end
  def default_locale=(value); end
  def default_separator; end
  def default_separator=(value); end

  # Tells the backend to load translations now. Used in situations like the
  # Rails production environment. Backends can implement whatever strategy
  # is useful.
  def eager_load!; end

  def enforce_available_locales; end

  # Raises an InvalidLocale exception when the passed locale is not available.
  def enforce_available_locales!(locale); end

  def enforce_available_locales=(value); end
  def exception_handler; end
  def exception_handler=(value); end

  # Returns true if a translation exists for a given key, otherwise returns false.
  #
  # @raise [Disabled]
  # @return [Boolean]
  def exists?(key, _locale = T.unsafe(nil), locale: T.unsafe(nil), **options); end

  # Localizes certain objects, such as dates and numbers to local formatting.
  #
  # @raise [Disabled]
  def l(object, locale: T.unsafe(nil), format: T.unsafe(nil), **options); end

  def load_path; end
  def load_path=(value); end
  def locale; end
  def locale=(value); end

  # Returns true when the passed locale, which can be either a String or a
  # Symbol, is in the list of available locales. Returns false otherwise.
  #
  # @return [Boolean]
  def locale_available?(locale); end

  # Localizes certain objects, such as dates and numbers to local formatting.
  #
  # @raise [Disabled]
  def localize(object, locale: T.unsafe(nil), format: T.unsafe(nil), **options); end

  # Merges the given locale, key and scope into a single array of keys.
  # Splits keys that contain dots into multiple keys. Makes sure all
  # keys are Symbols.
  def normalize_keys(locale, key, scope, separator = T.unsafe(nil)); end

  # Tells the backend to reload translations. Used in situations like the
  # Rails development environment. Backends can implement whatever strategy
  # is useful.
  def reload!; end

  # Translates, pluralizes and interpolates a given key using a given locale,
  # scope, and default, as well as interpolation values.
  #
  # *LOOKUP*
  #
  # Translation data is organized as a nested hash using the upper-level keys
  # as namespaces. <em>E.g.</em>, ActionView ships with the translation:
  # <tt>:date => {:formats => {:short => "%b %d"}}</tt>.
  #
  # Translations can be looked up at any level of this hash using the key argument
  # and the scope option. <em>E.g.</em>, in this example <tt>I18n.t :date</tt>
  # returns the whole translations hash <tt>{:formats => {:short => "%b %d"}}</tt>.
  #
  # Key can be either a single key or a dot-separated key (both Strings and Symbols
  # work). <em>E.g.</em>, the short format can be looked up using both:
  #   I18n.t 'date.formats.short'
  #   I18n.t :'date.formats.short'
  #
  # Scope can be either a single key, a dot-separated key or an array of keys
  # or dot-separated keys. Keys and scopes can be combined freely. So these
  # examples will all look up the same short date format:
  #   I18n.t 'date.formats.short'
  #   I18n.t 'formats.short', :scope => 'date'
  #   I18n.t 'short', :scope => 'date.formats'
  #   I18n.t 'short', :scope => %w(date formats)
  #
  # *INTERPOLATION*
  #
  # Translations can contain interpolation variables which will be replaced by
  # values passed to #translate as part of the options hash, with the keys matching
  # the interpolation variable names.
  #
  # <em>E.g.</em>, with a translation <tt>:foo => "foo %{bar}"</tt> the option
  # value for the key +bar+ will be interpolated into the translation:
  #   I18n.t :foo, :bar => 'baz' # => 'foo baz'
  #
  # *PLURALIZATION*
  #
  # Translation data can contain pluralized translations. Pluralized translations
  # are arrays of singular/plural versions of translations like <tt>['Foo', 'Foos']</tt>.
  #
  # Note that <tt>I18n::Backend::Simple</tt> only supports an algorithm for English
  # pluralization rules. Other algorithms can be supported by custom backends.
  #
  # This returns the singular version of a pluralized translation:
  #   I18n.t :foo, :count => 1 # => 'Foo'
  #
  # These both return the plural version of a pluralized translation:
  #   I18n.t :foo, :count => 0 # => 'Foos'
  #   I18n.t :foo, :count => 2 # => 'Foos'
  #
  # The <tt>:count</tt> option can be used both for pluralization and interpolation.
  # <em>E.g.</em>, with the translation
  # <tt>:foo => ['%{count} foo', '%{count} foos']</tt>, count will
  # be interpolated to the pluralized translation:
  #   I18n.t :foo, :count => 1 # => '1 foo'
  #
  # *DEFAULTS*
  #
  # This returns the translation for <tt>:foo</tt> or <tt>default</tt> if no translation was found:
  #   I18n.t :foo, :default => 'default'
  #
  # This returns the translation for <tt>:foo</tt> or the translation for <tt>:bar</tt> if no
  # translation for <tt>:foo</tt> was found:
  #   I18n.t :foo, :default => :bar
  #
  # Returns the translation for <tt>:foo</tt> or the translation for <tt>:bar</tt>
  # or <tt>default</tt> if no translations for <tt>:foo</tt> and <tt>:bar</tt> were found.
  #   I18n.t :foo, :default => [:bar, 'default']
  #
  # *BULK LOOKUP*
  #
  # This returns an array with the translations for <tt>:foo</tt> and <tt>:bar</tt>.
  #   I18n.t [:foo, :bar]
  #
  # Can be used with dot-separated nested keys:
  #   I18n.t [:'baz.foo', :'baz.bar']
  #
  # Which is the same as using a scope option:
  #   I18n.t [:foo, :bar], :scope => :baz
  #
  # *LAMBDAS*
  #
  # Both translations and defaults can be given as Ruby lambdas. Lambdas will be
  # called and passed the key and options.
  #
  # E.g. assuming the key <tt>:salutation</tt> resolves to:
  #   lambda { |key, options| options[:gender] == 'm' ? "Mr. #{options[:name]}" : "Mrs. #{options[:name]}" }
  #
  # Then <tt>I18n.t(:salutation, :gender => 'w', :name => 'Smith') will result in "Mrs. Smith".
  #
  # Note that the string returned by lambda will go through string interpolation too,
  # so the following lambda would give the same result:
  #   lambda { |key, options| options[:gender] == 'm' ? "Mr. %{name}" : "Mrs. %{name}" }
  #
  # It is recommended to use/implement lambdas in an "idempotent" way. E.g. when
  # a cache layer is put in front of I18n.translate it will generate a cache key
  # from the argument values passed to #translate. Therefore your lambdas should
  # always return the same translations/values per unique combination of argument
  # values.
  #
  # *Ruby 2.7+ keyword arguments warning*
  #
  # This method uses keyword arguments.
  # There is a breaking change in ruby that produces warning with ruby 2.7 and won't work as expected with ruby 3.0
  # The "hash" parameter must be passed as keyword argument.
  #
  # Good:
  #  I18n.t(:salutation, :gender => 'w', :name => 'Smith')
  #  I18n.t(:salutation, **{ :gender => 'w', :name => 'Smith' })
  #  I18n.t(:salutation, **any_hash)
  #
  # Bad:
  #  I18n.t(:salutation, { :gender => 'w', :name => 'Smith' })
  #  I18n.t(:salutation, any_hash)
  #
  # @raise [Disabled]
  def t(key = T.unsafe(nil), throw: T.unsafe(nil), raise: T.unsafe(nil), locale: T.unsafe(nil), **options); end

  # Wrapper for <tt>translate</tt> that adds <tt>:raise => true</tt>. With
  # this option, if no translation is found, it will raise <tt>I18n::MissingTranslationData</tt>
  def t!(key, **options); end

  # Translates, pluralizes and interpolates a given key using a given locale,
  # scope, and default, as well as interpolation values.
  #
  # *LOOKUP*
  #
  # Translation data is organized as a nested hash using the upper-level keys
  # as namespaces. <em>E.g.</em>, ActionView ships with the translation:
  # <tt>:date => {:formats => {:short => "%b %d"}}</tt>.
  #
  # Translations can be looked up at any level of this hash using the key argument
  # and the scope option. <em>E.g.</em>, in this example <tt>I18n.t :date</tt>
  # returns the whole translations hash <tt>{:formats => {:short => "%b %d"}}</tt>.
  #
  # Key can be either a single key or a dot-separated key (both Strings and Symbols
  # work). <em>E.g.</em>, the short format can be looked up using both:
  #   I18n.t 'date.formats.short'
  #   I18n.t :'date.formats.short'
  #
  # Scope can be either a single key, a dot-separated key or an array of keys
  # or dot-separated keys. Keys and scopes can be combined freely. So these
  # examples will all look up the same short date format:
  #   I18n.t 'date.formats.short'
  #   I18n.t 'formats.short', :scope => 'date'
  #   I18n.t 'short', :scope => 'date.formats'
  #   I18n.t 'short', :scope => %w(date formats)
  #
  # *INTERPOLATION*
  #
  # Translations can contain interpolation variables which will be replaced by
  # values passed to #translate as part of the options hash, with the keys matching
  # the interpolation variable names.
  #
  # <em>E.g.</em>, with a translation <tt>:foo => "foo %{bar}"</tt> the option
  # value for the key +bar+ will be interpolated into the translation:
  #   I18n.t :foo, :bar => 'baz' # => 'foo baz'
  #
  # *PLURALIZATION*
  #
  # Translation data can contain pluralized translations. Pluralized translations
  # are arrays of singular/plural versions of translations like <tt>['Foo', 'Foos']</tt>.
  #
  # Note that <tt>I18n::Backend::Simple</tt> only supports an algorithm for English
  # pluralization rules. Other algorithms can be supported by custom backends.
  #
  # This returns the singular version of a pluralized translation:
  #   I18n.t :foo, :count => 1 # => 'Foo'
  #
  # These both return the plural version of a pluralized translation:
  #   I18n.t :foo, :count => 0 # => 'Foos'
  #   I18n.t :foo, :count => 2 # => 'Foos'
  #
  # The <tt>:count</tt> option can be used both for pluralization and interpolation.
  # <em>E.g.</em>, with the translation
  # <tt>:foo => ['%{count} foo', '%{count} foos']</tt>, count will
  # be interpolated to the pluralized translation:
  #   I18n.t :foo, :count => 1 # => '1 foo'
  #
  # *DEFAULTS*
  #
  # This returns the translation for <tt>:foo</tt> or <tt>default</tt> if no translation was found:
  #   I18n.t :foo, :default => 'default'
  #
  # This returns the translation for <tt>:foo</tt> or the translation for <tt>:bar</tt> if no
  # translation for <tt>:foo</tt> was found:
  #   I18n.t :foo, :default => :bar
  #
  # Returns the translation for <tt>:foo</tt> or the translation for <tt>:bar</tt>
  # or <tt>default</tt> if no translations for <tt>:foo</tt> and <tt>:bar</tt> were found.
  #   I18n.t :foo, :default => [:bar, 'default']
  #
  # *BULK LOOKUP*
  #
  # This returns an array with the translations for <tt>:foo</tt> and <tt>:bar</tt>.
  #   I18n.t [:foo, :bar]
  #
  # Can be used with dot-separated nested keys:
  #   I18n.t [:'baz.foo', :'baz.bar']
  #
  # Which is the same as using a scope option:
  #   I18n.t [:foo, :bar], :scope => :baz
  #
  # *LAMBDAS*
  #
  # Both translations and defaults can be given as Ruby lambdas. Lambdas will be
  # called and passed the key and options.
  #
  # E.g. assuming the key <tt>:salutation</tt> resolves to:
  #   lambda { |key, options| options[:gender] == 'm' ? "Mr. #{options[:name]}" : "Mrs. #{options[:name]}" }
  #
  # Then <tt>I18n.t(:salutation, :gender => 'w', :name => 'Smith') will result in "Mrs. Smith".
  #
  # Note that the string returned by lambda will go through string interpolation too,
  # so the following lambda would give the same result:
  #   lambda { |key, options| options[:gender] == 'm' ? "Mr. %{name}" : "Mrs. %{name}" }
  #
  # It is recommended to use/implement lambdas in an "idempotent" way. E.g. when
  # a cache layer is put in front of I18n.translate it will generate a cache key
  # from the argument values passed to #translate. Therefore your lambdas should
  # always return the same translations/values per unique combination of argument
  # values.
  #
  # *Ruby 2.7+ keyword arguments warning*
  #
  # This method uses keyword arguments.
  # There is a breaking change in ruby that produces warning with ruby 2.7 and won't work as expected with ruby 3.0
  # The "hash" parameter must be passed as keyword argument.
  #
  # Good:
  #  I18n.t(:salutation, :gender => 'w', :name => 'Smith')
  #  I18n.t(:salutation, **{ :gender => 'w', :name => 'Smith' })
  #  I18n.t(:salutation, **any_hash)
  #
  # Bad:
  #  I18n.t(:salutation, { :gender => 'w', :name => 'Smith' })
  #  I18n.t(:salutation, any_hash)
  #
  # @raise [Disabled]
  def translate(key = T.unsafe(nil), throw: T.unsafe(nil), raise: T.unsafe(nil), locale: T.unsafe(nil), **options); end

  # Wrapper for <tt>translate</tt> that adds <tt>:raise => true</tt>. With
  # this option, if no translation is found, it will raise <tt>I18n::MissingTranslationData</tt>
  def translate!(key, **options); end

  # Transliterates UTF-8 characters to ASCII. By default this method will
  # transliterate only Latin strings to an ASCII approximation:
  #
  #    I18n.transliterate("Ærøskøbing")
  #    # => "AEroskobing"
  #
  #    I18n.transliterate("日本語")
  #    # => "???"
  #
  # It's also possible to add support for per-locale transliterations. I18n
  # expects transliteration rules to be stored at
  # <tt>i18n.transliterate.rule</tt>.
  #
  # Transliteration rules can either be a Hash or a Proc. Procs must accept a
  # single string argument. Hash rules inherit the default transliteration
  # rules, while Procs do not.
  #
  # *Examples*
  #
  # Setting a Hash in <locale>.yml:
  #
  #    i18n:
  #      transliterate:
  #        rule:
  #          ü: "ue"
  #          ö: "oe"
  #
  # Setting a Hash using Ruby:
  #
  #     store_translations(:de, i18n: {
  #                          transliterate: {
  #                            rule: {
  #                              'ü' => 'ue',
  #                              'ö' => 'oe'
  #                            }
  #                          }
  #                        })
  #
  # Setting a Proc:
  #
  #     translit = lambda {|string| MyTransliterator.transliterate(string) }
  #     store_translations(:xx, :i18n => {:transliterate => {:rule => translit})
  #
  # Transliterating strings:
  #
  #     I18n.locale = :en
  #     I18n.transliterate("Jürgen") # => "Jurgen"
  #     I18n.locale = :de
  #     I18n.transliterate("Jürgen") # => "Juergen"
  #     I18n.transliterate("Jürgen", :locale => :en) # => "Jurgen"
  #     I18n.transliterate("Jürgen", :locale => :de) # => "Juergen"
  def transliterate(key, throw: T.unsafe(nil), raise: T.unsafe(nil), locale: T.unsafe(nil), replacement: T.unsafe(nil), **options); end

  # Executes block with given I18n.locale set.
  def with_locale(tmp_locale = T.unsafe(nil)); end

  private

  # Any exceptions thrown in translate will be sent to the @@exception_handler
  # which can be a Symbol, a Proc or any other Object unless they're forced to
  # be raised or thrown (MissingTranslation).
  #
  # If exception_handler is a Symbol then it will simply be sent to I18n as
  # a method call. A Proc will simply be called. In any other case the
  # method #call will be called on the exception_handler object.
  #
  # Examples:
  #
  #   I18n.exception_handler = :custom_exception_handler              # this is the default
  #   I18n.custom_exception_handler(exception, locale, key, options)  # will be called like this
  #
  #   I18n.exception_handler = lambda { |*args| ... }                 # a lambda
  #   I18n.exception_handler.call(exception, locale, key, options)    # will be called like this
  #
  #   I18n.exception_handler = I18nExceptionHandler.new               # an object
  #   I18n.exception_handler.call(exception, locale, key, options)    # will be called like this
  def handle_exception(handling, exception, locale, key, options); end

  def normalize_key(key, separator); end
end

class I18n::Config
  # Returns an array of locales for which translations are available.
  # Unless you explicitely set these through I18n.available_locales=
  # the call will be delegated to the backend.
  def available_locales; end

  # Sets the available locales.
  def available_locales=(locales); end

  # Returns true if the available_locales have been initialized
  #
  # @return [Boolean]
  def available_locales_initialized?; end

  # Caches the available locales list as both strings and symbols in a Set, so
  # that we can have faster lookups to do the available locales enforce check.
  def available_locales_set; end

  # Returns the current backend. Defaults to +Backend::Simple+.
  def backend; end

  # Sets the current backend. Used to set a custom backend.
  def backend=(backend); end

  # Clears the available locales set so it can be recomputed again after I18n
  # gets reloaded.
  def clear_available_locales_set; end

  # Returns the current default locale. Defaults to :'en'
  def default_locale; end

  # Sets the current default locale. Used to set a custom default locale.
  def default_locale=(locale); end

  # Returns the current default scope separator. Defaults to '.'
  def default_separator; end

  # Sets the current default scope separator.
  def default_separator=(separator); end

  def enforce_available_locales; end
  def enforce_available_locales=(enforce_available_locales); end

  # Returns the current exception handler. Defaults to an instance of
  # I18n::ExceptionHandler.
  def exception_handler; end

  # Sets the exception handler.
  def exception_handler=(exception_handler); end

  # Returns the current interpolation patterns. Defaults to
  # I18n::DEFAULT_INTERPOLATION_PATTERNS.
  def interpolation_patterns; end

  # Sets the current interpolation patterns. Used to set a interpolation
  # patterns.
  #
  # E.g. using {{}} as a placeholder like "{{hello}}, world!":
  #
  #   I18n.config.interpolation_patterns << /\{\{(\w+)\}\}/
  def interpolation_patterns=(interpolation_patterns); end

  # Allow clients to register paths providing translation data sources. The
  # backend defines acceptable sources.
  #
  # E.g. the provided SimpleBackend accepts a list of paths to translation
  # files which are either named *.rb and contain plain Ruby Hashes or are
  # named *.yml and contain YAML data. So for the SimpleBackend clients may
  # register translation files like this:
  #   I18n.load_path << 'path/to/locale/en.yml'
  def load_path; end

  # Sets the load path instance. Custom implementations are expected to
  # behave like a Ruby Array.
  def load_path=(load_path); end

  # The only configuration value that is not global and scoped to thread is :locale.
  # It defaults to the default_locale.
  def locale; end

  # Sets the current locale pseudo-globally, i.e. in the Thread.current hash.
  def locale=(locale); end

  # Returns the current handler for situations when interpolation argument
  # is missing. MissingInterpolationArgument will be raised by default.
  def missing_interpolation_argument_handler; end

  # Sets the missing interpolation argument handler. It can be any
  # object that responds to #call. The arguments that will be passed to #call
  # are the same as for MissingInterpolationArgument initializer. Use +Proc.new+
  # if you don't care about arity.
  #
  # == Example:
  # You can supress raising an exception and return string instead:
  #
  #   I18n.config.missing_interpolation_argument_handler = Proc.new do |key|
  #     "#{key} is missing"
  #   end
  def missing_interpolation_argument_handler=(exception_handler); end
end

I18n::DEFAULT_INTERPOLATION_PATTERNS = T.let(T.unsafe(nil), Array)

class I18n::Disabled < ::I18n::ArgumentError
  # @return [Disabled] a new instance of Disabled
  def initialize(method); end
end

I18n::EMPTY_HASH = T.let(T.unsafe(nil), Hash)

class I18n::ExceptionHandler
  def call(exception, _locale, _key, _options); end
end

module I18n::Gettext
  class << self
    def extract_scope(msgid, separator); end

    # returns an array of plural keys for the given locale or the whole hash
    # of locale mappings to plural keys so that we can convert from gettext's
    # integer-index based style
    # TODO move this information to the pluralization module
    def plural_keys(*args); end
  end
end

I18n::Gettext::CONTEXT_SEPARATOR = T.let(T.unsafe(nil), String)

# Implements classical Gettext style accessors. To use this include the
# module to the global namespace or wherever you want to use it.
#
#   include I18n::Gettext::Helpers
module I18n::Gettext::Helpers
  # Makes dynamic translation messages readable for the gettext parser.
  # <tt>_(fruit)</tt> cannot be understood by the gettext parser. To help the parser find all your translations,
  # you can add <tt>fruit = N_("Apple")</tt> which does not translate, but tells the parser: "Apple" needs translation.
  # * msgid: the message id.
  # * Returns: msgid.
  def N_(msgsid); end

  def _(msgid, options = T.unsafe(nil)); end
  def gettext(msgid, options = T.unsafe(nil)); end
  def n_(msgid, msgid_plural, n = T.unsafe(nil)); end
  def ngettext(msgid, msgid_plural, n = T.unsafe(nil)); end

  # Method signatures:
  #   npgettext('Fruits', 'apple', 'apples', 2)
  #   npgettext('Fruits', ['apple', 'apples'], 2)
  def np_(msgctxt, msgid, msgid_plural, n = T.unsafe(nil)); end

  # Method signatures:
  #   npgettext('Fruits', 'apple', 'apples', 2)
  #   npgettext('Fruits', ['apple', 'apples'], 2)
  def npgettext(msgctxt, msgid, msgid_plural, n = T.unsafe(nil)); end

  # Method signatures:
  #   nsgettext('Fruits|apple', 'apples', 2)
  #   nsgettext(['Fruits|apple', 'apples'], 2)
  def ns_(msgid, msgid_plural, n = T.unsafe(nil), separator = T.unsafe(nil)); end

  # Method signatures:
  #   nsgettext('Fruits|apple', 'apples', 2)
  #   nsgettext(['Fruits|apple', 'apples'], 2)
  def nsgettext(msgid, msgid_plural, n = T.unsafe(nil), separator = T.unsafe(nil)); end

  def p_(msgctxt, msgid); end
  def pgettext(msgctxt, msgid); end
  def s_(msgid, separator = T.unsafe(nil)); end
  def sgettext(msgid, separator = T.unsafe(nil)); end
end

I18n::Gettext::PLURAL_SEPARATOR = T.let(T.unsafe(nil), String)
I18n::INTERPOLATION_PATTERN = T.let(T.unsafe(nil), Regexp)

class I18n::InvalidFilenames < ::I18n::ArgumentError
  # @return [InvalidFilenames] a new instance of InvalidFilenames
  def initialize(file_errors); end
end

I18n::InvalidFilenames::NUMBER_OF_ERRORS_SHOWN = T.let(T.unsafe(nil), Integer)

class I18n::InvalidLocale < ::I18n::ArgumentError
  # @return [InvalidLocale] a new instance of InvalidLocale
  def initialize(locale); end

  # Returns the value of attribute locale.
  def locale; end
end

class I18n::InvalidLocaleData < ::I18n::ArgumentError
  # @return [InvalidLocaleData] a new instance of InvalidLocaleData
  def initialize(filename, exception_message); end

  # Returns the value of attribute filename.
  def filename; end
end

class I18n::InvalidPluralizationData < ::I18n::ArgumentError
  # @return [InvalidPluralizationData] a new instance of InvalidPluralizationData
  def initialize(entry, count, key); end

  # Returns the value of attribute count.
  def count; end

  # Returns the value of attribute entry.
  def entry; end

  # Returns the value of attribute key.
  def key; end
end

I18n::JSON = ActiveSupport::JSON
module I18n::Locale; end

class I18n::Locale::Fallbacks < ::Hash
  # @return [Fallbacks] a new instance of Fallbacks
  def initialize(*mappings); end

  # @raise [InvalidLocale]
  def [](locale); end

  # Returns the value of attribute defaults.
  def defaults; end

  def defaults=(defaults); end
  def map(*args, &block); end

  protected

  def compute(tags, include_defaults = T.unsafe(nil), exclude = T.unsafe(nil)); end
end

module I18n::Locale::Tag
  class << self
    # Returns the current locale tag implementation. Defaults to +I18n::Locale::Tag::Simple+.
    def implementation; end

    # Sets the current locale tag implementation. Use this to set a different locale tag implementation.
    def implementation=(implementation); end

    # Factory method for locale tags. Delegates to the current locale tag implementation.
    def tag(tag); end
  end
end

module I18n::Locale::Tag::Parents
  def parent; end
  def parents; end
  def self_and_parents; end
end

I18n::Locale::Tag::RFC4646_FORMATS = T.let(T.unsafe(nil), Hash)
I18n::Locale::Tag::RFC4646_SUBTAGS = T.let(T.unsafe(nil), Array)

class I18n::Locale::Tag::Rfc4646 < ::Struct
  include ::I18n::Locale::Tag::Parents

  def language; end
  def region; end
  def script; end
  def to_a; end
  def to_s; end
  def to_sym; end
  def variant; end

  class << self
    def parser; end
    def parser=(parser); end

    # Parses the given tag and returns a Tag instance if it is valid.
    # Returns false if the given tag is not valid according to RFC 4646.
    def tag(tag); end
  end
end

module I18n::Locale::Tag::Rfc4646::Parser
  class << self
    def match(tag); end
  end
end

I18n::Locale::Tag::Rfc4646::Parser::PATTERN = T.let(T.unsafe(nil), Regexp)

class I18n::Locale::Tag::Simple
  include ::I18n::Locale::Tag::Parents

  # @return [Simple] a new instance of Simple
  def initialize(*tag); end

  def subtags; end

  # Returns the value of attribute tag.
  def tag; end

  def to_a; end
  def to_s; end
  def to_sym; end

  class << self
    def tag(tag); end
  end
end

class I18n::Middleware
  # @return [Middleware] a new instance of Middleware
  def initialize(app); end

  def call(env); end
end

class I18n::MissingInterpolationArgument < ::I18n::ArgumentError
  # @return [MissingInterpolationArgument] a new instance of MissingInterpolationArgument
  def initialize(key, values, string); end

  # Returns the value of attribute key.
  def key; end

  # Returns the value of attribute string.
  def string; end

  # Returns the value of attribute values.
  def values; end
end

class I18n::MissingTranslation < ::I18n::ArgumentError
  include ::I18n::MissingTranslation::Base
end

module I18n::MissingTranslation::Base
  def initialize(locale, key, options = T.unsafe(nil)); end

  # Returns the value of attribute key.
  def key; end

  def keys; end

  # Returns the value of attribute locale.
  def locale; end

  def message; end

  # Returns the value of attribute options.
  def options; end

  def to_exception; end
  def to_s; end
end

I18n::MissingTranslation::Base::PERMITTED_KEYS = T.let(T.unsafe(nil), Array)

class I18n::MissingTranslationData < ::I18n::ArgumentError
  include ::I18n::MissingTranslation::Base
end

I18n::RESERVED_KEYS = T.let(T.unsafe(nil), Array)

class I18n::ReservedInterpolationKey < ::I18n::ArgumentError
  # @return [ReservedInterpolationKey] a new instance of ReservedInterpolationKey
  def initialize(key, string); end

  # Returns the value of attribute key.
  def key; end

  # Returns the value of attribute string.
  def string; end
end

module I18n::Tests; end

module I18n::Tests::Localization
  class << self
    # @private
    def included(base); end
  end
end

class I18n::UnknownFileType < ::I18n::ArgumentError
  # @return [UnknownFileType] a new instance of UnknownFileType
  def initialize(type, filename); end

  # Returns the value of attribute filename.
  def filename; end

  # Returns the value of attribute type.
  def type; end
end

class I18n::UnsupportedMethod < ::I18n::ArgumentError
  # @return [UnsupportedMethod] a new instance of UnsupportedMethod
  def initialize(method, backend_klass, msg); end

  # Returns the value of attribute backend_klass.
  def backend_klass; end

  # Returns the value of attribute method.
  def method; end

  # Returns the value of attribute msg.
  def msg; end
end

module I18n::Utils
  class << self
    def deep_merge(hash, other_hash, &block); end
    def deep_merge!(hash, other_hash, &block); end
    def deep_symbolize_keys(hash); end
    def except(hash, *keys); end

    private

    def deep_symbolize_keys_in_object(value); end
  end
end

I18n::VERSION = T.let(T.unsafe(nil), String)
