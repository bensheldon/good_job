# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `puma` gem.
# Please instead update this file by running `bin/tapioca gem puma`.


# source://puma//lib/puma/detect.rb#7
module Puma
  class << self
    # @return [Boolean]
    #
    # source://puma//lib/puma.rb#45
    def abstract_unix_socket?; end

    # Shows deprecated warning for renamed methods.
    #
    # @example
    #   Puma.deprecate_method_change :on_booted, __callee__, __method__
    #
    # source://puma//lib/puma.rb#83
    def deprecate_method_change(method_old, method_caller, method_new); end

    # @return [Boolean]
    # @version 5.0.0
    #
    # source://puma//lib/puma/detect.rb#44
    def forkable?; end

    # @return [Boolean]
    #
    # source://puma//lib/puma/detect.rb#26
    def jruby?; end

    # @return [Boolean]
    # @version 5.0.0
    #
    # source://puma//lib/puma/detect.rb#39
    def mri?; end

    # @return [Boolean]
    #
    # source://puma//lib/puma/detect.rb#30
    def osx?; end

    # source://puma//lib/puma.rb#75
    def set_thread_name(name); end

    # @return [Boolean]
    #
    # source://puma//lib/puma.rb#41
    def ssl?; end

    # source://puma//lib/puma.rb#65
    def stats; end

    # @version 5.0.0
    #
    # source://puma//lib/puma.rb#71
    def stats_hash; end

    # source://puma//lib/puma.rb#60
    def stats_object=(val); end

    # @return [Boolean]
    #
    # source://puma//lib/puma/detect.rb#34
    def windows?; end
  end
end

# source://puma//lib/puma/binder.rb#16
class Puma::Binder
  include ::Puma::Const

  # @return [Binder] a new instance of Binder
  #
  # source://puma//lib/puma/binder.rb#21
  def initialize(log_writer, options, env: T.unsafe(nil)); end

  # @version 5.0.0
  #
  # source://puma//lib/puma/binder.rb#59
  def activated_sockets; end

  # source://puma//lib/puma/binder.rb#363
  def add_ssl_listener(host, port, ctx, optimize_for_latency = T.unsafe(nil), backlog = T.unsafe(nil)); end

  # Tell the server to listen on host +host+, port +port+.
  # If +optimize_for_latency+ is true (the default) then clients connecting
  # will be optimized for latency over throughput.
  #
  # +backlog+ indicates how many unaccepted connections the kernel should
  # allow to accumulate before returning connection refused.
  #
  # source://puma//lib/puma/binder.rb#335
  def add_tcp_listener(host, port, optimize_for_latency = T.unsafe(nil), backlog = T.unsafe(nil)); end

  # Tell the server to listen on +path+ as a UNIX domain socket.
  #
  # source://puma//lib/puma/binder.rb#414
  def add_unix_listener(path, umask = T.unsafe(nil), mode = T.unsafe(nil), backlog = T.unsafe(nil)); end

  # source://puma//lib/puma/binder.rb#147
  def before_parse(&block); end

  # source://puma//lib/puma/binder.rb#68
  def close; end

  # source://puma//lib/puma/binder.rb#461
  def close_listeners; end

  # @version 5.0.0
  #
  # source://puma//lib/puma/binder.rb#74
  def connected_ports; end

  # systemd socket activation.
  # LISTEN_FDS = number of listening sockets. e.g. 2 means accept on 2 sockets w/descriptors 3 and 4.
  # LISTEN_PID = PID of the service process, aka us
  #
  # @see https://www.freedesktop.org/software/systemd/man/systemd-socket-activate.html
  # @version 5.0.0
  #
  # source://puma//lib/puma/binder.rb#92
  def create_activated_fds(env_hash); end

  # @version 5.0.0
  #
  # source://puma//lib/puma/binder.rb#79
  def create_inherited_fds(env_hash); end

  # source://puma//lib/puma/binder.rb#64
  def env(sock); end

  # @version 5.0.0
  #
  # source://puma//lib/puma/binder.rb#59
  def envs; end

  # source://puma//lib/puma/binder.rb#394
  def inherit_ssl_listener(fd, ctx); end

  # source://puma//lib/puma/binder.rb#356
  def inherit_tcp_listener(host, port, fd); end

  # source://puma//lib/puma/binder.rb#449
  def inherit_unix_listener(path, fd); end

  # @version 5.0.0
  #
  # source://puma//lib/puma/binder.rb#59
  def inherited_fds; end

  # Returns the value of attribute ios.
  #
  # source://puma//lib/puma/binder.rb#56
  def ios; end

  # @version 5.0.0
  #
  # source://puma//lib/puma/binder.rb#62
  def ios=(_arg0); end

  # @version 5.0.0
  #
  # source://puma//lib/puma/binder.rb#59
  def listeners; end

  # @version 5.0.0
  #
  # source://puma//lib/puma/binder.rb#62
  def listeners=(_arg0); end

  # source://puma//lib/puma/binder.rb#312
  def localhost_authority; end

  # source://puma//lib/puma/binder.rb#316
  def localhost_authority_context; end

  # source://puma//lib/puma/binder.rb#153
  def parse(binds, log_writer = T.unsafe(nil), log_msg = T.unsafe(nil)); end

  # @version 5.0.0
  #
  # source://puma//lib/puma/binder.rb#59
  def proto_env; end

  # source://puma//lib/puma/binder.rb#474
  def redirects_for_restart; end

  # @version 5.0.0
  #
  # source://puma//lib/puma/binder.rb#481
  def redirects_for_restart_env; end

  # Synthesize binds from systemd socket activation
  #
  # When systemd socket activation is enabled, it can be tedious to keep the
  # binds in sync. This method can synthesize any binds based on the received
  # activated sockets. Any existing matching binds will be respected.
  #
  # When only_matching is true in, all binds that do not match an activated
  # socket is removed in place.
  #
  # It's a noop if no activated sockets were received.
  #
  # source://puma//lib/puma/binder.rb#120
  def synthesize_binds_from_activated_fs(binds, only_matching); end

  # @version 5.0.0
  #
  # source://puma//lib/puma/binder.rb#59
  def unix_paths; end

  private

  # source://puma//lib/puma/binder.rb#497
  def loc_addr_str(io); end

  # source://puma//lib/puma/binder.rb#490
  def loopback_addresses; end

  # @version 5.0.0
  #
  # source://puma//lib/puma/binder.rb#507
  def socket_activation_fd(int); end
end

# source://puma//lib/puma/binder.rb#19
Puma::Binder::RACK_VERSION = T.let(T.unsafe(nil), Array)

# An instance of this class represents a unique request from a client.
# For example, this could be a web request from a browser or from CURL.
#
# An instance of `Puma::Client` can be used as if it were an IO object
# by the reactor. The reactor is expected to call `#to_io`
# on any non-IO objects it polls. For example, nio4r internally calls
# `IO::try_convert` (which may call `#to_io`) when a new socket is
# registered.
#
# Instances of this class are responsible for knowing if
# the header and body are fully buffered via the `try_to_finish` method.
# They can be used to "time out" a response via the `timeout_at` reader.
#
# source://puma//lib/puma/client.rb#36
class Puma::Client
  include ::Puma::Const

  # @return [Client] a new instance of Client
  #
  # source://puma//lib/puma/client.rb#70
  def initialize(io, env = T.unsafe(nil)); end

  # Returns the value of attribute body.
  #
  # source://puma//lib/puma/client.rb#110
  def body; end

  # Returns true if the persistent connection can be closed immediately
  # without waiting for the configured idle/shutdown timeout.
  #
  # @return [Boolean]
  # @version 5.0.0
  #
  # source://puma//lib/puma/client.rb#378
  def can_close?; end

  # source://puma//lib/puma/client.rb#192
  def close; end

  # Remove in Puma 7?
  #
  # @return [Boolean]
  #
  # source://puma//lib/puma/client.rb#119
  def closed?; end

  # source://puma//lib/puma/client.rb#289
  def eagerly_finish; end

  # Returns the value of attribute env.
  #
  # source://puma//lib/puma/client.rb#110
  def env; end

  # source://puma//lib/puma/client.rb#383
  def expect_proxy_proto=(val); end

  # source://puma//lib/puma/client.rb#297
  def finish(timeout); end

  # For the full hijack protocol, `env['rack.hijack']` is set to
  # `client.method :full_hijack`
  #
  # source://puma//lib/puma/client.rb#136
  def full_hijack; end

  # if a client sends back-to-back requests, the buffer may contain one or more
  # of them.
  #
  # @return [Boolean]
  #
  # source://puma//lib/puma/client.rb#188
  def has_back_to_back_requests?; end

  # Returns the value of attribute hijacked.
  #
  # source://puma//lib/puma/client.rb#110
  def hijacked; end

  # Sets the attribute http_content_length_limit
  #
  # @param value the value to set the attribute http_content_length_limit to.
  #
  # source://puma//lib/puma/client.rb#114
  def http_content_length_limit=(_arg0); end

  # Returns the value of attribute http_content_length_limit_exceeded.
  #
  # source://puma//lib/puma/client.rb#110
  def http_content_length_limit_exceeded; end

  # source://puma//lib/puma/client.rb#142
  def in_data_phase; end

  # source://puma//lib/puma/client.rb#130
  def inspect; end

  # Returns the value of attribute io.
  #
  # source://puma//lib/puma/client.rb#110
  def io; end

  # Returns the value of attribute io_buffer.
  #
  # source://puma//lib/puma/client.rb#110
  def io_buffer; end

  # Test to see if io meets a bare minimum of functioning, @to_io needs to be
  # used for MiniSSL::Socket
  #
  # @return [Boolean]
  #
  # source://puma//lib/puma/client.rb#125
  def io_ok?; end

  # Returns the value of attribute listener.
  #
  # source://puma//lib/puma/client.rb#116
  def listener; end

  # Sets the attribute listener
  #
  # @param value the value to set the attribute listener to.
  #
  # source://puma//lib/puma/client.rb#116
  def listener=(_arg0); end

  # Wraps `@parser.execute` and adds meaningful error messages
  #
  # @return [Integer] bytes of buffer read by parser
  #
  # source://puma//lib/puma/client.rb#305
  def parser_execute; end

  # source://puma//lib/puma/client.rb#364
  def peer_family; end

  # source://puma//lib/puma/client.rb#352
  def peerip; end

  # Sets the attribute peerip
  #
  # @param value the value to set the attribute peerip to.
  #
  # source://puma//lib/puma/client.rb#114
  def peerip=(_arg0); end

  # only used with back-to-back requests contained in the buffer
  #
  # source://puma//lib/puma/client.rb#171
  def process_back_to_back_requests; end

  # Returns the value of attribute ready.
  #
  # source://puma//lib/puma/client.rb#110
  def ready; end

  # Returns the value of attribute remote_addr_header.
  #
  # source://puma//lib/puma/client.rb#116
  def remote_addr_header; end

  # Sets the attribute remote_addr_header
  #
  # @param value the value to set the attribute remote_addr_header to.
  #
  # source://puma//lib/puma/client.rb#116
  def remote_addr_header=(_arg0); end

  # Returns the value of attribute requests_served.
  #
  # source://puma//lib/puma/client.rb#110
  def requests_served; end

  # source://puma//lib/puma/client.rb#156
  def reset; end

  # source://puma//lib/puma/client.rb#146
  def set_timeout(val); end

  # Returns the value of attribute tempfile.
  #
  # source://puma//lib/puma/client.rb#110
  def tempfile; end

  # source://puma//lib/puma/client.rb#200
  def tempfile_close; end

  # Number of seconds until the timeout elapses.
  #
  # source://puma//lib/puma/client.rb#152
  def timeout; end

  # @raise [ConnectionError]
  #
  # source://puma//lib/puma/client.rb#340
  def timeout!; end

  # Returns the value of attribute timeout_at.
  #
  # source://puma//lib/puma/client.rb#110
  def timeout_at; end

  # Returns the value of attribute to_io.
  #
  # source://puma//lib/puma/client.rb#110
  def to_io; end

  # source://puma//lib/puma/client.rb#233
  def try_to_finish; end

  # If necessary, read the PROXY protocol from the buffer. Returns
  # false if more data is needed.
  #
  # source://puma//lib/puma/client.rb#211
  def try_to_parse_proxy_protocol; end

  # source://puma//lib/puma/client.rb#345
  def write_error(status_code); end

  private

  # source://puma//lib/puma/client.rb#712
  def above_http_content_limit(value); end

  # source://puma//lib/puma/client.rb#583
  def decode_chunk(chunk); end

  # source://puma//lib/puma/client.rb#494
  def read_body; end

  # source://puma//lib/puma/client.rb#535
  def read_chunked_body; end

  # source://puma//lib/puma/client.rb#704
  def set_ready; end

  # source://puma//lib/puma/client.rb#396
  def setup_body; end

  # source://puma//lib/puma/client.rb#560
  def setup_chunked_body(body); end

  # @version 5.0.0
  #
  # source://puma//lib/puma/client.rb#579
  def write_chunk(str); end
end

# this tests all values but the last, which must be chunked
#
# source://puma//lib/puma/client.rb#39
Puma::Client::ALLOWED_TRANSFER_ENCODING = T.let(T.unsafe(nil), Array)

# chunked body validation
#
# source://puma//lib/puma/client.rb#42
Puma::Client::CHUNK_SIZE_INVALID = T.let(T.unsafe(nil), Regexp)

# source://puma//lib/puma/client.rb#43
Puma::Client::CHUNK_VALID_ENDING = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/client.rb#44
Puma::Client::CHUNK_VALID_ENDING_SIZE = T.let(T.unsafe(nil), Integer)

# Content-Length header value validation
#
# source://puma//lib/puma/client.rb#55
Puma::Client::CONTENT_LENGTH_VALUE_INVALID = T.let(T.unsafe(nil), Regexp)

# The object used for a request with no body. All requests with
# no body share this one object since it has no state.
#
# source://puma//lib/puma/client.rb#66
Puma::Client::EmptyBody = T.let(T.unsafe(nil), Puma::NullIO)

# The maximum amount of excess data the client sends
# using chunk size extensions before we abort the connection.
#
# source://puma//lib/puma/client.rb#52
Puma::Client::MAX_CHUNK_EXCESS = T.let(T.unsafe(nil), Integer)

# The maximum number of bytes we'll buffer looking for a valid
# chunk header.
#
# source://puma//lib/puma/client.rb#48
Puma::Client::MAX_CHUNK_HEADER_SIZE = T.let(T.unsafe(nil), Integer)

# See:
# https://httpwg.org/specs/rfc9110.html#rfc.section.5.6.1.1
# https://httpwg.org/specs/rfc9112.html#rfc.section.6.1
#
# source://puma//lib/puma/client.rb#62
Puma::Client::STRIP_OWS = T.let(T.unsafe(nil), Regexp)

# source://puma//lib/puma/client.rb#57
Puma::Client::TE_ERR_MSG = T.let(T.unsafe(nil), String)

# This class is instantiated by the `Puma::Launcher` and used
# to boot and serve a Ruby application when puma "workers" are needed
# i.e. when using multi-processes. For example `$ puma -w 5`
#
# An instance of this class will spawn the number of processes passed in
# via the `spawn_workers` method call. Each worker will have it's own
# instance of a `Puma::Server`.
#
# source://puma//lib/puma/cluster/worker_handle.rb#4
class Puma::Cluster < ::Puma::Runner
  # @return [Cluster] a new instance of Cluster
  #
  # source://puma//lib/puma/cluster.rb#18
  def initialize(launcher); end

  # @return [Boolean]
  #
  # source://puma//lib/puma/cluster.rb#162
  def all_workers_booted?; end

  # @return [Boolean]
  #
  # source://puma//lib/puma/cluster.rb#170
  def all_workers_idle_timed_out?; end

  # @return [Boolean]
  #
  # source://puma//lib/puma/cluster.rb#166
  def all_workers_in_phase?; end

  # source://puma//lib/puma/cluster.rb#174
  def check_workers(refork = T.unsafe(nil)); end

  # source://puma//lib/puma/cluster.rb#141
  def cull_start_index(diff); end

  # source://puma//lib/puma/cluster.rb#117
  def cull_workers; end

  # @version 5.0.0
  #
  # source://puma//lib/puma/cluster.rb#304
  def fork_worker!; end

  # source://puma//lib/puma/cluster.rb#259
  def halt; end

  # source://puma//lib/puma/cluster.rb#151
  def next_worker_index; end

  # source://puma//lib/puma/cluster.rb#238
  def phased_restart(refork = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://puma//lib/puma/cluster.rb#299
  def preload?; end

  # source://puma//lib/puma/cluster.rb#64
  def redirect_io; end

  # source://puma//lib/puma/cluster.rb#264
  def reload_worker_directory; end

  # source://puma//lib/puma/cluster.rb#233
  def restart; end

  # source://puma//lib/puma/cluster.rb#364
  def run; end

  # We do this in a separate method to keep the lambda scope
  # of the signals handlers as small as possible.
  #
  # source://puma//lib/puma/cluster.rb#313
  def setup_signals; end

  # @version 5.0.0
  #
  # source://puma//lib/puma/cluster.rb#103
  def spawn_worker(idx, master); end

  # source://puma//lib/puma/cluster.rb#70
  def spawn_workers; end

  # source://puma//lib/puma/cluster.rb#48
  def start_phased_restart(refork = T.unsafe(nil)); end

  # Inside of a child process, this will return all zeroes, as @workers is only populated in
  # the master process.  Calling this also resets stat 'max' values to zero.
  #
  # @return [Hash]
  #
  # source://puma//lib/puma/cluster.rb#275
  def stats; end

  # source://puma//lib/puma/cluster.rb#247
  def stop; end

  # source://puma//lib/puma/cluster.rb#252
  def stop_blocked; end

  # source://puma//lib/puma/cluster.rb#33
  def stop_workers; end

  # source://puma//lib/puma/cluster.rb#211
  def worker(index, master); end

  # source://puma//lib/puma/cluster.rb#158
  def worker_at(idx); end

  # Returns the list of cluster worker handles.
  #
  # @return [Array<Puma::Cluster::WorkerHandle>]
  #
  # source://puma//lib/puma/cluster.rb#31
  def workers; end

  # source://puma//lib/puma/cluster.rb#131
  def workers_to_cull(diff); end

  private

  # source://puma//lib/puma/cluster.rb#627
  def idle_timed_out_worker_pids; end

  # source://puma//lib/puma/cluster.rb#631
  def idle_workers; end

  # source://puma//lib/puma/cluster.rb#550
  def single_worker_warning; end

  # @version 5.0.0
  #
  # source://puma//lib/puma/cluster.rb#613
  def timeout_workers; end

  # loops thru @workers, removing workers that exited, and calling
  # `#term` if needed
  #
  # source://puma//lib/puma/cluster.rb#561
  def wait_workers; end
end

# This class is instantiated by the `Puma::Cluster` and represents a single
# worker process.
#
# At the core of this class is running an instance of `Puma::Server` which
# gets created via the `start_server` method from the `Puma::Runner` class
# that this inherits from.
#
# source://puma//lib/puma/cluster/worker.rb#14
class Puma::Cluster::Worker < ::Puma::Runner
  # @return [Worker] a new instance of Worker
  #
  # source://puma//lib/puma/cluster/worker.rb#17
  def initialize(index:, master:, launcher:, pipes:, server: T.unsafe(nil)); end

  # source://puma//lib/puma/cluster/worker.rb#15
  def index; end

  # source://puma//lib/puma/cluster/worker.rb#15
  def master; end

  # source://puma//lib/puma/cluster/worker.rb#30
  def run; end

  private

  # source://puma//lib/puma/cluster/worker.rb#158
  def spawn_worker(idx); end
end

# This class represents a worker process from the perspective of the puma
# master process. It contains information about the process and its health
# and it exposes methods to control the process via IPC. It does not
# include the actual logic executed by the worker process itself. For that,
# see Puma::Cluster::Worker.
#
# source://puma//lib/puma/cluster/worker_handle.rb#12
class Puma::Cluster::WorkerHandle
  # @return [WorkerHandle] a new instance of WorkerHandle
  #
  # source://puma//lib/puma/cluster/worker_handle.rb#16
  def initialize(idx, pid, phase, options); end

  # source://puma//lib/puma/cluster/worker_handle.rb#44
  def boot!; end

  # @return [Boolean]
  #
  # source://puma//lib/puma/cluster/worker_handle.rb#36
  def booted?; end

  # source://puma//lib/puma/cluster/worker_handle.rb#121
  def hup; end

  # Returns the value of attribute index.
  #
  # source://puma//lib/puma/cluster/worker_handle.rb#31
  def index; end

  # source://puma//lib/puma/cluster/worker_handle.rb#116
  def kill; end

  # Returns the value of attribute last_checkin.
  #
  # source://puma//lib/puma/cluster/worker_handle.rb#31
  def last_checkin; end

  # Returns the value of attribute last_status.
  #
  # source://puma//lib/puma/cluster/worker_handle.rb#31
  def last_status; end

  # Returns the value of attribute phase.
  #
  # source://puma//lib/puma/cluster/worker_handle.rb#31
  def phase; end

  # @version 5.0.0
  #
  # source://puma//lib/puma/cluster/worker_handle.rb#34
  def phase=(_arg0); end

  # Returns the value of attribute pid.
  #
  # source://puma//lib/puma/cluster/worker_handle.rb#31
  def pid; end

  # @version 5.0.0
  #
  # source://puma//lib/puma/cluster/worker_handle.rb#34
  def pid=(_arg0); end

  # source://puma//lib/puma/cluster/worker_handle.rb#57
  def ping!(status); end

  # @see Puma::Cluster#check_workers
  # @version 5.0.0
  #
  # source://puma//lib/puma/cluster/worker_handle.rb#95
  def ping_timeout; end

  # Returns the value of attribute process_status.
  #
  # source://puma//lib/puma/cluster/worker_handle.rb#31
  def process_status; end

  # @version 5.0.0
  #
  # source://puma//lib/puma/cluster/worker_handle.rb#34
  def process_status=(_arg0); end

  # Resets max values to zero.  Called whenever `Cluster#stats` is called
  #
  # source://puma//lib/puma/cluster/worker_handle.rb#89
  def reset_max; end

  # Returns the value of attribute signal.
  #
  # source://puma//lib/puma/cluster/worker_handle.rb#31
  def signal; end

  # Returns the value of attribute started_at.
  #
  # source://puma//lib/puma/cluster/worker_handle.rb#31
  def started_at; end

  # source://puma//lib/puma/cluster/worker_handle.rb#103
  def term; end

  # source://puma//lib/puma/cluster/worker_handle.rb#49
  def term!; end

  # @return [Boolean]
  #
  # source://puma//lib/puma/cluster/worker_handle.rb#53
  def term?; end

  # source://puma//lib/puma/cluster/worker_handle.rb#40
  def uptime; end
end

# array of stat 'max' keys
#
# source://puma//lib/puma/cluster/worker_handle.rb#14
Puma::Cluster::WorkerHandle::WORKER_MAX_KEYS = T.let(T.unsafe(nil), Array)

# Calculate a delay value for sleeping when running in clustered mode
#
# The main reason this is a class is so it can be unit tested independently.
# This makes modification easier in the future if we can encode properties of the
# delay into a test instead of relying on end-to-end testing only.
#
# This is an imprecise mechanism to address specific goals:
#
# - Evenly distribute requests across all workers at start
# - Evenly distribute CPU resources across all workers
#
# ## Goal: Distribute requests across workers at start
#
# There was a perf bug in Puma where one worker would wake up slightly before the rest and accept
# all the requests on the socket even though it didn't have enough resources to process all of them.
# This was originally fixed by never calling accept when a worker had more requests than threads
# already https://github.com/puma/puma/pull/3678/files/2736ebddb3fc8528e5150b5913fba251c37a8bf7#diff-a95f46e7ce116caddc9b9a9aa81004246d5210d5da5f4df90a818c780630166bL251-L291
#
# With the introduction of true keepalive support, there are two ways a request can come in:
# - A new request from a new client comes into the socket and it must be "accept"-ed
# - A keepalive request is served and the connection is retained. Another request is then accepted
#
# Ideally the server handles requests in the order they come in, and ideally it doesn't accept more requests than it can handle.
# These goals are contradictory, because when the server is at maximum capacity due to keepalive connections, it could mean we
# block all new requests, even if those came in before the new request on the older keepalive connection.
#
# ## Goal: Distribute CPU resources across all workers
#
# - This issue was opened https://github.com/puma/puma/issues/2078
#
# There are several entangled issues and it's not exactly clear what the root cause is, but the observable outcome
# was that performance was better with a small sleep, and that eventually became the default.
#
# An attempt to describe why this works is here: https://github.com/puma/puma/issues/2078#issuecomment-3287032470.
#
# Summarizing: The delay is for tuning the rate at which "accept" is called on the socket.
# Puma works by calling "accept" nonblock on the socket in a loop. When there are multiple workers
# (processes), they will "race" to accept a request at roughly the same rate. However, if one
# worker has all threads busy processing requests, then accepting a new request might "steal" it from
# a less busy worker. If a worker has no work to do, it should loop as fast as possible.
#
# ## Solution: Distribute requests across workers at start
#
# For now, both goals are framed as "load balancing" across workers (processes) and achieved through
# the same mechanism of sleeping longer to delay busier workers. Rather than the prior Puma 6.x
# and earlier behavior of using a binary on/off sleep value, we increase it an amount proportional
# to the load the server is under, capping the maximum delay to the scenario where all threads are busy
# and the todo list has reached a multiplier of the maximum number of threads.
#
# Private: API may change unexpectedly
#
# source://puma//lib/puma/cluster_accept_loop_delay.rb#54
class Puma::ClusterAcceptLoopDelay
  # Initialize happens once, `call` happens often. Perform global calculations here.
  #
  # @return [ClusterAcceptLoopDelay] a new instance of ClusterAcceptLoopDelay
  #
  # source://puma//lib/puma/cluster_accept_loop_delay.rb#58
  def initialize(workers:, max_delay:); end

  # We want the extreme values of this delay to be known (minimum and maximum) as well as
  # a predictable curve between the two. i.e. no step functions or hard cliffs.
  #
  # Return value is always numeric. Returns 0 if there should be no delay.
  #
  # source://puma//lib/puma/cluster_accept_loop_delay.rb#79
  def calculate(busy_threads_plus_todo:, max_threads:); end

  # Returns the value of attribute max_delay.
  #
  # source://puma//lib/puma/cluster_accept_loop_delay.rb#55
  def max_delay; end

  # @return [Boolean]
  #
  # source://puma//lib/puma/cluster_accept_loop_delay.rb#71
  def on?; end
end

# The main configuration class of Puma.
#
# It can be initialized with a set of "user" options and "default" options.
# Defaults will be merged with `Configuration.puma_default_options`.
#
# This class works together with 2 main other classes the `UserFileDefaultOptions`
# which stores configuration options in order so the precedence is that user
# set configuration wins over "file" based configuration wins over "default"
# configuration. These configurations are set via the `DSL` class. This
# class powers the Puma config file syntax and does double duty as a configuration
# DSL used by the `Puma::CLI` and Puma rack handler.
#
# It also handles loading plugins.
#
# [Note:]
#   `:port` and `:host` are not valid keys. By the time they make it to the
#   configuration options they are expected to be incorporated into a `:binds` key.
#   Under the hood the DSL maps `port` and `host` calls to `:binds`
#
#     config = Configuration.new({}) do |user_config, file_config, default_config|
#       user_config.port 3003
#     end
#     config.clamp
#     puts config.options[:port]
#     # => 3003
#
# It is expected that `load` is called on the configuration instance after setting
# config. This method expands any values in `config_file` and puts them into the
# correct configuration option hash.
#
# Once all configuration is complete it is expected that `clamp` will be called
# on the instance. This will expand any procs stored under "default" values. This
# is done because an environment variable may have been modified while loading
# configuration files.
#
# source://puma//lib/puma/configuration.rb#128
class Puma::Configuration
  # @return [Configuration] a new instance of Configuration
  #
  # source://puma//lib/puma/configuration.rb#179
  def initialize(user_options = T.unsafe(nil), default_options = T.unsafe(nil), env = T.unsafe(nil), &block); end

  # Load the specified rackup file, pull options from
  # the rackup file, and set @app.
  #
  # source://puma//lib/puma/configuration.rb#317
  def app; end

  # Indicate if there is a properly configured app
  #
  # @return [Boolean]
  #
  # source://puma//lib/puma/configuration.rb#306
  def app_configured?; end

  # Call once all configuration (included from rackup files)
  # is loaded to finalize defaults and lock in the configuration.
  #
  # This also calls load if it hasn't been called yet.
  #
  # source://puma//lib/puma/configuration.rb#282
  def clamp; end

  # @raise [NotLoadedError]
  #
  # source://puma//lib/puma/configuration.rb#263
  def config_files; end

  # source://puma//lib/puma/configuration.rb#208
  def configure; end

  # Return which environment we're running in
  #
  # source://puma//lib/puma/configuration.rb#330
  def environment; end

  # Returns the value of attribute events.
  #
  # source://puma//lib/puma/configuration.rb#200
  def events; end

  # source://puma//lib/puma/configuration.rb#360
  def final_options; end

  # source://puma//lib/puma/configuration.rb#222
  def flatten; end

  # source://puma//lib/puma/configuration.rb#226
  def flatten!; end

  # Returns the value of attribute hooks.
  #
  # source://puma//lib/puma/configuration.rb#200
  def hooks; end

  # source://puma//lib/puma/configuration.rb#257
  def load; end

  # source://puma//lib/puma/configuration.rb#334
  def load_plugin(name); end

  # @raise [NotClampedError]
  #
  # source://puma//lib/puma/configuration.rb#202
  def options; end

  # Returns the value of attribute plugins.
  #
  # source://puma//lib/puma/configuration.rb#200
  def plugins; end

  # source://puma//lib/puma/configuration.rb#231
  def puma_default_options(env = T.unsafe(nil)); end

  # source://puma//lib/puma/configuration.rb#237
  def puma_options_from_env(env = T.unsafe(nil)); end

  # source://puma//lib/puma/configuration.rb#310
  def rackup; end

  # @param arg [Launcher, Int] `:before_restart` passes Launcher
  # @param key [:Symbol] hook to run
  #
  # source://puma//lib/puma/configuration.rb#341
  def run_hooks(key, arg, log_writer, hook_data = T.unsafe(nil)); end

  private

  # source://puma//lib/puma/configuration.rb#216
  def initialize_copy(other); end

  # source://puma//lib/puma/configuration.rb#411
  def load_rackup; end

  # Load and use the normal Rack builder if we can, otherwise
  # fallback to our minimal version.
  #
  # source://puma//lib/puma/configuration.rb#391
  def rack_builder; end

  # source://puma//lib/puma/configuration.rb#379
  def require_processor_counter; end

  # source://puma//lib/puma/configuration.rb#429
  def set_conditional_default_options; end

  # source://puma//lib/puma/configuration.rb#434
  def warn_hooks; end

  class << self
    # source://puma//lib/puma/configuration.rb#371
    def random_token; end

    # source://puma//lib/puma/configuration.rb#364
    def temp_path; end
  end
end

# Injects the Configuration object into the env
#
# source://puma//lib/puma/configuration.rb#292
class Puma::Configuration::ConfigMiddleware
  # @return [ConfigMiddleware] a new instance of ConfigMiddleware
  #
  # source://puma//lib/puma/configuration.rb#293
  def initialize(config, app); end

  # source://puma//lib/puma/configuration.rb#298
  def call(env); end
end

# source://puma//lib/puma/configuration.rb#132
Puma::Configuration::DEFAULTS = T.let(T.unsafe(nil), Hash)

# source://puma//lib/puma/configuration.rb#130
class Puma::Configuration::NotClampedError < ::StandardError; end

# source://puma//lib/puma/configuration.rb#129
class Puma::Configuration::NotLoadedError < ::StandardError; end

# source://puma//lib/puma/client.rb#16
class Puma::ConnectionError < ::RuntimeError; end

# Frequently used constants when constructing requests or responses.  Many times
# the constant just refers to a string with the same contents.  Using these constants
# gave about a 3% to 10% performance improvement over using the strings directly.
#
# The constants are frozen because Hash#[]= when called with a String key dups
# the String UNLESS the String is frozen. This saves us therefore 2 object
# allocations when creating the env hash later.
#
# While Puma does try to emulate the CGI/1.2 protocol, it does not use the REMOTE_IDENT,
# REMOTE_USER, or REMOTE_HOST parameters since those are either a security problem or
# too taxing on performance.
#
# source://puma//lib/puma/const.rb#101
module Puma::Const; end

# Banned keys of response header
#
# source://puma//lib/puma/const.rb#292
Puma::Const::BANNED_HEADER_KEY = T.let(T.unsafe(nil), Regexp)

# source://puma//lib/puma/const.rb#222
Puma::Const::CGI_VER = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#264
Puma::Const::CHUNKED = T.let(T.unsafe(nil), String)

# The basic max request size we'll try to read.
#
# source://puma//lib/puma/const.rb#138
Puma::Const::CHUNK_SIZE = T.let(T.unsafe(nil), Integer)

# source://puma//lib/puma/const.rb#250
Puma::Const::CLOSE = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#262
Puma::Const::CLOSE_CHUNKED = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#104
Puma::Const::CODE_NAME = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#266
Puma::Const::COLON = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#258
Puma::Const::CONNECTION_CLOSE = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#259
Puma::Const::CONNECTION_KEEP_ALIVE = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#116
Puma::Const::CONTENT_LENGTH = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#253
Puma::Const::CONTENT_LENGTH2 = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#254
Puma::Const::CONTENT_LENGTH_S = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#244
Puma::Const::CONTINUE = T.let(T.unsafe(nil), String)

# Illegal character in the key or value of response header
#
# source://puma//lib/puma/const.rb#277
Puma::Const::DQUOTE = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#274
Puma::Const::EARLY_HINTS = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#122
Puma::Const::ERROR_RESPONSE = T.let(T.unsafe(nil), Hash)

# source://puma//lib/puma/const.rb#221
Puma::Const::GATEWAY_INTERFACE = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#225
Puma::Const::HALT_COMMAND = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#148
Puma::Const::HEAD = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#271
Puma::Const::HIJACK = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#272
Puma::Const::HIJACK_IO = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#270
Puma::Const::HIJACK_P = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#236
Puma::Const::HTTP = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#237
Puma::Const::HTTPS = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#239
Puma::Const::HTTPS_KEY = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#248
Puma::Const::HTTP_10_200 = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#218
Puma::Const::HTTP_11 = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#246
Puma::Const::HTTP_11_100 = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#247
Puma::Const::HTTP_11_200 = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#242
Puma::Const::HTTP_CONNECTION = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#243
Puma::Const::HTTP_EXPECT = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#278
Puma::Const::HTTP_HEADER_DELIMITER = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#208
Puma::Const::HTTP_HOST = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#241
Puma::Const::HTTP_VERSION = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#201
Puma::Const::HTTP_X_FORWARDED_FOR = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#204
Puma::Const::HTTP_X_FORWARDED_PROTO = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#203
Puma::Const::HTTP_X_FORWARDED_SCHEME = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#202
Puma::Const::HTTP_X_FORWARDED_SSL = T.let(T.unsafe(nil), String)

# list from https://www.iana.org/assignments/http-methods/http-methods.xhtml
# as of 04-May-23
#
# source://puma//lib/puma/const.rb#156
Puma::Const::IANA_HTTP_METHODS = T.let(T.unsafe(nil), Array)

# source://puma//lib/puma/const.rb#279
Puma::Const::ILLEGAL_HEADER_KEY_REGEX = T.let(T.unsafe(nil), Regexp)

# header values can contain HTAB?
#
# source://puma//lib/puma/const.rb#281
Puma::Const::ILLEGAL_HEADER_VALUE_REGEX = T.let(T.unsafe(nil), Regexp)

# source://puma//lib/puma/const.rb#251
Puma::Const::KEEP_ALIVE = T.let(T.unsafe(nil), String)

# ETag is based on the apache standard of hex mtime-size-inode (inode is 0 on win32)
#
# source://puma//lib/puma/const.rb#199
Puma::Const::LINE_END = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#211
Puma::Const::LOCALHOST = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#212
Puma::Const::LOCALHOST_IPV4 = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#213
Puma::Const::LOCALHOST_IPV6 = T.let(T.unsafe(nil), String)

# Maximum request body size before it is moved out of memory and into a tempfile for reading.
#
# source://puma//lib/puma/const.rb#145
Puma::Const::MAX_BODY = T.let(T.unsafe(nil), Integer)

# This is the maximum header that is allowed before a client is booted.  The parser detects
# this, but we'd also like to do this as well.
#
# source://puma//lib/puma/const.rb#142
Puma::Const::MAX_HEADER = T.let(T.unsafe(nil), Integer)

# source://puma//lib/puma/const.rb#268
Puma::Const::NEWLINE = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#118
Puma::Const::PATH_INFO = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#210
Puma::Const::PORT_443 = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#209
Puma::Const::PORT_80 = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#294
Puma::Const::PROXY_PROTOCOL_V1_REGEX = T.let(T.unsafe(nil), Regexp)

# source://puma//lib/puma/const.rb#233
Puma::Const::PUMA_CONFIG = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#234
Puma::Const::PUMA_PEERCERT = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#106
Puma::Const::PUMA_SERVER_STRING = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#232
Puma::Const::PUMA_SOCKET = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#120
Puma::Const::PUMA_TMP_BASE = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#103
Puma::Const::PUMA_VERSION = T.let(T.unsafe(nil), String)

# All constants are prefixed with `PIPE_` to avoid name collisions.
#
# source://puma//lib/puma/const.rb#297
module Puma::Const::PipeRequest; end

# source://puma//lib/puma/const.rb#299
Puma::Const::PipeRequest::PIPE_BOOT = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#301
Puma::Const::PipeRequest::PIPE_EXTERNAL_TERM = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#300
Puma::Const::PipeRequest::PIPE_FORK = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#304
Puma::Const::PipeRequest::PIPE_IDLE = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#303
Puma::Const::PipeRequest::PIPE_PING = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#302
Puma::Const::PipeRequest::PIPE_TERM = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#298
Puma::Const::PipeRequest::PIPE_WAKEUP = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#115
Puma::Const::QUERY_STRING = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#230
Puma::Const::RACK_AFTER_REPLY = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#228
Puma::Const::RACK_INPUT = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#231
Puma::Const::RACK_RESPONSE_FINISHED = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#229
Puma::Const::RACK_URL_SCHEME = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#200
Puma::Const::REMOTE_ADDR = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#147
Puma::Const::REQUEST_METHOD = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#114
Puma::Const::REQUEST_PATH = T.let(T.unsafe(nil), String)

# The original URI requested by the client.
#
# source://puma//lib/puma/const.rb#113
Puma::Const::REQUEST_URI = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#226
Puma::Const::RESTART_COMMAND = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#206
Puma::Const::SERVER_NAME = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#207
Puma::Const::SERVER_PORT = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#217
Puma::Const::SERVER_PROTOCOL = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#220
Puma::Const::SERVER_SOFTWARE = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#224
Puma::Const::STOP_COMMAND = T.let(T.unsafe(nil), String)

# based on https://www.rfc-editor.org/rfc/rfc9110.html#name-overview,
# with CONNECT removed, and PATCH added
#
# source://puma//lib/puma/const.rb#152
Puma::Const::SUPPORTED_HTTP_METHODS = T.let(T.unsafe(nil), Array)

# source://puma//lib/puma/const.rb#255
Puma::Const::TRANSFER_ENCODING = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#256
Puma::Const::TRANSFER_ENCODING2 = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#261
Puma::Const::TRANSFER_ENCODING_CHUNKED = T.let(T.unsafe(nil), String)

# The keys of headers that should not be convert to underscore
# normalized versions. These headers are ignored at the request reading layer,
# but if we normalize them after reading, it's just confusing for the application.
#
# source://puma//lib/puma/const.rb#286
Puma::Const::UNMASKABLE_HEADERS = T.let(T.unsafe(nil), Hash)

# source://puma//lib/puma/const.rb#214
Puma::Const::UNSPECIFIED_IPV4 = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#215
Puma::Const::UNSPECIFIED_IPV6 = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/const.rb#103
Puma::Const::VERSION = T.let(T.unsafe(nil), String)

# How long to wait when getting some write blocking on the socket when
# sending data back
#
# source://puma//lib/puma/const.rb#110
Puma::Const::WRITE_TIMEOUT = T.let(T.unsafe(nil), Integer)

# The methods that are available for use inside the configuration file.
# These same methods are used in Puma cli and the rack handler
# internally.
#
# Used manually (via CLI class):
#
#   config = Configuration.new({}) do |user_config|
#     user_config.port 3001
#   end
#   config.clamp
#
#   puts config.options[:binds] # => "tcp://127.0.0.1:3001"
#
# Used to load file:
#
#   $ cat puma_config.rb
#   port 3002
#
# Resulting configuration:
#
#   config = Configuration.new(config_file: "puma_config.rb")
#   config.clamp
#
#   puts config.options[:binds] # => "tcp://127.0.0.1:3002"
#
# You can also find many examples being used by the test suite in
# +test/config+.
#
# Puma v6 adds the option to specify a key name (String or Symbol) to the
# hooks that run inside the forked workers.  All the hooks run inside the
# {Puma::Cluster::Worker#run} method.
#
# Previously, the worker index and the LogWriter instance were passed to the
# hook blocks/procs.  If a key name is specified, a hash is passed as the last
# parameter.  This allows storage of data, typically objects that are created
# before the worker that need to be passed to the hook when the worker is shutdown.
#
# The following hooks have been updated:
#
#     | DSL Method             |  Options Key            | Fork Block Location |
#     | before_worker_boot     | :before_worker_boot     | inside, before      |
#     | before_worker_shutdown | :before_worker_shutdown | inside, after       |
#     | before_refork          | :before_refork          | inside              |
#     | after_refork           | :after_refork           | inside              |
#
# source://puma//lib/puma/dsl.rb#52
class Puma::DSL
  # @return [DSL] a new instance of DSL
  #
  # source://puma//lib/puma/dsl.rb#126
  def initialize(options, config); end

  # source://puma//lib/puma/dsl.rb#133
  def _load_from(path); end

  # source://puma//lib/puma/dsl.rb#142
  def _offer_plugins; end

  # Start the Puma control rack application on +url+. This application can
  # be communicated with to control the main server. Additionally, you can
  # provide an authentication token, so all requests to the control server
  # will need to include that token as a query parameter. This allows for
  # simple authentication.
  #
  # Check out {Puma::App::Status} to see what the app has available.
  #
  # @example
  #   activate_control_app 'unix:///var/run/pumactl.sock'
  # @example
  #   activate_control_app 'unix:///var/run/pumactl.sock', { auth_token: '12345' }
  # @example
  #   activate_control_app 'unix:///var/run/pumactl.sock', { no_token: true }
  #
  # source://puma//lib/puma/dsl.rb#220
  def activate_control_app(url = T.unsafe(nil), opts = T.unsafe(nil)); end

  # Code to run after puma is booted (works for both single and cluster modes).
  #
  # @example
  #   after_booted do
  #   puts 'After booting...'
  #   end
  #
  # source://puma//lib/puma/dsl.rb#843
  def after_booted(&block); end

  # When `fork_worker` is enabled, code to run in Worker 0
  # after all other workers are re-forked from this process,
  # after the server has temporarily stopped serving requests
  # (once per complete refork cycle).
  #
  # This can be used to re-open any connections to remote servers
  # (database, Redis, ...) that were closed via before_refork.
  #
  # This can be called multiple times to add several hooks.
  #
  # @example
  #   after_refork do
  #   puts 'After refork...'
  #   end
  # @note Cluster mode with `fork_worker` enabled only.
  #
  # source://puma//lib/puma/dsl.rb#910
  def after_refork(key = T.unsafe(nil), &block); end

  # Code to run after puma is stopped (works for both: single and clustered)
  #
  # @example
  #   after_stopped do
  #   puts 'After stopping...'
  #   end
  #
  # source://puma//lib/puma/dsl.rb#858
  def after_stopped(&block); end

  # Code to run in the master after a worker has been started. The worker's
  # index is passed as an argument.
  #
  # This is called everytime a worker is to be started.
  #
  # @example
  #   after_worker_fork do
  #   puts 'After worker fork...'
  #   end
  # @note Cluster mode only.
  #
  # source://puma//lib/puma/dsl.rb#820
  def after_worker_boot(&block); end

  # Code to run in the master after a worker has been started. The worker's
  # index is passed as an argument.
  #
  # This is called everytime a worker is to be started.
  #
  # @example
  #   after_worker_fork do
  #   puts 'After worker fork...'
  #   end
  # @note Cluster mode only.
  #
  # source://puma//lib/puma/dsl.rb#816
  def after_worker_fork(&block); end

  # Code to run in the master right after a worker has stopped. The worker's
  # index and Process::Status are passed as arguments.
  #
  # @example
  #   after_worker_shutdown do |worker_handle|
  #   puts 'Worker crashed' unless worker_handle.process_status.success?
  #   end
  # @note Cluster mode only.
  #
  # source://puma//lib/puma/dsl.rb#832
  def after_worker_shutdown(&block); end

  # Use an object or block as the rack application. This allows the
  # configuration file to be the application itself.
  #
  # @example
  #   app do |env|
  #   body = 'Hello, World!'
  #
  #   [
  #   200,
  #   {
  #   'Content-Type' => 'text/plain',
  #   'Content-Length' => body.length.to_s
  #   },
  #   [body]
  #   ]
  #   end
  # @see Puma::Configuration#app
  #
  # source://puma//lib/puma/dsl.rb#197
  def app(obj = T.unsafe(nil), &block); end

  # Code to run immediately before master process
  # forks workers (once on boot). These hooks can block if necessary
  # to wait for background operations unknown to Puma to finish before
  # the process terminates.
  # This can be used to close any connections to remote servers (database,
  # Redis, ...) that were opened when preloading the code.
  #
  # This can be called multiple times to add several hooks.
  #
  # @example
  #   before_fork do
  #   puts "Starting workers..."
  #   end
  # @note Cluster mode only.
  #
  # source://puma//lib/puma/dsl.rb#737
  def before_fork(&block); end

  # When `fork_worker` is enabled, code to run in Worker 0
  # before all other workers are re-forked from this process,
  # after the server has temporarily stopped serving requests
  # (once per complete refork cycle).
  #
  # This can be used to trigger extra garbage-collection to maximize
  # copy-on-write efficiency, or close any connections to remote servers
  # (database, Redis, ...) that were opened while the server was running.
  #
  # This can be called multiple times to add several hooks.
  #
  # @example
  #   before_refork do
  #   3.times {GC.start}
  #   end
  # @note Cluster mode with `fork_worker` enabled only.
  # @version 5.0.0
  #
  # source://puma//lib/puma/dsl.rb#885
  def before_refork(key = T.unsafe(nil), &block); end

  # Code to run before doing a restart. This code should
  # close log files, database connections, etc.
  #
  # This can be called multiple times to add code each time.
  #
  # @example
  #   before_restart do
  #   puts 'On restart...'
  #   end
  #
  # source://puma//lib/puma/dsl.rb#444
  def before_restart(&block); end

  # Provide a block to be executed after a thread is trimmed from the thread
  # pool. Be careful: while this block executes, Puma's main loop is
  # blocked, so no new requests will be picked up.
  #
  # This hook only runs when a thread in the threadpool is trimmed by Puma.
  # It does not run when a thread dies due to exceptions or any other cause.
  #
  # Return values are ignored.
  # Raising an exception will log a warning.
  #
  # This hook is useful for cleaning up thread local resources when a thread
  # is trimmed.
  #
  # This can be called multiple times to add several hooks.
  #
  # @example
  #   before_thread_exit do
  #   puts 'On thread exit...'
  #   end
  #
  # source://puma//lib/puma/dsl.rb#959
  def before_thread_exit(&block); end

  # Provide a block to be executed just before a thread is added to the thread
  # pool. Be careful: while the block executes, thread creation is delayed, and
  # probably a request will have to wait too! The new thread will not be added to
  # the threadpool until the provided block returns.
  #
  # Return values are ignored.
  # Raising an exception will log a warning.
  #
  # This hook is useful for doing something when the thread pool grows.
  #
  # This can be called multiple times to add several hooks.
  #
  # @example
  #   before_thread_start do
  #   puts 'On thread start...'
  #   end
  #
  # source://puma//lib/puma/dsl.rb#931
  def before_thread_start(&block); end

  # Code to run in a worker when it boots to setup
  # the process before booting the app.
  #
  # This can be called multiple times to add several hooks.
  #
  # @example
  #   before_worker_boot do
  #   puts 'Before worker boot...'
  #   end
  # @note Cluster mode only.
  #
  # source://puma//lib/puma/dsl.rb#753
  def before_worker_boot(key = T.unsafe(nil), &block); end

  # Code to run in the master right before a worker is started. The worker's
  # index is passed as an argument.
  #
  # This can be called multiple times to add several hooks.
  #
  # @example
  #   before_worker_fork do
  #   puts 'Before worker fork...'
  #   end
  # @note Cluster mode only.
  #
  # source://puma//lib/puma/dsl.rb#796
  def before_worker_fork(&block); end

  # Code to run immediately before a worker shuts
  # down (after it has finished processing HTTP requests). The worker's
  # index is passed as an argument. These hooks
  # can block if necessary to wait for background operations unknown
  # to Puma to finish before the process terminates.
  #
  # This can be called multiple times to add several hooks.
  #
  # @example
  #   before_worker_shutdown do
  #   puts 'On worker shutdown...'
  #   end
  # @note Cluster mode only.
  #
  # source://puma//lib/puma/dsl.rb#776
  def before_worker_shutdown(key = T.unsafe(nil), &block); end

  # Bind the server to +url+. "tcp://", "unix://" and "ssl://" are the only
  # accepted protocols. Multiple urls can be bound to, calling +bind+ does
  # not overwrite previous bindings.
  #
  # The default is "tcp://0.0.0.0:9292".
  #
  # You can use query parameters within the url to specify options:
  #
  # * Set the socket backlog depth with +backlog+, default is 1024.
  # * Set up an SSL certificate with +key+ & +cert+.
  # * Set up an SSL certificate for mTLS with +key+, +cert+, +ca+ and +verify_mode+.
  # * Set whether to optimize for low latency instead of throughput with
  #   +low_latency+, default is to not optimize for low latency. This is done
  #   via +Socket::TCP_NODELAY+.
  # * Set socket permissions with +umask+.
  #
  # @example Backlog depth
  #   bind 'unix:///var/run/puma.sock?backlog=512'
  # @example Disable optimization for low latency
  #   bind 'tcp://0.0.0.0:9292?low_latency=false'
  # @example SSL cert
  #   bind 'ssl://127.0.0.1:9292?key=key.key&cert=cert.pem'
  # @example SSL cert for mutual TLS (mTLS)
  #   bind 'ssl://127.0.0.1:9292?key=key.key&cert=cert.pem&ca=ca.pem&verify_mode=force_peer'
  # @example Socket permissions
  #   bind 'unix:///var/run/puma.sock?umask=0111'
  # @see Puma::Cluster#run
  # @see Puma::Runner#load_and_bind
  #
  # source://puma//lib/puma/dsl.rb#286
  def bind(url); end

  # Bind to (systemd) activated sockets, regardless of configured binds.
  #
  # Systemd can present sockets as file descriptors that are already opened.
  # By default Puma will use these but only if it was explicitly told to bind
  # to the socket. If not, it will close the activated sockets. This means
  # all configuration is duplicated.
  #
  # Binds can contain additional configuration, but only SSL config is really
  # relevant since the unix and TCP socket options are ignored.
  #
  # This means there is a lot of duplicated configuration for no additional
  # value in most setups. This method tells the launcher to bind to all
  # activated sockets, regardless of existing bind.
  #
  # To clear configured binds, the value only can be passed. This will clear
  # out any binds that may have been configured.
  #
  # @example Only bind to systemd activated sockets, ignoring other binds
  #   bind_to_activated_sockets 'only'
  # @example Use any systemd activated sockets as well as configured binds
  #   bind_to_activated_sockets
  #
  # source://puma//lib/puma/dsl.rb#318
  def bind_to_activated_sockets(bind = T.unsafe(nil)); end

  # Use a clean fiber per request which ensures a clean slate for fiber
  # locals and fiber storage. Also provides a cleaner backtrace with less
  # Puma internal stack frames.
  #
  # The default is +false+.
  #
  # @example
  #   fiber_per_request
  #
  # source://puma//lib/puma/dsl.rb#386
  def clean_thread_locals(which = T.unsafe(nil)); end

  # source://puma//lib/puma/dsl.rb#291
  def clear_binds!; end

  # Pass in a custom logging class instance
  #
  # @example
  #   custom_logger Logger.new('t.log')
  #
  # source://puma//lib/puma/dsl.rb#499
  def custom_logger(custom_logger); end

  # Show debugging info
  #
  # The default is +false+.
  #
  # @example
  #   debug
  #
  # source://puma//lib/puma/dsl.rb#510
  def debug; end

  # source://puma//lib/puma/dsl.rb#157
  def default_host; end

  # The directory to operate out of.
  #
  # The default is the current directory.
  #
  # @example
  #   directory '/u/apps/lolcat'
  #
  # source://puma//lib/puma/dsl.rb#988
  def directory(dir); end

  # When shutting down, drain the accept socket of pending connections and
  # process them. This loops over the accept socket until there are no more
  # read events and then stops looking and waits for the requests to finish.
  #
  # @see Puma::Server#graceful_shutdown
  #
  # source://puma//lib/puma/dsl.rb#394
  def drain_on_shutdown(which = T.unsafe(nil)); end

  # Enable HTTP 103 Early Hints responses.
  #
  # The default is +nil+.
  #
  # @example
  #   early_hints
  #
  # source://puma//lib/puma/dsl.rb#540
  def early_hints(answer = T.unsafe(nil)); end

  # When `true`, keep-alive connections are maintained on inbound requests.
  # Enabling this setting reduces the number of TCP operations, reducing response
  # times for connections that can send multiple requests in a single connection.
  #
  # When Puma receives more incoming connections than available Puma threads,
  # enabling the keep-alive behavior may result in processing requests out-of-order,
  # increasing overall response time variance. Increased response time variance
  # means that the overall average of response times might not change, but more
  # outliers will exist. Those long-tail outliers may significantly affect response
  # times for some processed requests.
  #
  # When `false`, Puma closes the connection after each request, requiring the
  # client to open a new request. Disabling this setting guarantees that requests
  # will be processed in the order they are fully received, decreasing response
  # variance and eliminating long-tail outliers caused by keep-alive behavior.
  # The trade-off is that the number of TCP operations required will increase.
  #
  # The default is +true+.
  #
  # @example
  #   enable_keep_alives false
  #
  # source://puma//lib/puma/dsl.rb#1364
  def enable_keep_alives(enabled = T.unsafe(nil)); end

  # Set the environment in which the rack's app will run. The value must be
  # a string.
  #
  # The default is "development".
  #
  # @example
  #   environment 'production'
  #
  # source://puma//lib/puma/dsl.rb#406
  def environment(environment); end

  # When using prune_bundler, if extra runtime dependencies need to be loaded to
  # initialize your app, then this setting can be used. This includes any Puma plugins.
  #
  # Before bundler is pruned, the gem names supplied will be looked up in the bundler
  # context and then loaded again after bundler is pruned.
  # Only applies if prune_bundler is used.
  #
  # @example
  #   extra_runtime_dependencies ['gem_name_1', 'gem_name_2']
  # @example
  #   extra_runtime_dependencies ['puma_worker_killer', 'puma-heroku']
  # @see Puma::Launcher#extra_runtime_deps_directories
  #
  # source://puma//lib/puma/dsl.rb#1074
  def extra_runtime_dependencies(answer = T.unsafe(nil)); end

  # Use a clean fiber per request which ensures a clean slate for fiber
  # locals and fiber storage. Also provides a cleaner backtrace with less
  # Puma internal stack frames.
  #
  # The default is +false+.
  #
  # @example
  #   fiber_per_request
  #
  # source://puma//lib/puma/dsl.rb#382
  def fiber_per_request(which = T.unsafe(nil)); end

  # Define how long the tcp socket stays open, if no data has been received.
  #
  # The default is 30 seconds.
  #
  # @example
  #   first_data_timeout 40
  # @see Puma::Server.new
  #
  # source://puma//lib/puma/dsl.rb#343
  def first_data_timeout(seconds); end

  # How long to wait for threads to stop when shutting them down.
  # Specifying :immediately will cause Puma to kill the threads immediately.
  # Otherwise the value is the number of seconds to wait.
  #
  # Puma always waits a few seconds after killing a thread for it to try
  # to finish up it's work, even in :immediately mode.
  #
  # The default is +:forever+.
  #
  # @see Puma::Server#graceful_shutdown
  #
  # source://puma//lib/puma/dsl.rb#421
  def force_shutdown_after(val = T.unsafe(nil)); end

  # When enabled, workers will be forked from worker 0 instead of from the master process.
  # This option is similar to `preload_app` because the app is preloaded before forking,
  # but it is compatible with phased restart.
  #
  # This option also enables the `refork` command (SIGURG), which optimizes copy-on-write performance
  # in a running app.
  #
  # A refork will automatically trigger once after the specified number of requests
  # (default 1000), or pass 0 to disable auto refork.
  #
  # @note This is experimental.
  # @note Cluster mode only.
  #
  # source://puma//lib/puma/dsl.rb#1318
  def fork_worker(after_requests = T.unsafe(nil)); end

  # source://puma//lib/puma/dsl.rb#165
  def get(key, default = T.unsafe(nil)); end

  # Specify how big the request payload should be, in bytes.
  # This limit is compared against Content-Length HTTP header.
  # If the payload size (CONTENT_LENGTH) is larger than http_content_length_limit,
  # HTTP 413 status code is returned.
  #
  # When no Content-Length http header is present, it is compared against the
  # size of the body of the request.
  #
  # The default is +nil+.
  #
  # @example
  #   http_content_length_limit 2_000_000_000
  #
  # source://puma//lib/puma/dsl.rb#1412
  def http_content_length_limit(limit); end

  # If a new request is not received within this number of seconds, begin shutting down.
  #
  # The default is +nil+.
  #
  # @example
  #   idle_timeout 60
  # @see Puma::Server.new
  #
  # source://puma//lib/puma/dsl.rb#369
  def idle_timeout(seconds); end

  # source://puma//lib/puma/dsl.rb#161
  def inject(&blk); end

  # Specify the backend for the IO selector.
  #
  # Provided values will be passed directly to +NIO::Selector.new+, with the
  # exception of +:auto+ which will let nio4r choose the backend.
  #
  # Check the documentation of +NIO::Selector.backends+ for the list of valid
  # options. Note that the available options on your system will depend on the
  # operating system. If you want to use the pure Ruby backend (not
  # recommended due to its comparatively low performance), set environment
  # variable +NIO4R_PURE+ to +true+.
  #
  # The default is +:auto+.
  #
  # @see https://github.com/socketry/nio4r/blob/master/lib/nio/selector.rb
  #
  # source://puma//lib/puma/dsl.rb#1383
  def io_selector_backend(backend); end

  # Load additional configuration from a file.
  # Files get loaded later via Configuration#load.
  #
  # @example
  #   load 'config/puma/production.rb'
  #
  # source://puma//lib/puma/dsl.rb#251
  def load(file); end

  # source://puma//lib/puma/dsl.rb#560
  def log_formatter(&block); end

  # Enable request logging, the inverse of `quiet`.
  #
  # The default is +false+.
  #
  # @example
  #   log_requests
  #
  # source://puma//lib/puma/dsl.rb#490
  def log_requests(which = T.unsafe(nil)); end

  # Use +obj+ or +block+ as the low level error handler. This allows the
  # configuration file to change the default error on the server.
  #
  # @example
  #   lowlevel_error_handler do |err|
  #   [200, {}, ["error page"]]
  #   end
  #
  # source://puma//lib/puma/dsl.rb#1014
  def lowlevel_error_handler(obj = T.unsafe(nil), &block); end

  # @deprecated Use {#max_keep_alive} instead.
  #
  # source://puma//lib/puma/dsl.rb#1324
  def max_fast_inline(num_of_requests); end

  # The number of requests a keep-alive client can submit before being closed.
  # Note that some applications (server to server) may benefit from a very high
  # number or Float::INFINITY.
  #
  # The default is 999.
  #
  # @example
  #   max_keep_alive 20
  #
  # source://puma//lib/puma/dsl.rb#1338
  def max_keep_alive(num_of_requests); end

  # Ensures +STDOUT+ and +STDERR+ is immediately flushed to the underlying
  # operating system and is not buffered internally
  #
  # The default is +true+.
  #
  # @example
  #   mutate_stdout_and_stderr_to_sync_on_write false
  #
  # source://puma//lib/puma/dsl.rb#1395
  def mutate_stdout_and_stderr_to_sync_on_write(enabled = T.unsafe(nil)); end

  # Code to run after puma is booted (works for both single and cluster modes).
  #
  # @example
  #   after_booted do
  #   puts 'After booting...'
  #   end
  #
  # source://puma//lib/puma/dsl.rb#849
  def on_booted(&block); end

  # When `fork_worker` is enabled, code to run in Worker 0
  # before all other workers are re-forked from this process,
  # after the server has temporarily stopped serving requests
  # (once per complete refork cycle).
  #
  # This can be used to trigger extra garbage-collection to maximize
  # copy-on-write efficiency, or close any connections to remote servers
  # (database, Redis, ...) that were opened while the server was running.
  #
  # This can be called multiple times to add several hooks.
  #
  # @example
  #   before_refork do
  #   3.times {GC.start}
  #   end
  # @note Cluster mode with `fork_worker` enabled only.
  # @version 5.0.0
  #
  # source://puma//lib/puma/dsl.rb#891
  def on_refork(key = T.unsafe(nil), &block); end

  # Code to run before doing a restart. This code should
  # close log files, database connections, etc.
  #
  # This can be called multiple times to add code each time.
  #
  # @example
  #   before_restart do
  #   puts 'On restart...'
  #   end
  #
  # source://puma//lib/puma/dsl.rb#450
  def on_restart(&block); end

  # Code to run after puma is stopped (works for both: single and clustered)
  #
  # @example
  #   after_stopped do
  #   puts 'After stopping...'
  #   end
  #
  # source://puma//lib/puma/dsl.rb#863
  def on_stopped(&block); end

  # Provide a block to be executed after a thread is trimmed from the thread
  # pool. Be careful: while this block executes, Puma's main loop is
  # blocked, so no new requests will be picked up.
  #
  # This hook only runs when a thread in the threadpool is trimmed by Puma.
  # It does not run when a thread dies due to exceptions or any other cause.
  #
  # Return values are ignored.
  # Raising an exception will log a warning.
  #
  # This hook is useful for cleaning up thread local resources when a thread
  # is trimmed.
  #
  # This can be called multiple times to add several hooks.
  #
  # @example
  #   before_thread_exit do
  #   puts 'On thread exit...'
  #   end
  #
  # source://puma//lib/puma/dsl.rb#965
  def on_thread_exit(&block); end

  # Provide a block to be executed just before a thread is added to the thread
  # pool. Be careful: while the block executes, thread creation is delayed, and
  # probably a request will have to wait too! The new thread will not be added to
  # the threadpool until the provided block returns.
  #
  # Return values are ignored.
  # Raising an exception will log a warning.
  #
  # This hook is useful for doing something when the thread pool grows.
  #
  # This can be called multiple times to add several hooks.
  #
  # @example
  #   before_thread_start do
  #   puts 'On thread start...'
  #   end
  #
  # source://puma//lib/puma/dsl.rb#937
  def on_thread_start(&block); end

  # Code to run in a worker when it boots to setup
  # the process before booting the app.
  #
  # This can be called multiple times to add several hooks.
  #
  # @example
  #   before_worker_boot do
  #   puts 'Before worker boot...'
  #   end
  # @note Cluster mode only.
  #
  # source://puma//lib/puma/dsl.rb#759
  def on_worker_boot(key = T.unsafe(nil), &block); end

  # Code to run in the master right before a worker is started. The worker's
  # index is passed as an argument.
  #
  # This can be called multiple times to add several hooks.
  #
  # @example
  #   before_worker_fork do
  #   puts 'Before worker fork...'
  #   end
  # @note Cluster mode only.
  #
  # source://puma//lib/puma/dsl.rb#802
  def on_worker_fork(&block); end

  # Code to run immediately before a worker shuts
  # down (after it has finished processing HTTP requests). The worker's
  # index is passed as an argument. These hooks
  # can block if necessary to wait for background operations unknown
  # to Puma to finish before the process terminates.
  #
  # This can be called multiple times to add several hooks.
  #
  # @example
  #   before_worker_shutdown do
  #   puts 'On worker shutdown...'
  #   end
  # @note Cluster mode only.
  #
  # source://puma//lib/puma/dsl.rb#782
  def on_worker_shutdown(key = T.unsafe(nil), &block); end

  # Code to run out-of-band when the worker is idle.
  # These hooks run immediately after a request has finished
  # processing and there are no busy threads on the worker.
  # The worker doesn't accept new requests until this code finishes.
  #
  # This hook is useful for running out-of-band garbage collection
  # or scheduling asynchronous tasks to execute after a response.
  #
  # This can be called multiple times to add several hooks.
  #
  # source://puma//lib/puma/dsl.rb#977
  def out_of_band(&block); end

  # Define how long persistent connections can be idle before Puma closes them.
  #
  # The default is 20 seconds.
  #
  # @example
  #   persistent_timeout 30
  # @see Puma::Server.new
  #
  # source://puma//lib/puma/dsl.rb#356
  def persistent_timeout(seconds); end

  # Store the pid of the server in the file at "path".
  #
  # @example
  #   pidfile '/u/apps/lolcat/tmp/pids/puma.pid'
  #
  # source://puma//lib/puma/dsl.rb#468
  def pidfile(path); end

  # Load the named plugin for use by this configuration.
  #
  # @example
  #   plugin :tmp_restart
  #
  # source://puma//lib/puma/dsl.rb#174
  def plugin(name); end

  # Define the TCP port to bind to. Use `bind` for more advanced options.
  #
  # The default is +9292+.
  #
  # @example
  #   port 3000
  #
  # source://puma//lib/puma/dsl.rb#329
  def port(port, host = T.unsafe(nil)); end

  # Preload the application before forking the workers; this conflicts with
  # the phased restart feature.
  #
  # The default is +true+ if your app uses more than 1 worker.
  #
  # @example
  #   preload_app!
  # @note Cluster mode only.
  #
  # source://puma//lib/puma/dsl.rb#1002
  def preload_app!(answer = T.unsafe(nil)); end

  # This option is used to allow your app and its gems to be
  # properly reloaded when not using preload.
  #
  # When set, if Puma detects that it's been invoked in the
  # context of Bundler, it will cleanup the environment and
  # re-run itself outside the Bundler environment, but directly
  # using the files that Bundler has setup.
  #
  # This means that Puma is now decoupled from your Bundler
  # context and when each worker loads, it will be loading a
  # new Bundler context and thus can float around as the release
  # dictates.
  #
  # @note This is incompatible with +preload_app!+.
  # @note This is only supported for RubyGems 2.2+
  # @see extra_runtime_dependencies
  #
  # source://puma//lib/puma/dsl.rb#1038
  def prune_bundler(answer = T.unsafe(nil)); end

  # When set to true, workers accept all requests
  # and queue them before passing them to the handlers.
  # When set to false, each worker process accepts exactly as
  # many requests as it is configured to simultaneously handle.
  #
  # Queueing requests generally improves performance. In some
  # cases, such as a single threaded application, it may be
  # better to ensure requests get balanced across workers.
  #
  # Note that setting this to false disables HTTP keepalive and
  # slow clients will occupy a handler thread while the request
  # is being sent. A reverse proxy, such as nginx, can handle
  # slow clients and queue requests before they reach Puma.
  #
  # The default is +true+.
  #
  # @see Puma::Server
  #
  # source://puma//lib/puma/dsl.rb#1212
  def queue_requests(answer = T.unsafe(nil)); end

  # Disable request logging, the inverse of `log_requests`.
  #
  # The default is +true+.
  #
  # @example
  #   quiet
  #
  # source://puma//lib/puma/dsl.rb#479
  def quiet(which = T.unsafe(nil)); end

  # Allows setting `env['rack.url_scheme']`.
  # Only necessary if X-Forwarded-Proto is not being set by your proxy
  # Normal values are 'http' or 'https'.
  #
  # source://puma//lib/puma/dsl.rb#529
  def rack_url_scheme(scheme = T.unsafe(nil)); end

  # Load +path+ as a rackup file.
  #
  # The default is "config.ru".
  #
  # @example
  #   rackup '/u/apps/lolcat/config.ru'
  #
  # source://puma//lib/puma/dsl.rb#521
  def rackup(path); end

  # Raises a SignalException when SIGTERM is received. In environments where
  # SIGTERM is something expected, you can suppress these with this option.
  #
  # This can be useful for example in Kubernetes, where rolling restart is
  # guaranteed usually on the infrastructure level.
  #
  # The default is +true+.
  #
  # @example
  #   raise_exception_on_sigterm false
  # @see Puma::Cluster#setup_signals
  # @see Puma::Launcher#setup_signals
  #
  # source://puma//lib/puma/dsl.rb#1056
  def raise_exception_on_sigterm(answer = T.unsafe(nil)); end

  # Command to use to restart Puma. This should be just how to
  # load Puma itself (ie. 'ruby -Ilib bin/puma'), not the arguments
  # to Puma, as those are the same as the original process.
  #
  # @example
  #   restart_command '/u/app/lolcat/bin/restart_puma'
  #
  # source://puma//lib/puma/dsl.rb#459
  def restart_command(cmd); end

  # source://puma//lib/puma/dsl.rb#153
  def set_default_host(host); end

  # Control how the remote address of the connection is set. This
  # is configurable because to calculate the true socket peer address
  # a kernel syscall is required which for very fast rack handlers
  # slows down the handling significantly.
  #
  # There are 5 possible values:
  #
  # 1. **:socket** - read the peername from the socket using the
  #    syscall. This is the normal behavior. If this fails for any reason (e.g.,
  #    if the peer disconnects between the connection being accepted and the getpeername
  #    system call), Puma will return "0.0.0.0"
  # 2. **:localhost** - set the remote address to "127.0.0.1"
  # 3. **header: <http_header>**- set the remote address to the value of the
  #    provided http header. For instance:
  #    `set_remote_address header: "X-Real-IP"`.
  #    Only the first word (as separated by spaces or comma) is used, allowing
  #    headers such as X-Forwarded-For to be used as well. If this header is absent,
  #    Puma will fall back to the behavior of :socket
  # 4. **proxy_protocol: :v1**- set the remote address to the value read from the
  #    HAproxy PROXY protocol, version 1. If the request does not have the PROXY
  #    protocol attached to it, will fall back to :socket
  # 5. **\<Any string\>** - this allows you to hardcode remote address to any value
  #    you wish. Because Puma never uses this field anyway, it's format is
  #    entirely in your hands.
  #
  # The default is +:socket+.
  #
  # @example
  #   set_remote_address :localhost
  #
  # source://puma//lib/puma/dsl.rb#1276
  def set_remote_address(val = T.unsafe(nil)); end

  # When a shutdown is requested, the backtraces of all the
  # threads will be written to $stdout. This can help figure
  # out why shutdown is hanging.
  #
  # source://puma//lib/puma/dsl.rb#1220
  def shutdown_debug(val = T.unsafe(nil)); end

  # Disable warning message when running single mode with callback hook defined.
  #
  # The default is +false+.
  #
  # @example
  #   silence_fork_callback_warning
  #
  # source://puma//lib/puma/dsl.rb#717
  def silence_fork_callback_warning; end

  # Disable warning message when running in cluster mode with a single worker.
  #
  # Cluster mode has some overhead of running an additional 'control' process
  # in order to manage the cluster. If only running a single worker it is
  # likely not worth paying that overhead vs running in single mode with
  # additional threads instead.
  #
  # There are some scenarios where running cluster mode with a single worker
  # may still be warranted and valid under certain deployment scenarios, see
  # https://github.com/puma/puma/issues/2534
  #
  # Moving from workers = 1 to workers = 0 will save 10-30% of memory use.
  #
  # The default is +false+.
  #
  # @example
  #   silence_single_worker_warning
  # @note Cluster mode only.
  #
  # source://puma//lib/puma/dsl.rb#706
  def silence_single_worker_warning; end

  # Instead of using +bind+ and manually constructing a URI like:
  #
  #    bind 'ssl://127.0.0.1:9292?key=key_path&cert=cert_path'
  #
  # you can use the this method.
  #
  # When binding on localhost you don't need to specify +cert+ and +key+,
  # Puma will assume you are using the +localhost+ gem and try to load the
  # appropriate files.
  #
  # When using the options hash parameter, the `reuse:` value is either
  # `true`, which sets reuse 'on' with default values, or a hash, with `:size`
  # and/or `:timeout` keys, each with integer values.
  #
  # The `cert:` options hash parameter can be the path to a certificate
  # file including all intermediate certificates in PEM format.
  #
  # The `cert_pem:` options hash parameter can be String containing the
  # cerificate and all intermediate certificates in PEM format.
  #
  # @example
  #   ssl_bind '127.0.0.1', '9292', {
  #   cert: path_to_cert,
  #   key: path_to_key,
  #   ssl_cipher_filter: cipher_filter, # optional
  #   ssl_ciphersuites: ciphersuites,   # optional
  #   verify_mode: verify_mode,         # default 'none'
  #   verification_flags: flags,        # optional, not supported by JRuby
  #   reuse: true                       # optional
  #   }
  # @example Alternatively, you can provide +cert_pem+ and +key_pem+:
  #   ssl_bind '127.0.0.1', '9292', {
  #   cert_pem: File.read(path_to_cert),
  #   key_pem: File.read(path_to_key),
  #   reuse: {size: 2_000, timeout: 20} # optional
  #   }
  # @example For JRuby, two keys are required: +keystore+ & +keystore_pass+
  #   ssl_bind '127.0.0.1', '9292', {
  #   keystore: path_to_keystore,
  #   keystore_pass: password,
  #   ssl_cipher_list: cipher_list,     # optional
  #   verify_mode: verify_mode          # default 'none'
  #   }
  # @example Using self-signed certificate with the +localhost+ gem:
  #   ssl_bind '127.0.0.1', '9292'
  #
  # source://puma//lib/puma/dsl.rb#644
  def ssl_bind(host, port, opts = T.unsafe(nil)); end

  # Use +path+ as the file to store the server info state. This is
  # used by +pumactl+ to query and control the server.
  #
  # @example
  #   state_path '/u/apps/lolcat/tmp/pids/puma.state'
  #
  # source://puma//lib/puma/dsl.rb#655
  def state_path(path); end

  # Use +permission+ to restrict permissions for the state file.  By convention,
  # +permission+ is an octal number (e.g. `0640` or `0o640`).
  #
  # @example
  #   state_permission 0600
  #
  # source://puma//lib/puma/dsl.rb#665
  def state_permission(permission); end

  # Redirect +STDOUT+ and +STDERR+ to files specified. The +append+ parameter
  # specifies whether the output is appended.
  #
  # The default is +false+.
  #
  # @example
  #   stdout_redirect '/app/lolcat/log/stdout', '/app/lolcat/log/stderr'
  # @example
  #   stdout_redirect '/app/lolcat/log/stdout', '/app/lolcat/log/stderr', true
  #
  # source://puma//lib/puma/dsl.rb#554
  def stdout_redirect(stdout = T.unsafe(nil), stderr = T.unsafe(nil), append = T.unsafe(nil)); end

  # Supported http methods, which will replace `Puma::Const::SUPPORTED_HTTP_METHODS`.
  # The value of `:any` will allows all methods, otherwise, the value must be
  # an array of strings.  Note that methods are all uppercase.
  #
  # `Puma::Const::SUPPORTED_HTTP_METHODS` is conservative, if you want a
  # complete set of methods, the methods defined by the
  # [IANA Method Registry](https://www.iana.org/assignments/http-methods/http-methods.xhtml)
  # are pre-defined as the constant `Puma::Const::IANA_HTTP_METHODS`.
  #
  # @example Adds 'PROPFIND' to existing supported methods
  #   supported_http_methods(Puma::Const::SUPPORTED_HTTP_METHODS + ['PROPFIND'])
  # @example Allows any method
  #   supported_http_methods :any
  # @example Restricts methods to the array elements
  #   supported_http_methods %w[HEAD GET POST PUT DELETE OPTIONS PROPFIND]
  # @example Restricts methods to the methods in the IANA Registry
  #   supported_http_methods Puma::Const::IANA_HTTP_METHODS
  # @note If the `methods` value is `:any`, no method check with be performed,
  #   similar to Puma v5 and earlier.
  #
  # source://puma//lib/puma/dsl.rb#1437
  def supported_http_methods(methods); end

  # Additional text to display in process listing.
  #
  # If you do not specify a tag, Puma will infer it. If you do not want Puma
  # to add a tag, use an empty string.
  #
  # The default is the current file or directory base name.
  #
  # @example
  #   tag 'app name'
  # @example
  #   tag ''
  #
  # source://puma//lib/puma/dsl.rb#1090
  def tag(string); end

  # Configure the number of threads to use to answer requests.
  #
  # It can be a single fixed number, or a +min+ and a +max+.
  #
  # The default is the environment variables +PUMA_MIN_THREADS+ / +PUMA_MAX_THREADS+
  # (or +MIN_THREADS+ / +MAX_THREADS+ if the +PUMA_+ variables aren't set).
  #
  # If these environment variables aren't set, the default is "0, 5" in MRI or "0, 16" for other interpreters.
  #
  # @example
  #   threads 5
  # @example
  #   threads 0, 16
  # @example
  #   threads 5, 5
  #
  # source://puma//lib/puma/dsl.rb#580
  def threads(min, max = T.unsafe(nil)); end

  # Maximum delay of worker accept loop.
  #
  # Attempts to route traffic to less-busy workers by causing a busy worker to delay
  # listening on the socket, allowing workers which are not processing as many
  # requests to pick up new requests first.
  #
  # The default is 0.005 seconds.
  #
  # To turn off this feature, set the value to 0.
  #
  # @note Cluster mode with >= 2 workers only.
  # @note Interpreters with forking support only.
  # @see Puma::Server#handle_servers
  # @see Puma::ThreadPool#wait_for_less_busy_worker
  #
  # source://puma//lib/puma/dsl.rb#1242
  def wait_for_less_busy_worker(val = T.unsafe(nil)); end

  # Change the default worker timeout for booting.
  #
  # The default is the value of `worker_timeout`.
  #
  # @example
  #   worker_boot_timeout 60
  # @note Cluster mode only.
  # @see Puma::Cluster::Worker#ping_timeout
  #
  # source://puma//lib/puma/dsl.rb#1147
  def worker_boot_timeout(timeout); end

  # Change the default interval for checking workers.
  #
  # The default is 5 seconds.
  #
  # @example
  #   worker_check_interval 10
  # @note Cluster mode only.
  # @see Puma::Cluster#check_workers
  #
  # source://puma//lib/puma/dsl.rb#1105
  def worker_check_interval(interval); end

  # Set the strategy for worker culling.
  #
  # There are two possible values:
  #
  # 1. **:youngest** - the youngest workers (i.e. the workers that were
  #    the most recently started) will be culled.
  # 2. **:oldest** - the oldest workers (i.e. the workers that were started
  #    the longest time ago) will be culled.
  #
  # The default is +:youngest+.
  #
  # @example
  #   worker_culling_strategy :oldest
  # @note Cluster mode only.
  # @see Puma::Cluster#cull_workers
  #
  # source://puma//lib/puma/dsl.rb#1184
  def worker_culling_strategy(strategy); end

  # Set the timeout for worker shutdown.
  #
  # The default is 30 seconds.
  #
  # @example
  #   worker_shutdown_timeout 90
  # @note Cluster mode only.
  # @see Puma::Cluster::Worker#term
  #
  # source://puma//lib/puma/dsl.rb#1162
  def worker_shutdown_timeout(timeout); end

  # Verifies that all workers have checked in to the master process within
  # the given timeout. If not the worker process will be restarted. This is
  # not a request timeout, it is to protect against a hung or dead process.
  # Setting this value will not protect against slow requests.
  #
  # This value must be greater than worker_check_interval.
  #
  # The default is 60 seconds.
  #
  # @example
  #   worker_timeout 60
  # @note Cluster mode only.
  # @see Puma::Cluster::Worker#ping_timeout
  #
  # source://puma//lib/puma/dsl.rb#1125
  def worker_timeout(timeout); end

  # How many worker processes to run.  Typically this is set to
  # the number of available cores.
  #
  # The default is the value of the environment variable +WEB_CONCURRENCY+ if
  # set, otherwise 0.
  #
  # @example
  #   workers 2
  # @note Cluster mode only.
  # @see Puma::Cluster
  #
  # source://puma//lib/puma/dsl.rb#682
  def workers(count); end

  private

  # To avoid adding cert_pem and key_pem as URI params, we store them on the
  # options[:store] from where Puma binder knows how to find and extract them.
  #
  # source://puma//lib/puma/dsl.rb#1453
  def add_pem_values_to_options_store(opts); end

  # @raise [ArgumentError]
  #
  # source://puma//lib/puma/dsl.rb#1469
  def process_hook(options_key, key, block, cluster_only: T.unsafe(nil)); end

  class << self
    # Convenience method so logic can be used in CI.
    #
    # @see ssl_bind
    #
    # source://puma//lib/puma/dsl.rb#59
    def ssl_bind_str(host, port, opts); end
  end
end

# source://puma//lib/puma/dsl.rb#53
Puma::DSL::ON_WORKER_KEY = T.let(T.unsafe(nil), Array)

# The implementation of a detailed error logging.
#
# @version 5.0.0
#
# source://puma//lib/puma/error_logger.rb#9
class Puma::ErrorLogger
  include ::Puma::Const

  # @return [ErrorLogger] a new instance of ErrorLogger
  #
  # source://puma//lib/puma/error_logger.rb#18
  def initialize(ioerr, env: T.unsafe(nil)); end

  # Print occurred error details only if
  # environment variable PUMA_DEBUG is defined.
  # +options+ hash with additional options:
  # - +error+ is an exception object
  # - +req+ the http request
  # - +text+ (default nil) custom string to print in title
  #   and before all remaining info.
  #
  # source://puma//lib/puma/error_logger.rb#47
  def debug(options = T.unsafe(nil)); end

  # Print occurred error details.
  # +options+ hash with additional options:
  # - +error+ is an exception object
  # - +req+ the http request
  # - +text+ (default nil) custom string to print in title
  #   and before all remaining info.
  #
  # source://puma//lib/puma/error_logger.rb#35
  def info(options = T.unsafe(nil)); end

  # Returns the value of attribute ioerr.
  #
  # source://puma//lib/puma/error_logger.rb#12
  def ioerr; end

  # source://puma//lib/puma/error_logger.rb#73
  def request_dump(req); end

  # source://puma//lib/puma/error_logger.rb#91
  def request_headers(req); end

  # @return [Boolean]
  #
  # source://puma//lib/puma/error_logger.rb#96
  def request_parsed?(req); end

  # source://puma//lib/puma/error_logger.rb#78
  def request_title(req); end

  # source://puma//lib/puma/error_logger.rb#61
  def title(options = T.unsafe(nil)); end

  private

  # source://puma//lib/puma/error_logger.rb#100
  def internal_write(str); end

  class << self
    # source://puma//lib/puma/error_logger.rb#24
    def stdio(env: T.unsafe(nil)); end
  end
end

# source://puma//lib/puma/error_logger.rb#16
Puma::ErrorLogger::LOG_QUEUE = T.let(T.unsafe(nil), Thread::Queue)

# source://puma//lib/puma/error_logger.rb#14
Puma::ErrorLogger::REQUEST_FORMAT = T.let(T.unsafe(nil), String)

# This is an event sink used by `Puma::Server` to handle
# lifecycle events such as :after_booted, :before_restart, and :after_stopped.
# Using `Puma::DSL` it is possible to register callback hooks
# for each event type.
#
# source://puma//lib/puma/events.rb#9
class Puma::Events
  # @return [Events] a new instance of Events
  #
  # source://puma//lib/puma/events.rb#11
  def initialize; end

  # source://puma//lib/puma/events.rb#33
  def after_booted(&block); end

  # source://puma//lib/puma/events.rb#41
  def after_stopped(&block); end

  # source://puma//lib/puma/events.rb#37
  def before_restart(&block); end

  # Fire callbacks for the named hook
  #
  # source://puma//lib/puma/events.rb#16
  def fire(hook, *args); end

  # source://puma//lib/puma/events.rb#60
  def fire_after_booted!; end

  # source://puma//lib/puma/events.rb#68
  def fire_after_stopped!; end

  # source://puma//lib/puma/events.rb#64
  def fire_before_restart!; end

  # source://puma//lib/puma/events.rb#45
  def on_booted(&block); end

  # source://puma//lib/puma/events.rb#50
  def on_restart(&block); end

  # source://puma//lib/puma/events.rb#55
  def on_stopped(&block); end

  # Register a callback for a given hook
  #
  # source://puma//lib/puma/events.rb#21
  def register(hook, obj = T.unsafe(nil), &blk); end
end

# @version 5.2.1
#
# source://puma//lib/puma/detect.rb#9
Puma::HAS_FORK = T.let(T.unsafe(nil), TrueClass)

# source://puma//lib/puma/detect.rb#11
Puma::HAS_NATIVE_IO_WAIT = T.let(T.unsafe(nil), TrueClass)

# at present, MiniSSL::Engine is only defined in extension code (puma_http11),
# not in minissl.rb
#
# source://puma//lib/puma.rb#27
Puma::HAS_SSL = T.let(T.unsafe(nil), TrueClass)

# source://puma//lib/puma.rb#29
Puma::HAS_UNIX_SOCKET = T.let(T.unsafe(nil), TrueClass)

# Every standard HTTP code mapped to the appropriate message.
# Generated with:
# curl -s https://www.iana.org/assignments/http-status-codes/http-status-codes-1.csv | \
#   ruby -ne 'm = /^(\d{3}),(?!Unassigned|\(Unused\))([^,]+)/.match($_) and \
#             puts "#{m[1]} => \x27#{m[2].strip}\x27,"'
#
# source://puma//lib/puma/const.rb#17
Puma::HTTP_STATUS_CODES = T.let(T.unsafe(nil), Hash)

class Puma::HttpParser
  # source://puma//lib/puma.rb#12
  def initialize; end

  # source://puma//lib/puma.rb#12
  def body; end

  # source://puma//lib/puma.rb#12
  def error?; end

  # source://puma//lib/puma.rb#12
  def execute(_arg0, _arg1, _arg2); end

  # source://puma//lib/puma.rb#12
  def finish; end

  # source://puma//lib/puma.rb#12
  def finished?; end

  # source://puma//lib/puma.rb#12
  def nread; end

  # source://puma//lib/puma.rb#12
  def reset; end
end

class Puma::HttpParserError < ::StandardError; end

# source://puma//lib/puma/client.rb#18
class Puma::HttpParserError501 < ::IOError; end

# source://puma//lib/puma/io_buffer.rb#6
class Puma::IOBuffer < ::StringIO
  # @return [IOBuffer] a new instance of IOBuffer
  #
  # source://puma//lib/puma/io_buffer.rb#7
  def initialize; end

  # Ruby 3+
  #   StringIO.new.write("a", "b") # => 2
  #
  # source://puma//lib/puma/io_buffer.rb#47
  def append(*_arg0); end

  # source://puma//lib/puma/io_buffer.rb#35
  def clear; end

  # @return [Boolean]
  #
  # source://puma//lib/puma/io_buffer.rb#11
  def empty?; end

  # Read & Reset - returns contents and resets
  #
  # @return [String] StringIO contents
  #
  # source://puma//lib/puma/io_buffer.rb#27
  def read_and_reset; end

  # source://puma//lib/puma/io_buffer.rb#15
  def reset; end

  # source://puma//lib/puma/io_buffer.rb#20
  def to_s; end
end

# source://puma//lib/puma/detect.rb#21
Puma::IS_ARM = T.let(T.unsafe(nil), FalseClass)

# source://puma//lib/puma/detect.rb#13
Puma::IS_JRUBY = T.let(T.unsafe(nil), FalseClass)

# source://puma//lib/puma/detect.rb#19
Puma::IS_LINUX = T.let(T.unsafe(nil), FalseClass)

# @version 5.2.0
#
# source://puma//lib/puma/detect.rb#24
Puma::IS_MRI = T.let(T.unsafe(nil), TrueClass)

# source://puma//lib/puma/detect.rb#15
Puma::IS_OSX = T.let(T.unsafe(nil), TrueClass)

# source://puma//lib/puma/detect.rb#17
Puma::IS_WINDOWS = T.let(T.unsafe(nil), FalseClass)

# Puma deliberately avoids the use of the json gem and instead performs JSON
# serialization without any external dependencies. In a puma cluster, loading
# any gem into the puma master process means that operators cannot use a
# phased restart to upgrade their application if the new version of that
# application uses a different version of that gem. The json gem in
# particular is additionally problematic because it leverages native
# extensions. If the puma master process relies on a gem with native
# extensions and operators remove gems from disk related to old releases,
# subsequent phased restarts can fail.
#
# The implementation of JSON serialization in this module is not designed to
# be particularly full-featured or fast. It just has to handle the few places
# where Puma relies on JSON serialization internally.
#
# source://puma//lib/puma/json_serialization.rb#20
module Puma::JSONSerialization
  class << self
    # source://puma//lib/puma/json_serialization.rb#29
    def generate(value); end

    private

    # source://puma//lib/puma/json_serialization.rb#86
    def serialize_object_key(output, value); end

    # source://puma//lib/puma/json_serialization.rb#71
    def serialize_string(output, value); end

    # source://puma//lib/puma/json_serialization.rb#38
    def serialize_value(output, value); end
  end
end

# source://puma//lib/puma/json_serialization.rb#22
Puma::JSONSerialization::BACKSLASH = T.let(T.unsafe(nil), Regexp)

# source://puma//lib/puma/json_serialization.rb#24
Puma::JSONSerialization::CHAR_TO_ESCAPE = T.let(T.unsafe(nil), Regexp)

# As required by ECMA-404
#
# source://puma//lib/puma/json_serialization.rb#23
Puma::JSONSerialization::CONTROL_CHAR_TO_ESCAPE = T.let(T.unsafe(nil), Regexp)

# source://puma//lib/puma/json_serialization.rb#21
Puma::JSONSerialization::QUOTE = T.let(T.unsafe(nil), Regexp)

# source://puma//lib/puma/json_serialization.rb#26
class Puma::JSONSerialization::SerializationError < ::StandardError; end

# Puma::Launcher is the single entry point for starting a Puma server based on user
# configuration. It is responsible for taking user supplied arguments and resolving them
# with configuration in `config/puma.rb` or `config/puma/<env>.rb`.
#
# It is responsible for either launching a cluster of Puma workers or a single
# puma server.
#
# source://puma//lib/puma/launcher.rb#18
class Puma::Launcher
  # Returns an instance of Launcher
  #
  # +conf+ A Puma::Configuration object indicating how to run the server.
  #
  # +launcher_args+ A Hash that has a few optional keys.
  # - +:log_writer+:: Expected to hold an object similar to `Puma::LogWriter.stdio`.
  #   This object will be responsible for broadcasting Puma's internal state
  #   to a logging destination.
  # - +:events+:: Expected to hold an object similar to `Puma::Events`.
  # - +:argv+:: Expected to be an array of strings.
  # - +:env+:: Expected to hold a hash of environment variables.
  #
  # These arguments are re-used when restarting the puma server.
  #
  # Examples:
  #
  #   conf = Puma::Configuration.new do |user_config|
  #     user_config.threads 1, 10
  #     user_config.app do |env|
  #       [200, {}, ["hello world"]]
  #     end
  #   end
  #   Puma::Launcher.new(conf, log_writer: Puma::LogWriter.stdio).run
  #
  # @return [Launcher] a new instance of Launcher
  #
  # source://puma//lib/puma/launcher.rb#44
  def initialize(conf, launcher_args = T.unsafe(nil)); end

  # Returns the value of attribute binder.
  #
  # source://puma//lib/puma/launcher.rb#114
  def binder; end

  # source://puma//lib/puma/launcher.rb#229
  def close_binder_listeners; end

  # Returns the value of attribute config.
  #
  # source://puma//lib/puma/launcher.rb#114
  def config; end

  # Return all tcp ports the launcher may be using, TCP or SSL
  #
  # @version 5.0.0
  #
  # source://puma//lib/puma/launcher.rb#215
  def connected_ports; end

  # Delete the configured pidfile
  #
  # source://puma//lib/puma/launcher.rb#142
  def delete_pidfile; end

  # Returns the value of attribute events.
  #
  # source://puma//lib/puma/launcher.rb#114
  def events; end

  # Begin async shutdown of the server
  #
  # source://puma//lib/puma/launcher.rb#151
  def halt; end

  # Returns the value of attribute log_writer.
  #
  # source://puma//lib/puma/launcher.rb#114
  def log_writer; end

  # Returns the value of attribute options.
  #
  # source://puma//lib/puma/launcher.rb#114
  def options; end

  # Begin a phased restart if supported
  #
  # source://puma//lib/puma/launcher.rb#169
  def phased_restart; end

  # Begin a refork if supported
  #
  # source://puma//lib/puma/launcher.rb#185
  def refork; end

  # Begin async restart of the server
  #
  # source://puma//lib/puma/launcher.rb#163
  def restart; end

  # source://puma//lib/puma/launcher.rb#220
  def restart_args; end

  # Returns the value of attribute restart_dir.
  #
  # source://puma//lib/puma/launcher.rb#114
  def restart_dir; end

  # Run the server. This blocks until the server is stopped
  #
  # source://puma//lib/puma/launcher.rb#196
  def run; end

  # Return stats about the server
  #
  # source://puma//lib/puma/launcher.rb#117
  def stats; end

  # Begin async shutdown of the server gracefully
  #
  # source://puma//lib/puma/launcher.rb#157
  def stop; end

  # @version 5.0.0
  #
  # source://puma//lib/puma/launcher.rb#240
  def thread_status; end

  # Write a state file that can be used by pumactl to control
  # the server
  #
  # source://puma//lib/puma/launcher.rb#123
  def write_state; end

  private

  # @return [Boolean]
  #
  # source://puma//lib/puma/launcher.rb#341
  def clustered?; end

  # source://puma//lib/puma/launcher.rb#278
  def do_forceful_stop; end

  # source://puma//lib/puma/launcher.rb#283
  def do_graceful_stop; end

  # source://puma//lib/puma/launcher.rb#288
  def do_restart(previous_env); end

  # source://puma//lib/puma/launcher.rb#265
  def do_run_finished(previous_env); end

  # source://puma//lib/puma/launcher.rb#367
  def environment; end

  # source://puma//lib/puma/launcher.rb#380
  def generate_restart_data; end

  # source://puma//lib/puma/launcher.rb#253
  def get_env; end

  # source://puma//lib/puma/launcher.rb#337
  def log(str); end

  # source://puma//lib/puma/launcher.rb#492
  def log_config; end

  # source://puma//lib/puma/launcher.rb#375
  def prune_bundler!; end

  # @return [Boolean]
  #
  # source://puma//lib/puma/launcher.rb#371
  def prune_bundler?; end

  # source://puma//lib/puma/launcher.rb#333
  def reload_worker_directory; end

  # source://puma//lib/puma/launcher.rb#295
  def restart!; end

  # source://puma//lib/puma/launcher.rb#350
  def set_process_title; end

  # source://puma//lib/puma/launcher.rb#361
  def set_rack_environment; end

  # source://puma//lib/puma/launcher.rb#425
  def setup_signals; end

  # source://puma//lib/puma/launcher.rb#355
  def title; end

  # @raise [UnsupportedOption]
  #
  # source://puma//lib/puma/launcher.rb#345
  def unsupported(str); end

  # If configured, write the pid of the current process out
  # to a file.
  #
  # source://puma//lib/puma/launcher.rb#323
  def write_pid; end
end

# This class is used to pickup Gemfile changes during
# application restarts.
#
# source://puma//lib/puma/launcher/bundle_pruner.rb#8
class Puma::Launcher::BundlePruner
  # @return [BundlePruner] a new instance of BundlePruner
  #
  # source://puma//lib/puma/launcher/bundle_pruner.rb#10
  def initialize(original_argv, extra_runtime_dependencies, log_writer); end

  # source://puma//lib/puma/launcher/bundle_pruner.rb#16
  def prune; end

  private

  # source://puma//lib/puma/launcher/bundle_pruner.rb#75
  def extra_runtime_deps_paths; end

  # source://puma//lib/puma/launcher/bundle_pruner.rb#99
  def log(str); end

  # source://puma//lib/puma/launcher/bundle_pruner.rb#71
  def paths_to_require_after_prune; end

  # source://puma//lib/puma/launcher/bundle_pruner.rb#87
  def puma_require_paths; end

  # source://puma//lib/puma/launcher/bundle_pruner.rb#57
  def puma_wild_path; end

  # source://puma//lib/puma/launcher/bundle_pruner.rb#95
  def require_paths_for_gem(gem_spec); end

  # source://puma//lib/puma/launcher/bundle_pruner.rb#48
  def require_rubygems_min_version!; end

  # source://puma//lib/puma/launcher/bundle_pruner.rb#91
  def spec_for_gem(gem_name); end

  # source://puma//lib/puma/launcher/bundle_pruner.rb#62
  def with_unbundled_env; end
end

# Handles logging concerns for both standard messages
# (+stdout+) and errors (+stderr+).
#
# source://puma//lib/puma/log_writer.rb#12
class Puma::LogWriter
  # Create a LogWriter that prints to +stdout+ and +stderr+.
  #
  # @return [LogWriter] a new instance of LogWriter
  #
  # source://puma//lib/puma/log_writer.rb#34
  def initialize(stdout, stderr, env: T.unsafe(nil)); end

  # An HTTP connection error has occurred.
  # +error+ a connection exception, +req+ the request,
  # and +text+ additional info
  #
  # @version 5.0.0
  #
  # source://puma//lib/puma/log_writer.rb#111
  def connection_error(error, req, text = T.unsafe(nil)); end

  # Returns the value of attribute custom_logger.
  #
  # source://puma//lib/puma/log_writer.rb#31
  def custom_logger; end

  # Sets the attribute custom_logger
  #
  # @param value the value to set the attribute custom_logger to.
  #
  # source://puma//lib/puma/log_writer.rb#31
  def custom_logger=(_arg0); end

  # source://puma//lib/puma/log_writer.rb#93
  def debug(str); end

  # @return [Boolean]
  #
  # source://puma//lib/puma/log_writer.rb#89
  def debug?; end

  # Log occurred error debug dump.
  # +error+ an exception object, +req+ the request,
  # and +text+ additional info
  #
  # @version 5.0.0
  #
  # source://puma//lib/puma/log_writer.rb#143
  def debug_error(error, req = T.unsafe(nil), text = T.unsafe(nil)); end

  # Write +str+ to +@stderr+
  #
  # source://puma//lib/puma/log_writer.rb#98
  def error(str); end

  # source://puma//lib/puma/log_writer.rb#103
  def format(str); end

  # Returns the value of attribute formatter.
  #
  # source://puma//lib/puma/log_writer.rb#31
  def formatter; end

  # Sets the attribute formatter
  #
  # @param value the value to set the attribute formatter to.
  #
  # source://puma//lib/puma/log_writer.rb#31
  def formatter=(_arg0); end

  # Write +str+ to +@stdout+
  #
  # source://puma//lib/puma/log_writer.rb#62
  def log(str); end

  # An HTTP parse error has occurred.
  # +error+ a parsing exception,
  # and +req+ the request.
  #
  # source://puma//lib/puma/log_writer.rb#118
  def parse_error(error, req); end

  # An SSL error has occurred.
  #
  # @param error [Puma::MiniSSL::SSLError]
  # @param ssl_socket [Puma::MiniSSL::Socket]
  #
  # source://puma//lib/puma/log_writer.rb#125
  def ssl_error(error, ssl_socket); end

  # Returns the value of attribute stderr.
  #
  # source://puma//lib/puma/log_writer.rb#28
  def stderr; end

  # Returns the value of attribute stdout.
  #
  # source://puma//lib/puma/log_writer.rb#28
  def stdout; end

  # An unknown error has occurred.
  # +error+ an exception object, +req+ the request,
  # and +text+ additional info
  #
  # source://puma//lib/puma/log_writer.rb#135
  def unknown_error(error, req = T.unsafe(nil), text = T.unsafe(nil)); end

  # source://puma//lib/puma/log_writer.rb#70
  def write(str); end

  private

  # source://puma//lib/puma/log_writer.rb#74
  def internal_write(str); end

  class << self
    # source://puma//lib/puma/log_writer.rb#56
    def null(env: T.unsafe(nil)); end

    # source://puma//lib/puma/log_writer.rb#52
    def stdio(env: T.unsafe(nil)); end

    # Returns an LogWriter object which writes its status to
    # two StringIO objects.
    #
    # source://puma//lib/puma/log_writer.rb#48
    def strings(env: T.unsafe(nil)); end
  end
end

# source://puma//lib/puma/log_writer.rb#44
Puma::LogWriter::DEFAULT = T.let(T.unsafe(nil), Puma::LogWriter)

# source://puma//lib/puma/log_writer.rb#14
class Puma::LogWriter::DefaultFormatter
  # source://puma//lib/puma/log_writer.rb#15
  def call(str); end
end

# source://puma//lib/puma/log_writer.rb#26
Puma::LogWriter::LOG_QUEUE = T.let(T.unsafe(nil), Thread::Queue)

# source://puma//lib/puma/log_writer.rb#20
class Puma::LogWriter::PidFormatter
  # source://puma//lib/puma/log_writer.rb#21
  def call(str); end
end

# source://puma//lib/puma/minissl.rb#14
module Puma::MiniSSL
  class << self
    # source://puma//lib/puma.rb#12
    def check; end
  end
end

# source://puma//lib/puma/minissl.rb#207
class Puma::MiniSSL::Context
  # @return [Context] a new instance of Context
  #
  # source://puma//lib/puma/minissl.rb#211
  def initialize; end

  # Returns the value of attribute ca.
  #
  # source://puma//lib/puma/minissl.rb#287
  def ca; end

  # source://puma//lib/puma/minissl.rb#310
  def ca=(ca); end

  # Returns the value of attribute cert.
  #
  # source://puma//lib/puma/minissl.rb#286
  def cert; end

  # source://puma//lib/puma/minissl.rb#305
  def cert=(cert); end

  # Returns the value of attribute cert_pem.
  #
  # source://puma//lib/puma/minissl.rb#288
  def cert_pem; end

  # @raise [ArgumentError]
  #
  # source://puma//lib/puma/minissl.rb#315
  def cert_pem=(cert_pem); end

  # source://puma//lib/puma/minissl.rb#325
  def check; end

  # @raise [ArgumentError]
  #
  # source://puma//lib/puma/minissl.rb#223
  def check_file(file, desc); end

  # non-jruby Context properties
  #
  # source://puma//lib/puma/minissl.rb#284
  def key; end

  # source://puma//lib/puma/minissl.rb#296
  def key=(key); end

  # Executes the command to return the password needed to decrypt the key.
  #
  # source://puma//lib/puma/minissl.rb#331
  def key_password; end

  # Returns the value of attribute key_password_command.
  #
  # source://puma//lib/puma/minissl.rb#285
  def key_password_command; end

  # source://puma//lib/puma/minissl.rb#301
  def key_password_command=(key_password_command); end

  # Returns the value of attribute key_pem.
  #
  # source://puma//lib/puma/minissl.rb#289
  def key_pem; end

  # @raise [ArgumentError]
  #
  # source://puma//lib/puma/minissl.rb#320
  def key_pem=(key_pem); end

  # Returns the value of attribute no_tlsv1.
  #
  # source://puma//lib/puma/minissl.rb#209
  def no_tlsv1; end

  # disables TLSv1
  #
  # @raise [ArgumentError]
  #
  # source://puma//lib/puma/minissl.rb#373
  def no_tlsv1=(tlsv1); end

  # Returns the value of attribute no_tlsv1_1.
  #
  # source://puma//lib/puma/minissl.rb#209
  def no_tlsv1_1; end

  # disables TLSv1 and TLSv1.1.  Overrides `#no_tlsv1=`
  #
  # @raise [ArgumentError]
  #
  # source://puma//lib/puma/minissl.rb#380
  def no_tlsv1_1=(tlsv1_1); end

  # Returns the value of attribute reuse.
  #
  # source://puma//lib/puma/minissl.rb#294
  def reuse; end

  # Controls session reuse.  Allowed values are as follows:
  # * 'off' - matches the behavior of Puma 5.6 and earlier.  This is included
  #   in case reuse 'on' is made the default in future Puma versions.
  # * 'dflt' - sets session reuse on, with OpenSSL default cache size of
  #   20k and default timeout of 300 seconds.
  # * 's,t' - where s and t are integer strings, for size and timeout.
  # * 's' - where s is an integer strings for size.
  # * ',t' - where t is an integer strings for timeout.
  #
  # source://puma//lib/puma/minissl.rb#350
  def reuse=(reuse_str); end

  # Returns the value of attribute reuse_cache_size.
  #
  # source://puma//lib/puma/minissl.rb#294
  def reuse_cache_size; end

  # Returns the value of attribute reuse_timeout.
  #
  # source://puma//lib/puma/minissl.rb#294
  def reuse_timeout; end

  # Returns the value of attribute ssl_cipher_filter.
  #
  # source://puma//lib/puma/minissl.rb#290
  def ssl_cipher_filter; end

  # Sets the attribute ssl_cipher_filter
  #
  # @param value the value to set the attribute ssl_cipher_filter to.
  #
  # source://puma//lib/puma/minissl.rb#290
  def ssl_cipher_filter=(_arg0); end

  # Returns the value of attribute ssl_ciphersuites.
  #
  # source://puma//lib/puma/minissl.rb#291
  def ssl_ciphersuites; end

  # Sets the attribute ssl_ciphersuites
  #
  # @param value the value to set the attribute ssl_ciphersuites to.
  #
  # source://puma//lib/puma/minissl.rb#291
  def ssl_ciphersuites=(_arg0); end

  # Returns the value of attribute verification_flags.
  #
  # source://puma//lib/puma/minissl.rb#292
  def verification_flags; end

  # Sets the attribute verification_flags
  #
  # @param value the value to set the attribute verification_flags to.
  #
  # source://puma//lib/puma/minissl.rb#292
  def verification_flags=(_arg0); end

  # Returns the value of attribute verify_mode.
  #
  # source://puma//lib/puma/minissl.rb#208
  def verify_mode; end

  # Sets the attribute verify_mode
  #
  # @param value the value to set the attribute verify_mode to.
  #
  # source://puma//lib/puma/minissl.rb#208
  def verify_mode=(_arg0); end
end

# source://puma//lib/puma/minissl/context_builder.rb#3
class Puma::MiniSSL::ContextBuilder
  # @return [ContextBuilder] a new instance of ContextBuilder
  #
  # source://puma//lib/puma/minissl/context_builder.rb#4
  def initialize(params, log_writer); end

  # source://puma//lib/puma/minissl/context_builder.rb#9
  def context; end

  private

  # Returns the value of attribute log_writer.
  #
  # source://puma//lib/puma/minissl/context_builder.rb#93
  def log_writer; end

  # Returns the value of attribute params.
  #
  # source://puma//lib/puma/minissl/context_builder.rb#93
  def params; end
end

class Puma::MiniSSL::Engine
  # source://puma//lib/puma.rb#12
  def extract; end

  # source://puma//lib/puma.rb#12
  def init?; end

  # source://puma//lib/puma.rb#12
  def inject(_arg0); end

  # source://puma//lib/puma.rb#12
  def peercert; end

  # source://puma//lib/puma.rb#12
  def read; end

  # source://puma//lib/puma.rb#12
  def shutdown; end

  # source://puma//lib/puma.rb#12
  def ssl_vers_st; end

  # source://puma//lib/puma.rb#12
  def write(_arg0); end

  class << self
    # source://puma//lib/puma.rb#12
    def client; end

    # source://puma//lib/puma.rb#12
    def server(_arg0); end
  end
end

# Define constant at runtime, as it's easy to determine at built time,
# but Puma could (it shouldn't) be loaded with an older OpenSSL version
#
# @version 5.0.0
#
# source://puma//lib/puma/minissl.rb#18
Puma::MiniSSL::HAS_TLS1_3 = T.let(T.unsafe(nil), TrueClass)

Puma::MiniSSL::OPENSSL_LIBRARY_VERSION = T.let(T.unsafe(nil), String)
Puma::MiniSSL::OPENSSL_NO_SSL3 = T.let(T.unsafe(nil), TrueClass)
Puma::MiniSSL::OPENSSL_NO_TLS1 = T.let(T.unsafe(nil), FalseClass)
Puma::MiniSSL::OPENSSL_NO_TLS1_1 = T.let(T.unsafe(nil), FalseClass)
Puma::MiniSSL::OPENSSL_VERSION = T.let(T.unsafe(nil), String)

class Puma::MiniSSL::SSLContext
  # source://puma//lib/puma.rb#12
  def initialize(_arg0); end
end

# this class is defined so that it exists when Puma is compiled
# without ssl support, as Server and Reactor use it in rescue statements.
class Puma::MiniSSL::SSLError < ::StandardError; end

# source://puma//lib/puma/minissl.rb#417
class Puma::MiniSSL::Server
  # @return [Server] a new instance of Server
  #
  # source://puma//lib/puma/minissl.rb#418
  def initialize(socket, ctx); end

  # source://puma//lib/puma/minissl.rb#424
  def accept; end

  # source://puma//lib/puma/minissl.rb#431
  def accept_nonblock; end

  # @version 5.0.0
  #
  # source://puma//lib/puma/minissl.rb#445
  def addr; end

  # source://puma//lib/puma/minissl.rb#449
  def close; end

  # @return [Boolean]
  #
  # source://puma//lib/puma/minissl.rb#453
  def closed?; end

  # source://puma//lib/puma/minissl.rb#439
  def to_io; end
end

# source://puma//lib/puma/minissl.rb#22
class Puma::MiniSSL::Socket
  # @return [Socket] a new instance of Socket
  #
  # source://puma//lib/puma/minissl.rb#23
  def initialize(socket, engine); end

  # source://puma//lib/puma/minissl.rb#144
  def <<(data); end

  # source://puma//lib/puma/minissl.rb#167
  def close; end

  # @return [Boolean]
  #
  # source://puma//lib/puma/minissl.rb#35
  def closed?; end

  # source://puma//lib/puma/minissl.rb#77
  def engine_read_all; end

  # source://puma//lib/puma/minissl.rb#163
  def flush; end

  # source://puma//lib/puma/minissl.rb#182
  def peeraddr; end

  # OpenSSL is loaded in `MiniSSL::ContextBuilder` when
  # `MiniSSL::Context#verify_mode` is not `VERIFY_NONE`.
  # When `VERIFY_NONE`, `MiniSSL::Engine#peercert` is nil, regardless of
  # whether the client sends a cert.
  #
  # @return [OpenSSL::X509::Certificate, nil]
  #
  # source://puma//lib/puma/minissl.rb#192
  def peercert; end

  # source://puma//lib/puma/minissl.rb#85
  def read_nonblock(size, *_); end

  # source://puma//lib/puma/minissl.rb#60
  def readpartial(size); end

  # Returns a two element array,
  # first is protocol version (SSL_get_version),
  # second is 'handshake' state (SSL_state_string)
  #
  # Used for dropping tcp connections to ssl.
  # See OpenSSL ssl/ssl_stat.c SSL_state_string for info
  #
  # @version 5.0.0
  #
  # source://puma//lib/puma/minissl.rb#48
  def ssl_version_state; end

  # source://puma//lib/puma/minissl.rb#143
  def syswrite(data); end

  # source://puma//lib/puma/minissl.rb#31
  def to_io; end

  # source://puma//lib/puma/minissl.rb#120
  def write(data); end

  # The problem with implementing it properly
  # is that it means we'd have to have the ability to rewind
  # an engine because after we write+extract, the socket
  # write_nonblock call might raise an exception and later
  # code would pass the same data in, but the engine would think
  # it had already written the data in.
  #
  # So for the time being (and since write blocking is quite rare),
  # go ahead and actually block in write_nonblock.
  #
  # source://puma//lib/puma/minissl.rb#159
  def write_nonblock(data, *_); end

  private

  # Used to check the handshake status, in particular when a TCP connection
  # is made with TLSv1.3 as an available protocol
  #
  # @return [Boolean]
  # @version 5.0.0
  #
  # source://puma//lib/puma/minissl.rb#55
  def bad_tlsv1_3?; end
end

# https://github.com/openssl/openssl/blob/master/include/openssl/x509_vfy.h.in
# /* Certificate verify flags */
#
# source://puma//lib/puma/minissl.rb#393
Puma::MiniSSL::VERIFICATION_FLAGS = T.let(T.unsafe(nil), Hash)

# source://puma//lib/puma/minissl.rb#389
Puma::MiniSSL::VERIFY_FAIL_IF_NO_PEER_CERT = T.let(T.unsafe(nil), Integer)

# source://puma//lib/puma/minissl.rb#387
Puma::MiniSSL::VERIFY_NONE = T.let(T.unsafe(nil), Integer)

# source://puma//lib/puma/minissl.rb#388
Puma::MiniSSL::VERIFY_PEER = T.let(T.unsafe(nil), Integer)

# Provides an IO-like object that always appears to contain no data.
# Used as the value for rack.input when the request has no body.
#
# source://puma//lib/puma/null_io.rb#7
class Puma::NullIO
  # source://puma//lib/puma/null_io.rb#93
  def binmode; end

  # @return [Boolean]
  #
  # source://puma//lib/puma/null_io.rb#97
  def binmode?; end

  # source://puma//lib/puma/null_io.rb#51
  def close; end

  # This is used as singleton class, so can't have state.
  #
  # @return [Boolean]
  #
  # source://puma//lib/puma/null_io.rb#80
  def closed?; end

  # source://puma//lib/puma/null_io.rb#16
  def each; end

  # @return [Boolean]
  #
  # source://puma//lib/puma/null_io.rb#58
  def eof?; end

  # per rack spec
  #
  # source://puma//lib/puma/null_io.rb#89
  def external_encoding; end

  # source://puma//lib/puma/null_io.rb#75
  def flush; end

  # source://puma//lib/puma/null_io.rb#8
  def gets; end

  # source://puma//lib/puma/null_io.rb#19
  def pos; end

  # source://puma//lib/puma/null_io.rb#69
  def puts(*ary); end

  # Mimics IO#read with no data.
  #
  # source://puma//lib/puma/null_io.rb#25
  def read(length = T.unsafe(nil), buffer = T.unsafe(nil)); end

  # source://puma//lib/puma/null_io.rb#43
  def rewind; end

  # @raise [ArgumentError]
  #
  # source://puma//lib/puma/null_io.rb#46
  def seek(pos, whence = T.unsafe(nil)); end

  # source://puma//lib/puma/null_io.rb#84
  def set_encoding(enc); end

  # source://puma//lib/puma/null_io.rb#54
  def size; end

  # source://puma//lib/puma/null_io.rb#12
  def string; end

  # source://puma//lib/puma/null_io.rb#62
  def sync; end

  # source://puma//lib/puma/null_io.rb#66
  def sync=(v); end

  # source://puma//lib/puma/null_io.rb#72
  def write(*ary); end
end

# source://puma//lib/puma/plugin.rb#76
class Puma::Plugin
  # source://puma//lib/puma/plugin.rb#107
  def in_background(&blk); end

  class << self
    # source://puma//lib/puma/plugin.rb#97
    def create(&blk); end

    # source://puma//lib/puma/plugin.rb#90
    def extract_name(ary); end
  end
end

# Matches
#  "C:/Ruby22/lib/ruby/gems/2.2.0/gems/puma-3.0.1/lib/puma/plugin/tmp_restart.rb:3:in `<top (required)>'"
#  AS
#  C:/Ruby22/lib/ruby/gems/2.2.0/gems/puma-3.0.1/lib/puma/plugin/tmp_restart.rb
#
# source://puma//lib/puma/plugin.rb#81
Puma::Plugin::CALLER_FILE = T.let(T.unsafe(nil), Regexp)

# source://puma//lib/puma/plugin.rb#6
class Puma::PluginLoader
  # @return [PluginLoader] a new instance of PluginLoader
  #
  # source://puma//lib/puma/plugin.rb#7
  def initialize; end

  # @raise [UnknownPlugin]
  #
  # source://puma//lib/puma/plugin.rb#11
  def create(name); end

  # source://puma//lib/puma/plugin.rb#21
  def fire_starts(launcher); end
end

# source://puma//lib/puma/plugin.rb#30
class Puma::PluginRegistry
  # @return [PluginRegistry] a new instance of PluginRegistry
  #
  # source://puma//lib/puma/plugin.rb#31
  def initialize; end

  # source://puma//lib/puma/plugin.rb#60
  def add_background(blk); end

  # @raise [UnknownPlugin]
  #
  # source://puma//lib/puma/plugin.rb#40
  def find(name); end

  # source://puma//lib/puma/plugin.rb#64
  def fire_background; end

  # source://puma//lib/puma/plugin.rb#36
  def register(name, cls); end
end

# source://puma//lib/puma/plugin.rb#74
Puma::Plugins = T.let(T.unsafe(nil), Puma::PluginRegistry)

# Monitors a collection of IO objects, calling a block whenever
# any monitored object either receives data or times out, or when the Reactor shuts down.
#
# The waiting/wake up is performed with nio4r, which will use the appropriate backend (libev,
# Java NIO or just plain IO#select). The call to `NIO::Selector#select` will
# 'wakeup' any IO object that receives data.
#
# This class additionally tracks a timeout for every added object,
# and wakes up any object when its timeout elapses.
#
# The implementation uses a Queue to synchronize adding new objects from the internal select loop.
#
# source://puma//lib/puma/reactor.rb#17
class Puma::Reactor
  # Create a new Reactor to monitor IO objects added by #add.
  # The provided block will be invoked when an IO has data available to read,
  # its timeout elapses, or when the Reactor shuts down.
  #
  # @return [Reactor] a new instance of Reactor
  #
  # source://puma//lib/puma/reactor.rb#27
  def initialize(backend, &block); end

  # Add a new client to monitor.
  # The object must respond to #timeout and #timeout_at.
  # Returns false if the reactor is already shut down.
  #
  # source://puma//lib/puma/reactor.rb#57
  def add(client); end

  # Maximum number of clients in the selector.  Reset with calls to `Server.stats`.
  #
  # source://puma//lib/puma/reactor.rb#21
  def reactor_max; end

  # Sets the attribute reactor_max
  #
  # @param value the value to set the attribute reactor_max to.
  #
  # source://puma//lib/puma/reactor.rb#21
  def reactor_max=(_arg0); end

  # Returns the value of attribute reactor_size.
  #
  # source://puma//lib/puma/reactor.rb#22
  def reactor_size; end

  # Run the internal select loop, using a background thread by default.
  #
  # source://puma//lib/puma/reactor.rb#43
  def run(background = T.unsafe(nil)); end

  # Shutdown the reactor, blocking until the background thread is finished.
  #
  # source://puma//lib/puma/reactor.rb#66
  def shutdown; end

  private

  # Start monitoring the object.
  #
  # source://puma//lib/puma/reactor.rb#121
  def register(client); end

  # source://puma//lib/puma/reactor.rb#77
  def select_loop; end

  # 'Wake up' a monitored object by calling the provided block.
  # Stop monitoring the object if the block returns `true`.
  #
  # source://puma//lib/puma/reactor.rb#132
  def wakeup!(client); end
end

# The methods here are included in Server, but are separated into this file.
# All the methods here pertain to passing the request to the app, then
# writing the response back to the client.
#
# None of the methods here are called externally, with the exception of
# #handle_request, which is called in Server#process_client.
#
# @version 5.0.3
#
# source://puma//lib/puma/request.rb#15
module Puma::Request
  include ::Puma::Const

  # @param env [Hash] see Puma::Client#env, from request
  # @return [Puma::Const::PORT_443, Puma::Const::PORT_80]
  #
  # source://puma//lib/puma/request.rb#282
  def default_server_port(env); end

  # Takes the request contained in +client+, invokes the Rack application to construct
  # the response and writes it back to +client.io+.
  #
  # It'll return +false+ when the connection is closed, this doesn't mean
  # that the response wasn't successful.
  #
  # It'll return +:async+ if the connection remains open but will be handled
  # elsewhere, i.e. the connection has been hijacked by the Rack application.
  #
  # Finally, it'll return +true+ on keep-alive connections.
  #
  # @param client [Puma::Client]
  # @param requests [Integer]
  # @return [Boolean, :async]
  #
  # source://puma//lib/puma/request.rb#50
  def handle_request(client, requests); end

  # Assembles the headers and prepares the body for actually sending the
  # response via `#fast_write_response`.
  #
  # @param client [Puma::Client]
  # @param headers [Hash] the headers returned by the Rack application
  # @param requests [Integer] number of inline requests handled
  # @param res_body [Array] the body returned by the Rack application or
  #   a call to `Server#lowlevel_error`
  # @param status [Integer] the status returned by the Rack application
  # @return [Boolean, :async] keep-alive status or `:async`
  #
  # source://puma//lib/puma/request.rb#171
  def prepare_response(status, headers, res_body, requests, client); end

  private

  # Used to write headers and body.
  # Writes to a socket (normally `Client#io`) using `#fast_write_str`.
  # Accumulates `body` items into `io_buffer`, then writes to socket.
  #
  # @param body [Enumerable, File] the body object
  # @param chunked [Boolean]
  # @param io_buffer [Puma::IOBuffer] contains headers
  # @param socket [#write] the response socket
  # @raise [ConnectionError]
  #
  # source://puma//lib/puma/request.rb#329
  def fast_write_response(socket, body, io_buffer, chunked, content_length); end

  # Used to write 'early hints', 'no body' responses, 'hijacked' responses,
  # and body segments (called by `fast_write_response`).
  # Writes a string to a socket (normally `Client#io`) using `write_nonblock`.
  # Large strings may not be written in one pass, especially if `io` is a
  # `MiniSSL::Socket`.
  #
  # @param socket [#write_nonblock] the request/response socket
  # @param str [String] the string written to the io
  # @raise [ConnectionError]
  #
  # source://puma//lib/puma/request.rb#302
  def fast_write_str(socket, str); end

  # @param status [Integer] status from the app
  # @return [String] the text description from Puma::HTTP_STATUS_CODES
  #
  # source://puma//lib/puma/request.rb#584
  def fetch_status_code(status); end

  # @param header_key [#to_s]
  # @return [Boolean]
  #
  # source://puma//lib/puma/request.rb#497
  def illegal_header_key?(header_key); end

  # @param header_value [#to_s]
  # @return [Boolean]
  #
  # source://puma//lib/puma/request.rb#504
  def illegal_header_value?(header_value); end

  # Given a Hash +env+ for the request read from +client+, add
  # and fixup keys to comply with Rack's env guidelines.
  #
  # @param client [Puma::Client] only needed for Client#peerip
  # @param env [Hash] see Puma::Client#env, from request
  #
  # source://puma//lib/puma/request.rb#420
  def normalize_env(env, client); end

  # Fixup any headers with `,` in the name to have `_` now. We emit
  # headers with `,` in them during the parse phase to avoid ambiguity
  # with the `-` to `_` conversion for critical headers. But here for
  # compatibility, we'll convert them back. This code is written to
  # avoid allocation in the common case (ie there are no headers
  # with `,` in their names), that's why it has the extra conditionals.
  #
  # @note If a normalized version of a `,` header already exists, we ignore
  #   the `,` version. This prevents clobbering headers managed by proxies
  #   but not by clients (Like X-Forwarded-For).
  # @param env [Hash] see Puma::Client#env, from request, modifies in place
  # @version 5.0.3
  #
  # source://puma//lib/puma/request.rb#523
  def req_env_post_parse(env); end

  # Used in the lambda for env[ `Puma::Const::EARLY_HINTS` ]
  #
  # @param headers [Hash] the headers returned by the Rack application
  # @return [String]
  # @version 5.0.3
  #
  # source://puma//lib/puma/request.rb#563
  def str_early_hints(headers); end

  # Processes and write headers to the IOBuffer.
  #
  # @param content_length [Integer, nil] content length if it can be determined from the
  #   response body
  # @param env [Hash] see Puma::Client#env, from request
  # @param force_keep_alive [Boolean] 'anded' with keep_alive, based on system
  #   status and `@max_keep_alive`
  # @param headers [Hash] the headers returned by the Rack application
  # @param io_buffer [Puma::IOBuffer] modified inn place
  # @param status [Integer] the status returned by the Rack application
  # @return [Hash] resp_info
  # @version 5.0.3
  #
  # source://puma//lib/puma/request.rb#601
  def str_headers(env, status, headers, res_body, io_buffer, force_keep_alive); end
end

# Single element array body: smaller bodies are written to io_buffer first,
# then a single write from io_buffer. Larger sizes are written separately.
# Also fixes max size of chunked file body read.
#
# source://puma//lib/puma/request.rb#20
Puma::Request::BODY_LEN_MAX = T.let(T.unsafe(nil), Integer)

# source://puma//lib/puma/request.rb#32
Puma::Request::CUSTOM_STAT = T.let(T.unsafe(nil), String)

# source://puma//lib/puma/request.rb#276
Puma::Request::HTTP_ON_VALUES = T.let(T.unsafe(nil), Hash)

# File body: smaller bodies are combined with io_buffer, then written to
# socket.  Larger bodies are written separately using `copy_stream`
#
# source://puma//lib/puma/request.rb#24
Puma::Request::IO_BODY_MAX = T.let(T.unsafe(nil), Integer)

# Array body: elements are collected in io_buffer.  When io_buffer's size
# exceeds value, they are written to the socket.
#
# source://puma//lib/puma/request.rb#28
Puma::Request::IO_BUFFER_LEN_MAX = T.let(T.unsafe(nil), Integer)

# source://puma//lib/puma/request.rb#30
Puma::Request::SOCKET_WRITE_ERR_MSG = T.let(T.unsafe(nil), String)

# Generic class that is used by `Puma::Cluster` and `Puma::Single` to
# serve requests. This class spawns a new instance of `Puma::Server` via
# a call to `start_server`.
#
# source://puma//lib/puma/runner.rb#10
class Puma::Runner
  include ::Puma::Const::PipeRequest

  # @return [Runner] a new instance of Runner
  #
  # source://puma//lib/puma/runner.rb#14
  def initialize(launcher); end

  # source://puma//lib/puma/runner.rb#170
  def app; end

  # @version 5.0.0
  #
  # source://puma//lib/puma/runner.rb#91
  def close_control_listeners; end

  # source://puma//lib/puma/runner.rb#59
  def debug(str); end

  # @return [Boolean]
  #
  # source://puma//lib/puma/runner.rb#38
  def development?; end

  # source://puma//lib/puma/runner.rb#55
  def error(str); end

  # source://puma//lib/puma/runner.rb#153
  def load_and_bind; end

  # source://puma//lib/puma/runner.rb#46
  def log(str); end

  # Returns the hash of configuration options.
  #
  # @return [Puma::UserFileDefaultOptions]
  #
  # source://puma//lib/puma/runner.rb#28
  def options; end

  # source://puma//lib/puma/runner.rb#95
  def output_header(mode); end

  # source://puma//lib/puma/runner.rb#126
  def redirect_io; end

  # @return [Boolean]
  #
  # source://puma//lib/puma/runner.rb#122
  def redirected_io?; end

  # source://puma//lib/puma/runner.rb#63
  def start_control; end

  # source://puma//lib/puma/runner.rb#174
  def start_server; end

  # @version 5.0.0
  #
  # source://puma//lib/puma/runner.rb#51
  def stop_control; end

  # @return [Boolean]
  #
  # source://puma//lib/puma/runner.rb#42
  def test?; end

  # source://puma//lib/puma/runner.rb#30
  def wakeup!; end

  # source://puma//lib/puma/runner.rb#114
  def warn_ruby_mn_threads; end

  private

  # this method call should always be guarded by `@log_writer.debug?`
  #
  # source://puma//lib/puma/runner.rb#205
  def debug_loaded_extensions(str); end

  # source://puma//lib/puma/runner.rb#181
  def ensure_output_directory_exists(path, io_name); end

  # source://puma//lib/puma/runner.rb#191
  def stats; end

  # source://puma//lib/puma/runner.rb#187
  def utc_iso8601(val); end
end

# For some HTTP status codes the client only expects headers.
#
# source://puma//lib/puma/const.rb#84
Puma::STATUS_WITH_NO_ENTITY_BODY = T.let(T.unsafe(nil), Hash)

# The HTTP Server itself. Serves out a single Rack app.
#
# This class is used by the `Puma::Single` and `Puma::Cluster` classes
# to generate one or more `Puma::Server` instances capable of handling requests.
# Each Puma process will contain one `Puma::Server` instance.
#
# The `Puma::Server` instance pulls requests from the socket, adds them to a
# `Puma::Reactor` where they get eventually passed to a `Puma::ThreadPool`.
#
# Each `Puma::Server` will have one reactor and one thread pool.
#
# source://puma//lib/puma/server.rb#32
class Puma::Server
  include ::Puma::Const
  include ::Puma::Request

  # Create a server for the rack app +app+.
  #
  # +log_writer+ is a Puma::LogWriter object used to log info and error messages.
  #
  # +events+ is a Puma::Events object used to notify application status events.
  #
  # Server#run returns a thread that you can join on to wait for the server
  # to do its work.
  #
  # @note Several instance variables exist so they are available for testing,
  #   and have default values set via +fetch+.  Normally the values are set via
  #   `::Puma::Configuration.puma_default_options`.
  # @note The `events` parameter is set to nil, and set to `Events.new` in code.
  #   Often `options` needs to be passed, but `events` does not.  Using nil allows
  #   calling code to not require events.rb.
  # @return [Server] a new instance of Server
  #
  # source://puma//lib/puma/server.rb#76
  def initialize(app, events = T.unsafe(nil), options = T.unsafe(nil)); end

  # source://puma//lib/puma/server.rb#724
  def add_ssl_listener(host, port, ctx, optimize_for_latency = T.unsafe(nil), backlog = T.unsafe(nil)); end

  # source://puma//lib/puma/server.rb#720
  def add_tcp_listener(host, port, optimize_for_latency = T.unsafe(nil), backlog = T.unsafe(nil)); end

  # source://puma//lib/puma/server.rb#729
  def add_unix_listener(path, umask = T.unsafe(nil), mode = T.unsafe(nil), backlog = T.unsafe(nil)); end

  # Returns the value of attribute app.
  #
  # source://puma//lib/puma/server.rb#56
  def app; end

  # Sets the attribute app
  #
  # @param value the value to set the attribute app to.
  #
  # source://puma//lib/puma/server.rb#56
  def app=(_arg0); end

  # @todo the following may be deprecated in the future
  #
  # source://puma//lib/puma/server.rb#52
  def auto_trim_time; end

  # source://puma//lib/puma/server.rb#228
  def backlog; end

  # source://puma//lib/puma/server.rb#676
  def begin_restart(sync = T.unsafe(nil)); end

  # Returns the value of attribute binder.
  #
  # source://puma//lib/puma/server.rb#57
  def binder; end

  # Sets the attribute binder
  #
  # @param value the value to set the attribute binder to.
  #
  # source://puma//lib/puma/server.rb#57
  def binder=(_arg0); end

  # Handle various error types thrown by Client I/O operations.
  #
  # source://puma//lib/puma/server.rb#571
  def client_error(e, client, requests = T.unsafe(nil)); end

  # source://puma//lib/puma/server.rb#550
  def close_client_safely(client); end

  # @return [Boolean]
  #
  # source://puma//lib/puma/server.rb#222
  def closed_socket?(socket); end

  # source://puma//lib/puma/server.rb#734
  def connected_ports; end

  # 6 == Socket::IPPROTO_TCP
  # 3 == TCP_CORK
  # 1/0 == turn on/off
  #
  # source://puma//lib/puma/server.rb#196
  def cork_socket(socket); end

  # @todo the following may be deprecated in the future
  #
  # source://puma//lib/puma/server.rb#52
  def early_hints; end

  # Returns the value of attribute events.
  #
  # source://puma//lib/puma/server.rb#47
  def events; end

  # @todo the following may be deprecated in the future
  #
  # source://puma//lib/puma/server.rb#52
  def first_data_timeout; end

  # Wait for all outstanding requests to finish.
  #
  # source://puma//lib/puma/server.rb#620
  def graceful_shutdown; end

  # source://puma//lib/puma/server.rb#671
  def halt(sync = T.unsafe(nil)); end

  # source://puma//lib/puma/server.rb#452
  def handle_check; end

  # source://puma//lib/puma/server.rb#335
  def handle_servers; end

  # source://puma//lib/puma/server.rb#147
  def inherit_binder(bind); end

  # @todo the following may be deprecated in the future
  #
  # source://puma//lib/puma/server.rb#52
  def leak_stack_on_error; end

  # Returns the value of attribute log_writer.
  #
  # source://puma//lib/puma/server.rb#46
  def log_writer; end

  # A fallback rack response if +@app+ raises as exception.
  #
  # source://puma//lib/puma/server.rb#593
  def lowlevel_error(e, env, status = T.unsafe(nil)); end

  # for #stats
  #
  # source://puma//lib/puma/server.rb#48
  def max_threads; end

  # for #stats
  #
  # source://puma//lib/puma/server.rb#48
  def min_threads; end

  # source://puma//lib/puma/server.rb#444
  def new_client(io, sock); end

  # Returns the value of attribute options.
  #
  # source://puma//lib/puma/server.rb#44
  def options; end

  # @todo the following may be deprecated in the future
  #
  # source://puma//lib/puma/server.rb#52
  def persistent_timeout; end

  # This number represents the number of requests that
  # the server is capable of taking right now.
  #
  # For example if the number is 5 then it means
  # there are 5 threads sitting idle ready to take
  # a request. If one request comes in, then the
  # value would be 4 until it finishes processing.
  #
  # source://puma//lib/puma/server.rb#245
  def pool_capacity; end

  # Given a connection on +client+, handle the incoming requests,
  # or queue the connection in the Reactor if no request is available.
  #
  # This method is called from a ThreadPool worker thread.
  #
  # This method supports HTTP Keep-Alive so it may, depending on if the client
  # indicates that it supports keep alive, wait for another request before
  # returning.
  #
  # Return true if one or more requests were processed.
  #
  # source://puma//lib/puma/server.rb#480
  def process_client(client); end

  # This method is called from the Reactor thread when a queued Client receives data,
  # times out, or when the Reactor is shutting down.
  #
  # While the code lives in the Server, the logic is executed on the reactor thread, independently
  # from the server.
  #
  # It is responsible for ensuring that a request has been completely received
  # before it starts to be processed by the ThreadPool. This may be known as read buffering.
  # If read buffering is not done, and no other read buffering is performed (such as by an application server
  # such as nginx) then the application would be subject to a slow client attack.
  #
  # For a graphical representation of how the request buffer works see [architecture.md](https://github.com/puma/puma/blob/master/docs/architecture.md#connection-pipeline).
  #
  # The method checks to see if it has the full header and body with
  # the `Puma::Client#try_to_finish` method. If the full request has been sent,
  # then the request is passed to the ThreadPool (`@thread_pool << client`)
  # so that a "worker thread" can pick up the request and begin to execute application logic.
  # The Client is then removed from the reactor (return `true`).
  #
  # If a client object times out, a 408 response is written, its connection is closed,
  # and the object is removed from the reactor (return `true`).
  #
  # If the Reactor is shutting down, all Clients are either timed out or passed to the
  # ThreadPool, depending on their current state (#can_close?).
  #
  # Otherwise, if the full request is not ready then the client will remain in the reactor
  # (return `false`). When the client sends more data to the socket the `Puma::Client` object
  # will wake up and again be checked to see if it's ready to be passed to the thread pool.
  #
  # source://puma//lib/puma/server.rb#319
  def reactor_wakeup(client); end

  # @todo the following may be deprecated in the future
  #
  # source://puma//lib/puma/server.rb#52
  def reaping_time; end

  # @version 5.0.0
  #
  # source://puma//lib/puma/server.rb#49
  def requests_count; end

  # source://puma//lib/puma/server.rb#711
  def reset_max; end

  # Runs the server.
  #
  # If +background+ is true (the default) then a thread is spun
  # up in the background to handle requests. Otherwise requests
  # are handled synchronously.
  #
  # source://puma//lib/puma/server.rb#255
  def run(background = T.unsafe(nil), thread_name: T.unsafe(nil)); end

  # source://puma//lib/puma/server.rb#233
  def running; end

  # @return [Boolean]
  #
  # source://puma//lib/puma/server.rb#681
  def shutting_down?; end

  # Returns a hash of stats about the running server for reporting purposes.
  #
  # @return [Hash] hash containing stat info from `Server` and `ThreadPool`
  # @version 5.0.0
  #
  # source://puma//lib/puma/server.rb#702
  def stats; end

  # Stops the acceptor thread and then causes the worker threads to finish
  # off the request queue before finally exiting.
  #
  # source://puma//lib/puma/server.rb#666
  def stop(sync = T.unsafe(nil)); end

  # Returns the value of attribute thread.
  #
  # source://puma//lib/puma/server.rb#45
  def thread; end

  # source://puma//lib/puma/server.rb#199
  def uncork_socket(socket); end

  # Triggers a client timeout if the thread-pool shuts down
  # during execution of the provided block.
  #
  # source://puma//lib/puma/server.rb#562
  def with_force_shutdown(client, &block); end

  private

  # source://puma//lib/puma/server.rb#649
  def notify_safely(message); end

  # source://puma//lib/puma/server.rb#612
  def response_to_error(client, requests, err, status_code); end

  class << self
    # source://puma//lib/puma/server.rb#153
    def current; end

    private

    # @return [Boolean]
    # @version 5.0.0
    #
    # source://puma//lib/puma/server.rb#165
    def closed_socket_supported?; end

    # @return [Boolean]
    # @version 5.0.0
    #
    # source://puma//lib/puma/server.rb#159
    def tcp_cork_supported?; end
  end
end

# source://puma//lib/puma/server.rb#33
module Puma::Server::FiberPerRequest
  # source://puma//lib/puma/server.rb#34
  def handle_request(client, requests); end
end

# List of methods invoked by #stats.
#
# @version 5.0.0
#
# source://puma//lib/puma/server.rb#687
Puma::Server::STAT_METHODS = T.let(T.unsafe(nil), Array)

# This class is instantiated by the `Puma::Launcher` and used
# to boot and serve a Ruby application when no puma "workers" are needed
# i.e. only using "threaded" mode. For example `$ puma -t 1:5`
#
# At the core of this class is running an instance of `Puma::Server` which
# gets created via the `start_server` method from the `Puma::Runner` class
# that this inherits from.
#
# source://puma//lib/puma/single.rb#15
class Puma::Single < ::Puma::Runner
  # source://puma//lib/puma/single.rb#31
  def halt; end

  # source://puma//lib/puma/single.rb#23
  def restart; end

  # source://puma//lib/puma/single.rb#41
  def run; end

  # source://puma//lib/puma/single.rb#17
  def stats; end

  # source://puma//lib/puma/single.rb#27
  def stop; end

  # source://puma//lib/puma/single.rb#35
  def stop_blocked; end
end

# Internal Docs for A simple thread pool management object.
#
# Each Puma "worker" has a thread pool to process requests.
#
# First a connection to a client is made in `Puma::Server`. It is wrapped in a
# `Puma::Client` instance and then passed to the `Puma::Reactor` to ensure
# the whole request is buffered into memory. Once the request is ready, it is passed into
# a thread pool via the `Puma::ThreadPool#<<` operator where it is stored in a `@todo` array.
#
# Each thread in the pool has an internal loop where it pulls a request from the `@todo` array
# and processes it.
#
# source://puma//lib/puma/thread_pool.rb#23
class Puma::ThreadPool
  # Maintain a minimum of +min+ and maximum of +max+ threads
  # in the pool.
  #
  # The block passed is the work that will be performed in each
  # thread.
  #
  # @return [ThreadPool] a new instance of ThreadPool
  #
  # source://puma//lib/puma/thread_pool.rb#40
  def initialize(name, options = T.unsafe(nil), server: T.unsafe(nil), &block); end

  # Add +work+ to the todo list for a Thread to pickup and process.
  #
  # source://puma//lib/puma/thread_pool.rb#261
  def <<(work); end

  # source://puma//lib/puma/thread_pool.rb#342
  def auto_reap!(timeout = T.unsafe(nil)); end

  # source://puma//lib/puma/thread_pool.rb#337
  def auto_trim!(timeout = T.unsafe(nil)); end

  # How many objects have yet to be processed by the pool?
  #
  # source://puma//lib/puma/thread_pool.rb#112
  def backlog; end

  # The maximum size of the backlog
  #
  # source://puma//lib/puma/thread_pool.rb#118
  def backlog_max; end

  # @version 5.0.0
  #
  # source://puma//lib/puma/thread_pool.rb#129
  def busy_threads; end

  # seconds
  #
  # source://puma//lib/puma/thread_pool.rb#32
  def out_of_band_running; end

  # source://puma//lib/puma/thread_pool.rb#123
  def pool_capacity; end

  # If there are dead threads in the pool make them go away while decreasing
  # spawned counter so that new healthy threads could be created again.
  #
  # source://puma//lib/puma/thread_pool.rb#295
  def reap; end

  # source://puma//lib/puma/thread_pool.rb#106
  def reset_max; end

  # Tell all threads in the pool to exit and wait for them to finish.
  # Wait +timeout+ seconds then raise +ForceShutdown+ in remaining threads.
  # Next, wait an extra +@shutdown_grace_time+ seconds then force-kill remaining
  # threads. Finally, wait 1 second for remaining threads to exit.
  #
  # source://puma//lib/puma/thread_pool.rb#365
  def shutdown(timeout = T.unsafe(nil)); end

  # Returns the value of attribute spawned.
  #
  # source://puma//lib/puma/thread_pool.rb#89
  def spawned; end

  # generate stats hash so as not to perform multiple locks
  #
  # @return [Hash] hash containing stat info from ThreadPool
  #
  # source://puma//lib/puma/thread_pool.rb#93
  def stats; end

  # If there are any free threads in the pool, tell one to go ahead
  # and exit. If +force+ is true, then a trim request is requested
  # even if all threads are being utilized.
  #
  # source://puma//lib/puma/thread_pool.rb#283
  def trim(force = T.unsafe(nil)); end

  # Returns the value of attribute trim_requested.
  #
  # source://puma//lib/puma/thread_pool.rb#89
  def trim_requested; end

  # source://puma//lib/puma/thread_pool.rb#245
  def wait_while_out_of_band_running; end

  # Returns the value of attribute waiting.
  #
  # source://puma//lib/puma/thread_pool.rb#89
  def waiting; end

  # Allows ThreadPool::ForceShutdown to be raised within the
  # provided block if the thread is forced to shutdown during execution.
  #
  # source://puma//lib/puma/thread_pool.rb#349
  def with_force_shutdown; end

  # @version 5.0.0
  #
  # source://puma//lib/puma/thread_pool.rb#254
  def with_mutex(&block); end

  private

  #
  # Must be called with @mutex held!
  #
  # source://puma//lib/puma/thread_pool.rb#137
  def spawn_thread; end

  # source://puma//lib/puma/thread_pool.rb#211
  def trigger_before_thread_exit_hooks; end

  # source://puma//lib/puma/thread_pool.rb#196
  def trigger_before_thread_start_hooks; end

  # @version 5.0.0
  #
  # source://puma//lib/puma/thread_pool.rb#227
  def trigger_out_of_band_hook; end
end

# source://puma//lib/puma/thread_pool.rb#310
class Puma::ThreadPool::Automaton
  # @return [Automaton] a new instance of Automaton
  #
  # source://puma//lib/puma/thread_pool.rb#311
  def initialize(pool, timeout, thread_name, message); end

  # source://puma//lib/puma/thread_pool.rb#319
  def start!; end

  # source://puma//lib/puma/thread_pool.rb#331
  def stop; end
end

# source://puma//lib/puma/thread_pool.rb#24
class Puma::ThreadPool::ForceShutdown < ::RuntimeError; end

# How long, after raising the ForceShutdown of a thread during
# forced shutdown mode, to wait for the thread to try and finish
# up its work before leaving the thread to die on the vine.
#
# source://puma//lib/puma/thread_pool.rb#30
Puma::ThreadPool::SHUTDOWN_GRACE_TIME = T.let(T.unsafe(nil), Integer)

# source://puma//lib/puma/plugin.rb#4
class Puma::UnknownPlugin < ::RuntimeError; end

# source://puma//lib/puma/reactor.rb#4
class Puma::UnsupportedBackend < ::StandardError; end

# source://puma//lib/puma/const.rb#5
class Puma::UnsupportedOption < ::RuntimeError; end

# A class used for storing "leveled" configuration options.
#
# In this class any "user" specified options take precedence over any
# "file" specified options, take precedence over any "default" options.
#
# User input is preferred over "defaults":
#   user_options    = { foo: "bar" }
#   default_options = { foo: "zoo" }
#   options = UserFileDefaultOptions.new(user_options, default_options)
#   puts options[:foo]
#   # => "bar"
#
# All values can be accessed via `all_of`
#
#   puts options.all_of(:foo)
#   # => ["bar", "zoo"]
#
# A "file" option can be set. This config will be preferred over "default" options
# but will defer to any available "user" specified options.
#
#   user_options    = { foo: "bar" }
#   default_options = { rackup: "zoo.rb" }
#   options = UserFileDefaultOptions.new(user_options, default_options)
#   options.file_options[:rackup] = "sup.rb"
#   puts options[:rackup]
#   # => "sup.rb"
#
# The "default" options can be set via procs. These are resolved during runtime
# via calls to `finalize_values`
#
# source://puma//lib/puma/configuration.rb#38
class Puma::UserFileDefaultOptions
  # @return [UserFileDefaultOptions] a new instance of UserFileDefaultOptions
  #
  # source://puma//lib/puma/configuration.rb#39
  def initialize(user_options, default_options); end

  # source://puma//lib/puma/configuration.rb#47
  def [](key); end

  # source://puma//lib/puma/configuration.rb#51
  def []=(key, value); end

  # source://puma//lib/puma/configuration.rb#63
  def all_of(key); end

  # Returns the value of attribute default_options.
  #
  # source://puma//lib/puma/configuration.rb#45
  def default_options; end

  # source://puma//lib/puma/configuration.rb#55
  def fetch(key, default_value = T.unsafe(nil)); end

  # Returns the value of attribute file_options.
  #
  # source://puma//lib/puma/configuration.rb#45
  def file_options; end

  # source://puma//lib/puma/configuration.rb#87
  def final_options; end

  # source://puma//lib/puma/configuration.rb#79
  def finalize_values; end

  # Returns the value of attribute user_options.
  #
  # source://puma//lib/puma/configuration.rb#45
  def user_options; end
end

# source://puma//lib/puma/util.rb#6
module Puma::Util
  private

  # source://puma//lib/puma/util.rb#17
  def escape(s, encoding = T.unsafe(nil)); end

  # Stolen from Mongrel, with some small modifications:
  # Parses a query string by breaking it up at the '&'
  # and ';' characters.  You can also use this to parse
  # cookies by changing the characters used in the second
  # parameter (which defaults to '&;').
  #
  # source://puma//lib/puma/util.rb#42
  def parse_query(qs, d = T.unsafe(nil), &unescaper); end

  # source://puma//lib/puma/util.rb#9
  def pipe; end

  # source://puma//lib/puma/util.rb#21
  def unescape(s, encoding = T.unsafe(nil)); end

  class << self
    # source://puma//lib/puma/util.rb#17
    def escape(s, encoding = T.unsafe(nil)); end

    # Stolen from Mongrel, with some small modifications:
    # Parses a query string by breaking it up at the '&'
    # and ';' characters.  You can also use this to parse
    # cookies by changing the characters used in the second
    # parameter (which defaults to '&;').
    #
    # source://puma//lib/puma/util.rb#42
    def parse_query(qs, d = T.unsafe(nil), &unescaper); end

    # source://puma//lib/puma/util.rb#9
    def pipe; end

    # source://puma//lib/puma/util.rb#21
    def unescape(s, encoding = T.unsafe(nil)); end
  end
end

# source://puma//lib/puma/util.rb#35
Puma::Util::DEFAULT_SEP = T.let(T.unsafe(nil), Regexp)

# A case-insensitive Hash that preserves the original case of a
# header when set.
#
# source://puma//lib/puma/util.rb#67
class Puma::Util::HeaderHash < ::Hash
  # @return [HeaderHash] a new instance of HeaderHash
  #
  # source://puma//lib/puma/util.rb#72
  def initialize(hash = T.unsafe(nil)); end

  # source://puma//lib/puma/util.rb#91
  def [](k); end

  # source://puma//lib/puma/util.rb#95
  def []=(k, v); end

  # source://puma//lib/puma/util.rb#102
  def delete(k); end

  # source://puma//lib/puma/util.rb#78
  def each; end

  # @return [Boolean]
  #
  # source://puma//lib/puma/util.rb#113
  def has_key?(k); end

  # @return [Boolean]
  #
  # source://puma//lib/puma/util.rb#109
  def include?(k); end

  # @return [Boolean]
  #
  # source://puma//lib/puma/util.rb#115
  def key?(k); end

  # @return [Boolean]
  #
  # source://puma//lib/puma/util.rb#114
  def member?(k); end

  # source://puma//lib/puma/util.rb#122
  def merge(other); end

  # source://puma//lib/puma/util.rb#117
  def merge!(other); end

  # source://puma//lib/puma/util.rb#127
  def replace(other); end

  # source://puma//lib/puma/util.rb#85
  def to_hash; end

  class << self
    # source://puma//lib/puma/util.rb#68
    def new(hash = T.unsafe(nil)); end
  end
end
