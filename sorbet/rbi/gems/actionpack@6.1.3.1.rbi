# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `actionpack` gem.
# Please instead update this file by running `bin/tapioca sync`.

# typed: true

module ActionDispatch
  extend(::ActiveSupport::Autoload)

  def test_app; end
  def test_app=(val); end

  class << self
    def test_app; end
    def test_app=(val); end
  end
end

class ActionDispatch::ActionableExceptions
  def initialize(app); end

  def call(env); end
  def endpoint; end
  def endpoint=(val); end

  private

  def actionable_request?(request); end
  def redirect_to(location); end

  class << self
    def endpoint; end
    def endpoint=(val); end
  end
end

class ActionDispatch::AssertionResponse
  def initialize(code_or_name); end

  def code; end
  def code_and_name; end
  def name; end

  private

  def code_from_name(name); end
  def name_from_code(code); end
end

ActionDispatch::AssertionResponse::GENERIC_RESPONSE_CODES = T.let(T.unsafe(nil), Hash)

module ActionDispatch::Assertions
  include(::ActionDispatch::Assertions::ResponseAssertions)
  include(::ActionDispatch::Assertions::RoutingAssertions)
  extend(::ActiveSupport::Concern)

  include(::Rails::Dom::Testing::Assertions)

  def html_document; end
end

module ActionDispatch::Assertions::ResponseAssertions
  def assert_redirected_to(options = T.unsafe(nil), message = T.unsafe(nil)); end
  def assert_response(type, message = T.unsafe(nil)); end

  private

  def code_with_name(code_or_name); end
  def generate_response_message(expected, actual = T.unsafe(nil)); end
  def location_if_redirected; end
  def normalize_argument_to_redirection(fragment); end
  def parameterize(value); end
  def response_body_if_short; end
end

ActionDispatch::Assertions::ResponseAssertions::RESPONSE_PREDICATES = T.let(T.unsafe(nil), Hash)

module ActionDispatch::Assertions::RoutingAssertions
  def assert_generates(expected_path, options, defaults = T.unsafe(nil), extras = T.unsafe(nil), message = T.unsafe(nil)); end
  def assert_recognizes(expected_options, path, extras = T.unsafe(nil), msg = T.unsafe(nil)); end
  def assert_routing(path, options, defaults = T.unsafe(nil), extras = T.unsafe(nil), message = T.unsafe(nil)); end
  def method_missing(selector, *args, &block); end
  def setup; end
  def with_routing; end

  private

  def fail_on(exception_class, message); end
  def recognized_request_for(path, extras = T.unsafe(nil), msg); end
end

class ActionDispatch::Callbacks
  include(::ActiveSupport::Callbacks)
  extend(::ActiveSupport::Callbacks::ClassMethods)
  extend(::ActiveSupport::DescendantsTracker)

  def initialize(app); end

  def __callbacks; end
  def __callbacks?; end
  def _call_callbacks; end
  def _run_call_callbacks(&block); end
  def call(env); end

  class << self
    def __callbacks; end
    def __callbacks=(value); end
    def __callbacks?; end
    def _call_callbacks; end
    def _call_callbacks=(value); end
    def after(*args, &block); end
    def before(*args, &block); end
  end
end

class ActionDispatch::ContentSecurityPolicy
  def initialize; end

  def base_uri(*sources); end
  def block_all_mixed_content(enabled = T.unsafe(nil)); end
  def build(context = T.unsafe(nil), nonce = T.unsafe(nil), nonce_directives = T.unsafe(nil)); end
  def child_src(*sources); end
  def connect_src(*sources); end
  def default_src(*sources); end
  def directives; end
  def font_src(*sources); end
  def form_action(*sources); end
  def frame_ancestors(*sources); end
  def frame_src(*sources); end
  def img_src(*sources); end
  def manifest_src(*sources); end
  def media_src(*sources); end
  def object_src(*sources); end
  def plugin_types(*types); end
  def prefetch_src(*sources); end
  def report_uri(uri); end
  def require_sri_for(*types); end
  def sandbox(*values); end
  def script_src(*sources); end
  def script_src_attr(*sources); end
  def script_src_elem(*sources); end
  def style_src(*sources); end
  def style_src_attr(*sources); end
  def style_src_elem(*sources); end
  def upgrade_insecure_requests(enabled = T.unsafe(nil)); end
  def worker_src(*sources); end

  private

  def apply_mapping(source); end
  def apply_mappings(sources); end
  def build_directive(sources, context); end
  def build_directives(context, nonce, nonce_directives); end
  def initialize_copy(other); end
  def nonce_directive?(directive, nonce_directives); end
  def resolve_source(source, context); end
end

class ActionDispatch::ContentSecurityPolicy::Middleware
  def initialize(app); end

  def call(env); end

  private

  def header_name(request); end
  def html_response?(headers); end
  def policy_present?(headers); end
end

ActionDispatch::ContentSecurityPolicy::Middleware::CONTENT_TYPE = T.let(T.unsafe(nil), String)

ActionDispatch::ContentSecurityPolicy::Middleware::POLICY = T.let(T.unsafe(nil), String)

ActionDispatch::ContentSecurityPolicy::Middleware::POLICY_REPORT_ONLY = T.let(T.unsafe(nil), String)

module ActionDispatch::ContentSecurityPolicy::Request
  def content_security_policy; end
  def content_security_policy=(policy); end
  def content_security_policy_nonce; end
  def content_security_policy_nonce_directives; end
  def content_security_policy_nonce_directives=(generator); end
  def content_security_policy_nonce_generator; end
  def content_security_policy_nonce_generator=(generator); end
  def content_security_policy_report_only; end
  def content_security_policy_report_only=(value); end

  private

  def generate_content_security_policy_nonce; end
end

ActionDispatch::ContentSecurityPolicy::Request::NONCE = T.let(T.unsafe(nil), String)

ActionDispatch::ContentSecurityPolicy::Request::NONCE_DIRECTIVES = T.let(T.unsafe(nil), String)

ActionDispatch::ContentSecurityPolicy::Request::NONCE_GENERATOR = T.let(T.unsafe(nil), String)

ActionDispatch::ContentSecurityPolicy::Request::POLICY = T.let(T.unsafe(nil), String)

ActionDispatch::ContentSecurityPolicy::Request::POLICY_REPORT_ONLY = T.let(T.unsafe(nil), String)

class ActionDispatch::Cookies
  def initialize(app); end

  def call(env); end
end

ActionDispatch::Cookies::AUTHENTICATED_ENCRYPTED_COOKIE_SALT = T.let(T.unsafe(nil), String)

class ActionDispatch::Cookies::AbstractCookieJar
  include(::ActionDispatch::Cookies::ChainedCookieJars)

  def initialize(parent_jar); end

  def [](name); end
  def []=(name, options); end

  protected

  def request; end

  private

  def commit(name, options); end
  def cookie_metadata(name, options); end
  def expiry_options(options); end
  def parse(name, data, purpose: T.unsafe(nil)); end
end

ActionDispatch::Cookies::COOKIES_DIGEST = T.let(T.unsafe(nil), String)

ActionDispatch::Cookies::COOKIES_ROTATIONS = T.let(T.unsafe(nil), String)

ActionDispatch::Cookies::COOKIES_SAME_SITE_PROTECTION = T.let(T.unsafe(nil), String)

ActionDispatch::Cookies::COOKIES_SERIALIZER = T.let(T.unsafe(nil), String)

module ActionDispatch::Cookies::ChainedCookieJars
  def encrypted; end
  def permanent; end
  def signed; end
  def signed_or_encrypted; end

  private

  def encrypted_cookie_cipher; end
  def prepare_upgrade_legacy_hmac_aes_cbc_cookies?; end
  def signed_cookie_digest; end
  def upgrade_legacy_hmac_aes_cbc_cookies?; end
end

class ActionDispatch::Cookies::CookieJar
  include(::ActionDispatch::Cookies::ChainedCookieJars)
  include(::Enumerable)

  def initialize(request); end

  def [](name); end
  def []=(name, options); end
  def always_write_cookie; end
  def always_write_cookie=(val); end
  def clear(options = T.unsafe(nil)); end
  def commit!; end
  def committed?; end
  def delete(name, options = T.unsafe(nil)); end
  def deleted?(name, options = T.unsafe(nil)); end
  def each(&block); end
  def fetch(name, *args, &block); end
  def has_key?(name); end
  def key?(name); end
  def request; end
  def to_hash(*_arg0); end
  def to_header; end
  def update(other_hash); end
  def update_cookies_from_jar; end
  def write(headers); end

  private

  def escape(string); end
  def handle_options(options); end
  def make_set_cookie_header(header); end
  def write_cookie?(cookie); end

  class << self
    def always_write_cookie; end
    def always_write_cookie=(val); end
    def build(req, cookies); end
  end
end

ActionDispatch::Cookies::CookieJar::DOMAIN_REGEXP = T.let(T.unsafe(nil), Regexp)

class ActionDispatch::Cookies::CookieOverflow < ::StandardError
end

ActionDispatch::Cookies::ENCRYPTED_COOKIE_CIPHER = T.let(T.unsafe(nil), String)

ActionDispatch::Cookies::ENCRYPTED_COOKIE_SALT = T.let(T.unsafe(nil), String)

ActionDispatch::Cookies::ENCRYPTED_SIGNED_COOKIE_SALT = T.let(T.unsafe(nil), String)

class ActionDispatch::Cookies::EncryptedKeyRotatingCookieJar < ::ActionDispatch::Cookies::AbstractCookieJar
  include(::ActionDispatch::Cookies::SerializedCookieJars)

  def initialize(parent_jar); end


  private

  def commit(name, options); end
  def parse(name, encrypted_message, purpose: T.unsafe(nil)); end
end

ActionDispatch::Cookies::GENERATOR_KEY = T.let(T.unsafe(nil), String)

ActionDispatch::Cookies::HTTP_HEADER = T.let(T.unsafe(nil), String)

class ActionDispatch::Cookies::JsonSerializer
  class << self
    def dump(value); end
    def load(value); end
  end
end

ActionDispatch::Cookies::MAX_COOKIE_SIZE = T.let(T.unsafe(nil), Integer)

class ActionDispatch::Cookies::MarshalWithJsonFallback
  class << self
    def dump(value); end
    def load(value); end
  end
end

class ActionDispatch::Cookies::PermanentCookieJar < ::ActionDispatch::Cookies::AbstractCookieJar

  private

  def commit(name, options); end
end

ActionDispatch::Cookies::SECRET_KEY_BASE = T.let(T.unsafe(nil), String)

ActionDispatch::Cookies::SIGNED_COOKIE_DIGEST = T.let(T.unsafe(nil), String)

ActionDispatch::Cookies::SIGNED_COOKIE_SALT = T.let(T.unsafe(nil), String)

module ActionDispatch::Cookies::SerializedCookieJars

  protected

  def deserialize(name); end
  def digest; end
  def needs_migration?(value); end
  def serialize(value); end
  def serializer; end
end

ActionDispatch::Cookies::SerializedCookieJars::MARSHAL_SIGNATURE = T.let(T.unsafe(nil), String)

ActionDispatch::Cookies::SerializedCookieJars::SERIALIZER = ActiveSupport::MessageEncryptor::NullSerializer

class ActionDispatch::Cookies::SignedKeyRotatingCookieJar < ::ActionDispatch::Cookies::AbstractCookieJar
  include(::ActionDispatch::Cookies::SerializedCookieJars)

  def initialize(parent_jar); end


  private

  def commit(name, options); end
  def parse(name, signed_message, purpose: T.unsafe(nil)); end
end

ActionDispatch::Cookies::USE_AUTHENTICATED_COOKIE_ENCRYPTION = T.let(T.unsafe(nil), String)

ActionDispatch::Cookies::USE_COOKIES_WITH_METADATA = T.let(T.unsafe(nil), String)

class ActionDispatch::DebugExceptions
  def initialize(app, routes_app = T.unsafe(nil), response_format = T.unsafe(nil), interceptors = T.unsafe(nil)); end

  def call(env); end

  private

  def api_request?(content_type); end
  def create_template(request, wrapper); end
  def invoke_interceptors(request, exception); end
  def log_array(logger, array); end
  def log_error(request, wrapper); end
  def logger(request); end
  def render(status, body, format); end
  def render_exception(request, exception); end
  def render_for_api_request(content_type, wrapper); end
  def render_for_browser_request(request, wrapper); end
  def routes_inspector(exception); end
  def stderr_logger; end

  class << self
    def interceptors; end
    def register_interceptor(object = T.unsafe(nil), &block); end
  end
end

class ActionDispatch::DebugLocks
  def initialize(app, path = T.unsafe(nil)); end

  def call(env); end

  private

  def blocked_by?(victim, blocker, all_threads); end
  def render_details(req); end
end

class ActionDispatch::DebugView < ::ActionView::Base
  def initialize(assigns); end

  def compiled_method_container; end
  def debug_hash(object); end
  def debug_headers(headers); end
  def debug_params(params); end
  def params_valid?; end
  def protect_against_forgery?; end
  def render(*_arg0); end
end

ActionDispatch::DebugView::RESCUES_TEMPLATE_PATH = T.let(T.unsafe(nil), String)

class ActionDispatch::ExceptionWrapper
  def initialize(backtrace_cleaner, exception); end

  def application_trace; end
  def backtrace_cleaner; end
  def exception; end
  def exception_trace; end
  def file; end
  def framework_trace; end
  def full_trace; end
  def line_number; end
  def rescue_responses; end
  def rescue_responses=(val); end
  def rescue_template; end
  def rescue_templates; end
  def rescue_templates=(val); end
  def silent_exceptions; end
  def silent_exceptions=(val); end
  def source_extracts; end
  def source_to_show_id; end
  def status_code; end
  def trace_to_show; end
  def traces; end
  def unwrapped_exception; end
  def wrapped_causes; end
  def wrapper_exceptions; end
  def wrapper_exceptions=(val); end

  private

  def backtrace; end
  def causes_for(exception); end
  def clean_backtrace(*args); end
  def expand_backtrace; end
  def extract_file_and_line_number(trace); end
  def source_fragment(path, line); end
  def wrapped_causes_for(exception, backtrace_cleaner); end

  class << self
    def rescue_responses; end
    def rescue_responses=(val); end
    def rescue_templates; end
    def rescue_templates=(val); end
    def silent_exceptions; end
    def silent_exceptions=(val); end
    def status_code_for_exception(class_name); end
    def wrapper_exceptions; end
    def wrapper_exceptions=(val); end
  end
end

class ActionDispatch::Executor
  def initialize(app, executor); end

  def call(env); end
end

class ActionDispatch::Flash
  class << self
    def new(app); end
  end
end

class ActionDispatch::Flash::FlashHash
  include(::Enumerable)

  def initialize(flashes = T.unsafe(nil), discard = T.unsafe(nil)); end

  def [](k); end
  def []=(k, v); end
  def alert; end
  def alert=(message); end
  def clear; end
  def delete(key); end
  def discard(k = T.unsafe(nil)); end
  def each(&block); end
  def empty?; end
  def keep(k = T.unsafe(nil)); end
  def key?(name); end
  def keys; end
  def merge!(h); end
  def notice; end
  def notice=(message); end
  def now; end
  def replace(h); end
  def sweep; end
  def to_hash; end
  def to_session_value; end
  def update(h); end

  protected

  def now_is_loaded?; end

  private

  def initialize_copy(other); end
  def stringify_array(array); end

  class << self
    def from_session_value(value); end
  end
end

class ActionDispatch::Flash::FlashNow
  def initialize(flash); end

  def [](k); end
  def []=(k, v); end
  def alert=(message); end
  def flash; end
  def flash=(_arg0); end
  def notice=(message); end
end

ActionDispatch::Flash::KEY = T.let(T.unsafe(nil), String)

module ActionDispatch::Flash::RequestMethods
  def commit_flash; end
  def flash; end
  def flash=(flash); end
  def flash_hash; end
  def reset_session; end
end

class ActionDispatch::HostAuthorization
  def initialize(app, hosts, deprecated_response_app = T.unsafe(nil), exclude: T.unsafe(nil), response_app: T.unsafe(nil)); end

  def call(env); end

  private

  def authorized?(request); end
  def excluded?(request); end
  def mark_as_authorized(request); end
end

ActionDispatch::HostAuthorization::DEFAULT_RESPONSE_APP = T.let(T.unsafe(nil), Proc)

class ActionDispatch::HostAuthorization::Permissions
  def initialize(hosts); end

  def allows?(host); end
  def empty?; end

  private

  def sanitize_hosts(hosts); end
  def sanitize_regexp(host); end
  def sanitize_string(host); end
end

module ActionDispatch::Http
  extend(::ActiveSupport::Autoload)
end

module ActionDispatch::Http::Cache
end

module ActionDispatch::Http::Cache::Request
  def etag_matches?(etag); end
  def fresh?(response); end
  def if_modified_since; end
  def if_none_match; end
  def if_none_match_etags; end
  def not_modified?(modified_at); end
end

ActionDispatch::Http::Cache::Request::HTTP_IF_MODIFIED_SINCE = T.let(T.unsafe(nil), String)

ActionDispatch::Http::Cache::Request::HTTP_IF_NONE_MATCH = T.let(T.unsafe(nil), String)

module ActionDispatch::Http::Cache::Response
  def cache_control; end
  def date; end
  def date=(utc_time); end
  def date?; end
  def etag=(weak_validators); end
  def etag?; end
  def last_modified; end
  def last_modified=(utc_time); end
  def last_modified?; end
  def strong_etag=(strong_validators); end
  def strong_etag?; end
  def weak_etag=(weak_validators); end
  def weak_etag?; end

  private

  def cache_control_headers; end
  def cache_control_segments; end
  def generate_strong_etag(validators); end
  def generate_weak_etag(validators); end
  def handle_conditional_get!; end
  def merge_and_normalize_cache_control!(cache_control); end
  def prepare_cache_control!; end
end

ActionDispatch::Http::Cache::Response::DATE = T.let(T.unsafe(nil), String)

ActionDispatch::Http::Cache::Response::DEFAULT_CACHE_CONTROL = T.let(T.unsafe(nil), String)

ActionDispatch::Http::Cache::Response::LAST_MODIFIED = T.let(T.unsafe(nil), String)

ActionDispatch::Http::Cache::Response::MUST_REVALIDATE = T.let(T.unsafe(nil), String)

ActionDispatch::Http::Cache::Response::NO_CACHE = T.let(T.unsafe(nil), String)

ActionDispatch::Http::Cache::Response::NO_STORE = T.let(T.unsafe(nil), String)

ActionDispatch::Http::Cache::Response::PRIVATE = T.let(T.unsafe(nil), String)

ActionDispatch::Http::Cache::Response::PUBLIC = T.let(T.unsafe(nil), String)

ActionDispatch::Http::Cache::Response::SPECIAL_KEYS = T.let(T.unsafe(nil), Set)

module ActionDispatch::Http::FilterParameters
  def initialize; end

  def filtered_env; end
  def filtered_parameters; end
  def filtered_path; end

  private

  def env_filter; end
  def filtered_query_string; end
  def parameter_filter; end
  def parameter_filter_for(filters); end
end

ActionDispatch::Http::FilterParameters::ENV_MATCH = T.let(T.unsafe(nil), Array)

ActionDispatch::Http::FilterParameters::KV_RE = T.let(T.unsafe(nil), String)

ActionDispatch::Http::FilterParameters::NULL_ENV_FILTER = T.let(T.unsafe(nil), ActiveSupport::ParameterFilter)

ActionDispatch::Http::FilterParameters::NULL_PARAM_FILTER = T.let(T.unsafe(nil), ActiveSupport::ParameterFilter)

ActionDispatch::Http::FilterParameters::PAIR_RE = T.let(T.unsafe(nil), Regexp)

class ActionDispatch::Http::Headers
  include(::Enumerable)

  def initialize(request); end

  def [](key); end
  def []=(key, value); end
  def add(key, value); end
  def each(&block); end
  def env; end
  def fetch(key, default = T.unsafe(nil)); end
  def include?(key); end
  def key?(key); end
  def merge(headers_or_env); end
  def merge!(headers_or_env); end

  private

  def env_name(key); end

  class << self
    def from_hash(hash); end
  end
end

ActionDispatch::Http::Headers::CGI_VARIABLES = T.let(T.unsafe(nil), Set)

ActionDispatch::Http::Headers::DEFAULT = T.let(T.unsafe(nil), Object)

ActionDispatch::Http::Headers::HTTP_HEADER = T.let(T.unsafe(nil), Regexp)

module ActionDispatch::Http::MimeNegotiation
  extend(::ActiveSupport::Concern)

  def accepts; end
  def content_mime_type; end
  def content_type; end
  def format(view_path = T.unsafe(nil)); end
  def format=(extension); end
  def formats; end
  def formats=(extensions); end
  def has_content_type?; end
  def negotiate_mime(order); end
  def should_apply_vary_header?; end
  def variant; end
  def variant=(variant); end

  private

  def format_from_path_extension; end
  def params_readable?; end
  def use_accept_header; end
  def valid_accept_header; end
end

ActionDispatch::Http::MimeNegotiation::BROWSER_LIKE_ACCEPTS = T.let(T.unsafe(nil), Regexp)

class ActionDispatch::Http::MimeNegotiation::InvalidType < ::Mime::Type::InvalidMimeType
end

ActionDispatch::Http::MimeNegotiation::RESCUABLE_MIME_FORMAT_ERRORS = T.let(T.unsafe(nil), Array)

module ActionDispatch::Http::Parameters
  extend(::ActiveSupport::Concern)

  mixes_in_class_methods(::ActionDispatch::Http::Parameters::ClassMethods)

  def parameters; end
  def params; end
  def path_parameters; end
  def path_parameters=(parameters); end

  private

  def log_parse_error_once; end
  def params_parsers; end
  def parse_formatted_parameters(parsers); end
end

module ActionDispatch::Http::Parameters::ClassMethods
  def parameter_parsers=(parsers); end
end

ActionDispatch::Http::Parameters::DEFAULT_PARSERS = T.let(T.unsafe(nil), Hash)

ActionDispatch::Http::Parameters::PARAMETERS_KEY = T.let(T.unsafe(nil), String)

class ActionDispatch::Http::Parameters::ParseError < ::StandardError
  def initialize; end
end

module ActionDispatch::Http::URL
  def initialize; end

  def domain(tld_length = T.unsafe(nil)); end
  def host; end
  def host_with_port; end
  def optional_port; end
  def port; end
  def port_string; end
  def protocol; end
  def raw_host_with_port; end
  def secure_protocol; end
  def secure_protocol=(val); end
  def server_port; end
  def standard_port; end
  def standard_port?; end
  def subdomain(tld_length = T.unsafe(nil)); end
  def subdomains(tld_length = T.unsafe(nil)); end
  def tld_length; end
  def tld_length=(val); end
  def url; end

  class << self
    def extract_domain(host, tld_length); end
    def extract_subdomain(host, tld_length); end
    def extract_subdomains(host, tld_length); end
    def full_url_for(options); end
    def path_for(options); end
    def secure_protocol; end
    def secure_protocol=(val); end
    def tld_length; end
    def tld_length=(val); end
    def url_for(options); end

    private

    def add_anchor(path, anchor); end
    def add_params(path, params); end
    def add_trailing_slash(path); end
    def build_host_url(host, port, protocol, options, path); end
    def extract_domain_from(host, tld_length); end
    def extract_subdomains_from(host, tld_length); end
    def named_host?(host); end
    def normalize_host(_host, options); end
    def normalize_port(port, protocol); end
    def normalize_protocol(protocol); end
  end
end

ActionDispatch::Http::URL::HOST_REGEXP = T.let(T.unsafe(nil), Regexp)

ActionDispatch::Http::URL::IP_HOST_REGEXP = T.let(T.unsafe(nil), Regexp)

ActionDispatch::Http::URL::PROTOCOL_REGEXP = T.let(T.unsafe(nil), Regexp)

class ActionDispatch::Http::UploadedFile
  def initialize(hash); end

  def close(unlink_now = T.unsafe(nil)); end
  def content_type; end
  def content_type=(_arg0); end
  def eof?; end
  def headers; end
  def headers=(_arg0); end
  def open; end
  def original_filename; end
  def original_filename=(_arg0); end
  def path; end
  def read(length = T.unsafe(nil), buffer = T.unsafe(nil)); end
  def rewind; end
  def size; end
  def tempfile; end
  def tempfile=(_arg0); end
  def to_io; end
  def to_path; end
end

class ActionDispatch::IllegalStateError < ::StandardError
end

class ActionDispatch::IntegrationTest < ::ActiveSupport::TestCase
  include(::ActionDispatch::TestProcess::FixtureFile)
end

module ActionDispatch::IntegrationTest::Behavior
  include(::Rails::Dom::Testing::Assertions::DomAssertions)
  include(::Rails::Dom::Testing::Assertions::SelectorAssertions::CountDescribable)
  include(::Rails::Dom::Testing::Assertions::SelectorAssertions)
  include(::Rails::Dom::Testing::Assertions)
  include(::ActionDispatch::Assertions::ResponseAssertions)
  include(::ActionDispatch::Assertions::RoutingAssertions)
  include(::ActionDispatch::Assertions)
  extend(::ActiveSupport::Concern)
end

module ActionDispatch::IntegrationTest::UrlOptions
  extend(::ActiveSupport::Concern)

  def url_options; end
end

module ActionDispatch::Journey
end

class ActionDispatch::Journey::Format
  def initialize(parts); end

  def evaluate(hash); end

  class << self
    def required_path(symbol); end
    def required_segment(symbol); end
  end
end

ActionDispatch::Journey::Format::ESCAPE_PATH = T.let(T.unsafe(nil), Proc)

ActionDispatch::Journey::Format::ESCAPE_SEGMENT = T.let(T.unsafe(nil), Proc)

class ActionDispatch::Journey::Format::Parameter < ::Struct
  def escape(value); end
  def escaper; end
  def escaper=(_); end
  def name; end
  def name=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def members; end
    def new(*_arg0); end
  end
end

class ActionDispatch::Journey::Formatter
  def initialize(routes); end

  def clear; end
  def generate(name, options, path_parameters); end
  def routes; end

  private

  def build_cache; end
  def cache; end
  def extract_parameterized_parts(route, options, recall); end
  def match_route(name, options); end
  def missing_keys(route, parts); end
  def named_routes; end
  def non_recursive(cache, options); end
  def possibles(cache, options, depth = T.unsafe(nil)); end
end

class ActionDispatch::Journey::Formatter::MissingRoute
  def initialize(constraints, missing_keys, unmatched_keys, routes, name); end

  def constraints; end
  def message; end
  def missing_keys; end
  def name; end
  def params; end
  def path(method_name); end
  def routes; end
  def unmatched_keys; end
end

class ActionDispatch::Journey::Formatter::RouteWithParams
  def initialize(route, parameterized_parts, params); end

  def params; end
  def path(_); end
end

module ActionDispatch::Journey::GTG
end

class ActionDispatch::Journey::GTG::Builder
  def initialize(root); end

  def ast; end
  def endpoints; end
  def firstpos(node); end
  def lastpos(node); end
  def nullable?(node); end
  def root; end
  def transition_table; end

  private

  def build_followpos; end
  def symbol(edge); end
end

ActionDispatch::Journey::GTG::Builder::DUMMY = T.let(T.unsafe(nil), ActionDispatch::Journey::Nodes::Dummy)

class ActionDispatch::Journey::GTG::MatchData
  def initialize(memos); end

  def memos; end
end

class ActionDispatch::Journey::GTG::Simulator
  def initialize(transition_table); end

  def memos(string); end
  def tt; end
end

ActionDispatch::Journey::GTG::Simulator::INITIAL_STATE = T.let(T.unsafe(nil), Array)

class ActionDispatch::Journey::GTG::TransitionTable
  include(::ActionDispatch::Journey::NFA::Dot)

  def initialize; end

  def []=(from, to, sym); end
  def accepting?(state); end
  def accepting_states; end
  def add_accepting(state); end
  def add_memo(idx, memo); end
  def as_json(options = T.unsafe(nil)); end
  def eclosure(t); end
  def memo(idx); end
  def memos; end
  def move(t, a); end
  def states; end
  def to_svg; end
  def transitions; end
  def visualizer(paths, title = T.unsafe(nil)); end

  private

  def states_hash_for(sym); end
end

module ActionDispatch::Journey::NFA
end

module ActionDispatch::Journey::NFA::Dot
  def to_dot; end
end

module ActionDispatch::Journey::Nodes
end

class ActionDispatch::Journey::Nodes::Binary < ::ActionDispatch::Journey::Nodes::Node
  def initialize(left, right); end

  def children; end
  def right; end
  def right=(_arg0); end
end

class ActionDispatch::Journey::Nodes::Cat < ::ActionDispatch::Journey::Nodes::Binary
  def cat?; end
  def type; end
end

class ActionDispatch::Journey::Nodes::Dot < ::ActionDispatch::Journey::Nodes::Terminal
  def type; end
end

class ActionDispatch::Journey::Nodes::Dummy < ::ActionDispatch::Journey::Nodes::Literal
  def initialize(x = T.unsafe(nil)); end

  def literal?; end
end

class ActionDispatch::Journey::Nodes::Group < ::ActionDispatch::Journey::Nodes::Unary
  def group?; end
  def type; end
end

class ActionDispatch::Journey::Nodes::Literal < ::ActionDispatch::Journey::Nodes::Terminal
  def literal?; end
  def type; end
end

class ActionDispatch::Journey::Nodes::Node
  include(::Enumerable)

  def initialize(left); end

  def cat?; end
  def each(&block); end
  def group?; end
  def left; end
  def left=(_arg0); end
  def literal?; end
  def memo; end
  def memo=(_arg0); end
  def name; end
  def star?; end
  def symbol?; end
  def terminal?; end
  def to_dot; end
  def to_s; end
  def to_sym; end
  def type; end
end

class ActionDispatch::Journey::Nodes::Or < ::ActionDispatch::Journey::Nodes::Node
  def initialize(children); end

  def children; end
  def type; end
end

class ActionDispatch::Journey::Nodes::Slash < ::ActionDispatch::Journey::Nodes::Terminal
  def type; end
end

class ActionDispatch::Journey::Nodes::Star < ::ActionDispatch::Journey::Nodes::Unary
  def name; end
  def star?; end
  def type; end
end

class ActionDispatch::Journey::Nodes::Symbol < ::ActionDispatch::Journey::Nodes::Terminal
  def initialize(left, regexp = T.unsafe(nil)); end

  def default_regexp?; end
  def name; end
  def regexp; end
  def regexp=(_arg0); end
  def symbol; end
  def symbol?; end
  def type; end
end

ActionDispatch::Journey::Nodes::Symbol::DEFAULT_EXP = T.let(T.unsafe(nil), Regexp)

ActionDispatch::Journey::Nodes::Symbol::GREEDY_EXP = T.let(T.unsafe(nil), Regexp)

class ActionDispatch::Journey::Nodes::Terminal < ::ActionDispatch::Journey::Nodes::Node
  def symbol; end
  def terminal?; end
end

class ActionDispatch::Journey::Nodes::Unary < ::ActionDispatch::Journey::Nodes::Node
  def children; end
end

class ActionDispatch::Journey::Parser < ::Racc::Parser
  include(::ActionDispatch::Journey::Nodes)

  def initialize; end

  def _reduce_1(val, _values); end
  def _reduce_10(val, _values); end
  def _reduce_15(val, _values); end
  def _reduce_16(val, _values); end
  def _reduce_17(val, _values); end
  def _reduce_18(val, _values); end
  def _reduce_2(val, _values); end
  def _reduce_7(val, _values); end
  def _reduce_8(val, _values); end
  def _reduce_9(val, _values); end
  def _reduce_none(val, _values); end
  def next_token; end
  def parse(string); end

  class << self
    def parse(string); end
  end
end

ActionDispatch::Journey::Parser::Racc_arg = T.let(T.unsafe(nil), Array)

ActionDispatch::Journey::Parser::Racc_token_to_s_table = T.let(T.unsafe(nil), Array)

module ActionDispatch::Journey::Path
end

class ActionDispatch::Journey::Path::Pattern
  def initialize(ast, requirements, separators, anchored); end

  def =~(other); end
  def anchored; end
  def ast; end
  def build_formatter; end
  def eager_load!; end
  def match(other); end
  def match?(other); end
  def names; end
  def optional_names; end
  def required_names; end
  def requirements; end
  def requirements_for_missing_keys_check; end
  def source; end
  def spec; end
  def to_regexp; end

  private

  def offsets; end
  def regexp_visitor; end
end

class ActionDispatch::Journey::Path::Pattern::AnchoredRegexp < ::ActionDispatch::Journey::Visitors::Visitor
  def initialize(separator, matchers); end

  def accept(node); end
  def visit_CAT(node); end
  def visit_DOT(node); end
  def visit_GROUP(node); end
  def visit_LITERAL(node); end
  def visit_OR(node); end
  def visit_SLASH(node); end
  def visit_STAR(node); end
  def visit_SYMBOL(node); end
end

class ActionDispatch::Journey::Path::Pattern::MatchData
  def initialize(names, offsets, match); end

  def [](x); end
  def captures; end
  def length; end
  def named_captures; end
  def names; end
  def post_match; end
  def to_s; end
end

class ActionDispatch::Journey::Path::Pattern::UnanchoredRegexp < ::ActionDispatch::Journey::Path::Pattern::AnchoredRegexp
  def accept(node); end
end

class ActionDispatch::Journey::Route
  def initialize(name:, path:, app: T.unsafe(nil), constraints: T.unsafe(nil), required_defaults: T.unsafe(nil), defaults: T.unsafe(nil), request_method_match: T.unsafe(nil), precedence: T.unsafe(nil), scope_options: T.unsafe(nil), internal: T.unsafe(nil)); end

  def app; end
  def ast; end
  def conditions; end
  def constraints; end
  def defaults; end
  def dispatcher?; end
  def eager_load!; end
  def format(path_options); end
  def glob?; end
  def internal; end
  def ip; end
  def matches?(request); end
  def name; end
  def parts; end
  def path; end
  def precedence; end
  def required_default?(key); end
  def required_defaults; end
  def required_keys; end
  def required_parts; end
  def requirements; end
  def requires_matching_verb?; end
  def scope_options; end
  def score(supplied_keys); end
  def segment_keys; end
  def segments; end
  def verb; end

  private

  def match_verb(request); end
  def verbs; end

  class << self
    def verb_matcher(verb); end
  end
end

module ActionDispatch::Journey::Route::VerbMatchers
end

class ActionDispatch::Journey::Route::VerbMatchers::All
  class << self
    def call(_); end
    def verb; end
  end
end

class ActionDispatch::Journey::Route::VerbMatchers::DELETE
  class << self
    def call(req); end
    def verb; end
  end
end

class ActionDispatch::Journey::Route::VerbMatchers::GET
  class << self
    def call(req); end
    def verb; end
  end
end

class ActionDispatch::Journey::Route::VerbMatchers::HEAD
  class << self
    def call(req); end
    def verb; end
  end
end

class ActionDispatch::Journey::Route::VerbMatchers::LINK
  class << self
    def call(req); end
    def verb; end
  end
end

class ActionDispatch::Journey::Route::VerbMatchers::OPTIONS
  class << self
    def call(req); end
    def verb; end
  end
end

class ActionDispatch::Journey::Route::VerbMatchers::PATCH
  class << self
    def call(req); end
    def verb; end
  end
end

class ActionDispatch::Journey::Route::VerbMatchers::POST
  class << self
    def call(req); end
    def verb; end
  end
end

class ActionDispatch::Journey::Route::VerbMatchers::PUT
  class << self
    def call(req); end
    def verb; end
  end
end

class ActionDispatch::Journey::Route::VerbMatchers::TRACE
  class << self
    def call(req); end
    def verb; end
  end
end

class ActionDispatch::Journey::Route::VerbMatchers::UNLINK
  class << self
    def call(req); end
    def verb; end
  end
end

class ActionDispatch::Journey::Route::VerbMatchers::Unknown
  def initialize(verb); end

  def call(request); end
  def verb; end
end

ActionDispatch::Journey::Route::VerbMatchers::VERBS = T.let(T.unsafe(nil), Array)

ActionDispatch::Journey::Route::VerbMatchers::VERB_TO_CLASS = T.let(T.unsafe(nil), Hash)

class ActionDispatch::Journey::Router
  def initialize(routes); end

  def eager_load!; end
  def recognize(rails_req); end
  def routes; end
  def routes=(_arg0); end
  def serve(req); end
  def visualizer; end

  private

  def ast; end
  def custom_routes; end
  def filter_routes(path); end
  def find_routes(req); end
  def match_head_routes(routes, req); end
  def partitioned_routes; end
  def simulator; end
end

class ActionDispatch::Journey::Router::Utils
  class << self
    def escape_fragment(fragment); end
    def escape_path(path); end
    def escape_segment(segment); end
    def normalize_path(path); end
    def unescape_uri(uri); end
  end
end

ActionDispatch::Journey::Router::Utils::ENCODER = T.let(T.unsafe(nil), ActionDispatch::Journey::Router::Utils::UriEncoder)

class ActionDispatch::Journey::Router::Utils::UriEncoder
  def escape_fragment(fragment); end
  def escape_path(path); end
  def escape_segment(segment); end
  def unescape_uri(uri); end

  private

  def escape(component, pattern); end
  def percent_encode(unsafe); end
end

ActionDispatch::Journey::Router::Utils::UriEncoder::ALPHA = T.let(T.unsafe(nil), String)

ActionDispatch::Journey::Router::Utils::UriEncoder::DEC2HEX = T.let(T.unsafe(nil), Array)

ActionDispatch::Journey::Router::Utils::UriEncoder::DIGIT = T.let(T.unsafe(nil), String)

ActionDispatch::Journey::Router::Utils::UriEncoder::EMPTY = T.let(T.unsafe(nil), String)

ActionDispatch::Journey::Router::Utils::UriEncoder::ENCODE = T.let(T.unsafe(nil), String)

ActionDispatch::Journey::Router::Utils::UriEncoder::ESCAPED = T.let(T.unsafe(nil), Regexp)

ActionDispatch::Journey::Router::Utils::UriEncoder::FRAGMENT = T.let(T.unsafe(nil), Regexp)

ActionDispatch::Journey::Router::Utils::UriEncoder::PATH = T.let(T.unsafe(nil), Regexp)

ActionDispatch::Journey::Router::Utils::UriEncoder::SEGMENT = T.let(T.unsafe(nil), Regexp)

ActionDispatch::Journey::Router::Utils::UriEncoder::SUB_DELIMS = T.let(T.unsafe(nil), String)

ActionDispatch::Journey::Router::Utils::UriEncoder::UNRESERVED = T.let(T.unsafe(nil), String)

ActionDispatch::Journey::Router::Utils::UriEncoder::US_ASCII = T.let(T.unsafe(nil), Encoding)

ActionDispatch::Journey::Router::Utils::UriEncoder::UTF_8 = T.let(T.unsafe(nil), Encoding)

class ActionDispatch::Journey::Routes
  include(::Enumerable)

  def initialize; end

  def add_route(name, mapping); end
  def anchored_routes; end
  def ast; end
  def clear; end
  def custom_routes; end
  def each(&block); end
  def empty?; end
  def last; end
  def length; end
  def partition_route(route); end
  def routes; end
  def simulator; end
  def size; end

  private

  def clear_cache!; end
end

class ActionDispatch::Journey::Scanner
  def initialize; end

  def eos?; end
  def next_token; end
  def pos; end
  def pre_match; end
  def scan_setup(str); end

  private

  def dedup_scan(regex); end
  def scan; end
end

module ActionDispatch::Journey::Visitors
end

class ActionDispatch::Journey::Visitors::Dot < ::ActionDispatch::Journey::Visitors::FunctionalVisitor
  def initialize; end

  def accept(node, seed = T.unsafe(nil)); end

  private

  def binary(node, seed); end
  def nary(node, seed); end
  def terminal(node, seed); end
  def unary(node, seed); end
  def visit_CAT(node, seed); end
  def visit_GROUP(node, seed); end
  def visit_OR(node, seed); end
  def visit_STAR(node, seed); end
end

ActionDispatch::Journey::Visitors::Dot::INSTANCE = T.let(T.unsafe(nil), ActionDispatch::Journey::Visitors::Dot)

class ActionDispatch::Journey::Visitors::Each < ::ActionDispatch::Journey::Visitors::FunctionalVisitor
  def visit(node, block); end
end

ActionDispatch::Journey::Visitors::Each::INSTANCE = T.let(T.unsafe(nil), ActionDispatch::Journey::Visitors::Each)

class ActionDispatch::Journey::Visitors::FormatBuilder < ::ActionDispatch::Journey::Visitors::Visitor
  def accept(node); end
  def binary(node); end
  def terminal(node); end
  def visit_GROUP(n); end
  def visit_STAR(n); end
  def visit_SYMBOL(n); end
end

class ActionDispatch::Journey::Visitors::FunctionalVisitor
  def accept(node, seed); end
  def binary(node, seed); end
  def nary(node, seed); end
  def terminal(node, seed); end
  def unary(node, seed); end
  def visit(node, seed); end
  def visit_CAT(n, seed); end
  def visit_DOT(n, seed); end
  def visit_GROUP(n, seed); end
  def visit_LITERAL(n, seed); end
  def visit_OR(n, seed); end
  def visit_SLASH(n, seed); end
  def visit_STAR(n, seed); end
  def visit_SYMBOL(n, seed); end
end

ActionDispatch::Journey::Visitors::FunctionalVisitor::DISPATCH_CACHE = T.let(T.unsafe(nil), Hash)

class ActionDispatch::Journey::Visitors::String < ::ActionDispatch::Journey::Visitors::FunctionalVisitor

  private

  def binary(node, seed); end
  def nary(node, seed); end
  def terminal(node, seed); end
  def visit_GROUP(node, seed); end
end

ActionDispatch::Journey::Visitors::String::INSTANCE = T.let(T.unsafe(nil), ActionDispatch::Journey::Visitors::String)

class ActionDispatch::Journey::Visitors::Visitor
  def accept(node); end

  private

  def binary(node); end
  def nary(node); end
  def terminal(node); end
  def unary(node); end
  def visit(node); end
  def visit_CAT(n); end
  def visit_DOT(n); end
  def visit_GROUP(n); end
  def visit_LITERAL(n); end
  def visit_OR(n); end
  def visit_SLASH(n); end
  def visit_STAR(n); end
  def visit_SYMBOL(n); end
end

ActionDispatch::Journey::Visitors::Visitor::DISPATCH_CACHE = T.let(T.unsafe(nil), Hash)

class ActionDispatch::MiddlewareStack
  include(::Enumerable)

  def initialize(*args); end

  def [](i); end
  def build(app = T.unsafe(nil), &block); end
  def delete(target); end
  def each; end
  def insert(index, klass, *args, &block); end
  def insert_after(index, *args, &block); end
  def insert_before(index, klass, *args, &block); end
  def last; end
  def middlewares; end
  def middlewares=(_arg0); end
  def move(target, source); end
  def move_after(target, source); end
  def move_before(target, source); end
  def size; end
  def swap(target, *args, &block); end
  def unshift(klass, *args, &block); end
  def use(klass, *args, &block); end

  private

  def assert_index(index, where); end
  def build_middleware(klass, args, block); end
  def initialize_copy(other); end
end

class ActionDispatch::MiddlewareStack::InstrumentationProxy
  def initialize(middleware, class_name); end

  def call(env); end
end

ActionDispatch::MiddlewareStack::InstrumentationProxy::EVENT_NAME = T.let(T.unsafe(nil), String)

class ActionDispatch::MiddlewareStack::Middleware
  def initialize(klass, args, block); end

  def ==(middleware); end
  def args; end
  def block; end
  def build(app); end
  def build_instrumented(app); end
  def inspect; end
  def klass; end
  def name; end
end

class ActionDispatch::MissingController < ::NameError
end

class ActionDispatch::PermissionsPolicy
  def initialize; end

  def accelerometer(*sources); end
  def ambient_light_sensor(*sources); end
  def autoplay(*sources); end
  def build(context = T.unsafe(nil)); end
  def camera(*sources); end
  def directives; end
  def encrypted_media(*sources); end
  def fullscreen(*sources); end
  def geolocation(*sources); end
  def gyroscope(*sources); end
  def magnetometer(*sources); end
  def microphone(*sources); end
  def midi(*sources); end
  def payment(*sources); end
  def picture_in_picture(*sources); end
  def speaker(*sources); end
  def usb(*sources); end
  def vibrate(*sources); end
  def vr(*sources); end

  private

  def apply_mapping(source); end
  def apply_mappings(sources); end
  def build_directive(sources, context); end
  def build_directives(context); end
  def initialize_copy(other); end
  def resolve_source(source, context); end
end

class ActionDispatch::PermissionsPolicy::Middleware
  def initialize(app); end

  def call(env); end

  private

  def html_response?(headers); end
  def policy_empty?(policy); end
  def policy_present?(headers); end
end

ActionDispatch::PermissionsPolicy::Middleware::CONTENT_TYPE = T.let(T.unsafe(nil), String)

ActionDispatch::PermissionsPolicy::Middleware::POLICY = T.let(T.unsafe(nil), String)

module ActionDispatch::PermissionsPolicy::Request
  def permissions_policy; end
  def permissions_policy=(policy); end
end

ActionDispatch::PermissionsPolicy::Request::POLICY = T.let(T.unsafe(nil), String)

class ActionDispatch::PublicExceptions
  def initialize(public_path); end

  def call(env); end
  def public_path; end
  def public_path=(_arg0); end

  private

  def render(status, content_type, body); end
  def render_format(status, content_type, body); end
  def render_html(status); end
end

class ActionDispatch::Railtie < ::Rails::Railtie
end

class ActionDispatch::Reloader < ::ActionDispatch::Executor
end

class ActionDispatch::RemoteIp
  def initialize(app, ip_spoofing_check = T.unsafe(nil), custom_proxies = T.unsafe(nil)); end

  def call(env); end
  def check_ip; end
  def proxies; end
end

class ActionDispatch::RemoteIp::GetIp
  def initialize(req, check_ip, proxies); end

  def calculate_ip; end
  def to_s; end

  private

  def filter_proxies(ips); end
  def ips_from(header); end
end

class ActionDispatch::RemoteIp::IpSpoofAttackError < ::StandardError
end

ActionDispatch::RemoteIp::TRUSTED_PROXIES = T.let(T.unsafe(nil), Array)

class ActionDispatch::Request
  include(::ActionDispatch::Flash::RequestMethods)
  include(::Rack::Request::Helpers)
  include(::ActionDispatch::Http::Cache::Request)
  include(::ActionDispatch::Http::MimeNegotiation)
  include(::ActionDispatch::Http::Parameters)
  include(::ActionDispatch::Http::FilterParameters)
  include(::ActionDispatch::Http::URL)
  include(::ActionDispatch::ContentSecurityPolicy::Request)
  include(::ActionDispatch::PermissionsPolicy::Request)
  include(::Rack::Request::Env)
  extend(::ActionDispatch::Http::Parameters::ClassMethods)

  def initialize(env); end

  def GET; end
  def POST; end
  def accept; end
  def accept_charset; end
  def accept_encoding; end
  def accept_language; end
  def auth_type; end
  def authenticated_encrypted_cookie_salt; end
  def authorization; end
  def body; end
  def body_stream; end
  def cache_control; end
  def client_ip; end
  def content_length; end
  def controller_class; end
  def controller_class_for(name); end
  def controller_instance; end
  def controller_instance=(controller); end
  def cookie_jar; end
  def cookie_jar=(jar); end
  def cookies_digest; end
  def cookies_rotations; end
  def cookies_same_site_protection; end
  def cookies_serializer; end
  def encrypted_cookie_cipher; end
  def encrypted_cookie_salt; end
  def encrypted_signed_cookie_salt; end
  def engine_script_name(_routes); end
  def engine_script_name=(name); end
  def form_data?; end
  def from; end
  def fullpath; end
  def gateway_interface; end
  def have_cookie_jar?; end
  def headers; end
  def http_auth_salt; end
  def ignore_accept_header; end
  def ignore_accept_header=(val); end
  def inspect; end
  def ip; end
  def key?(key); end
  def key_generator; end
  def local?; end
  def logger; end
  def media_type; end
  def method; end
  def method_symbol; end
  def negotiate; end
  def origin; end
  def original_fullpath; end
  def original_script_name; end
  def original_url; end
  def path_translated; end
  def pragma; end
  def query_parameters; end
  def raw_post; end
  def raw_request_method; end
  def remote_addr; end
  def remote_host; end
  def remote_ident; end
  def remote_ip; end
  def remote_ip=(remote_ip); end
  def remote_user; end
  def request_id; end
  def request_id=(id); end
  def request_method; end
  def request_method=(request_method); end
  def request_method_symbol; end
  def request_parameters; end
  def request_parameters=(params); end
  def routes; end
  def routes=(routes); end
  def secret_key_base; end
  def send_early_hints(links); end
  def server_addr; end
  def server_name; end
  def server_protocol; end
  def server_software; end
  def session=(session); end
  def session_options=(options); end
  def show_exceptions?; end
  def signed_cookie_digest; end
  def signed_cookie_salt; end
  def ssl?; end
  def use_authenticated_cookie_encryption; end
  def use_cookies_with_metadata; end
  def uuid; end
  def version; end
  def x_csrf_token; end
  def x_forwarded_for; end
  def x_forwarded_host; end
  def x_request_id; end
  def xhr?; end
  def xml_http_request?; end

  private

  def check_method(name); end

  class << self
    def empty; end
    def ignore_accept_header; end
    def ignore_accept_header=(val); end
    def parameter_parsers; end
  end
end

ActionDispatch::Request::ACTION_DISPATCH_REQUEST_ID = T.let(T.unsafe(nil), String)

ActionDispatch::Request::ENV_METHODS = T.let(T.unsafe(nil), Array)

ActionDispatch::Request::HTTP_METHODS = T.let(T.unsafe(nil), Array)

ActionDispatch::Request::HTTP_METHOD_LOOKUP = T.let(T.unsafe(nil), Hash)

ActionDispatch::Request::LOCALHOST = T.let(T.unsafe(nil), Regexp)

class ActionDispatch::Request::PASS_NOT_FOUND
  class << self
    def action(_); end
    def action_encoding_template(action); end
    def call(_); end
  end
end

ActionDispatch::Request::RFC2518 = T.let(T.unsafe(nil), Array)

ActionDispatch::Request::RFC2616 = T.let(T.unsafe(nil), Array)

ActionDispatch::Request::RFC3253 = T.let(T.unsafe(nil), Array)

ActionDispatch::Request::RFC3648 = T.let(T.unsafe(nil), Array)

ActionDispatch::Request::RFC3744 = T.let(T.unsafe(nil), Array)

ActionDispatch::Request::RFC4791 = T.let(T.unsafe(nil), Array)

ActionDispatch::Request::RFC5323 = T.let(T.unsafe(nil), Array)

ActionDispatch::Request::RFC5789 = T.let(T.unsafe(nil), Array)

class ActionDispatch::Request::Session
  def initialize(by, req); end

  def [](key); end
  def []=(key, value); end
  def clear; end
  def delete(key); end
  def destroy; end
  def dig(*keys); end
  def each(&block); end
  def empty?; end
  def exists?; end
  def fetch(key, default = T.unsafe(nil), &block); end
  def has_key?(key); end
  def id; end
  def include?(key); end
  def inspect; end
  def key?(key); end
  def keys; end
  def loaded?; end
  def merge!(other); end
  def options; end
  def to_h; end
  def to_hash; end
  def update(hash); end
  def values; end

  private

  def load!; end
  def load_for_read!; end
  def load_for_write!; end

  class << self
    def create(store, req, default_options); end
    def find(req); end
    def set(req, session); end
  end
end

ActionDispatch::Request::Session::ENV_SESSION_KEY = T.let(T.unsafe(nil), String)

ActionDispatch::Request::Session::ENV_SESSION_OPTIONS_KEY = T.let(T.unsafe(nil), String)

class ActionDispatch::Request::Session::Options
  def initialize(by, default_options); end

  def [](key); end
  def []=(k, v); end
  def id(req); end
  def to_hash; end
  def values_at(*args); end

  class << self
    def find(req); end
    def set(req, options); end
  end
end

ActionDispatch::Request::Session::Unspecified = T.let(T.unsafe(nil), Object)

class ActionDispatch::Request::Utils
  def perform_deep_munge; end
  def perform_deep_munge=(val); end

  class << self
    def check_param_encoding(params); end
    def each_param_value(params, &block); end
    def normalize_encode_params(params); end
    def perform_deep_munge; end
    def perform_deep_munge=(val); end
    def set_binary_encoding(request, params, controller, action); end
  end
end

class ActionDispatch::Request::Utils::CustomParamEncoder
  class << self
    def action_encoding_template(request, controller, action); end
    def encode(request, params, controller, action); end
  end
end

class ActionDispatch::Request::Utils::NoNilParamEncoder < ::ActionDispatch::Request::Utils::ParamEncoder
  class << self
    def handle_array(params); end
  end
end

class ActionDispatch::Request::Utils::ParamEncoder
  class << self
    def handle_array(params); end
    def normalize_encode_params(params); end
  end
end

class ActionDispatch::RequestId
  def initialize(app, header:); end

  def call(env); end

  private

  def internal_request_id; end
  def make_request_id(request_id); end
end

class ActionDispatch::Response
  include(::Rack::Response::Helpers)
  include(::ActionDispatch::Http::FilterRedirect)
  include(::ActionDispatch::Http::Cache::Response)
  include(::MonitorMixin)

  def initialize(status = T.unsafe(nil), header = T.unsafe(nil), body = T.unsafe(nil)); end

  def [](*_arg0, &_arg1); end
  def []=(*_arg0, &_arg1); end
  def _cache_control; end
  def _cache_control=(v); end
  def abort; end
  def await_commit; end
  def await_sent; end
  def body; end
  def body=(body); end
  def body_parts; end
  def charset; end
  def charset=(charset); end
  def close; end
  def code; end
  def commit!; end
  def committed?; end
  def content_type; end
  def content_type=(content_type); end
  def cookies; end
  def default_charset; end
  def default_charset=(val); end
  def default_headers; end
  def default_headers=(val); end
  def delete_header(key); end
  def each(&block); end
  def get_header(key); end
  def has_header?(key); end
  def header; end
  def headers; end
  def media_type; end
  def message; end
  def prepare!; end
  def redirect_url; end
  def request; end
  def request=(_arg0); end
  def reset_body!; end
  def response_code; end
  def send_file(path); end
  def sending!; end
  def sending?; end
  def sending_file=(v); end
  def sent!; end
  def sent?; end
  def set_header(key, v); end
  def status; end
  def status=(status); end
  def status_message; end
  def stream; end
  def to_a; end
  def write(string); end

  private

  def assign_default_content_type_and_charset!; end
  def before_committed; end
  def before_sending; end
  def build_buffer(response, body); end
  def handle_no_content!; end
  def munge_body_object(body); end
  def parse_content_type(content_type); end
  def parsed_content_type_header; end
  def rack_response(status, header); end
  def set_content_type(content_type, charset); end

  class << self
    def create(status = T.unsafe(nil), header = T.unsafe(nil), body = T.unsafe(nil), default_headers: T.unsafe(nil)); end
    def default_charset; end
    def default_charset=(val); end
    def default_headers; end
    def default_headers=(val); end
    def merge_default_headers(original, default); end
    def return_only_media_type_on_content_type; end
    def return_only_media_type_on_content_type=(*_arg0); end
  end
end

class ActionDispatch::Response::Buffer
  def initialize(response, buf); end

  def abort; end
  def body; end
  def close; end
  def closed?; end
  def each(&block); end
  def write(string); end

  private

  def each_chunk(&block); end
end

ActionDispatch::Response::CONTENT_TYPE = T.let(T.unsafe(nil), String)

ActionDispatch::Response::CONTENT_TYPE_PARSER = T.let(T.unsafe(nil), Regexp)

class ActionDispatch::Response::ContentTypeHeader < ::Struct
  def charset; end
  def charset=(_); end
  def mime_type; end
  def mime_type=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def members; end
    def new(*_arg0); end
  end
end

class ActionDispatch::Response::FileBody
  def initialize(path); end

  def body; end
  def each; end
  def to_path; end
end

class ActionDispatch::Response::Header
  def initialize(response, header); end

  def []=(k, v); end
  def merge(other); end
  def to_hash; end
end

ActionDispatch::Response::LOCATION = T.let(T.unsafe(nil), String)

ActionDispatch::Response::NO_CONTENT_CODES = T.let(T.unsafe(nil), Array)

ActionDispatch::Response::NullContentTypeHeader = T.let(T.unsafe(nil), ActionDispatch::Response::ContentTypeHeader)

class ActionDispatch::Response::RackBody
  def initialize(response); end

  def body; end
  def close; end
  def each(*args, &block); end
  def respond_to?(method, include_private = T.unsafe(nil)); end
  def to_ary; end
  def to_path; end
end

ActionDispatch::Response::SET_COOKIE = T.let(T.unsafe(nil), String)

module ActionDispatch::Routing
  extend(::ActiveSupport::Autoload)
end

module ActionDispatch::Routing::ConsoleFormatter
end

class ActionDispatch::Routing::ConsoleFormatter::Base
  def initialize; end

  def header(routes); end
  def no_routes(routes, filter); end
  def result; end
  def section(routes); end
  def section_title(title); end
end

class ActionDispatch::Routing::ConsoleFormatter::Expanded < ::ActionDispatch::Routing::ConsoleFormatter::Base
  def initialize(width: T.unsafe(nil)); end

  def section(routes); end
  def section_title(title); end

  private

  def draw_expanded_section(routes); end
  def route_header(index:); end
end

class ActionDispatch::Routing::ConsoleFormatter::Sheet < ::ActionDispatch::Routing::ConsoleFormatter::Base
  def header(routes); end
  def section(routes); end
  def section_title(title); end

  private

  def draw_header(routes); end
  def draw_section(routes); end
  def widths(routes); end
end

ActionDispatch::Routing::HTTP_METHODS = T.let(T.unsafe(nil), Array)

class ActionDispatch::Routing::HtmlTableFormatter
  def initialize(view); end

  def header(routes); end
  def no_routes(*_arg0); end
  def result; end
  def section(routes); end
  def section_title(title); end
end

class ActionDispatch::Routing::Mapper
  include(::ActionDispatch::Routing::Mapper::Base)
  include(::ActionDispatch::Routing::Mapper::HttpHelpers)
  include(::ActionDispatch::Routing::Redirection)
  include(::ActionDispatch::Routing::Mapper::Scoping)
  include(::ActionDispatch::Routing::Mapper::Concerns)
  include(::ActionDispatch::Routing::Mapper::Resources)
  include(::ActionDispatch::Routing::Mapper::CustomUrls)

  def initialize(set); end

  class << self
    def normalize_name(name); end
    def normalize_path(path); end
  end
end

module ActionDispatch::Routing::Mapper::Base
  def default_url_options(options); end
  def default_url_options=(options); end
  def has_named_route?(name); end
  def match(path, options = T.unsafe(nil)); end
  def mount(app, options = T.unsafe(nil)); end
  def with_default_scope(scope, &block); end

  private

  def app_name(app, rails_app); end
  def define_generate_prefix(app, name); end
  def rails_app?(app); end
end

module ActionDispatch::Routing::Mapper::Concerns
  def concern(name, callable = T.unsafe(nil), &block); end
  def concerns(*args); end
end

class ActionDispatch::Routing::Mapper::Constraints < ::ActionDispatch::Routing::Endpoint
  def initialize(app, constraints, strategy); end

  def app; end
  def constraints; end
  def dispatcher?; end
  def matches?(req); end
  def serve(req); end

  private

  def constraint_args(constraint, request); end
end

ActionDispatch::Routing::Mapper::Constraints::CALL = T.let(T.unsafe(nil), Proc)

ActionDispatch::Routing::Mapper::Constraints::SERVE = T.let(T.unsafe(nil), Proc)

module ActionDispatch::Routing::Mapper::CustomUrls
  def direct(name, options = T.unsafe(nil), &block); end
  def resolve(*args, &block); end
end

module ActionDispatch::Routing::Mapper::HttpHelpers
  def delete(*args, &block); end
  def get(*args, &block); end
  def options(*args, &block); end
  def patch(*args, &block); end
  def post(*args, &block); end
  def put(*args, &block); end

  private

  def map_method(method, args, &block); end
end

class ActionDispatch::Routing::Mapper::Mapping
  def initialize(set:, ast:, controller:, default_action:, to:, formatted:, via:, options_constraints:, anchor:, scope_params:, options:); end

  def application; end
  def ast; end
  def conditions; end
  def default_action; end
  def default_controller; end
  def defaults; end
  def make_route(name, precedence); end
  def path; end
  def required_defaults; end
  def requirements; end
  def scope_options; end
  def to; end

  private

  def add_controller_module(controller, modyoule); end
  def alter_regex_for_custom_routes(node); end
  def app(blocks); end
  def blocks(callable_constraint); end
  def build_conditions(current_conditions, request_class); end
  def check_controller_and_action(path_params, controller, action); end
  def check_part(name, part, path_params, hash); end
  def constraints(options, path_params); end
  def dispatcher(raise_on_name_error); end
  def intern(object); end
  def normalize_defaults(options); end
  def normalize_format(formatted); end
  def normalize_options!(options, path_params, modyoule); end
  def request_method; end
  def split_constraints(path_params, constraints); end
  def split_to(to); end
  def translate_controller(controller); end
  def verify_regexp_requirements(requirements); end

  class << self
    def build(scope, set, ast, controller, default_action, to, via, formatted, options_constraints, anchor, options); end
    def check_via(via); end
    def normalize_path(path, format); end
    def optional_format?(path, format); end
  end
end

ActionDispatch::Routing::Mapper::Mapping::ANCHOR_CHARACTERS_REGEX = T.let(T.unsafe(nil), Regexp)

ActionDispatch::Routing::Mapper::Mapping::JOINED_SEPARATORS = T.let(T.unsafe(nil), String)

ActionDispatch::Routing::Mapper::Mapping::OPTIONAL_FORMAT_REGEX = T.let(T.unsafe(nil), Regexp)

module ActionDispatch::Routing::Mapper::Resources
  def collection; end
  def draw(name); end
  def match(path, *rest, &block); end
  def member; end
  def namespace(path, options = T.unsafe(nil)); end
  def nested; end
  def new; end
  def resource(*resources, &block); end
  def resources(*resources, &block); end
  def resources_path_names(options); end
  def root(path, options = T.unsafe(nil)); end
  def shallow; end
  def shallow?; end

  private

  def action_options?(options); end
  def action_path(name); end
  def add_route(action, controller, options, _path, to, via, formatted, anchor, options_constraints); end
  def api_only?; end
  def apply_action_options(options); end
  def apply_common_behavior_for(method, resources, options, &block); end
  def canonical_action?(action); end
  def decomposed_match(path, controller, options, _path, to, via, formatted, anchor, options_constraints); end
  def get_to_from_path(path, to, action); end
  def map_match(paths, options); end
  def match_root_route(options); end
  def name_for_action(as, action); end
  def nested_options; end
  def nested_scope?; end
  def param_constraint; end
  def param_constraint?; end
  def parent_resource; end
  def path_for_action(action, path); end
  def path_scope(path); end
  def prefix_name_for_action(as, action); end
  def resource_method_scope?; end
  def resource_scope(resource); end
  def resource_scope?; end
  def scope_action_options; end
  def set_member_mappings_for_resource; end
  def shallow_nesting_depth; end
  def shallow_scope; end
  def using_match_shorthand?(path); end
  def with_scope_level(kind); end
end

ActionDispatch::Routing::Mapper::Resources::CANONICAL_ACTIONS = T.let(T.unsafe(nil), Array)

ActionDispatch::Routing::Mapper::Resources::RESOURCE_OPTIONS = T.let(T.unsafe(nil), Array)

class ActionDispatch::Routing::Mapper::Resources::Resource
  def initialize(entities, api_only, shallow, options = T.unsafe(nil)); end

  def actions; end
  def available_actions; end
  def collection_name; end
  def collection_scope; end
  def controller; end
  def default_actions; end
  def member_name; end
  def member_scope; end
  def name; end
  def nested_param; end
  def nested_scope; end
  def new_scope(new_path); end
  def param; end
  def path; end
  def plural; end
  def resource_scope; end
  def shallow?; end
  def shallow_scope; end
  def singleton?; end
  def singular; end
end

class ActionDispatch::Routing::Mapper::Resources::SingletonResource < ::ActionDispatch::Routing::Mapper::Resources::Resource
  def initialize(entities, api_only, shallow, options); end

  def collection_name; end
  def default_actions; end
  def member_name; end
  def member_scope; end
  def nested_scope; end
  def plural; end
  def singleton?; end
  def singular; end
end

ActionDispatch::Routing::Mapper::Resources::VALID_ON_OPTIONS = T.let(T.unsafe(nil), Array)

class ActionDispatch::Routing::Mapper::Scope
  include(::Enumerable)

  def initialize(hash, parent = T.unsafe(nil), scope_level = T.unsafe(nil)); end

  def [](key); end
  def action_name(name_prefix, prefix, collection_name, member_name); end
  def each; end
  def frame; end
  def nested?; end
  def new(hash); end
  def new_level(level); end
  def null?; end
  def options; end
  def parent; end
  def resource_method_scope?; end
  def resource_scope?; end
  def resources?; end
  def root?; end
  def scope_level; end
end

ActionDispatch::Routing::Mapper::Scope::NULL = T.let(T.unsafe(nil), ActionDispatch::Routing::Mapper::Scope)

ActionDispatch::Routing::Mapper::Scope::OPTIONS = T.let(T.unsafe(nil), Array)

ActionDispatch::Routing::Mapper::Scope::RESOURCE_METHOD_SCOPES = T.let(T.unsafe(nil), Array)

ActionDispatch::Routing::Mapper::Scope::RESOURCE_SCOPES = T.let(T.unsafe(nil), Array)

module ActionDispatch::Routing::Mapper::Scoping
  def constraints(constraints = T.unsafe(nil)); end
  def controller(controller); end
  def defaults(defaults = T.unsafe(nil)); end
  def namespace(path, options = T.unsafe(nil)); end
  def scope(*args); end

  private

  def merge_action_scope(parent, child); end
  def merge_as_scope(parent, child); end
  def merge_blocks_scope(parent, child); end
  def merge_constraints_scope(parent, child); end
  def merge_controller_scope(parent, child); end
  def merge_defaults_scope(parent, child); end
  def merge_format_scope(parent, child); end
  def merge_module_scope(parent, child); end
  def merge_options_scope(parent, child); end
  def merge_path_names_scope(parent, child); end
  def merge_path_scope(parent, child); end
  def merge_shallow_path_scope(parent, child); end
  def merge_shallow_prefix_scope(parent, child); end
  def merge_shallow_scope(parent, child); end
  def merge_to_scope(parent, child); end
  def merge_via_scope(parent, child); end
end

ActionDispatch::Routing::Mapper::Scoping::POISON = T.let(T.unsafe(nil), Object)

ActionDispatch::Routing::Mapper::URL_OPTIONS = T.let(T.unsafe(nil), Array)

module ActionDispatch::Routing::PolymorphicRoutes
  def edit_polymorphic_path(record_or_hash, options = T.unsafe(nil)); end
  def edit_polymorphic_url(record_or_hash, options = T.unsafe(nil)); end
  def new_polymorphic_path(record_or_hash, options = T.unsafe(nil)); end
  def new_polymorphic_url(record_or_hash, options = T.unsafe(nil)); end
  def polymorphic_path(record_or_hash_or_array, options = T.unsafe(nil)); end
  def polymorphic_url(record_or_hash_or_array, options = T.unsafe(nil)); end

  private

  def polymorphic_mapping(record); end
  def polymorphic_path_for_action(action, record_or_hash, options); end
  def polymorphic_url_for_action(action, record_or_hash, options); end
end

class ActionDispatch::Routing::PolymorphicRoutes::HelperMethodBuilder
  def initialize(key_strategy, prefix, suffix); end

  def handle_class(klass); end
  def handle_class_call(target, klass); end
  def handle_list(list); end
  def handle_model(record); end
  def handle_model_call(target, record); end
  def handle_string(record); end
  def handle_string_call(target, str); end
  def prefix; end
  def suffix; end

  private

  def get_method_for_class(klass); end
  def get_method_for_string(str); end
  def polymorphic_mapping(target, record); end

  class << self
    def build(action, type); end
    def get(action, type); end
    def path; end
    def plural(prefix, suffix); end
    def polymorphic_method(recipient, record_or_hash_or_array, action, type, options); end
    def singular(prefix, suffix); end
    def url; end
  end
end

ActionDispatch::Routing::PolymorphicRoutes::HelperMethodBuilder::CACHE = T.let(T.unsafe(nil), Hash)

class ActionDispatch::Routing::RouteSet
  def initialize(config = T.unsafe(nil)); end

  def add_polymorphic_mapping(klass, options, &block); end
  def add_route(mapping, name); end
  def add_url_helper(name, options, &block); end
  def api_only?; end
  def append(&block); end
  def call(env); end
  def clear!; end
  def default_scope; end
  def default_scope=(_arg0); end
  def default_url_options; end
  def default_url_options=(_arg0); end
  def define_mounted_helper(name, script_namer = T.unsafe(nil)); end
  def disable_clear_and_finalize; end
  def disable_clear_and_finalize=(_arg0); end
  def draw(&block); end
  def draw_paths; end
  def draw_paths=(_arg0); end
  def eager_load!; end
  def empty?; end
  def env_key; end
  def extra_keys(options, recall = T.unsafe(nil)); end
  def finalize!; end
  def find_relative_url_root(options); end
  def find_script_name(options); end
  def formatter; end
  def formatter=(_arg0); end
  def generate_extras(options, recall = T.unsafe(nil)); end
  def generate_url_helpers(supports_path); end
  def inspect; end
  def mounted_helpers; end
  def named_routes; end
  def named_routes=(_arg0); end
  def optimize_routes_generation?; end
  def path_for(options, route_name = T.unsafe(nil), reserved = T.unsafe(nil)); end
  def polymorphic_mappings; end
  def prepend(&block); end
  def recognize_path(path, environment = T.unsafe(nil)); end
  def recognize_path_with_request(req, path, extras, raise_on_missing: T.unsafe(nil)); end
  def relative_url_root; end
  def request_class; end
  def resources_path_names; end
  def resources_path_names=(_arg0); end
  def router; end
  def router=(_arg0); end
  def routes; end
  def set; end
  def set=(_arg0); end
  def url_for(options, route_name = T.unsafe(nil), url_strategy = T.unsafe(nil), method_name = T.unsafe(nil), reserved = T.unsafe(nil)); end
  def url_helpers(supports_path = T.unsafe(nil)); end

  private

  def eval_block(block); end
  def generate(route_name, options, recall = T.unsafe(nil), method_name = T.unsafe(nil)); end
  def make_request(env); end

  class << self
    def default_resources_path_names; end
    def new_with_config(config); end
  end
end

class ActionDispatch::Routing::RouteSet::Config < ::Struct
  def api_only; end
  def api_only=(_); end
  def relative_url_root; end
  def relative_url_root=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def members; end
    def new(*_arg0); end
  end
end

class ActionDispatch::Routing::RouteSet::CustomUrlHelper
  def initialize(name, defaults, &block); end

  def block; end
  def call(t, args, only_path = T.unsafe(nil)); end
  def defaults; end
  def name; end

  private

  def eval_block(t, args, options); end
  def merge_defaults(options); end
end

ActionDispatch::Routing::RouteSet::DEFAULT_CONFIG = T.let(T.unsafe(nil), ActionDispatch::Routing::RouteSet::Config)

class ActionDispatch::Routing::RouteSet::Dispatcher < ::ActionDispatch::Routing::Endpoint
  def initialize(raise_on_name_error); end

  def dispatcher?; end
  def serve(req); end

  private

  def controller(req); end
  def dispatch(controller, action, req, res); end
end

class ActionDispatch::Routing::RouteSet::Generator
  def initialize(named_route, options, recall, set); end

  def controller; end
  def current_controller; end
  def different_controller?; end
  def generate; end
  def named_route; end
  def normalize_controller!; end
  def normalize_controller_action_id!; end
  def normalize_options!; end
  def options; end
  def recall; end
  def set; end
  def use_recall_for(key); end
  def use_relative_controller!; end

  private

  def named_route_exists?; end
  def segment_keys; end
end

module ActionDispatch::Routing::RouteSet::MountedHelpers
  extend(::ActiveSupport::Concern)

  include(::ActionDispatch::Routing::UrlFor)
end

class ActionDispatch::Routing::RouteSet::NamedRouteCollection
  include(::Enumerable)

  def initialize; end

  def [](name); end
  def []=(name, route); end
  def add(name, route); end
  def add_url_helper(name, defaults, &block); end
  def clear; end
  def clear!; end
  def each; end
  def get(name); end
  def helper_names; end
  def key?(name); end
  def length; end
  def names; end
  def path_helpers_module; end
  def route_defined?(name); end
  def url_helpers_module; end

  private

  def define_url_helper(mod, name, helper, url_strategy); end
  def routes; end
end

class ActionDispatch::Routing::RouteSet::NamedRouteCollection::UrlHelper
  def initialize(route, options, route_name); end

  def call(t, method_name, args, inner_options, url_strategy); end
  def handle_positional_args(controller_options, inner_options, args, result, path_params); end
  def route_name; end

  class << self
    def create(route, options, route_name); end
    def optimize_helper?(route); end
  end
end

class ActionDispatch::Routing::RouteSet::NamedRouteCollection::UrlHelper::OptimizedUrlHelper < ::ActionDispatch::Routing::RouteSet::NamedRouteCollection::UrlHelper
  def initialize(route, options, route_name); end

  def arg_size; end
  def call(t, method_name, args, inner_options, url_strategy); end

  private

  def optimize_routes_generation?(t); end
  def optimized_helper(args); end
  def parameterize_args(args); end
  def raise_generation_error(args); end
end

ActionDispatch::Routing::RouteSet::PATH = T.let(T.unsafe(nil), Proc)

ActionDispatch::Routing::RouteSet::RESERVED_OPTIONS = T.let(T.unsafe(nil), Array)

class ActionDispatch::Routing::RouteSet::StaticDispatcher < ::ActionDispatch::Routing::RouteSet::Dispatcher
  def initialize(controller_class); end


  private

  def controller(_); end
end

ActionDispatch::Routing::RouteSet::UNKNOWN = T.let(T.unsafe(nil), Proc)

class ActionDispatch::Routing::RouteWrapper < ::SimpleDelegator
  def action; end
  def constraints; end
  def controller; end
  def endpoint; end
  def engine?; end
  def internal?; end
  def name; end
  def path; end
  def rack_app; end
  def reqs; end
end

class ActionDispatch::Routing::RoutesInspector
  def initialize(routes); end

  def format(formatter, filter = T.unsafe(nil)); end

  private

  def collect_engine_routes(route); end
  def collect_routes(routes); end
  def filter_routes(filter); end
  def normalize_filter(filter); end
end

class ActionDispatch::Routing::RoutesProxy
  include(::ActionDispatch::Routing::PolymorphicRoutes)
  include(::ActionDispatch::Routing::UrlFor)

  def initialize(routes, scope, helpers, script_namer = T.unsafe(nil)); end

  def _routes; end
  def default_url_options; end
  def default_url_options=(_arg0); end
  def default_url_options?; end
  def routes; end
  def routes=(_arg0); end
  def scope; end
  def scope=(_arg0); end
  def url_options; end

  private

  def merge_script_names(previous_script_name, new_script_name); end
  def method_missing(method, *args); end
  def respond_to_missing?(method, _); end

  class << self
    def default_url_options; end
    def default_url_options=(value); end
    def default_url_options?; end
  end
end

ActionDispatch::Routing::SEPARATORS = T.let(T.unsafe(nil), Array)

module ActionDispatch::Routing::UrlFor
  include(::ActionDispatch::Routing::PolymorphicRoutes)
  extend(::ActiveSupport::Concern)

  def initialize(*_arg0); end

  def full_url_for(options = T.unsafe(nil)); end
  def route_for(name, *args); end
  def url_for(options = T.unsafe(nil)); end
  def url_options; end

  protected

  def optimize_routes_generation?; end

  private

  def _routes_context; end
  def _with_routes(routes); end
end

class ActionDispatch::SSL
  def initialize(app, redirect: T.unsafe(nil), hsts: T.unsafe(nil), secure_cookies: T.unsafe(nil), ssl_default_redirect_status: T.unsafe(nil)); end

  def call(env); end

  private

  def build_hsts_header(hsts); end
  def flag_cookies_as_secure!(headers); end
  def https_location_for(request); end
  def normalize_hsts_options(options); end
  def redirect_to_https(request); end
  def redirection_status(request); end
  def set_hsts_header!(headers); end

  class << self
    def default_hsts_options; end
  end
end

ActionDispatch::SSL::HSTS_EXPIRES_IN = T.let(T.unsafe(nil), Integer)

ActionDispatch::SSL::PERMANENT_REDIRECT_REQUEST_METHODS = T.let(T.unsafe(nil), Array)

module ActionDispatch::Session
end

class ActionDispatch::Session::AbstractSecureStore < ::Rack::Session::Abstract::PersistedSecure
  include(::ActionDispatch::Session::Compatibility)
  include(::ActionDispatch::Session::StaleSessionCheck)
  include(::ActionDispatch::Session::SessionObject)

  def generate_sid; end

  private

  def set_cookie(request, response, cookie); end
end

class ActionDispatch::Session::AbstractStore < ::Rack::Session::Abstract::Persisted
  include(::ActionDispatch::Session::Compatibility)
  include(::ActionDispatch::Session::StaleSessionCheck)
  include(::ActionDispatch::Session::SessionObject)


  private

  def set_cookie(request, response, cookie); end
end

class ActionDispatch::Session::CacheStore < ::ActionDispatch::Session::AbstractSecureStore
  def initialize(app, options = T.unsafe(nil)); end

  def delete_session(env, sid, options); end
  def find_session(env, sid); end
  def write_session(env, sid, session, options); end

  private

  def cache_key(id); end
  def get_session_with_fallback(sid); end
end

class ActionDispatch::Session::CookieStore < ::ActionDispatch::Session::AbstractSecureStore
  def initialize(app, options = T.unsafe(nil)); end

  def delete_session(req, session_id, options); end
  def load_session(req); end

  private

  def cookie_jar(request); end
  def extract_session_id(req); end
  def get_cookie(req); end
  def persistent_session_id!(data, sid = T.unsafe(nil)); end
  def set_cookie(request, session_id, cookie); end
  def unpacked_cookie_data(req); end
  def write_session(req, sid, session_data, options); end
end

class ActionDispatch::Session::CookieStore::SessionId
  def initialize(session_id, cookie_value = T.unsafe(nil)); end

  def cookie_value; end
end

class ActionDispatch::ShowExceptions
  def initialize(app, exceptions_app); end

  def call(env); end

  private

  def pass_response(status); end
  def render_exception(request, exception); end
end

ActionDispatch::ShowExceptions::FAILSAFE_RESPONSE = T.let(T.unsafe(nil), Array)

class ActionDispatch::Static
  def initialize(app, path, index: T.unsafe(nil), headers: T.unsafe(nil)); end

  def call(env); end
end

class ActionDispatch::SystemTestCase < ::ActiveSupport::TestCase
  include(::Capybara::DSL)
  include(::Capybara::Minitest::Assertions)
  include(::ActionDispatch::SystemTesting::TestHelpers::SetupAndTeardown)
  include(::ActionDispatch::SystemTesting::TestHelpers::ScreenshotHelper)

  def initialize(*_arg0); end


  private

  def method_missing(name, *args, &block); end
  def respond_to_missing?(name, include_private = T.unsafe(nil)); end
  def url_helpers; end

  class << self
    def driven_by(driver, using: T.unsafe(nil), screen_size: T.unsafe(nil), options: T.unsafe(nil), &capabilities); end
    def driver; end
    def driver=(value); end
    def driver?; end
    def start_application; end
  end
end

module ActionDispatch::TestProcess
  include(::ActionDispatch::TestProcess::FixtureFile)

  def assigns(key = T.unsafe(nil)); end
  def cookies; end
  def flash; end
  def redirect_to_url; end
  def session; end
end

module ActionDispatch::TestProcess::FixtureFile
  def fixture_file_upload(path, mime_type = T.unsafe(nil), binary = T.unsafe(nil)); end
end

class ActionDispatch::TestRequest < ::ActionDispatch::Request
  def accept=(mime_types); end
  def action=(action_name); end
  def host=(host); end
  def if_modified_since=(last_modified); end
  def if_none_match=(etag); end
  def path=(path); end
  def port=(number); end
  def remote_addr=(addr); end
  def request_method=(method); end
  def request_uri=(uri); end
  def user_agent=(user_agent); end

  class << self
    def create(env = T.unsafe(nil)); end

    private

    def default_env; end
  end
end

ActionDispatch::TestRequest::DEFAULT_ENV = T.let(T.unsafe(nil), Hash)

class ActionDispatch::TestResponse < ::ActionDispatch::Response
  def parsed_body; end
  def response_parser; end

  class << self
    def from_response(response); end
  end
end

class ActionDispatch::FileHandler
  def initialize(root, index: T.unsafe(nil), headers: T.unsafe(nil), precompressed: T.unsafe(nil), compressible_content_types: T.unsafe(nil)); end

  def attempt(env); end
  def call(env); end

  private

  def clean_path(path_info); end
  def compressible?(content_type); end
  def each_candidate_filepath(path_info); end
  def each_precompressed_filepath(filepath); end
  def file_readable?(path); end
  def find_file(path_info, accept_encoding:); end
  def serve(request, filepath, content_headers); end
  def try_files(filepath, content_type, accept_encoding:); end
  def try_precompressed_files(filepath, headers, accept_encoding:); end
end

ActionDispatch::FileHandler::PRECOMPRESSED = T.let(T.unsafe(nil), Hash)

module ActionDispatch::Http::FilterRedirect
  def filtered_location; end

  private

  def location_filter_match?; end
  def location_filters; end
end

ActionDispatch::Http::FilterRedirect::FILTERED = T.let(T.unsafe(nil), String)

module ActionDispatch::Integration
end

module ActionDispatch::Integration::RequestHelpers
  def delete(path, **args); end
  def follow_redirect!(**args); end
  def get(path, **args); end
  def head(path, **args); end
  def options(path, **args); end
  def patch(path, **args); end
  def post(path, **args); end
  def put(path, **args); end
end

module ActionDispatch::Integration::Runner
  include(::Rails::Dom::Testing::Assertions::DomAssertions)
  include(::Rails::Dom::Testing::Assertions::SelectorAssertions::CountDescribable)
  include(::Rails::Dom::Testing::Assertions::SelectorAssertions)
  include(::Rails::Dom::Testing::Assertions)
  include(::ActionDispatch::Assertions::ResponseAssertions)
  include(::ActionDispatch::Assertions::RoutingAssertions)
  include(::ActionDispatch::Assertions)

  def initialize(*args, &blk); end

  def app; end
  def assertions; end
  def assertions=(assertions); end
  def assigns(*_arg0, &_arg1); end
  def before_setup; end
  def cookies(*_arg0, &_arg1); end
  def copy_session_variables!; end
  def create_session(app); end
  def default_url_options; end
  def default_url_options=(options); end
  def delete(*_arg0, &_arg1); end
  def follow_redirect!(*_arg0, &_arg1); end
  def get(*_arg0, &_arg1); end
  def head(*_arg0, &_arg1); end
  def integration_session; end
  def open_session; end
  def patch(*_arg0, &_arg1); end
  def post(*_arg0, &_arg1); end
  def put(*_arg0, &_arg1); end
  def remove!; end
  def reset!; end
  def root_session; end
  def root_session=(_arg0); end

  private

  def method_missing(method, *args, &block); end
  def respond_to_missing?(method, _); end
end

ActionDispatch::Integration::Runner::APP_SESSIONS = T.let(T.unsafe(nil), Hash)

class ActionDispatch::Integration::Session
  include(::Minitest::Assertions)
  include(::Rails::Dom::Testing::Assertions::DomAssertions)
  include(::Rails::Dom::Testing::Assertions::SelectorAssertions::CountDescribable)
  include(::Rails::Dom::Testing::Assertions::SelectorAssertions)
  include(::Rails::Dom::Testing::Assertions)
  include(::ActionDispatch::Assertions::ResponseAssertions)
  include(::ActionDispatch::Assertions::RoutingAssertions)
  include(::ActionDispatch::Assertions)
  include(::ActionDispatch::Integration::RequestHelpers)
  include(::ActionDispatch::TestProcess::FixtureFile)
  include(::ActionDispatch::TestProcess)
  include(::ActionDispatch::Routing::PolymorphicRoutes)
  include(::ActionDispatch::Routing::UrlFor)

  def initialize(app); end

  def accept; end
  def accept=(_arg0); end
  def body(*_arg0, &_arg1); end
  def controller; end
  def cookies; end
  def default_url_options; end
  def default_url_options=(_arg0); end
  def default_url_options?; end
  def headers(*_arg0, &_arg1); end
  def host; end
  def host!(_arg0); end
  def host=(_arg0); end
  def https!(flag = T.unsafe(nil)); end
  def https?; end
  def path(*_arg0, &_arg1); end
  def process(method, path, params: T.unsafe(nil), headers: T.unsafe(nil), env: T.unsafe(nil), xhr: T.unsafe(nil), as: T.unsafe(nil)); end
  def redirect?(*_arg0, &_arg1); end
  def remote_addr; end
  def remote_addr=(_arg0); end
  def request; end
  def request_count; end
  def request_count=(_arg0); end
  def reset!; end
  def response; end
  def status(*_arg0, &_arg1); end
  def status_message(*_arg0, &_arg1); end
  def url_options; end

  private

  def _mock_session; end
  def build_expanded_path(path); end
  def build_full_uri(path, env); end

  class << self
    def default_url_options; end
    def default_url_options=(value); end
    def default_url_options?; end
  end
end

ActionDispatch::Integration::Session::DEFAULT_HOST = T.let(T.unsafe(nil), String)

module ActionDispatch::IntegrationTest::Behavior::ClassMethods
  def app; end
  def app=(app); end
  def register_encoder(*args, **options); end
end

class ActionDispatch::RequestEncoder
  def initialize(mime_name, param_encoder, response_parser); end

  def accept_header; end
  def content_type; end
  def encode_params(params); end
  def response_parser; end

  class << self
    def encoder(name); end
    def parser(content_type); end
    def register_encoder(mime_name, param_encoder: T.unsafe(nil), response_parser: T.unsafe(nil)); end
  end
end

class ActionDispatch::RequestEncoder::IdentityEncoder
  def accept_header; end
  def content_type; end
  def encode_params(params); end
  def response_parser; end
end

class ActionDispatch::Routing::Endpoint
  def app; end
  def dispatcher?; end
  def engine?; end
  def matches?(req); end
  def rack_app; end
  def redirect?; end
end

class ActionDispatch::Routing::OptionRedirect < ::ActionDispatch::Routing::Redirect
  def inspect; end
  def options; end
  def path(params, request); end
end

class ActionDispatch::Routing::PathRedirect < ::ActionDispatch::Routing::Redirect
  def inspect; end
  def path(params, request); end

  private

  def interpolation_required?(string, params); end
end

ActionDispatch::Routing::PathRedirect::URL_PARTS = T.let(T.unsafe(nil), Regexp)

class ActionDispatch::Routing::Redirect < ::ActionDispatch::Routing::Endpoint
  def initialize(status, block); end

  def block; end
  def call(env); end
  def inspect; end
  def path(params, request); end
  def redirect?; end
  def serve(req); end
  def status; end

  private

  def escape(params); end
  def escape_fragment(params); end
  def escape_path(params); end
  def relative_path?(path); end
end

module ActionDispatch::Routing::Redirection
  def redirect(*args, &block); end
end

module ActionDispatch::Session::Compatibility
  def initialize(app, options = T.unsafe(nil)); end

  def generate_sid; end

  private

  def initialize_sid; end
  def make_request(env); end
end

module ActionDispatch::Session::SessionObject
  def loaded_session?(session); end
  def prepare_session(req); end
end

class ActionDispatch::Session::SessionRestoreError < ::StandardError
  def initialize; end
end

module ActionDispatch::Session::StaleSessionCheck
  def extract_session_id(env); end
  def load_session(env); end
  def stale_session_check!; end
end

module ActionDispatch::SystemTesting
end

class ActionDispatch::SystemTesting::Browser
  def initialize(name); end

  def configure; end
  def name; end
  def options; end
  def preload; end
  def type; end

  private

  def initialize_options; end
  def set_default_options; end
  def set_headless_chrome_browser_options; end
  def set_headless_firefox_browser_options; end
end

class ActionDispatch::SystemTesting::Driver
  def initialize(name, **options, &capabilities); end

  def use; end

  private

  def browser_options; end
  def register; end
  def register_poltergeist(app); end
  def register_selenium(app); end
  def register_webkit(app); end
  def registerable?; end
  def setup; end
end

class ActionDispatch::SystemTesting::Server
  def run; end

  private

  def set_port; end
  def set_server; end
  def setup; end

  class << self
    def silence_puma; end
    def silence_puma=(_arg0); end
  end
end

module ActionDispatch::SystemTesting::TestHelpers
end

module ActionDispatch::SystemTesting::TestHelpers::ScreenshotHelper
  def take_failed_screenshot; end
  def take_screenshot; end

  private

  def _screenshot_counter; end
  def _screenshot_counter=(_arg0); end
  def absolute_html_path; end
  def absolute_image_path; end
  def absolute_path; end
  def display_image; end
  def failed?; end
  def html_path; end
  def image_name; end
  def image_path; end
  def increment_unique; end
  def inline_base64(path); end
  def output_type; end
  def save_html; end
  def save_html?; end
  def save_image; end
  def supports_screenshot?; end
  def unique; end
end

module ActionDispatch::SystemTesting::TestHelpers::SetupAndTeardown
  def after_teardown; end
  def before_teardown; end
  def host!(host); end
end

module ActionPack
  class << self
    def gem_version; end
    def version; end
  end
end

module ActionPack::VERSION
end

ActionPack::VERSION::MAJOR = T.let(T.unsafe(nil), Integer)

ActionPack::VERSION::MINOR = T.let(T.unsafe(nil), Integer)

ActionPack::VERSION::PRE = T.let(T.unsafe(nil), String)

ActionPack::VERSION::STRING = T.let(T.unsafe(nil), String)

ActionPack::VERSION::TINY = T.let(T.unsafe(nil), Integer)

module Mime
  class << self
    def [](type); end
    def fetch(type); end
  end
end

Mime::ALL = T.let(T.unsafe(nil), Mime::AllType)

class Mime::AllType < ::Mime::Type
  include(::Singleton)
  extend(::Singleton::SingletonClassMethods)

  def initialize; end

  def all?; end
  def html?; end
end

Mime::EXTENSION_LOOKUP = T.let(T.unsafe(nil), Hash)

Mime::LOOKUP = T.let(T.unsafe(nil), Hash)

class Mime::Mimes
  include(::Enumerable)

  def initialize; end

  def <<(type); end
  def delete_if; end
  def each; end
  def symbols; end
end

class Mime::NullType
  include(::Singleton)
  extend(::Singleton::SingletonClassMethods)

  def nil?; end
  def ref; end
  def to_s; end

  private

  def method_missing(method, *args); end
  def respond_to_missing?(method, _); end
end

Mime::SET = T.let(T.unsafe(nil), Mime::Mimes)

class Mime::Type
  def initialize(string, symbol = T.unsafe(nil), synonyms = T.unsafe(nil)); end

  def ==(mime_type); end
  def ===(list); end
  def =~(mime_type); end
  def all?; end
  def eql?(other); end
  def hash; end
  def html?; end
  def match?(mime_type); end
  def ref; end
  def symbol; end
  def to_s; end
  def to_str; end
  def to_sym; end

  protected

  def string; end
  def synonyms; end

  private

  def method_missing(method, *args); end
  def respond_to_missing?(method, include_private = T.unsafe(nil)); end
  def to_a; end
  def to_ary; end

  class << self
    def lookup(string); end
    def lookup_by_extension(extension); end
    def parse(accept_header); end
    def parse_data_with_trailing_star(type); end
    def parse_trailing_star(accept_header); end
    def register(string, symbol, mime_type_synonyms = T.unsafe(nil), extension_synonyms = T.unsafe(nil), skip_lookup = T.unsafe(nil)); end
    def register_alias(string, symbol, extension_synonyms = T.unsafe(nil)); end
    def register_callback(&block); end
    def unregister(symbol); end
  end
end

class Mime::Type::AcceptItem
  def initialize(index, name, q = T.unsafe(nil)); end

  def <=>(item); end
  def index; end
  def index=(_arg0); end
  def name; end
  def name=(_arg0); end
  def q; end
  def q=(_arg0); end
  def to_s; end
end

class Mime::Type::AcceptList
  class << self
    def find_item_by_name(array, name); end
    def sort!(list); end
  end
end

class Mime::Type::InvalidMimeType < ::StandardError
end

Mime::Type::MIME_NAME = T.let(T.unsafe(nil), String)

Mime::Type::MIME_PARAMETER = T.let(T.unsafe(nil), String)

Mime::Type::MIME_PARAMETER_KEY = T.let(T.unsafe(nil), String)

Mime::Type::MIME_PARAMETER_VALUE = T.let(T.unsafe(nil), String)

Mime::Type::MIME_REGEXP = T.let(T.unsafe(nil), Regexp)

module Rack
  class << self
    def release; end
    def version; end
  end
end

Rack::CACHE_CONTROL = T.let(T.unsafe(nil), String)

Rack::CONTENT_LENGTH = T.let(T.unsafe(nil), String)

Rack::CONTENT_TYPE = T.let(T.unsafe(nil), String)

Rack::DELETE = T.let(T.unsafe(nil), String)

Rack::ETAG = T.let(T.unsafe(nil), String)

Rack::EXPIRES = T.let(T.unsafe(nil), String)

Rack::File = Rack::Files

Rack::GET = T.let(T.unsafe(nil), String)

Rack::HEAD = T.let(T.unsafe(nil), String)

Rack::HTTPS = T.let(T.unsafe(nil), String)

Rack::HTTP_COOKIE = T.let(T.unsafe(nil), String)

Rack::HTTP_HOST = T.let(T.unsafe(nil), String)

Rack::HTTP_PORT = T.let(T.unsafe(nil), String)

Rack::HTTP_VERSION = T.let(T.unsafe(nil), String)

Rack::LINK = T.let(T.unsafe(nil), String)

Rack::OPTIONS = T.let(T.unsafe(nil), String)

Rack::PATCH = T.let(T.unsafe(nil), String)

Rack::PATH_INFO = T.let(T.unsafe(nil), String)

Rack::POST = T.let(T.unsafe(nil), String)

Rack::PUT = T.let(T.unsafe(nil), String)

Rack::QUERY_STRING = T.let(T.unsafe(nil), String)

Rack::RACK_ERRORS = T.let(T.unsafe(nil), String)

Rack::RACK_HIJACK = T.let(T.unsafe(nil), String)

Rack::RACK_HIJACK_IO = T.let(T.unsafe(nil), String)

Rack::RACK_INPUT = T.let(T.unsafe(nil), String)

Rack::RACK_IS_HIJACK = T.let(T.unsafe(nil), String)

Rack::RACK_LOGGER = T.let(T.unsafe(nil), String)

Rack::RACK_METHODOVERRIDE_ORIGINAL_METHOD = T.let(T.unsafe(nil), String)

Rack::RACK_MULTIPART_BUFFER_SIZE = T.let(T.unsafe(nil), String)

Rack::RACK_MULTIPART_TEMPFILE_FACTORY = T.let(T.unsafe(nil), String)

Rack::RACK_MULTIPROCESS = T.let(T.unsafe(nil), String)

Rack::RACK_MULTITHREAD = T.let(T.unsafe(nil), String)

Rack::RACK_RECURSIVE_INCLUDE = T.let(T.unsafe(nil), String)

Rack::RACK_REQUEST_COOKIE_HASH = T.let(T.unsafe(nil), String)

Rack::RACK_REQUEST_COOKIE_STRING = T.let(T.unsafe(nil), String)

Rack::RACK_REQUEST_FORM_HASH = T.let(T.unsafe(nil), String)

Rack::RACK_REQUEST_FORM_INPUT = T.let(T.unsafe(nil), String)

Rack::RACK_REQUEST_FORM_VARS = T.let(T.unsafe(nil), String)

Rack::RACK_REQUEST_QUERY_HASH = T.let(T.unsafe(nil), String)

Rack::RACK_REQUEST_QUERY_STRING = T.let(T.unsafe(nil), String)

Rack::RACK_RUNONCE = T.let(T.unsafe(nil), String)

Rack::RACK_SESSION = T.let(T.unsafe(nil), String)

Rack::RACK_SESSION_OPTIONS = T.let(T.unsafe(nil), String)

Rack::RACK_SESSION_UNPACKED_COOKIE_DATA = T.let(T.unsafe(nil), String)

Rack::RACK_SHOWSTATUS_DETAIL = T.let(T.unsafe(nil), String)

Rack::RACK_TEMPFILES = T.let(T.unsafe(nil), String)

Rack::RACK_URL_SCHEME = T.let(T.unsafe(nil), String)

Rack::RACK_VERSION = T.let(T.unsafe(nil), String)

Rack::RELEASE = T.let(T.unsafe(nil), String)

Rack::REQUEST_METHOD = T.let(T.unsafe(nil), String)

Rack::REQUEST_PATH = T.let(T.unsafe(nil), String)

Rack::SCRIPT_NAME = T.let(T.unsafe(nil), String)

Rack::SERVER_NAME = T.let(T.unsafe(nil), String)

Rack::SERVER_PORT = T.let(T.unsafe(nil), String)

Rack::SERVER_PROTOCOL = T.let(T.unsafe(nil), String)

Rack::SET_COOKIE = T.let(T.unsafe(nil), String)

Rack::TRACE = T.let(T.unsafe(nil), String)

Rack::TRANSFER_ENCODING = T.let(T.unsafe(nil), String)

Rack::UNLINK = T.let(T.unsafe(nil), String)

Rack::VERSION = T.let(T.unsafe(nil), Array)
