# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `rack` gem.
# Please instead update this file by running `bin/tapioca gem rack`.


# source://rack//lib/rack/version.rb#8
module Rack
  class << self
    # Return the Rack release as a dotted string.
    #
    # source://rack//lib/rack/version.rb#14
    def release; end
  end
end

# source://rack//lib/rack.rb#59
module Rack::Auth; end

# Rack::Auth::AbstractHandler implements common authentication functionality.
#
# +realm+ should be set for all handlers.
#
# source://rack//lib/rack/auth/abstract/handler.rb#11
class Rack::Auth::AbstractHandler
  # @return [AbstractHandler] a new instance of AbstractHandler
  #
  # source://rack//lib/rack/auth/abstract/handler.rb#15
  def initialize(app, realm = T.unsafe(nil), &authenticator); end

  # Returns the value of attribute realm.
  #
  # source://rack//lib/rack/auth/abstract/handler.rb#13
  def realm; end

  # Sets the attribute realm
  #
  # @param value the value to set the attribute realm to.
  #
  # source://rack//lib/rack/auth/abstract/handler.rb#13
  def realm=(_arg0); end

  private

  # source://rack//lib/rack/auth/abstract/handler.rb#31
  def bad_request; end

  # source://rack//lib/rack/auth/abstract/handler.rb#22
  def unauthorized(www_authenticate = T.unsafe(nil)); end
end

# source://rack//lib/rack/auth/abstract/request.rb#8
class Rack::Auth::AbstractRequest
  # @return [AbstractRequest] a new instance of AbstractRequest
  #
  # source://rack//lib/rack/auth/abstract/request.rb#10
  def initialize(env); end

  # source://rack//lib/rack/auth/abstract/request.rb#35
  def params; end

  # source://rack//lib/rack/auth/abstract/request.rb#27
  def parts; end

  # @return [Boolean]
  #
  # source://rack//lib/rack/auth/abstract/request.rb#19
  def provided?; end

  # source://rack//lib/rack/auth/abstract/request.rb#14
  def request; end

  # source://rack//lib/rack/auth/abstract/request.rb#31
  def scheme; end

  # @return [Boolean]
  #
  # source://rack//lib/rack/auth/abstract/request.rb#23
  def valid?; end

  private

  # source://rack//lib/rack/auth/abstract/request.rb#44
  def authorization_key; end
end

# source://rack//lib/rack/auth/abstract/request.rb#42
Rack::Auth::AbstractRequest::AUTHORIZATION_KEYS = T.let(T.unsafe(nil), Array)

# Rack::Auth::Basic implements HTTP Basic Authentication, as per RFC 2617.
#
# Initialize with the Rack application that you want protecting,
# and a block that checks if a username and password pair are valid.
#
# source://rack//lib/rack/auth/basic.rb#13
class Rack::Auth::Basic < ::Rack::Auth::AbstractHandler
  # source://rack//lib/rack/auth/basic.rb#15
  def call(env); end

  private

  # source://rack//lib/rack/auth/basic.rb#34
  def challenge; end

  # @return [Boolean]
  #
  # source://rack//lib/rack/auth/basic.rb#38
  def valid?(auth); end
end

# source://rack//lib/rack/auth/basic.rb#42
class Rack::Auth::Basic::Request < ::Rack::Auth::AbstractRequest
  # @return [Boolean]
  #
  # source://rack//lib/rack/auth/basic.rb#43
  def basic?; end

  # source://rack//lib/rack/auth/basic.rb#47
  def credentials; end

  # source://rack//lib/rack/auth/basic.rb#51
  def username; end
end

# source://rack//lib/rack/builder.rb#6
Rack::BUILDER_TOPLEVEL_BINDING = T.let(T.unsafe(nil), Proc)

# Represents a 400 Bad Request error when input data fails to meet the
# requirements.
#
# source://rack//lib/rack/bad_request.rb#6
module Rack::BadRequest; end

# Proxy for response bodies allowing calling a block when
# the response body is closed (after the response has been fully
# sent to the client).
#
# source://rack//lib/rack/body_proxy.rb#7
class Rack::BodyProxy
  # Set the response body to wrap, and the block to call when the
  # response has been fully sent.
  #
  # @return [BodyProxy] a new instance of BodyProxy
  #
  # source://rack//lib/rack/body_proxy.rb#10
  def initialize(body, &block); end

  # If not already closed, close the wrapped body and
  # then call the block the proxy was initialized with.
  #
  # source://rack//lib/rack/body_proxy.rb#28
  def close; end

  # Whether the proxy is closed.  The proxy starts as not closed,
  # and becomes closed on the first call to close.
  #
  # @return [Boolean]
  #
  # source://rack//lib/rack/body_proxy.rb#40
  def closed?; end

  # Delegate missing methods to the wrapped body.
  #
  # source://rack//lib/rack/body_proxy.rb#45
  def method_missing(method_name, *args, **_arg2, &block); end

  private

  # Return whether the wrapped body responds to the method.
  #
  # @return [Boolean]
  #
  # source://rack//lib/rack/body_proxy.rb#17
  def respond_to_missing?(method_name, include_all = T.unsafe(nil)); end
end

# Rack::Builder provides a domain-specific language (DSL) to construct Rack
# applications. It is primarily used to parse +config.ru+ files which
# instantiate several middleware and a final application which are hosted
# by a Rack-compatible web server.
#
# Example:
#
#   app = Rack::Builder.new do
#     use Rack::CommonLogger
#     map "/ok" do
#       run lambda { |env| [200, {'content-type' => 'text/plain'}, ['OK']] }
#     end
#   end
#
#   run app
#
# Or
#
#   app = Rack::Builder.app do
#     use Rack::CommonLogger
#     run lambda { |env| [200, {'content-type' => 'text/plain'}, ['OK']] }
#   end
#
#   run app
#
# +use+ adds middleware to the stack, +run+ dispatches to an application.
# You can use +map+ to construct a Rack::URLMap in a convenient way.
#
# source://rack//lib/rack/builder.rb#36
class Rack::Builder
  # Initialize a new Rack::Builder instance.  +default_app+ specifies the
  # default application if +run+ is not called later.  If a block
  # is given, it is evaluated in the context of the instance.
  #
  # @return [Builder] a new instance of Builder
  #
  # source://rack//lib/rack/builder.rb#116
  def initialize(default_app = T.unsafe(nil), **options, &block); end

  # Call the Rack application generated by this builder instance. Note that
  # this rebuilds the Rack application and runs the warmup code (if any)
  # every time it is called, so it should not be used if performance is important.
  #
  # source://rack//lib/rack/builder.rb#282
  def call(env); end

  # Freeze the app (set using run) and all middleware instances when building the application
  # in to_app.
  #
  # source://rack//lib/rack/builder.rb#265
  def freeze_app; end

  # Creates a route within the application.  Routes under the mapped path will be sent to
  # the Rack application specified by run inside the block.  Other requests will be sent to the
  # default application specified by run outside the block.
  #
  #   class App
  #     def call(env)
  #       [200, {'content-type' => 'text/plain'}, ["Hello World"]]
  #     end
  #   end
  #
  #   class Heartbeat
  #     def call(env)
  #       [200, { "content-type" => "text/plain" }, ["OK"]]
  #     end
  #   end
  #
  #   app = Rack::Builder.app do
  #     map '/heartbeat' do
  #       run Heartbeat.new
  #     end
  #     run App.new
  #   end
  #
  #   run app
  #
  # The +use+ method can also be used inside the block to specify middleware to run under a specific path:
  #
  #   app = Rack::Builder.app do
  #     map '/heartbeat' do
  #       use Middleware
  #       run Heartbeat.new
  #     end
  #     run App.new
  #   end
  #
  # This example includes a piece of middleware which will run before +/heartbeat+ requests hit +Heartbeat+.
  #
  # Note that providing a +path+ of +/+ will ignore any default application given in a +run+ statement
  # outside the block.
  #
  # source://rack//lib/rack/builder.rb#256
  def map(path, &block); end

  # Any options provided to the Rack::Builder instance at initialization.
  # These options can be server-specific. Some general options are:
  #
  # * +:isolation+: One of +process+, +thread+ or +fiber+. The execution
  #   isolation model to use.
  #
  # source://rack//lib/rack/builder.rb#132
  def options; end

  # Takes a block or argument that is an object that responds to #call and
  # returns a Rack response.
  #
  # You can use a block:
  #
  #   run do |env|
  #     [200, { "content-type" => "text/plain" }, ["Hello World!"]]
  #   end
  #
  # You can also provide a lambda:
  #
  #   run lambda { |env| [200, { "content-type" => "text/plain" }, ["OK"]] }
  #
  # You can also provide a class instance:
  #
  #   class Heartbeat
  #     def call(env)
  #      [200, { "content-type" => "text/plain" }, ["OK"]]
  #     end
  #   end
  #
  #   run Heartbeat.new
  #
  # @raise [ArgumentError]
  #
  # source://rack//lib/rack/builder.rb#195
  def run(app = T.unsafe(nil), &block); end

  # Return the Rack application generated by this instance.
  #
  # source://rack//lib/rack/builder.rb#270
  def to_app; end

  # Specifies middleware to use in a stack.
  #
  #   class Middleware
  #     def initialize(app)
  #       @app = app
  #     end
  #
  #     def call(env)
  #       env["rack.some_header"] = "setting an example"
  #       @app.call(env)
  #     end
  #   end
  #
  #   use Middleware
  #   run lambda { |env| [200, { "content-type" => "text/plain" }, ["OK"]] }
  #
  # All requests through to this application will first be processed by the middleware class.
  # The +call+ method in this example sets an additional environment key which then can be
  # referenced in the application if required.
  #
  # source://rack//lib/rack/builder.rb#159
  def use(middleware, *args, **_arg2, &block); end

  # Takes a lambda or block that is used to warm-up the application. This block is called
  # before the Rack application is returned by to_app.
  #
  #   warmup do |app|
  #     client = Rack::MockRequest.new(app)
  #     client.get('/')
  #   end
  #
  #   use SomeMiddleware
  #   run MyApp
  #
  # source://rack//lib/rack/builder.rb#213
  def warmup(prc = T.unsafe(nil), &block); end

  private

  # Generate a URLMap instance by generating new Rack applications for each
  # map block in this instance.
  #
  # source://rack//lib/rack/builder.rb#290
  def generate_map(default_app, mapping); end

  class << self
    # Create a new Rack::Builder instance and return the Rack application
    # generated from it.
    #
    # source://rack//lib/rack/builder.rb#136
    def app(default_app = T.unsafe(nil), &block); end

    # Load the given file as a rackup file, treating the
    # contents as if specified inside a Rack::Builder block.
    #
    # Ignores content in the file after +__END__+, so that
    # use of +__END__+ will not result in a syntax error.
    #
    # Example config.ru file:
    #
    #   $ cat config.ru
    #
    #   use Rack::ContentLength
    #   require './app.rb'
    #   run App
    #
    # source://rack//lib/rack/builder.rb#87
    def load_file(path, **options); end

    # Evaluate the given +builder_script+ string in the context of
    # a Rack::Builder block, returning a Rack application.
    #
    # source://rack//lib/rack/builder.rb#102
    def new_from_string(builder_script, path = T.unsafe(nil), **options); end

    # Parse the given config file to get a Rack application.
    #
    # If the config file ends in +.ru+, it is treated as a
    # rackup file and the contents will be treated as if
    # specified inside a Rack::Builder block.
    #
    # If the config file does not end in +.ru+, it is
    # required and Rack will use the basename of the file
    # to guess which constant will be the Rack application to run.
    #
    # Examples:
    #
    #   Rack::Builder.parse_file('config.ru')
    #   # Rack application built using Rack::Builder.new
    #
    #   Rack::Builder.parse_file('app.rb')
    #   # requires app.rb, which can be anywhere in Ruby's
    #   # load path. After requiring, assumes App constant
    #   # is a Rack application
    #
    #   Rack::Builder.parse_file('./my_app.rb')
    #   # requires ./my_app.rb, which should be in the
    #   # process's current directory.  After requiring,
    #   # assumes MyApp constant is a Rack application
    #
    # source://rack//lib/rack/builder.rb#65
    def parse_file(path, **options); end
  end
end

# https://stackoverflow.com/questions/2223882/whats-the-difference-between-utf-8-and-utf-8-without-bom
#
# source://rack//lib/rack/builder.rb#39
Rack::Builder::UTF_8_BOM = T.let(T.unsafe(nil), String)

# Response Header Keys
#
# source://rack//lib/rack/constants.rb#19
Rack::CACHE_CONTROL = T.let(T.unsafe(nil), String)

# source://rack//lib/rack/constants.rb#35
Rack::CONNECT = T.let(T.unsafe(nil), String)

# source://rack//lib/rack/constants.rb#20
Rack::CONTENT_LENGTH = T.let(T.unsafe(nil), String)

# source://rack//lib/rack/constants.rb#21
Rack::CONTENT_TYPE = T.let(T.unsafe(nil), String)

# Rack::Cascade tries a request on several apps, and returns the
# first response that is not 404 or 405 (or in a list of configured
# status codes).  If all applications tried return one of the configured
# status codes, return the last response.
#
# source://rack//lib/rack/cascade.rb#11
class Rack::Cascade
  # Set the apps to send requests to, and what statuses result in
  # cascading.  Arguments:
  #
  # apps: An enumerable of rack applications.
  # cascade_for: The statuses to use cascading for.  If a response is received
  #              from an app, the next app is tried.
  #
  # @return [Cascade] a new instance of Cascade
  #
  # source://rack//lib/rack/cascade.rb#21
  def initialize(apps, cascade_for = T.unsafe(nil)); end

  # Append an app to the list of apps to cascade.  This app will
  # be tried last.
  #
  # source://rack//lib/rack/cascade.rb#65
  def <<(app); end

  # Append an app to the list of apps to cascade.  This app will
  # be tried last.
  #
  # source://rack//lib/rack/cascade.rb#56
  def add(app); end

  # An array of applications to try in order.
  #
  # source://rack//lib/rack/cascade.rb#13
  def apps; end

  # Call each app in order.  If the responses uses a status that requires
  # cascading, try the next app.  If all responses require cascading,
  # return the response from the last app.
  #
  # source://rack//lib/rack/cascade.rb#32
  def call(env); end

  # Whether the given app is one of the apps to cascade to.
  #
  # @return [Boolean]
  #
  # source://rack//lib/rack/cascade.rb#61
  def include?(app); end
end

# Rack::CommonLogger forwards every request to the given +app+, and
# logs a line in the
# {Apache common log format}[http://httpd.apache.org/docs/1.3/logs.html#common]
# to the configured logger.
#
# source://rack//lib/rack/common_logger.rb#13
class Rack::CommonLogger
  # +logger+ can be any object that supports the +write+ or +<<+ methods,
  # which includes the standard library Logger.  These methods are called
  # with a single string argument, the log message.
  # If +logger+ is nil, CommonLogger will fall back <tt>env['rack.errors']</tt>.
  #
  # @return [CommonLogger] a new instance of CommonLogger
  #
  # source://rack//lib/rack/common_logger.rb#29
  def initialize(app, logger = T.unsafe(nil)); end

  # Log all requests in common_log format after a response has been
  # returned.  Note that if the app raises an exception, the request
  # will not be logged, so if exception handling middleware are used,
  # they should be loaded after this middleware.  Additionally, because
  # the logging happens after the request body has been fully sent, any
  # exceptions raised during the sending of the response body will
  # cause the request not to be logged.
  #
  # source://rack//lib/rack/common_logger.rb#41
  def call(env); end

  private

  # Attempt to determine the content length for the response to
  # include it in the logged data.
  #
  # source://rack//lib/rack/common_logger.rb#84
  def extract_content_length(headers); end

  # Log the request to the configured logger.
  #
  # source://rack//lib/rack/common_logger.rb#52
  def log(env, status, response_headers, began_at); end
end

# Common Log Format: http://httpd.apache.org/docs/1.3/logs.html#common
#
#   lilith.local - - [07/Aug/2006 23:58:02 -0400] "GET / HTTP/1.1" 500 -
#
#   %{%s - %s [%s] "%s %s%s %s" %d %s\n} %
#
# The actual format is slightly different than the above due to the
# separation of SCRIPT_NAME and PATH_INFO, and because the elapsed
# time in seconds is included at the end.
#
# source://rack//lib/rack/common_logger.rb#23
Rack::CommonLogger::FORMAT = T.let(T.unsafe(nil), String)

# Middleware that enables conditional GET using if-none-match and
# if-modified-since. The application should set either or both of the
# last-modified or etag response headers according to RFC 2616. When
# either of the conditions is met, the response body is set to be zero
# length and the response status is set to 304 Not Modified.
#
# Applications that defer response body generation until the body's each
# message is received will avoid response body generation completely when
# a conditional GET matches.
#
# Adapted from Michael Klishin's Merb implementation:
# https://github.com/wycats/merb/blob/master/merb-core/lib/merb-core/rack/middleware/conditional_get.rb
#
# source://rack//lib/rack/conditional_get.rb#21
class Rack::ConditionalGet
  # @return [ConditionalGet] a new instance of ConditionalGet
  #
  # source://rack//lib/rack/conditional_get.rb#22
  def initialize(app); end

  # Return empty 304 response if the response has not been
  # modified since the last request.
  #
  # source://rack//lib/rack/conditional_get.rb#28
  def call(env); end

  private

  # Whether the etag response header matches the if-none-match request header.
  # If so, the request has not been modified.
  #
  # @return [Boolean]
  #
  # source://rack//lib/rack/conditional_get.rb#63
  def etag_matches?(none_match, headers); end

  # Return whether the response has not been modified since the
  # last request.
  #
  # @return [Boolean]
  #
  # source://rack//lib/rack/conditional_get.rb#52
  def fresh?(env, headers); end

  # Whether the last-modified response header matches the if-modified-since
  # request header.  If so, the request has not been modified.
  #
  # @return [Boolean]
  #
  # source://rack//lib/rack/conditional_get.rb#69
  def modified_since?(modified_since, headers); end

  # Return a Time object for the given string (which should be in RFC2822
  # format), or nil if the string cannot be parsed.
  #
  # source://rack//lib/rack/conditional_get.rb#76
  def to_rfc2822(since); end
end

# Rack::Config modifies the environment using the block given during
# initialization.
#
# Example:
#     use Rack::Config do |env|
#       env['my-key'] = 'some-value'
#     end
#
# source://rack//lib/rack/config.rb#11
class Rack::Config
  # @return [Config] a new instance of Config
  #
  # source://rack//lib/rack/config.rb#12
  def initialize(app, &block); end

  # source://rack//lib/rack/config.rb#17
  def call(env); end
end

# Sets the content-length header on responses that do not specify
# a content-length or transfer-encoding header.  Note that this
# does not fix responses that have an invalid content-length
# header specified.
#
# source://rack//lib/rack/content_length.rb#12
class Rack::ContentLength
  include ::Rack::Utils

  # @return [ContentLength] a new instance of ContentLength
  #
  # source://rack//lib/rack/content_length.rb#15
  def initialize(app); end

  # source://rack//lib/rack/content_length.rb#19
  def call(env); end
end

# Sets the content-type header on responses which don't have one.
#
# Builder Usage:
#   use Rack::ContentType, "text/plain"
#
# When no content type argument is provided, "text/html" is the
# default.
#
# source://rack//lib/rack/content_type.rb#15
class Rack::ContentType
  include ::Rack::Utils

  # @return [ContentType] a new instance of ContentType
  #
  # source://rack//lib/rack/content_type.rb#18
  def initialize(app, content_type = T.unsafe(nil)); end

  # source://rack//lib/rack/content_type.rb#23
  def call(env); end
end

# source://rack//lib/rack/constants.rb#32
Rack::DELETE = T.let(T.unsafe(nil), String)

# This middleware enables content encoding of http responses,
# usually for purposes of compression.
#
# Currently supported encodings:
#
# * gzip
# * identity (no transformation)
#
# This middleware automatically detects when encoding is supported
# and allowed. For example no encoding is made when a cache
# directive of 'no-transform' is present, when the response status
# code is one that doesn't allow an entity body, or when the body
# is empty.
#
# Note that despite the name, Deflater does not support the +deflate+
# encoding.
#
# source://rack//lib/rack/deflater.rb#28
class Rack::Deflater
  # Creates Rack::Deflater middleware. Options:
  #
  # :if :: a lambda enabling / disabling deflation based on returned boolean value
  #        (e.g <tt>use Rack::Deflater, :if => lambda { |*, body| sum=0; body.each { |i| sum += i.length }; sum > 512 }</tt>).
  #        However, be aware that calling `body.each` inside the block will break cases where `body.each` is not idempotent,
  #        such as when it is an +IO+ instance.
  # :include :: a list of content types that should be compressed. By default, all content types are compressed.
  # :sync :: determines if the stream is going to be flushed after every chunk.  Flushing after every chunk reduces
  #          latency for time-sensitive streaming applications, but hurts compression and throughput.
  #          Defaults to +true+.
  #
  # @return [Deflater] a new instance of Deflater
  #
  # source://rack//lib/rack/deflater.rb#39
  def initialize(app, options = T.unsafe(nil)); end

  # source://rack//lib/rack/deflater.rb#46
  def call(env); end

  private

  # Whether the body should be compressed.
  #
  # @return [Boolean]
  #
  # source://rack//lib/rack/deflater.rb#136
  def should_deflate?(env, status, headers, body); end
end

# Body class used for gzip encoded responses.
#
# source://rack//lib/rack/deflater.rb#83
class Rack::Deflater::GzipStream
  # Initialize the gzip stream.  Arguments:
  # body :: Response body to compress with gzip
  # mtime :: The modification time of the body, used to set the
  #          modification time in the gzip header.
  # sync :: Whether to flush each gzip chunk as soon as it is ready.
  #
  # @return [GzipStream] a new instance of GzipStream
  #
  # source://rack//lib/rack/deflater.rb#92
  def initialize(body, mtime, sync); end

  # Close the original body if possible.
  #
  # source://rack//lib/rack/deflater.rb#128
  def close; end

  # Yield gzip compressed strings to the given block.
  #
  # source://rack//lib/rack/deflater.rb#99
  def each(&block); end

  # Call the block passed to #each with the gzipped data.
  #
  # source://rack//lib/rack/deflater.rb#123
  def write(data); end
end

# source://rack//lib/rack/deflater.rb#85
Rack::Deflater::GzipStream::BUFFER_LENGTH = T.let(T.unsafe(nil), Integer)

# Rack::Directory serves entries below the +root+ given, according to the
# path info of the Rack request. If a directory is found, the file's contents
# will be presented in an html based index. If a file is found, the env will
# be passed to the specified +app+.
#
# If +app+ is not specified, a Rack::Files of the same +root+ will be used.
#
# source://rack//lib/rack/directory.rb#19
class Rack::Directory
  # Set the root directory and application for serving files.
  #
  # @return [Directory] a new instance of Directory
  #
  # source://rack//lib/rack/directory.rb#83
  def initialize(root, app = T.unsafe(nil)); end

  # source://rack//lib/rack/directory.rb#89
  def call(env); end

  # Rack response to use for requests with invalid paths, or nil if path is valid.
  #
  # source://rack//lib/rack/directory.rb#109
  def check_bad_request(path_info); end

  # Rack response to use for requests with paths outside the root, or nil if path is inside the root.
  #
  # source://rack//lib/rack/directory.rb#119
  def check_forbidden(path_info); end

  # Rack response to use for unreadable and non-file, non-directory entries.
  #
  # source://rack//lib/rack/directory.rb#181
  def entity_not_found(path_info); end

  # Provide human readable file sizes
  #
  # source://rack//lib/rack/directory.rb#197
  def filesize_format(int); end

  # Internals of request handling.  Similar to call but does
  # not remove body for HEAD requests.
  #
  # source://rack//lib/rack/directory.rb#96
  def get(env); end

  # Rack response to use for directories under the root.
  #
  # source://rack//lib/rack/directory.rb#130
  def list_directory(path_info, path, script_name); end

  # Rack response to use for files and directories under the root.
  # Unreadable and non-file, non-directory entries will get a 404 response.
  #
  # source://rack//lib/rack/directory.rb#171
  def list_path(env, path, path_info, script_name); end

  # The root of the directory hierarchy.  Only requests for files and
  # directories inside of the root directory are supported.
  #
  # source://rack//lib/rack/directory.rb#80
  def root; end

  # File::Stat for the given path, but return nil for missing/bad entries.
  #
  # source://rack//lib/rack/directory.rb#163
  def stat(path); end
end

# source://rack//lib/rack/directory.rb#20
Rack::Directory::DIR_FILE = T.let(T.unsafe(nil), String)

# source://rack//lib/rack/directory.rb#43
Rack::Directory::DIR_PAGE_FOOTER = T.let(T.unsafe(nil), String)

# source://rack//lib/rack/directory.rb#21
Rack::Directory::DIR_PAGE_HEADER = T.let(T.unsafe(nil), String)

# Body class for directory entries, showing an index page with links
# to each file.
#
# source://rack//lib/rack/directory.rb#51
class Rack::Directory::DirectoryBody < ::Struct
  # Yield strings for each part of the directory entry
  #
  # @yield [DIR_PAGE_HEADER % [ show_path, show_path ]]
  #
  # source://rack//lib/rack/directory.rb#53
  def each; end

  private

  # Escape each element in the array of html strings.
  #
  # source://rack//lib/rack/directory.rb#73
  def DIR_FILE_escape(htmls); end
end

# Stolen from Ramaze
#
# source://rack//lib/rack/directory.rb#189
Rack::Directory::FILESIZE_FORMAT = T.let(T.unsafe(nil), Array)

# source://rack//lib/rack/constants.rb#22
Rack::ETAG = T.let(T.unsafe(nil), String)

# Automatically sets the etag header on all String bodies.
#
# The etag header is skipped if etag or last-modified headers are sent or if
# a sendfile body (body.responds_to :to_path) is given (since such cases
# should be handled by apache/nginx).
#
# On initialization, you can pass two parameters: a cache-control directive
# used when etag is absent and a directive when it is present. The first
# defaults to nil, while the second defaults to "max-age=0, private, must-revalidate"
#
# source://rack//lib/rack/etag.rb#18
class Rack::ETag
  # @return [ETag] a new instance of ETag
  #
  # source://rack//lib/rack/etag.rb#22
  def initialize(app, no_cache_control = T.unsafe(nil), cache_control = T.unsafe(nil)); end

  # source://rack//lib/rack/etag.rb#28
  def call(env); end

  private

  # source://rack//lib/rack/etag.rb#61
  def digest_body(body); end

  # @return [Boolean]
  #
  # source://rack//lib/rack/etag.rb#53
  def etag_status?(status); end

  # @return [Boolean]
  #
  # source://rack//lib/rack/etag.rb#57
  def skip_caching?(headers); end
end

# source://rack//lib/rack/etag.rb#20
Rack::ETag::DEFAULT_CACHE_CONTROL = T.let(T.unsafe(nil), String)

# source://rack//lib/rack/etag.rb#19
Rack::ETag::ETAG_STRING = T.let(T.unsafe(nil), String)

# source://rack//lib/rack/constants.rb#23
Rack::EXPIRES = T.let(T.unsafe(nil), String)

# This middleware provides hooks to certain places in the request /
# response lifecycle.  This is so that middleware that don't need to filter
# the response data can safely leave it alone and not have to send messages
# down the traditional "rack stack".
#
# The events are:
#
# * on_start(request, response)
#
#   This event is sent at the start of the request, before the next
#   middleware in the chain is called.  This method is called with a request
#   object, and a response object.  Right now, the response object is always
#   nil, but in the future it may actually be a real response object.
#
# * on_commit(request, response)
#
#   The response has been committed.  The application has returned, but the
#   response has not been sent to the webserver yet.  This method is always
#   called with a request object and the response object.  The response
#   object is constructed from the rack triple that the application returned.
#   Changes may still be made to the response object at this point.
#
# * on_send(request, response)
#
#   The webserver has started iterating over the response body, or has called
#   the streaming body, and presumably has started sending data over the
#   wire. This method is always called with a request object and the response
#   object. The response object is constructed from the rack triple that the
#   application returned.  Changes SHOULD NOT be made to the response object
#   as the webserver has already started sending data.  Any mutations will
#   likely result in an exception.
#
# * on_finish(request, response)
#
#   The webserver has closed the response, and all data has been written to
#   the response socket.  The request and response object should both be
#   read-only at this point.  The body MAY NOT be available on the response
#   object as it may have been flushed to the socket.
#
# * on_error(request, response, error)
#
#   An exception has occurred in the application or an `on_commit` event.
#   This method will get the request, the response (if available) and the
#   exception that was raised.
#
# ## Order
#
# `on_start` is called on the handlers in the order that they were passed to
# the constructor.  `on_commit`, on_send`, `on_finish`, and `on_error` are
# called in the reverse order.  `on_finish` handlers are called inside an
# `ensure` block, so they are guaranteed to be called even if something
# raises an exception.  If something raises an exception in a `on_finish`
# method, then nothing is guaranteed.
#
# source://rack//lib/rack/events.rb#62
class Rack::Events
  # @return [Events] a new instance of Events
  #
  # source://rack//lib/rack/events.rb#121
  def initialize(app, handlers); end

  # source://rack//lib/rack/events.rb#126
  def call(env); end

  private

  # source://rack//lib/rack/events.rb#164
  def make_request(env); end

  # source://rack//lib/rack/events.rb#168
  def make_response(status, headers, body); end

  # source://rack//lib/rack/events.rb#152
  def on_commit(request, response); end

  # source://rack//lib/rack/events.rb#148
  def on_error(request, response, e); end

  # source://rack//lib/rack/events.rb#160
  def on_finish(request, response); end

  # source://rack//lib/rack/events.rb#156
  def on_start(request, response); end
end

# source://rack//lib/rack/events.rb#63
module Rack::Events::Abstract
  # source://rack//lib/rack/events.rb#67
  def on_commit(req, res); end

  # source://rack//lib/rack/events.rb#76
  def on_error(req, res, e); end

  # source://rack//lib/rack/events.rb#73
  def on_finish(req, res); end

  # source://rack//lib/rack/events.rb#70
  def on_send(req, res); end

  # source://rack//lib/rack/events.rb#64
  def on_start(req, res); end
end

# source://rack//lib/rack/events.rb#110
class Rack::Events::BufferedResponse < ::Rack::Response::Raw
  # @return [BufferedResponse] a new instance of BufferedResponse
  #
  # source://rack//lib/rack/events.rb#113
  def initialize(status, headers, body); end

  # Returns the value of attribute body.
  #
  # source://rack//lib/rack/events.rb#111
  def body; end

  # source://rack//lib/rack/events.rb#118
  def to_a; end
end

# source://rack//lib/rack/events.rb#80
class Rack::Events::EventedBodyProxy < ::Rack::BodyProxy
  # @return [EventedBodyProxy] a new instance of EventedBodyProxy
  #
  # source://rack//lib/rack/events.rb#83
  def initialize(body, request, response, handlers, &block); end

  # source://rack//lib/rack/events.rb#95
  def call(stream); end

  # source://rack//lib/rack/events.rb#90
  def each; end

  # Returns the value of attribute request.
  #
  # source://rack//lib/rack/events.rb#81
  def request; end

  # @return [Boolean]
  #
  # source://rack//lib/rack/events.rb#100
  def respond_to?(method_name, include_all = T.unsafe(nil)); end

  # Returns the value of attribute response.
  #
  # source://rack//lib/rack/events.rb#81
  def response; end
end

# Rack::Files serves files below the +root+ directory given, according to the
# path info of the Rack request.
# e.g. when Rack::Files.new("/etc") is used, you can access 'passwd' file
# as http://localhost:9292/passwd
#
# Handlers can detect if bodies are a Rack::Files, and use mechanisms
# like sendfile on the +path+.
#
# source://rack//lib/rack/files.rb#20
class Rack::Files
  # @return [Files] a new instance of Files
  #
  # source://rack//lib/rack/files.rb#27
  def initialize(root, headers = T.unsafe(nil), default_mime = T.unsafe(nil)); end

  # source://rack//lib/rack/files.rb#34
  def call(env); end

  # source://rack//lib/rack/files.rb#39
  def get(env); end

  # Returns the value of attribute root.
  #
  # source://rack//lib/rack/files.rb#25
  def root; end

  # source://rack//lib/rack/files.rb#68
  def serving(request, path); end

  private

  # source://rack//lib/rack/files.rb#190
  def fail(status, body, headers = T.unsafe(nil)); end

  # source://rack//lib/rack/files.rb#209
  def filesize(path); end

  # The MIME type for the contents of the file located at @path
  #
  # source://rack//lib/rack/files.rb#205
  def mime_type(path, default_mime); end
end

# source://rack//lib/rack/files.rb#21
Rack::Files::ALLOWED_VERBS = T.let(T.unsafe(nil), Array)

# source://rack//lib/rack/files.rb#22
Rack::Files::ALLOW_HEADER = T.let(T.unsafe(nil), String)

# source://rack//lib/rack/files.rb#121
class Rack::Files::BaseIterator
  # @return [BaseIterator] a new instance of BaseIterator
  #
  # source://rack//lib/rack/files.rb#124
  def initialize(path, ranges, options); end

  # source://rack//lib/rack/files.rb#144
  def bytesize; end

  # source://rack//lib/rack/files.rb#153
  def close; end

  # source://rack//lib/rack/files.rb#130
  def each; end

  # Returns the value of attribute options.
  #
  # source://rack//lib/rack/files.rb#122
  def options; end

  # Returns the value of attribute path.
  #
  # source://rack//lib/rack/files.rb#122
  def path; end

  # Returns the value of attribute ranges.
  #
  # source://rack//lib/rack/files.rb#122
  def ranges; end

  private

  # source://rack//lib/rack/files.rb#171
  def each_range_part(file, range); end

  # @return [Boolean]
  #
  # source://rack//lib/rack/files.rb#157
  def multipart?; end

  # source://rack//lib/rack/files.rb#161
  def multipart_heading(range); end
end

# source://rack//lib/rack/files.rb#184
class Rack::Files::Iterator < ::Rack::Files::BaseIterator
  # source://rack//lib/rack/files.rb#185
  def to_path; end
end

# source://rack//lib/rack/files.rb#23
Rack::Files::MULTIPART_BOUNDARY = T.let(T.unsafe(nil), String)

# Rack::ForwardRequest gets caught by Rack::Recursive and redirects
# the current request to the app at +url+.
#
#   raise ForwardRequest.new("/not-found")
#
# source://rack//lib/rack/recursive.rb#14
class Rack::ForwardRequest < ::Exception
  # @return [ForwardRequest] a new instance of ForwardRequest
  #
  # source://rack//lib/rack/recursive.rb#17
  def initialize(url, env = T.unsafe(nil)); end

  # Returns the value of attribute env.
  #
  # source://rack//lib/rack/recursive.rb#15
  def env; end

  # Returns the value of attribute url.
  #
  # source://rack//lib/rack/recursive.rb#15
  def url; end
end

# HTTP method verbs
#
# source://rack//lib/rack/constants.rb#28
Rack::GET = T.let(T.unsafe(nil), String)

# source://rack//lib/rack/constants.rb#33
Rack::HEAD = T.let(T.unsafe(nil), String)

# source://rack//lib/rack/constants.rb#7
Rack::HTTPS = T.let(T.unsafe(nil), String)

# source://rack//lib/rack/constants.rb#16
Rack::HTTP_COOKIE = T.let(T.unsafe(nil), String)

# Request env keys
#
# source://rack//lib/rack/constants.rb#5
Rack::HTTP_HOST = T.let(T.unsafe(nil), String)

# source://rack//lib/rack/constants.rb#6
Rack::HTTP_PORT = T.let(T.unsafe(nil), String)

# Rack::Head returns an empty body for all HEAD requests. It leaves
# all other requests unchanged.
#
# source://rack//lib/rack/head.rb#9
class Rack::Head
  # @return [Head] a new instance of Head
  #
  # source://rack//lib/rack/head.rb#10
  def initialize(app); end

  # source://rack//lib/rack/head.rb#14
  def call(env); end
end

# Rack::Headers is a Hash subclass that downcases all keys.  It's designed
# to be used by rack applications that don't implement the Rack 3 SPEC
# (by using non-lowercase response header keys), automatically handling
# the downcasing of keys.
#
# source://rack//lib/rack/headers.rb#8
class Rack::Headers < ::Hash
  # source://rack//lib/rack/headers.rb#110
  def [](key); end

  # source://rack//lib/rack/headers.rb#114
  def []=(key, value); end

  # source://rack//lib/rack/headers.rb#119
  def assoc(key); end

  # @raise [TypeError]
  #
  # source://rack//lib/rack/headers.rb#123
  def compare_by_identity; end

  # source://rack//lib/rack/headers.rb#127
  def delete(key); end

  # source://rack//lib/rack/headers.rb#131
  def dig(key, *a); end

  # :nocov:
  #
  # source://rack//lib/rack/headers.rb#227
  def except(*a); end

  # source://rack//lib/rack/headers.rb#135
  def fetch(key, *default, &block); end

  # source://rack//lib/rack/headers.rb#140
  def fetch_values(*a); end

  # @return [Boolean]
  #
  # source://rack//lib/rack/headers.rb#144
  def has_key?(key); end

  # @return [Boolean]
  #
  # source://rack//lib/rack/headers.rb#147
  def include?(key); end

  # source://rack//lib/rack/headers.rb#151
  def invert; end

  # @return [Boolean]
  #
  # source://rack//lib/rack/headers.rb#148
  def key?(key); end

  # @return [Boolean]
  #
  # source://rack//lib/rack/headers.rb#149
  def member?(key); end

  # source://rack//lib/rack/headers.rb#157
  def merge(hash, &block); end

  # source://rack//lib/rack/headers.rb#196
  def merge!(hash, &block); end

  # source://rack//lib/rack/headers.rb#161
  def reject(&block); end

  # source://rack//lib/rack/headers.rb#167
  def replace(hash); end

  # source://rack//lib/rack/headers.rb#172
  def select(&block); end

  # :nocov:
  #
  # source://rack//lib/rack/headers.rb#205
  def slice(*a); end

  # source://rack//lib/rack/headers.rb#117
  def store(key, value); end

  # source://rack//lib/rack/headers.rb#178
  def to_proc; end

  # source://rack//lib/rack/headers.rb#211
  def transform_keys(&block); end

  # source://rack//lib/rack/headers.rb#215
  def transform_keys!; end

  # source://rack//lib/rack/headers.rb#182
  def transform_values(&block); end

  # source://rack//lib/rack/headers.rb#186
  def update(hash, &block); end

  # source://rack//lib/rack/headers.rb#198
  def values_at(*keys); end

  private

  # source://rack//lib/rack/headers.rb#234
  def downcase_key(key); end

  class << self
    # source://rack//lib/rack/headers.rb#91
    def [](*items); end
  end
end

# source://rack//lib/rack/headers.rb#9
Rack::Headers::KNOWN_HEADERS = T.let(T.unsafe(nil), Hash)

# source://rack//lib/rack/constants.rb#36
Rack::LINK = T.let(T.unsafe(nil), String)

# Validates your application and the requests and responses according to the Rack spec. See SPEC.rdoc for details.
#
# source://rack//lib/rack/lint.rb#10
class Rack::Lint
  # N.B. The empty `##` comments creates paragraphs in the output. A trailing "\" is used to escape the newline character, which combines the comments into a single paragraph.
  #
  # = Rack Specification
  #
  # This specification aims to formalize the Rack protocol. You can (and should) use +Rack::Lint+ to enforce it. When you develop middleware, be sure to test with +Rack::Lint+ to catch possible violations of this specification.
  #
  # == The Application
  #
  # A Rack application is a Ruby object that responds to +call+. \
  #
  # @raise [LintError]
  # @return [Lint] a new instance of Lint
  #
  # source://rack//lib/rack/lint.rb#65
  def initialize(app); end

  # Invoke the application, validating the request and response according to the Rack spec.
  #
  # source://rack//lib/rack/lint.rb#15
  def call(env = T.unsafe(nil)); end
end

# :stopdoc:
#
# source://rack//lib/rack/lint.rb#21
Rack::Lint::ALLOWED_SCHEMES = T.let(T.unsafe(nil), Array)

# Match a host name, according to RFC3986. Copied from `URI::RFC3986_Parser::HOST` because older Ruby versions (< 3.3) don't expose it.
#
# source://rack//lib/rack/lint.rb#29
Rack::Lint::HOST_PATTERN = T.let(T.unsafe(nil), Regexp)

# source://rack//lib/rack/lint.rb#52
Rack::Lint::HTTP_HOST_PATTERN = T.let(T.unsafe(nil), Regexp)

# Represents a failure to meet the Rack specification.
#
# source://rack//lib/rack/lint.rb#12
class Rack::Lint::LintError < ::RuntimeError; end

# source://rack//lib/rack/lint.rb#24
Rack::Lint::REQUEST_PATH_ABSOLUTE_FORM = T.let(T.unsafe(nil), Regexp)

# source://rack//lib/rack/lint.rb#26
Rack::Lint::REQUEST_PATH_ASTERISK_FORM = T.let(T.unsafe(nil), String)

# source://rack//lib/rack/lint.rb#25
Rack::Lint::REQUEST_PATH_AUTHORITY_FORM = T.let(T.unsafe(nil), Regexp)

# source://rack//lib/rack/lint.rb#23
Rack::Lint::REQUEST_PATH_ORIGIN_FORM = T.let(T.unsafe(nil), Regexp)

# source://rack//lib/rack/lint.rb#51
Rack::Lint::SERVER_NAME_PATTERN = T.let(T.unsafe(nil), Regexp)

# source://rack//lib/rack/lint.rb#71
class Rack::Lint::Wrapper
  # @return [Wrapper] a new instance of Wrapper
  #
  # source://rack//lib/rack/lint.rb#72
  def initialize(app, env); end

  # ==== Streaming Body
  #
  # @raise [LintError]
  #
  # source://rack//lib/rack/lint.rb#918
  def call(stream); end

  # ==== The <tt>content-length</tt> Header
  #
  # source://rack//lib/rack/lint.rb#768
  def check_content_length_header(status, headers); end

  # ==== The <tt>content-type</tt> Header
  #
  # source://rack//lib/rack/lint.rb#753
  def check_content_type_header(status, headers); end

  # === Early Hints
  #
  # The application or any middleware may call the <tt>rack.early_hints</tt> with an object which would be valid as the headers of a Rack response.
  #
  # source://rack//lib/rack/lint.rb#670
  def check_early_hints(env); end

  # == The Request Environment
  #
  # Incoming HTTP requests are represented using an environment. \
  #
  # @raise [LintError]
  #
  # source://rack//lib/rack/lint.rb#136
  def check_environment(env); end

  # === The Error Stream
  #
  # source://rack//lib/rack/lint.rb#571
  def check_error_stream(error); end

  # source://rack//lib/rack/lint.rb#743
  def check_header_value(key, value); end

  # === The Headers
  #
  # source://rack//lib/rack/lint.rb#704
  def check_headers(headers); end

  # === Hijacking
  #
  # The hijacking interfaces provides a means for an application to take control of the HTTP connection. There are two distinct hijack interfaces: full hijacking where the application takes over the raw connection, and partial hijacking where the application takes over just the response body stream. In both cases, the application is responsible for closing the hijacked stream.
  #
  # Full hijacking only works with HTTP/1. Partial hijacking is functionally equivalent to streaming bodies, and is still optionally supported for backwards compatibility with older Rack versions.
  #
  # ==== Full Hijack
  #
  # Full hijack is used to completely take over an HTTP/1 connection. It occurs before any headers are written and causes the server to ignore any response generated by the application. It is intended to be used when applications need access to the raw HTTP/1 connection.
  #
  # source://rack//lib/rack/lint.rb#618
  def check_hijack(env); end

  # ==== Partial Hijack
  #
  # Partial hijack is used for bi-directional streaming of the request and response body. It occurs after the status and headers are written by the server and causes the server to ignore the Body of the response. It is intended to be used when applications need bi-directional streaming.
  #
  # source://rack//lib/rack/lint.rb#639
  def check_hijack_response(headers, env); end

  # === The Input Stream
  #
  # The input stream is an +IO+-like object which contains the raw HTTP request data. \
  #
  # source://rack//lib/rack/lint.rb#478
  def check_input_stream(input); end

  # ==== The <tt>rack.protocol</tt> Header
  #
  # source://rack//lib/rack/lint.rb#795
  def check_rack_protocol_header(status, headers); end

  # == The Response
  #
  # Outgoing HTTP responses are generated from the response tuple generated by the application. The response tuple is an +Array+ of three elements, which are: the HTTP status, the headers, and the response body. The Rack application is responsible for ensuring that the response tuple is well-formed and should follow the rules set out in this specification.
  #
  # === The Status
  #
  # source://rack//lib/rack/lint.rb#694
  def check_status(status); end

  # Setting this value informs the server that it should perform a connection upgrade. In HTTP/1, this is done using the +upgrade+ header. In HTTP/2+, this is done by accepting the request.
  #
  # === The Body
  #
  # The Body is typically an +Array+ of +String+ values, an enumerable that yields +String+ values, a +Proc+, or an +IO+-like object.
  #
  # The Body must respond to +each+ or +call+. It may optionally respond to +to_path+ or +to_ary+. A Body that responds to +each+ is considered to be an Enumerable Body. A Body that responds to +call+ is considered to be a Streaming Body.
  #
  # A Body that responds to both +each+ and +call+ must be treated as an Enumerable Body, not a Streaming Body. If it responds to +each+, you must call +each+ and not +call+. If the Body doesn't respond to +each+, then you can assume it responds to +call+.
  #
  # The Body must either be consumed or returned. The Body is consumed by optionally calling either +each+ or +call+. Then, if the Body responds to +close+, it must be called to release any resources associated with the generation of the body. In other words, +close+ must always be called at least once; typically after the web server has sent the response to the client, but also in cases where the Rack application makes internal/virtual requests and discards the response.
  #
  # source://rack//lib/rack/lint.rb#821
  def close; end

  # ==== Enumerable Body
  #
  # @raise [LintError]
  #
  # source://rack//lib/rack/lint.rb#852
  def each; end

  # @return [Boolean]
  #
  # source://rack//lib/rack/lint.rb#895
  def respond_to?(name, *_arg1); end

  # @raise [LintError]
  #
  # source://rack//lib/rack/lint.rb#87
  def response; end

  # If the Body responds to +to_ary+, it must return an +Array+ whose contents are identical to that produced by calling +each+. Middleware may call +to_ary+ directly on the Body and return a new Body in its place. In other words, middleware can only process the Body directly if it responds to +to_ary+. If the Body responds to both +to_ary+ and +close+, its implementation of +to_ary+ must call +close+.
  #
  # source://rack//lib/rack/lint.rb#905
  def to_ary; end

  # source://rack//lib/rack/lint.rb#891
  def to_path; end

  # source://rack//lib/rack/lint.rb#780
  def verify_content_length(size); end

  # source://rack//lib/rack/lint.rb#835
  def verify_to_path; end

  private

  # @raise [LintError]
  #
  # source://rack//lib/rack/lint.rb#126
  def assert_required(key); end
end

# source://rack//lib/rack/lint.rb#889
Rack::Lint::Wrapper::BODY_METHODS = T.let(T.unsafe(nil), Hash)

# source://rack//lib/rack/lint.rb#580
class Rack::Lint::Wrapper::ErrorWrapper
  # @return [ErrorWrapper] a new instance of ErrorWrapper
  #
  # source://rack//lib/rack/lint.rb#581
  def initialize(error); end

  # * +close+ must never be called on the error stream.
  #
  # @raise [LintError]
  #
  # source://rack//lib/rack/lint.rb#602
  def close(*args); end

  # * +flush+ must be called without arguments and must be called in order to make the error appear for sure.
  #
  # source://rack//lib/rack/lint.rb#597
  def flush; end

  # * +puts+ must be called with a single argument that responds to +to_s+.
  #
  # source://rack//lib/rack/lint.rb#586
  def puts(str); end

  # * +write+ must be called with a single argument that is a +String+.
  #
  # @raise [LintError]
  #
  # source://rack//lib/rack/lint.rb#591
  def write(str); end
end

# source://rack//lib/rack/lint.rb#495
class Rack::Lint::Wrapper::InputWrapper
  # @return [InputWrapper] a new instance of InputWrapper
  #
  # source://rack//lib/rack/lint.rb#496
  def initialize(input); end

  # * +close+ can be called on the input stream to indicate that any remaining input is not needed.
  #
  # source://rack//lib/rack/lint.rb#563
  def close(*args); end

  # * +each+ must be called without arguments and only yield +String+ values.
  #
  # @raise [LintError]
  #
  # source://rack//lib/rack/lint.rb#552
  def each(*args); end

  # * +gets+ must be called without arguments and return a +String+, or +nil+ on EOF (end-of-file).
  #
  # @raise [LintError]
  #
  # source://rack//lib/rack/lint.rb#501
  def gets(*args); end

  # * +read+ behaves like <tt>IO#read</tt>. Its signature is <tt>read([length, [buffer]])</tt>.
  #   * If given, +length+ must be a non-negative Integer (>= 0) or +nil+, and +buffer+ must be a +String+ and may not be +nil+.
  #   * If +length+ is given and not +nil+, then this method reads at most +length+ bytes from the input stream.
  #   * If +length+ is not given or +nil+, then this method reads all data until EOF.
  #   * When EOF is reached, this method returns +nil+ if +length+ is given and not +nil+, or +""+ if +length+ is not given or is +nil+.
  #   * If +buffer+ is given, then the read data will be placed into +buffer+ instead of a newly created +String+.
  #
  # source://rack//lib/rack/lint.rb#519
  def read(*args); end
end

# source://rack//lib/rack/lint.rb#936
class Rack::Lint::Wrapper::StreamWrapper
  extend ::Forwardable

  # @return [StreamWrapper] a new instance of StreamWrapper
  #
  # source://rack//lib/rack/lint.rb#947
  def initialize(stream); end

  # source://rack//lib/rack/lint.rb#945
  def <<(*args, **_arg1, &block); end

  # source://rack//lib/rack/lint.rb#945
  def close(*args, **_arg1, &block); end

  # source://rack//lib/rack/lint.rb#945
  def close_read(*args, **_arg1, &block); end

  # source://rack//lib/rack/lint.rb#945
  def close_write(*args, **_arg1, &block); end

  # source://rack//lib/rack/lint.rb#945
  def closed?(*args, **_arg1, &block); end

  # source://rack//lib/rack/lint.rb#945
  def flush(*args, **_arg1, &block); end

  # source://rack//lib/rack/lint.rb#945
  def read(*args, **_arg1, &block); end

  # source://rack//lib/rack/lint.rb#945
  def write(*args, **_arg1, &block); end
end

# The semantics of these +IO+ methods must be a best effort match to those of a normal Ruby +IO+ or +Socket+ object, using standard arguments and raising standard exceptions. Servers may simply pass on real +IO+ objects to the Streaming Body. In some cases (e.g. when using <tt>transfer-encoding</tt> or HTTP/2+), the server may need to provide a wrapper that implements the required methods, in order to provide the correct semantics.
#
# source://rack//lib/rack/lint.rb#940
Rack::Lint::Wrapper::StreamWrapper::REQUIRED_METHODS = T.let(T.unsafe(nil), Array)

# Rack::Lock locks every request inside a mutex, so that every request
# will effectively be executed synchronously.
#
# source://rack//lib/rack/lock.rb#8
class Rack::Lock
  # @return [Lock] a new instance of Lock
  #
  # source://rack//lib/rack/lock.rb#9
  def initialize(app, mutex = T.unsafe(nil)); end

  # source://rack//lib/rack/lock.rb#13
  def call(env); end

  private

  # source://rack//lib/rack/lock.rb#25
  def unlock; end
end

# Rack::MediaType parse media type and parameters out of content_type string
#
# source://rack//lib/rack/media_type.rb#6
class Rack::MediaType
  class << self
    # The media type parameters provided in CONTENT_TYPE as a Hash, or
    # an empty Hash if no CONTENT_TYPE or media-type parameters were
    # provided.  e.g., when the CONTENT_TYPE is "text/plain;charset=utf-8",
    # this method responds with the following Hash:
    #   { 'charset' => 'utf-8' }
    #
    # This will pass back parameters with empty strings in the hash if they
    # lack a value (e.g., "text/plain;charset=" will return { 'charset' => '' },
    # and "text/plain;charset" will return { 'charset' => '' }, similarly to
    # the query params parser (barring the latter case, which returns nil instead)).
    #
    # source://rack//lib/rack/media_type.rb#34
    def params(content_type); end

    # The media type (type/subtype) portion of the CONTENT_TYPE header
    # without any media type parameters. e.g., when CONTENT_TYPE is
    # "text/plain;charset=utf-8", the media-type is "text/plain".
    #
    # For more information on the use of media types in HTTP, see:
    # http://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.7
    #
    # source://rack//lib/rack/media_type.rb#16
    def type(content_type); end

    private

    # source://rack//lib/rack/media_type.rb#47
    def strip_doublequotes(str); end
  end
end

# source://rack//lib/rack/media_type.rb#7
Rack::MediaType::SPLIT_PATTERN = T.let(T.unsafe(nil), Regexp)

# source://rack//lib/rack/method_override.rb#8
class Rack::MethodOverride
  # @return [MethodOverride] a new instance of MethodOverride
  #
  # source://rack//lib/rack/method_override.rb#15
  def initialize(app); end

  # source://rack//lib/rack/method_override.rb#19
  def call(env); end

  # source://rack//lib/rack/method_override.rb#31
  def method_override(env); end

  private

  # source://rack//lib/rack/method_override.rb#44
  def allowed_methods; end

  # source://rack//lib/rack/method_override.rb#48
  def method_override_param(req); end
end

# source://rack//lib/rack/method_override.rb#13
Rack::MethodOverride::ALLOWED_METHODS = T.let(T.unsafe(nil), Array)

# source://rack//lib/rack/method_override.rb#9
Rack::MethodOverride::HTTP_METHODS = T.let(T.unsafe(nil), Array)

# source://rack//lib/rack/method_override.rb#12
Rack::MethodOverride::HTTP_METHOD_OVERRIDE_HEADER = T.let(T.unsafe(nil), String)

# source://rack//lib/rack/method_override.rb#11
Rack::MethodOverride::METHOD_OVERRIDE_PARAM_KEY = T.let(T.unsafe(nil), String)

# source://rack//lib/rack/mime.rb#4
module Rack::Mime
  private

  # Returns true if the given value is a mime match for the given mime match
  # specification, false otherwise.
  #
  #    Rack::Mime.match?('text/html', 'text/*') => true
  #    Rack::Mime.match?('text/plain', '*') => true
  #    Rack::Mime.match?('text/html', 'application/json') => false
  #
  # @return [Boolean]
  #
  # source://rack//lib/rack/mime.rb#30
  def match?(value, matcher); end

  # Returns String with mime type if found, otherwise use +fallback+.
  # +ext+ should be filename extension in the '.ext' format that
  #       File.extname(file) returns.
  # +fallback+ may be any object
  #
  # Also see the documentation for MIME_TYPES
  #
  # Usage:
  #     Rack::Mime.mime_type('.foo')
  #
  # This is a shortcut for:
  #     Rack::Mime::MIME_TYPES.fetch('.foo', 'application/octet-stream')
  #
  # source://rack//lib/rack/mime.rb#18
  def mime_type(ext, fallback = T.unsafe(nil)); end

  class << self
    # Returns true if the given value is a mime match for the given mime match
    # specification, false otherwise.
    #
    #    Rack::Mime.match?('text/html', 'text/*') => true
    #    Rack::Mime.match?('text/plain', '*') => true
    #    Rack::Mime.match?('text/html', 'application/json') => false
    #
    # @return [Boolean]
    #
    # source://rack//lib/rack/mime.rb#36
    def match?(value, matcher); end

    # Returns String with mime type if found, otherwise use +fallback+.
    # +ext+ should be filename extension in the '.ext' format that
    #       File.extname(file) returns.
    # +fallback+ may be any object
    #
    # Also see the documentation for MIME_TYPES
    #
    # Usage:
    #     Rack::Mime.mime_type('.foo')
    #
    # This is a shortcut for:
    #     Rack::Mime::MIME_TYPES.fetch('.foo', 'application/octet-stream')
    #
    # source://rack//lib/rack/mime.rb#21
    def mime_type(ext, fallback = T.unsafe(nil)); end
  end
end

# List of most common mime-types, selected various sources
# according to their usefulness in a webserving scope for Ruby
# users.
#
# To amend this list with your local mime.types list you can use:
#
#     require 'webrick/httputils'
#     list = WEBrick::HTTPUtils.load_mime_types('/etc/mime.types')
#     Rack::Mime::MIME_TYPES.merge!(list)
#
# N.B. On Ubuntu the mime.types file does not include the leading period, so
# users may need to modify the data before merging into the hash.
#
# source://rack//lib/rack/mime.rb#51
Rack::Mime::MIME_TYPES = T.let(T.unsafe(nil), Hash)

# Rack::MockRequest helps testing your Rack application without
# actually using HTTP.
#
# After performing a request on a URL with get/post/put/patch/delete, it
# returns a MockResponse with useful helper methods for effective
# testing.
#
# You can pass a hash with additional configuration to the
# get/post/put/patch/delete.
# <tt>:input</tt>:: A String or IO-like to be used as rack.input.
# <tt>:fatal</tt>:: Raise a FatalWarning if the app writes to rack.errors.
# <tt>:lint</tt>:: If true, wrap the application in a Rack::Lint.
#
# source://rack//lib/rack/mock_request.rb#23
class Rack::MockRequest
  # @return [MockRequest] a new instance of MockRequest
  #
  # source://rack//lib/rack/mock_request.rb#44
  def initialize(app); end

  # Make a DELETE request and return a MockResponse. See #request.
  #
  # source://rack//lib/rack/mock_request.rb#57
  def delete(uri, opts = T.unsafe(nil)); end

  # Make a GET request and return a MockResponse. See #request.
  #
  # source://rack//lib/rack/mock_request.rb#49
  def get(uri, opts = T.unsafe(nil)); end

  # Make a HEAD request and return a MockResponse. See #request.
  #
  # source://rack//lib/rack/mock_request.rb#59
  def head(uri, opts = T.unsafe(nil)); end

  # Make an OPTIONS request and return a MockResponse. See #request.
  #
  # source://rack//lib/rack/mock_request.rb#61
  def options(uri, opts = T.unsafe(nil)); end

  # Make a PATCH request and return a MockResponse. See #request.
  #
  # source://rack//lib/rack/mock_request.rb#55
  def patch(uri, opts = T.unsafe(nil)); end

  # Make a POST request and return a MockResponse. See #request.
  #
  # source://rack//lib/rack/mock_request.rb#51
  def post(uri, opts = T.unsafe(nil)); end

  # Make a PUT request and return a MockResponse. See #request.
  #
  # source://rack//lib/rack/mock_request.rb#53
  def put(uri, opts = T.unsafe(nil)); end

  # Make a request using the given request method for the given
  # uri to the rack application and return a MockResponse.
  # Options given are passed to MockRequest.env_for.
  #
  # source://rack//lib/rack/mock_request.rb#66
  def request(method = T.unsafe(nil), uri = T.unsafe(nil), opts = T.unsafe(nil)); end

  class << self
    # Return the Rack environment used for a request to +uri+.
    # All options that are strings are added to the returned environment.
    # Options:
    # :fatal :: Whether to raise an exception if request outputs to rack.errors
    # :input :: The rack.input to set
    # :http_version :: The SERVER_PROTOCOL to set
    # :method :: The HTTP request method to use
    # :params :: The params to use
    # :script_name :: The SCRIPT_NAME to set
    #
    # source://rack//lib/rack/mock_request.rb#98
    def env_for(uri = T.unsafe(nil), opts = T.unsafe(nil)); end

    # For historical reasons, we're pinning to RFC 2396.
    # URI::Parser = URI::RFC2396_Parser
    #
    # source://rack//lib/rack/mock_request.rb#84
    def parse_uri_rfc2396(uri); end
  end
end

# source://rack//lib/rack/mock_request.rb#27
class Rack::MockRequest::FatalWarner
  # source://rack//lib/rack/mock_request.rb#36
  def flush; end

  # @raise [FatalWarning]
  #
  # source://rack//lib/rack/mock_request.rb#28
  def puts(warning); end

  # source://rack//lib/rack/mock_request.rb#39
  def string; end

  # @raise [FatalWarning]
  #
  # source://rack//lib/rack/mock_request.rb#32
  def write(warning); end
end

# source://rack//lib/rack/mock_request.rb#24
class Rack::MockRequest::FatalWarning < ::RuntimeError; end

# Rack::MockResponse provides useful helpers for testing your apps.
# Usually, you don't create the MockResponse on your own, but use
# MockRequest.
#
# source://rack//lib/rack/mock_response.rb#12
class Rack::MockResponse < ::Rack::Response
  # @return [MockResponse] a new instance of MockResponse
  #
  # source://rack//lib/rack/mock_response.rb#47
  def initialize(status, headers, body, errors = T.unsafe(nil)); end

  # source://rack//lib/rack/mock_response.rb#62
  def =~(other); end

  # source://rack//lib/rack/mock_response.rb#70
  def body; end

  # source://rack//lib/rack/mock_response.rb#96
  def cookie(name); end

  # Headers
  #
  # source://rack//lib/rack/mock_response.rb#42
  def cookies; end

  # @return [Boolean]
  #
  # source://rack//lib/rack/mock_response.rb#92
  def empty?; end

  # Errors
  #
  # source://rack//lib/rack/mock_response.rb#45
  def errors; end

  # Errors
  #
  # source://rack//lib/rack/mock_response.rb#45
  def errors=(_arg0); end

  # source://rack//lib/rack/mock_response.rb#66
  def match(other); end

  # Headers
  #
  # source://rack//lib/rack/mock_response.rb#42
  def original_headers; end

  private

  # source://rack//lib/rack/mock_response.rb#123
  def identify_cookie_attributes(cookie_filling); end

  # source://rack//lib/rack/mock_response.rb#102
  def parse_cookies_from_header; end

  class << self
    # source://rack//lib/rack/mock_response.rb#38
    def [](*_arg0); end
  end
end

# source://rack//lib/rack/mock_response.rb#13
class Rack::MockResponse::Cookie
  # @return [Cookie] a new instance of Cookie
  #
  # source://rack//lib/rack/mock_response.rb#16
  def initialize(args); end

  # Returns the value of attribute domain.
  #
  # source://rack//lib/rack/mock_response.rb#14
  def domain; end

  # Returns the value of attribute expires.
  #
  # source://rack//lib/rack/mock_response.rb#14
  def expires; end

  # source://rack//lib/rack/mock_response.rb#25
  def method_missing(method_name, *args, **_arg2, &block); end

  # Returns the value of attribute name.
  #
  # source://rack//lib/rack/mock_response.rb#14
  def name; end

  # Returns the value of attribute path.
  #
  # source://rack//lib/rack/mock_response.rb#14
  def path; end

  # Returns the value of attribute secure.
  #
  # source://rack//lib/rack/mock_response.rb#14
  def secure; end

  # Returns the value of attribute value.
  #
  # source://rack//lib/rack/mock_response.rb#14
  def value; end

  private

  # :nocov:
  #
  # @return [Boolean]
  #
  # source://rack//lib/rack/mock_response.rb#32
  def respond_to_missing?(method_name, include_all = T.unsafe(nil)); end
end

# A multipart form data parser, adapted from IOWA.
#
# Usually, Rack::Request#POST takes care of calling this.
#
# source://rack//lib/rack/multipart/parser.rb#9
module Rack::Multipart
  class << self
    # source://rack//lib/rack/multipart.rb#72
    def build_multipart(params, first = T.unsafe(nil)); end

    # source://rack//lib/rack/multipart.rb#68
    def extract_multipart(request, params = T.unsafe(nil)); end

    # source://rack//lib/rack/multipart.rb#48
    def parse_multipart(env, params = T.unsafe(nil)); end
  end
end

# Base class for multipart exceptions that do not subclass from
# other exception classes for backwards compatibility.
#
# source://rack//lib/rack/multipart/parser.rb#26
class Rack::Multipart::BoundaryTooLongError < ::StandardError
  include ::Rack::BadRequest
end

# source://rack//lib/rack/multipart/parser.rb#33
Rack::Multipart::EOL = T.let(T.unsafe(nil), String)

# Use specific error class when parsing multipart request
# that ends early.
#
# source://rack//lib/rack/multipart/parser.rb#20
class Rack::Multipart::EmptyContentError < ::EOFError
  include ::Rack::BadRequest
end

# Prefer to use the BoundaryTooLongError class or Rack::BadRequest.
#
# source://rack//lib/rack/multipart/parser.rb#31
Rack::Multipart::Error = Rack::Multipart::BoundaryTooLongError

# whitespace with optional folding
#
# source://rack//lib/rack/multipart/parser.rb#34
Rack::Multipart::FWS = T.let(T.unsafe(nil), Regexp)

# source://rack//lib/rack/multipart/generator.rb#7
class Rack::Multipart::Generator
  # @return [Generator] a new instance of Generator
  #
  # source://rack//lib/rack/multipart/generator.rb#8
  def initialize(params, first = T.unsafe(nil)); end

  # source://rack//lib/rack/multipart/generator.rb#16
  def dump; end

  private

  # source://rack//lib/rack/multipart/generator.rb#89
  def content_for_other(file, name); end

  # source://rack//lib/rack/multipart/generator.rb#77
  def content_for_tempfile(io, file, name); end

  # source://rack//lib/rack/multipart/generator.rb#52
  def flattened_params; end

  # @return [Boolean]
  #
  # source://rack//lib/rack/multipart/generator.rb#37
  def multipart?; end
end

# anything but a non-folding CRLF
#
# source://rack//lib/rack/multipart/parser.rb#35
Rack::Multipart::HEADER_VALUE = T.let(T.unsafe(nil), String)

# source://rack//lib/rack/multipart/parser.rb#36
Rack::Multipart::MULTIPART = T.let(T.unsafe(nil), Regexp)

# source://rack//lib/rack/multipart.rb#16
Rack::Multipart::MULTIPART_BOUNDARY = T.let(T.unsafe(nil), String)

# source://rack//lib/rack/multipart/parser.rb#38
Rack::Multipart::MULTIPART_CONTENT_DISPOSITION = T.let(T.unsafe(nil), Regexp)

# source://rack//lib/rack/multipart/parser.rb#39
Rack::Multipart::MULTIPART_CONTENT_ID = T.let(T.unsafe(nil), Regexp)

# source://rack//lib/rack/multipart/parser.rb#37
Rack::Multipart::MULTIPART_CONTENT_TYPE = T.let(T.unsafe(nil), Regexp)

# source://rack//lib/rack/multipart.rb#18
class Rack::Multipart::MissingInputError < ::StandardError
  include ::Rack::BadRequest
end

# source://rack//lib/rack/multipart/parser.rb#10
class Rack::Multipart::MultipartPartLimitError < ::Errno::EMFILE
  include ::Rack::BadRequest
end

# source://rack//lib/rack/multipart/parser.rb#14
class Rack::Multipart::MultipartTotalPartLimitError < ::StandardError
  include ::Rack::BadRequest
end

# Accumulator for multipart form data, conforming to the QueryParser API.
# In future, the Parser could return the pair list directly, but that would
# change its API.
#
# source://rack//lib/rack/multipart.rb#25
class Rack::Multipart::ParamList
  # @return [ParamList] a new instance of ParamList
  #
  # source://rack//lib/rack/multipart.rb#34
  def initialize; end

  # source://rack//lib/rack/multipart.rb#38
  def <<(pair); end

  # source://rack//lib/rack/multipart.rb#42
  def to_params_hash; end

  class << self
    # source://rack//lib/rack/multipart.rb#26
    def make_params; end

    # source://rack//lib/rack/multipart.rb#30
    def normalize_params(params, key, value); end
  end
end

# Rack::Multipart::Parser handles parsing of multipart/form-data requests.
#
# File Parameter Contents
#
# When processing file uploads, the parser returns a hash containing
# information about uploaded files. For +file+ parameters, the hash includes:
#
# * +:filename+ - The original filename, already URL decoded by the parser
# * +:type+ - The content type of the uploaded file
# * +:name+ - The parameter name from the form
# * +:tempfile+ - A Tempfile object containing the uploaded data
# * +:head+ - The raw header content for this part
#
# source://rack//lib/rack/multipart/parser.rb#53
class Rack::Multipart::Parser
  # @return [Parser] a new instance of Parser
  #
  # source://rack//lib/rack/multipart/parser.rb#235
  def initialize(boundary, tempfile, bufsize, query_parser); end

  # source://rack//lib/rack/multipart/parser.rb#254
  def parse(io); end

  # source://rack//lib/rack/multipart/parser.rb#277
  def result; end

  # Returns the value of attribute state.
  #
  # source://rack//lib/rack/multipart/parser.rb#233
  def state; end

  private

  # Scan until the we find the start or end of the boundary.
  # If we find it, return the appropriate symbol for the start or
  # end of the boundary.  If we don't find the start or end of the
  # boundary, clear the buffer and return nil.
  #
  # source://rack//lib/rack/multipart/parser.rb#493
  def consume_boundary; end

  # Return the related Encoding object. However, because
  # enc is submitted by the user, it may be invalid, so
  # use a binary encoding in that case.
  #
  # source://rack//lib/rack/multipart/parser.rb#548
  def find_encoding(enc); end

  # source://rack//lib/rack/multipart/parser.rb#330
  def handle_consume_token; end

  # source://rack//lib/rack/multipart/parser.rb#563
  def handle_dummy_encoding(name, body); end

  # source://rack//lib/rack/multipart/parser.rb#573
  def handle_empty_content!(content); end

  # This handles the initial parser state.  We read until we find the starting
  # boundary, then we can transition to the next state. If we find the ending
  # boundary, this is an invalid multipart upload, but keep scanning for opening
  # boundary in that case. If no boundary found, we need to keep reading data
  # and retry. It's highly unlikely the initial read will not consume the
  # boundary.  The client would have to deliberately craft a response
  # with the opening boundary beyond the buffer size for that to happen.
  #
  # source://rack//lib/rack/multipart/parser.rb#303
  def handle_fast_forward; end

  # source://rack//lib/rack/multipart/parser.rb#460
  def handle_mime_body; end

  # source://rack//lib/rack/multipart/parser.rb#342
  def handle_mime_head; end

  # source://rack//lib/rack/multipart/parser.rb#502
  def normalize_filename(filename); end

  # source://rack//lib/rack/multipart/parser.rb#290
  def read_data(io, outbuf); end

  # source://rack//lib/rack/multipart/parser.rb#515
  def tag_multipart_encoding(filename, content_type, name, body); end

  # source://rack//lib/rack/multipart/parser.rb#482
  def update_retained_size(size); end

  class << self
    # source://rack//lib/rack/multipart/parser.rb#122
    def parse(io, content_length, content_type, tmpfile, bufsize, qp); end

    # source://rack//lib/rack/multipart/parser.rb#115
    def parse_boundary(content_type); end
  end
end

# source://rack//lib/rack/multipart/parser.rb#62
Rack::Multipart::Parser::BOUNDARY_START_LIMIT = T.let(T.unsafe(nil), Integer)

# source://rack//lib/rack/multipart/parser.rb#80
Rack::Multipart::Parser::BUFFERED_UPLOAD_BYTESIZE_LIMIT = T.let(T.unsafe(nil), Integer)

# source://rack//lib/rack/multipart/parser.rb#54
Rack::Multipart::Parser::BUFSIZE = T.let(T.unsafe(nil), Integer)

# source://rack//lib/rack/multipart/parser.rb#83
class Rack::Multipart::Parser::BoundedIO
  # @return [BoundedIO] a new instance of BoundedIO
  #
  # source://rack//lib/rack/multipart/parser.rb#84
  def initialize(io, content_length); end

  # source://rack//lib/rack/multipart/parser.rb#90
  def read(size, outbuf = T.unsafe(nil)); end
end

# source://rack//lib/rack/multipart/parser.rb#512
Rack::Multipart::Parser::CHARSET = T.let(T.unsafe(nil), String)

# source://rack//lib/rack/multipart/parser.rb#341
Rack::Multipart::Parser::CONTENT_DISPOSITION_MAX_BYTES = T.let(T.unsafe(nil), Integer)

# source://rack//lib/rack/multipart/parser.rb#340
Rack::Multipart::Parser::CONTENT_DISPOSITION_MAX_PARAMS = T.let(T.unsafe(nil), Integer)

# source://rack//lib/rack/multipart/parser.rb#142
class Rack::Multipart::Parser::Collector
  include ::Enumerable

  # @return [Collector] a new instance of Collector
  #
  # source://rack//lib/rack/multipart/parser.rb#178
  def initialize(tempfile); end

  # source://rack//lib/rack/multipart/parser.rb#184
  def each; end

  # source://rack//lib/rack/multipart/parser.rb#204
  def on_mime_body(mime_index, content); end

  # source://rack//lib/rack/multipart/parser.rb#208
  def on_mime_finish(mime_index); end

  # source://rack//lib/rack/multipart/parser.rb#188
  def on_mime_head(mime_index, head, filename, content_type, name); end

  private

  # source://rack//lib/rack/multipart/parser.rb#213
  def check_part_limits; end
end

# source://rack//lib/rack/multipart/parser.rb#166
class Rack::Multipart::Parser::Collector::BufferPart < ::Rack::Multipart::Parser::Collector::MimePart
  # source://rack//lib/rack/multipart/parser.rb#168
  def close; end

  # @return [Boolean]
  #
  # source://rack//lib/rack/multipart/parser.rb#167
  def file?; end
end

# source://rack//lib/rack/multipart/parser.rb#143
class Rack::Multipart::Parser::Collector::MimePart < ::Struct
  # @yield [data]
  #
  # source://rack//lib/rack/multipart/parser.rb#144
  def get_data; end
end

# source://rack//lib/rack/multipart/parser.rb#171
class Rack::Multipart::Parser::Collector::TempfilePart < ::Rack::Multipart::Parser::Collector::MimePart
  # source://rack//lib/rack/multipart/parser.rb#173
  def close; end

  # @return [Boolean]
  #
  # source://rack//lib/rack/multipart/parser.rb#172
  def file?; end
end

# source://rack//lib/rack/multipart/parser.rb#113
Rack::Multipart::Parser::EMPTY = T.let(T.unsafe(nil), Rack::Multipart::Parser::MultipartInfo)

# source://rack//lib/rack/multipart/parser.rb#65
Rack::Multipart::Parser::MIME_HEADER_BYTESIZE_LIMIT = T.let(T.unsafe(nil), Integer)

# source://rack//lib/rack/multipart/parser.rb#112
class Rack::Multipart::Parser::MultipartInfo < ::Struct
  # Returns the value of attribute params
  #
  # @return [Object] the current value of params
  #
  # source://rack//lib/rack/multipart/parser.rb#112
  def params; end

  # Sets the attribute params
  #
  # @param value [Object] the value to set the attribute params to.
  # @return [Object] the newly set value
  #
  # source://rack//lib/rack/multipart/parser.rb#112
  def params=(_); end

  # Returns the value of attribute tmp_files
  #
  # @return [Object] the current value of tmp_files
  #
  # source://rack//lib/rack/multipart/parser.rb#112
  def tmp_files; end

  # Sets the attribute tmp_files
  #
  # @param value [Object] the value to set the attribute tmp_files to.
  # @return [Object] the newly set value
  #
  # source://rack//lib/rack/multipart/parser.rb#112
  def tmp_files=(_); end

  class << self
    # source://rack//lib/rack/multipart/parser.rb#112
    def [](*_arg0); end

    # source://rack//lib/rack/multipart/parser.rb#112
    def inspect; end

    # source://rack//lib/rack/multipart/parser.rb#112
    def keyword_init?; end

    # source://rack//lib/rack/multipart/parser.rb#112
    def members; end

    # source://rack//lib/rack/multipart/parser.rb#112
    def new(*_arg0); end
  end
end

# source://rack//lib/rack/multipart/parser.rb#554
Rack::Multipart::Parser::REENCODE_DUMMY_ENCODINGS = T.let(T.unsafe(nil), Hash)

# source://rack//lib/rack/multipart/parser.rb#56
Rack::Multipart::Parser::TEMPFILE_FACTORY = T.let(T.unsafe(nil), Proc)

# source://rack//lib/rack/multipart/parser.rb#55
Rack::Multipart::Parser::TEXT_PLAIN = T.let(T.unsafe(nil), String)

# Despite the misleading name, UploadedFile is designed for use for
# preparing multipart file upload bodies, generally for use in tests.
# It is not designed for and should not be used for handling uploaded
# files (there is no need for that, since Rack's multipart parser
# already creates Tempfiles for that). Using this with non-trusted
# filenames can create a security vulnerability.
#
# You should only use this class if you plan on passing the instances
# to Rack::MockRequest for use in creating multipart request bodies.
#
# UploadedFile delegates most methods to the tempfile it contains.
#
# source://rack//lib/rack/multipart/uploaded_file.rb#19
class Rack::Multipart::UploadedFile
  # Create a new UploadedFile.  For backwards compatibility, this accepts
  # both positional and keyword versions of the same arguments:
  #
  # filepath/path :: The path to the file
  # ct/content_type :: The content_type of the file
  # bin/binary :: Whether to set binmode on the file before copying data into it.
  #
  # If both positional and keyword arguments are present, the keyword arguments
  # take precedence.
  #
  # The following keyword-only arguments are also accepted:
  #
  # filename :: Override the filename to use for the file.  This is so the
  #             filename for the upload does not need to match the basename of
  #             the file path.  This should not contain slashes, unless you are
  #             trying to test how an application handles invalid filenames in
  #             multipart upload bodies.
  # io :: Use the given IO-like instance as the tempfile, instead of creating
  #       a Tempfile instance.  This is useful for building multipart file
  #       upload bodies without a file being present on the filesystem. If you are
  #       providing this, you should also provide the filename argument.
  #
  # @return [UploadedFile] a new instance of UploadedFile
  #
  # source://rack//lib/rack/multipart/uploaded_file.rb#49
  def initialize(filepath = T.unsafe(nil), ct = T.unsafe(nil), bin = T.unsafe(nil), path: T.unsafe(nil), content_type: T.unsafe(nil), binary: T.unsafe(nil), filename: T.unsafe(nil), io: T.unsafe(nil)); end

  # The content type of the instance.
  #
  # source://rack//lib/rack/multipart/uploaded_file.rb#26
  def content_type; end

  # The content type of the instance.
  #
  # source://rack//lib/rack/multipart/uploaded_file.rb#26
  def content_type=(_arg0); end

  # The path of the tempfile for the instance, if the tempfile has a path.
  # nil if the tempfile does not have a path.
  #
  # source://rack//lib/rack/multipart/uploaded_file.rb#69
  def local_path; end

  # Delegate method missing calls to the tempfile.
  #
  # source://rack//lib/rack/multipart/uploaded_file.rb#77
  def method_missing(method_name, *args, &block); end

  # The provided name of the file. This generally is the basename of
  # path provided during initialization, but it can contain slashes if they
  # were present in the filename argument when the instance was created.
  #
  # source://rack//lib/rack/multipart/uploaded_file.rb#23
  def original_filename; end

  # The path of the tempfile for the instance, if the tempfile has a path.
  # nil if the tempfile does not have a path.
  #
  # source://rack//lib/rack/multipart/uploaded_file.rb#66
  def path; end

  private

  # Return true if the tempfile responds to the method.
  #
  # @return [Boolean]
  #
  # source://rack//lib/rack/multipart/uploaded_file.rb#72
  def respond_to_missing?(*args); end
end

# source://rack//lib/rack/null_logger.rb#6
class Rack::NullLogger
  # @return [NullLogger] a new instance of NullLogger
  #
  # source://rack//lib/rack/null_logger.rb#7
  def initialize(app); end

  # source://rack//lib/rack/null_logger.rb#45
  def <<(msg); end

  # source://rack//lib/rack/null_logger.rb#43
  def add(severity, message = T.unsafe(nil), progname = T.unsafe(nil), &block); end

  # source://rack//lib/rack/null_logger.rb#11
  def call(env); end

  # source://rack//lib/rack/null_logger.rb#42
  def close; end

  # source://rack//lib/rack/null_logger.rb#34
  def datetime_format; end

  # source://rack//lib/rack/null_logger.rb#39
  def datetime_format=(datetime_format); end

  # source://rack//lib/rack/null_logger.rb#17
  def debug(progname = T.unsafe(nil), &block); end

  # source://rack//lib/rack/null_logger.rb#27
  def debug!; end

  # @return [Boolean]
  #
  # source://rack//lib/rack/null_logger.rb#23
  def debug?; end

  # source://rack//lib/rack/null_logger.rb#19
  def error(progname = T.unsafe(nil), &block); end

  # source://rack//lib/rack/null_logger.rb#28
  def error!; end

  # @return [Boolean]
  #
  # source://rack//lib/rack/null_logger.rb#25
  def error?; end

  # source://rack//lib/rack/null_logger.rb#20
  def fatal(progname = T.unsafe(nil), &block); end

  # source://rack//lib/rack/null_logger.rb#29
  def fatal!; end

  # @return [Boolean]
  #
  # source://rack//lib/rack/null_logger.rb#26
  def fatal?; end

  # source://rack//lib/rack/null_logger.rb#35
  def formatter; end

  # source://rack//lib/rack/null_logger.rb#40
  def formatter=(formatter); end

  # source://rack//lib/rack/null_logger.rb#16
  def info(progname = T.unsafe(nil), &block); end

  # source://rack//lib/rack/null_logger.rb#30
  def info!; end

  # @return [Boolean]
  #
  # source://rack//lib/rack/null_logger.rb#22
  def info?; end

  # source://rack//lib/rack/null_logger.rb#32
  def level; end

  # source://rack//lib/rack/null_logger.rb#37
  def level=(level); end

  # source://rack//lib/rack/null_logger.rb#44
  def log(severity, message = T.unsafe(nil), progname = T.unsafe(nil), &block); end

  # source://rack//lib/rack/null_logger.rb#33
  def progname; end

  # source://rack//lib/rack/null_logger.rb#38
  def progname=(progname); end

  # source://rack//lib/rack/null_logger.rb#46
  def reopen(logdev = T.unsafe(nil)); end

  # source://rack//lib/rack/null_logger.rb#36
  def sev_threshold; end

  # source://rack//lib/rack/null_logger.rb#41
  def sev_threshold=(sev_threshold); end

  # source://rack//lib/rack/null_logger.rb#21
  def unknown(progname = T.unsafe(nil), &block); end

  # source://rack//lib/rack/null_logger.rb#18
  def warn(progname = T.unsafe(nil), &block); end

  # source://rack//lib/rack/null_logger.rb#31
  def warn!; end

  # @return [Boolean]
  #
  # source://rack//lib/rack/null_logger.rb#24
  def warn?; end
end

# source://rack//lib/rack/constants.rb#34
Rack::OPTIONS = T.let(T.unsafe(nil), String)

# source://rack//lib/rack/constants.rb#31
Rack::PATCH = T.let(T.unsafe(nil), String)

# source://rack//lib/rack/constants.rb#8
Rack::PATH_INFO = T.let(T.unsafe(nil), String)

# source://rack//lib/rack/constants.rb#29
Rack::POST = T.let(T.unsafe(nil), String)

# source://rack//lib/rack/constants.rb#30
Rack::PUT = T.let(T.unsafe(nil), String)

# source://rack//lib/rack/constants.rb#12
Rack::QUERY_STRING = T.let(T.unsafe(nil), String)

# source://rack//lib/rack/query_parser.rb#7
class Rack::QueryParser
  # @return [QueryParser] a new instance of QueryParser
  #
  # source://rack//lib/rack/query_parser.rb#62
  def initialize(params_class, param_depth_limit, bytesize_limit: T.unsafe(nil), params_limit: T.unsafe(nil)); end

  # Returns the value of attribute bytesize_limit.
  #
  # source://rack//lib/rack/query_parser.rb#60
  def bytesize_limit; end

  # source://rack//lib/rack/query_parser.rb#196
  def make_params; end

  # source://rack//lib/rack/query_parser.rb#200
  def new_depth_limit(param_depth_limit); end

  # normalize_params recursively expands parameters into structural types. If
  # the structural types represented by two different parameter names are in
  # conflict, a ParameterTypeError is raised.  The depth argument is deprecated
  # and should no longer be used, it is kept for backwards compatibility with
  # earlier versions of rack.
  #
  # source://rack//lib/rack/query_parser.rb#124
  def normalize_params(params, name, v, _depth = T.unsafe(nil)); end

  # Returns the value of attribute param_depth_limit.
  #
  # source://rack//lib/rack/query_parser.rb#40
  def param_depth_limit; end

  # parse_nested_query expands a query string into structural types. Supported
  # types are Arrays, Hashes and basic value types. It is possible to supply
  # query strings with parameters of conflicting types, in this case a
  # ParameterTypeError is raised. Users are encouraged to return a 400 in this
  # case.
  #
  # source://rack//lib/rack/query_parser.rb#109
  def parse_nested_query(qs, separator = T.unsafe(nil)); end

  # Stolen from Mongrel, with some small modifications:
  # Parses a query string by breaking it up at the '&'.  You can also use this
  # to parse cookies by changing the characters used in the second parameter
  # (which defaults to '&').
  #
  # source://rack//lib/rack/query_parser.rb#73
  def parse_query(qs, separator = T.unsafe(nil), &unescaper); end

  # Parses a query string by breaking it up at the '&', returning all key-value
  # pairs as an array of [key, value] arrays. Unlike parse_query, this preserves
  # all duplicate keys rather than collapsing them.
  #
  # source://rack//lib/rack/query_parser.rb#94
  def parse_query_pairs(qs, separator = T.unsafe(nil)); end

  private

  # @raise [ParamsTooDeepError]
  #
  # source://rack//lib/rack/query_parser.rb#128
  def _normalize_params(params, name, v, depth); end

  # source://rack//lib/rack/query_parser.rb#222
  def each_query_pair(qs, separator, unescaper = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://rack//lib/rack/query_parser.rb#210
  def params_hash_has_key?(hash, key); end

  # @return [Boolean]
  #
  # source://rack//lib/rack/query_parser.rb#206
  def params_hash_type?(obj); end

  # source://rack//lib/rack/query_parser.rb#253
  def unescape(string, encoding = T.unsafe(nil)); end

  class << self
    # source://rack//lib/rack/query_parser.rb#36
    def make_default(param_depth_limit, **options); end
  end
end

# source://rack//lib/rack/query_parser.rb#54
Rack::QueryParser::BYTESIZE_LIMIT = T.let(T.unsafe(nil), Integer)

# source://rack//lib/rack/query_parser.rb#9
Rack::QueryParser::COMMON_SEP = T.let(T.unsafe(nil), Hash)

# source://rack//lib/rack/query_parser.rb#8
Rack::QueryParser::DEFAULT_SEP = T.let(T.unsafe(nil), Regexp)

# InvalidParameterError is the error that is raised when incoming structural
# parameters (parsed by parse_nested_query) contain invalid format or byte
# sequence.
#
# source://rack//lib/rack/query_parser.rb#20
class Rack::QueryParser::InvalidParameterError < ::ArgumentError
  include ::Rack::BadRequest
end

# source://rack//lib/rack/query_parser.rb#57
Rack::QueryParser::PARAMS_LIMIT = T.let(T.unsafe(nil), Integer)

# ParameterTypeError is the error that is raised when incoming structural
# parameters (parsed by parse_nested_query) contain conflicting types.
#
# source://rack//lib/rack/query_parser.rb#13
class Rack::QueryParser::ParameterTypeError < ::TypeError
  include ::Rack::BadRequest
end

# source://rack//lib/rack/query_parser.rb#257
class Rack::QueryParser::Params < ::Hash
  # source://rack//lib/rack/query_parser.rb#258
  def to_params_hash; end
end

# ParamsTooDeepError is the old name for the error that is raised when params
# are recursively nested over the specified limit. Make it the same as
# as QueryLimitError, so that code that rescues ParamsTooDeepError error
# to handle bad query strings also now handles other limits.
#
# source://rack//lib/rack/query_parser.rb#34
Rack::QueryParser::ParamsTooDeepError = Rack::QueryParser::QueryLimitError

# QueryLimitError is for errors raised when the query provided exceeds one
# of the query parser limits.
#
# source://rack//lib/rack/query_parser.rb#26
class Rack::QueryParser::QueryLimitError < ::RangeError
  include ::Rack::BadRequest
end

# source://rack//lib/rack/constants.rb#43
Rack::RACK_EARLY_HINTS = T.let(T.unsafe(nil), String)

# source://rack//lib/rack/constants.rb#44
Rack::RACK_ERRORS = T.let(T.unsafe(nil), String)

# source://rack//lib/rack/constants.rb#51
Rack::RACK_HIJACK = T.let(T.unsafe(nil), String)

# source://rack//lib/rack/constants.rb#46
Rack::RACK_INPUT = T.let(T.unsafe(nil), String)

# source://rack//lib/rack/constants.rb#52
Rack::RACK_IS_HIJACK = T.let(T.unsafe(nil), String)

# source://rack//lib/rack/constants.rb#45
Rack::RACK_LOGGER = T.let(T.unsafe(nil), String)

# source://rack//lib/rack/constants.rb#67
Rack::RACK_METHODOVERRIDE_ORIGINAL_METHOD = T.let(T.unsafe(nil), String)

# source://rack//lib/rack/constants.rb#54
Rack::RACK_MULTIPART_BUFFER_SIZE = T.let(T.unsafe(nil), String)

# source://rack//lib/rack/constants.rb#55
Rack::RACK_MULTIPART_TEMPFILE_FACTORY = T.let(T.unsafe(nil), String)

# source://rack//lib/rack/constants.rb#57
Rack::RACK_PROTOCOL = T.let(T.unsafe(nil), String)

# source://rack//lib/rack/constants.rb#53
Rack::RACK_RECURSIVE_INCLUDE = T.let(T.unsafe(nil), String)

# source://rack//lib/rack/constants.rb#63
Rack::RACK_REQUEST_COOKIE_HASH = T.let(T.unsafe(nil), String)

# source://rack//lib/rack/constants.rb#64
Rack::RACK_REQUEST_COOKIE_STRING = T.let(T.unsafe(nil), String)

# source://rack//lib/rack/constants.rb#62
Rack::RACK_REQUEST_FORM_ERROR = T.let(T.unsafe(nil), String)

# source://rack//lib/rack/constants.rb#59
Rack::RACK_REQUEST_FORM_HASH = T.let(T.unsafe(nil), String)

# source://rack//lib/rack/constants.rb#58
Rack::RACK_REQUEST_FORM_INPUT = T.let(T.unsafe(nil), String)

# source://rack//lib/rack/constants.rb#60
Rack::RACK_REQUEST_FORM_PAIRS = T.let(T.unsafe(nil), String)

# source://rack//lib/rack/constants.rb#61
Rack::RACK_REQUEST_FORM_VARS = T.let(T.unsafe(nil), String)

# source://rack//lib/rack/constants.rb#65
Rack::RACK_REQUEST_QUERY_HASH = T.let(T.unsafe(nil), String)

# source://rack//lib/rack/constants.rb#66
Rack::RACK_REQUEST_QUERY_STRING = T.let(T.unsafe(nil), String)

# source://rack//lib/rack/constants.rb#56
Rack::RACK_RESPONSE_FINISHED = T.let(T.unsafe(nil), String)

# source://rack//lib/rack/constants.rb#47
Rack::RACK_SESSION = T.let(T.unsafe(nil), String)

# source://rack//lib/rack/constants.rb#48
Rack::RACK_SESSION_OPTIONS = T.let(T.unsafe(nil), String)

# source://rack//lib/rack/constants.rb#49
Rack::RACK_SHOWSTATUS_DETAIL = T.let(T.unsafe(nil), String)

# source://rack//lib/rack/constants.rb#42
Rack::RACK_TEMPFILES = T.let(T.unsafe(nil), String)

# source://rack//lib/rack/constants.rb#50
Rack::RACK_URL_SCHEME = T.let(T.unsafe(nil), String)

# Rack environment variables
#
# source://rack//lib/rack/constants.rb#41
Rack::RACK_VERSION = T.let(T.unsafe(nil), String)

# source://rack//lib/rack/version.rb#11
Rack::RELEASE = T.let(T.unsafe(nil), String)

# source://rack//lib/rack/constants.rb#9
Rack::REQUEST_METHOD = T.let(T.unsafe(nil), String)

# source://rack//lib/rack/constants.rb#10
Rack::REQUEST_PATH = T.let(T.unsafe(nil), String)

# Rack::Recursive allows applications called down the chain to
# include data from other applications (by using
# <tt>rack['rack.recursive.include'][...]</tt> or raise a
# ForwardRequest to redirect internally.
#
# source://rack//lib/rack/recursive.rb#36
class Rack::Recursive
  # @return [Recursive] a new instance of Recursive
  #
  # source://rack//lib/rack/recursive.rb#37
  def initialize(app); end

  # source://rack//lib/rack/recursive.rb#45
  def _call(env); end

  # source://rack//lib/rack/recursive.rb#41
  def call(env); end

  # source://rack//lib/rack/recursive.rb#52
  def include(env, path); end
end

# High performant source reloader
#
# This class acts as Rack middleware.
#
# What makes it especially suited for use in a production environment is that
# any file will only be checked once and there will only be made one system
# call stat(2).
#
# Please note that this will not reload files in the background, it does so
# only when actively called.
#
# It is performing a check/reload cycle at the start of every request, but
# also respects a cool down time, during which nothing will be done.
#
# source://rack//lib/rack/reloader.rb#24
class Rack::Reloader
  # @return [Reloader] a new instance of Reloader
  #
  # source://rack//lib/rack/reloader.rb#25
  def initialize(app, cooldown = T.unsafe(nil), backend = T.unsafe(nil)); end

  # source://rack//lib/rack/reloader.rb#36
  def call(env); end

  # source://rack//lib/rack/reloader.rb#50
  def reload!(stderr = T.unsafe(nil)); end

  # A safe Kernel::load, issuing the hooks depending on the results
  #
  # source://rack//lib/rack/reloader.rb#58
  def safe_load(file, mtime, stderr = T.unsafe(nil)); end
end

# source://rack//lib/rack/reloader.rb#68
module Rack::Reloader::Stat
  # Takes a relative or absolute +file+ name, a couple possible +paths+ that
  # the +file+ might reside in. Returns the full path and File::Stat for the
  # path.
  #
  # source://rack//lib/rack/reloader.rb#88
  def figure_path(file, paths); end

  # source://rack//lib/rack/reloader.rb#69
  def rotation; end

  # source://rack//lib/rack/reloader.rb#103
  def safe_stat(file); end
end

# Rack::Request provides a convenient interface to a Rack
# environment.  It is stateless, the environment +env+ passed to the
# constructor will be directly modified.
#
#   req = Rack::Request.new(env)
#   req.post?
#   req.params["data"]
#
# source://rack//lib/rack/request.rb#16
class Rack::Request
  include ::Rack::Request::Env
  include ::Rack::Request::Helpers

  # @return [Request] a new instance of Request
  #
  # source://rack//lib/rack/request.rb#62
  def initialize(env); end

  # source://rack//lib/rack/request.rb#81
  def delete_param(k); end

  # source://rack//lib/rack/request.rb#68
  def ip; end

  # source://rack//lib/rack/request.rb#72
  def params; end

  # source://rack//lib/rack/request.rb#76
  def update_param(k, v); end

  class << self
    # The priority when checking forwarded headers. The default
    # is <tt>[:forwarded, :x_forwarded]</tt>, which means, check the
    # +Forwarded+ header first, followed by the appropriate
    # <tt>X-Forwarded-*</tt> header.  You can revert the priority by
    # reversing the priority, or remove checking of either
    # or both headers by removing elements from the array.
    #
    # This should be set as appropriate in your environment
    # based on what reverse proxies are in use.  If you are not
    # using reverse proxies, you should probably use an empty
    # array.
    #
    # source://rack//lib/rack/request.rb#31
    def forwarded_priority; end

    # The priority when checking forwarded headers. The default
    # is <tt>[:forwarded, :x_forwarded]</tt>, which means, check the
    # +Forwarded+ header first, followed by the appropriate
    # <tt>X-Forwarded-*</tt> header.  You can revert the priority by
    # reversing the priority, or remove checking of either
    # or both headers by removing elements from the array.
    #
    # This should be set as appropriate in your environment
    # based on what reverse proxies are in use.  If you are not
    # using reverse proxies, you should probably use an empty
    # array.
    #
    # source://rack//lib/rack/request.rb#31
    def forwarded_priority=(_arg0); end

    # Returns the value of attribute ip_filter.
    #
    # source://rack//lib/rack/request.rb#18
    def ip_filter; end

    # Sets the attribute ip_filter
    #
    # @param value the value to set the attribute ip_filter to.
    #
    # source://rack//lib/rack/request.rb#18
    def ip_filter=(_arg0); end

    # The priority when checking either the <tt>X-Forwarded-Proto</tt>
    # or <tt>X-Forwarded-Scheme</tt> header for the forwarded protocol.
    # The default is <tt>[:proto, :scheme]</tt>, to try the
    # <tt>X-Forwarded-Proto</tt> header before the
    # <tt>X-Forwarded-Scheme</tt> header.  Rack 2 had behavior
    # similar to <tt>[:scheme, :proto]</tt>.  You can remove either or
    # both of the entries in array to ignore that respective header.
    #
    # source://rack//lib/rack/request.rb#40
    def x_forwarded_proto_priority; end

    # The priority when checking either the <tt>X-Forwarded-Proto</tt>
    # or <tt>X-Forwarded-Scheme</tt> header for the forwarded protocol.
    # The default is <tt>[:proto, :scheme]</tt>, to try the
    # <tt>X-Forwarded-Proto</tt> header before the
    # <tt>X-Forwarded-Scheme</tt> header.  Rack 2 had behavior
    # similar to <tt>[:scheme, :proto]</tt>.  You can remove either or
    # both of the entries in array to ignore that respective header.
    #
    # source://rack//lib/rack/request.rb#40
    def x_forwarded_proto_priority=(_arg0); end
  end
end

# source://rack//lib/rack/request.rb#60
Rack::Request::ALLOWED_SCHEMES = T.let(T.unsafe(nil), Array)

# source://rack//lib/rack/request.rb#87
module Rack::Request::Env
  # source://rack//lib/rack/request.rb#91
  def initialize(env); end

  # Add a header that may have multiple values.
  #
  # Example:
  #   request.add_header 'Accept', 'image/png'
  #   request.add_header 'Accept', '*/*'
  #
  #   assert_equal 'image/png,*/*', request.get_header('Accept')
  #
  # http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.2
  #
  # source://rack//lib/rack/request.rb#134
  def add_header(key, v); end

  # Delete a request specific value for `name`.
  #
  # source://rack//lib/rack/request.rb#145
  def delete_header(name); end

  # Loops through each key / value pair in the request specific data.
  #
  # source://rack//lib/rack/request.rb#116
  def each_header(&block); end

  # The environment of the request.
  #
  # source://rack//lib/rack/request.rb#89
  def env; end

  # If a block is given, it yields to the block if the value hasn't been set
  # on the request.
  #
  # source://rack//lib/rack/request.rb#111
  def fetch_header(name, &block); end

  # Get a request specific value for `name`.
  #
  # source://rack//lib/rack/request.rb#105
  def get_header(name); end

  # Predicate method to test to see if `name` has been set as request
  # specific data
  #
  # @return [Boolean]
  #
  # source://rack//lib/rack/request.rb#100
  def has_header?(name); end

  # Set a request specific value for `name` to `v`
  #
  # source://rack//lib/rack/request.rb#121
  def set_header(name, v); end

  private

  # source://rack//lib/rack/request.rb#149
  def initialize_copy(other); end
end

# source://rack//lib/rack/request.rb#154
module Rack::Request::Helpers
  # Returns the data received in the query string.
  #
  # source://rack//lib/rack/request.rb#491
  def GET; end

  # Returns the data received in the request body.
  #
  # This method support both application/x-www-form-urlencoded and
  # multipart/form-data.
  #
  # source://rack//lib/rack/request.rb#542
  def POST; end

  # source://rack//lib/rack/request.rb#611
  def accept_encoding; end

  # source://rack//lib/rack/request.rb#615
  def accept_language; end

  # The authority of the incoming request as defined by RFC3976.
  # https://tools.ietf.org/html/rfc3986#section-3.2
  #
  # In HTTP/1, this is the `host` header.
  # In HTTP/2, this is the `:authority` pseudo-header.
  #
  # source://rack//lib/rack/request.rb#271
  def authority; end

  # source://rack//lib/rack/request.rb#594
  def base_url; end

  # source://rack//lib/rack/request.rb#195
  def body; end

  # The character set of the request body if a "charset" media type
  # parameter was given, or nil if no "charset" was specified. Note
  # that, per RFC2616, text/* media types that specify no explicit
  # charset are to be considered ISO-8859-1.
  #
  # source://rack//lib/rack/request.rb#465
  def content_charset; end

  # source://rack//lib/rack/request.rb#204
  def content_length; end

  # source://rack//lib/rack/request.rb#313
  def content_type; end

  # source://rack//lib/rack/request.rb#298
  def cookies; end

  # Checks the HTTP request method (or verb) to see if it was of type DELETE
  #
  # @return [Boolean]
  #
  # source://rack//lib/rack/request.rb#225
  def delete?; end

  # Destructively delete a parameter, whether it's in GET or POST. Returns the value of the deleted parameter.
  #
  # If the parameter is in both GET and POST, the POST value takes precedence since that's how #params works.
  #
  # <tt>env['rack.input']</tt> is not touched.
  #
  # source://rack//lib/rack/request.rb#589
  def delete_param(k); end

  # Determine whether the request body contains form-data by checking
  # the request content-type for one of the media-types:
  # "application/x-www-form-urlencoded" or "multipart/form-data". The
  # list of form-data media types can be modified through the
  # +FORM_DATA_MEDIA_TYPES+ array.
  #
  # A request body is also assumed to contain form-data when no
  # content-type header is provided and the request_method is POST.
  #
  # @return [Boolean]
  #
  # source://rack//lib/rack/request.rb#477
  def form_data?; end

  # Returns the form data pairs received in the request body.
  #
  # This method support both application/x-www-form-urlencoded and
  # multipart/form-data.
  #
  # source://rack//lib/rack/request.rb#499
  def form_pairs; end

  # source://rack//lib/rack/request.rb#398
  def forwarded_authority; end

  # source://rack//lib/rack/request.rb#358
  def forwarded_for; end

  # source://rack//lib/rack/request.rb#379
  def forwarded_port; end

  # source://rack//lib/rack/request.rb#607
  def fullpath; end

  # Checks the HTTP request method (or verb) to see if it was of type GET
  #
  # @return [Boolean]
  #
  # source://rack//lib/rack/request.rb#228
  def get?; end

  # Checks the HTTP request method (or verb) to see if it was of type HEAD
  #
  # @return [Boolean]
  #
  # source://rack//lib/rack/request.rb#231
  def head?; end

  # Returns a formatted host, suitable for being used in a URI.
  #
  # source://rack//lib/rack/request.rb#338
  def host; end

  # The `HTTP_HOST` header.
  #
  # source://rack//lib/rack/request.rb#323
  def host_authority; end

  # source://rack//lib/rack/request.rb#327
  def host_with_port(authority = T.unsafe(nil)); end

  # Returns an address suitable for being to resolve to an address.
  # In the case of a domain name or IPv4 address, the result is the same
  # as +host+. In the case of IPv6 or future address formats, the square
  # brackets are removed.
  #
  # source://rack//lib/rack/request.rb#346
  def hostname; end

  # source://rack//lib/rack/request.rb#419
  def ip; end

  # Checks the HTTP request method (or verb) to see if it was of type LINK
  #
  # @return [Boolean]
  #
  # source://rack//lib/rack/request.rb#237
  def link?; end

  # source://rack//lib/rack/request.rb#205
  def logger; end

  # The media type (type/subtype) portion of the CONTENT_TYPE header
  # without any media type parameters. e.g., when CONTENT_TYPE is
  # "text/plain;charset=utf-8", the media-type is "text/plain".
  #
  # For more information on the use of media types in HTTP, see:
  # http://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.7
  #
  # source://rack//lib/rack/request.rb#448
  def media_type; end

  # The media type parameters provided in CONTENT_TYPE as a Hash, or
  # an empty Hash if no CONTENT_TYPE or media-type parameters were
  # provided.  e.g., when the CONTENT_TYPE is "text/plain;charset=utf-8",
  # this method responds with the following Hash:
  #   { 'charset' => 'utf-8' }
  #
  # source://rack//lib/rack/request.rb#457
  def media_type_params; end

  # Checks the HTTP request method (or verb) to see if it was of type OPTIONS
  #
  # @return [Boolean]
  #
  # source://rack//lib/rack/request.rb#234
  def options?; end

  # The union of GET and POST data.
  #
  # Note that modifications will not be persisted in the env. Use update_param or delete_param if you want to destructively modify params.
  #
  # source://rack//lib/rack/request.rb#556
  def params; end

  # Determine whether the request body contains data by checking
  # the request media_type against registered parse-data media-types
  #
  # @return [Boolean]
  #
  # source://rack//lib/rack/request.rb#486
  def parseable_data?; end

  # Checks the HTTP request method (or verb) to see if it was of type PATCH
  #
  # @return [Boolean]
  #
  # source://rack//lib/rack/request.rb#240
  def patch?; end

  # source://rack//lib/rack/request.rb#603
  def path; end

  # source://rack//lib/rack/request.rb#199
  def path_info; end

  # source://rack//lib/rack/request.rb#200
  def path_info=(s); end

  # source://rack//lib/rack/request.rb#350
  def port; end

  # Checks the HTTP request method (or verb) to see if it was of type POST
  #
  # @return [Boolean]
  #
  # source://rack//lib/rack/request.rb#243
  def post?; end

  # Checks the HTTP request method (or verb) to see if it was of type PUT
  #
  # @return [Boolean]
  #
  # source://rack//lib/rack/request.rb#246
  def put?; end

  # Allow overriding the query parser that the receiver will use.
  # By default Rack::Utils.default_query_parser is used.
  #
  # source://rack//lib/rack/request.rb#562
  def query_parser=(_arg0); end

  # source://rack//lib/rack/request.rb#203
  def query_string; end

  # the referer of the client
  #
  # source://rack//lib/rack/request.rb#209
  def referer; end

  # the referer of the client
  #
  # source://rack//lib/rack/request.rb#210
  def referrer; end

  # source://rack//lib/rack/request.rb#202
  def request_method; end

  # source://rack//lib/rack/request.rb#254
  def scheme; end

  # source://rack//lib/rack/request.rb#196
  def script_name; end

  # source://rack//lib/rack/request.rb#197
  def script_name=(s); end

  # The authority as defined by the `SERVER_NAME` and `SERVER_PORT`
  # variables.
  #
  # source://rack//lib/rack/request.rb#277
  def server_authority; end

  # source://rack//lib/rack/request.rb#290
  def server_name; end

  # source://rack//lib/rack/request.rb#294
  def server_port; end

  # source://rack//lib/rack/request.rb#212
  def session; end

  # source://rack//lib/rack/request.rb#218
  def session_options; end

  # @return [Boolean]
  #
  # source://rack//lib/rack/request.rb#415
  def ssl?; end

  # Checks the HTTP request method (or verb) to see if it was of type TRACE
  #
  # @return [Boolean]
  #
  # source://rack//lib/rack/request.rb#249
  def trace?; end

  # @return [Boolean]
  #
  # source://rack//lib/rack/request.rb#619
  def trusted_proxy?(ip); end

  # Checks the HTTP request method (or verb) to see if it was of type UNLINK
  #
  # @return [Boolean]
  #
  # source://rack//lib/rack/request.rb#252
  def unlink?; end

  # Destructively update a parameter, whether it's in GET and/or POST. Returns nil.
  #
  # The parameter is updated wherever it was previous defined, so GET, POST, or both. If it wasn't previously defined, it's inserted into GET.
  #
  # <tt>env['rack.input']</tt> is not touched.
  #
  # source://rack//lib/rack/request.rb#569
  def update_param(k, v); end

  # Tries to return a remake of the original request URL as a string.
  #
  # source://rack//lib/rack/request.rb#599
  def url; end

  # source://rack//lib/rack/request.rb#206
  def user_agent; end

  # @return [Boolean]
  #
  # source://rack//lib/rack/request.rb#318
  def xhr?; end

  private

  # source://rack//lib/rack/request.rb#770
  def allowed_scheme(header); end

  # source://rack//lib/rack/request.rb#625
  def default_session; end

  # source://rack//lib/rack/request.rb#682
  def expand_param_pairs(pairs, query_parser = T.unsafe(nil)); end

  # source://rack//lib/rack/request.rb#774
  def forwarded_priority; end

  # source://rack//lib/rack/request.rb#746
  def forwarded_scheme; end

  # Get an array of values set in the RFC 7239 `Forwarded` request header.
  #
  # source://rack//lib/rack/request.rb#665
  def get_http_forwarded(token); end

  # source://rack//lib/rack/request.rb#641
  def parse_http_accept_header(header); end

  # source://rack//lib/rack/request.rb#677
  def parse_multipart; end

  # source://rack//lib/rack/request.rb#673
  def parse_query(qs, d = T.unsafe(nil)); end

  # source://rack//lib/rack/request.rb#669
  def query_parser; end

  # source://rack//lib/rack/request.rb#735
  def split_authority(authority); end

  # source://rack//lib/rack/request.rb#692
  def split_header(value); end

  # Assist with compatibility when processing `X-Forwarded-For`.
  #
  # source://rack//lib/rack/request.rb#628
  def wrap_ipv6(host); end

  # source://rack//lib/rack/request.rb#778
  def x_forwarded_proto_priority; end
end

# source://rack//lib/rack/request.rb#720
Rack::Request::Helpers::AUTHORITY = T.let(T.unsafe(nil), Regexp)

# Default ports depending on scheme. Used to decide whether or not
# to include the port in a generated URI.
#
# source://rack//lib/rack/request.rb#173
Rack::Request::Helpers::DEFAULT_PORTS = T.let(T.unsafe(nil), Hash)

# The set of form-data media-types. Requests that do not indicate
# one of the media types present in this list will not be eligible
# for form-data / param parsing.
#
# source://rack//lib/rack/request.rb#158
Rack::Request::Helpers::FORM_DATA_MEDIA_TYPES = T.let(T.unsafe(nil), Array)

# source://rack//lib/rack/request.rb#741
Rack::Request::Helpers::FORWARDED_SCHEME_HEADERS = T.let(T.unsafe(nil), Hash)

# source://rack//lib/rack/request.rb#181
Rack::Request::Helpers::HTTP_FORWARDED = T.let(T.unsafe(nil), String)

# The address of the client which connected to the proxy.
#
# source://rack//lib/rack/request.rb#176
Rack::Request::Helpers::HTTP_X_FORWARDED_FOR = T.let(T.unsafe(nil), String)

# The contents of the host/:authority header sent to the proxy.
#
# source://rack//lib/rack/request.rb#179
Rack::Request::Helpers::HTTP_X_FORWARDED_HOST = T.let(T.unsafe(nil), String)

# The port used to connect to the proxy.
#
# source://rack//lib/rack/request.rb#190
Rack::Request::Helpers::HTTP_X_FORWARDED_PORT = T.let(T.unsafe(nil), String)

# The protocol used to connect to the proxy.
#
# source://rack//lib/rack/request.rb#187
Rack::Request::Helpers::HTTP_X_FORWARDED_PROTO = T.let(T.unsafe(nil), String)

# The value of the scheme sent to the proxy.
#
# source://rack//lib/rack/request.rb#184
Rack::Request::Helpers::HTTP_X_FORWARDED_SCHEME = T.let(T.unsafe(nil), String)

# Another way for specifying https scheme was used.
#
# source://rack//lib/rack/request.rb#193
Rack::Request::Helpers::HTTP_X_FORWARDED_SSL = T.let(T.unsafe(nil), String)

# The set of media-types. Requests that do not indicate
# one of the media types present in this list will not be eligible
# for param parsing like soap attachments or generic multiparts
#
# source://rack//lib/rack/request.rb#166
Rack::Request::Helpers::PARSEABLE_DATA_MEDIA_TYPES = T.let(T.unsafe(nil), Array)

# Rack::Response provides a convenient interface to create a Rack
# response.
#
# It allows setting of headers and cookies, and provides useful
# defaults (an OK response with empty headers and body).
#
# You can use Response#write to iteratively generate your response,
# but note that this is buffered by Rack::Response until you call
# +finish+.  +finish+ however can take a block inside which calls to
# +write+ are synchronous with the Rack response.
#
# Your application's +call+ should end returning Response#finish.
#
# source://rack//lib/rack/response.rb#23
class Rack::Response
  include ::Rack::Response::Helpers

  # Initialize the response object with the specified +body+, +status+
  # and +headers+.
  #
  # If the +body+ is +nil+, construct an empty response object with internal
  # buffering.
  #
  # If the +body+ responds to +to_str+, assume it's a string-like object and
  # construct a buffered response object containing using that string as the
  # initial contents of the buffer.
  #
  # Otherwise it is expected +body+ conforms to the normal requirements of a
  # Rack response body, typically implementing one of +each+ (enumerable
  # body) or +call+ (streaming body).
  #
  # The +status+ defaults to +200+ which is the "OK" HTTP status code. You
  # can provide any other valid status code.
  #
  # The +headers+ must be a +Hash+ of key-value header pairs which conform to
  # the Rack specification for response headers. The key must be a +String+
  # instance and the value can be either a +String+ or +Array+ instance.
  #
  # @return [Response] a new instance of Response
  # @yield [_self]
  # @yieldparam _self [Rack::Response] the object that the method was called on
  #
  # source://rack//lib/rack/response.rb#54
  def initialize(body = T.unsafe(nil), status = T.unsafe(nil), headers = T.unsafe(nil)); end

  # @raise [ArgumentError]
  #
  # source://rack//lib/rack/response.rb#177
  def [](key); end

  # @raise [ArgumentError]
  #
  # source://rack//lib/rack/response.rb#178
  def []=(key, value); end

  # Returns the value of attribute body.
  #
  # source://rack//lib/rack/response.rb#31
  def body; end

  # Sets the attribute body
  #
  # @param value the value to set the attribute body to.
  #
  # source://rack//lib/rack/response.rb#31
  def body=(_arg0); end

  # @return [Boolean]
  #
  # source://rack//lib/rack/response.rb#95
  def chunked?; end

  # source://rack//lib/rack/response.rb#152
  def close; end

  # @raise [ArgumentError]
  #
  # source://rack//lib/rack/response.rb#172
  def delete_header(key); end

  # source://rack//lib/rack/response.rb#130
  def each(&callback); end

  # @return [Boolean]
  #
  # source://rack//lib/rack/response.rb#156
  def empty?; end

  # Generate a response array consistent with the requirements of the SPEC.
  # which is suitable to be returned from the middleware `#call(env)` method.
  #
  # @return [Array] a 3-tuple suitable of `[status, headers, body]`
  #
  # source://rack//lib/rack/response.rb#107
  def finish(&block); end

  # @raise [ArgumentError]
  #
  # source://rack//lib/rack/response.rb#164
  def get_header(key); end

  # @raise [ArgumentError]
  # @return [Boolean]
  #
  # source://rack//lib/rack/response.rb#160
  def has_header?(key); end

  # Returns the value of attribute headers.
  #
  # source://rack//lib/rack/response.rb#32
  def headers; end

  # Returns the value of attribute length.
  #
  # source://rack//lib/rack/response.rb#31
  def length; end

  # Sets the attribute length
  #
  # @param value the value to set the attribute length to.
  #
  # source://rack//lib/rack/response.rb#31
  def length=(_arg0); end

  # @return [Boolean]
  #
  # source://rack//lib/rack/response.rb#99
  def no_entity_body?; end

  # source://rack//lib/rack/response.rb#90
  def redirect(target, status = T.unsafe(nil)); end

  # @raise [ArgumentError]
  #
  # source://rack//lib/rack/response.rb#168
  def set_header(key, value); end

  # Returns the value of attribute status.
  #
  # source://rack//lib/rack/response.rb#31
  def status; end

  # Sets the attribute status
  #
  # @param value the value to set the attribute status to.
  #
  # source://rack//lib/rack/response.rb#31
  def status=(_arg0); end

  # Generate a response array consistent with the requirements of the SPEC.
  # which is suitable to be returned from the middleware `#call(env)` method.
  # For *response
  #
  # @return [Array] a 3-tuple suitable of `[status, headers, body]`
  #
  # source://rack//lib/rack/response.rb#128
  def to_a(&block); end

  # Append a chunk to the response body.
  #
  # Converts the response into a buffered response if it wasn't already.
  #
  # NOTE: Do not mix #write and direct #body access!
  #
  # source://rack//lib/rack/response.rb#146
  def write(chunk); end

  class << self
    # source://rack//lib/rack/response.rb#24
    def [](status, headers, body); end
  end
end

# source://rack//lib/rack/response.rb#28
Rack::Response::CHUNKED = T.let(T.unsafe(nil), String)

# source://rack//lib/rack/response.rb#180
module Rack::Response::Helpers
  # @return [Boolean]
  #
  # source://rack//lib/rack/response.rb#191
  def accepted?; end

  # Add a header that may have multiple values.
  #
  # Example:
  #   response.add_header 'vary', 'accept-encoding'
  #   response.add_header 'vary', 'cookie'
  #
  #   assert_equal 'accept-encoding,cookie', response.get_header('vary')
  #
  # http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.2
  #
  # @raise [ArgumentError]
  #
  # source://rack//lib/rack/response.rb#219
  def add_header(key, value); end

  # @return [Boolean]
  #
  # source://rack//lib/rack/response.rb#194
  def bad_request?; end

  # Specify that the content should be cached.
  #
  # @option directive
  # @param directive [Hash] a customizable set of options
  # @param duration [Integer] The number of seconds until the cache expires.
  #
  # source://rack//lib/rack/response.rb#307
  def cache!(duration = T.unsafe(nil), directive: T.unsafe(nil)); end

  # source://rack//lib/rack/response.rb#290
  def cache_control; end

  # source://rack//lib/rack/response.rb#294
  def cache_control=(value); end

  # @return [Boolean]
  #
  # source://rack//lib/rack/response.rb#186
  def client_error?; end

  # source://rack//lib/rack/response.rb#257
  def content_length; end

  # Get the content type of the response.
  #
  # source://rack//lib/rack/response.rb#240
  def content_type; end

  # Set the content type of the response.
  #
  # source://rack//lib/rack/response.rb#245
  def content_type=(content_type); end

  # @return [Boolean]
  #
  # source://rack//lib/rack/response.rb#190
  def created?; end

  # source://rack//lib/rack/response.rb#274
  def delete_cookie(key, value = T.unsafe(nil)); end

  # Specifies that the content shouldn't be cached. Overrides `cache!` if already called.
  #
  # source://rack//lib/rack/response.rb#299
  def do_not_cache!; end

  # source://rack//lib/rack/response.rb#314
  def etag; end

  # source://rack//lib/rack/response.rb#318
  def etag=(value); end

  # @return [Boolean]
  #
  # source://rack//lib/rack/response.rb#196
  def forbidden?; end

  # @return [Boolean]
  #
  # source://rack//lib/rack/response.rb#206
  def include?(header); end

  # @return [Boolean]
  #
  # source://rack//lib/rack/response.rb#183
  def informational?; end

  # @return [Boolean]
  #
  # source://rack//lib/rack/response.rb#181
  def invalid?; end

  # source://rack//lib/rack/response.rb#262
  def location; end

  # source://rack//lib/rack/response.rb#266
  def location=(location); end

  # source://rack//lib/rack/response.rb#249
  def media_type; end

  # source://rack//lib/rack/response.rb#253
  def media_type_params; end

  # @return [Boolean]
  #
  # source://rack//lib/rack/response.rb#198
  def method_not_allowed?; end

  # @return [Boolean]
  #
  # source://rack//lib/rack/response.rb#193
  def moved_permanently?; end

  # @return [Boolean]
  #
  # source://rack//lib/rack/response.rb#192
  def no_content?; end

  # @return [Boolean]
  #
  # source://rack//lib/rack/response.rb#199
  def not_acceptable?; end

  # @return [Boolean]
  #
  # source://rack//lib/rack/response.rb#197
  def not_found?; end

  # @return [Boolean]
  #
  # source://rack//lib/rack/response.rb#189
  def ok?; end

  # @return [Boolean]
  #
  # source://rack//lib/rack/response.rb#201
  def precondition_failed?; end

  # @return [Boolean]
  #
  # source://rack//lib/rack/response.rb#204
  def redirect?; end

  # @return [Boolean]
  #
  # source://rack//lib/rack/response.rb#185
  def redirection?; end

  # @return [Boolean]
  #
  # source://rack//lib/rack/response.rb#200
  def request_timeout?; end

  # @return [Boolean]
  #
  # source://rack//lib/rack/response.rb#187
  def server_error?; end

  # source://rack//lib/rack/response.rb#270
  def set_cookie(key, value); end

  # source://rack//lib/rack/response.rb#282
  def set_cookie_header; end

  # source://rack//lib/rack/response.rb#286
  def set_cookie_header=(value); end

  # @return [Boolean]
  #
  # source://rack//lib/rack/response.rb#184
  def successful?; end

  # @return [Boolean]
  #
  # source://rack//lib/rack/response.rb#195
  def unauthorized?; end

  # @return [Boolean]
  #
  # source://rack//lib/rack/response.rb#202
  def unprocessable?; end

  protected

  # source://rack//lib/rack/response.rb#359
  def append(chunk); end

  # Convert the body of this response into an internally buffered Array if possible.
  #
  # `@buffered` is a ternary value which indicates whether the body is buffered. It can be:
  # * `nil` - The body has not been buffered yet.
  # * `true` - The body is buffered as an Array instance.
  # * `false` - The body is not buffered and cannot be buffered.
  #
  # @return [Boolean] whether the body is buffered as an Array instance.
  #
  # source://rack//lib/rack/response.rb#332
  def buffered_body!; end
end

# source://rack//lib/rack/response.rb#375
class Rack::Response::Raw
  include ::Rack::Response::Helpers

  # @return [Raw] a new instance of Raw
  #
  # source://rack//lib/rack/response.rb#381
  def initialize(status, headers); end

  # source://rack//lib/rack/response.rb#398
  def delete_header(key); end

  # source://rack//lib/rack/response.rb#390
  def get_header(key); end

  # @return [Boolean]
  #
  # source://rack//lib/rack/response.rb#386
  def has_header?(key); end

  # Returns the value of attribute headers.
  #
  # source://rack//lib/rack/response.rb#378
  def headers; end

  # source://rack//lib/rack/response.rb#394
  def set_header(key, value); end

  # Returns the value of attribute status.
  #
  # source://rack//lib/rack/response.rb#379
  def status; end

  # Sets the attribute status
  #
  # @param value the value to set the attribute status to.
  #
  # source://rack//lib/rack/response.rb#379
  def status=(_arg0); end
end

# source://rack//lib/rack/response.rb#29
Rack::Response::STATUS_WITH_NO_ENTITY_BODY = T.let(T.unsafe(nil), Hash)

# Class which can make any IO object rewindable, including non-rewindable ones. It does
# this by buffering the data into a tempfile, which is rewindable.
#
# Don't forget to call #close when you're done. This frees up temporary resources that
# RewindableInput uses, though it does *not* close the original IO object.
#
# source://rack//lib/rack/rewindable_input.rb#14
class Rack::RewindableInput
  # @return [RewindableInput] a new instance of RewindableInput
  #
  # source://rack//lib/rack/rewindable_input.rb#32
  def initialize(io); end

  # Closes this RewindableInput object without closing the originally
  # wrapped IO object. Cleans up any temporary resources that this RewindableInput
  # has created.
  #
  # This method may be called multiple times. It does nothing on subsequent calls.
  #
  # source://rack//lib/rack/rewindable_input.rb#68
  def close; end

  # source://rack//lib/rack/rewindable_input.rb#48
  def each(&block); end

  # source://rack//lib/rack/rewindable_input.rb#38
  def gets; end

  # source://rack//lib/rack/rewindable_input.rb#43
  def read(*args); end

  # source://rack//lib/rack/rewindable_input.rb#53
  def rewind; end

  # source://rack//lib/rack/rewindable_input.rb#58
  def size; end

  private

  # @return [Boolean]
  #
  # source://rack//lib/rack/rewindable_input.rb#112
  def filesystem_has_posix_semantics?; end

  # source://rack//lib/rack/rewindable_input.rb#81
  def make_rewindable; end
end

# Makes rack.input rewindable, for compatibility with applications and middleware
# designed for earlier versions of Rack (where rack.input was required to be
# rewindable).
#
# source://rack//lib/rack/rewindable_input.rb#18
class Rack::RewindableInput::Middleware
  # @return [Middleware] a new instance of Middleware
  #
  # source://rack//lib/rack/rewindable_input.rb#19
  def initialize(app); end

  # source://rack//lib/rack/rewindable_input.rb#23
  def call(env); end
end

# Sets an "x-runtime" response header, indicating the response
# time of the request, in seconds
#
# You can put it right before the application to see the processing
# time, or before all the other middlewares to include time for them,
# too.
#
# source://rack//lib/rack/runtime.rb#12
class Rack::Runtime
  # @return [Runtime] a new instance of Runtime
  #
  # source://rack//lib/rack/runtime.rb#16
  def initialize(app, name = T.unsafe(nil)); end

  # source://rack//lib/rack/runtime.rb#22
  def call(env); end
end

# source://rack//lib/rack/runtime.rb#13
Rack::Runtime::FORMAT_STRING = T.let(T.unsafe(nil), String)

# source://rack//lib/rack/runtime.rb#14
Rack::Runtime::HEADER_NAME = T.let(T.unsafe(nil), String)

# source://rack//lib/rack/constants.rb#11
Rack::SCRIPT_NAME = T.let(T.unsafe(nil), String)

# source://rack//lib/rack/constants.rb#14
Rack::SERVER_NAME = T.let(T.unsafe(nil), String)

# source://rack//lib/rack/constants.rb#15
Rack::SERVER_PORT = T.let(T.unsafe(nil), String)

# source://rack//lib/rack/constants.rb#13
Rack::SERVER_PROTOCOL = T.let(T.unsafe(nil), String)

# source://rack//lib/rack/constants.rb#24
Rack::SET_COOKIE = T.let(T.unsafe(nil), String)

# = Sendfile
#
# The Sendfile middleware intercepts responses whose body is being
# served from a file and replaces it with a server specific x-sendfile
# header. The web server is then responsible for writing the file contents
# to the client. This can dramatically reduce the amount of work required
# by the Ruby backend and takes advantage of the web server's optimized file
# delivery code.
#
# In order to take advantage of this middleware, the response body must
# respond to +to_path+ and the request must include an `x-sendfile-type`
# header. Rack::Files and other components implement +to_path+ so there's
# rarely anything you need to do in your application. The `x-sendfile-type`
# header is typically set in your web servers configuration. The following
# sections attempt to document
#
# === Nginx
#
# Nginx supports the `x-accel-redirect` header. This is similar to `x-sendfile`
# but requires parts of the filesystem to be mapped into a private URL
# hierarchy.
#
# The following example shows the Nginx configuration required to create
# a private "/files/" area, enable `x-accel-redirect`, and pass the special
# `x-accel-mapping` header to the backend:
#
#   location ~ /files/(.*) {
#     internal;
#     alias /var/www/$1;
#   }
#
#   location / {
#     proxy_redirect     off;
#
#     proxy_set_header   Host                $host;
#     proxy_set_header   X-Real-IP           $remote_addr;
#     proxy_set_header   X-Forwarded-For     $proxy_add_x_forwarded_for;
#
#     proxy_set_header   x-accel-mapping     /var/www/=/files/;
#
#     proxy_pass         http://127.0.0.1:8080/;
#   }
#
# The `x-accel-mapping` header should specify the location on the file system,
# followed by an equals sign (=), followed name of the private URL pattern
# that it maps to. The middleware performs a simple substitution on the
# resulting path.
#
# To enable `x-accel-redirect`, you must configure the middleware explicitly:
#
#   use Rack::Sendfile, "x-accel-redirect"
#
# For security reasons, the `x-sendfile-type` header from requests is ignored.
# The sendfile variation must be set via the middleware constructor.
#
# See Also: https://www.nginx.com/resources/wiki/start/topics/examples/xsendfile
#
# === lighttpd
#
# Lighttpd has supported some variation of the `x-sendfile` header for some
# time, although only recent version support `x-sendfile` in a reverse proxy
# configuration.
#
#   $HTTP["host"] == "example.com" {
#      proxy-core.protocol = "http"
#      proxy-core.balancer = "round-robin"
#      proxy-core.backends = (
#        "127.0.0.1:8000",
#        "127.0.0.1:8001",
#        ...
#      )
#
#      proxy-core.allow-x-sendfile = "enable"
#      proxy-core.rewrite-request = (
#        "x-sendfile-type" => (".*" => "x-sendfile")
#      )
#    }
#
# See Also: http://redmine.lighttpd.net/wiki/lighttpd/Docs:ModProxyCore
#
# === Apache
#
# `x-sendfile` is supported under Apache 2.x using a separate module:
#
# https://tn123.org/mod_xsendfile/
#
# Once the module is compiled and installed, you can enable it using
# XSendFile config directive:
#
#   RequestHeader Set x-sendfile-type x-sendfile
#   ProxyPassReverse / http://localhost:8001/
#   XSendFile on
#
# === Mapping parameter
#
# The third parameter allows for an overriding extension of the
# `x-accel-mapping` header. Mappings should be provided in tuples of internal to
# external. The internal values may contain regular expression syntax, they
# will be matched with case indifference.
#
# When `x-accel-redirect` is explicitly enabled via the variation parameter,
# and no application-level mappings are provided, the middleware will read
# the `x-accel-mapping` header from the proxy. This allows nginx to control
# the path mapping without requiring application-level configuration.
#
# === Security
#
# For security reasons, the `x-sendfile-type` header from HTTP requests is
# ignored. The sendfile variation must be explicitly configured via the
# middleware constructor to prevent information disclosure vulnerabilities
# where attackers could bypass proxy restrictions.
#
# source://rack//lib/rack/sendfile.rb#121
class Rack::Sendfile
  # @return [Sendfile] a new instance of Sendfile
  #
  # source://rack//lib/rack/sendfile.rb#122
  def initialize(app, variation = T.unsafe(nil), mappings = T.unsafe(nil)); end

  # source://rack//lib/rack/sendfile.rb#130
  def call(env); end

  private

  # source://rack//lib/rack/sendfile.rb#182
  def map_accel_path(env, path); end

  # source://rack//lib/rack/sendfile.rb#166
  def variation(env); end

  # source://rack//lib/rack/sendfile.rb#172
  def x_accel_mapping(env); end
end

# Rack::ShowExceptions catches all exceptions raised from the app it
# wraps.  It shows a useful backtrace with the sourcefile and
# clickable context, the whole Rack environment and the request
# data.
#
# Be careful when you use this on public-facing sites as it could
# reveal information helpful to attackers.
#
# source://rack//lib/rack/show_exceptions.rb#18
class Rack::ShowExceptions
  # @return [ShowExceptions] a new instance of ShowExceptions
  #
  # source://rack//lib/rack/show_exceptions.rb#26
  def initialize(app); end

  # source://rack//lib/rack/show_exceptions.rb#30
  def call(env); end

  # source://rack//lib/rack/show_exceptions.rb#65
  def dump_exception(exception); end

  # source://rack//lib/rack/show_exceptions.rb#120
  def h(obj); end

  # @return [Boolean]
  #
  # source://rack//lib/rack/show_exceptions.rb#56
  def prefers_plaintext?(env); end

  # source://rack//lib/rack/show_exceptions.rb#80
  def pretty(env, exception); end

  # source://rack//lib/rack/show_exceptions.rb#116
  def template; end

  private

  # @return [Boolean]
  #
  # source://rack//lib/rack/show_exceptions.rb#60
  def accepts_html?(env); end
end

# source://rack//lib/rack/show_exceptions.rb#19
Rack::ShowExceptions::CONTEXT = T.let(T.unsafe(nil), Integer)

# source://rack//lib/rack/show_exceptions.rb#21
class Rack::ShowExceptions::Frame < ::Struct
  # Returns the value of attribute context_line
  #
  # @return [Object] the current value of context_line
  #
  # source://rack//lib/rack/show_exceptions.rb#21
  def context_line; end

  # Sets the attribute context_line
  #
  # @param value [Object] the value to set the attribute context_line to.
  # @return [Object] the newly set value
  #
  # source://rack//lib/rack/show_exceptions.rb#21
  def context_line=(_); end

  # Returns the value of attribute filename
  #
  # @return [Object] the current value of filename
  #
  # source://rack//lib/rack/show_exceptions.rb#21
  def filename; end

  # Sets the attribute filename
  #
  # @param value [Object] the value to set the attribute filename to.
  # @return [Object] the newly set value
  #
  # source://rack//lib/rack/show_exceptions.rb#21
  def filename=(_); end

  # Returns the value of attribute function
  #
  # @return [Object] the current value of function
  #
  # source://rack//lib/rack/show_exceptions.rb#21
  def function; end

  # Sets the attribute function
  #
  # @param value [Object] the value to set the attribute function to.
  # @return [Object] the newly set value
  #
  # source://rack//lib/rack/show_exceptions.rb#21
  def function=(_); end

  # Returns the value of attribute lineno
  #
  # @return [Object] the current value of lineno
  #
  # source://rack//lib/rack/show_exceptions.rb#21
  def lineno; end

  # Sets the attribute lineno
  #
  # @param value [Object] the value to set the attribute lineno to.
  # @return [Object] the newly set value
  #
  # source://rack//lib/rack/show_exceptions.rb#21
  def lineno=(_); end

  # Returns the value of attribute post_context
  #
  # @return [Object] the current value of post_context
  #
  # source://rack//lib/rack/show_exceptions.rb#21
  def post_context; end

  # Sets the attribute post_context
  #
  # @param value [Object] the value to set the attribute post_context to.
  # @return [Object] the newly set value
  #
  # source://rack//lib/rack/show_exceptions.rb#21
  def post_context=(_); end

  # Returns the value of attribute post_context_lineno
  #
  # @return [Object] the current value of post_context_lineno
  #
  # source://rack//lib/rack/show_exceptions.rb#21
  def post_context_lineno; end

  # Sets the attribute post_context_lineno
  #
  # @param value [Object] the value to set the attribute post_context_lineno to.
  # @return [Object] the newly set value
  #
  # source://rack//lib/rack/show_exceptions.rb#21
  def post_context_lineno=(_); end

  # Returns the value of attribute pre_context
  #
  # @return [Object] the current value of pre_context
  #
  # source://rack//lib/rack/show_exceptions.rb#21
  def pre_context; end

  # Sets the attribute pre_context
  #
  # @param value [Object] the value to set the attribute pre_context to.
  # @return [Object] the newly set value
  #
  # source://rack//lib/rack/show_exceptions.rb#21
  def pre_context=(_); end

  # Returns the value of attribute pre_context_lineno
  #
  # @return [Object] the current value of pre_context_lineno
  #
  # source://rack//lib/rack/show_exceptions.rb#21
  def pre_context_lineno; end

  # Sets the attribute pre_context_lineno
  #
  # @param value [Object] the value to set the attribute pre_context_lineno to.
  # @return [Object] the newly set value
  #
  # source://rack//lib/rack/show_exceptions.rb#21
  def pre_context_lineno=(_); end

  class << self
    # source://rack//lib/rack/show_exceptions.rb#21
    def [](*_arg0); end

    # source://rack//lib/rack/show_exceptions.rb#21
    def inspect; end

    # source://rack//lib/rack/show_exceptions.rb#21
    def keyword_init?; end

    # source://rack//lib/rack/show_exceptions.rb#21
    def members; end

    # source://rack//lib/rack/show_exceptions.rb#21
    def new(*_arg0); end
  end
end

# source://rack//lib/rack/show_exceptions.rb#135
Rack::ShowExceptions::TEMPLATE = T.let(T.unsafe(nil), ERB)

# Rack::ShowStatus catches all empty responses and replaces them
# with a site explaining the error.
#
# Additional details can be put into <tt>rack.showstatus.detail</tt>
# and will be shown as HTML.  If such details exist, the error page
# is always rendered, even if the reply was not empty.
#
# source://rack//lib/rack/show_status.rb#18
class Rack::ShowStatus
  # @return [ShowStatus] a new instance of ShowStatus
  #
  # source://rack//lib/rack/show_status.rb#19
  def initialize(app); end

  # source://rack//lib/rack/show_status.rb#24
  def call(env); end

  # source://rack//lib/rack/show_status.rb#54
  def h(obj); end
end

# source://rack//lib/rack/show_status.rb#69
Rack::ShowStatus::TEMPLATE = T.let(T.unsafe(nil), String)

# The Rack::Static middleware intercepts requests for static files
# (javascript files, images, stylesheets, etc) based on the url prefixes or
# route mappings passed in the options, and serves them using a Rack::Files
# object. This allows a Rack stack to serve both static and dynamic content.
#
# Examples:
#
# Serve all requests beginning with /media from the "media" folder located
# in the current directory (ie media/*):
#
#     use Rack::Static, :urls => ["/media"]
#
# Same as previous, but instead of returning 404 for missing files under
# /media, call the next middleware:
#
#     use Rack::Static, :urls => ["/media"], :cascade => true
#
# Serve all requests beginning with /css or /images from the folder "public"
# in the current directory (ie public/css/* and public/images/*):
#
#     use Rack::Static, :urls => ["/css", "/images"], :root => "public"
#
# Serve all requests to / with "index.html" from the folder "public" in the
# current directory (ie public/index.html):
#
#     use Rack::Static, :urls => {"/" => 'index.html'}, :root => 'public'
#
# Serve all requests normally from the folder "public" in the current
# directory but uses index.html as default route for "/"
#
#     use Rack::Static, :urls => [""], :root => 'public', :index =>
#     'index.html'
#
# Set custom HTTP Headers for based on rules:
#
#     use Rack::Static, :root => 'public',
#         :header_rules => [
#           [rule, {header_field => content, header_field => content}],
#           [rule, {header_field => content}]
#         ]
#
#  Rules for selecting files:
#
#  1) All files
#     Provide the :all symbol
#     :all => Matches every file
#
#  2) Folders
#     Provide the folder path as a string
#     '/folder' or '/folder/subfolder' => Matches files in a certain folder
#
#  3) File Extensions
#     Provide the file extensions as an array
#     ['css', 'js'] or %w(css js) => Matches files ending in .css or .js
#
#  4) Regular Expressions / Regexp
#     Provide a regular expression
#     %r{\.(?:css|js)\z} => Matches files ending in .css or .js
#     /\.(?:eot|ttf|otf|woff2|woff|svg)\z/ => Matches files ending in
#       the most common web font formats (.eot, .ttf, .otf, .woff2, .woff, .svg)
#       Note: This Regexp is available as a shortcut, using the :fonts rule
#
#  5) Font Shortcut
#     Provide the :fonts symbol
#     :fonts => Uses the Regexp rule stated right above to match all common web font endings
#
#  Rule Ordering:
#    Rules are applied in the order that they are provided.
#    List rather general rules above special ones.
#
#  Complete example use case including HTTP header rules:
#
#     use Rack::Static, :root => 'public',
#         :header_rules => [
#           # Cache all static files in public caches (e.g. Rack::Cache)
#           #  as well as in the browser
#           [:all, {'cache-control' => 'public, max-age=31536000'}],
#
#           # Provide web fonts with cross-origin access-control-headers
#           #  Firefox requires this when serving assets using a Content Delivery Network
#           [:fonts, {'access-control-allow-origin' => '*'}]
#         ]
#
# source://rack//lib/rack/static.rb#92
class Rack::Static
  # @return [Static] a new instance of Static
  #
  # source://rack//lib/rack/static.rb#93
  def initialize(app, options = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://rack//lib/rack/static.rb#109
  def add_index_root?(path); end

  # Convert HTTP header rules to HTTP headers
  #
  # source://rack//lib/rack/static.rb#167
  def applicable_rules(path); end

  # source://rack//lib/rack/static.rb#125
  def call(env); end

  # source://rack//lib/rack/static.rb#121
  def can_serve(path); end

  # source://rack//lib/rack/static.rb#113
  def overwrite_file_path(path); end

  # source://rack//lib/rack/static.rb#117
  def route_file(path); end
end

# source://rack//lib/rack/constants.rb#38
Rack::TRACE = T.let(T.unsafe(nil), String)

# source://rack//lib/rack/constants.rb#25
Rack::TRANSFER_ENCODING = T.let(T.unsafe(nil), String)

# Middleware tracks and cleans Tempfiles created throughout a request (i.e. Rack::Multipart)
# Ideas/strategy based on posts by Eric Wong and Charles Oliver Nutter
# https://groups.google.com/forum/#!searchin/rack-devel/temp/rack-devel/brK8eh-MByw/sw61oJJCGRMJ
#
# source://rack//lib/rack/tempfile_reaper.rb#11
class Rack::TempfileReaper
  # @return [TempfileReaper] a new instance of TempfileReaper
  #
  # source://rack//lib/rack/tempfile_reaper.rb#12
  def initialize(app); end

  # source://rack//lib/rack/tempfile_reaper.rb#16
  def call(env); end
end

# source://rack//lib/rack/constants.rb#37
Rack::UNLINK = T.let(T.unsafe(nil), String)

# Rack::URLMap takes a hash mapping urls or paths to apps, and
# dispatches accordingly.  Support for HTTP/1.1 host names exists if
# the URLs start with <tt>http://</tt> or <tt>https://</tt>.
#
# URLMap modifies the SCRIPT_NAME and PATH_INFO such that the part
# relevant for dispatch is in the SCRIPT_NAME, and the rest in the
# PATH_INFO.  This should be taken care of when you need to
# reconstruct the URL in order to create links.
#
# URLMap dispatches in such a way that the longest paths are tried
# first, since they are most specific.
#
# source://rack//lib/rack/urlmap.rb#20
class Rack::URLMap
  # @return [URLMap] a new instance of URLMap
  #
  # source://rack//lib/rack/urlmap.rb#21
  def initialize(map = T.unsafe(nil)); end

  # source://rack//lib/rack/urlmap.rb#48
  def call(env); end

  # source://rack//lib/rack/urlmap.rb#25
  def remap(map); end

  private

  # @return [Boolean]
  #
  # source://rack//lib/rack/urlmap.rb#87
  def casecmp?(v1, v2); end
end

# Rack::Utils contains a grab-bag of useful methods for writing web
# applications adopted from all kinds of Ruby libraries.
#
# source://rack//lib/rack/utils.rb#20
module Rack::Utils
  private

  # Return best accept value to use, based on the algorithm
  # in RFC 2616 Section 14.  If there are multiple best
  # matches (same specificity and quality), the value returned
  # is arbitrary.
  #
  # source://rack//lib/rack/utils.rb#167
  def best_q_match(q_value_header, available_mimes); end

  # source://rack//lib/rack/utils.rb#120
  def build_nested_query(value, prefix = T.unsafe(nil)); end

  # source://rack//lib/rack/utils.rb#110
  def build_query(params); end

  # Parses the "Range:" header, if present, into an array of Range objects.
  # Returns nil if the header is missing or syntactically invalid.
  # Returns an empty array if none of the ranges are satisfiable.
  #
  # source://rack//lib/rack/utils.rb#402
  def byte_ranges(env, size); end

  # source://rack//lib/rack/utils.rb#600
  def clean_path_info(path_info); end

  # :nocov:
  #
  # source://rack//lib/rack/utils.rb#91
  def clock_time; end

  # source://rack//lib/rack/utils.rb#360
  def delete_cookie_header!(headers, key, value = T.unsafe(nil)); end

  # :call-seq:
  #   delete_set_cookie_header(key, value = {}) -> encoded string
  #
  # Generate an encoded string based on the given +key+ and +value+ using
  # set_cookie_header for the purpose of causing the specified cookie to be
  # deleted. The +value+ may be an instance of +Hash+ and can include
  # attributes as outlined by set_cookie_header. The encoded cookie will have
  # a +max_age+ of 0 seconds, an +expires+ date in the past and an empty
  # +value+. When used with the +set-cookie+ header, it will cause the client
  # to *remove* any matching cookie.
  #
  #   delete_set_cookie_header("myname")
  #   # => "myname=; max-age=0; expires=Thu, 01 Jan 1970 00:00:00 GMT"
  #
  # source://rack//lib/rack/utils.rb#356
  def delete_set_cookie_header(key, value = T.unsafe(nil)); end

  # :call-seq:
  #   delete_set_cookie_header!(header, key, value = {}) -> header value
  #
  # Set an expired cookie in the specified headers with the given cookie
  # +key+ and +value+ using delete_set_cookie_header. This causes
  # the client to immediately delete the specified cookie.
  #
  #   delete_set_cookie_header!(nil, "mycookie")
  #   # => "mycookie=; max-age=0; expires=Thu, 01 Jan 1970 00:00:00 GMT"
  #
  # If the header is non-nil, it will be modified in place.
  #
  #   header = []
  #   delete_set_cookie_header!(header, "mycookie")
  #   # => ["mycookie=; max-age=0; expires=Thu, 01 Jan 1970 00:00:00 GMT"]
  #   header
  #   # => ["mycookie=; max-age=0; expires=Thu, 01 Jan 1970 00:00:00 GMT"]
  #
  # source://rack//lib/rack/utils.rb#384
  def delete_set_cookie_header!(header, key, value = T.unsafe(nil)); end

  # URI escapes. (CGI style space to +)
  #
  # source://rack//lib/rack/utils.rb#40
  def escape(s); end

  # Escape ampersands, brackets and quotes to their HTML/XML entities.
  #
  # source://rack//lib/rack/utils.rb#183
  def escape_html(_arg0); end

  # Like URI escaping, but with %20 instead of +. Strictly speaking this is
  # true URI escaping.
  #
  # source://rack//lib/rack/utils.rb#46
  def escape_path(s); end

  # source://rack//lib/rack/utils.rb#149
  def forwarded_values(forwarded_header); end

  # source://rack//lib/rack/utils.rb#406
  def get_byte_ranges(http_range, size); end

  # :call-seq:
  #   parse_cookies(env) -> hash
  #
  # Parse cookies from the provided request environment using
  # parse_cookies_header. Returns a map of cookie +key+ to cookie +value+.
  #
  #   parse_cookies({'HTTP_COOKIE' => 'myname=myvalue'})
  #   # => {'myname' => 'myvalue'}
  #
  # source://rack//lib/rack/utils.rb#257
  def parse_cookies(env); end

  # :call-seq:
  #   parse_cookies_header(value) -> hash
  #
  # Parse cookies from the provided header +value+ according to RFC6265. The
  # syntax for cookie headers only supports semicolons. Returns a map of
  # cookie +key+ to cookie +value+.
  #
  #   parse_cookies_header('myname=myvalue; max-age=0')
  #   # => {"myname"=>"myvalue", "max-age"=>"0"}
  #
  # source://rack//lib/rack/utils.rb#238
  def parse_cookies_header(value); end

  # source://rack//lib/rack/utils.rb#106
  def parse_nested_query(qs, d = T.unsafe(nil)); end

  # source://rack//lib/rack/utils.rb#102
  def parse_query(qs, d = T.unsafe(nil), &unescaper); end

  # source://rack//lib/rack/utils.rb#138
  def q_values(q_value_header); end

  # source://rack//lib/rack/utils.rb#395
  def rfc2822(time); end

  # :nocov:
  #
  # source://rack//lib/rack/utils.rb#448
  def secure_compare(a, b); end

  # source://rack//lib/rack/utils.rb#196
  def select_best_encoding(available_encodings, accept_encoding); end

  # :call-seq:
  #   set_cookie_header(key, value) -> encoded string
  #
  # Generate an encoded string using the provided +key+ and +value+ suitable
  # for the +set-cookie+ header according to RFC6265. The +value+ may be an
  # instance of either +String+ or +Hash+. If the cookie key is invalid (as
  # defined by RFC6265), an +ArgumentError+ will be raised.
  #
  # If the cookie +value+ is an instance of +Hash+, it considers the following
  # cookie attribute keys: +domain+, +max_age+, +expires+ (must be instance
  # of +Time+), +secure+, +http_only+, +same_site+ and +value+. For more
  # details about the interpretation of these fields, consult
  # [RFC6265 Section 5.2](https://datatracker.ietf.org/doc/html/rfc6265#section-5.2).
  #
  #   set_cookie_header("myname", "myvalue")
  #   # => "myname=myvalue"
  #
  #   set_cookie_header("myname", {value: "myvalue", max_age: 10})
  #   # => "myname=myvalue; max-age=10"
  #
  # source://rack//lib/rack/utils.rb#286
  def set_cookie_header(key, value); end

  # :call-seq:
  #   set_cookie_header!(headers, key, value) -> header value
  #
  # Append a cookie in the specified headers with the given cookie +key+ and
  # +value+ using set_cookie_header.
  #
  # If the headers already contains a +set-cookie+ key, it will be converted
  # to an +Array+ if not already, and appended to.
  #
  # source://rack//lib/rack/utils.rb#330
  def set_cookie_header!(headers, key, value); end

  # source://rack//lib/rack/utils.rb#582
  def status_code(status); end

  # Unescapes a URI escaped string with +encoding+. +encoding+ will be the
  # target encoding of the string returned, and it defaults to UTF-8
  #
  # source://rack//lib/rack/utils.rb#58
  def unescape(s, encoding = T.unsafe(nil)); end

  # Unescapes the **path** component of a URI.  See Rack::Utils.unescape for
  # unescaping query parameters or form components.
  #
  # source://rack//lib/rack/utils.rb#52
  def unescape_path(s); end

  # source://rack//lib/rack/utils.rb#617
  def valid_path?(path); end

  class << self
    # Return best accept value to use, based on the algorithm
    # in RFC 2616 Section 14.  If there are multiple best
    # matches (same specificity and quality), the value returned
    # is arbitrary.
    #
    # source://rack//lib/rack/utils.rb#167
    def best_q_match(q_value_header, available_mimes); end

    # source://rack//lib/rack/utils.rb#120
    def build_nested_query(value, prefix = T.unsafe(nil)); end

    # source://rack//lib/rack/utils.rb#110
    def build_query(params); end

    # Parses the "Range:" header, if present, into an array of Range objects.
    # Returns nil if the header is missing or syntactically invalid.
    # Returns an empty array if none of the ranges are satisfiable.
    #
    # source://rack//lib/rack/utils.rb#402
    def byte_ranges(env, size); end

    # source://rack//lib/rack/utils.rb#600
    def clean_path_info(path_info); end

    # source://rack//lib/rack/utils.rb#91
    def clock_time; end

    # Returns the value of attribute default_query_parser.
    #
    # source://rack//lib/rack/utils.rb#30
    def default_query_parser; end

    # Sets the attribute default_query_parser
    #
    # @param value the value to set the attribute default_query_parser to.
    #
    # source://rack//lib/rack/utils.rb#30
    def default_query_parser=(_arg0); end

    # source://rack//lib/rack/utils.rb#360
    def delete_cookie_header!(headers, key, value = T.unsafe(nil)); end

    # :call-seq:
    #   delete_set_cookie_header(key, value = {}) -> encoded string
    #
    # Generate an encoded string based on the given +key+ and +value+ using
    # set_cookie_header for the purpose of causing the specified cookie to be
    # deleted. The +value+ may be an instance of +Hash+ and can include
    # attributes as outlined by set_cookie_header. The encoded cookie will have
    # a +max_age+ of 0 seconds, an +expires+ date in the past and an empty
    # +value+. When used with the +set-cookie+ header, it will cause the client
    # to *remove* any matching cookie.
    #
    #   delete_set_cookie_header("myname")
    #   # => "myname=; max-age=0; expires=Thu, 01 Jan 1970 00:00:00 GMT"
    #
    # source://rack//lib/rack/utils.rb#356
    def delete_set_cookie_header(key, value = T.unsafe(nil)); end

    # :call-seq:
    #   delete_set_cookie_header!(header, key, value = {}) -> header value
    #
    # Set an expired cookie in the specified headers with the given cookie
    # +key+ and +value+ using delete_set_cookie_header. This causes
    # the client to immediately delete the specified cookie.
    #
    #   delete_set_cookie_header!(nil, "mycookie")
    #   # => "mycookie=; max-age=0; expires=Thu, 01 Jan 1970 00:00:00 GMT"
    #
    # If the header is non-nil, it will be modified in place.
    #
    #   header = []
    #   delete_set_cookie_header!(header, "mycookie")
    #   # => ["mycookie=; max-age=0; expires=Thu, 01 Jan 1970 00:00:00 GMT"]
    #   header
    #   # => ["mycookie=; max-age=0; expires=Thu, 01 Jan 1970 00:00:00 GMT"]
    #
    # source://rack//lib/rack/utils.rb#384
    def delete_set_cookie_header!(header, key, value = T.unsafe(nil)); end

    # URI escapes. (CGI style space to +)
    #
    # source://rack//lib/rack/utils.rb#40
    def escape(s); end

    # source://rack//lib/rack/utils.rb#183
    def escape_html(_arg0); end

    # Like URI escaping, but with %20 instead of +. Strictly speaking this is
    # true URI escaping.
    #
    # source://rack//lib/rack/utils.rb#46
    def escape_path(s); end

    # source://rack//lib/rack/utils.rb#149
    def forwarded_values(forwarded_header); end

    # source://rack//lib/rack/utils.rb#406
    def get_byte_ranges(http_range, size); end

    # Returns the value of attribute multipart_file_limit.
    #
    # source://rack//lib/rack/utils.rb#65
    def multipart_file_limit; end

    # Sets the attribute multipart_file_limit
    #
    # @param value the value to set the attribute multipart_file_limit to.
    #
    # source://rack//lib/rack/utils.rb#65
    def multipart_file_limit=(_arg0); end

    # Returns the value of attribute multipart_file_limit.
    # multipart_part_limit is the original name of multipart_file_limit, but
    # the limit only counts parts with filenames.
    #
    # source://rack//lib/rack/utils.rb#69
    def multipart_part_limit; end

    # Sets the attribute multipart_file_limit
    #
    # @param value the value to set the attribute multipart_file_limit to.
    #
    # source://rack//lib/rack/utils.rb#70
    def multipart_part_limit=(_arg0); end

    # Returns the value of attribute multipart_total_part_limit.
    #
    # source://rack//lib/rack/utils.rb#63
    def multipart_total_part_limit; end

    # Sets the attribute multipart_total_part_limit
    #
    # @param value the value to set the attribute multipart_total_part_limit to.
    #
    # source://rack//lib/rack/utils.rb#63
    def multipart_total_part_limit=(_arg0); end

    # source://rack//lib/rack/utils.rb#82
    def param_depth_limit; end

    # source://rack//lib/rack/utils.rb#86
    def param_depth_limit=(v); end

    # :call-seq:
    #   parse_cookies(env) -> hash
    #
    # Parse cookies from the provided request environment using
    # parse_cookies_header. Returns a map of cookie +key+ to cookie +value+.
    #
    #   parse_cookies({'HTTP_COOKIE' => 'myname=myvalue'})
    #   # => {'myname' => 'myvalue'}
    #
    # source://rack//lib/rack/utils.rb#257
    def parse_cookies(env); end

    # :call-seq:
    #   parse_cookies_header(value) -> hash
    #
    # Parse cookies from the provided header +value+ according to RFC6265. The
    # syntax for cookie headers only supports semicolons. Returns a map of
    # cookie +key+ to cookie +value+.
    #
    #   parse_cookies_header('myname=myvalue; max-age=0')
    #   # => {"myname"=>"myvalue", "max-age"=>"0"}
    #
    # source://rack//lib/rack/utils.rb#238
    def parse_cookies_header(value); end

    # source://rack//lib/rack/utils.rb#106
    def parse_nested_query(qs, d = T.unsafe(nil)); end

    # source://rack//lib/rack/utils.rb#102
    def parse_query(qs, d = T.unsafe(nil), &unescaper); end

    # source://rack//lib/rack/utils.rb#138
    def q_values(q_value_header); end

    # source://rack//lib/rack/utils.rb#395
    def rfc2822(time); end

    # source://rack//lib/rack/utils.rb#448
    def secure_compare(a, b); end

    # source://rack//lib/rack/utils.rb#196
    def select_best_encoding(available_encodings, accept_encoding); end

    # :call-seq:
    #   set_cookie_header(key, value) -> encoded string
    #
    # Generate an encoded string using the provided +key+ and +value+ suitable
    # for the +set-cookie+ header according to RFC6265. The +value+ may be an
    # instance of either +String+ or +Hash+. If the cookie key is invalid (as
    # defined by RFC6265), an +ArgumentError+ will be raised.
    #
    # If the cookie +value+ is an instance of +Hash+, it considers the following
    # cookie attribute keys: +domain+, +max_age+, +expires+ (must be instance
    # of +Time+), +secure+, +http_only+, +same_site+ and +value+. For more
    # details about the interpretation of these fields, consult
    # [RFC6265 Section 5.2](https://datatracker.ietf.org/doc/html/rfc6265#section-5.2).
    #
    #   set_cookie_header("myname", "myvalue")
    #   # => "myname=myvalue"
    #
    #   set_cookie_header("myname", {value: "myvalue", max_age: 10})
    #   # => "myname=myvalue; max-age=10"
    #
    # source://rack//lib/rack/utils.rb#286
    def set_cookie_header(key, value); end

    # :call-seq:
    #   set_cookie_header!(headers, key, value) -> header value
    #
    # Append a cookie in the specified headers with the given cookie +key+ and
    # +value+ using set_cookie_header.
    #
    # If the headers already contains a +set-cookie+ key, it will be converted
    # to an +Array+ if not already, and appended to.
    #
    # source://rack//lib/rack/utils.rb#330
    def set_cookie_header!(headers, key, value); end

    # source://rack//lib/rack/utils.rb#582
    def status_code(status); end

    # Unescapes a URI escaped string with +encoding+. +encoding+ will be the
    # target encoding of the string returned, and it defaults to UTF-8
    #
    # source://rack//lib/rack/utils.rb#58
    def unescape(s, encoding = T.unsafe(nil)); end

    # Unescapes the **path** component of a URI.  See Rack::Utils.unescape for
    # unescaping query parameters or form components.
    #
    # source://rack//lib/rack/utils.rb#52
    def unescape_path(s); end

    # @return [Boolean]
    #
    # source://rack//lib/rack/utils.rb#617
    def valid_path?(path); end
  end
end

# source://rack//lib/rack/utils.rb#25
Rack::Utils::COMMON_SEP = T.let(T.unsafe(nil), Hash)

# Context allows the use of a compatible middleware at different points
# in a request handling stack. A compatible middleware must define
# #context which should take the arguments env and app. The first of which
# would be the request environment. The second of which would be the rack
# application that the request would be forwarded to.
#
# source://rack//lib/rack/utils.rb#471
class Rack::Utils::Context
  # @return [Context] a new instance of Context
  #
  # source://rack//lib/rack/utils.rb#474
  def initialize(app_f, app_r); end

  # Returns the value of attribute app.
  #
  # source://rack//lib/rack/utils.rb#472
  def app; end

  # source://rack//lib/rack/utils.rb#479
  def call(env); end

  # source://rack//lib/rack/utils.rb#487
  def context(env, app = T.unsafe(nil)); end

  # Returns the value of attribute for.
  #
  # source://rack//lib/rack/utils.rb#472
  def for; end

  # source://rack//lib/rack/utils.rb#483
  def recontext(app); end
end

# source://rack//lib/rack/utils.rb#24
Rack::Utils::DEFAULT_SEP = T.let(T.unsafe(nil), Regexp)

# Every standard HTTP code mapped to the appropriate message.
# Generated with:
#   curl -s https://www.iana.org/assignments/http-status-codes/http-status-codes-1.csv \
#     | ruby -rcsv -e "puts CSV.parse(STDIN, headers: true) \
#     .reject {|v| v['Description'] == 'Unassigned' or v['Description'].include? '(' } \
#     .map {|v| %Q/#{v['Value']} => '#{v['Description']}'/ }.join(','+?\n)"
#
# source://rack//lib/rack/utils.rb#498
Rack::Utils::HTTP_STATUS_CODES = T.let(T.unsafe(nil), Hash)

# source://rack//lib/rack/utils.rb#22
Rack::Utils::InvalidParameterError = Rack::QueryParser::InvalidParameterError

# source://rack//lib/rack/utils.rb#26
Rack::Utils::KeySpaceConstrainedParams = Rack::QueryParser::Params

# source://rack//lib/rack/utils.rb#615
Rack::Utils::NULL_BYTE = T.let(T.unsafe(nil), String)

# source://rack//lib/rack/utils.rb#568
Rack::Utils::OBSOLETE_SYMBOLS_TO_STATUS_CODES = T.let(T.unsafe(nil), Hash)

# source://rack//lib/rack/utils.rb#576
Rack::Utils::OBSOLETE_SYMBOL_MAPPINGS = T.let(T.unsafe(nil), Hash)

# source://rack//lib/rack/utils.rb#598
Rack::Utils::PATH_SEPS = T.let(T.unsafe(nil), Regexp)

# source://rack//lib/rack/utils.rb#21
Rack::Utils::ParameterTypeError = Rack::QueryParser::ParameterTypeError

# source://rack//lib/rack/utils.rb#23
Rack::Utils::ParamsTooDeepError = Rack::QueryParser::QueryLimitError

# Responses with HTTP status codes that should not have an entity body
#
# source://rack//lib/rack/utils.rb#562
Rack::Utils::STATUS_WITH_NO_ENTITY_BODY = T.let(T.unsafe(nil), Hash)

# source://rack//lib/rack/utils.rb#564
Rack::Utils::SYMBOL_TO_STATUS_CODE = T.let(T.unsafe(nil), Hash)

# source://rack//lib/rack/utils.rb#27
Rack::Utils::URI_PARSER = T.let(T.unsafe(nil), URI::RFC2396_Parser)

# A valid cookie key according to RFC6265 and RFC2616.
# A <cookie-name> can be any US-ASCII characters, except control characters, spaces, or tabs. It also must not contain a separator character like the following: ( ) < > @ , ; : \ " / [ ] ? = { }.
#
# source://rack//lib/rack/utils.rb#263
Rack::Utils::VALID_COOKIE_KEY = T.let(T.unsafe(nil), Regexp)

# source://rack//lib/rack/version.rb#9
Rack::VERSION = T.let(T.unsafe(nil), String)
