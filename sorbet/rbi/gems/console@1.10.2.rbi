# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `console` gem.
# Please instead update this file by running `bin/tapioca sync`.

# typed: true

module Console
  def logger; end
  def logger=(logger); end

  class << self
    def extended(klass); end
    def logger; end
    def logger=(instance); end
  end
end

class Console::Buffer < ::StringIO
  def initialize(prefix = T.unsafe(nil)); end

  def <<(*args, prefix: T.unsafe(nil)); end
  def puts(*args, prefix: T.unsafe(nil)); end
end

module Console::Event
end

class Console::Event::Failure < ::Console::Event::Generic
  def initialize(exception, root = T.unsafe(nil)); end

  def exception; end
  def format(output, terminal, verbose); end
  def format_exception(exception, prefix, output, terminal, verbose); end
  def root; end
  def to_h; end

  class << self
    def current_working_directory; end
    def for(exception); end
    def register(terminal); end
  end
end

class Console::Event::Generic
  def as_json; end
  def format(buffer, terminal); end
  def to_h; end

  class << self
    def register(terminal); end
  end
end

class Console::Event::Metric < ::Console::Event::Generic
  def initialize(name, value, **tags); end

  def format(output, terminal, verbose); end
  def name; end
  def tags; end
  def to_h; end
  def value; end

  class << self
    def [](**parameters); end
  end
end

class Console::Event::Progress < ::Console::Event::Generic
  def initialize(current, total); end

  def bar(value = T.unsafe(nil), width = T.unsafe(nil)); end
  def current; end
  def format(output, terminal, verbose); end
  def to_h; end
  def total; end
  def value; end

  class << self
    def register(terminal); end
  end
end

Console::Event::Progress::BLOCK = T.let(T.unsafe(nil), Array)

class Console::Event::Spawn < ::Console::Event::Generic
  def initialize(environment, *arguments, **options); end

  def arguments; end
  def chdir_string(options); end
  def environment; end
  def format(output, terminal, verbose); end
  def options; end
  def to_h; end

  class << self
    def for(*arguments, **options); end
    def register(terminal); end
  end
end

class Console::Filter
  def initialize(output, verbose: T.unsafe(nil), level: T.unsafe(nil), enabled: T.unsafe(nil), **options); end

  def all!; end
  def call(*arguments, **options, &block); end
  def disable(subject); end
  def enable(subject, level = T.unsafe(nil)); end
  def enabled?(subject, level = T.unsafe(nil)); end
  def level; end
  def level=(level); end
  def off!; end
  def options; end
  def options=(_arg0); end
  def output; end
  def output=(_arg0); end
  def subjects; end
  def verbose; end
  def verbose!(value = T.unsafe(nil)); end
  def with(level: T.unsafe(nil), verbose: T.unsafe(nil), **options); end

  class << self
    def [](**levels); end
  end
end

class Console::Logger < ::Console::Filter
  extend(::Fiber::Local)

  def initialize(output, **options); end

  def failure(subject, exception, *arguments, &block); end
  def measure(subject, total, **options); end
  def progress(subject, total, **options); end

  class << self
    def default_log_level(env = T.unsafe(nil)); end
    def default_logger(output, verbose: T.unsafe(nil), level: T.unsafe(nil)); end
    def local; end
    def verbose?(env = T.unsafe(nil)); end
  end
end

Console::Logger::DEFAULT_LEVEL = T.let(T.unsafe(nil), Integer)

class Console::Progress
  def initialize(output, subject, total = T.unsafe(nil), minimum_output_duration: T.unsafe(nil)); end

  def average_duration; end
  def current; end
  def duration; end
  def estimated_remaining_time; end
  def increment(amount = T.unsafe(nil)); end
  def mark(*arguments); end
  def progress; end
  def remaining; end
  def resize(total); end
  def subject; end
  def to_s; end
  def total; end

  private

  def duration_since_last_output; end
  def formatted_duration(duration); end
  def output?; end

  class << self
    def now; end
  end
end

class Console::Resolver
  def initialize; end

  def bind(names, &block); end
  def resolve(trace_point); end
  def waiting?; end

  class << self
    def default_resolver(logger, env = T.unsafe(nil)); end
  end
end

Console::Shell = Console::Event::Spawn

module Console::Terminal
  class << self
    def for(io); end
    def start_at!(environment = T.unsafe(nil)); end
  end
end

Console::Terminal::CONSOLE_START_AT = T.let(T.unsafe(nil), String)

class Console::Terminal::Logger
  def initialize(io = T.unsafe(nil), verbose: T.unsafe(nil), start_at: T.unsafe(nil), **options); end

  def call(subject = T.unsafe(nil), *arguments, name: T.unsafe(nil), severity: T.unsafe(nil), **options, &block); end
  def io; end
  def register_defaults(terminal); end
  def start; end
  def terminal; end
  def verbose; end
  def verbose!(value = T.unsafe(nil)); end
  def verbose=(_arg0); end

  protected

  def build_prefix(name); end
  def format_argument(argument, output); end
  def format_object_subject(severity, prefix, subject, output); end
  def format_options(options, output); end
  def format_string_subject(severity, prefix, subject, output); end
  def format_subject(severity, prefix, subject, buffer); end
  def format_value(value, output); end
  def time_offset_prefix; end
end

Console::Terminal::Logger::UNKNOWN = T.let(T.unsafe(nil), String)

class Console::Terminal::Text
  def initialize(output); end

  def [](key); end
  def []=(key, value); end
  def colors?; end
  def print(*arguments); end
  def print_line(*arguments); end
  def puts(*arguments, style: T.unsafe(nil)); end
  def reset; end
  def style(foreground, background = T.unsafe(nil), *attributes); end
  def write(*arguments, style: T.unsafe(nil)); end
end

class Console::Terminal::XTerm < ::Console::Terminal::Text
  def colors?; end
  def reset; end
  def size; end
  def style(foreground, background = T.unsafe(nil), *attributes); end
end

Console::Terminal::XTerm::ATTRIBUTES = T.let(T.unsafe(nil), Hash)

Console::Terminal::XTerm::COLORS = T.let(T.unsafe(nil), Hash)

Console::UNKNOWN = T.let(T.unsafe(nil), String)

Console::VERSION = T.let(T.unsafe(nil), String)
