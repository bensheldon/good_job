# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `protocol-http2` gem.
# Please instead update this file by running `bin/tapioca gem protocol-http2`.

# source://protocol-http2//lib/protocol/http2/error.rb#8
module Protocol; end

# source://protocol-http2//lib/protocol/http2/error.rb#9
module Protocol::HTTP2; end

# source://protocol-http2//lib/protocol/http2/ping_frame.rb#10
Protocol::HTTP2::ACKNOWLEDGEMENT = T.let(T.unsafe(nil), Integer)

# source://protocol-http2//lib/protocol/http2/ping_frame.rb#12
module Protocol::HTTP2::Acknowledgement
  # source://protocol-http2//lib/protocol/http2/ping_frame.rb#21
  def acknowledge; end

  # source://protocol-http2//lib/protocol/http2/ping_frame.rb#17
  def acknowledgement!; end

  # @return [Boolean]
  #
  # source://protocol-http2//lib/protocol/http2/ping_frame.rb#13
  def acknowledgement?; end
end

# source://protocol-http2//lib/protocol/http2/reset_stream_frame.rb#18
Protocol::HTTP2::CANCEL = T.let(T.unsafe(nil), Integer)

# source://protocol-http2//lib/protocol/http2/reset_stream_frame.rb#19
Protocol::HTTP2::COMPRESSION_ERROR = T.let(T.unsafe(nil), Integer)

# Default connection "fast-fail" preamble string as defined by the spec.
#
# source://protocol-http2//lib/protocol/http2/framer.rb#36
Protocol::HTTP2::CONNECTION_PREFACE = T.let(T.unsafe(nil), String)

# source://protocol-http2//lib/protocol/http2/reset_stream_frame.rb#20
Protocol::HTTP2::CONNECT_ERROR = T.let(T.unsafe(nil), Integer)

# source://protocol-http2//lib/protocol/http2/client.rb#10
class Protocol::HTTP2::Client < ::Protocol::HTTP2::Connection
  # @return [Client] a new instance of Client
  #
  # source://protocol-http2//lib/protocol/http2/client.rb#11
  def initialize(framer); end

  # @raise [ProtocolError]
  #
  # source://protocol-http2//lib/protocol/http2/client.rb#43
  def create_push_promise_stream; end

  # @return [Boolean]
  #
  # source://protocol-http2//lib/protocol/http2/client.rb#15
  def local_stream_id?(id); end

  # source://protocol-http2//lib/protocol/http2/client.rb#47
  def receive_push_promise(frame); end

  # @return [Boolean]
  #
  # source://protocol-http2//lib/protocol/http2/client.rb#19
  def remote_stream_id?(id); end

  # source://protocol-http2//lib/protocol/http2/client.rb#27
  def send_connection_preface(settings = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://protocol-http2//lib/protocol/http2/client.rb#23
  def valid_remote_stream_id?(stream_id); end
end

# source://protocol-http2//lib/protocol/http2/connection.rb#15
class Protocol::HTTP2::Connection
  include ::Protocol::HTTP2::FlowControlled

  # @return [Connection] a new instance of Connection
  #
  # source://protocol-http2//lib/protocol/http2/connection.rb#18
  def initialize(framer, local_stream_id); end

  # source://protocol-http2//lib/protocol/http2/connection.rb#52
  def [](id); end

  # Accept an incoming push promise from the other side of the connection.
  # On the client side, we accept push promise streams.
  # On the server side, existing streams create push promise streams.
  #
  # source://protocol-http2//lib/protocol/http2/connection.rb#335
  def accept_push_promise_stream(stream_id, &block); end

  # Accept an incoming stream from the other side of the connnection.
  # On the server side, we accept requests.
  #
  # source://protocol-http2//lib/protocol/http2/connection.rb#324
  def accept_stream(stream_id, &block); end

  # @return [Boolean]
  #
  # source://protocol-http2//lib/protocol/http2/connection.rb#404
  def client_stream_id?(id); end

  # Close the underlying framer and all streams.
  #
  # source://protocol-http2//lib/protocol/http2/connection.rb#99
  def close(error = T.unsafe(nil)); end

  # Transition the connection into the closed state.
  #
  # source://protocol-http2//lib/protocol/http2/connection.rb#181
  def close!; end

  # Whether the connection is effectively or actually closed.
  #
  # @return [Boolean]
  #
  # source://protocol-http2//lib/protocol/http2/connection.rb#89
  def closed?; end

  # This is only valid if the stream doesn't exist in `@streams`.
  #
  # @return [Boolean]
  #
  # source://protocol-http2//lib/protocol/http2/connection.rb#431
  def closed_stream_id?(id); end

  # Traverse active streams in order of priority and allow them to consume the available flow-control window.
  #
  # @param amount [Integer] the amount of data to write. Defaults to the current window capacity.
  #
  # source://protocol-http2//lib/protocol/http2/connection.rb#454
  def consume_window(size = T.unsafe(nil)); end

  # source://protocol-http2//lib/protocol/http2/connection.rb#354
  def create_push_promise_stream(&block); end

  # Create a stream, defaults to an outgoing stream.
  # On the client side, we create requests.
  #
  # @return [Stream] the created stream.
  #
  # source://protocol-http2//lib/protocol/http2/connection.rb#342
  def create_stream(id = T.unsafe(nil), &block); end

  # source://protocol-http2//lib/protocol/http2/connection.rb#115
  def decode_headers(data); end

  # source://protocol-http2//lib/protocol/http2/connection.rb#93
  def delete(id); end

  # Returns the value of attribute dependencies.
  #
  # source://protocol-http2//lib/protocol/http2/connection.rb#130
  def dependencies; end

  # Returns the value of attribute dependency.
  #
  # source://protocol-http2//lib/protocol/http2/connection.rb#132
  def dependency; end

  # source://protocol-http2//lib/protocol/http2/connection.rb#111
  def encode_headers(headers, buffer = T.unsafe(nil)); end

  # Returns the value of attribute framer.
  #
  # source://protocol-http2//lib/protocol/http2/connection.rb#69
  def framer; end

  # source://protocol-http2//lib/protocol/http2/connection.rb#48
  def id; end

  # @return [Boolean]
  #
  # source://protocol-http2//lib/protocol/http2/connection.rb#412
  def idle_stream_id?(id); end

  # 6.8. GOAWAY
  # There is an inherent race condition between an endpoint starting new streams and the remote sending a GOAWAY frame. To deal with this case, the GOAWAY contains the stream identifier of the last peer-initiated stream that was or might be processed on the sending endpoint in this connection. For instance, if the server sends a GOAWAY frame, the identified stream is the highest-numbered stream initiated by the client.
  # Once sent, the sender will ignore frames sent on streams initiated by the receiver if the stream has an identifier higher than the included last stream identifier. Receivers of a GOAWAY frame MUST NOT open additional streams on the connection, although a new connection can be established for new streams.
  #
  # @return [Boolean]
  #
  # source://protocol-http2//lib/protocol/http2/connection.rb#137
  def ignore_frame?(frame); end

  # Current settings value for local and peer
  #
  # source://protocol-http2//lib/protocol/http2/connection.rb#75
  def local_settings; end

  # Current settings value for local and peer
  #
  # source://protocol-http2//lib/protocol/http2/connection.rb#75
  def local_settings=(_arg0); end

  # Our window for receiving data. When we receive data, it reduces this window.
  # If the window gets too small, we must send a window update.
  #
  # source://protocol-http2//lib/protocol/http2/connection.rb#80
  def local_window; end

  # source://protocol-http2//lib/protocol/http2/connection.rb#65
  def maximum_concurrent_streams; end

  # The size of a frame payload is limited by the maximum size that a receiver advertises in the SETTINGS_MAX_FRAME_SIZE setting.
  #
  # source://protocol-http2//lib/protocol/http2/connection.rb#61
  def maximum_frame_size; end

  # Streams are identified with an unsigned 31-bit integer.  Streams initiated by a client MUST use odd-numbered stream identifiers; those initiated by the server MUST use even-numbered stream identifiers.  A stream identifier of zero (0x0) is used for connection control messages; the stream identifier of zero cannot be used to establish a new stream.
  #
  # source://protocol-http2//lib/protocol/http2/connection.rb#120
  def next_stream_id; end

  # source://protocol-http2//lib/protocol/http2/connection.rb#261
  def open!; end

  # In addition to changing the flow-control window for streams that are not yet active, a SETTINGS frame can alter the initial flow-control window size for streams with active flow-control windows (that is, streams in the "open" or "half-closed (remote)" state).  When the value of SETTINGS_INITIAL_WINDOW_SIZE changes, a receiver MUST adjust the size of all stream flow-control windows that it maintains by the difference between the new value and the old value.
  #
  # @return [Boolean] whether the frame was an acknowledgement
  #
  # source://protocol-http2//lib/protocol/http2/connection.rb#238
  def process_settings(frame); end

  # Reads one frame from the network and processes. Processing the frame updates the state of the connection and related streams. If the frame triggers an error, e.g. a protocol error, the connection will typically emit a goaway frame and re-raise the exception. You should continue processing frames until the underlying connection is closed.
  #
  # source://protocol-http2//lib/protocol/http2/connection.rb#147
  def read_frame; end

  # @raise [ProtocolError]
  #
  # source://protocol-http2//lib/protocol/http2/connection.rb#490
  def receive_continuation(frame); end

  # source://protocol-http2//lib/protocol/http2/connection.rb#306
  def receive_data(frame); end

  # source://protocol-http2//lib/protocol/http2/connection.rb#494
  def receive_frame(frame); end

  # source://protocol-http2//lib/protocol/http2/connection.rb#197
  def receive_goaway(frame); end

  # On the server side, starts a new request.
  #
  # source://protocol-http2//lib/protocol/http2/connection.rb#359
  def receive_headers(frame); end

  # source://protocol-http2//lib/protocol/http2/connection.rb#289
  def receive_ping(frame); end

  # Sets the priority for an incoming stream.
  #
  # source://protocol-http2//lib/protocol/http2/connection.rb#392
  def receive_priority(frame); end

  # @raise [ProtocolError]
  #
  # source://protocol-http2//lib/protocol/http2/connection.rb#400
  def receive_push_promise(frame); end

  # source://protocol-http2//lib/protocol/http2/connection.rb#440
  def receive_reset_stream(frame); end

  # source://protocol-http2//lib/protocol/http2/connection.rb#267
  def receive_settings(frame); end

  # source://protocol-http2//lib/protocol/http2/connection.rb#471
  def receive_window_update(frame); end

  # Returns the value of attribute remote_settings.
  #
  # source://protocol-http2//lib/protocol/http2/connection.rb#76
  def remote_settings; end

  # Sets the attribute remote_settings
  #
  # @param value the value to set the attribute remote_settings to.
  #
  # source://protocol-http2//lib/protocol/http2/connection.rb#76
  def remote_settings=(_arg0); end

  # The highest stream_id that has been successfully accepted by this connection.
  #
  # source://protocol-http2//lib/protocol/http2/connection.rb#86
  def remote_stream_id; end

  # Our window for sending data. When we send data, it reduces this window.
  #
  # source://protocol-http2//lib/protocol/http2/connection.rb#83
  def remote_window; end

  # Tell the remote end that the connection is being shut down. If the `error_code` is 0, this is a graceful shutdown. The other end of the connection should not make any new streams, but existing streams may be completed.
  #
  # source://protocol-http2//lib/protocol/http2/connection.rb#188
  def send_goaway(error_code = T.unsafe(nil), message = T.unsafe(nil)); end

  # source://protocol-http2//lib/protocol/http2/connection.rb#278
  def send_ping(data); end

  # source://protocol-http2//lib/protocol/http2/connection.rb#384
  def send_priority(stream_id, priority); end

  # source://protocol-http2//lib/protocol/http2/connection.rb#171
  def send_settings(changes); end

  # @return [Boolean]
  #
  # source://protocol-http2//lib/protocol/http2/connection.rb#408
  def server_stream_id?(id); end

  # Connection state (:new, :open, :closed).
  #
  # source://protocol-http2//lib/protocol/http2/connection.rb#72
  def state; end

  # Connection state (:new, :open, :closed).
  #
  # source://protocol-http2//lib/protocol/http2/connection.rb#72
  def state=(_arg0); end

  # Returns the value of attribute streams.
  #
  # source://protocol-http2//lib/protocol/http2/connection.rb#128
  def streams; end

  # source://protocol-http2//lib/protocol/http2/connection.rb#217
  def update_local_settings(changes); end

  # source://protocol-http2//lib/protocol/http2/connection.rb#227
  def update_remote_settings(changes); end

  # @return [Boolean]
  #
  # source://protocol-http2//lib/protocol/http2/connection.rb#318
  def valid_remote_stream_id?(stream_id); end

  # source://protocol-http2//lib/protocol/http2/connection.rb#209
  def write_frame(frame); end

  # @yield [@framer]
  #
  # source://protocol-http2//lib/protocol/http2/connection.rb#213
  def write_frames; end
end

# The CONTINUATION frame is used to continue a sequence of header block fragments. Any number of CONTINUATION frames can be sent, as long as the preceding frame is on the same stream and is a HEADERS, PUSH_PROMISE, or CONTINUATION frame without the END_HEADERS flag set.
#
# +---------------------------------------------------------------+
# |                   Header Block Fragment (*)                 ...
# +---------------------------------------------------------------+
#
# source://protocol-http2//lib/protocol/http2/continuation_frame.rb#93
class Protocol::HTTP2::ContinuationFrame < ::Protocol::HTTP2::Frame
  include ::Protocol::HTTP2::Continued

  # This is only invoked if the continuation is received out of the normal flow.
  #
  # source://protocol-http2//lib/protocol/http2/continuation_frame.rb#99
  def apply(connection); end

  # source://protocol-http2//lib/protocol/http2/continuation_frame.rb#103
  def inspect; end
end

# source://protocol-http2//lib/protocol/http2/continuation_frame.rb#96
Protocol::HTTP2::ContinuationFrame::TYPE = T.let(T.unsafe(nil), Integer)

# source://protocol-http2//lib/protocol/http2/continuation_frame.rb#10
module Protocol::HTTP2::Continued
  # source://protocol-http2//lib/protocol/http2/continuation_frame.rb#11
  def initialize(*_arg0); end

  # Returns the value of attribute continuation.
  #
  # source://protocol-http2//lib/protocol/http2/continuation_frame.rb#55
  def continuation; end

  # Sets the attribute continuation
  #
  # @param value the value to set the attribute continuation to.
  #
  # source://protocol-http2//lib/protocol/http2/continuation_frame.rb#55
  def continuation=(_arg0); end

  # @return [Boolean]
  #
  # source://protocol-http2//lib/protocol/http2/continuation_frame.rb#17
  def continued?; end

  # @return [Boolean]
  #
  # source://protocol-http2//lib/protocol/http2/continuation_frame.rb#21
  def end_headers?; end

  # source://protocol-http2//lib/protocol/http2/continuation_frame.rb#57
  def pack(data, **options); end

  # source://protocol-http2//lib/protocol/http2/continuation_frame.rb#25
  def read(stream, maximum_frame_size); end

  # source://protocol-http2//lib/protocol/http2/continuation_frame.rb#78
  def unpack; end

  # source://protocol-http2//lib/protocol/http2/continuation_frame.rb#47
  def write(stream); end
end

# source://protocol-http2//lib/protocol/http2/dependency.rb#8
Protocol::HTTP2::DEFAULT_WEIGHT = T.let(T.unsafe(nil), Integer)

# DATA frames convey arbitrary, variable-length sequences of octets associated with a stream. One or more DATA frames are used, for instance, to carry HTTP request or response payloads.
#
# DATA frames MAY also contain padding. Padding can be added to DATA frames to obscure the size of messages.
#
# +---------------+
# |Pad Length? (8)|
# +---------------+-----------------------------------------------+
# |                            Data (*)                         ...
# +---------------------------------------------------------------+
# |                           Padding (*)                       ...
# +---------------------------------------------------------------+
#
# source://protocol-http2//lib/protocol/http2/data_frame.rb#23
class Protocol::HTTP2::DataFrame < ::Protocol::HTTP2::Frame
  include ::Protocol::HTTP2::Padded

  # source://protocol-http2//lib/protocol/http2/data_frame.rb#41
  def apply(connection); end

  # @return [Boolean]
  #
  # source://protocol-http2//lib/protocol/http2/data_frame.rb#28
  def end_stream?; end

  # source://protocol-http2//lib/protocol/http2/data_frame.rb#45
  def inspect; end

  # source://protocol-http2//lib/protocol/http2/data_frame.rb#32
  def pack(data, *arguments, **options); end
end

# source://protocol-http2//lib/protocol/http2/data_frame.rb#26
Protocol::HTTP2::DataFrame::TYPE = T.let(T.unsafe(nil), Integer)

# source://protocol-http2//lib/protocol/http2/dependency.rb#10
class Protocol::HTTP2::Dependency
  # @return [Dependency] a new instance of Dependency
  #
  # source://protocol-http2//lib/protocol/http2/dependency.rb#40
  def initialize(connection, id, weight = T.unsafe(nil)); end

  # source://protocol-http2//lib/protocol/http2/dependency.rb#57
  def <=>(other); end

  # source://protocol-http2//lib/protocol/http2/dependency.rb#98
  def add_child(dependency); end

  # The dependent children.
  #
  # source://protocol-http2//lib/protocol/http2/dependency.rb#71
  def children; end

  # The dependent children.
  #
  # source://protocol-http2//lib/protocol/http2/dependency.rb#71
  def children=(_arg0); end

  # source://protocol-http2//lib/protocol/http2/dependency.rb#80
  def clear_cache!; end

  # The connection this stream belongs to.
  #
  # source://protocol-http2//lib/protocol/http2/dependency.rb#62
  def connection; end

  # Traverse active streams in order of priority and allow them to consume the available flow-control window.
  #
  # @param amount [Integer] the amount of data to write. Defaults to the current window capacity.
  #
  # source://protocol-http2//lib/protocol/http2/dependency.rb#191
  def consume_window(size); end

  # source://protocol-http2//lib/protocol/http2/dependency.rb#84
  def delete!; end

  # An exclusive flag allows for the insertion of a new level of dependencies.  The exclusive flag causes the stream to become the sole dependency of its parent stream, causing other dependencies to become dependent on the exclusive stream.
  #
  # @param parent [Dependency] the dependency which will be inserted, taking control of all current children.
  #
  # source://protocol-http2//lib/protocol/http2/dependency.rb#115
  def exclusive_child(parent); end

  # Stream ID (odd for client initiated streams, even otherwise).
  #
  # source://protocol-http2//lib/protocol/http2/dependency.rb#65
  def id; end

  # source://protocol-http2//lib/protocol/http2/dependency.rb#206
  def inspect; end

  # source://protocol-http2//lib/protocol/http2/dependency.rb#178
  def ordered_children; end

  # The parent dependency.
  #
  # source://protocol-http2//lib/protocol/http2/dependency.rb#68
  def parent; end

  # The parent dependency.
  #
  # source://protocol-http2//lib/protocol/http2/dependency.rb#68
  def parent=(_arg0); end

  # source://protocol-http2//lib/protocol/http2/dependency.rb#210
  def print_hierarchy(output = T.unsafe(nil), indent: T.unsafe(nil)); end

  # The current local priority of the stream.
  #
  # source://protocol-http2//lib/protocol/http2/dependency.rb#160
  def priority(exclusive = T.unsafe(nil)); end

  # Change the priority of the stream both locally and remotely.
  #
  # source://protocol-http2//lib/protocol/http2/dependency.rb#154
  def priority=(priority); end

  # source://protocol-http2//lib/protocol/http2/dependency.rb#130
  def process_priority(priority); end

  # source://protocol-http2//lib/protocol/http2/dependency.rb#168
  def receive_priority(frame); end

  # source://protocol-http2//lib/protocol/http2/dependency.rb#107
  def remove_child(dependency); end

  # source://protocol-http2//lib/protocol/http2/dependency.rb#164
  def send_priority(priority); end

  # source://protocol-http2//lib/protocol/http2/dependency.rb#76
  def stream; end

  # source://protocol-http2//lib/protocol/http2/dependency.rb#172
  def total_weight; end

  # The weight of the stream relative to other siblings.
  #
  # source://protocol-http2//lib/protocol/http2/dependency.rb#74
  def weight; end

  # The weight of the stream relative to other siblings.
  #
  # source://protocol-http2//lib/protocol/http2/dependency.rb#74
  def weight=(_arg0); end

  class << self
    # source://protocol-http2//lib/protocol/http2/dependency.rb#11
    def create(connection, id, priority = T.unsafe(nil)); end
  end
end

# source://protocol-http2//lib/protocol/http2/frame.rb#12
Protocol::HTTP2::END_HEADERS = T.let(T.unsafe(nil), Integer)

# source://protocol-http2//lib/protocol/http2/frame.rb#11
Protocol::HTTP2::END_STREAM = T.let(T.unsafe(nil), Integer)

# source://protocol-http2//lib/protocol/http2/reset_stream_frame.rb#21
Protocol::HTTP2::ENHANCE_YOUR_CALM = T.let(T.unsafe(nil), Integer)

# Status codes as defined by <https://tools.ietf.org/html/rfc7540#section-7>.
#
# source://protocol-http2//lib/protocol/http2/error.rb#11
class Protocol::HTTP2::Error < ::Protocol::HTTP::Error; end

# Used by the endpoint to indicate that the stream is no longer needed.
#
# source://protocol-http2//lib/protocol/http2/error.rb#37
Protocol::HTTP2::Error::CANCEL = T.let(T.unsafe(nil), Integer)

# The endpoint is unable to maintain the header compression context for the connection.
#
# source://protocol-http2//lib/protocol/http2/error.rb#40
Protocol::HTTP2::Error::COMPRESSION_ERROR = T.let(T.unsafe(nil), Integer)

# The connection established in response to a CONNECT request was reset or abnormally closed.
#
# source://protocol-http2//lib/protocol/http2/error.rb#43
Protocol::HTTP2::Error::CONNECT_ERROR = T.let(T.unsafe(nil), Integer)

# The endpoint detected that its peer is exhibiting a behavior that might be generating excessive load.
#
# source://protocol-http2//lib/protocol/http2/error.rb#46
Protocol::HTTP2::Error::ENHANCE_YOUR_CALM = T.let(T.unsafe(nil), Integer)

# The endpoint detected that its peer violated the flow-control protocol.
#
# source://protocol-http2//lib/protocol/http2/error.rb#22
Protocol::HTTP2::Error::FLOW_CONTROL_ERROR = T.let(T.unsafe(nil), Integer)

# The endpoint received a frame with an invalid size.
#
# source://protocol-http2//lib/protocol/http2/error.rb#31
Protocol::HTTP2::Error::FRAME_SIZE_ERROR = T.let(T.unsafe(nil), Integer)

# The endpoint requires that HTTP/1.1 be used instead of HTTP/2.
#
# source://protocol-http2//lib/protocol/http2/error.rb#52
Protocol::HTTP2::Error::HTTP_1_1_REQUIRED = T.let(T.unsafe(nil), Integer)

# The underlying transport has properties that do not meet minimum security requirements.
#
# source://protocol-http2//lib/protocol/http2/error.rb#49
Protocol::HTTP2::Error::INADEQUATE_SECURITY = T.let(T.unsafe(nil), Integer)

# The endpoint encountered an unexpected internal error.
#
# source://protocol-http2//lib/protocol/http2/error.rb#19
Protocol::HTTP2::Error::INTERNAL_ERROR = T.let(T.unsafe(nil), Integer)

# The associated condition is not a result of an error.  For example, a GOAWAY might include this code to indicate graceful shutdown of a connection.
#
# source://protocol-http2//lib/protocol/http2/error.rb#13
Protocol::HTTP2::Error::NO_ERROR = T.let(T.unsafe(nil), Integer)

# The endpoint detected an unspecific protocol error.  This error is for use when a more specific error code is not available.
#
# source://protocol-http2//lib/protocol/http2/error.rb#16
Protocol::HTTP2::Error::PROTOCOL_ERROR = T.let(T.unsafe(nil), Integer)

# The endpoint refused the stream prior to performing any application processing.
#
# source://protocol-http2//lib/protocol/http2/error.rb#34
Protocol::HTTP2::Error::REFUSED_STREAM = T.let(T.unsafe(nil), Integer)

# The endpoint sent a SETTINGS frame but did not receive a response in a timely manner.
#
# source://protocol-http2//lib/protocol/http2/error.rb#25
Protocol::HTTP2::Error::SETTINGS_TIMEOUT = T.let(T.unsafe(nil), Integer)

# The endpoint received a frame after a stream was half-closed.
#
# source://protocol-http2//lib/protocol/http2/error.rb#28
Protocol::HTTP2::Error::STREAM_CLOSED = T.let(T.unsafe(nil), Integer)

# source://protocol-http2//lib/protocol/http2/reset_stream_frame.rb#13
Protocol::HTTP2::FLOW_CONTROL_ERROR = T.let(T.unsafe(nil), Integer)

# HTTP/2 frame type mapping as defined by the spec
#
# source://protocol-http2//lib/protocol/http2/framer.rb#22
Protocol::HTTP2::FRAMES = T.let(T.unsafe(nil), Array)

# source://protocol-http2//lib/protocol/http2/reset_stream_frame.rb#16
Protocol::HTTP2::FRAME_SIZE_ERROR = T.let(T.unsafe(nil), Integer)

# Raised on invalid flow control frame or command.
#
# source://protocol-http2//lib/protocol/http2/error.rb#100
class Protocol::HTTP2::FlowControlError < ::Protocol::HTTP2::ProtocolError
  # @return [FlowControlError] a new instance of FlowControlError
  #
  # source://protocol-http2//lib/protocol/http2/error.rb#101
  def initialize(message); end
end

# source://protocol-http2//lib/protocol/http2/flow_controlled.rb#11
module Protocol::HTTP2::FlowControlled
  # This could be negative if the window has been overused due to a change in initial window size.
  #
  # source://protocol-http2//lib/protocol/http2/flow_controlled.rb#17
  def available_frame_size(maximum_frame_size = T.unsafe(nil)); end

  # source://protocol-http2//lib/protocol/http2/flow_controlled.rb#12
  def available_size; end

  # source://protocol-http2//lib/protocol/http2/flow_controlled.rb#48
  def consume_local_window(frame); end

  # Keep track of the amount of data sent, and fail if is too much.
  #
  # source://protocol-http2//lib/protocol/http2/flow_controlled.rb#30
  def consume_remote_window(frame); end

  # source://protocol-http2//lib/protocol/http2/flow_controlled.rb#70
  def receive_window_update(frame); end

  # source://protocol-http2//lib/protocol/http2/flow_controlled.rb#54
  def request_window_update; end

  # Notify the remote end that we are prepared to receive more data:
  #
  # source://protocol-http2//lib/protocol/http2/flow_controlled.rb#61
  def send_window_update(window_increment); end

  # source://protocol-http2//lib/protocol/http2/flow_controlled.rb#43
  def update_local_window(frame); end

  # The window has been expanded by the given amount.
  #
  # @param size [Integer] the maximum amount of data to send.
  # @return [Boolean] whether the window update was used or not.
  #
  # source://protocol-http2//lib/protocol/http2/flow_controlled.rb#87
  def window_updated(size); end
end

# source://protocol-http2//lib/protocol/http2/frame.rb#20
class Protocol::HTTP2::Frame
  include ::Comparable

  # @param length [Integer] the length of the payload, or nil if the header has not been read yet.
  # @return [Frame] a new instance of Frame
  #
  # source://protocol-http2//lib/protocol/http2/frame.rb#38
  def initialize(stream_id = T.unsafe(nil), flags = T.unsafe(nil), type = T.unsafe(nil), length = T.unsafe(nil), payload = T.unsafe(nil)); end

  # source://protocol-http2//lib/protocol/http2/frame.rb#50
  def <=>(other); end

  # source://protocol-http2//lib/protocol/http2/frame.rb#199
  def apply(connection); end

  # source://protocol-http2//lib/protocol/http2/frame.rb#93
  def clear_flags(mask); end

  # Check if frame is a connection frame: SETTINGS, PING, GOAWAY, and any
  # frame addressed to stream ID = 0.
  #
  # @return [Boolean]
  #
  # source://protocol-http2//lib/protocol/http2/frame.rb#105
  def connection?; end

  # @return [Boolean]
  #
  # source://protocol-http2//lib/protocol/http2/frame.rb#97
  def flag_set?(mask); end

  # Returns the value of attribute flags.
  #
  # source://protocol-http2//lib/protocol/http2/frame.rb#72
  def flags; end

  # Sets the attribute flags
  #
  # @param value the value to set the attribute flags to.
  #
  # source://protocol-http2//lib/protocol/http2/frame.rb#72
  def flags=(_arg0); end

  # Generates common 9-byte frame header.
  # - http://tools.ietf.org/html/draft-ietf-httpbis-http2-16#section-4.1
  #
  # @return [String]
  #
  # source://protocol-http2//lib/protocol/http2/frame.rb#116
  def header; end

  # source://protocol-http2//lib/protocol/http2/frame.rb#203
  def inspect; end

  # The generic frame header uses the following binary representation:
  #
  # +-----------------------------------------------+
  # |                 Length (24)                   |
  # +---------------+---------------+---------------+
  # |   Type (8)    |   Flags (8)   |
  # +-+-------------+---------------+-------------------------------+
  # |R|                 Stream Identifier (31)                      |
  # +=+=============================================================+
  # |                   Frame Payload (0...)                      ...
  # +---------------------------------------------------------------+
  #
  # source://protocol-http2//lib/protocol/http2/frame.rb#70
  def length; end

  # The generic frame header uses the following binary representation:
  #
  # +-----------------------------------------------+
  # |                 Length (24)                   |
  # +---------------+---------------+---------------+
  # |   Type (8)    |   Flags (8)   |
  # +-+-------------+---------------+-------------------------------+
  # |R|                 Stream Identifier (31)                      |
  # +=+=============================================================+
  # |                   Frame Payload (0...)                      ...
  # +---------------------------------------------------------------+
  #
  # source://protocol-http2//lib/protocol/http2/frame.rb#70
  def length=(_arg0); end

  # source://protocol-http2//lib/protocol/http2/frame.rb#80
  def pack(payload, maximum_size: T.unsafe(nil)); end

  # Returns the value of attribute payload.
  #
  # source://protocol-http2//lib/protocol/http2/frame.rb#74
  def payload; end

  # Sets the attribute payload
  #
  # @param value the value to set the attribute payload to.
  #
  # source://protocol-http2//lib/protocol/http2/frame.rb#74
  def payload=(_arg0); end

  # source://protocol-http2//lib/protocol/http2/frame.rb#165
  def read(stream, maximum_frame_size = T.unsafe(nil)); end

  # source://protocol-http2//lib/protocol/http2/frame.rb#148
  def read_header(stream); end

  # source://protocol-http2//lib/protocol/http2/frame.rb#157
  def read_payload(stream); end

  # source://protocol-http2//lib/protocol/http2/frame.rb#89
  def set_flags(mask); end

  # Returns the value of attribute stream_id.
  #
  # source://protocol-http2//lib/protocol/http2/frame.rb#73
  def stream_id; end

  # Sets the attribute stream_id
  #
  # @param value the value to set the attribute stream_id to.
  #
  # source://protocol-http2//lib/protocol/http2/frame.rb#73
  def stream_id=(_arg0); end

  # source://protocol-http2//lib/protocol/http2/frame.rb#54
  def to_ary; end

  # Returns the value of attribute type.
  #
  # source://protocol-http2//lib/protocol/http2/frame.rb#71
  def type; end

  # Sets the attribute type
  #
  # @param value the value to set the attribute type to.
  #
  # source://protocol-http2//lib/protocol/http2/frame.rb#71
  def type=(_arg0); end

  # source://protocol-http2//lib/protocol/http2/frame.rb#76
  def unpack; end

  # @return [Boolean]
  #
  # source://protocol-http2//lib/protocol/http2/frame.rb#46
  def valid_type?; end

  # source://protocol-http2//lib/protocol/http2/frame.rb#183
  def write(stream); end

  # source://protocol-http2//lib/protocol/http2/frame.rb#175
  def write_header(stream); end

  # source://protocol-http2//lib/protocol/http2/frame.rb#179
  def write_payload(stream); end

  class << self
    # Decodes common 9-byte header.
    #
    # @param buffer [String]
    #
    # source://protocol-http2//lib/protocol/http2/frame.rb#138
    def parse_header(buffer); end
  end
end

# source://protocol-http2//lib/protocol/http2/frame.rb#109
Protocol::HTTP2::Frame::HEADER_FORMAT = T.let(T.unsafe(nil), String)

# Used for generating 24-bit frame length:
#
# source://protocol-http2//lib/protocol/http2/frame.rb#31
Protocol::HTTP2::Frame::LENGTH_HISHIFT = T.let(T.unsafe(nil), Integer)

# source://protocol-http2//lib/protocol/http2/frame.rb#32
Protocol::HTTP2::Frame::LENGTH_LOMASK = T.let(T.unsafe(nil), Integer)

# source://protocol-http2//lib/protocol/http2/frame.rb#110
Protocol::HTTP2::Frame::STREAM_ID_MASK = T.let(T.unsafe(nil), Integer)

# The base class does not have any specific type index:
#
# source://protocol-http2//lib/protocol/http2/frame.rb#35
Protocol::HTTP2::Frame::TYPE = T.let(T.unsafe(nil), T.untyped)

# The absolute maximum bounds for the length field:
#
# source://protocol-http2//lib/protocol/http2/frame.rb#28
Protocol::HTTP2::Frame::VALID_LENGTH = T.let(T.unsafe(nil), Range)

# Stream Identifier cannot be bigger than this:
# https://http2.github.stream/http2-spec/#rfc.section.4.1
#
# source://protocol-http2//lib/protocol/http2/frame.rb#25
Protocol::HTTP2::Frame::VALID_STREAM_ID = T.let(T.unsafe(nil), Range)

# When the frame payload does not match expectations.
#
# source://protocol-http2//lib/protocol/http2/error.rb#87
class Protocol::HTTP2::FrameSizeError < ::Protocol::HTTP2::ProtocolError
  # @return [FrameSizeError] a new instance of FrameSizeError
  #
  # source://protocol-http2//lib/protocol/http2/error.rb#88
  def initialize(message); end
end

# source://protocol-http2//lib/protocol/http2/framer.rb#38
class Protocol::HTTP2::Framer
  # @return [Framer] a new instance of Framer
  #
  # source://protocol-http2//lib/protocol/http2/framer.rb#39
  def initialize(stream, frames = T.unsafe(nil)); end

  # source://protocol-http2//lib/protocol/http2/framer.rb#44
  def close; end

  # @return [Boolean]
  #
  # source://protocol-http2//lib/protocol/http2/framer.rb#48
  def closed?; end

  # source://protocol-http2//lib/protocol/http2/framer.rb#56
  def read_connection_preface; end

  # @raise if the underlying IO fails for some reason.
  # @return [Frame] the frame that has been read from the underlying IO.
  #
  # source://protocol-http2//lib/protocol/http2/framer.rb#68
  def read_frame(maximum_frame_size = T.unsafe(nil)); end

  # @raise [EOFError]
  #
  # source://protocol-http2//lib/protocol/http2/framer.rb#97
  def read_header; end

  # source://protocol-http2//lib/protocol/http2/framer.rb#52
  def write_connection_preface; end

  # source://protocol-http2//lib/protocol/http2/framer.rb#86
  def write_frame(frame); end
end

# source://protocol-http2//lib/protocol/http2/error.rb#83
class Protocol::HTTP2::GoawayError < ::Protocol::HTTP2::ProtocolError; end

# The GOAWAY frame is used to initiate shutdown of a connection or to signal serious error conditions. GOAWAY allows an endpoint to gracefully stop accepting new streams while still finishing processing of previously established streams. This enables administrative actions, like server maintenance.
#
# +-+-------------------------------------------------------------+
# |R|                  Last-Stream-ID (31)                        |
# +-+-------------------------------------------------------------+
# |                      Error Code (32)                          |
# +---------------------------------------------------------------+
# |                  Additional Debug Data (*)                    |
# +---------------------------------------------------------------+
#
# source://protocol-http2//lib/protocol/http2/goaway_frame.rb#20
class Protocol::HTTP2::GoawayFrame < ::Protocol::HTTP2::Frame
  # source://protocol-http2//lib/protocol/http2/goaway_frame.rb#40
  def apply(connection); end

  # @return [Boolean]
  #
  # source://protocol-http2//lib/protocol/http2/goaway_frame.rb#24
  def connection?; end

  # source://protocol-http2//lib/protocol/http2/goaway_frame.rb#36
  def pack(last_stream_id, error_code, data); end

  # source://protocol-http2//lib/protocol/http2/goaway_frame.rb#28
  def unpack; end
end

# source://protocol-http2//lib/protocol/http2/goaway_frame.rb#22
Protocol::HTTP2::GoawayFrame::FORMAT = T.let(T.unsafe(nil), String)

# source://protocol-http2//lib/protocol/http2/goaway_frame.rb#21
Protocol::HTTP2::GoawayFrame::TYPE = T.let(T.unsafe(nil), Integer)

# source://protocol-http2//lib/protocol/http2/reset_stream_frame.rb#23
Protocol::HTTP2::HTTP_1_1_REQUIRED = T.let(T.unsafe(nil), Integer)

# Raised if connection header is missing or invalid indicating that
# this is an invalid HTTP 2.0 request - no frames are emitted and the
# connection must be aborted.
#
# source://protocol-http2//lib/protocol/http2/error.rb#58
class Protocol::HTTP2::HandshakeError < ::Protocol::HTTP2::Error; end

# source://protocol-http2//lib/protocol/http2/error.rb#93
class Protocol::HTTP2::HeaderError < ::Protocol::HTTP2::StreamClosed
  # @return [HeaderError] a new instance of HeaderError
  #
  # source://protocol-http2//lib/protocol/http2/error.rb#94
  def initialize(message); end
end

# The HEADERS frame is used to open a stream, and additionally carries a header block fragment. HEADERS frames can be sent on a stream in the "idle", "reserved (local)", "open", or "half-closed (remote)" state.
#
# +---------------+
# |Pad Length? (8)|
# +-+-------------+-----------------------------------------------+
# |E|                 Stream Dependency? (31)                     |
# +-+-------------+-----------------------------------------------+
# |  Weight? (8)  |
# +-+-------------+-----------------------------------------------+
# |                   Header Block Fragment (*)                 ...
# +---------------------------------------------------------------+
# |                           Padding (*)                       ...
# +---------------------------------------------------------------+
#
# source://protocol-http2//lib/protocol/http2/headers_frame.rb#27
class Protocol::HTTP2::HeadersFrame < ::Protocol::HTTP2::Frame
  include ::Protocol::HTTP2::Padded
  include ::Protocol::HTTP2::Continued

  # source://protocol-http2//lib/protocol/http2/headers_frame.rb#66
  def apply(connection); end

  # @return [Boolean]
  #
  # source://protocol-http2//lib/protocol/http2/headers_frame.rb#36
  def end_stream?; end

  # source://protocol-http2//lib/protocol/http2/headers_frame.rb#70
  def inspect; end

  # source://protocol-http2//lib/protocol/http2/headers_frame.rb#51
  def pack(priority, data, *arguments, **options); end

  # @return [Boolean]
  #
  # source://protocol-http2//lib/protocol/http2/headers_frame.rb#32
  def priority?; end

  # source://protocol-http2//lib/protocol/http2/headers_frame.rb#40
  def unpack; end
end

# source://protocol-http2//lib/protocol/http2/headers_frame.rb#30
Protocol::HTTP2::HeadersFrame::TYPE = T.let(T.unsafe(nil), Integer)

# source://protocol-http2//lib/protocol/http2/reset_stream_frame.rb#22
Protocol::HTTP2::INADEQUATE_SECURITY = T.let(T.unsafe(nil), Integer)

# source://protocol-http2//lib/protocol/http2/reset_stream_frame.rb#12
Protocol::HTTP2::INTERNAL_ERROR = T.let(T.unsafe(nil), Integer)

# This is a window which efficiently maintains a desired capacity.
#
# source://protocol-http2//lib/protocol/http2/window_update_frame.rb#79
class Protocol::HTTP2::LocalWindow < ::Protocol::HTTP2::Window
  # @return [LocalWindow] a new instance of LocalWindow
  #
  # source://protocol-http2//lib/protocol/http2/window_update_frame.rb#80
  def initialize(capacity = T.unsafe(nil), desired: T.unsafe(nil)); end

  # Returns the value of attribute desired.
  #
  # source://protocol-http2//lib/protocol/http2/window_update_frame.rb#86
  def desired; end

  # Sets the attribute desired
  #
  # @param value the value to set the attribute desired to.
  #
  # source://protocol-http2//lib/protocol/http2/window_update_frame.rb#86
  def desired=(_arg0); end

  # @return [Boolean]
  #
  # source://protocol-http2//lib/protocol/http2/window_update_frame.rb#97
  def limited?; end

  # source://protocol-http2//lib/protocol/http2/window_update_frame.rb#88
  def wanted; end
end

# source://protocol-http2//lib/protocol/http2/frame.rb#18
Protocol::HTTP2::MAXIMUM_ALLOWED_FRAME_SIZE = T.let(T.unsafe(nil), Integer)

# source://protocol-http2//lib/protocol/http2/frame.rb#16
Protocol::HTTP2::MAXIMUM_ALLOWED_WINDOW_SIZE = T.let(T.unsafe(nil), Integer)

# source://protocol-http2//lib/protocol/http2/frame.rb#17
Protocol::HTTP2::MINIMUM_ALLOWED_FRAME_SIZE = T.let(T.unsafe(nil), Integer)

# source://protocol-http2//lib/protocol/http2/reset_stream_frame.rb#10
Protocol::HTTP2::NO_ERROR = T.let(T.unsafe(nil), Integer)

# source://protocol-http2//lib/protocol/http2/frame.rb#13
Protocol::HTTP2::PADDED = T.let(T.unsafe(nil), Integer)

# source://protocol-http2//lib/protocol/http2/frame.rb#14
Protocol::HTTP2::PRIORITY = T.let(T.unsafe(nil), Integer)

# source://protocol-http2//lib/protocol/http2/reset_stream_frame.rb#11
Protocol::HTTP2::PROTOCOL_ERROR = T.let(T.unsafe(nil), Integer)

# Certain frames can have padding:
# https://http2.github.io/http2-spec/#padding
#
# +---------------+
# |Pad Length? (8)|
# +---------------+-----------------------------------------------+
# |                            Data (*)                         ...
# +---------------------------------------------------------------+
# |                           Padding (*)                       ...
# +---------------------------------------------------------------+
#
# source://protocol-http2//lib/protocol/http2/padded.rb#21
module Protocol::HTTP2::Padded
  # source://protocol-http2//lib/protocol/http2/padded.rb#26
  def pack(data, padding_size: T.unsafe(nil), maximum_size: T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://protocol-http2//lib/protocol/http2/padded.rb#22
  def padded?; end

  # source://protocol-http2//lib/protocol/http2/padded.rb#47
  def unpack; end
end

# source://protocol-http2//lib/protocol/http2/settings_frame.rb#148
class Protocol::HTTP2::PendingSettings
  # @return [PendingSettings] a new instance of PendingSettings
  #
  # source://protocol-http2//lib/protocol/http2/settings_frame.rb#149
  def initialize(current = T.unsafe(nil)); end

  # source://protocol-http2//lib/protocol/http2/settings_frame.rb#164
  def acknowledge; end

  # source://protocol-http2//lib/protocol/http2/settings_frame.rb#159
  def append(changes); end

  # Returns the value of attribute current.
  #
  # source://protocol-http2//lib/protocol/http2/settings_frame.rb#156
  def current; end

  # source://protocol-http2//lib/protocol/http2/settings_frame.rb#198
  def enable_connect_protocol; end

  # source://protocol-http2//lib/protocol/http2/settings_frame.rb#178
  def enable_push; end

  # source://protocol-http2//lib/protocol/http2/settings_frame.rb#174
  def header_table_size; end

  # source://protocol-http2//lib/protocol/http2/settings_frame.rb#186
  def initial_window_size; end

  # source://protocol-http2//lib/protocol/http2/settings_frame.rb#182
  def maximum_concurrent_streams; end

  # source://protocol-http2//lib/protocol/http2/settings_frame.rb#190
  def maximum_frame_size; end

  # source://protocol-http2//lib/protocol/http2/settings_frame.rb#194
  def maximum_header_list_size; end

  # Returns the value of attribute pending.
  #
  # source://protocol-http2//lib/protocol/http2/settings_frame.rb#157
  def pending; end
end

# The PING frame is a mechanism for measuring a minimal round-trip time from the sender, as well as determining whether an idle connection is still functional. PING frames can be sent from any endpoint.
#
# +---------------------------------------------------------------+
# |                                                               |
# |                      Opaque Data (64)                         |
# |                                                               |
# +---------------------------------------------------------------+
#
# source://protocol-http2//lib/protocol/http2/ping_frame.rb#39
class Protocol::HTTP2::PingFrame < ::Protocol::HTTP2::Frame
  include ::Protocol::HTTP2::Acknowledgement

  # source://protocol-http2//lib/protocol/http2/ping_frame.rb#52
  def acknowledge; end

  # source://protocol-http2//lib/protocol/http2/ping_frame.rb#48
  def apply(connection); end

  # @return [Boolean]
  #
  # source://protocol-http2//lib/protocol/http2/ping_frame.rb#44
  def connection?; end

  # source://protocol-http2//lib/protocol/http2/ping_frame.rb#60
  def read_payload(stream); end
end

# source://protocol-http2//lib/protocol/http2/ping_frame.rb#40
Protocol::HTTP2::PingFrame::TYPE = T.let(T.unsafe(nil), Integer)

# Stream Dependency:  A 31-bit stream identifier for the stream that
# this stream depends on (see Section 5.3).  This field is only
# present if the PRIORITY flag is set.
#
# source://protocol-http2//lib/protocol/http2/priority_frame.rb#15
class Protocol::HTTP2::Priority < ::Struct
  # source://protocol-http2//lib/protocol/http2/priority_frame.rb#31
  def pack; end

  # Sets the attribute weight
  #
  # @param value [Object] the value to set the attribute weight to.
  # @return [Object] the newly set value
  #
  # source://protocol-http2//lib/protocol/http2/priority_frame.rb#41
  def weight=(value); end

  class << self
    # All streams are initially assigned a non-exclusive dependency on stream 0x0.  Pushed streams (Section 8.2) initially depend on their associated stream.  In both cases, streams are assigned a default weight of 16.
    #
    # source://protocol-http2//lib/protocol/http2/priority_frame.rb#20
    def default(stream_dependency = T.unsafe(nil), weight = T.unsafe(nil)); end

    # source://protocol-http2//lib/protocol/http2/priority_frame.rb#24
    def unpack(data); end
  end
end

# source://protocol-http2//lib/protocol/http2/priority_frame.rb#17
Protocol::HTTP2::Priority::EXCLUSIVE = T.let(T.unsafe(nil), Integer)

# source://protocol-http2//lib/protocol/http2/priority_frame.rb#16
Protocol::HTTP2::Priority::FORMAT = T.let(T.unsafe(nil), String)

# The PRIORITY frame specifies the sender-advised priority of a stream. It can be sent in any stream state, including idle or closed streams.
#
# +-+-------------------------------------------------------------+
# |E|                  Stream Dependency (31)                     |
# +-+-------------+-----------------------------------------------+
# |   Weight (8)  |
# +-+-------------+
#
# source://protocol-http2//lib/protocol/http2/priority_frame.rb#58
class Protocol::HTTP2::PriorityFrame < ::Protocol::HTTP2::Frame
  # source://protocol-http2//lib/protocol/http2/priority_frame.rb#69
  def apply(connection); end

  # source://protocol-http2//lib/protocol/http2/priority_frame.rb#61
  def pack(priority); end

  # source://protocol-http2//lib/protocol/http2/priority_frame.rb#73
  def read_payload(stream); end

  # source://protocol-http2//lib/protocol/http2/priority_frame.rb#65
  def unpack; end
end

# source://protocol-http2//lib/protocol/http2/priority_frame.rb#59
Protocol::HTTP2::PriorityFrame::TYPE = T.let(T.unsafe(nil), Integer)

# Raised by stream or connection handlers, results in GOAWAY frame
# which signals termination of the current connection. You *cannot*
# recover from this exception, or any exceptions subclassed from it.
#
# source://protocol-http2//lib/protocol/http2/error.rb#64
class Protocol::HTTP2::ProtocolError < ::Protocol::HTTP2::Error
  # @return [ProtocolError] a new instance of ProtocolError
  #
  # source://protocol-http2//lib/protocol/http2/error.rb#65
  def initialize(message, code = T.unsafe(nil)); end

  # Returns the value of attribute code.
  #
  # source://protocol-http2//lib/protocol/http2/error.rb#71
  def code; end
end

# The PUSH_PROMISE frame is used to notify the peer endpoint in advance of streams the sender intends to initiate. The PUSH_PROMISE frame includes the unsigned 31-bit identifier of the stream the endpoint plans to create along with a set of headers that provide additional context for the stream.
#
# +---------------+
# |Pad Length? (8)|
# +-+-------------+-----------------------------------------------+
# |R|                  Promised Stream ID (31)                    |
# +-+-----------------------------+-------------------------------+
# |                   Header Block Fragment (*)                 ...
# +---------------------------------------------------------------+
# |                           Padding (*)                       ...
# +---------------------------------------------------------------+
#
# source://protocol-http2//lib/protocol/http2/push_promise_frame.rb#24
class Protocol::HTTP2::PushPromiseFrame < ::Protocol::HTTP2::Frame
  include ::Protocol::HTTP2::Padded
  include ::Protocol::HTTP2::Continued

  # source://protocol-http2//lib/protocol/http2/push_promise_frame.rb#42
  def apply(connection); end

  # source://protocol-http2//lib/protocol/http2/push_promise_frame.rb#38
  def pack(stream_id, data, *arguments, **options); end

  # source://protocol-http2//lib/protocol/http2/push_promise_frame.rb#30
  def unpack; end
end

# source://protocol-http2//lib/protocol/http2/push_promise_frame.rb#28
Protocol::HTTP2::PushPromiseFrame::FORMAT = T.let(T.unsafe(nil), String)

# source://protocol-http2//lib/protocol/http2/push_promise_frame.rb#27
Protocol::HTTP2::PushPromiseFrame::TYPE = T.let(T.unsafe(nil), Integer)

# source://protocol-http2//lib/protocol/http2/reset_stream_frame.rb#17
Protocol::HTTP2::REFUSED_STREAM = T.let(T.unsafe(nil), Integer)

# The RST_STREAM frame allows for immediate termination of a stream. RST_STREAM is sent to request cancellation of a stream or to indicate that an error condition has occurred.
#
# +---------------------------------------------------------------+
# |                        Error Code (32)                        |
# +---------------------------------------------------------------+
#
# source://protocol-http2//lib/protocol/http2/reset_stream_frame.rb#31
class Protocol::HTTP2::ResetStreamFrame < ::Protocol::HTTP2::Frame
  # source://protocol-http2//lib/protocol/http2/reset_stream_frame.rb#44
  def apply(connection); end

  # source://protocol-http2//lib/protocol/http2/reset_stream_frame.rb#39
  def pack(error_code = T.unsafe(nil)); end

  # source://protocol-http2//lib/protocol/http2/reset_stream_frame.rb#48
  def read_payload(stream); end

  # source://protocol-http2//lib/protocol/http2/reset_stream_frame.rb#35
  def unpack; end
end

# source://protocol-http2//lib/protocol/http2/reset_stream_frame.rb#33
Protocol::HTTP2::ResetStreamFrame::FORMAT = T.let(T.unsafe(nil), String)

# source://protocol-http2//lib/protocol/http2/reset_stream_frame.rb#32
Protocol::HTTP2::ResetStreamFrame::TYPE = T.let(T.unsafe(nil), Integer)

# source://protocol-http2//lib/protocol/http2/reset_stream_frame.rb#15
Protocol::HTTP2::STREAM_CLOSED = T.let(T.unsafe(nil), Integer)

# source://protocol-http2//lib/protocol/http2/server.rb#10
class Protocol::HTTP2::Server < ::Protocol::HTTP2::Connection
  # @return [Server] a new instance of Server
  #
  # source://protocol-http2//lib/protocol/http2/server.rb#11
  def initialize(framer); end

  # @raise [ProtocolError]
  #
  # source://protocol-http2//lib/protocol/http2/server.rb#41
  def accept_push_promise_stream(stream_id, &block); end

  # @return [Boolean]
  #
  # source://protocol-http2//lib/protocol/http2/server.rb#45
  def enable_push?; end

  # @return [Boolean]
  #
  # source://protocol-http2//lib/protocol/http2/server.rb#15
  def local_stream_id?(id); end

  # source://protocol-http2//lib/protocol/http2/server.rb#27
  def read_connection_preface(settings = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://protocol-http2//lib/protocol/http2/server.rb#19
  def remote_stream_id?(id); end

  # @return [Boolean]
  #
  # source://protocol-http2//lib/protocol/http2/server.rb#23
  def valid_remote_stream_id?(stream_id); end
end

# source://protocol-http2//lib/protocol/http2/settings_frame.rb#10
class Protocol::HTTP2::Settings
  # @return [Settings] a new instance of Settings
  #
  # source://protocol-http2//lib/protocol/http2/settings_frame.rb#93
  def initialize; end

  # source://protocol-http2//lib/protocol/http2/settings_frame.rb#113
  def difference(other); end

  # Returns the value of attribute enable_connect_protocol.
  #
  # source://protocol-http2//lib/protocol/http2/settings_frame.rb#79
  def enable_connect_protocol; end

  # source://protocol-http2//lib/protocol/http2/settings_frame.rb#81
  def enable_connect_protocol=(value); end

  # @return [Boolean]
  #
  # source://protocol-http2//lib/protocol/http2/settings_frame.rb#89
  def enable_connect_protocol?; end

  # This setting can be used to disable server push. An endpoint MUST NOT send a PUSH_PROMISE frame if it receives this parameter set to a value of 0.
  #
  # source://protocol-http2//lib/protocol/http2/settings_frame.rb#35
  def enable_push; end

  # source://protocol-http2//lib/protocol/http2/settings_frame.rb#37
  def enable_push=(value); end

  # @return [Boolean]
  #
  # source://protocol-http2//lib/protocol/http2/settings_frame.rb#45
  def enable_push?; end

  # Allows the sender to inform the remote endpoint of the maximum size of the header compression table used to decode header blocks, in octets.
  #
  # source://protocol-http2//lib/protocol/http2/settings_frame.rb#32
  def header_table_size; end

  # Allows the sender to inform the remote endpoint of the maximum size of the header compression table used to decode header blocks, in octets.
  #
  # source://protocol-http2//lib/protocol/http2/settings_frame.rb#32
  def header_table_size=(_arg0); end

  # Indicates the sender's initial window size (in octets) for stream-level flow control.
  #
  # source://protocol-http2//lib/protocol/http2/settings_frame.rb#53
  def initial_window_size; end

  # source://protocol-http2//lib/protocol/http2/settings_frame.rb#55
  def initial_window_size=(value); end

  # Indicates the maximum number of concurrent streams that the sender will allow.
  #
  # source://protocol-http2//lib/protocol/http2/settings_frame.rb#50
  def maximum_concurrent_streams; end

  # Indicates the maximum number of concurrent streams that the sender will allow.
  #
  # source://protocol-http2//lib/protocol/http2/settings_frame.rb#50
  def maximum_concurrent_streams=(_arg0); end

  # Indicates the size of the largest frame payload that the sender is willing to receive, in octets.
  #
  # source://protocol-http2//lib/protocol/http2/settings_frame.rb#64
  def maximum_frame_size; end

  # source://protocol-http2//lib/protocol/http2/settings_frame.rb#66
  def maximum_frame_size=(value); end

  # This advisory setting informs a peer of the maximum size of header list that the sender is prepared to accept, in octets.
  #
  # source://protocol-http2//lib/protocol/http2/settings_frame.rb#77
  def maximum_header_list_size; end

  # This advisory setting informs a peer of the maximum size of header list that the sender is prepared to accept, in octets.
  #
  # source://protocol-http2//lib/protocol/http2/settings_frame.rb#77
  def maximum_header_list_size=(_arg0); end

  # source://protocol-http2//lib/protocol/http2/settings_frame.rb#105
  def update(changes); end
end

# source://protocol-http2//lib/protocol/http2/settings_frame.rb#19
Protocol::HTTP2::Settings::ASSIGN = T.let(T.unsafe(nil), Array)

# source://protocol-http2//lib/protocol/http2/settings_frame.rb#17
Protocol::HTTP2::Settings::ENABLE_CONNECT_PROTOCOL = T.let(T.unsafe(nil), Integer)

# source://protocol-http2//lib/protocol/http2/settings_frame.rb#12
Protocol::HTTP2::Settings::ENABLE_PUSH = T.let(T.unsafe(nil), Integer)

# source://protocol-http2//lib/protocol/http2/settings_frame.rb#11
Protocol::HTTP2::Settings::HEADER_TABLE_SIZE = T.let(T.unsafe(nil), Integer)

# source://protocol-http2//lib/protocol/http2/settings_frame.rb#14
Protocol::HTTP2::Settings::INITIAL_WINDOW_SIZE = T.let(T.unsafe(nil), Integer)

# source://protocol-http2//lib/protocol/http2/settings_frame.rb#13
Protocol::HTTP2::Settings::MAXIMUM_CONCURRENT_STREAMS = T.let(T.unsafe(nil), Integer)

# source://protocol-http2//lib/protocol/http2/settings_frame.rb#15
Protocol::HTTP2::Settings::MAXIMUM_FRAME_SIZE = T.let(T.unsafe(nil), Integer)

# source://protocol-http2//lib/protocol/http2/settings_frame.rb#16
Protocol::HTTP2::Settings::MAXIMUM_HEADER_LIST_SIZE = T.let(T.unsafe(nil), Integer)

# The SETTINGS frame conveys configuration parameters that affect how endpoints communicate, such as preferences and constraints on peer behavior. The SETTINGS frame is also used to acknowledge the receipt of those parameters. Individually, a SETTINGS parameter can also be referred to as a "setting".
#
# +-------------------------------+
# |       Identifier (16)         |
# +-------------------------------+-------------------------------+
# |                        Value (32)                             |
# +---------------------------------------------------------------+
#
# source://protocol-http2//lib/protocol/http2/settings_frame.rb#211
class Protocol::HTTP2::SettingsFrame < ::Protocol::HTTP2::Frame
  include ::Protocol::HTTP2::Acknowledgement

  # source://protocol-http2//lib/protocol/http2/settings_frame.rb#234
  def apply(connection); end

  # @return [Boolean]
  #
  # source://protocol-http2//lib/protocol/http2/settings_frame.rb#217
  def connection?; end

  # source://protocol-http2//lib/protocol/http2/settings_frame.rb#230
  def pack(settings = T.unsafe(nil)); end

  # source://protocol-http2//lib/protocol/http2/settings_frame.rb#238
  def read_payload(stream); end

  # source://protocol-http2//lib/protocol/http2/settings_frame.rb#221
  def unpack; end
end

# source://protocol-http2//lib/protocol/http2/settings_frame.rb#213
Protocol::HTTP2::SettingsFrame::FORMAT = T.let(T.unsafe(nil), String)

# source://protocol-http2//lib/protocol/http2/settings_frame.rb#212
Protocol::HTTP2::SettingsFrame::TYPE = T.let(T.unsafe(nil), Integer)

# A single HTTP 2.0 connection can multiplex multiple streams in parallel:
# multiple requests and responses can be in flight simultaneously and stream
# data can be interleaved and prioritized.
#
# This class encapsulates all of the state, transition, flow-control, and
# error management as defined by the HTTP 2.0 specification. All you have
# to do is subscribe to appropriate events (marked with ":" prefix in
# diagram below) and provide your application logic to handle request
# and response processing.
#
#                          +--------+
#                  send PP |        | recv PP
#                 ,--------|  idle  |--------.
#                /         |        |         \
#               v          +--------+          v
#        +----------+          |           +----------+
#        |          |          | send H /  |          |
# ,------| reserved |          | recv H    | reserved |------.
# |      | (local)  |          |           | (remote) |      |
# |      +----------+          v           +----------+      |
# |          |             +--------+             |          |
# |          |     recv ES |        | send ES     |          |
# |   send H |     ,-------|  open  |-------.     | recv H   |
# |          |    /        |        |        \    |          |
# |          v   v         +--------+         v   v          |
# |      +----------+          |           +----------+      |
# |      |   half   |          |           |   half   |      |
# |      |  closed  |          | send R /  |  closed  |      |
# |      | (remote) |          | recv R    | (local)  |      |
# |      +----------+          |           +----------+      |
# |           |                |                 |           |
# |           | send ES /      |       recv ES / |           |
# |           | send R /       v        send R / |           |
# |           | recv R     +--------+   recv R   |           |
# | send R /  `----------->|        |<-----------'  send R / |
# | recv R                 | closed |               recv R   |
# `----------------------->|        |<----------------------'
#                          +--------+
#
#    send:   endpoint sends this frame
#    recv:   endpoint receives this frame
#
#    H:  HEADERS frame (with implied CONTINUATIONs)
#    PP: PUSH_PROMISE frame (with implied CONTINUATIONs)
#    ES: END_STREAM flag
#    R:  RST_STREAM frame
#
# State transition methods use a trailing "!".
#
# source://protocol-http2//lib/protocol/http2/stream.rb#59
class Protocol::HTTP2::Stream
  include ::Protocol::HTTP2::FlowControlled

  # @return [Stream] a new instance of Stream
  #
  # source://protocol-http2//lib/protocol/http2/stream.rb#70
  def initialize(connection, id, state = T.unsafe(nil)); end

  # Override this function to implement your own push promise logic.
  #
  # source://protocol-http2//lib/protocol/http2/stream.rb#425
  def accept_push_promise_stream(stream_id, headers); end

  # @return [Boolean]
  #
  # source://protocol-http2//lib/protocol/http2/stream.rb#120
  def active?; end

  # Transition directly to closed state. Do not pass go, do not collect $200.
  # This method should only be used by `Connection#close`.
  #
  # source://protocol-http2//lib/protocol/http2/stream.rb#130
  def close(error = T.unsafe(nil)); end

  # Transition the stream into the closed state.
  #
  # @param error_code [Integer] the error code if the stream was closed due to a stream reset.
  #
  # source://protocol-http2//lib/protocol/http2/stream.rb#244
  def close!(error_code = T.unsafe(nil)); end

  # The stream has been closed. If closed due to a stream reset, the error will be set.
  #
  # source://protocol-http2//lib/protocol/http2/stream.rb#239
  def closed(error = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://protocol-http2//lib/protocol/http2/stream.rb#124
  def closed?; end

  # The connection this stream belongs to.
  #
  # source://protocol-http2//lib/protocol/http2/stream.rb#83
  def connection; end

  # source://protocol-http2//lib/protocol/http2/stream.rb#187
  def consume_remote_window(frame); end

  # Override this function to implement your own push promise logic.
  #
  # source://protocol-http2//lib/protocol/http2/stream.rb#403
  def create_push_promise_stream(headers); end

  # Returns the value of attribute dependency.
  #
  # source://protocol-http2//lib/protocol/http2/stream.rb#91
  def dependency; end

  # Stream ID (odd for client initiated streams, even otherwise).
  #
  # source://protocol-http2//lib/protocol/http2/stream.rb#86
  def id; end

  # source://protocol-http2//lib/protocol/http2/stream.rb#322
  def ignore_data(frame); end

  # source://protocol-http2//lib/protocol/http2/stream.rb#440
  def inspect; end

  # Returns the value of attribute local_window.
  #
  # source://protocol-http2//lib/protocol/http2/stream.rb#93
  def local_window; end

  # source://protocol-http2//lib/protocol/http2/stream.rb#112
  def maximum_frame_size; end

  # source://protocol-http2//lib/protocol/http2/stream.rb#226
  def open!; end

  # The stream has been opened.
  #
  # source://protocol-http2//lib/protocol/http2/stream.rb#223
  def opened(error = T.unsafe(nil)); end

  # source://protocol-http2//lib/protocol/http2/stream.rb#108
  def parent=(stream); end

  # source://protocol-http2//lib/protocol/http2/stream.rb#100
  def priority; end

  # source://protocol-http2//lib/protocol/http2/stream.rb#104
  def priority=(priority); end

  # @return [String] the data that was received.
  #
  # source://protocol-http2//lib/protocol/http2/stream.rb#318
  def process_data(frame); end

  # source://protocol-http2//lib/protocol/http2/stream.rb#270
  def process_headers(frame); end

  # DATA frames are subject to flow control and can only be sent when a stream is in the "open" or "half-closed (remote)" state.  The entire DATA frame payload is included in flow control, including the Pad Length and Padding fields if present.  If a DATA frame is received whose stream is not in "open" or "half-closed (local)" state, the recipient MUST respond with a stream error of type STREAM_CLOSED.
  #
  # source://protocol-http2//lib/protocol/http2/stream.rb#327
  def receive_data(frame); end

  # source://protocol-http2//lib/protocol/http2/stream.rb#285
  def receive_headers(frame); end

  # source://protocol-http2//lib/protocol/http2/stream.rb#429
  def receive_push_promise(frame); end

  # source://protocol-http2//lib/protocol/http2/stream.rb#352
  def receive_reset_stream(frame); end

  # Returns the value of attribute remote_window.
  #
  # source://protocol-http2//lib/protocol/http2/stream.rb#94
  def remote_window; end

  # source://protocol-http2//lib/protocol/http2/stream.rb#382
  def reserved_local!; end

  # source://protocol-http2//lib/protocol/http2/stream.rb#392
  def reserved_remote!; end

  # source://protocol-http2//lib/protocol/http2/stream.rb#204
  def send_data(*arguments, **options); end

  # The HEADERS frame is used to open a stream, and additionally carries a header block fragment. HEADERS frames can be sent on a stream in the "idle", "reserved (local)", "open", or "half-closed (remote)" state.
  #
  # source://protocol-http2//lib/protocol/http2/stream.rb#157
  def send_headers(*arguments); end

  # HEADERS frames can be sent on a stream in the "idle", "reserved (local)", "open", or "half-closed (remote)" state. Despite it's name, it can also be used for trailers.
  #
  # @return [Boolean]
  #
  # source://protocol-http2//lib/protocol/http2/stream.rb#138
  def send_headers?; end

  # Server push is semantically equivalent to a server responding to a request; however, in this case, that request is also sent by the server, as a PUSH_PROMISE frame.
  #
  # @param headers [Hash] contains a complete set of request header fields that the server attributes to the request.
  #
  # source://protocol-http2//lib/protocol/http2/stream.rb#409
  def send_push_promise(headers); end

  # source://protocol-http2//lib/protocol/http2/stream.rb#257
  def send_reset_stream(error_code = T.unsafe(nil)); end

  # Stream state, e.g. `idle`, `closed`.
  #
  # source://protocol-http2//lib/protocol/http2/stream.rb#89
  def state; end

  # Stream state, e.g. `idle`, `closed`.
  #
  # source://protocol-http2//lib/protocol/http2/stream.rb#89
  def state=(_arg0); end

  # source://protocol-http2//lib/protocol/http2/stream.rb#96
  def weight; end

  # source://protocol-http2//lib/protocol/http2/stream.rb#116
  def write_frame(frame); end

  protected

  # source://protocol-http2//lib/protocol/http2/stream.rb#281
  def ignore_headers(frame); end

  private

  # source://protocol-http2//lib/protocol/http2/stream.rb#193
  def write_data(data, flags = T.unsafe(nil), **options); end

  # source://protocol-http2//lib/protocol/http2/stream.rb#142
  def write_headers(priority, headers, flags = T.unsafe(nil)); end

  # A normal request is client request -> server response -> client.
  # A push promise is server request -> client -> server response -> client.
  # The server generates the same set of headers as if the client was sending a request, and sends these to the client. The client can reject the request by resetting the (new) stream. Otherwise, the server will start sending a response as if the client had send the request.
  #
  # source://protocol-http2//lib/protocol/http2/stream.rb#368
  def write_push_promise(stream_id, headers, flags = T.unsafe(nil), **options); end

  class << self
    # source://protocol-http2//lib/protocol/http2/stream.rb#62
    def create(connection, id); end
  end
end

# source://protocol-http2//lib/protocol/http2/error.rb#77
class Protocol::HTTP2::StreamClosed < ::Protocol::HTTP2::StreamError
  # @return [StreamClosed] a new instance of StreamClosed
  #
  # source://protocol-http2//lib/protocol/http2/error.rb#78
  def initialize(message); end
end

# source://protocol-http2//lib/protocol/http2/error.rb#74
class Protocol::HTTP2::StreamError < ::Protocol::HTTP2::ProtocolError; end

# source://protocol-http2//lib/protocol/http2/reset_stream_frame.rb#14
Protocol::HTTP2::TIMEOUT = T.let(T.unsafe(nil), Integer)

# source://protocol-http2//lib/protocol/http2/priority_frame.rb#10
Protocol::HTTP2::VALID_WEIGHT = T.let(T.unsafe(nil), Range)

# source://protocol-http2//lib/protocol/http2/window_update_frame.rb#10
class Protocol::HTTP2::Window
  # @param capacity [Integer] The initial window size, typically from the settings.
  # @return [Window] a new instance of Window
  #
  # source://protocol-http2//lib/protocol/http2/window_update_frame.rb#12
  def initialize(capacity = T.unsafe(nil)); end

  # Returns the value of attribute available.
  #
  # source://protocol-http2//lib/protocol/http2/window_update_frame.rb#47
  def available; end

  # @return [Boolean]
  #
  # source://protocol-http2//lib/protocol/http2/window_update_frame.rb#49
  def available?; end

  # Returns the value of attribute capacity.
  #
  # source://protocol-http2//lib/protocol/http2/window_update_frame.rb#27
  def capacity; end

  # When the value of SETTINGS_INITIAL_WINDOW_SIZE changes, a receiver MUST adjust the size of all stream flow-control windows that it maintains by the difference between the new value and the old value.
  #
  # source://protocol-http2//lib/protocol/http2/window_update_frame.rb#30
  def capacity=(value); end

  # source://protocol-http2//lib/protocol/http2/window_update_frame.rb#42
  def consume(amount); end

  # source://protocol-http2//lib/protocol/http2/window_update_frame.rb#53
  def expand(amount); end

  # The window is completely full?
  #
  # @return [Boolean]
  #
  # source://protocol-http2//lib/protocol/http2/window_update_frame.rb#22
  def full?; end

  # source://protocol-http2//lib/protocol/http2/window_update_frame.rb#73
  def inspect; end

  # @return [Boolean]
  #
  # source://protocol-http2//lib/protocol/http2/window_update_frame.rb#69
  def limited?; end

  # Returns the value of attribute used.
  #
  # source://protocol-http2//lib/protocol/http2/window_update_frame.rb#26
  def used; end

  # source://protocol-http2//lib/protocol/http2/window_update_frame.rb#65
  def wanted; end
end

# The WINDOW_UPDATE frame is used to implement flow control.
#
# +-+-------------------------------------------------------------+
# |R|              Window Size Increment (31)                     |
# +-+-------------------------------------------------------------+
#
# source://protocol-http2//lib/protocol/http2/window_update_frame.rb#112
class Protocol::HTTP2::WindowUpdateFrame < ::Protocol::HTTP2::Frame
  # source://protocol-http2//lib/protocol/http2/window_update_frame.rb#132
  def apply(connection); end

  # source://protocol-http2//lib/protocol/http2/window_update_frame.rb#116
  def pack(window_size_increment); end

  # source://protocol-http2//lib/protocol/http2/window_update_frame.rb#124
  def read_payload(stream); end

  # source://protocol-http2//lib/protocol/http2/window_update_frame.rb#120
  def unpack; end
end

# source://protocol-http2//lib/protocol/http2/window_update_frame.rb#114
Protocol::HTTP2::WindowUpdateFrame::FORMAT = T.let(T.unsafe(nil), String)

# source://protocol-http2//lib/protocol/http2/window_update_frame.rb#113
Protocol::HTTP2::WindowUpdateFrame::TYPE = T.let(T.unsafe(nil), Integer)
