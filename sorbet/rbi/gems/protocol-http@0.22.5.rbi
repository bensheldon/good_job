# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `protocol-http` gem.
# Please instead update this file by running `bin/tapioca gem protocol-http`.

module Protocol; end
module Protocol::HTTP; end
module Protocol::HTTP::Body; end

# A body which buffers all it's contents.
class Protocol::HTTP::Body::Buffered < ::Protocol::HTTP::Body::Readable
  # @return [Buffered] a new instance of Buffered
  def initialize(chunks = T.unsafe(nil), length = T.unsafe(nil)); end

  # Returns the value of attribute chunks.
  def chunks; end

  # @return [Boolean]
  def empty?; end

  def finish; end
  def inspect; end
  def length; end
  def read; end

  # A buffered response is always ready.
  #
  # @return [Boolean]
  def ready?; end

  def rewind; end
  def write(chunk); end

  class << self
    def for(body); end

    # Wraps an array into a buffered body.
    #
    # @return [Readable, nil] the wrapped body or nil if nil was given.
    def wrap(body); end
  end
end

# Invokes a callback once the body has completed, either successfully or due to an error.
class Protocol::HTTP::Body::Completable < ::Protocol::HTTP::Body::Wrapper
  # @return [Completable] a new instance of Completable
  def initialize(body, callback); end

  def close(error = T.unsafe(nil)); end
  def finish; end

  class << self
    def wrap(message, &block); end
  end
end

class Protocol::HTTP::Body::Head < ::Protocol::HTTP::Body::Readable
  # @return [Head] a new instance of Head
  def initialize(length); end

  # @return [Boolean]
  def empty?; end

  def length; end

  # @return [Boolean]
  def ready?; end

  class << self
    def for(body); end
  end
end

# def finish -> buffer the stream and close it.
# 	def close(error = nil) -> close the stream immediately.
# end
class Protocol::HTTP::Body::Readable
  # Write the body to the given stream.
  def call(stream); end

  # The consumer can call stop to signal that the stream output has terminated.
  def close(error = T.unsafe(nil)); end

  # Enumerate all chunks until finished, then invoke `#close`.
  def each; end

  # Will read return any data?
  #
  # @return [Boolean]
  def empty?; end

  # Read all remaining chunks into a buffered body and close the underlying input.
  def finish; end

  # Read all remaining chunks into a single binary string using `#each`.
  def join; end

  def length; end

  # Read the next available chunk.
  def read; end

  # Whether calling read will block.
  # We prefer pessimistic implementation, and thus default to `false`.
  #
  # @return [Boolean]
  def ready?; end

  # Should the internal mechanism prefer to use {call}?
  #
  # @return [Boolean]
  def stream?; end
end

# General operations for interacting with a request or response body.
module Protocol::HTTP::Body::Reader
  # Whether there is a body?
  #
  # @return [Boolean]
  def body?; end

  # Close the connection as quickly as possible. Discards body. May close the underlying connection if necessary to terminate the stream.
  def close(error = T.unsafe(nil)); end

  # Read chunks from the body.
  #
  # @yield [String] read chunks from the body.
  def each(&block); end

  # Gracefully finish reading the body. This will buffer the remainder of the body.
  #
  # @return [Buffered] buffers the entire body.
  def finish; end

  # Reads the entire request/response body.
  #
  # @return [String] the entire body as a string.
  def read; end

  # Write the body of the response to the given file path.
  def save(path, mode = T.unsafe(nil), *args); end
end

# Wrapping body instance. Typically you'd override `#read`.
class Protocol::HTTP::Body::Wrapper < ::Protocol::HTTP::Body::Readable
  # @return [Wrapper] a new instance of Wrapper
  def initialize(body); end

  # The wrapped body.
  def body; end

  def call(stream); end
  def close(error = T.unsafe(nil)); end

  # @return [Boolean]
  def empty?; end

  # Buffer any remaining body.
  def finish; end

  def inspect; end
  def length; end

  # Read the next available chunk.
  def read; end

  # @return [Boolean]
  def ready?; end

  # @return [Boolean]
  def stream?; end

  class << self
    def wrap(message); end
  end
end

# Represents an individual cookie key-value pair.
class Protocol::HTTP::Cookie
  # @return [Cookie] a new instance of Cookie
  def initialize(name, value, directives); end

  # Returns the value of attribute directives.
  def directives; end

  def encoded_name; end
  def encoded_value; end

  # Returns the value of attribute name.
  def name; end

  def to_s; end

  # Returns the value of attribute value.
  def value; end

  class << self
    def parse(string); end
    def parse_directives(strings); end
  end
end

# A generic, HTTP protocol error.
class Protocol::HTTP::Error < ::StandardError; end

module Protocol::HTTP::Header; end

# Used for basic authorization.
#
# ~~~ ruby
# headers.add('authorization', Authorization.basic("my_username", "my_password"))
# ~~~
class Protocol::HTTP::Header::Authorization < ::String
  # Splits the header and
  #
  # @return [Tuple(String, String)]
  def credentials; end

  class << self
    def basic(username, password); end
  end
end

class Protocol::HTTP::Header::CacheControl < ::Protocol::HTTP::Header::Split
  # @return [CacheControl] a new instance of CacheControl
  def initialize(value); end

  def <<(value); end

  # @return [Boolean]
  def dynamic?; end

  def max_age; end

  # @return [Boolean]
  def no_cache?; end

  # @return [Boolean]
  def no_store?; end

  # @return [Boolean]
  def private?; end

  # @return [Boolean]
  def public?; end

  # @return [Boolean]
  def static?; end

  # @return [Boolean]
  def streaming?; end
end

Protocol::HTTP::Header::CacheControl::DYNAMIC = T.let(T.unsafe(nil), String)
Protocol::HTTP::Header::CacheControl::MAX_AGE = T.let(T.unsafe(nil), String)
Protocol::HTTP::Header::CacheControl::NO_CACHE = T.let(T.unsafe(nil), String)
Protocol::HTTP::Header::CacheControl::NO_STORE = T.let(T.unsafe(nil), String)
Protocol::HTTP::Header::CacheControl::PRIVATE = T.let(T.unsafe(nil), String)
Protocol::HTTP::Header::CacheControl::PUBLIC = T.let(T.unsafe(nil), String)
Protocol::HTTP::Header::CacheControl::STATIC = T.let(T.unsafe(nil), String)
Protocol::HTTP::Header::CacheControl::STREAMING = T.let(T.unsafe(nil), String)

class Protocol::HTTP::Header::Connection < ::Protocol::HTTP::Header::Split
  # @return [Connection] a new instance of Connection
  def initialize(value); end

  def <<(value); end

  # @return [Boolean]
  def close?; end

  # @return [Boolean]
  def keep_alive?; end

  # @return [Boolean]
  def upgrade?; end
end

Protocol::HTTP::Header::Connection::CLOSE = T.let(T.unsafe(nil), String)
Protocol::HTTP::Header::Connection::KEEP_ALIVE = T.let(T.unsafe(nil), String)
Protocol::HTTP::Header::Connection::UPGRADE = T.let(T.unsafe(nil), String)

# The Cookie HTTP request header contains stored HTTP cookies previously sent by the server with the Set-Cookie header.
class Protocol::HTTP::Header::Cookie < ::Protocol::HTTP::Header::Multiple
  def to_h; end
end

class Protocol::HTTP::Header::ETag < ::String
  def <<(value); end

  # @return [Boolean]
  def weak?; end
end

# This implementation is not strictly correct according to the RFC-specified format.
class Protocol::HTTP::Header::ETags < ::Protocol::HTTP::Header::Split
  # @return [Boolean]
  def match?(etag); end

  # @return [Boolean]
  def wildcard?; end
end

# Header value which is split by newline charaters (e.g. cookies).
class Protocol::HTTP::Header::Multiple < ::Array
  # @return [Multiple] a new instance of Multiple
  def initialize(value); end

  def to_s; end
end

# The Set-Cookie HTTP response header sends cookies from the server to the user agent.
class Protocol::HTTP::Header::SetCookie < ::Protocol::HTTP::Header::Cookie; end

# Header value which is split by commas.
class Protocol::HTTP::Header::Split < ::Array
  # @return [Split] a new instance of Split
  def initialize(value); end

  def <<(value); end
  def to_s; end
end

Protocol::HTTP::Header::Split::COMMA = T.let(T.unsafe(nil), Regexp)

class Protocol::HTTP::Header::Vary < ::Protocol::HTTP::Header::Split
  # @return [Vary] a new instance of Vary
  def initialize(value); end

  def <<(value); end
end

# Headers are an array of key-value pairs. Some header keys represent multiple values.
class Protocol::HTTP::Headers
  # @return [Headers] a new instance of Headers
  def initialize(fields = T.unsafe(nil), indexed = T.unsafe(nil)); end

  def ==(other); end
  def [](key); end

  # Append the value to the given key. Some values can be appended multiple times, others can only be set once.
  #
  # @param key [String] The header key.
  # @param value The header value.
  def []=(key, value); end

  # Add the specified header key value pair.
  #
  # @param key [String] the header key.
  # @param value [String] the header value to assign.
  def add(key, value); end

  def clear; end

  # Delete all headers with the given key, and return the merged value.
  def delete(key); end

  def each(&block); end

  # @return [Boolean]
  def empty?; end

  def extract(keys); end

  # An array of `[key, value]` pairs.
  def fields; end

  def flatten; end

  # Flatten trailer into the headers.
  def flatten!; end

  def freeze; end

  # @return [Boolean]
  def include?(key); end

  def inspect; end
  def keys; end
  def merge(headers); end
  def merge!(headers); end

  # Set the specified header key to the specified value, replacing any existing header keys with the same name.
  #
  # @param key [String] the header key to replace.
  # @param value [String] the header value to assign.
  def set(key, value); end

  # A hash table of `{key, policy[key].map(values)}`
  def to_h; end

  # Enumerate all headers in the trailer, if there are any.
  def trailer(&block); end

  # Record the current headers, and prepare to receive trailer.
  def trailer!(&block); end

  # @return [Boolean] the trailer if there are any.
  def trailer?; end

  protected

  def merge_into(hash, key, value); end

  private

  def initialize_dup(other); end

  class << self
    # Construct an instance from a headers Array or Hash. No-op if already an instance of `Headers`. If the underlying array is frozen, it will be duped.
    #
    # @return [Headers] an instance of headers.
    def [](headers); end
  end
end

# Used for merging objects into a sequential list of headers. Normalizes header keys and values.
class Protocol::HTTP::Headers::Merged
  include ::Enumerable

  # @return [Merged] a new instance of Merged
  def initialize(*all); end

  def <<(headers); end
  def clear; end

  # @yield [String, String] header key (lower case) and value (as string).
  def each(&block); end
end

Protocol::HTTP::Headers::Multiple = Protocol::HTTP::Header::Multiple
Protocol::HTTP::Headers::POLICY = T.let(T.unsafe(nil), Hash)
Protocol::HTTP::Headers::Split = Protocol::HTTP::Header::Split
Protocol::HTTP::Headers::TRAILER = T.let(T.unsafe(nil), String)

# All supported HTTP methods
class Protocol::HTTP::Methods
  def connect(location, headers = T.unsafe(nil), body = T.unsafe(nil)); end
  def delete(location, headers = T.unsafe(nil), body = T.unsafe(nil)); end
  def get(location, headers = T.unsafe(nil), body = T.unsafe(nil)); end
  def head(location, headers = T.unsafe(nil), body = T.unsafe(nil)); end
  def link(location, headers = T.unsafe(nil), body = T.unsafe(nil)); end
  def options(location, headers = T.unsafe(nil), body = T.unsafe(nil)); end
  def patch(location, headers = T.unsafe(nil), body = T.unsafe(nil)); end
  def post(location, headers = T.unsafe(nil), body = T.unsafe(nil)); end
  def put(location, headers = T.unsafe(nil), body = T.unsafe(nil)); end
  def trace(location, headers = T.unsafe(nil), body = T.unsafe(nil)); end
  def unlink(location, headers = T.unsafe(nil), body = T.unsafe(nil)); end

  class << self
    def each; end

    # @return [Boolean]
    def valid?(name); end
  end
end

Protocol::HTTP::Methods::CONNECT = T.let(T.unsafe(nil), String)
Protocol::HTTP::Methods::DELETE = T.let(T.unsafe(nil), String)
Protocol::HTTP::Methods::GET = T.let(T.unsafe(nil), String)
Protocol::HTTP::Methods::HEAD = T.let(T.unsafe(nil), String)
Protocol::HTTP::Methods::LINK = T.let(T.unsafe(nil), String)
Protocol::HTTP::Methods::OPTIONS = T.let(T.unsafe(nil), String)
Protocol::HTTP::Methods::PATCH = T.let(T.unsafe(nil), String)
Protocol::HTTP::Methods::POST = T.let(T.unsafe(nil), String)
Protocol::HTTP::Methods::PUT = T.let(T.unsafe(nil), String)
Protocol::HTTP::Methods::TRACE = T.let(T.unsafe(nil), String)
Protocol::HTTP::Methods::UNLINK = T.let(T.unsafe(nil), String)

class Protocol::HTTP::Request
  include ::Protocol::HTTP::Body::Reader

  # @return [Request] a new instance of Request
  def initialize(scheme = T.unsafe(nil), authority = T.unsafe(nil), method = T.unsafe(nil), path = T.unsafe(nil), version = T.unsafe(nil), headers = T.unsafe(nil), body = T.unsafe(nil), protocol = T.unsafe(nil)); end

  # Returns the value of attribute authority.
  def authority; end

  # Sets the attribute authority
  #
  # @param value the value to set the attribute authority to.
  def authority=(_arg0); end

  # Returns the value of attribute body.
  def body; end

  # Sets the attribute body
  #
  # @param value the value to set the attribute body to.
  def body=(_arg0); end

  # Send the request to the given connection.
  def call(connection); end

  # @return [Boolean]
  def connect?; end

  # @return [Boolean]
  def head?; end

  # Returns the value of attribute headers.
  def headers; end

  # Sets the attribute headers
  #
  # @param value the value to set the attribute headers to.
  def headers=(_arg0); end

  # @return [Boolean]
  def idempotent?; end

  # Returns the value of attribute method.
  def method; end

  # Sets the attribute method
  #
  # @param value the value to set the attribute method to.
  def method=(_arg0); end

  # Returns the value of attribute path.
  def path; end

  # Sets the attribute path
  #
  # @param value the value to set the attribute path to.
  def path=(_arg0); end

  # Returns the value of attribute protocol.
  def protocol; end

  # Sets the attribute protocol
  #
  # @param value the value to set the attribute protocol to.
  def protocol=(_arg0); end

  # Returns the value of attribute scheme.
  def scheme; end

  # Sets the attribute scheme
  #
  # @param value the value to set the attribute scheme to.
  def scheme=(_arg0); end

  def to_s; end

  # Returns the value of attribute version.
  def version; end

  # Sets the attribute version
  #
  # @param value the value to set the attribute version to.
  def version=(_arg0); end

  class << self
    def [](method, path, headers, body); end
  end
end

class Protocol::HTTP::Response
  include ::Protocol::HTTP::Body::Reader

  # @return [Response] a new instance of Response
  def initialize(version = T.unsafe(nil), status = T.unsafe(nil), headers = T.unsafe(nil), body = T.unsafe(nil), protocol = T.unsafe(nil)); end

  # @return [Boolean]
  def bad_request?; end

  # Returns the value of attribute body.
  def body; end

  # Sets the attribute body
  #
  # @param value the value to set the attribute body to.
  def body=(_arg0); end

  # @return [Boolean]
  def continue?; end

  # @return [Boolean]
  def failure?; end

  # Returns the value of attribute headers.
  def headers; end

  # Sets the attribute headers
  #
  # @param value the value to set the attribute headers to.
  def headers=(_arg0); end

  # @return [Boolean]
  def hijack?; end

  # @return [Boolean]
  def not_modified?; end

  # @return [Boolean]
  def partial?; end

  # @return [Boolean]
  def preserve_method?; end

  # Returns the value of attribute protocol.
  def protocol; end

  # Sets the attribute protocol
  #
  # @param value the value to set the attribute protocol to.
  def protocol=(_arg0); end

  # @return [Boolean]
  def redirection?; end

  # @return [Boolean]
  def server_failure?; end

  # Returns the value of attribute status.
  def status; end

  # Sets the attribute status
  #
  # @param value the value to set the attribute status to.
  def status=(_arg0); end

  # @return [Boolean]
  def success?; end

  def to_ary; end
  def to_s; end

  # Returns the value of attribute version.
  def version; end

  # Sets the attribute version
  #
  # @param value the value to set the attribute version to.
  def version=(_arg0); end

  class << self
    def [](status, headers = T.unsafe(nil), body = T.unsafe(nil), protocol = T.unsafe(nil)); end
    def for_exception(exception); end
  end
end

module Protocol::HTTP::URL
  class << self
    def assign(keys, value, parent); end

    # TODO use native C extension from `Trenni::Reference`.
    def decode(string, maximum = T.unsafe(nil), symbolize_keys: T.unsafe(nil)); end

    # Encodes a hash or array into a query string
    def encode(value, prefix = T.unsafe(nil)); end

    # Escapes a generic string, using percent encoding.
    def escape(string, encoding = T.unsafe(nil)); end

    # Escapes a path
    def escape_path(path); end

    def scan(string); end
    def split(name); end
    def unescape(string, encoding = T.unsafe(nil)); end
  end
end

# According to https://tools.ietf.org/html/rfc3986#section-3.3, we escape non-pchar.
Protocol::HTTP::URL::NON_PCHAR = T.let(T.unsafe(nil), Regexp)
