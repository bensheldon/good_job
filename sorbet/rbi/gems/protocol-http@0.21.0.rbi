# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `protocol-http` gem.
# Please instead update this file by running `bin/tapioca sync`.

# typed: true

module Protocol
end

module Protocol::HTTP
end

module Protocol::HTTP::Body
end

class Protocol::HTTP::Body::Buffered < ::Protocol::HTTP::Body::Readable
  def initialize(chunks = T.unsafe(nil), length = T.unsafe(nil)); end

  def chunks; end
  def empty?; end
  def finish; end
  def inspect; end
  def length; end
  def read; end
  def ready?; end
  def rewind; end
  def write(chunk); end

  class << self
    def for(body); end
    def wrap(body); end
  end
end

class Protocol::HTTP::Body::Completable < ::Protocol::HTTP::Body::Wrapper
  def initialize(body, callback); end

  def close(error = T.unsafe(nil)); end
  def finish; end

  class << self
    def wrap(message, &block); end
  end
end

class Protocol::HTTP::Body::Head < ::Protocol::HTTP::Body::Readable
  def initialize(length); end

  def empty?; end
  def length; end
  def ready?; end

  class << self
    def for(body); end
  end
end

class Protocol::HTTP::Body::Readable
  def call(stream); end
  def close(error = T.unsafe(nil)); end
  def each; end
  def empty?; end
  def finish; end
  def join; end
  def length; end
  def read; end
  def ready?; end
  def stream?; end
end

module Protocol::HTTP::Body::Reader
  def body?; end
  def close(error = T.unsafe(nil)); end
  def each(&block); end
  def finish; end
  def read; end
  def save(path, mode = T.unsafe(nil), *args); end
end

class Protocol::HTTP::Body::Wrapper < ::Protocol::HTTP::Body::Readable
  def initialize(body); end

  def body; end
  def call(stream); end
  def close(error = T.unsafe(nil)); end
  def empty?; end
  def finish; end
  def inspect; end
  def length; end
  def read; end
  def ready?; end
  def stream?; end

  class << self
    def wrap(message); end
  end
end

class Protocol::HTTP::Error < ::StandardError
end

module Protocol::HTTP::Header
end

class Protocol::HTTP::Header::Authorization < ::String
  def credentials; end

  class << self
    def basic(username, password); end
  end
end

class Protocol::HTTP::Header::CacheControl < ::Protocol::HTTP::Header::Split
  def initialize(value); end

  def <<(value); end
  def dynamic?; end
  def max_age; end
  def no_cache?; end
  def no_store?; end
  def private?; end
  def public?; end
  def static?; end
  def streaming?; end
end

Protocol::HTTP::Header::CacheControl::DYNAMIC = T.let(T.unsafe(nil), String)

Protocol::HTTP::Header::CacheControl::MAX_AGE = T.let(T.unsafe(nil), String)

Protocol::HTTP::Header::CacheControl::NO_CACHE = T.let(T.unsafe(nil), String)

Protocol::HTTP::Header::CacheControl::NO_STORE = T.let(T.unsafe(nil), String)

Protocol::HTTP::Header::CacheControl::PRIVATE = T.let(T.unsafe(nil), String)

Protocol::HTTP::Header::CacheControl::PUBLIC = T.let(T.unsafe(nil), String)

Protocol::HTTP::Header::CacheControl::STATIC = T.let(T.unsafe(nil), String)

Protocol::HTTP::Header::CacheControl::STREAMING = T.let(T.unsafe(nil), String)

class Protocol::HTTP::Header::Connection < ::Protocol::HTTP::Header::Split
  def initialize(value); end

  def <<(value); end
  def close?; end
  def keep_alive?; end
  def upgrade?; end
end

Protocol::HTTP::Header::Connection::CLOSE = T.let(T.unsafe(nil), String)

Protocol::HTTP::Header::Connection::KEEP_ALIVE = T.let(T.unsafe(nil), String)

Protocol::HTTP::Header::Connection::UPGRADE = T.let(T.unsafe(nil), String)

class Protocol::HTTP::Header::Cookie < ::Protocol::HTTP::Header::Multiple
  def to_h; end
end

class Protocol::HTTP::Header::ETag < ::String
  def <<(value); end
  def weak?; end
end

class Protocol::HTTP::Header::ETags < ::Protocol::HTTP::Header::Split
  def match?(etag); end
  def wildcard?; end
end

class Protocol::HTTP::Header::Multiple < ::Array
  def initialize(value); end

  def to_s; end
end

class Protocol::HTTP::Header::SetCookie < ::Protocol::HTTP::Header::Cookie
end

class Protocol::HTTP::Header::Split < ::Array
  def initialize(value); end

  def <<(value); end
  def to_s; end
end

Protocol::HTTP::Header::Split::COMMA = T.let(T.unsafe(nil), Regexp)

class Protocol::HTTP::Header::Vary < ::Protocol::HTTP::Header::Split
  def initialize(value); end

  def <<(value); end
end

class Protocol::HTTP::Headers
  def initialize(fields = T.unsafe(nil), indexed = T.unsafe(nil)); end

  def ==(other); end
  def [](key); end
  def []=(key, value); end
  def add(key, value); end
  def clear; end
  def delete(key); end
  def each(&block); end
  def empty?; end
  def extract(keys); end
  def fields; end
  def flatten; end
  def flatten!; end
  def freeze; end
  def include?(key); end
  def inspect; end
  def keys; end
  def merge(headers); end
  def merge!(headers); end
  def set(key, value); end
  def to_h; end
  def trailers(&block); end
  def trailers!(&block); end
  def trailers?; end

  protected

  def merge_into(hash, key, value); end

  private

  def initialize_dup(other); end

  class << self
    def [](headers); end
  end
end

class Protocol::HTTP::Headers::Merged
  include(::Enumerable)

  def initialize(*all); end

  def <<(headers); end
  def clear; end
  def each(&block); end
end

Protocol::HTTP::Headers::Multiple = Protocol::HTTP::Header::Multiple

Protocol::HTTP::Headers::POLICY = T.let(T.unsafe(nil), Hash)

Protocol::HTTP::Headers::Split = Protocol::HTTP::Header::Split

Protocol::HTTP::Headers::TRAILERS = T.let(T.unsafe(nil), String)

class Protocol::HTTP::Methods
  def connect(location, headers = T.unsafe(nil), body = T.unsafe(nil)); end
  def delete(location, headers = T.unsafe(nil), body = T.unsafe(nil)); end
  def get(location, headers = T.unsafe(nil), body = T.unsafe(nil)); end
  def head(location, headers = T.unsafe(nil), body = T.unsafe(nil)); end
  def link(location, headers = T.unsafe(nil), body = T.unsafe(nil)); end
  def options(location, headers = T.unsafe(nil), body = T.unsafe(nil)); end
  def patch(location, headers = T.unsafe(nil), body = T.unsafe(nil)); end
  def post(location, headers = T.unsafe(nil), body = T.unsafe(nil)); end
  def put(location, headers = T.unsafe(nil), body = T.unsafe(nil)); end
  def trace(location, headers = T.unsafe(nil), body = T.unsafe(nil)); end
  def unlink(location, headers = T.unsafe(nil), body = T.unsafe(nil)); end

  class << self
    def each; end
    def valid?(name); end
  end
end

Protocol::HTTP::Methods::CONNECT = T.let(T.unsafe(nil), String)

Protocol::HTTP::Methods::DELETE = T.let(T.unsafe(nil), String)

Protocol::HTTP::Methods::GET = T.let(T.unsafe(nil), String)

Protocol::HTTP::Methods::HEAD = T.let(T.unsafe(nil), String)

Protocol::HTTP::Methods::LINK = T.let(T.unsafe(nil), String)

Protocol::HTTP::Methods::OPTIONS = T.let(T.unsafe(nil), String)

Protocol::HTTP::Methods::PATCH = T.let(T.unsafe(nil), String)

Protocol::HTTP::Methods::POST = T.let(T.unsafe(nil), String)

Protocol::HTTP::Methods::PUT = T.let(T.unsafe(nil), String)

Protocol::HTTP::Methods::TRACE = T.let(T.unsafe(nil), String)

Protocol::HTTP::Methods::UNLINK = T.let(T.unsafe(nil), String)

class Protocol::HTTP::Middleware < ::Protocol::HTTP::Methods
  def initialize(delegate); end

  def call(request); end
  def close; end
  def delegate; end

  class << self
    def for(&block); end
  end
end

module Protocol::HTTP::Middleware::HelloWorld
  class << self
    def call(request); end
    def close; end
  end
end

module Protocol::HTTP::Middleware::Okay
  class << self
    def call(request); end
    def close; end
  end
end

class Protocol::HTTP::Request
  include(::Protocol::HTTP::Body::Reader)

  def initialize(scheme = T.unsafe(nil), authority = T.unsafe(nil), method = T.unsafe(nil), path = T.unsafe(nil), version = T.unsafe(nil), headers = T.unsafe(nil), body = T.unsafe(nil), protocol = T.unsafe(nil)); end

  def authority; end
  def authority=(_arg0); end
  def body; end
  def body=(_arg0); end
  def call(connection); end
  def connect?; end
  def head?; end
  def headers; end
  def headers=(_arg0); end
  def idempotent?; end
  def method; end
  def method=(_arg0); end
  def path; end
  def path=(_arg0); end
  def protocol; end
  def protocol=(_arg0); end
  def scheme; end
  def scheme=(_arg0); end
  def to_s; end
  def version; end
  def version=(_arg0); end

  class << self
    def [](method, path, headers, body); end
  end
end

class Protocol::HTTP::Response
  include(::Protocol::HTTP::Body::Reader)

  def initialize(version = T.unsafe(nil), status = T.unsafe(nil), headers = T.unsafe(nil), body = T.unsafe(nil), protocol = T.unsafe(nil)); end

  def bad_request?; end
  def body; end
  def body=(_arg0); end
  def continue?; end
  def failure?; end
  def headers; end
  def headers=(_arg0); end
  def hijack?; end
  def not_modified?; end
  def partial?; end
  def preserve_method?; end
  def protocol; end
  def protocol=(_arg0); end
  def redirection?; end
  def server_failure?; end
  def status; end
  def status=(_arg0); end
  def success?; end
  def to_ary; end
  def to_s; end
  def version; end
  def version=(_arg0); end

  class << self
    def [](status, headers = T.unsafe(nil), body = T.unsafe(nil), protocol = T.unsafe(nil)); end
    def for_exception(exception); end
  end
end
