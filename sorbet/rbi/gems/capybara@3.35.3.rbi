# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `capybara` gem.
# Please instead update this file by running `bin/tapioca gem capybara`.

module Capybara
  extend ::Capybara::DSL

  class << self
    # Parse raw html into a document using Nokogiri, and adjust textarea contents as defined by the spec.
    #
    # @param html [String] The raw html
    # @return [Nokogiri::HTML::Document] HTML document
    def HTML(html); end

    # Add a new selector to Capybara. Selectors can be used by various methods in Capybara
    # to find certain elements on the page in a more convenient way. For example adding a
    # selector to find certain table rows might look like this:
    #
    #     Capybara.add_selector(:row) do
    #       xpath { |num| ".//tbody/tr[#{num}]" }
    #     end
    #
    # This makes it possible to use this selector in a variety of ways:
    #
    #     find(:row, 3)
    #     page.find('table#myTable').find(:row, 3).text
    #     page.find('table#myTable').has_selector?(:row, 3)
    #     within(:row, 3) { expect(page).to have_content('$100.000') }
    #
    # Here is another example:
    #
    #     Capybara.add_selector(:id) do
    #       xpath { |id| XPath.descendant[XPath.attr(:id) == id.to_s] }
    #     end
    #
    # Note that this particular selector already ships with Capybara.
    #
    # @param name [Symbol] The name of the selector to add
    # @yield A block executed in the context of the new {Capybara::Selector}
    def add_selector(name, **options, &block); end

    # See {Capybara.configure}
    def allow_gumbo(*args, &block); end

    def allow_gumbo=(*args, &block); end

    # See {Capybara.configure}
    def always_include_port(*args, &block); end

    def always_include_port=(*args, &block); end

    # See {Capybara.configure}
    def app(*args, &block); end

    def app=(*args, &block); end

    # See {Capybara.configure}
    def app_host(*args, &block); end

    def app_host=(*args, &block); end
    def asset_host(*args, &block); end
    def asset_host=(*args, &block); end
    def automatic_label_click(*args, &block); end
    def automatic_label_click=(*args, &block); end
    def automatic_reload(*args, &block); end
    def automatic_reload=(*args, &block); end

    # Configure Capybara to suit your needs.
    #
    #     Capybara.configure do |config|
    #       config.run_server = false
    #       config.app_host   = 'http://www.google.com'
    #     end
    #
    # #### Configurable options
    #
    # - **allow_gumbo** (Boolean = `false`) - When `nokogumbo` is available, whether it will be used to parse HTML strings.
    # - **always_include_port** (Boolean = `false`) - Whether the Rack server's port should automatically be inserted into every visited URL
    #   unless another port is explicitly specified.
    # - **app_host** (String, `nil`) - The default host to use when giving a relative URL to visit, must be a valid URL e.g. `http://www.example.com`.
    # - **asset_host** (String = `nil`) - Where dynamic assets are hosted - will be prepended to relative asset locations if present.
    # - **automatic_label_click** (Boolean = `false`) - Whether {Capybara::Node::Element#choose Element#choose}, {Capybara::Node::Element#check Element#check},
    #   {Capybara::Node::Element#uncheck Element#uncheck} will attempt to click the associated `<label>` element if the checkbox/radio button are non-visible.
    # - **automatic_reload** (Boolean = `true`) - Whether to automatically reload elements as Capybara is waiting.
    # - **default_max_wait_time** (Numeric = `2`) - The maximum number of seconds to wait for asynchronous processes to finish.
    # - **default_normalize_ws** (Boolean = `false`) - Whether text predicates and matchers use normalize whitespace behavior.
    # - **default_selector** (`:css`, `:xpath` = `:css`) - Methods which take a selector use the given type by default. See also {Capybara::Selector}.
    # - **default_set_options** (Hash = `{}`) - The default options passed to {Capybara::Node::Element#set Element#set}.
    # - **enable_aria_label** (Boolean = `false`) - Whether fields, links, and buttons will match against `aria-label` attribute.
    # - **enable_aria_role** (Boolean = `false`) - Selectors will check for relevant aria role (currently only `button`).
    # - **exact** (Boolean = `false`) - Whether locators are matched exactly or with substrings. Only affects selector conditions
    #   written using the `XPath#is` method.
    # - **exact_text** (Boolean = `false`) - Whether the text matchers and `:text` filter match exactly or on substrings.
    # - **ignore_hidden_elements** (Boolean = `true`) - Whether to ignore hidden elements on the page.
    # - **match** (`:one`, `:first`, `:prefer_exact`, `:smart` = `:smart`) - The matching strategy to find nodes.
    # - **predicates_wait** (Boolean = `true`) - Whether Capybara's predicate matchers use waiting behavior by default.
    # - **raise_server_errors** (Boolean = `true`) - Should errors raised in the server be raised in the tests?
    # - **reuse_server** (Boolean = `true`) - Whether to reuse the server thread between multiple sessions using the same app object.
    # - **run_server** (Boolean = `true`) - Whether to start a Rack server for the given Rack app.
    # - **save_path** (String = `Dir.pwd`) - Where to put pages saved through {Capybara::Session#save_page save_page}, {Capybara::Session#save_screenshot save_screenshot},
    #   {Capybara::Session#save_and_open_page save_and_open_page}, or {Capybara::Session#save_and_open_screenshot save_and_open_screenshot}.
    # - **server** (Symbol = `:default` (which uses puma)) - The name of the registered server to use when running the app under test.
    # - **server_port** (Integer) - The port Capybara will run the application server on, if not specified a random port will be used.
    # - **server_errors** (Array\<Class> = `[Exception]`) - Error classes that should be raised in the tests if they are raised in the server
    #   and {configure raise_server_errors} is `true`.
    # - **test_id** (Symbol, String, `nil` = `nil`) - Optional attribute to match locator against with built-in selectors along with id.
    # - **threadsafe** (Boolean = `false`) - Whether sessions can be configured individually.
    # - **w3c_click_offset** (Boolean = 'false') - Whether click offsets should be from element center (true) or top left (false)
    #
    # #### DSL Options
    #
    # When using `capybara/dsl`, the following options are also available:
    #
    # - **default_driver** (Symbol = `:rack_test`) - The name of the driver to use by default.
    # - **javascript_driver** (Symbol = `:selenium`) - The name of a driver to use for JavaScript enabled tests.
    #
    # @yield [config]
    def configure; end

    # @return [Symbol] The name of the driver currently in use
    def current_driver; end

    def current_driver=(name); end

    # The current {Capybara::Session} based on what is set as {app} and {current_driver}.
    #
    # @return [Capybara::Session] The currently used session
    def current_session; end

    # See {Capybara.configure}
    def default_driver(*args, &block); end

    def default_driver=(*args, &block); end
    def default_host(*args, &block); end
    def default_host=(*args, &block); end

    # See {Capybara.configure}
    def default_max_wait_time(*args, &block); end

    def default_max_wait_time=(*args, &block); end
    def default_normalize_ws(*args, &block); end
    def default_normalize_ws=(*args, &block); end

    # See {Capybara.configure}
    def default_selector(*args, &block); end

    def default_selector=(*args, &block); end
    def default_set_options(*args, &block); end
    def default_set_options=(*args, &block); end
    def disable_animation(*args, &block); end
    def disable_animation=(*args, &block); end
    def drivers; end
    def enable_aria_label(*args, &block); end
    def enable_aria_label=(*args, &block); end
    def enable_aria_role(*args, &block); end
    def enable_aria_role=(*args, &block); end
    def exact(*args, &block); end
    def exact=(*args, &block); end
    def exact_text(*args, &block); end
    def exact_text=(*args, &block); end
    def ignore_hidden_elements(*args, &block); end
    def ignore_hidden_elements=(*args, &block); end

    # See {Capybara.configure}
    def javascript_driver(*args, &block); end

    def javascript_driver=(*args, &block); end
    def match(*args, &block); end
    def match=(*args, &block); end

    # @return [Symbol] The name of the driver currently in use
    def mode; end

    # Modify a selector previously created by {Capybara.add_selector}.
    # For example, adding a new filter to the :button selector to filter based on
    # button style (a class) might look like this
    #
    #     Capybara.modify_selector(:button) do
    #       filter (:btn_style, valid_values: [:primary, :secondary]) { |node, style| node[:class].split.include? "btn-#{style}" }
    #     end
    #
    # @param name [Symbol] The name of the selector to modify
    # @yield A block executed in the context of the existing {Capybara::Selector}
    def modify_selector(name, &block); end

    def predicates_wait(*args, &block); end
    def predicates_wait=(*args, &block); end
    def raise_server_errors(*args, &block); end
    def raise_server_errors=(*args, &block); end

    # Register a new driver for Capybara.
    #
    #     Capybara.register_driver :rack_test do |app|
    #       Capybara::RackTest::Driver.new(app)
    #     end
    #
    # @param name [Symbol] The name of the new driver
    # @yield [app] This block takes a rack app and returns a Capybara driver
    # @yieldparam app [<Rack>] The rack application that this driver runs against. May be nil.
    # @yieldreturn [Capybara::Driver::Base] A Capybara driver instance
    def register_driver(name, &block); end

    # Register a new server for Capybara.
    #
    #     Capybara.register_server :webrick do |app, port, host|
    #       require 'rack/handler/webrick'
    #       Rack::Handler::WEBrick.run(app, ...)
    #     end
    #
    # @param name [Symbol] The name of the new driver
    # @yield [app, port, host] This block takes a rack app and a port and returns a rack server listening on that port
    # @yieldparam app [<Rack>] The rack application that this server will contain.
    # @yieldparam port The port number the server should listen on
    # @yieldparam host The host/ip to bind to
    def register_server(name, &block); end

    # Reset sessions, cleaning out the pool of sessions. This will remove any session information such
    # as cookies.
    def reset!; end

    # Reset sessions, cleaning out the pool of sessions. This will remove any session information such
    # as cookies.
    def reset_sessions!; end

    # See {Capybara.configure}
    def reuse_server(*args, &block); end

    def reuse_server=(*args, &block); end

    # Runs Capybara's default server for the given application and port
    # under most circumstances you should not have to call this method
    # manually.
    #
    # @param app [Rack Application] The rack application to run
    # @param port [Integer] The port to run the application on
    def run_default_server(app, port); end

    def run_server(*args, &block); end
    def run_server=(*args, &block); end
    def save_path(*args, &block); end
    def save_path=(*args, &block); end

    # See {Capybara.configure}
    def server(*args, &block); end

    def server=(*args, &block); end
    def server_errors(*args, &block); end
    def server_errors=(*args, &block); end
    def server_host(*args, &block); end
    def server_host=(*args, &block); end
    def server_port(*args, &block); end
    def server_port=(*args, &block); end
    def servers; end

    # The current session name.
    #
    # @return [Symbol] The name of the currently used session.
    def session_name; end

    def session_name=(name); end
    def session_options; end

    # Wraps the given string, which should contain an HTML document or fragment
    # in a {Capybara::Node::Simple} which exposes all {Capybara::Node::Matchers},
    # {Capybara::Node::Finders} and {Capybara::Node::DocumentMatchers}. This allows you to query
    # any string containing HTML in the exact same way you would query the current document in a Capybara
    # session.
    #
    # @example A single element
    #   node = Capybara.string('<a href="foo">bar</a>')
    #   anchor = node.first('a')
    #   anchor[:href] #=> 'foo'
    #   anchor.text #=> 'bar'
    # @example Multiple elements
    #   node = Capybara.string <<-HTML
    #   <ul>
    #   <li id="home">Home</li>
    #   <li id="projects">Projects</li>
    #   </ul>
    #   HTML
    #
    #   node.find('#projects').text # => 'Projects'
    #   node.has_selector?('li#home', text: 'Home')
    #   node.has_selector?('#projects')
    #   node.find('ul').find('li:first-child').text # => 'Home'
    # @param html [String] An html fragment or document
    # @return [Capybara::Node::Simple] A node which has Capybara's finders and matchers
    def string(html); end

    def test_id(*args, &block); end
    def test_id=(*args, &block); end

    # See {Capybara.configure}
    def threadsafe(*args, &block); end

    def threadsafe=(*args, &block); end

    # Use the default driver as the current driver
    def use_default_driver; end

    # Yield a block using a specific driver
    def using_driver(driver); end

    # Yield a block using a specific session name or {Capybara::Session} instance.
    def using_session(name_or_session, &block); end

    # Yield a block using a specific wait time
    def using_wait_time(seconds); end

    def visible_text_only(*args, &block); end
    def visible_text_only=(*args, &block); end
    def w3c_click_offset(*args, &block); end
    def w3c_click_offset=(*args, &block); end

    private

    def config; end
    def session_pool; end
    def specified_session; end
    def specified_session=(session); end
  end
end

class Capybara::Ambiguous < ::Capybara::ElementNotFound; end
class Capybara::CapybaraError < ::StandardError; end

class Capybara::Config
  extend ::Forwardable

  # @return [Config] a new instance of Config
  def initialize; end

  # Returns the value of attribute allow_gumbo.
  def allow_gumbo; end

  # Sets the attribute allow_gumbo
  #
  # @param value the value to set the attribute allow_gumbo to.
  def allow_gumbo=(_arg0); end

  def always_include_port(*args, &block); end
  def always_include_port=(*args, &block); end

  # Returns the value of attribute app.
  def app; end

  # Sets the attribute app
  #
  # @param value the value to set the attribute app to.
  def app=(_arg0); end

  def app_host(*args, &block); end
  def app_host=(*args, &block); end
  def asset_host(*args, &block); end
  def asset_host=(*args, &block); end
  def automatic_label_click(*args, &block); end
  def automatic_label_click=(*args, &block); end
  def automatic_reload(*args, &block); end
  def automatic_reload=(*args, &block); end

  # @return [Symbol] The name of the driver to use by default
  def default_driver; end

  # Sets the attribute default_driver
  #
  # @param value the value to set the attribute default_driver to.
  def default_driver=(_arg0); end

  def default_host(*args, &block); end
  def default_host=(*args, &block); end
  def default_max_wait_time(*args, &block); end
  def default_max_wait_time=(*args, &block); end
  def default_normalize_ws(*args, &block); end
  def default_normalize_ws=(*args, &block); end
  def default_selector(*args, &block); end
  def default_selector=(*args, &block); end
  def default_set_options(*args, &block); end
  def default_set_options=(*args, &block); end
  def deprecate(method, alternate_method, once: T.unsafe(nil)); end
  def disable_animation(*args, &block); end
  def disable_animation=(*args, &block); end
  def enable_aria_label(*args, &block); end
  def enable_aria_label=(*args, &block); end
  def enable_aria_role(*args, &block); end
  def enable_aria_role=(*args, &block); end
  def exact(*args, &block); end
  def exact=(*args, &block); end
  def exact_text(*args, &block); end
  def exact_text=(*args, &block); end
  def ignore_hidden_elements(*args, &block); end
  def ignore_hidden_elements=(*args, &block); end

  # @return [Symbol] The name of the driver used when JavaScript is needed
  def javascript_driver; end

  # Sets the attribute javascript_driver
  #
  # @param value the value to set the attribute javascript_driver to.
  def javascript_driver=(_arg0); end

  def match(*args, &block); end
  def match=(*args, &block); end
  def predicates_wait(*args, &block); end
  def predicates_wait=(*args, &block); end
  def raise_server_errors(*args, &block); end
  def raise_server_errors=(*args, &block); end

  # Returns the value of attribute reuse_server.
  def reuse_server; end

  # Sets the attribute reuse_server
  #
  # @param value the value to set the attribute reuse_server to.
  def reuse_server=(_arg0); end

  def run_server(*args, &block); end
  def run_server=(*args, &block); end
  def save_path(*args, &block); end
  def save_path=(*args, &block); end

  # Return the proc that Capybara will call to run the Rack application.
  # The block returned receives a rack app, port, and host/ip and should run a Rack handler
  # By default, Capybara will try to use puma.
  def server; end

  # Set the server to use.
  #
  #     Capybara.server = :webrick
  #     Capybara.server = :puma, { Silent: true }
  #
  # @overload server=
  # @overload server=
  # @see register_server
  def server=(name); end

  def server_errors(*args, &block); end
  def server_errors=(*args, &block); end
  def server_host(*args, &block); end
  def server_host=(*args, &block); end
  def server_port(*args, &block); end
  def server_port=(*args, &block); end

  # Returns the value of attribute session_options.
  def session_options; end

  def test_id(*args, &block); end
  def test_id=(*args, &block); end

  # Returns the value of attribute threadsafe.
  def threadsafe; end

  def threadsafe=(bool); end
  def visible_text_only(*args, &block); end
  def visible_text_only=(*args, &block); end
  def w3c_click_offset(*args, &block); end
  def w3c_click_offset=(*args, &block); end
end

Capybara::Config::OPTIONS = T.let(T.unsafe(nil), Array)

# :nocov:
module Capybara::DSL
  def accept_alert(*_arg0, &_arg1); end
  def accept_confirm(*_arg0, &_arg1); end
  def accept_prompt(*_arg0, &_arg1); end
  def all(*_arg0, &_arg1); end
  def assert_all_of_selectors(*_arg0, &_arg1); end
  def assert_any_of_selectors(*_arg0, &_arg1); end
  def assert_current_path(*_arg0, &_arg1); end
  def assert_no_current_path(*_arg0, &_arg1); end
  def assert_no_selector(*_arg0, &_arg1); end
  def assert_no_text(*_arg0, &_arg1); end
  def assert_no_title(*_arg0, &_arg1); end
  def assert_none_of_selectors(*_arg0, &_arg1); end
  def assert_selector(*_arg0, &_arg1); end
  def assert_text(*_arg0, &_arg1); end
  def assert_title(*_arg0, &_arg1); end
  def attach_file(*_arg0, &_arg1); end
  def body(*_arg0, &_arg1); end
  def check(*_arg0, &_arg1); end
  def choose(*_arg0, &_arg1); end
  def click_button(*_arg0, &_arg1); end
  def click_link(*_arg0, &_arg1); end
  def click_link_or_button(*_arg0, &_arg1); end
  def click_on(*_arg0, &_arg1); end
  def current_host(*_arg0, &_arg1); end
  def current_path(*_arg0, &_arg1); end
  def current_scope(*_arg0, &_arg1); end
  def current_url(*_arg0, &_arg1); end
  def current_window(*_arg0, &_arg1); end
  def dismiss_confirm(*_arg0, &_arg1); end
  def dismiss_prompt(*_arg0, &_arg1); end
  def evaluate_script(*_arg0, &_arg1); end
  def execute_script(*_arg0, &_arg1); end
  def fill_in(*_arg0, &_arg1); end
  def find(*_arg0, &_arg1); end
  def find_all(*_arg0, &_arg1); end
  def find_button(*_arg0, &_arg1); end
  def find_by_id(*_arg0, &_arg1); end
  def find_field(*_arg0, &_arg1); end
  def find_link(*_arg0, &_arg1); end
  def first(*_arg0, &_arg1); end
  def go_back(*_arg0, &_arg1); end
  def go_forward(*_arg0, &_arg1); end
  def has_button?(*_arg0, &_arg1); end
  def has_checked_field?(*_arg0, &_arg1); end
  def has_content?(*_arg0, &_arg1); end
  def has_css?(*_arg0, &_arg1); end
  def has_current_path?(*_arg0, &_arg1); end
  def has_field?(*_arg0, &_arg1); end
  def has_link?(*_arg0, &_arg1); end
  def has_no_button?(*_arg0, &_arg1); end
  def has_no_checked_field?(*_arg0, &_arg1); end
  def has_no_content?(*_arg0, &_arg1); end
  def has_no_css?(*_arg0, &_arg1); end
  def has_no_current_path?(*_arg0, &_arg1); end
  def has_no_field?(*_arg0, &_arg1); end
  def has_no_link?(*_arg0, &_arg1); end
  def has_no_select?(*_arg0, &_arg1); end
  def has_no_selector?(*_arg0, &_arg1); end
  def has_no_table?(*_arg0, &_arg1); end
  def has_no_text?(*_arg0, &_arg1); end
  def has_no_title?(*_arg0, &_arg1); end
  def has_no_unchecked_field?(*_arg0, &_arg1); end
  def has_no_xpath?(*_arg0, &_arg1); end
  def has_select?(*_arg0, &_arg1); end
  def has_selector?(*_arg0, &_arg1); end
  def has_table?(*_arg0, &_arg1); end
  def has_text?(*_arg0, &_arg1); end
  def has_title?(*_arg0, &_arg1); end
  def has_unchecked_field?(*_arg0, &_arg1); end
  def has_xpath?(*_arg0, &_arg1); end
  def html(*_arg0, &_arg1); end
  def open_new_window(*_arg0, &_arg1); end

  # Shortcut to accessing the current session.
  #
  #     class MyClass
  #       include Capybara::DSL
  #
  #       def has_header?
  #         page.has_css?('h1')
  #       end
  #     end
  #
  # @return [Capybara::Session] The current session object
  def page; end

  def query(*_arg0, &_arg1); end
  def refresh(*_arg0, &_arg1); end
  def refute_selector(*_arg0, &_arg1); end
  def reset_session!(*_arg0, &_arg1); end
  def response_headers(*_arg0, &_arg1); end
  def save_and_open_page(*_arg0, &_arg1); end
  def save_and_open_screenshot(*_arg0, &_arg1); end
  def save_page(*_arg0, &_arg1); end
  def save_screenshot(*_arg0, &_arg1); end
  def scroll_by(*_arg0, &_arg1); end
  def scroll_to(*_arg0, &_arg1); end
  def select(*_arg0, &_arg1); end
  def send_keys(*_arg0, &_arg1); end
  def source(*_arg0, &_arg1); end
  def status_code(*_arg0, &_arg1); end
  def switch_to_frame(*_arg0, &_arg1); end
  def switch_to_window(*_arg0, &_arg1); end
  def text(*_arg0, &_arg1); end
  def title(*_arg0, &_arg1); end
  def uncheck(*_arg0, &_arg1); end
  def unselect(*_arg0, &_arg1); end

  # Shortcut to working in a different session.
  def using_session(name_or_session, &block); end

  # Shortcut to using a different wait time.
  def using_wait_time(seconds, &block); end

  def visit(*_arg0, &_arg1); end
  def window_opened_by(*_arg0, &_arg1); end
  def windows(*_arg0, &_arg1); end
  def within(*_arg0, &_arg1); end
  def within_element(*_arg0, &_arg1); end
  def within_fieldset(*_arg0, &_arg1); end
  def within_frame(*_arg0, &_arg1); end
  def within_table(*_arg0, &_arg1); end
  def within_window(*_arg0, &_arg1); end

  class << self
    # @private
    def extended(base); end

    # @private
    # @private
    def included(base); end
  end
end

module Capybara::Driver; end

class Capybara::Driver::Base
  # Execute the block, and then accept the modal opened.
  #
  # @option options
  # @option options
  # @option options
  # @param type [:alert, :confirm, :prompt]
  # @param options [Hash] a customizable set of options
  # @raise [Capybara::ModalNotFound] if modal dialog hasn't been found
  # @return [String] the message shown in the modal
  def accept_modal(type, **options, &blk); end

  # @raise [Capybara::NotSupportedByDriverError]
  def close_window(handle); end

  # @raise [NotImplementedError]
  def current_url; end

  # @raise [Capybara::NotSupportedByDriverError]
  def current_window_handle; end

  # Execute the block, and then dismiss the modal opened.
  #
  # @option options
  # @option options
  # @param type [:alert, :confirm, :prompt]
  # @param options [Hash] a customizable set of options
  # @raise [Capybara::ModalNotFound] if modal dialog hasn't been found
  # @return [String] the message shown in the modal
  def dismiss_modal(type, **options, &blk); end

  # @raise [Capybara::NotSupportedByDriverError]
  def evaluate_async_script(script, *args); end

  # @raise [Capybara::NotSupportedByDriverError]
  def evaluate_script(script, *args); end

  # @raise [Capybara::NotSupportedByDriverError]
  def execute_script(script, *args); end

  # @raise [NotImplementedError]
  def find_css(query, **options); end

  # @raise [NotImplementedError]
  def find_xpath(query, **options); end

  def frame_title; end
  def frame_url; end

  # @raise [Capybara::NotSupportedByDriverError]
  def fullscreen_window(handle); end

  # @raise [Capybara::NotSupportedByDriverError]
  def go_back; end

  # @raise [Capybara::NotSupportedByDriverError]
  def go_forward; end

  # @raise [NotImplementedError]
  def html; end

  def invalid_element_errors; end

  # @raise [Capybara::NotSupportedByDriverError]
  def maximize_window(handle); end

  # @return [Boolean]
  def needs_server?; end

  # @raise [Capybara::NotSupportedByDriverError]
  def no_such_window_error; end

  # @raise [Capybara::NotSupportedByDriverError]
  def open_new_window; end

  # @raise [NotImplementedError]
  def refresh; end

  def reset!; end

  # @raise [Capybara::NotSupportedByDriverError]
  def resize_window_to(handle, width, height); end

  # @raise [Capybara::NotSupportedByDriverError]
  def response_headers; end

  # @raise [Capybara::NotSupportedByDriverError]
  def save_screenshot(path, **options); end

  # @raise [Capybara::NotSupportedByDriverError]
  def send_keys(*_arg0); end

  # Sets the attribute session
  #
  # @param value the value to set the attribute session to.
  def session=(_arg0); end

  def session_options; end

  # @raise [Capybara::NotSupportedByDriverError]
  def status_code; end

  # @param frame [Capybara::Node::Element, :parent, :top] The iframe element to switch to
  # @raise [Capybara::NotSupportedByDriverError]
  def switch_to_frame(frame); end

  # @raise [Capybara::NotSupportedByDriverError]
  def switch_to_window(handle); end

  # @raise [NotImplementedError]
  def visit(path); end

  # @return [Boolean]
  def wait?; end

  # @raise [Capybara::NotSupportedByDriverError]
  def window_handles; end

  # @raise [Capybara::NotSupportedByDriverError]
  def window_size(handle); end

  private

  def session; end
end

class Capybara::Driver::Node
  # @return [Node] a new instance of Node
  def initialize(driver, native, initial_cache = T.unsafe(nil)); end

  # @raise [NotSupportedByDriverError]
  def ==(other); end

  # @raise [NotImplementedError]
  def [](name); end

  # @raise [NotImplementedError]
  def all_text; end

  # @raise [NotImplementedError]
  # @return [Boolean]
  def checked?; end

  # @raise [NotImplementedError]
  def click(keys = T.unsafe(nil), **options); end

  # @raise [NotImplementedError]
  # @return [Boolean]
  def disabled?; end

  # @raise [NotImplementedError]
  def double_click(keys = T.unsafe(nil), **options); end

  # @raise [NotImplementedError]
  def drag_to(element, **options); end

  # Returns the value of attribute driver.
  def driver; end

  # @raise [NotImplementedError]
  def drop(*args); end

  # @raise [NotImplementedError]
  def hover; end

  # Returns the value of attribute initial_cache.
  def initial_cache; end

  def inspect; end

  # @return [Boolean]
  def multiple?; end

  # Returns the value of attribute native.
  def native; end

  # @raise [NotImplementedError]
  # @return [Boolean]
  def obscured?; end

  # @raise [NotSupportedByDriverError]
  def path; end

  # @return [Boolean]
  def readonly?; end

  # @raise [NotSupportedByDriverError]
  def rect; end

  # @raise [NotImplementedError]
  def right_click(keys = T.unsafe(nil), **options); end

  # @raise [NotImplementedError]
  def scroll_by(x, y); end

  # @raise [NotImplementedError]
  def scroll_to(element, alignment, position = T.unsafe(nil)); end

  # @raise [NotImplementedError]
  def select_option; end

  # @raise [NotImplementedError]
  # @return [Boolean]
  def selected?; end

  # @raise [NotImplementedError]
  def send_keys(*args); end

  # @param value [String, Array] Array is only allowed if node has 'multiple' attribute
  # @param options [Hash] Driver specific options for how to set a value on a node
  # @raise [NotImplementedError]
  def set(value, **options); end

  # @raise [NotImplementedError]
  def style(styles); end

  # @raise [NotImplementedError]
  def tag_name; end

  # @raise [NotSupportedByDriverError]
  def trigger(event); end

  # @raise [NotImplementedError]
  def unselect_option; end

  # @raise [NotImplementedError]
  def value; end

  # @raise [NotImplementedError]
  # @return [Boolean]
  def visible?; end

  # @raise [NotImplementedError]
  def visible_text; end
end

class Capybara::DriverNotFoundError < ::Capybara::CapybaraError; end
class Capybara::ElementNotFound < ::Capybara::CapybaraError; end
class Capybara::ExpectationNotMet < ::Capybara::ElementNotFound; end
class Capybara::FileNotFound < ::Capybara::CapybaraError; end
class Capybara::FrozenInTime < ::Capybara::CapybaraError; end

# @api private
module Capybara::Helpers
  private

  # A poor man's `pluralize`. Given two declensions, one singular and one
  # plural, as well as a count, this will pick the correct declension. This
  # way we can generate grammatically correct error message.
  #
  # @api private
  # @param singular [String] The singular form of the word
  # @param plural [String] The plural form of the word
  # @param count [Integer] The number of items
  def declension(singular, plural, count); end

  # @api private
  def filter_backtrace(trace); end

  # Injects a `<base>` tag into the given HTML code, pointing to
  # {Capybara.configure asset_host}.
  #
  # @api private
  # @param html [String] HTML code to inject into
  # @param host [URL] (Capybara.asset_host) The host from which assets should be loaded
  # @return [String] The modified HTML code
  def inject_asset_host(html, host: T.unsafe(nil)); end

  # @api private
  def monotonic_time; end

  # Normalizes whitespace space by stripping leading and trailing
  # whitespace and replacing sequences of whitespace characters
  # with a single space.
  #
  # @api private
  # @deprecated
  # @param text [String] Text to normalize
  # @return [String] Normalized text
  def normalize_whitespace(text); end

  # @api private
  def timer(expire_in:); end

  # Escapes any characters that would have special meaning in a regexp
  # if text is not a regexp
  #
  # @api private
  # @param text [String] Text to escape
  # @param exact [Boolean] (false) Whether or not this should be an exact text match
  # @param options [Fixnum, Boolean, nil] Options passed to Regexp.new when creating the Regexp
  # @return [Regexp] Regexp to match the passed in text and options
  def to_regexp(text, exact: T.unsafe(nil), all_whitespace: T.unsafe(nil), options: T.unsafe(nil)); end

  # @api private
  def warn(message, uplevel: T.unsafe(nil)); end

  class << self
    # A poor man's `pluralize`. Given two declensions, one singular and one
    # plural, as well as a count, this will pick the correct declension. This
    # way we can generate grammatically correct error message.
    #
    # @api private
    # @param singular [String] The singular form of the word
    # @param plural [String] The plural form of the word
    # @param count [Integer] The number of items
    def declension(singular, plural, count); end

    # @api private
    def filter_backtrace(trace); end

    # Injects a `<base>` tag into the given HTML code, pointing to
    # {Capybara.configure asset_host}.
    #
    # @api private
    # @param html [String] HTML code to inject into
    # @param host [URL] (Capybara.asset_host) The host from which assets should be loaded
    # @return [String] The modified HTML code
    def inject_asset_host(html, host: T.unsafe(nil)); end

    def monotonic_time; end

    # Normalizes whitespace space by stripping leading and trailing
    # whitespace and replacing sequences of whitespace characters
    # with a single space.
    #
    # @api private
    # @deprecated
    # @param text [String] Text to normalize
    # @return [String] Normalized text
    def normalize_whitespace(text); end

    # @api private
    def timer(expire_in:); end

    # Escapes any characters that would have special meaning in a regexp
    # if text is not a regexp
    #
    # @api private
    # @param text [String] Text to escape
    # @param exact [Boolean] (false) Whether or not this should be an exact text match
    # @param options [Fixnum, Boolean, nil] Options passed to Regexp.new when creating the Regexp
    # @return [Regexp] Regexp to match the passed in text and options
    def to_regexp(text, exact: T.unsafe(nil), all_whitespace: T.unsafe(nil), options: T.unsafe(nil)); end

    # @api private
    def warn(message, uplevel: T.unsafe(nil)); end
  end
end

# @api private
class Capybara::Helpers::Timer
  # @api private
  # @return [Timer] a new instance of Timer
  def initialize(expire_in); end

  # @api private
  # @return [Boolean]
  def expired?; end

  # @api private
  # @return [Boolean]
  def stalled?; end

  private

  # @api private
  def current; end
end

class Capybara::InfiniteRedirectError < ::Capybara::CapybaraError; end
module Capybara::Minitest; end

module Capybara::Minitest::Assertions
  # See {Capybara::Node::Matchers#assert_all_of_selectors}
  def assert_all_of_selectors(*args, &optional_filter_block); end

  # See {Capybara::Node::Matchers#assert_ancestor}
  def assert_ancestor(*args, &optional_filter_block); end

  # See {Capybara::Node::Matchers#assert_any_of_selectors}
  def assert_any_of_selectors(*args, &optional_filter_block); end

  # See {Capybara::Node::Matchers#has_button?}
  def assert_button(*args, &optional_filter_block); end

  # See {Capybara::Node::Matchers#has_checked_field?}
  def assert_checked_field(*args, &optional_filter_block); end

  # See {Capybara::Node::Matchers#assert_text}
  def assert_content(*args, **kwargs, &optional_filter_block); end

  # See {Capybara::Node::Matchers#has_css?}
  def assert_css(*args, &optional_filter_block); end

  # See {Capybara::SessionMatchers#assert_current_path}
  def assert_current_path(*args, **kwargs, &optional_filter_block); end

  # See {Capybara::Node::Matchers#has_field?}
  def assert_field(*args, &optional_filter_block); end

  # See {Capybara::Node::Matchers#has_link?}
  def assert_link(*args, &optional_filter_block); end

  # See {Capybara::Node::Matchers#matches_css?}
  def assert_matches_css(*args, &optional_filter_block); end

  # See {Capybara::Node::Matchers#assert_matches_selector}
  def assert_matches_selector(*args, &optional_filter_block); end

  # See {Capybara::Node::Matchers#assert_matches_style}
  def assert_matches_style(*args, &optional_filter_block); end

  # See {Capybara::Node::Matchers#matches_xpath?}
  def assert_matches_xpath(*args, &optional_filter_block); end

  # See {Capybara::Node::Matchers#assert_no_ancestor}
  def assert_no_ancestor(*args, &optional_filter_block); end

  # See {Capybara::Node::Matchers#has_no_button?}
  def assert_no_button(*args, &optional_filter_block); end

  # Assert that provided checked_field does not exist
  def assert_no_checked_field(*args, &optional_filter_block); end

  # See {Capybara::Node::Matchers#assert_no_text}
  def assert_no_content(*args, **kwargs, &optional_filter_block); end

  # See {Capybara::Node::Matchers#has_no_css?}
  def assert_no_css(*args, &optional_filter_block); end

  # See {Capybara::SessionMatchers#assert_no_current_path}
  def assert_no_current_path(*args, **kwargs, &optional_filter_block); end

  # See {Capybara::Node::Matchers#has_no_field?}
  def assert_no_field(*args, &optional_filter_block); end

  # Assert that provided link does not exist
  def assert_no_link(*args, &optional_filter_block); end

  # See {Capybara::Node::Matchers#has_no_select?}
  def assert_no_select(*args, &optional_filter_block); end

  # See {Capybara::Node::Matchers#assert_no_selector}
  def assert_no_selector(*args, &optional_filter_block); end

  # See {Capybara::Node::Matchers#assert_no_sibling}
  def assert_no_sibling(*args, &optional_filter_block); end

  # See {Capybara::Node::Matchers#has_no_table?}
  def assert_no_table(*args, &optional_filter_block); end

  # See {Capybara::Node::Matchers#assert_no_text}
  def assert_no_text(*args, **kwargs, &optional_filter_block); end

  # See {Capybara::Node::DocumentMatchers#assert_no_title}
  def assert_no_title(*args, **kwargs, &optional_filter_block); end

  # Assert that provided unchecked field does not exist
  def assert_no_unchecked_field(*args, &optional_filter_block); end

  # See {Capybara::Node::Matchers#has_no_xpath?}
  def assert_no_xpath(*args, &optional_filter_block); end

  # See {Capybara::Node::Matchers#assert_none_of_selectors}
  def assert_none_of_selectors(*args, &optional_filter_block); end

  # See {Capybara::Node::Matchers#not_matches_css?}
  def assert_not_matches_css(*args, &optional_filter_block); end

  # See {Capybara::Node::Matchers#assert_not_matches_selector}
  def assert_not_matches_selector(*args, &optional_filter_block); end

  # See {Capybara::Node::Matchers#not_matches_xpath?}
  def assert_not_matches_xpath(*args, &optional_filter_block); end

  # See {Capybara::Node::Matchers#has_select?}
  def assert_select(*args, &optional_filter_block); end

  # See {Capybara::Node::Matchers#assert_selector}
  def assert_selector(*args, &optional_filter_block); end

  # See {Capybara::Node::Matchers#assert_sibling}
  def assert_sibling(*args, &optional_filter_block); end

  # See {Capybara::Node::Matchers#has_table?}
  def assert_table(*args, &optional_filter_block); end

  # See {Capybara::Node::Matchers#assert_text}
  def assert_text(*args, **kwargs, &optional_filter_block); end

  # See {Capybara::Node::DocumentMatchers#assert_title}
  def assert_title(*args, **kwargs, &optional_filter_block); end

  # See {Capybara::Node::Matchers#has_unchecked_field?}
  def assert_unchecked_field(*args, &optional_filter_block); end

  # See {Capybara::Node::Matchers#has_xpath?}
  def assert_xpath(*args, &optional_filter_block); end

  # See {Capybara::Node::Matchers#assert_no_ancestor}
  def refute_ancestor(*args, &optional_filter_block); end

  # Assert that provided button does not exist
  def refute_button(*args, &optional_filter_block); end

  # See {Capybara::Node::Matchers#has_no_checked_field?}
  def refute_checked_field(*args, &optional_filter_block); end

  # See {Capybara::Node::Matchers#assert_no_text}
  def refute_content(*args, **kwargs, &optional_filter_block); end

  # Assert that provided css does not exist
  def refute_css(*args, &optional_filter_block); end

  # See {Capybara::SessionMatchers#assert_no_current_path}
  def refute_current_path(*args, **kwargs, &optional_filter_block); end

  # Assert that provided field does not exist
  def refute_field(*args, &optional_filter_block); end

  # See {Capybara::Node::Matchers#has_no_link?}
  def refute_link(*args, &optional_filter_block); end

  # Assert that element matches css
  def refute_matches_css(*args, &optional_filter_block); end

  # See {Capybara::Node::Matchers#assert_not_matches_selector}
  def refute_matches_selector(*args, &optional_filter_block); end

  # Assert that element does not match xpath
  def refute_matches_xpath(*args, &optional_filter_block); end

  # Assert that provided select does not exist
  def refute_select(*args, &optional_filter_block); end

  # See {Capybara::Node::Matchers#assert_no_selector}
  def refute_selector(*args, &optional_filter_block); end

  # See {Capybara::Node::Matchers#assert_no_sibling}
  def refute_sibling(*args, &optional_filter_block); end

  # Assert that provided table does not exist
  def refute_table(*args, &optional_filter_block); end

  # See {Capybara::Node::Matchers#assert_no_text}
  def refute_text(*args, **kwargs, &optional_filter_block); end

  # See {Capybara::Node::DocumentMatchers#assert_no_title}
  def refute_title(*args, **kwargs, &optional_filter_block); end

  # See {Capybara::Node::Matchers#has_no_unchecked_field?}
  def refute_unchecked_field(*args, &optional_filter_block); end

  # Assert that provide xpath does not exist
  def refute_xpath(*args, &optional_filter_block); end

  private

  def determine_subject(args); end
  def extract_locator(args); end
end

class Capybara::ModalNotFound < ::Capybara::CapybaraError; end
module Capybara::Node; end

module Capybara::Node::Actions
  # Find a descendant file field on the page and attach a file given its path. There are two ways to use
  # {#attach_file}, in the first method the file field can be found via its name, id,
  # {Capybara.configure test_id} attribute, or label text. In the case of the file field being hidden for
  # styling reasons the `make_visible` option can be used to temporarily change the CSS of
  # the file field, attach the file, and then revert the CSS back to original. If no locator is
  # passed this will match self or a descendant.
  # The second method, which is currently in beta and may be changed/removed, involves passing a block
  # which performs whatever actions would trigger the file chooser to appear.
  #
  #     # will attach file to a descendant file input element that has a name, id, or label_text matching 'My File'
  #     page.attach_file('My File', '/path/to/file.png')
  #
  #     # will attach file to el if it's a file input element
  #     el.attach_file('/path/to/file.png')
  #
  #     # will attach file to whatever file input is triggered by the block
  #     page.attach_file('/path/to/file.png') do
  #       page.find('#upload_button').click
  #     end
  #
  # @overload attach_file
  # @overload attach_file
  # @return [Capybara::Node::Element] The file field element
  def attach_file(locator = T.unsafe(nil), paths, make_visible: T.unsafe(nil), **options); end

  # Find a descendant check box and mark it as checked. The check box can be found
  # via name, id, {Capybara.configure test_id} attribute, or label text. If no locator
  # is provided this will match against self or a descendant.
  #
  #     # will check a descendant checkbox with a name, id, or label text matching 'German'
  #     page.check('German')
  #
  #     # will check `el` if it's a checkbox element
  #     el.check()
  #
  # @overload check
  # @return [Capybara::Node::Element] The element checked or the label clicked
  def check(locator = T.unsafe(nil), **options); end

  # Find a descendant radio button and mark it as checked. The radio button can be found
  # via name, id, {Capybara.configure test_id} attribute or label text. If no locator is
  # provided this will match against self or a descendant.
  #
  #     # will choose a descendant radio button with a name, id, or label text matching 'Male'
  #     page.choose('Male')
  #
  #     # will choose `el` if it's a radio button element
  #     el.choose()
  #
  # @overload choose
  # @return [Capybara::Node::Element] The element chosen or the label clicked
  def choose(locator = T.unsafe(nil), **options); end

  # Finds a button on the page and clicks it.
  # This can be any `<input>` element of type submit, reset, image, button or it can be a
  # `<button>` element. All buttons can be found by their id, name, {Capybara.configure test_id} attribute, value, or title. `<button>` elements can also be found
  # by their text content, and image `<input>` elements by their alt attribute.
  #
  # @overload click_button
  # @return [Capybara::Node::Element] The element clicked
  def click_button(locator = T.unsafe(nil), **options); end

  # Finds a link by id, {Capybara.configure test_id} attribute, text or title and clicks it. Also looks at image
  # alt text inside the link.
  #
  # @overload click_link
  # @return [Capybara::Node::Element] The element clicked
  def click_link(locator = T.unsafe(nil), **options); end

  # Finds a button or link and clicks it. See {#click_button} and
  # {#click_link} for what locator will match against for each type of element.
  #
  # @overload click_link_or_button
  # @return [Capybara::Node::Element] The element clicked
  def click_link_or_button(locator = T.unsafe(nil), **options); end

  # Finds a button or link and clicks it. See {#click_button} and
  # {#click_link} for what locator will match against for each type of element.
  #
  # @overload click_link_or_button
  # @return [Capybara::Node::Element] The element clicked
  def click_on(locator = T.unsafe(nil), **options); end

  # Locate a text field or text area and fill it in with the given text.
  # The field can be found via its name, id, {Capybara.configure test_id} attribute, placeholder, or label text.
  # If no locator is provided this will operate on self or a descendant.
  #
  #     # will fill in a descendant fillable field with name, id, or label text matching 'Name'
  #     page.fill_in 'Name', with: 'Bob'
  #
  #     # will fill in `el` if it's a fillable field
  #     el.fill_in with: 'Tom'
  #
  # @overload fill_in
  # @return [Capybara::Node::Element] The element filled in
  def fill_in(locator = T.unsafe(nil), with:, currently_with: T.unsafe(nil), fill_options: T.unsafe(nil), **find_options); end

  # If `from` option is present, {#select} finds a select box, or text input with associated datalist,
  # on the page and selects a particular option from it.
  # Otherwise it finds an option inside current scope and selects it.
  # If the select box is a multiple select, {#select} can be called multiple times to select more than
  # one option.
  # The select box can be found via its name, id, {Capybara.configure test_id} attribute, or label text.
  # The option can be found by its text.
  #
  #     page.select 'March', from: 'Month'
  #
  # @overload select
  # @raise [ArgumentError]
  # @return [Capybara::Node::Element] The option element selected
  def select(value = T.unsafe(nil), from: T.unsafe(nil), **options); end

  # Find a descendant check box and uncheck it. The check box can be found
  # via name, id, {Capybara.configure test_id} attribute, or label text. If
  # no locator is provided this will match against self or a descendant.
  #
  #     # will uncheck a descendant checkbox with a name, id, or label text matching 'German'
  #     page.uncheck('German')
  #
  #     # will uncheck `el` if it's a checkbox element
  #     el.uncheck()
  #
  # @overload uncheck
  # @return [Capybara::Node::Element] The element unchecked or the label clicked
  def uncheck(locator = T.unsafe(nil), **options); end

  # Find a select box on the page and unselect a particular option from it. If the select
  # box is a multiple select, {#unselect} can be called multiple times to unselect more than
  # one option. The select box can be found via its name, id, {Capybara.configure test_id} attribute,
  # or label text.
  #
  #     page.unselect 'March', from: 'Month'
  #
  # @overload unselect
  # @raise [ArgumentError]
  # @return [Capybara::Node::Element] The option element unselected
  def unselect(value = T.unsafe(nil), from: T.unsafe(nil), **options); end

  private

  def _check_with_label(selector, checked, locator, allow_label_click: T.unsafe(nil), **options); end
  def _reset_style(element); end
  def _update_style(element, style); end
  def find_select_or_datalist_input(from, options); end
  def select_datalist_option(input, value); end
  def while_visible(element, visible_css); end
end

Capybara::Node::Actions::CAPTURE_FILE_ELEMENT_SCRIPT = T.let(T.unsafe(nil), String)
Capybara::Node::Actions::DATALIST_OPTIONS_SCRIPT = T.let(T.unsafe(nil), String)
Capybara::Node::Actions::RESET_STYLE_SCRIPT = T.let(T.unsafe(nil), String)
Capybara::Node::Actions::UPDATE_STYLE_SCRIPT = T.let(T.unsafe(nil), String)

# A {Capybara::Node::Base} represents either an element on a page through the subclass
# {Capybara::Node::Element} or a document through {Capybara::Node::Document}.
#
# Both types of Node share the same methods, used for interacting with the
# elements on the page. These methods are divided into three categories,
# finders, actions and matchers. These are found in the modules
# {Capybara::Node::Finders}, {Capybara::Node::Actions} and {Capybara::Node::Matchers}
# respectively.
#
# A {Capybara::Session} exposes all methods from {Capybara::Node::Document} directly:
#
#     session = Capybara::Session.new(:rack_test, my_app)
#     session.visit('/')
#     session.fill_in('Foo', with: 'Bar')    # from Capybara::Node::Actions
#     bar = session.find('#bar')                # from Capybara::Node::Finders
#     bar.select('Baz', from: 'Quox')        # from Capybara::Node::Actions
#     session.has_css?('#foobar')               # from Capybara::Node::Matchers
class Capybara::Node::Base
  include ::Capybara::Node::Finders
  include ::Capybara::Node::Actions
  include ::Capybara::Node::Matchers

  # @return [Base] a new instance of Base
  def initialize(session, base); end

  # Returns the value of attribute base.
  def base; end

  # @api private
  def find_css(css, **options); end

  # @api private
  def find_xpath(xpath, **options); end

  # Returns the value of attribute query_scope.
  def query_scope; end

  # overridden in subclasses, e.g. Capybara::Node::Element
  def reload; end

  # Returns the value of attribute session.
  def session; end

  # @api private
  def session_options; end

  # This method is Capybara's primary defence against asynchronicity
  # problems. It works by attempting to run a given block of code until it
  # succeeds. The exact behaviour of this method depends on a number of
  # factors. Basically there are certain exceptions which, when raised
  # from the block, instead of bubbling up, are caught, and the block is
  # re-run.
  #
  # Certain drivers, such as RackTest, have no support for asynchronous
  # processes, these drivers run the block, and any error raised bubbles up
  # immediately. This allows faster turn around in the case where an
  # expectation fails.
  #
  # Only exceptions that are {Capybara::ElementNotFound} or any subclass
  # thereof cause the block to be rerun. Drivers may specify additional
  # exceptions which also cause reruns. This usually occurs when a node is
  # manipulated which no longer exists on the page. For example, the
  # Selenium driver specifies
  # `Selenium::WebDriver::Error::ObsoleteElementError`.
  #
  # As long as any of these exceptions are thrown, the block is re-run,
  # until a certain amount of time passes. The amount of time defaults to
  # {Capybara.default_max_wait_time} and can be overridden through the `seconds`
  # argument. This time is compared with the system time to see how much
  # time has passed. On rubies/platforms which don't support access to a monotonic process clock
  # if the return value of `Time.now` is stubbed out, Capybara will raise `Capybara::FrozenInTime`.
  #
  # @param seconds [Integer] (current sessions default_max_wait_time) Maximum number of seconds to retry this block
  # @param errors [Array<Exception>] (driver.invalid_element_errors +
  #   [Capybara::ElementNotFound]) exception types that cause the block to be rerun
  # @raise [Capybara::FrozenInTime] If the return value of `Time.now` appears stuck
  # @return [Object] The result of the given block
  def synchronize(seconds = T.unsafe(nil), errors: T.unsafe(nil)); end

  def to_capybara_node; end

  protected

  # @return [Boolean]
  def catch_error?(error, errors = T.unsafe(nil)); end

  def driver; end
end

# A {Capybara::Document} represents an HTML document. Any operation
# performed on it will be performed on the entire document.
#
# @see Capybara::Node
class Capybara::Node::Document < ::Capybara::Node::Base
  include ::Capybara::Node::DocumentMatchers

  def evaluate_script(*args); end
  def execute_script(*args); end
  def inspect; end
  def scroll_to(*args, **options); end

  # @return [String] The text of the document
  def text(type = T.unsafe(nil), normalize_ws: T.unsafe(nil)); end

  # @return [String] The title of the document
  def title; end
end

module Capybara::Node::DocumentMatchers
  # Asserts that the page doesn't have the given title.
  #
  # @option options
  # @option options
  # @overload assert_no_title
  # @overload assert_no_title
  # @param options [Hash] a customizable set of options
  # @raise [Capybara::ExpectationNotMet] if the assertion hasn't succeeded during wait time
  # @return [true]
  def assert_no_title(title, **options); end

  # Asserts that the page has the given title.
  #
  # @option options
  # @option options
  # @overload assert_title
  # @overload assert_title
  # @param options [Hash] a customizable set of options
  # @raise [Capybara::ExpectationNotMet] if the assertion hasn't succeeded during wait time
  # @return [true]
  def assert_title(title, **options); end

  # Checks if the page doesn't have the given title.
  #
  # @option options
  # @option options
  # @overload has_no_title?
  # @overload has_no_title?
  # @param options [Hash] a customizable set of options
  # @return [Boolean]
  def has_no_title?(title, **options); end

  # Checks if the page has the given title.
  #
  # @option options
  # @option options
  # @overload has_title?
  # @overload has_title?
  # @param options [Hash] a customizable set of options
  # @return [Boolean]
  def has_title?(title, **options); end

  private

  def _verify_title(title, options); end
end

# A {Capybara::Node::Element} represents a single element on the page. It is possible
# to interact with the contents of this element the same as with a document:
#
#     session = Capybara::Session.new(:rack_test, my_app)
#
#     bar = session.find('#bar')              # from Capybara::Node::Finders
#     bar.select('Baz', from: 'Quox')      # from Capybara::Node::Actions
#
# {Capybara::Node::Element} also has access to HTML attributes and other properties of the
# element:
#
#      bar.value
#      bar.text
#      bar[:title]
#
# @see Capybara::Node
class Capybara::Node::Element < ::Capybara::Node::Base
  # @return [Element] a new instance of Element
  def initialize(session, base, query_scope, query); end

  # Retrieve the given attribute.
  #
  #     element[:title] # => HTML title attribute
  #
  # @param attribute [Symbol] The attribute to retrieve
  # @return [String] The value of the attribute
  def [](attribute); end

  def allow_reload!(idx = T.unsafe(nil)); end

  # Whether or not the element is checked.
  #
  # @return [Boolean] Whether the element is checked
  def checked?; end

  # Click the Element.
  #
  # If the driver dynamic pages (JS) and the element is currently non-interactable, this method will
  # continuously retry the action until either the element becomes interactable or the maximum
  # wait time expires.
  #
  # Both x: and y: must be specified if an offset is wanted, if not specified the click will occur at the middle of the element.
  #
  # @option options
  # @overload click
  # @param wait [false, Numeric] Maximum time to wait for the action to succeed. Defaults to {Capybara.configure default_max_wait_time}.
  # @param options [Hash] a customizable set of options
  # @return [Capybara::Node::Element] The element
  def click(*keys, **options); end

  # Whether or not the element is disabled.
  #
  # @return [Boolean] Whether the element is disabled
  def disabled?; end

  # Double Click the Element.
  #
  # If the driver dynamic pages (JS) and the element is currently non-interactable, this method will
  # continuously retry the action until either the element becomes interactable or the maximum
  # wait time expires.
  #
  # Both x: and y: must be specified if an offset is wanted, if not specified the click will occur at the middle of the element.
  #
  # @overload double_click
  # @param wait [false, Numeric] Maximum time to wait for the action to succeed. Defaults to {Capybara.configure default_max_wait_time}.
  # @return [Capybara::Node::Element] The element
  def double_click(*keys, **options); end

  # Drag the element to the given other element.
  #
  #     source = page.find('#foo')
  #     target = page.find('#bar')
  #     source.drag_to(target)
  #
  # @option options
  # @option options
  # @option options
  # @param node [Capybara::Node::Element] The element to drag to
  # @param options [Hash] Driver specific options for dragging. May not be supported by all drivers.
  # @return [Capybara::Node::Element] The dragged element
  def drag_to(node, **options); end

  # Drop items on the current element.
  #
  #     target = page.find('#foo')
  #     target.drop('/some/path/file.csv')
  #
  # @overload drop
  # @overload drop
  # @return [Capybara::Node::Element] The element
  def drop(*args); end

  # Evaluate the given JavaScript in the context of the element and obtain the result from a
  # callback function which will be passed as the last argument to the script. `this` in the
  # script will refer to the element this is called on.
  #
  # @param script [String] A string of JavaScript to evaluate
  # @return [Object] The result of the evaluated JavaScript (may be driver specific)
  def evaluate_async_script(script, *args); end

  # Evaluate the given JS in the context of the element and return the result. Be careful when using this with
  # scripts that return complex objects, such as jQuery statements. {#execute_script} might
  # be a better alternative. `this` in the script will refer to the element this is called on.
  #
  # @param script [String] A string of JavaScript to evaluate
  # @return [Object] The result of the evaluated JavaScript (may be driver specific)
  def evaluate_script(script, *args); end

  # Execute the given JS in the context of the element not returning a result. This is useful for scripts that return
  # complex objects, such as jQuery statements. {#execute_script} should be used over
  # {#evaluate_script} whenever a result is not expected or needed. `this` in the script will refer to the element this is called on.
  #
  # @param script [String] A string of JavaScript to execute
  # @param args Optional arguments that will be passed to the script. Driver support for this is optional and types of objects supported may differ between drivers
  def execute_script(script, *args); end

  # Toggle the elements background color between white and black for a period of time.
  #
  # @return [Capybara::Node::Element] The element
  def flash; end

  # Hover on the Element.
  #
  # @return [Capybara::Node::Element] The element
  def hover; end

  # @api private
  def initial_cache; end

  # A human-readable representation of the element.
  #
  # @return [String] A string representation
  def inspect; end

  # Whether or not the element supports multiple results.
  #
  # @return [Boolean] Whether the element supports multiple results.
  def multiple?; end

  # @return [Object] The native element from the driver, this allows access to driver specific methods
  def native; end

  # Whether or not the element is currently in the viewport and it (or descendants)
  # would be considered clickable at the elements center point.
  #
  # @return [Boolean] Whether the elements center is obscured.
  def obscured?; end

  # An XPath expression describing where on the page the element can be found.
  #
  # @return [String] An XPath expression
  def path; end

  # Whether or not the element is readonly.
  #
  # @return [Boolean] Whether the element is readonly
  def readonly?; end

  def rect; end

  # @api private
  def reload; end

  # Right Click the Element.
  #
  # If the driver dynamic pages (JS) and the element is currently non-interactable, this method will
  # continuously retry the action until either the element becomes interactable or the maximum
  # wait time expires.
  #
  # Both x: and y: must be specified if an offset is wanted, if not specified the click will occur at the middle of the element.
  #
  # @option options
  # @overload right_click
  # @param wait [false, Numeric] Maximum time to wait for the action to succeed. Defaults to {Capybara.configure default_max_wait_time}.
  # @param options [Hash] a customizable set of options
  # @return [Capybara::Node::Element] The element
  def right_click(*keys, **options); end

  # Scroll the page or element.
  #
  # @overload scroll_to
  # @overload scroll_to
  # @overload scroll_to
  # @return [Capybara::Node::Element] The element
  def scroll_to(pos_or_el_or_x, y = T.unsafe(nil), align: T.unsafe(nil), offset: T.unsafe(nil)); end

  # Select this node if it is an option element inside a select tag.
  #
  # If the driver dynamic pages (JS) and the element is currently non-interactable, this method will
  # continuously retry the action until either the element becomes interactable or the maximum
  # wait time expires.
  #
  # @param wait [false, Numeric] Maximum time to wait for the action to succeed. Defaults to {Capybara.configure default_max_wait_time}.
  # @return [Capybara::Node::Element] The element
  def select_option(wait: T.unsafe(nil)); end

  # Whether or not the element is selected.
  #
  # @return [Boolean] Whether the element is selected
  def selected?; end

  # Send Keystrokes to the Element.
  #
  # Examples:
  #
  #     element.send_keys "foo"                     #=> value: 'foo'
  #     element.send_keys "tet", :left, "s"         #=> value: 'test'
  #     element.send_keys [:control, 'a'], :space   #=> value: ' ' - assuming ctrl-a selects all contents
  #
  # Symbols supported for keys:
  # * :cancel
  # * :help
  # * :backspace
  # * :tab
  # * :clear
  # * :return
  # * :enter
  # * :shift
  # * :control
  # * :alt
  # * :pause
  # * :escape
  # * :space
  # * :page_up
  # * :page_down
  # * :end
  # * :home
  # * :left
  # * :up
  # * :right
  # * :down
  # * :insert
  # * :delete
  # * :semicolon
  # * :equals
  # * :numpad0
  # * :numpad1
  # * :numpad2
  # * :numpad3
  # * :numpad4
  # * :numpad5
  # * :numpad6
  # * :numpad7
  # * :numpad8
  # * :numpad9
  # * :multiply      - numeric keypad *
  # * :add           - numeric keypad +
  # * :separator     - numeric keypad 'separator' key ??
  # * :subtract      - numeric keypad -
  # * :decimal       - numeric keypad .
  # * :divide        - numeric keypad /
  # * :f1
  # * :f2
  # * :f3
  # * :f4
  # * :f5
  # * :f6
  # * :f7
  # * :f8
  # * :f9
  # * :f10
  # * :f11
  # * :f12
  # * :meta
  # * :command      - alias of :meta
  #
  # @overload send_keys
  # @return [Capybara::Node::Element] The element
  def send_keys(*args); end

  # Set the value of the form element to the given value.
  #
  # @param value [String] The new value
  # @param options [Hash] Driver specific options for how to set the value. Take default values from {Capybara.configure default_set_options}.
  # @return [Capybara::Node::Element] The element
  def set(value, **options); end

  # Retrieve the given CSS styles.
  #
  #     element.style('color', 'font-size') # => Computed values of CSS 'color' and 'font-size' styles
  #
  # @param styles [Array<String>] Names of the desired CSS properties
  # @raise [ArgumentError]
  # @return [Hash] Hash of the CSS property names to computed values
  def style(*styles); end

  # @return [String] The tag name of the element
  def tag_name; end

  # Retrieve the text of the element. If {Capybara.configure ignore_hidden_elements}
  # is `true`, which it is by default, then this will return only text
  # which is visible. The exact semantics of this may differ between
  # drivers, but generally any text within elements with `display:none` is
  # ignored. This behaviour can be overridden by passing `:all` to this
  # method.
  #
  # @param type [:all, :visible] Whether to return only visible or all text
  # @return [String] The text of the element
  def text(type = T.unsafe(nil), normalize_ws: T.unsafe(nil)); end

  # Trigger any event on the current element, for example mouseover or focus
  # events. Not supported with the Selenium driver, and SHOULDN'T BE USED IN TESTING unless you
  # fully understand why you're using it, that it can allow actions a user could never
  # perform, and that it may completely invalidate your test.
  #
  # @param event [String] The name of the event to trigger
  # @return [Capybara::Node::Element] The element
  def trigger(event); end

  # Unselect this node if it is an option element inside a multiple select tag.
  #
  # If the driver dynamic pages (JS) and the element is currently non-interactable, this method will
  # continuously retry the action until either the element becomes interactable or the maximum
  # wait time expires.
  #
  # @param wait [false, Numeric] Maximum time to wait for the action to succeed. Defaults to {Capybara.configure default_max_wait_time}.
  # @return [Capybara::Node::Element] The element
  def unselect_option(wait: T.unsafe(nil)); end

  # @return [String] The value of the form element
  def value; end

  # Whether or not the element is visible. Not all drivers support CSS, so
  # the result may be inaccurate.
  #
  # @return [Boolean] Whether the element is visible
  def visible?; end

  private

  # @raise [ArgumentError]
  def perform_click_action(keys, wait: T.unsafe(nil), **options); end
end

Capybara::Node::Element::STYLE_SCRIPT = T.let(T.unsafe(nil), String)

module Capybara::Node::Finders
  # Find all elements on the page matching the given selector
  # and options.
  #
  # Both XPath and CSS expressions are supported, but Capybara
  # does not try to automatically distinguish between them. The
  # following statements are equivalent:
  #
  #     page.all(:css, 'a#person_123')
  #     page.all(:xpath, './/a[@id="person_123"]')
  #
  # If the type of selector is left out, Capybara uses
  # {Capybara.configure default_selector}. It's set to `:css` by default.
  #
  #     page.all("a#person_123")
  #
  #     Capybara.default_selector = :xpath
  #     page.all('.//a[@id="person_123"]')
  #
  # The set of found elements can further be restricted by specifying
  # options. It's possible to select elements by their text or visibility:
  #
  #     page.all('a', text: 'Home')
  #     page.all('#menu li', visible: true)
  #
  # By default Capybara's waiting behavior will wait up to {Capybara.configure default_max_wait_time}
  # seconds for matching elements to be available and then return an empty result if none
  # are available. It is possible to set expectations on the number of results located and
  # Capybara will raise an exception if the number of elements located don't satisfy the
  # specified conditions. The expectations can be set using:
  #
  #     page.assert_selector('p#foo', count: 4)
  #     page.assert_selector('p#foo', maximum: 10)
  #     page.assert_selector('p#foo', minimum: 1)
  #     page.assert_selector('p#foo', between: 1..10)
  #
  # If the driver is capable of executing JavaScript, this method will wait for a set amount of time
  # and continuously retry finding the element until either the element is found or the time
  # expires. The length of time this method will wait is controlled through {Capybara.configure default_max_wait_time}.
  #
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @overload all
  # @overload all
  # @param kind [Symbol] Optional selector type (:css, :xpath, :field, etc.). Defaults to {Capybara.configure default_selector}.
  # @param locator [String] The locator for the specified selector
  # @param options [Hash] a customizable set of options
  # @raise [Capybara::ExpectationNotMet] The number of elements found doesn't match the specified conditions
  # @return [Capybara::Result] A collection of found elements
  def all(*args, allow_reload: T.unsafe(nil), **options, &optional_filter_block); end

  # Find an {Capybara::Node::Element} based on the given arguments that is also an ancestor of the element called on.
  # {#ancestor} will raise an error if the element is not found.
  #
  # {#ancestor} takes the same options as {#find}.
  #
  #     element.ancestor('#foo').find('.bar')
  #     element.ancestor(:xpath, './/div[contains(., "bar")]')
  #     element.ancestor('ul', text: 'Quox').click_link('Delete')
  #
  # If the driver is capable of executing JavaScript, this method will wait for a set amount of time
  # and continuously retry finding the element until either the element is found or the time
  # expires. The length of time this method will wait is controlled through {Capybara.configure default_max_wait_time}.
  #
  # @option options
  # @param options [Hash] a customizable set of options
  # @param kind [Symbol] Optional selector type (:css, :xpath, :field, etc.). Defaults to {Capybara.configure default_selector}.
  # @param locator [String] The locator for the specified selector
  # @param options [Hash] a customizable set of options
  # @raise [Capybara::ElementNotFound] If the element can't be found before time expires
  # @return [Capybara::Node::Element] The found element
  def ancestor(*args, **options, &optional_filter_block); end

  # Find an {Capybara::Node::Element} based on the given arguments. {#find} will raise an error if the element
  # is not found.
  #
  #     page.find('#foo').find('.bar')
  #     page.find(:xpath, './/div[contains(., "bar")]')
  #     page.find('li', text: 'Quox').click_link('Delete')
  #
  # If the driver is capable of executing JavaScript, this method will wait for a set amount of time
  # and continuously retry finding the element until either the element is found or the time
  # expires. The length of time this method will wait is controlled through {Capybara.configure default_max_wait_time}.
  #
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @param options [Hash] a customizable set of options
  # @param kind [Symbol] Optional selector type (:css, :xpath, :field, etc.). Defaults to {Capybara.configure default_selector}.
  # @param locator [String] The locator for the specified selector
  # @param options [Hash] a customizable set of options
  # @raise [Capybara::ElementNotFound] If the element can't be found before time expires
  # @return [Capybara::Node::Element] The found element
  def find(*args, **options, &optional_filter_block); end

  # Find all elements on the page matching the given selector
  # and options.
  #
  # Both XPath and CSS expressions are supported, but Capybara
  # does not try to automatically distinguish between them. The
  # following statements are equivalent:
  #
  #     page.all(:css, 'a#person_123')
  #     page.all(:xpath, './/a[@id="person_123"]')
  #
  # If the type of selector is left out, Capybara uses
  # {Capybara.configure default_selector}. It's set to `:css` by default.
  #
  #     page.all("a#person_123")
  #
  #     Capybara.default_selector = :xpath
  #     page.all('.//a[@id="person_123"]')
  #
  # The set of found elements can further be restricted by specifying
  # options. It's possible to select elements by their text or visibility:
  #
  #     page.all('a', text: 'Home')
  #     page.all('#menu li', visible: true)
  #
  # By default Capybara's waiting behavior will wait up to {Capybara.configure default_max_wait_time}
  # seconds for matching elements to be available and then return an empty result if none
  # are available. It is possible to set expectations on the number of results located and
  # Capybara will raise an exception if the number of elements located don't satisfy the
  # specified conditions. The expectations can be set using:
  #
  #     page.assert_selector('p#foo', count: 4)
  #     page.assert_selector('p#foo', maximum: 10)
  #     page.assert_selector('p#foo', minimum: 1)
  #     page.assert_selector('p#foo', between: 1..10)
  #
  # If the driver is capable of executing JavaScript, this method will wait for a set amount of time
  # and continuously retry finding the element until either the element is found or the time
  # expires. The length of time this method will wait is controlled through {Capybara.configure default_max_wait_time}.
  #
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @overload all
  # @overload all
  # @param kind [Symbol] Optional selector type (:css, :xpath, :field, etc.). Defaults to {Capybara.configure default_selector}.
  # @param locator [String] The locator for the specified selector
  # @param options [Hash] a customizable set of options
  # @raise [Capybara::ExpectationNotMet] The number of elements found doesn't match the specified conditions
  # @return [Capybara::Result] A collection of found elements
  def find_all(*args, allow_reload: T.unsafe(nil), **options, &optional_filter_block); end

  # Find a button on the page.
  # This can be any `<input>` element of type submit, reset, image, button or it can be a
  # `<button>` element. All buttons can be found by their id, name, {Capybara.configure test_id} attribute, value, or title.
  # `<button>` elements can also be found by their text content, and image `<input>` elements by their alt attribute.
  #
  # @overload find_button
  # @return [Capybara::Node::Element] The found element
  def find_button(locator = T.unsafe(nil), **options, &optional_filter_block); end

  # Find a element on the page, given its id.
  #
  # If the driver is capable of executing JavaScript, this method will wait for a set amount of time
  # and continuously retry finding the element until either the element is found or the time
  # expires. The length of time this method will wait is controlled through {Capybara.configure default_max_wait_time}.
  #
  # @option options
  # @param id [String] id of element
  # @param options [Hash] a customizable set of options
  # @return [Capybara::Node::Element] The found element
  def find_by_id(id, **options, &optional_filter_block); end

  # Find a form field on the page. The field can be found by its name, id or label text.
  #
  # @overload find_field
  # @return [Capybara::Node::Element] The found element
  def find_field(locator = T.unsafe(nil), **options, &optional_filter_block); end

  # Find a link on the page. The link can be found by its id or text.
  #
  # @overload find_link
  # @return [Capybara::Node::Element] The found element
  def find_link(locator = T.unsafe(nil), **options, &optional_filter_block); end

  # Find the first element on the page matching the given selector
  # and options. By default {#first} will wait up to {Capybara.configure default_max_wait_time}
  # seconds for matching elements to appear and then raise an error if no matching
  # element is found, or `nil` if the provided count options allow for empty results.
  #
  # @overload first
  # @raise [Capybara::ElementNotFound] If element(s) matching the provided options can't be found before time expires
  # @return [Capybara::Node::Element] The found element or nil
  def first(*args, **options, &optional_filter_block); end

  # Find an {Capybara::Node::Element} based on the given arguments that is also a sibling of the element called on.
  # {#sibling} will raise an error if the element is not found.
  #
  # {#sibling} takes the same options as {#find}.
  #
  #     element.sibling('#foo').find('.bar')
  #     element.sibling(:xpath, './/div[contains(., "bar")]')
  #     element.sibling('ul', text: 'Quox').click_link('Delete')
  #
  # If the driver is capable of executing JavaScript, this method will wait for a set amount of time
  # and continuously retry finding the element until either the element is found or the time
  # expires. The length of time this method will wait is controlled through {Capybara.configure default_max_wait_time}.
  #
  # @option options
  # @param options [Hash] a customizable set of options
  # @param kind [Symbol] Optional selector type (:css, :xpath, :field, etc.). Defaults to {Capybara.configure default_selector}.
  # @param locator [String] The locator for the specified selector
  # @param options [Hash] a customizable set of options
  # @raise [Capybara::ElementNotFound] If the element can't be found before time expires
  # @return [Capybara::Node::Element] The found element
  def sibling(*args, **options, &optional_filter_block); end

  private

  # @return [Boolean]
  def ambiguous?(query, result); end

  # @return [Boolean]
  def options_include_minimum?(opts); end

  def parent; end

  # @return [Boolean]
  def prefer_exact?(query); end

  def synced_resolve(query); end
end

module Capybara::Node::Matchers
  def ==(other); end

  # Asserts that all of the provided selectors are present on the given page
  # or descendants of the current node.  If options are provided, the assertion
  # will check that each locator is present with those options as well (other than `:wait`).
  #
  #     page.assert_all_of_selectors(:custom, 'Tom', 'Joe', visible: all)
  #     page.assert_all_of_selectors(:css, '#my_div', 'a.not_clicked')
  #
  # It accepts all options that {Capybara::Node::Finders#all} accepts,
  # such as `:text` and `:visible`.
  #
  # The `:wait` option applies to all of the selectors as a group, so all of the locators must be present
  # within `:wait` (defaults to {Capybara.configure default_max_wait_time}) seconds.
  #
  # @overload assert_all_of_selectors
  def assert_all_of_selectors(*args, **options, &optional_filter_block); end

  # Asserts that a given selector matches an ancestor of the current node.
  #
  #     element.assert_ancestor('p#foo')
  #
  # Accepts the same options as {#assert_selector}
  #
  # @param options [Hash] a customizable set of options
  # @param kind [Symbol] Optional selector type (:css, :xpath, :field, etc.). Defaults to {Capybara.configure default_selector}.
  # @param locator [String] The locator for the specified selector
  # @param options [Hash] a customizable set of options
  # @raise [Capybara::ExpectationNotMet] If the selector does not exist
  def assert_ancestor(*args, &optional_filter_block); end

  # Asserts that any of the provided selectors are present on the given page
  # or descendants of the current node. If options are provided, the assertion
  # will check that each locator is present with those options as well (other than `:wait`).
  #
  #     page.assert_any_of_selectors(:custom, 'Tom', 'Joe', visible: all)
  #     page.assert_any_of_selectors(:css, '#my_div', 'a.not_clicked')
  #
  # It accepts all options that {Capybara::Node::Finders#all} accepts,
  # such as `:text` and `:visible`.
  #
  # The `:wait` option applies to all of the selectors as a group, so any of the locators must be present
  # within `:wait` (defaults to {Capybara.configure default_max_wait_time}) seconds.
  #
  # @overload assert_any_of_selectors
  def assert_any_of_selectors(*args, wait: T.unsafe(nil), **options, &optional_filter_block); end

  # Asserts that the current node matches a given selector.
  #
  #     node.assert_matches_selector('p#foo')
  #     node.assert_matches_selector(:xpath, '//p[@id="foo"]')
  #     node.assert_matches_selector(:foo)
  #
  # It also accepts all options that {Capybara::Node::Finders#all} accepts,
  # such as `:text` and `:visible`.
  #
  #     node.assert_matches_selector('li', text: 'Horse', visible: true)
  #
  # @param kind [Symbol] Optional selector type (:css, :xpath, :field, etc.). Defaults to {Capybara.configure default_selector}.
  # @param locator [String] The locator for the specified selector
  # @param options [Hash] a customizable set of options
  # @raise [Capybara::ExpectationNotMet] If the selector does not match
  def assert_matches_selector(*args, &optional_filter_block); end

  # Asserts that an element has the specified CSS styles.
  #
  #     element.assert_matches_style( 'color' => 'rgb(0,0,255)', 'font-size' => /px/ )
  #
  # @param styles [Hash]
  # @raise [Capybara::ExpectationNotMet] If the element doesn't have the specified styles
  def assert_matches_style(styles = T.unsafe(nil), **options); end

  def assert_no_ancestor(*args, &optional_filter_block); end

  # Asserts that a given selector is not on the page or a descendant of the current node.
  # Usage is identical to {#assert_selector}.
  #
  # Query options such as `:count`, `:minimum`, `:maximum`, and `:between` are
  # considered to be an integral part of the selector. This will return
  # `true`, for example, if a page contains 4 anchors but the query expects 5:
  #
  #     page.assert_no_selector('a', minimum: 1) # Found, raises Capybara::ExpectationNotMet
  #     page.assert_no_selector('a', count: 4)   # Found, raises Capybara::ExpectationNotMet
  #     page.assert_no_selector('a', count: 5)   # Not Found, returns true
  #
  # @param kind [Symbol] Optional selector type (:css, :xpath, :field, etc.). Defaults to {Capybara.configure default_selector}.
  # @param locator [String] The locator for the specified selector
  # @param options [Hash] a customizable set of options
  # @raise [Capybara::ExpectationNotMet] If the selector exists
  def assert_no_selector(*args, &optional_filter_block); end

  def assert_no_sibling(*args, &optional_filter_block); end

  # Asserts that the page or current node doesn't have the given text content,
  # ignoring any HTML tags.
  #
  # @overload assert_no_text
  # @overload assert_no_text
  # @raise [Capybara::ExpectationNotMet] if the assertion hasn't succeeded during wait time
  # @return [true]
  def assert_no_text(type_or_text, *args, **opts); end

  # Asserts that none of the provided selectors are present on the given page
  # or descendants of the current node. If options are provided, the assertion
  # will check that each locator is not present with those options as well (other than `:wait`).
  #
  #     page.assert_none_of_selectors(:custom, 'Tom', 'Joe', visible: all)
  #     page.assert_none_of_selectors(:css, '#my_div', 'a.not_clicked')
  #
  # It accepts all options that {Capybara::Node::Finders#all} accepts,
  # such as `:text` and `:visible`.
  #
  # The `:wait` option applies to all of the selectors as a group, so none of the locators must be present
  # within `:wait` (defaults to {Capybara.configure default_max_wait_time}) seconds.
  #
  # @overload assert_none_of_selectors
  def assert_none_of_selectors(*args, **options, &optional_filter_block); end

  # Asserts that the current node does not match a given selector.
  # Usage is identical to {#assert_matches_selector}.
  #
  # @param kind [Symbol] Optional selector type (:css, :xpath, :field, etc.). Defaults to {Capybara.configure default_selector}.
  # @param locator [String] The locator for the specified selector
  # @param options [Hash] a customizable set of options
  # @raise [Capybara::ExpectationNotMet] If the selector matches
  def assert_not_matches_selector(*args, &optional_filter_block); end

  # Asserts that a given selector is on the page or a descendant of the current node.
  #
  #     page.assert_selector('p#foo')
  #     page.assert_selector(:xpath, './/p[@id="foo"]')
  #     page.assert_selector(:foo)
  #
  # By default it will check if the expression occurs at least once,
  # but a different number can be specified.
  #
  #     page.assert_selector('p#foo', count: 4)
  #
  # This will check if the expression occurs exactly 4 times. See
  # {Capybara::Node::Finders#all} for other available result size options.
  #
  # If a `:count` of 0 is specified, it will behave like {#assert_no_selector};
  # however, use of that method is preferred over this one.
  #
  # It also accepts all options that {Capybara::Node::Finders#all} accepts,
  # such as `:text` and `:visible`.
  #
  #     page.assert_selector('li', text: 'Horse', visible: true)
  #
  # {#assert_selector} can also accept XPath expressions generated by the
  # XPath gem:
  #
  #     page.assert_selector(:xpath, XPath.descendant(:p))
  #
  # @option options
  # @param kind [Symbol] Optional selector type (:css, :xpath, :field, etc.). Defaults to {Capybara.configure default_selector}.
  # @param locator [String] The locator for the specified selector
  # @param options [Hash] a customizable set of options
  # @raise [Capybara::ExpectationNotMet] If the selector does not exist
  def assert_selector(*args, &optional_filter_block); end

  # Asserts that a given selector matches a sibling of the current node.
  #
  #     element.assert_sibling('p#foo')
  #
  # Accepts the same options as {#assert_selector}
  #
  # @param options [Hash] a customizable set of options
  # @param kind [Symbol] Optional selector type (:css, :xpath, :field, etc.). Defaults to {Capybara.configure default_selector}.
  # @param locator [String] The locator for the specified selector
  # @param options [Hash] a customizable set of options
  # @raise [Capybara::ExpectationNotMet] If the selector does not exist
  def assert_sibling(*args, &optional_filter_block); end

  # @deprecated Use {#assert_matches_style} instead.
  def assert_style(styles = T.unsafe(nil), **options); end

  # Asserts that the page or current node has the given text content,
  # ignoring any HTML tags.
  #
  # @overload assert_text
  # @overload assert_text
  # @raise [Capybara::ExpectationNotMet] if the assertion hasn't succeeded during wait time
  # @return [true]
  def assert_text(type_or_text, *args, **opts); end

  # Predicate version of {#assert_ancestor}
  #
  # @return [Boolean]
  def has_ancestor?(*args, **options, &optional_filter_block); end

  # Checks if the page or current node has a button with the given
  # text, value or id.
  #
  # @param locator [String] The text, value or id of a button to check for
  # @return [Boolean] Whether it exists
  def has_button?(locator = T.unsafe(nil), **options, &optional_filter_block); end

  # Checks if the page or current node has a radio button or
  # checkbox with the given label, value, id, or {Capybara.configure test_id} attribute that is currently
  # checked.
  #
  # @param locator [String] The label, name or id of a checked field
  # @return [Boolean] Whether it exists
  def has_checked_field?(locator = T.unsafe(nil), **options, &optional_filter_block); end

  # Checks if the page or current node has the given text content,
  # ignoring any HTML tags.
  #
  # By default it will check if the text occurs at least once,
  # but a different number can be specified.
  #
  #     page.has_text?('lorem ipsum', between: 2..4)
  #
  # This will check if the text occurs from 2 to 4 times.
  #
  # @overload has_text?
  # @overload has_text?
  # @return [Boolean] Whether it exists
  def has_content?(*args, **options); end

  # Checks if a given CSS selector is on the page or a descendant of the current node.
  #
  #     page.has_css?('p#foo')
  #
  # By default it will check if the selector occurs at least once,
  # but a different number can be specified.
  #
  #     page.has_css?('p#foo', count: 4)
  #
  # This will check if the selector occurs exactly 4 times.
  #
  # It also accepts all options that {Capybara::Node::Finders#all} accepts,
  # such as `:text` and `:visible`.
  #
  #     page.has_css?('li', text: 'Horse', visible: true)
  #
  # @option options
  # @param path [String] A CSS selector
  # @param options [Hash] a customizable set of options
  # @return [Boolean] If the selector exists
  def has_css?(path, **options, &optional_filter_block); end

  # Checks if the page or current node has a form field with the given
  # label, name or id.
  #
  # For text fields and other textual fields, such as textareas and
  # HTML5 email/url/etc. fields, it's possible to specify a `:with`
  # option to specify the text the field should contain:
  #
  #     page.has_field?('Name', with: 'Jonas')
  #
  # It is also possible to filter by the field type attribute:
  #
  #     page.has_field?('Email', type: 'email')
  #
  # NOTE: 'textarea' and 'select' are valid type values, matching the associated tag names.
  #
  # @option options
  # @option options
  # @param locator [String] The label, name or id of a field to check for
  # @param options [Hash] a customizable set of options
  # @return [Boolean] Whether it exists
  def has_field?(locator = T.unsafe(nil), **options, &optional_filter_block); end

  # Checks if the page or current node has a link with the given
  # text or id.
  #
  # @option options
  # @param locator [String] The text or id of a link to check for
  # @param options [Hash] a customizable set of options
  # @return [Boolean] Whether it exists
  def has_link?(locator = T.unsafe(nil), **options, &optional_filter_block); end

  # Predicate version of {#assert_no_ancestor}
  #
  # @return [Boolean]
  def has_no_ancestor?(*args, **options, &optional_filter_block); end

  # Checks if the page or current node has no button with the given
  # text, value or id.
  #
  # @param locator [String] The text, value or id of a button to check for
  # @return [Boolean] Whether it doesn't exist
  def has_no_button?(locator = T.unsafe(nil), **options, &optional_filter_block); end

  # Checks if the page or current node has no radio button or
  # checkbox with the given label, value or id, or {Capybara.configure test_id} attribute that is currently
  # checked.
  #
  # @param locator [String] The label, name or id of a checked field
  # @return [Boolean] Whether it doesn't exist
  def has_no_checked_field?(locator = T.unsafe(nil), **options, &optional_filter_block); end

  # Checks if the page or current node does not have the given text
  # content, ignoring any HTML tags and normalizing whitespace.
  #
  # @overload has_no_text?
  # @overload has_no_text?
  # @return [Boolean] Whether it doesn't exist
  def has_no_content?(*args, **options); end

  # Checks if a given CSS selector is not on the page or a descendant of the current node.
  # Usage is identical to {#has_css?}.
  #
  # @param path [String] A CSS selector
  # @param options [Hash] a customizable set of options
  # @return [Boolean]
  def has_no_css?(path, **options, &optional_filter_block); end

  # Checks if the page or current node has no form field with the given
  # label, name or id. See {#has_field?}.
  #
  # @option options
  # @option options
  # @param locator [String] The label, name or id of a field to check for
  # @param options [Hash] a customizable set of options
  # @return [Boolean] Whether it doesn't exist
  def has_no_field?(locator = T.unsafe(nil), **options, &optional_filter_block); end

  # Checks if the page or current node has no link with the given
  # text or id.
  #
  # @param locator [String] The text or id of a link to check for
  # @param options [Hash] a customizable set of options
  # @return [Boolean] Whether it doesn't exist
  def has_no_link?(locator = T.unsafe(nil), **options, &optional_filter_block); end

  # Checks if the page or current node has no select field with the
  # given label, name or id. See {#has_select?}.
  #
  # @param locator [String] The label, name or id of a select box
  # @param options [Hash] a customizable set of options
  # @return [Boolean] Whether it doesn't exist
  def has_no_select?(locator = T.unsafe(nil), **options, &optional_filter_block); end

  # Checks if a given selector is not on the page or a descendant of the current node.
  # Usage is identical to {#has_selector?}.
  #
  # @param kind [Symbol] Optional selector type (:css, :xpath, :field, etc.). Defaults to {Capybara.configure default_selector}.
  # @param locator [String] The locator for the specified selector
  # @param options [Hash] a customizable set of options
  # @return [Boolean]
  def has_no_selector?(*args, **options, &optional_filter_block); end

  # Predicate version of {#assert_no_sibling}
  #
  # @return [Boolean]
  def has_no_sibling?(*args, **options, &optional_filter_block); end

  # Checks if the page or current node has no table with the given id
  # or caption. See {#has_table?}.
  #
  # @param locator [String] The id or caption of a table
  # @param options [Hash] a customizable set of options
  # @return [Boolean] Whether it doesn't exist
  def has_no_table?(locator = T.unsafe(nil), **options, &optional_filter_block); end

  # Checks if the page or current node does not have the given text
  # content, ignoring any HTML tags and normalizing whitespace.
  #
  # @overload has_no_text?
  # @overload has_no_text?
  # @return [Boolean] Whether it doesn't exist
  def has_no_text?(*args, **options); end

  # Checks if the page or current node has no radio button or
  # checkbox with the given label, value or id, or {Capybara.configure test_id} attribute that is currently
  # unchecked.
  #
  # @param locator [String] The label, name or id of an unchecked field
  # @return [Boolean] Whether it doesn't exist
  def has_no_unchecked_field?(locator = T.unsafe(nil), **options, &optional_filter_block); end

  # Checks if a given XPath expression is not on the page or a descendant of the current node.
  # Usage is identical to {#has_xpath?}.
  #
  # @param path [String] An XPath expression
  # @param options [Hash] a customizable set of options
  # @return [Boolean]
  def has_no_xpath?(path, **options, &optional_filter_block); end

  # Checks if the page or current node has a select field with the
  # given label, name or id.
  #
  # It can be specified which option should currently be selected:
  #
  #     page.has_select?('Language', selected: 'German')
  #
  # For multiple select boxes, several options may be specified:
  #
  #     page.has_select?('Language', selected: ['English', 'German'])
  #
  # It's also possible to check if the exact set of options exists for
  # this select box:
  #
  #     page.has_select?('Language', options: ['English', 'German', 'Spanish'])
  #
  # You can also check for a partial set of options:
  #
  #     page.has_select?('Language', with_options: ['English', 'German'])
  #
  # @option options
  # @option options
  # @option options
  # @option options
  # @param locator [String] The label, name or id of a select box
  # @param options [Hash] a customizable set of options
  # @return [Boolean] Whether it exists
  def has_select?(locator = T.unsafe(nil), **options, &optional_filter_block); end

  # Checks if a given selector is on the page or a descendant of the current node.
  #
  #     page.has_selector?('p#foo')
  #     page.has_selector?(:xpath, './/p[@id="foo"]')
  #     page.has_selector?(:foo)
  #
  # By default it will check if the expression occurs at least once,
  # but a different number can be specified.
  #
  #     page.has_selector?('p.foo', count: 4)
  #
  # This will check if the expression occurs exactly 4 times.
  #
  # It also accepts all options that {Capybara::Node::Finders#all} accepts,
  # such as `:text` and `:visible`.
  #
  #     page.has_selector?('li', text: 'Horse', visible: true)
  #
  # {#has_selector?} can also accept XPath expressions generated by the
  # XPath gem:
  #
  #     page.has_selector?(:xpath, XPath.descendant(:p))
  #
  # @option options
  # @option options
  # @option options
  # @option options
  # @param kind [Symbol] Optional selector type (:css, :xpath, :field, etc.). Defaults to {Capybara.configure default_selector}.
  # @param locator [String] The locator for the specified selector
  # @param options [Hash] a customizable set of options
  # @return [Boolean] If the expression exists
  def has_selector?(*args, **options, &optional_filter_block); end

  # Predicate version of {#assert_sibling}
  #
  # @return [Boolean]
  def has_sibling?(*args, **options, &optional_filter_block); end

  # @deprecated Use {#matches_style?} instead.
  # @return [Boolean]
  def has_style?(styles = T.unsafe(nil), **options); end

  # Checks if the page or current node has a table with the given id
  # or caption:
  #
  #    page.has_table?('People')
  #
  # @option options
  # @option options
  # @option options
  # @option options
  # @param locator [String] The id or caption of a table
  # @param options [Hash] a customizable set of options
  # @return [Boolean] Whether it exists
  def has_table?(locator = T.unsafe(nil), **options, &optional_filter_block); end

  # Checks if the page or current node has the given text content,
  # ignoring any HTML tags.
  #
  # By default it will check if the text occurs at least once,
  # but a different number can be specified.
  #
  #     page.has_text?('lorem ipsum', between: 2..4)
  #
  # This will check if the text occurs from 2 to 4 times.
  #
  # @overload has_text?
  # @overload has_text?
  # @return [Boolean] Whether it exists
  def has_text?(*args, **options); end

  # Checks if the page or current node has a radio button or
  # checkbox with the given label, value or id, or {Capybara.configure test_id} attribute that is currently
  # unchecked.
  #
  # @param locator [String] The label, name or id of an unchecked field
  # @return [Boolean] Whether it exists
  def has_unchecked_field?(locator = T.unsafe(nil), **options, &optional_filter_block); end

  # Checks if a given XPath expression is on the page or a descendant of the current node.
  #
  #     page.has_xpath?('.//p[@id="foo"]')
  #
  # By default it will check if the expression occurs at least once,
  # but a different number can be specified.
  #
  #     page.has_xpath?('.//p[@id="foo"]', count: 4)
  #
  # This will check if the expression occurs exactly 4 times.
  #
  # It also accepts all options that {Capybara::Node::Finders#all} accepts,
  # such as `:text` and `:visible`.
  #
  #     page.has_xpath?('.//li', text: 'Horse', visible: true)
  #
  # {#has_xpath?} can also accept XPath expressions generated by the
  # XPath gem:
  #
  #     xpath = XPath.generate { |x| x.descendant(:p) }
  #     page.has_xpath?(xpath)
  #
  # @option options
  # @param path [String] An XPath expression
  # @param options [Hash] a customizable set of options
  # @return [Boolean] If the expression exists
  def has_xpath?(path, **options, &optional_filter_block); end

  # Checks if the current node matches given CSS selector.
  #
  # @param css [String] The CSS selector to match against the current code
  # @return [Boolean]
  def matches_css?(css, **options, &optional_filter_block); end

  # Checks if the current node matches given selector.
  #
  # @param kind [Symbol] Optional selector type (:css, :xpath, :field, etc.). Defaults to {Capybara.configure default_selector}.
  # @param locator [String] The locator for the specified selector
  # @param options [Hash] a customizable set of options
  # @return [Boolean]
  def matches_selector?(*args, **options, &optional_filter_block); end

  # Checks if a an element has the specified CSS styles.
  #
  #     element.matches_style?( 'color' => 'rgb(0,0,255)', 'font-size' => /px/ )
  #
  # @param styles [Hash]
  # @return [Boolean] If the styles match
  def matches_style?(styles = T.unsafe(nil), **options); end

  # Checks if the current node matches given XPath expression.
  #
  # @param xpath [String, XPath::Expression] The XPath expression to match against the current code
  # @return [Boolean]
  def matches_xpath?(xpath, **options, &optional_filter_block); end

  # Checks if the current node does not match given CSS selector.
  #
  # @param css [String] The CSS selector to match against the current code
  # @return [Boolean]
  def not_matches_css?(css, **options, &optional_filter_block); end

  # Checks if the current node does not match given selector.
  # Usage is identical to {#has_selector?}.
  #
  # @param kind [Symbol] Optional selector type (:css, :xpath, :field, etc.). Defaults to {Capybara.configure default_selector}.
  # @param locator [String] The locator for the specified selector
  # @param options [Hash] a customizable set of options
  # @return [Boolean]
  def not_matches_selector?(*args, **options, &optional_filter_block); end

  # Checks if the current node does not match given XPath expression.
  #
  # @param xpath [String, XPath::Expression] The XPath expression to match against the current code
  # @return [Boolean]
  def not_matches_xpath?(xpath, **options, &optional_filter_block); end

  private

  def _set_query_session_options(*query_args); end
  def _verify_match_result(query_args, optional_filter_block); end
  def _verify_multiple(*args, wait: T.unsafe(nil), **options); end
  def _verify_selector_result(query_args, optional_filter_block, query_type = T.unsafe(nil)); end
  def _verify_text(type = T.unsafe(nil), expected_text, **query_options); end
  def extract_selector(args); end
  def make_predicate(options); end
end

# A {Capybara::Node::Simple} is a simpler version of {Capybara::Node::Base} which
# includes only {Capybara::Node::Finders} and {Capybara::Node::Matchers} and does
# not include {Capybara::Node::Actions}. This type of node is returned when
# using {Capybara.string}.
#
# It is useful in that it does not require a session, an application or a driver,
# but can still use Capybara's finders and matchers on any string that contains HTML.
class Capybara::Node::Simple
  include ::Capybara::Node::Finders
  include ::Capybara::Node::Matchers
  include ::Capybara::Node::DocumentMatchers

  # @return [Simple] a new instance of Simple
  def initialize(native); end

  # Retrieve the given attribute
  #
  #     element[:title] # => HTML title attribute
  #
  # @param name [Symbol] The attribute name to retrieve
  # @return [String] The value of the attribute
  def [](name); end

  def allow_reload!(*_arg0); end

  # Whether or not the element is checked.
  #
  # @return [Boolean] Whether the element is checked
  def checked?; end

  # Whether or not the element is disabled.
  #
  # @return [Boolean] Whether the element is disabled
  def disabled?; end

  # @api private
  def find_css(css, **_options); end

  # @api private
  def find_xpath(xpath, **_options); end

  # @api private
  def initial_cache; end

  def inspect; end

  # @return [Boolean]
  def multiple?; end

  # Returns the value of attribute native.
  def native; end

  # An XPath expression describing where on the page the element can be found
  #
  # @return [String] An XPath expression
  def path; end

  # @return [Boolean]
  def readonly?; end

  # Whether or not the element is selected.
  #
  # @return [Boolean] Whether the element is selected
  def selected?; end

  # @api private
  def session_options; end

  def synchronize(_seconds = T.unsafe(nil)); end

  # @return [String] The tag name of the element
  def tag_name; end

  # @return [String] The text of the element
  def text(_type = T.unsafe(nil), normalize_ws: T.unsafe(nil)); end

  # @return [String] The title of the document
  def title; end

  # @return [String] The value of the form element
  def value; end

  # Whether or not the element is visible. Does not support CSS, so
  # the result may be inaccurate.
  #
  # @param check_ancestors [Boolean] Whether to inherit visibility from ancestors
  # @return [Boolean] Whether the element is visible
  def visible?(check_ancestors = T.unsafe(nil)); end

  private

  def option_value(option); end
end

Capybara::Node::Simple::VISIBILITY_XPATH = T.let(T.unsafe(nil), String)
class Capybara::NotSupportedByDriverError < ::Capybara::CapybaraError; end

# @api private
module Capybara::Queries; end

class Capybara::Queries::AncestorQuery < ::Capybara::Queries::SelectorQuery
  def description(applied = T.unsafe(nil)); end

  # @api private
  def resolve_for(node, exact = T.unsafe(nil)); end
end

# @api private
class Capybara::Queries::BaseQuery
  # @api private
  # @return [BaseQuery] a new instance of BaseQuery
  def initialize(options); end

  # Checks if a count of 0 is valid for the query
  # Returns false if query does not have any count options specified.
  #
  # @api private
  # @return [Boolean]
  def expects_none?; end

  # Generates a failure message from the query description and count options.
  #
  # @api private
  def failure_message; end

  # Checks if the given count matches the query count options.
  # Defaults to true if no count options are specified. If multiple
  # count options exist, it tests that all conditions are met;
  # however, if :count is specified, all other options are ignored.
  #
  # @api private
  # @param count [Integer] The actual number. Should be coercible via Integer()
  # @return [Boolean]
  def matches_count?(count); end

  # @api private
  def negative_failure_message; end

  # @api private
  def options; end

  # @api private
  def session_options; end

  # @api private
  def session_options=(_arg0); end

  # @api private
  def wait; end

  private

  # @api private
  # @raise [ArgumentError]
  def assert_valid_keys; end

  # @api private
  def count_message; end

  # @api private
  # @return [Boolean]
  def count_specified?; end

  # @api private
  def occurrences(count); end

  class << self
    # @api private
    def wait(options, default = T.unsafe(nil)); end
  end
end

# @api private
Capybara::Queries::BaseQuery::COUNT_KEYS = T.let(T.unsafe(nil), Array)

# @api private
class Capybara::Queries::CurrentPathQuery < ::Capybara::Queries::BaseQuery
  # @api private
  # @return [CurrentPathQuery] a new instance of CurrentPathQuery
  def initialize(expected_path, **options, &optional_filter_block); end

  # @api private
  def failure_message; end

  # @api private
  def negative_failure_message; end

  # @api private
  # @return [Boolean]
  def resolves_for?(session); end

  private

  # @api private
  def failure_message_helper(negated = T.unsafe(nil)); end

  # @api private
  # @return [Boolean]
  def matches_filter_block?(url); end

  # @api private
  def valid_keys; end
end

# @api private
class Capybara::Queries::MatchQuery < ::Capybara::Queries::SelectorQuery
  # @api private
  def visible; end

  private

  # @api private
  def assert_valid_keys; end

  # @api private
  def valid_keys; end
end

# @api private
class Capybara::Queries::SelectorQuery < ::Capybara::Queries::BaseQuery
  # @api private
  # @raise [ArgumentError]
  # @return [SelectorQuery] a new instance of SelectorQuery
  def initialize(*args, session_options:, enable_aria_label: T.unsafe(nil), enable_aria_role: T.unsafe(nil), test_id: T.unsafe(nil), selector_format: T.unsafe(nil), order: T.unsafe(nil), **options, &filter_block); end

  # @api private
  def applied_description; end

  # @api private
  def css; end

  # @api private
  def description(only_applied = T.unsafe(nil)); end

  # @api private
  # @return [Boolean]
  def exact?; end

  # @api private
  def expression; end

  # @api private
  def failure_message; end

  # @api private
  def label; end

  # @api private
  def locator; end

  # @api private
  def match; end

  # @api private
  # @return [Boolean]
  def matches_filters?(node, node_filter_errors = T.unsafe(nil)); end

  # @api private
  def name; end

  # @api private
  def negative_failure_message; end

  # @api private
  def options; end

  # @api private
  def resolve_for(node, exact = T.unsafe(nil)); end

  # @api private
  def selector; end

  # @api private
  # @return [Boolean]
  def supports_exact?; end

  # @api private
  def visible; end

  # @api private
  def xpath(exact = T.unsafe(nil)); end

  private

  # @api private
  def applied_filters; end

  # @api private
  def apply_expression_filters(expression); end

  # @api private
  # @return [Boolean]
  def apply_filter?(filter); end

  # @api private
  # @raise [ArgumentError]
  def assert_valid_keys; end

  # @api private
  def builder(expr); end

  # @api private
  def custom_keys; end

  # @api private
  def default_visibility; end

  # @api private
  # @return [Boolean]
  def describe_within?; end

  # @api private
  # @return [Boolean]
  def document?(node); end

  # @api private
  def exact_text; end

  # @api private
  def expression_filters; end

  # @api private
  def filter_set(name); end

  # @api private
  def filtered_expression(expr); end

  # @api private
  def find_nodes_by_selector_format(node, exact); end

  # @api private
  def find_selector(locator); end

  # @api private
  # @return [Boolean]
  def first_try?; end

  # @api private
  # @return [Boolean]
  def matches_class_filter?(node); end

  # @api private
  # @return [Boolean]
  def matches_exact_text_filter?(node); end

  # @api private
  # @return [Boolean]
  def matches_filter_block?(node); end

  # @api private
  # @return [Boolean]
  def matches_id_filter?(node); end

  # @api private
  # @return [Boolean]
  def matches_locator_filter?(node); end

  # @api private
  # @return [Boolean]
  def matches_node_filters?(node, errors); end

  # @api private
  # @return [Boolean]
  def matches_spatial_filters?(node); end

  # @api private
  # @return [Boolean]
  def matches_style?(node, styles); end

  # @api private
  # @return [Boolean]
  def matches_style_filter?(node); end

  # @api private
  # @return [Boolean]
  def matches_system_filters?(node); end

  # @api private
  # @return [Boolean]
  def matches_text_exactly?(node, value); end

  # @api private
  # @return [Boolean]
  def matches_text_filter?(node); end

  # @api private
  # @return [Boolean]
  def matches_text_regexp?(node, regexp); end

  # @api private
  # @return [Boolean]
  def matches_visibility_filters?(node); end

  # @api private
  def matching_text; end

  # @api private
  # @return [Boolean]
  def need_to_process_classes?; end

  # @api private
  def node_filters; end

  # @api private
  def normalize_ws; end

  # @api private
  def ordered_results(results); end

  # @api private
  def position_cache(key); end

  # @api private
  def rect_cache(key); end

  # @api private
  def selector_format; end

  # @api private
  def show_for_stage(only_applied); end

  # @api private
  # @return [Boolean]
  def simple_root?(node); end

  # @api private
  def text_fragments; end

  # @api private
  def to_element(node); end

  # @api private
  # @return [Boolean]
  def try_text_match_in_expression?; end

  # @api private
  # @return [Boolean]
  def use_default_class_filter?; end

  # @api private
  # @return [Boolean]
  def use_default_id_filter?; end

  # @api private
  # @return [Boolean]
  def use_default_style_filter?; end

  # @api private
  # @return [Boolean]
  def use_spatial_filter?; end

  # @api private
  def valid_keys; end

  # @api private
  def warn_exact_usage; end

  # @api private
  def xpath_text_conditions; end
end

# @api private
class Capybara::Queries::SelectorQuery::Rectangle
  # @api private
  # @return [Rectangle] a new instance of Rectangle
  def initialize(position); end

  # @api private
  # @return [Boolean]
  def above?(other); end

  # @api private
  # @return [Boolean]
  def below?(other); end

  # @api private
  def bottom; end

  # @api private
  def distance(other); end

  # @api private
  def left; end

  # @api private
  # @return [Boolean]
  def left_of?(other); end

  # @api private
  # @return [Boolean]
  def near?(other); end

  # @api private
  def right; end

  # @api private
  # @return [Boolean]
  def right_of?(other); end

  # @api private
  def top; end

  protected

  # @api private
  def line_segments; end

  private

  # @api private
  def distance_segment_segment(l1p1, l1p2, l2p1, l2p2); end
end

# @api private
Capybara::Queries::SelectorQuery::SPATIAL_KEYS = T.let(T.unsafe(nil), Array)

# @api private
Capybara::Queries::SelectorQuery::VALID_KEYS = T.let(T.unsafe(nil), Array)

# @api private
Capybara::Queries::SelectorQuery::VALID_MATCH = T.let(T.unsafe(nil), Array)

# @api private
class Capybara::Queries::SiblingQuery < ::Capybara::Queries::SelectorQuery
  # @api private
  def description(applied = T.unsafe(nil)); end

  # @api private
  def resolve_for(node, exact = T.unsafe(nil)); end
end

# @api private
class Capybara::Queries::StyleQuery < ::Capybara::Queries::BaseQuery
  # @api private
  # @return [StyleQuery] a new instance of StyleQuery
  def initialize(expected_styles, session_options:, **options); end

  # @api private
  def failure_message; end

  # @api private
  # @return [Boolean]
  def resolves_for?(node); end

  private

  # @api private
  def stringify_keys(hsh); end

  # @api private
  def valid_keys; end
end

# @api private
class Capybara::Queries::TextQuery < ::Capybara::Queries::BaseQuery
  # @api private
  # @raise [ArgumentError]
  # @return [TextQuery] a new instance of TextQuery
  def initialize(type = T.unsafe(nil), expected_text, session_options:, **options); end

  # @api private
  def description; end

  # @api private
  def failure_message; end

  # @api private
  def negative_failure_message; end

  # @api private
  def resolve_for(node); end

  private

  # @api private
  def build_message(report_on_invisible); end

  # @api private
  def case_insensitive_message; end

  # @api private
  # @return [Boolean]
  def check_case_insensitive?; end

  # @api private
  # @return [Boolean]
  def check_visible_text?; end

  # @api private
  def default_type; end

  # @api private
  # @return [Boolean]
  def exact?; end

  # @api private
  def invisible_message; end

  # @api private
  def text(node: T.unsafe(nil), query_type: T.unsafe(nil)); end

  # @api private
  def valid_keys; end

  # @api private
  def valid_types; end
end

# @api private
class Capybara::Queries::TitleQuery < ::Capybara::Queries::BaseQuery
  # @api private
  # @return [TitleQuery] a new instance of TitleQuery
  def initialize(expected_title, **options); end

  # @api private
  def failure_message; end

  # @api private
  def negative_failure_message; end

  # @api private
  # @return [Boolean]
  def resolves_for?(node); end

  private

  # @api private
  def failure_message_helper(negated = T.unsafe(nil)); end

  # @api private
  def valid_keys; end
end

module Capybara::RackTest; end

class Capybara::RackTest::Browser
  include ::Rack::Test::Methods

  # @return [Browser] a new instance of Browser
  def initialize(driver); end

  def app; end
  def build_uri(path); end

  # Returns the value of attribute current_host.
  def current_host; end

  # Sets the attribute current_host
  #
  # @param value the value to set the attribute current_host to.
  def current_host=(_arg0); end

  def current_url; end
  def dom; end

  # Returns the value of attribute driver.
  def driver; end

  def find(format, selector); end
  def follow(method, path, **attributes); end
  def html; end
  def options; end
  def process(method, path, attributes = T.unsafe(nil), env = T.unsafe(nil)); end
  def process_and_follow_redirects(method, path, attributes = T.unsafe(nil), env = T.unsafe(nil)); end
  def refresh; end
  def reset_cache!; end
  def reset_host!; end
  def submit(method, path, attributes); end
  def title; end
  def visit(path, **attributes); end

  protected

  def build_rack_mock_session; end
  def request_path; end

  private

  # @return [Boolean]
  def fragment_or_script?(path); end
end

class Capybara::RackTest::CSSHandlers < ::BasicObject
  include ::Kernel
  include ::ActiveSupport::ForkTracker::CoreExt
  include ::ActiveSupport::ForkTracker::CoreExtPrivate

  def disabled(list); end
  def enabled(list); end
end

class Capybara::RackTest::Driver < ::Capybara::Driver::Base
  # @raise [ArgumentError]
  # @return [Driver] a new instance of Driver
  def initialize(app, **options); end

  # Returns the value of attribute app.
  def app; end

  def browser; end
  def current_url; end
  def delete(*args, &block); end
  def dom; end
  def find_css(selector); end
  def find_xpath(selector); end
  def follow(method, path, **attributes); end

  # @return [Boolean]
  def follow_redirects?; end

  def get(*args, &block); end
  def header(key, value); end
  def html; end
  def invalid_element_errors; end

  # Returns the value of attribute options.
  def options; end

  def post(*args, &block); end
  def put(*args, &block); end
  def redirect_limit; end
  def refresh; end
  def request; end
  def reset!; end
  def response; end
  def response_headers; end
  def status_code; end
  def submit(method, path, attributes); end
  def title; end
  def visit(path, **attributes); end
end

Capybara::RackTest::Driver::DEFAULT_OPTIONS = T.let(T.unsafe(nil), Hash)
module Capybara::RackTest::Errors; end
class Capybara::RackTest::Errors::StaleElementReferenceError < ::StandardError; end

class Capybara::RackTest::Form < ::Capybara::RackTest::Node
  # @return [Boolean]
  def multipart?; end

  def params(button); end
  def submit(button); end

  private

  def add_input_param(field, params); end
  def add_select_param(field, params); end
  def add_textarea_param(field, params); end
  def file_to_upload(filename); end
  def make_params; end
  def merge_param!(params, key, value); end
  def request_method; end

  # @return [Boolean]
  def submitter?(el); end
end

# This only needs to inherit from Rack::Test::UploadedFile because Rack::Test checks for
# the class specifically when determining whether to construct the request as multipart.
# That check should be based solely on the form element's 'enctype' attribute value,
# which should probably be provided to Rack::Test in its non-GET request methods.
class Capybara::RackTest::Form::NilUploadedFile < ::Rack::Test::UploadedFile
  # @return [NilUploadedFile] a new instance of NilUploadedFile
  def initialize; end

  def content_type; end
  def original_filename; end
  def path; end
  def read; end
  def size; end
end

class Capybara::RackTest::Form::ParamsHash < ::Hash
  def to_params_hash; end
end

class Capybara::RackTest::Node < ::Capybara::Driver::Node
  def ==(other); end
  def [](*_arg0, &_arg1); end
  def all_text(*_arg0, &_arg1); end

  # @return [Boolean]
  def checked?(*_arg0, &_arg1); end

  # @raise [ArgumentError]
  def click(*_arg0, &_arg1); end

  # @return [Boolean]
  def disabled?(*_arg0, &_arg1); end

  def find_css(*_arg0, &_arg1); end
  def find_xpath(*_arg0, &_arg1); end
  def path(*_arg0, &_arg1); end
  def select_option(*_arg0, &_arg1); end

  # @return [Boolean]
  def selected?(*_arg0, &_arg1); end

  def set(*_arg0, &_arg1); end

  # @raise [NotImplementedError]
  def style(*_arg0, &_arg1); end

  def tag_name(*_arg0, &_arg1); end

  # @raise [Capybara::UnselectNotAllowed]
  def unselect_option(*_arg0, &_arg1); end

  def value(*_arg0, &_arg1); end

  # @return [Boolean]
  def visible?(*_arg0, &_arg1); end

  def visible_text(*_arg0, &_arg1); end

  protected

  # @return [Boolean]
  def checkbox?; end

  # @return [Boolean]
  def checkbox_or_radio?(field = T.unsafe(nil)); end

  # @api private
  def displayed_text(check_ancestor: T.unsafe(nil)); end

  # @return [Boolean]
  def input_field?; end

  # @return [Boolean]
  def radio?; end

  # @return [Boolean]
  def range?; end

  # @return [Boolean]
  def text_or_password?; end

  # @return [Boolean]
  def textarea?; end

  private

  # @return [Boolean]
  def attribute_is_not_blank?(attribute); end

  # @return [Boolean]
  def checkable?; end

  def click_label; end
  def deselect_options; end
  def follow_link; end
  def form; end

  # @return [Boolean]
  def link?; end

  # a reference to the select node if this is an option node
  def select_node; end

  def set_checkbox(value); end
  def set_input(value); end
  def set_radio(_value); end
  def set_range(value); end

  # @raise [Capybara::RackTest::Errors::StaleElementReferenceError]
  def stale_check; end

  def string_node; end

  # @return [Boolean]
  def submits?; end

  def toggle_details(details = T.unsafe(nil)); end
  def type; end
  def unchecked_all_text; end
  def unchecked_checked?; end
  def unchecked_click(keys = T.unsafe(nil), **options); end
  def unchecked_disabled?; end
  def unchecked_find_css(locator, **_hints); end
  def unchecked_find_xpath(locator, **_hints); end
  def unchecked_path; end
  def unchecked_select_option; end
  def unchecked_selected?; end
  def unchecked_set(value, **options); end
  def unchecked_style(_styles); end
  def unchecked_tag_name; end
  def unchecked_unselect_option; end
  def unchecked_value; end
  def unchecked_visible?; end
  def unchecked_visible_text; end
end

Capybara::RackTest::Node::BLOCK_ELEMENTS = T.let(T.unsafe(nil), Array)
Capybara::RackTest::Node::DISABLED_BY_FIELDSET_XPATH = T.let(T.unsafe(nil), String)
Capybara::RackTest::Node::OPTION_OWNER_XPATH = T.let(T.unsafe(nil), String)
class Capybara::ReadOnlyElementError < ::Capybara::CapybaraError; end

class Capybara::ReadOnlySessionConfig < ::SimpleDelegator
  def always_include_port=(_); end
  def app_host=(_); end
  def asset_host=(_); end
  def automatic_label_click=(_); end
  def automatic_reload=(_); end
  def default_host=(_); end
  def default_max_wait_time=(_); end
  def default_normalize_ws=(_); end
  def default_selector=(_); end
  def default_set_options=(_); end
  def disable_animation=(_); end
  def enable_aria_label=(_); end
  def enable_aria_role=(_); end
  def exact=(_); end
  def exact_text=(_); end
  def ignore_hidden_elements=(_); end
  def match=(_); end
  def predicates_wait=(_); end
  def raise_server_errors=(_); end
  def run_server=(_); end
  def save_path=(_); end
  def server_errors=(_); end
  def server_host=(_); end
  def server_port=(_); end
  def test_id=(_); end
  def visible_text_only=(_); end
  def w3c_click_offset=(_); end
end

# @api private
class Capybara::RegistrationContainer
  # @api private
  # @return [RegistrationContainer] a new instance of RegistrationContainer
  def initialize; end

  # @api private
  def [](name); end

  # @api private
  def []=(name, value); end

  # @api private
  def method_missing(method_name, *args, **options, &block); end

  # @api private
  def names; end

  private

  # @api private
  def register(name, block); end

  # @api private
  # @return [Boolean]
  def respond_to_missing?(method_name, include_all); end
end

# A {Capybara::Result} represents a collection of {Capybara::Node::Element} on the page. It is possible to interact with this
# collection similar to an Array because it implements Enumerable and offers the following Array methods through delegation:
#
# * \[\]
# * each()
# * at()
# * size()
# * count()
# * length()
# * first()
# * last()
# * empty?()
# * values_at()
# * sample()
#
# @see Capybara::Node::Element
class Capybara::Result
  include ::Enumerable
  extend ::Forwardable

  # @return [Result] a new instance of Result
  def initialize(elements, query); end

  def [](*args); end

  # @api private
  def allow_reload!; end

  def at(*args); end
  def compare_count; end
  def each(&block); end

  # @return [Boolean]
  def empty?; end

  def failure_message; end
  def index(*_arg0); end
  def inspect(*args, &block); end
  def last(*args, &block); end
  def length(*args, &block); end

  # @return [Boolean]
  def matches_count?; end

  def negative_failure_message; end
  def sample(*args, &block); end
  def size(*args, &block); end
  def unfiltered_size; end
  def values_at(*args, &block); end

  private

  def add_to_cache(elem); end
  def full_results; end

  # JRuby < 9.2.8.0 has an issue with lazy enumerators which
  # causes a concurrency issue with network requests here
  # https://github.com/jruby/jruby/issues/4212
  # while JRuby >= 9.2.8.0 leaks threads when using lazy enumerators
  # https://github.com/teamcapybara/capybara/issues/2349
  # so disable the use and JRuby users will need to pay a performance penalty
  def lazy_select_elements(&block); end

  def load_up_to(num); end
  def rest; end
end

class Capybara::ScopeError < ::Capybara::CapybaraError; end

# All Selectors below support the listed selector specific filters in addition to the following system-wide filters
#   * :id (String, Regexp, XPath::Expression) - Matches the id attribute
#   * :class (String, Array<String | Regexp>, Regexp, XPath::Expression) - Matches the class(es) provided
#   * :style (String, Regexp, Hash<String, String>) - Match on elements style
#   * :above (Element) - Match elements above the passed element on the page
#   * :below (Element) - Match elements below the passed element on the page
#   * :left_of (Element) - Match elements left of the passed element on the page
#   * :right_of (Element) - Match elements right of the passed element on the page
#   * :near (Element) - Match elements near (within 50px) the passed element on the page
#
# ### Built-in Selectors
#
# * **:xpath** - Select elements by XPath expression
#   * Locator: An XPath expression
#
# * **:css** - Select elements by CSS selector
#   * Locator: A CSS selector
#
# * **:id** - Select element by id
#   * Locator: (String, Regexp, XPath::Expression) The id of the element to match
#
# * **:field** - Select field elements (input [not of type submit, image, or hidden], textarea, select)
#   * Locator: Matches against the id, {Capybara.configure test_id} attribute, name, placeholder, or
#     associated label text
#   * Filters:
#       * :name (String, Regexp) - Matches the name attribute
#       * :placeholder (String, Regexp) - Matches the placeholder attribute
#       * :type (String) - Matches the type attribute of the field or element type for 'textarea' and 'select'
#       * :readonly (Boolean) - Match on the element being readonly
#       * :with (String, Regexp) - Matches the current value of the field
#       * :checked (Boolean) - Match checked fields?
#       * :unchecked (Boolean) - Match unchecked fields?
#       * :disabled (Boolean, :all) - Match disabled field? (Default: false)
#       * :multiple (Boolean) - Match fields that accept multiple values
#       * :valid (Boolean) - Match fields that are valid/invalid according to HTML5 form validation
#       * :validation_message (String, Regexp) - Matches the elements current validationMessage
#
# * **:fieldset** - Select fieldset elements
#   * Locator: Matches id, {Capybara.configure test_id}, or contents of wrapped legend
#   * Filters:
#       * :legend (String) - Matches contents of wrapped legend
#       * :disabled (Boolean) - Match disabled fieldset?
#
# * **:link** - Find links (`<a>` elements with an href attribute)
#   * Locator: Matches the id, {Capybara.configure test_id}, or title attributes, or the string content of the link,
#     or the alt attribute of a contained img element. By default this selector requires a link to have an href attribute.
#   * Filters:
#       * :title (String) - Matches the title attribute
#       * :alt (String) - Matches the alt attribute of a contained img element
#       * :href (String, Regexp, nil, false) - Matches the normalized href of the link, if nil will find `<a>` elements with no href attribute, if false ignores href presence
#
# * **:button** - Find buttons ( input [of type submit, reset, image, button] or button elements )
#   * Locator: Matches the id, {Capybara.configure test_id} attribute, name, value, or title attributes, string content of a button, or the alt attribute of an image type button or of a descendant image of a button
#   * Filters:
#       * :name (String, Regexp) - Matches the name attribute
#       * :title (String) - Matches the title attribute
#       * :value (String) - Matches the value of an input button
#       * :type (String) - Matches the type attribute
#       * :disabled (Boolean, :all) - Match disabled buttons (Default: false)
#
# * **:link_or_button** - Find links or buttons
#   * Locator: See :link and :button selectors
#   * Filters:
#       * :disabled (Boolean, :all) - Match disabled buttons? (Default: false)
#
# * **:fillable_field** - Find text fillable fields ( textarea, input [not of type submit, image, radio, checkbox, hidden, file] )
#   * Locator: Matches against the id, {Capybara.configure test_id} attribute, name, placeholder, or associated label text
#   * Filters:
#       * :name (String, Regexp) - Matches the name attribute
#       * :placeholder (String, Regexp) - Matches the placeholder attribute
#       * :with (String, Regexp) - Matches the current value of the field
#       * :type (String) - Matches the type attribute of the field or element type for 'textarea'
#       * :disabled (Boolean, :all) - Match disabled field? (Default: false)
#       * :multiple (Boolean) - Match fields that accept multiple values
#       * :valid (Boolean) - Match fields that are valid/invalid according to HTML5 form validation
#       * :validation_message (String, Regexp) - Matches the elements current validationMessage
#
# * **:radio_button** - Find radio buttons
#   * Locator: Match id, {Capybara.configure test_id} attribute, name, or associated label text
#   * Filters:
#       * :name (String, Regexp) - Matches the name attribute
#       * :checked (Boolean) - Match checked fields?
#       * :unchecked (Boolean) - Match unchecked fields?
#       * :disabled (Boolean, :all) - Match disabled field? (Default: false)
#       * :option (String, Regexp) - Match the current value
#       * :with - Alias of :option
#
# * **:checkbox** - Find checkboxes
#   * Locator: Match id, {Capybara.configure test_id} attribute, name, or associated label text
#   * Filters:
#       * :name (String, Regexp) - Matches the name attribute
#       * :checked (Boolean) - Match checked fields?
#       * :unchecked (Boolean) - Match unchecked fields?
#       * :disabled (Boolean, :all) - Match disabled field? (Default: false)
#       * :with (String, Regexp) - Match the current value
#       * :option - Alias of :with
#
# * **:select** - Find select elements
#   * Locator: Match id, {Capybara.configure test_id} attribute, name, placeholder, or associated label text
#   * Filters:
#       * :name (String, Regexp) - Matches the name attribute
#       * :placeholder (String, Placeholder) - Matches the placeholder attribute
#       * :disabled (Boolean, :all) - Match disabled field? (Default: false)
#       * :multiple (Boolean) - Match fields that accept multiple values
#       * :options (Array<String>) - Exact match options
#       * :enabled_options (Array<String>) - Exact match enabled options
#       * :disabled_options (Array<String>) - Exact match disabled options
#       * :with_options (Array<String>) - Partial match options
#       * :selected (String, Array<String>) - Match the selection(s)
#       * :with_selected (String, Array<String>) - Partial match the selection(s)
#
# * **:option** - Find option elements
#   * Locator: Match text of option
#   * Filters:
#       * :disabled (Boolean) - Match disabled option
#       * :selected (Boolean) - Match selected option
#
# * **:datalist_input** - Find input field with datalist completion
#   * Locator: Matches against the id, {Capybara.configure test_id} attribute, name,
#     placeholder, or associated label text
#   * Filters:
#       * :name (String, Regexp) - Matches the name attribute
#       * :placeholder (String, Regexp) - Matches the placeholder attribute
#       * :disabled (Boolean, :all) - Match disabled field? (Default: false)
#       * :options (Array<String>) - Exact match options
#       * :with_options (Array<String>) - Partial match options
#
# * **:datalist_option** - Find datalist option
#   * Locator: Match text or value of option
#   * Filters:
#       * :disabled (Boolean) - Match disabled option
#
# * **:file_field** - Find file input elements
#   * Locator: Match id, {Capybara.configure test_id} attribute, name, or associated label text
#   * Filters:
#       * :name (String, Regexp) - Matches the name attribute
#       * :disabled (Boolean, :all) - Match disabled field? (Default: false)
#       * :multiple (Boolean) - Match field that accepts multiple values
#
# * **:label** - Find label elements
#   * Locator: Match id, {Capybara.configure test_id}, or text contents
#   * Filters:
#       * :for (Element, String, Regexp) - The element or id of the element associated with the label
#
# * **:table** - Find table elements
#   * Locator: id, {Capybara.configure test_id}, or caption text of table
#   * Filters:
#       * :caption (String) - Match text of associated caption
#       * :with_rows (Array<Array<String>>, Array<Hash<String, String>>) - Partial match `<td>` data - visibility of `<td>` elements is not considered
#       * :rows (Array<Array<String>>) - Match all `<td>`s - visibility of `<td>` elements is not considered
#       * :with_cols (Array<Array<String>>, Array<Hash<String, String>>) - Partial match `<td>` data - visibility of `<td>` elements is not considered
#       * :cols (Array<Array<String>>) - Match all `<td>`s - visibility of `<td>` elements is not considered
#
# * **:table_row** - Find table row
#   * Locator: Array<String>, Hash<String, String> table row `<td>` contents - visibility of `<td>` elements is not considered
#
# * **:frame** - Find frame/iframe elements
#   * Locator: Match id, {Capybara.configure test_id} attribute, or name
#   * Filters:
#       * :name (String) - Match name attribute
#
# * **:element**
#   * Locator: Type of element ('div', 'a', etc) - if not specified defaults to '*'
#   * Filters:
#       * :\<any> (String, Regexp) - Match on any specified element attribute
class Capybara::Selector < ::SimpleDelegator
  # @return [Selector] a new instance of Selector
  def initialize(definition, config:, format:); end

  def add_error(error_msg); end

  # @api private
  def builder(expr = T.unsafe(nil)); end

  def call(locator, **options); end
  def current_format; end
  def enable_aria_label; end
  def enable_aria_role; end

  # Returns the value of attribute errors.
  def errors; end

  def expression_for(name, locator, config: T.unsafe(nil), format: T.unsafe(nil), **options); end
  def format; end
  def test_id; end

  # @api private
  def with_filter_errors(errors); end

  private

  def find_by_attr(attribute, value); end
  def find_by_class_attr(classes); end
  def locate_field(xpath, locator, **_options); end
  def locate_label(locator); end
  def locator_description; end

  # @return [Boolean]
  def locator_valid?(locator); end

  class << self
    def [](name); end
    def add(name, **options, &block); end
    def all; end
    def for(locator); end
    def remove(name); end
    def update(name, &block); end
  end
end

class Capybara::Selector::CSS
  class << self
    def escape(str); end
    def escape_char(char); end
    def split(css); end
  end
end

Capybara::Selector::CSS::ESCAPE = T.let(T.unsafe(nil), Regexp)
Capybara::Selector::CSS::H = T.let(T.unsafe(nil), Regexp)
Capybara::Selector::CSS::NMSTART = T.let(T.unsafe(nil), Regexp)
Capybara::Selector::CSS::NONASCII = T.let(T.unsafe(nil), Regexp)
Capybara::Selector::CSS::S = T.let(T.unsafe(nil), String)

class Capybara::Selector::CSS::Splitter
  def split(css); end

  private

  # @raise [ArgumentError]
  def parse_block(start, final, strio); end

  def parse_paren(strio); end
  def parse_square(strio); end

  # @raise [ArgumentError]
  def parse_string(quote, strio); end
end

Capybara::Selector::CSS::UNICODE = T.let(T.unsafe(nil), Regexp)

# @api private
class Capybara::Selector::CSSBuilder
  # @api private
  # @return [CSSBuilder] a new instance of CSSBuilder
  def initialize(expression); end

  # @api private
  def add_attribute_conditions(**attributes); end

  # @api private
  def expression; end

  private

  # @api private
  def attribute_conditions(attributes); end

  # @api private
  def class_conditions(classes); end

  # @api private
  def regexp_conditions(name, value); end
end

class Capybara::Selector::Definition
  extend ::Forwardable

  # @return [Definition] a new instance of Definition
  def initialize(name, locator_type: T.unsafe(nil), raw_locator: T.unsafe(nil), supports_exact: T.unsafe(nil), &block); end

  # Define a selector by a CSS selector
  #
  # @overload css
  # @overload css
  # @return [#call] The block that will be called to generate the CSS selector
  def css(*allowed_filters, &block); end

  def custom_filters; end
  def default_format; end
  def default_visibility(fallback = T.unsafe(nil), options = T.unsafe(nil)); end
  def describe(*args, &block); end
  def describe_all_expression_filters(**opts); end
  def describe_expression_filters(&block); end
  def describe_node_filters(&block); end

  # @param options [Hash] The options of the query used to generate the description
  # @return [String] Description of the selector when used with the options passed
  def description(*args, &block); end

  # @option options
  # @option options
  # @option options
  # @option options
  # @param options [Hash] ({})      Options of the filter
  # @param name [Symbol, Regexp] The filter name
  # @param matcher [Regexp] (nil)   A Regexp used to check whether a specific option is handled by this filter
  # @param types [Array<Symbol>] The types of the filter - currently valid types are [:boolean]
  def expression_filter(*args, &block); end

  def expression_filters; end

  # Returns the value of attribute expressions.
  def expressions; end

  def filter(*args, &block); end
  def filter_set(name, filters_to_use = T.unsafe(nil)); end

  # Set/get a descriptive label for the selector
  #
  # @overload label
  # @overload label
  # @return [String] The currently set label
  def label(label = T.unsafe(nil)); end

  def locator_filter(*types, **options, &block); end

  # @api private
  def locator_types; end

  # Automatic selector detection
  #
  # @return [#call] The block that will be used to detect selector match
  # @yield [locator] This block takes the passed in locator string and returns whether or not it matches the selector
  # @yieldparam , [String] locator      The locator string used to determine if it matches the selector
  # @yieldreturn [Boolean] Whether this selector matches the locator string
  def match(&block); end

  # Should this selector be used for the passed in locator
  #
  #  This is used by the automatic selector selection mechanism when no selector type is passed to a selector query
  #
  # @param locator [String] The locator passed to the query
  # @return [Boolean] Whether or not to use this selector
  def match?(locator); end

  # Returns the value of attribute name.
  def name; end

  # @option options
  # @option options
  # @option options
  # @option options
  # @param name [Symbol, Regexp] The filter name
  # @param types [Array<Symbol>] The types of the filter - currently valid types are [:boolean]
  # @param options [Hash] ({})      Options of the filter
  def node_filter(*args, &block); end

  def node_filters; end

  # @api private
  # @return [Boolean]
  def raw_locator?; end

  # @api private
  # @return [Boolean]
  def supports_exact?; end

  # Set the default visibility mode that shouble be used if no visibile option is passed when using the selector.
  # If not specified will default to the behavior indicated by Capybara.ignore_hidden_elements
  #
  # @param default_visibility [Symbol] Only find elements with the specified visibility:
  #   * :all - finds visible and invisible elements.
  #   * :hidden - only finds invisible elements.
  #   * :visible - only finds visible elements.
  def visible(default_visibility = T.unsafe(nil), &block); end

  # Define a selector by an xpath expression
  #
  # @overload xpath
  # @overload xpath
  # @return [#call] The block that will be called to generate the XPath expression
  def xpath(*allowed_filters, &block); end

  private

  def expression(type, allowed_filters, &block); end
  def handled_custom_options(filter, options); end
  def parameter_names(block); end
end

class Capybara::Selector::FilterSet
  # @return [FilterSet] a new instance of FilterSet
  def initialize(name, &block); end

  def describe(what = T.unsafe(nil), &block); end
  def description(node_filters: T.unsafe(nil), expression_filters: T.unsafe(nil), **options); end
  def descriptions; end
  def expression_filter(name, *types, **options, &block); end

  # Returns the value of attribute expression_filters.
  def expression_filters; end

  def filter(names, *types, **options, &block); end
  def import(name, filters = T.unsafe(nil)); end
  def node_filter(names, *types, **options, &block); end

  # Returns the value of attribute node_filters.
  def node_filters; end

  protected

  def expression_filter_descriptions; end
  def node_filter_descriptions; end
  def undeclared_descriptions; end

  private

  def add_filter(name, filter_class, *types, matcher: T.unsafe(nil), **options, &block); end
  def options_with_defaults(options); end

  class << self
    def [](name); end
    def add(name, &block); end
    def all; end
    def remove(name); end
  end
end

module Capybara::Selector::Filters; end

class Capybara::Selector::Filters::Base
  # @return [Base] a new instance of Base
  def initialize(name, matcher, block, **options); end

  # @return [Boolean]
  def boolean?; end

  def default; end

  # @return [Boolean]
  def default?; end

  def format; end

  # @return [Boolean]
  def handles_option?(option_name); end

  # @return [Boolean]
  def matcher?; end

  # @return [Boolean]
  def skip?(value); end

  private

  def apply(subject, name, value, skip_value, ctx); end
  def filter_context(context); end

  # @return [Boolean]
  def valid_value?(value); end
end

class Capybara::Selector::Filters::ExpressionFilter < ::Capybara::Selector::Filters::Base
  def apply_filter(expr, name, value, selector); end
end

class Capybara::Selector::Filters::IdentityExpressionFilter < ::Capybara::Selector::Filters::ExpressionFilter
  # @return [IdentityExpressionFilter] a new instance of IdentityExpressionFilter
  def initialize(name); end

  def apply_filter(expr, _name, _value, _ctx); end

  # @return [Boolean]
  def default?; end

  # @return [Boolean]
  def matcher?; end
end

class Capybara::Selector::Filters::LocatorFilter < ::Capybara::Selector::Filters::NodeFilter
  # @return [LocatorFilter] a new instance of LocatorFilter
  def initialize(block, **options); end

  # @return [Boolean]
  def matches?(node, value, context = T.unsafe(nil), exact:); end

  private

  def apply(subject, value, skip_value, ctx, **options); end
end

class Capybara::Selector::Filters::NodeFilter < ::Capybara::Selector::Filters::Base
  # @return [NodeFilter] a new instance of NodeFilter
  def initialize(name, matcher, block, **options); end

  # @return [Boolean]
  def matches?(node, name, value, context = T.unsafe(nil)); end
end

# @api private
class Capybara::Selector::RegexpDisassembler
  # @api private
  # @return [RegexpDisassembler] a new instance of RegexpDisassembler
  def initialize(regexp); end

  # @api private
  def alternated_substrings; end

  # @api private
  def substrings; end

  private

  # @api private
  def collapse(strs); end

  # @api private
  def combine(strs); end

  # @api private
  def extract_strings(expression, alternation: T.unsafe(nil)); end

  # @api private
  def process(alternation:); end

  # @api private
  def remove_and_covered(strings); end

  # @api private
  def remove_or_covered(or_series); end
end

# @api private
class Capybara::Selector::RegexpDisassembler::Expression
  # @api private
  # @return [Expression] a new instance of Expression
  def initialize(exp); end

  # @api private
  def extract_strings(process_alternatives); end

  protected

  # @api private
  # @return [Boolean]
  def alternation?; end

  # @api private
  def alternative_strings; end

  # @api private
  # @return [Boolean]
  def ignore?; end

  # @api private
  # @return [Boolean]
  def optional?; end

  # @api private
  def optional_strings; end

  # @api private
  def repeated_strings(process_alternatives); end

  # @api private
  def strings(process_alternatives); end

  # @api private
  # @return [Boolean]
  def terminal?; end

  # @api private
  def terminal_strings; end

  private

  # @api private
  def alternatives; end

  # @api private
  def each; end

  # @api private
  # @return [Boolean]
  def fixed_repeat?; end

  # @api private
  # @return [Boolean]
  def indeterminate?; end

  # @api private
  def max_repeat; end

  # @api private
  def min_repeat; end

  # @api private
  def options_set(strs); end

  # @api private
  def repeat_set(str); end

  # @api private
  def type; end
end

# @api private
class Capybara::Selector::XPathBuilder
  # @api private
  # @return [XPathBuilder] a new instance of XPathBuilder
  def initialize(expression); end

  # @api private
  def add_attribute_conditions(**conditions); end

  # @api private
  def expression; end

  private

  # @api private
  def attribute_conditions(attributes); end

  # @api private
  def class_conditions(classes); end

  # @api private
  def regexp_to_xpath_conditions(regexp); end
end

module Capybara::Selenium; end

module Capybara::Selenium::ChromeLogs
  def available_log_types; end
  def commands(command); end
  def log(type); end
end

Capybara::Selenium::ChromeLogs::COMMANDS = T.let(T.unsafe(nil), Hash)
Capybara::Selenium::ChromeLogs::LOG_MSG = T.let(T.unsafe(nil), String)

class Capybara::Selenium::ChromeNode < ::Capybara::Selenium::Node
  include ::Capybara::Selenium::Node::Html5Drag
  include ::Capybara::Selenium::Node::FileInputClickEmulation

  def click(*_arg0, **_arg1); end

  # @return [Boolean]
  def disabled?; end

  def drop(*args); end
  def select_option; end
  def send_keys(*args); end
  def set_file(value); end
  def set_text(value, clear: T.unsafe(nil), **_unused); end

  # @return [Boolean]
  def visible?; end

  private

  def browser_version(to_float: T.unsafe(nil)); end

  # @return [Boolean]
  def chromedriver_fixed_actions_key_state?; end

  # @return [Boolean]
  def chromedriver_supports_displayed_endpoint?; end

  def chromedriver_version; end
  def file_errors; end

  # @return [Boolean]
  def native_displayed?; end

  # @raise [ArgumentError]
  def perform_legacy_drag(element, drop_modifiers); end
end

class Capybara::Selenium::Driver < ::Capybara::Driver::Base
  include ::Capybara::Selenium::Find

  # @return [Driver] a new instance of Driver
  def initialize(app, **options); end

  def accept_modal(_type, **options); end

  # Returns the value of attribute app.
  def app; end

  def browser; end

  # @raise [ArgumentError]
  def close_window(handle); end

  def current_url; end
  def current_window_handle; end
  def dismiss_modal(_type, **options); end
  def evaluate_async_script(script, *args); end
  def evaluate_script(script, *args); end
  def execute_script(script, *args); end

  # @return [Boolean]
  def frame_obscured_at?(x:, y:); end

  def fullscreen_window(handle); end
  def go_back; end
  def go_forward; end
  def html; end
  def invalid_element_errors; end
  def maximize_window(handle); end

  # @return [Boolean]
  def needs_server?; end

  def no_such_window_error; end
  def open_new_window(kind = T.unsafe(nil)); end

  # Returns the value of attribute options.
  def options; end

  def quit; end
  def refresh; end
  def reset!; end
  def resize_window_to(handle, width, height); end
  def save_screenshot(path, **_options); end
  def send_keys(*args); end
  def switch_to_frame(frame); end
  def switch_to_window(handle); end
  def title; end
  def visit(path); end

  # @return [Boolean]
  def wait?; end

  def window_handles; end
  def window_size(handle); end

  private

  def accept_unhandled_reset_alert; end
  def active_element; end
  def bridge; end
  def build_node(native_node, initial_cache = T.unsafe(nil)); end
  def clear_browser_state; end
  def clear_browser_state_errors; end
  def clear_local_storage; end
  def clear_session_storage; end
  def clear_storage; end
  def delete_all_cookies; end
  def find_context; end
  def find_modal(text: T.unsafe(nil), **options); end
  def find_modal_errors; end
  def modal_error; end
  def native_args(args); end
  def navigate_with_accept(url); end
  def reset_browser_state; end

  # @return [Boolean]
  def selenium_4?; end

  def setup_exit_handler; end

  # @return [Boolean]
  def silenced_unknown_error_message?(msg); end

  def silenced_unknown_error_messages; end
  def specialize_driver; end
  def unhandled_alert_errors; end
  def unwrap_script_result(arg); end
  def wait_for_empty_page(timer); end
  def with_legacy_error(errors, legacy_error); end
  def within_given_window(handle); end

  class << self
    def load_selenium; end
    def register_specialization(browser_name, specialization); end

    # Returns the value of attribute selenium_webdriver_version.
    def selenium_webdriver_version; end

    # Returns the value of attribute specializations.
    def specializations; end
  end
end

Capybara::Selenium::Driver::CAPS_VERSION = T.let(T.unsafe(nil), Gem::Requirement)

module Capybara::Selenium::Driver::ChromeDriver
  def fullscreen_window(handle); end
  def reset!; end
  def resize_window_to(handle, width, height); end

  private

  def build_node(native_node, initial_cache = T.unsafe(nil)); end
  def cdp_unsupported_errors; end
  def chromedriver_version; end

  # @return [Boolean]
  def clear_all_storage?; end

  def clear_storage; end
  def delete_all_cookies; end
  def execute_cdp(cmd, params = T.unsafe(nil)); end
  def storage_clears; end
  def storage_types_to_clear; end

  # @return [Boolean]
  def uniform_storage_clear?; end

  class << self
    # @private
    def extended(base); end
  end
end

Capybara::Selenium::Driver::DEFAULT_OPTIONS = T.let(T.unsafe(nil), Hash)

module Capybara::Selenium::Driver::EdgeDriver
  def download_path=(path); end
  def fullscreen_window(handle); end
  def reset!; end
  def resize_window_to(handle, width, height); end

  private

  def build_node(native_node, initial_cache = T.unsafe(nil)); end
  def cdp_unsupported_errors; end

  # @return [Boolean]
  def clear_all_storage?; end

  def clear_storage; end
  def delete_all_cookies; end
  def edgedriver_version; end
  def execute_cdp(cmd, params = T.unsafe(nil)); end
  def storage_clears; end
  def storage_types_to_clear; end

  # @return [Boolean]
  def uniform_storage_clear?; end

  class << self
    # @private
    def extended(base); end
  end
end

module Capybara::Selenium::Driver::FirefoxDriver
  class << self
    # @private
    def extended(driver); end

    # @return [Boolean]
    def w3c?(driver); end
  end
end

module Capybara::Selenium::Driver::InternetExplorerDriver
  def switch_to_frame(frame); end

  private

  def build_node(native_node, initial_cache = T.unsafe(nil)); end
end

Capybara::Selenium::Driver::SPECIAL_OPTIONS = T.let(T.unsafe(nil), Array)

module Capybara::Selenium::Driver::SafariDriver
  def switch_to_frame(frame); end

  private

  def build_node(native_node, initial_cache = T.unsafe(nil)); end
end

module Capybara::Selenium::Driver::W3CFirefoxDriver
  def refresh; end
  def reset!; end
  def resize_window_to(handle, width, height); end
  def switch_to_frame(frame); end

  private

  def browser_version; end
  def build_node(native_node, initial_cache = T.unsafe(nil)); end

  class << self
    # @private
    def extended(driver); end

    # @return [Boolean]
    def pause_broken?(sel_driver); end
  end
end

class Capybara::Selenium::EdgeNode < ::Capybara::Selenium::Node
  include ::Capybara::Selenium::Node::Html5Drag

  def click(*_arg0); end

  # @return [Boolean]
  def disabled?; end

  def drop(*args); end
  def select_option; end
  def set_file(value); end
  def set_text(value, clear: T.unsafe(nil), **_unused); end

  # @return [Boolean]
  def visible?; end

  private

  def browser_version; end

  # @return [Boolean]
  def chrome_edge?; end

  def file_errors; end

  # @return [Boolean]
  def native_displayed?; end
end

module Capybara::Selenium::Find
  def find_css(selector, uses_visibility: T.unsafe(nil), texts: T.unsafe(nil), styles: T.unsafe(nil), position: T.unsafe(nil), **_options); end
  def find_xpath(selector, uses_visibility: T.unsafe(nil), styles: T.unsafe(nil), position: T.unsafe(nil), **_options); end

  private

  def build_hints_js(uses_visibility, styles, position); end
  def es_context; end
  def filter_by_text(elements, texts); end
  def find_by(format, selector, uses_visibility:, texts:, styles:, position:); end
  def gather_hints(elements, uses_visibility:, styles:, position:); end
  def is_displayed_atom; end
end

class Capybara::Selenium::FirefoxNode < ::Capybara::Selenium::Node
  include ::Capybara::Selenium::Node::Html5Drag
  include ::Capybara::Selenium::Node::FileInputClickEmulation

  def click(keys = T.unsafe(nil), **options); end

  # @return [Boolean]
  def disabled?; end

  def drop(*args); end

  # @return [Boolean]
  def focused?; end

  def hover; end
  def select_option; end
  def send_keys(*args); end
  def set_file(value); end

  # @return [Boolean]
  def visible?; end

  private

  def _send_keys(keys, actions = T.unsafe(nil), down_keys = T.unsafe(nil)); end
  def browser_version; end

  # @return [Boolean]
  def native_displayed?; end

  def perform_with_options(click_options); end

  # @raise [ArgumentError]
  def upload(local_file); end
end

class Capybara::Selenium::IENode < ::Capybara::Selenium::Node
  # @return [Boolean]
  def disabled?; end
end

class Capybara::Selenium::Node < ::Capybara::Driver::Node
  include ::Capybara::Selenium::Find
  include ::Capybara::Selenium::Scroll

  def ==(other); end
  def [](name); end
  def all_text; end

  # @return [Boolean]
  def checked?; end

  def click(keys = T.unsafe(nil), **options); end

  # @return [Boolean]
  def content_editable?; end

  # @return [Boolean]
  def disabled?; end

  # @raise [ArgumentError]
  def double_click(keys = T.unsafe(nil), **options); end

  def drag_to(element, drop_modifiers: T.unsafe(nil), **_arg2); end

  # @raise [NotImplementedError]
  def drop(*_); end

  def hover; end

  # @return [Boolean]
  def multiple?; end

  # @return [Boolean]
  def obscured?(x: T.unsafe(nil), y: T.unsafe(nil)); end

  def path; end

  # @return [Boolean]
  def readonly?; end

  def rect; end
  def right_click(keys = T.unsafe(nil), **options); end
  def select_option; end

  # @return [Boolean]
  def selected?; end

  def send_keys(*args); end

  # Set the value of the form element to the given value.
  #
  # @option options
  # @param value [String] The new value
  # @param options [Hash{}] Driver specific options for how to set the value
  def set(value, **options); end

  def style(styles); end
  def tag_name; end

  # @raise [Capybara::UnselectNotAllowed]
  def unselect_option; end

  def value; end

  # @return [Boolean]
  def visible?; end

  def visible_text; end

  protected

  def scroll_if_needed; end
  def scroll_to_center; end

  private

  def action_with_modifiers(click_options); end
  def attrs(*attr_names); end
  def auto_rapid_set_length; end
  def boolean_attr(val); end
  def bridge; end
  def browser; end
  def browser_action; end
  def build_node(native_node, initial_cache = T.unsafe(nil)); end
  def capabilities; end
  def each_key(keys, &block); end
  def find_context; end
  def modifiers_down(actions, keys); end
  def modifiers_up(actions, keys); end
  def normalize_keys(keys); end

  # @raise [ArgumentError]
  def perform_with_options(click_options, &block); end

  # a reference to the select node if this is an option node
  def select_node; end

  def set_color(value); end
  def set_content_editable(value); end
  def set_date(value); end
  def set_datetime_local(value); end
  def set_file(value); end
  def set_range(value); end
  def set_text(value, clear: T.unsafe(nil), rapid: T.unsafe(nil), **_unused); end
  def set_time(value); end
  def sibling_index(parent, node, selector); end
  def update_value_js(value); end

  # @return [Boolean]
  def w3c?; end

  def with_file_detector; end
end

# ClickOptions encapsulates click option logic
class Capybara::Selenium::Node::ClickOptions
  # @return [ClickOptions] a new instance of ClickOptions
  def initialize(keys, options); end

  # @return [Boolean]
  def center_offset?; end

  def coords; end

  # @return [Boolean]
  def coords?; end

  def delay; end

  # @return [Boolean]
  def empty?; end

  # Returns the value of attribute keys.
  def keys; end

  # Returns the value of attribute options.
  def options; end
end

module Capybara::Selenium::Node::FileInputClickEmulation
  def click(keys = T.unsafe(nil), **options); end

  private

  # @return [Boolean]
  def attaching_file?; end

  def emulate_click; end

  # @return [Boolean]
  def visible_file_field?; end
end

Capybara::Selenium::Node::GET_XPATH_SCRIPT = T.let(T.unsafe(nil), String)

module Capybara::Selenium::Node::Html5Drag
  # Implement methods to emulate HTML5 drag and drop
  def drag_to(element, html5: T.unsafe(nil), delay: T.unsafe(nil), drop_modifiers: T.unsafe(nil)); end

  private

  def html5_drop(*args); end
  def perform_html5_drag(element, delay, drop_modifiers); end
  def perform_legacy_drag(element, drop_modifiers); end
end

Capybara::Selenium::Node::Html5Drag::ATTACH_FILE = T.let(T.unsafe(nil), String)
Capybara::Selenium::Node::Html5Drag::DROP_FILE = T.let(T.unsafe(nil), String)
Capybara::Selenium::Node::Html5Drag::DROP_STRING = T.let(T.unsafe(nil), String)
Capybara::Selenium::Node::Html5Drag::HTML5_DRAG_DROP_SCRIPT = T.let(T.unsafe(nil), String)
Capybara::Selenium::Node::Html5Drag::LEGACY_DRAG_CHECK = T.let(T.unsafe(nil), String)
Capybara::Selenium::Node::Html5Drag::MOUSEDOWN_TRACKER = T.let(T.unsafe(nil), String)

# @api private
class Capybara::Selenium::Node::ModifierKeysStack
  # @api private
  # @return [ModifierKeysStack] a new instance of ModifierKeysStack
  def initialize; end

  # @api private
  # @return [Boolean]
  def include?(key); end

  # @api private
  def pop; end

  # @api private
  def press(key); end

  # @api private
  def push; end
end

Capybara::Selenium::Node::OBSCURED_OR_OFFSET_SCRIPT = T.let(T.unsafe(nil), String)
Capybara::Selenium::Node::RAPID_APPEND_TEXT = T.let(T.unsafe(nil), String)

# SettableValue encapsulates time/date field formatting
class Capybara::Selenium::Node::SettableValue
  # @return [SettableValue] a new instance of SettableValue
  def initialize(value); end

  # @return [Boolean]
  def dateable?; end

  # @return [Boolean]
  def timeable?; end

  def to_date_str; end
  def to_datetime_str; end
  def to_s; end
  def to_time_str; end

  # Returns the value of attribute value.
  def value; end
end

class Capybara::Selenium::SafariNode < ::Capybara::Selenium::Node
  # include Html5Drag
  def click(keys = T.unsafe(nil), **options); end

  # @return [Boolean]
  def disabled?; end

  def hover; end
  def select_option; end
  def send_keys(*args); end
  def set_file(value); end
  def set_text(value, clear: T.unsafe(nil), **_unused); end
  def unselect_option; end
  def visible_text; end

  private

  def _send_keys(keys, actions = T.unsafe(nil), down_keys = T.unsafe(nil)); end
end

Capybara::Selenium::SafariNode::MODIFIER_KEYS = T.let(T.unsafe(nil), Array)

module Capybara::Selenium::Scroll
  def scroll_by(x, y); end
  def scroll_to(element, location, position = T.unsafe(nil)); end

  private

  def scroll_element_to_location(element, location); end
  def scroll_to_coords(x, y); end
  def scroll_to_location(location); end
end

Capybara::Selenium::Scroll::SCROLL_POSITIONS = T.let(T.unsafe(nil), Hash)

# @api private
class Capybara::Server
  # @api private
  # @return [Server] a new instance of Server
  def initialize(app, *deprecated_options, port: T.unsafe(nil), host: T.unsafe(nil), reportable_errors: T.unsafe(nil), extra_middleware: T.unsafe(nil)); end

  # @api private
  def app; end

  # @api private
  def base_url; end

  # @api private
  def boot; end

  # @api private
  def error; end

  # @api private
  def host; end

  # @api private
  def port; end

  # @api private
  def reset_error!; end

  # @api private
  # @return [Boolean]
  def responsive?; end

  # @api private
  # @return [Boolean]
  def using_ssl?; end

  # @api private
  def wait_for_pending_requests; end

  private

  # @api private
  def find_available_port(host); end

  # @api private
  def middleware; end

  # @api private
  # @return [Boolean]
  def pending_requests?; end

  # @api private
  def port_key; end

  class << self
    # @api private
    def ports; end
  end
end

class Capybara::Server::AnimationDisabler
  # @return [AnimationDisabler] a new instance of AnimationDisabler
  def initialize(app); end

  def call(env); end

  private

  # Returns the value of attribute disable_markup.
  def disable_markup; end

  # @return [Boolean]
  def html_content?; end

  def insert_disable(html); end

  class << self
    def selector_for(css_or_bool); end
  end
end

Capybara::Server::AnimationDisabler::DISABLE_MARKUP_TEMPLATE = T.let(T.unsafe(nil), String)

class Capybara::Server::Checker
  # @return [Checker] a new instance of Checker
  def initialize(host, port); end

  def request(&block); end

  # @return [Boolean]
  def ssl?; end

  private

  def http_request(&block); end
  def https_request(&block); end
  def make_request(**options, &block); end
  def ssl_options; end
end

Capybara::Server::Checker::TRY_HTTPS_ERRORS = T.let(T.unsafe(nil), Array)

class Capybara::Server::Middleware
  # @return [Middleware] a new instance of Middleware
  def initialize(app, server_errors, extra_middleware = T.unsafe(nil)); end

  def call(env); end
  def clear_error; end

  # Returns the value of attribute error.
  def error; end

  def pending_requests; end

  # @return [Boolean]
  def pending_requests?; end
end

class Capybara::Server::Middleware::Counter
  # @return [Counter] a new instance of Counter
  def initialize; end

  def decrement(uri); end
  def increment(uri); end

  # @return [Boolean]
  def positive?; end

  def value; end
end

# The {Session} class represents a single user's interaction with the system. The {Session} can use
# any of the underlying drivers. A session can be initialized manually like this:
#
#     session = Capybara::Session.new(:culerity, MyRackApp)
#
# The application given as the second argument is optional. When running Capybara against an external
# page, you might want to leave it out:
#
#     session = Capybara::Session.new(:culerity)
#     session.visit('http://www.google.com')
#
# When {Capybara.configure threadsafe} is `true` the sessions options will be initially set to the
# current values of the global options and a configuration block can be passed to the session initializer.
# For available options see {Capybara::SessionConfig::OPTIONS}:
#
#     session = Capybara::Session.new(:driver, MyRackApp) do |config|
#       config.app_host = "http://my_host.dev"
#     end
#
# The {Session} provides a number of methods for controlling the navigation of the page, such as {#visit},
# {#current_path}, and so on. It also delegates a number of methods to a {Capybara::Document}, representing
# the current HTML document. This allows interaction:
#
#     session.fill_in('q', with: 'Capybara')
#     session.click_button('Search')
#     expect(session).to have_content('Capybara')
#
# When using `capybara/dsl`, the {Session} is initialized automatically for you.
class Capybara::Session
  include ::Capybara::SessionMatchers

  # @return [Session] a new instance of Session
  def initialize(mode, app = T.unsafe(nil)); end

  # Execute the block, accepting a alert.
  #
  # Expects a block whose actions will trigger the display modal to appear.
  #
  # @example
  #   accept_alert do
  #   click_link('link that triggers appearance of system modal')
  #   end
  # @overload accept_alert
  # @overload accept_alert
  # @raise [Capybara::ModalNotFound] if modal dialog hasn't been found
  # @return [String] the message shown in the modal
  def accept_alert(text = T.unsafe(nil), **options, &blk); end

  # Execute the block, accepting a confirm.
  #
  # Expects a block whose actions will trigger the display modal to appear.
  #
  # @example
  #   accept_confirm do
  #   click_link('link that triggers appearance of system modal')
  #   end
  # @overload accept_confirm
  # @overload accept_confirm
  # @raise [Capybara::ModalNotFound] if modal dialog hasn't been found
  # @return [String] the message shown in the modal
  def accept_confirm(text = T.unsafe(nil), **options, &blk); end

  # Execute the block, accepting a prompt, optionally responding to the prompt.
  #
  # Expects a block whose actions will trigger the display modal to appear.
  #
  # @example
  #   accept_prompt do
  #   click_link('link that triggers appearance of system modal')
  #   end
  # @option options
  # @overload accept_prompt
  # @overload accept_prompt
  # @param options [Hash] a customizable set of options
  # @raise [Capybara::ModalNotFound] if modal dialog hasn't been found
  # @return [String] the message shown in the modal
  def accept_prompt(text = T.unsafe(nil), **options, &blk); end

  def all(*_arg0, &_arg1); end

  # Returns the value of attribute app.
  def app; end

  def assert_all_of_selectors(*_arg0, &_arg1); end
  def assert_any_of_selectors(*_arg0, &_arg1); end
  def assert_no_selector(*_arg0, &_arg1); end
  def assert_no_text(*_arg0, &_arg1); end
  def assert_no_title(*_arg0, &_arg1); end
  def assert_none_of_selectors(*_arg0, &_arg1); end
  def assert_selector(*_arg0, &_arg1); end
  def assert_text(*_arg0, &_arg1); end
  def assert_title(*_arg0, &_arg1); end
  def attach_file(*_arg0, &_arg1); end

  # @return [String] A snapshot of the DOM of the current document, as it looks right now (potentially modified by JavaScript).
  def body; end

  def check(*_arg0, &_arg1); end
  def choose(*_arg0, &_arg1); end

  # Reset the session (i.e. remove cookies and navigate to blank page).
  #
  # This method does not:
  #
  # * accept modal dialogs if they are present (Selenium driver now does, others may not)
  # * clear browser cache/HTML 5 local storage/IndexedDB/Web SQL database/etc.
  # * modify state of the driver/underlying browser in any other way
  #
  # as doing so will result in performance downsides and it's not needed to do everything from the list above for most apps.
  #
  # If you want to do anything from the list above on a general basis you can:
  #
  # * write RSpec/Cucumber/etc. after hook
  # * monkeypatch this method
  # * use Ruby's `prepend` method
  def cleanup!; end

  def click_button(*_arg0, &_arg1); end
  def click_link(*_arg0, &_arg1); end
  def click_link_or_button(*_arg0, &_arg1); end
  def click_on(*_arg0, &_arg1); end
  def config; end

  # Accepts a block to set the configuration options if {Capybara.configure threadsafe} is `true`. Note that some options only have an effect
  # if set at initialization time, so look at the configuration block that can be passed to the initializer too.
  #
  # @yield [config]
  def configure; end

  # @return [String] Host of the current page
  def current_host; end

  # @return [String] Path of the current page, without any domain information
  def current_path; end

  def current_scope; end

  # @return [String] Fully qualified URL of the current page
  def current_url; end

  # @return [Capybara::Window] current window
  def current_window; end

  # Execute the block, dismissing a confirm.
  #
  # Expects a block whose actions will trigger the display modal to appear.
  #
  # @example
  #   dismiss_confirm do
  #   click_link('link that triggers appearance of system modal')
  #   end
  # @overload dismiss_confirm
  # @overload dismiss_confirm
  # @raise [Capybara::ModalNotFound] if modal dialog hasn't been found
  # @return [String] the message shown in the modal
  def dismiss_confirm(text = T.unsafe(nil), **options, &blk); end

  # Execute the block, dismissing a prompt.
  #
  # Expects a block whose actions will trigger the display modal to appear.
  #
  # @example
  #   dismiss_prompt do
  #   click_link('link that triggers appearance of system modal')
  #   end
  # @overload dismiss_prompt
  # @overload dismiss_prompt
  # @raise [Capybara::ModalNotFound] if modal dialog hasn't been found
  # @return [String] the message shown in the modal
  def dismiss_prompt(text = T.unsafe(nil), **options, &blk); end

  def document; end
  def driver; end

  # Evaluate the given JavaScript and obtain the result from a callback function which will be passed as the last argument to the script.
  #
  # @param script [String] A string of JavaScript to evaluate
  # @param args Optional arguments that will be passed to the script
  # @return [Object] The result of the evaluated JavaScript (may be driver specific)
  def evaluate_async_script(script, *args); end

  # Evaluate the given JavaScript and return the result. Be careful when using this with
  # scripts that return complex objects, such as jQuery statements. {#execute_script} might
  # be a better alternative.
  #
  # @param script [String] A string of JavaScript to evaluate
  # @param args Optional arguments that will be passed to the script
  # @return [Object] The result of the evaluated JavaScript (may be driver specific)
  def evaluate_script(script, *args); end

  # Execute the given script, not returning a result. This is useful for scripts that return
  # complex objects, such as jQuery statements. {#execute_script} should be used over
  # {#evaluate_script} whenever possible.
  #
  # @param script [String] A string of JavaScript to execute
  # @param args Optional arguments that will be passed to the script. Driver support for this is optional and types of objects supported may differ between drivers
  def execute_script(script, *args); end

  def fill_in(*_arg0, &_arg1); end
  def find(*_arg0, &_arg1); end
  def find_all(*_arg0, &_arg1); end
  def find_button(*_arg0, &_arg1); end
  def find_by_id(*_arg0, &_arg1); end
  def find_field(*_arg0, &_arg1); end
  def find_link(*_arg0, &_arg1); end
  def first(*_arg0, &_arg1); end

  # Move back a single entry in the browser's history.
  def go_back; end

  # Move forward a single entry in the browser's history.
  def go_forward; end

  def has_button?(*_arg0, &_arg1); end
  def has_checked_field?(*_arg0, &_arg1); end
  def has_content?(*_arg0, &_arg1); end
  def has_css?(*_arg0, &_arg1); end
  def has_field?(*_arg0, &_arg1); end
  def has_link?(*_arg0, &_arg1); end
  def has_no_button?(*_arg0, &_arg1); end
  def has_no_checked_field?(*_arg0, &_arg1); end
  def has_no_content?(*_arg0, &_arg1); end
  def has_no_css?(*_arg0, &_arg1); end
  def has_no_field?(*_arg0, &_arg1); end
  def has_no_link?(*_arg0, &_arg1); end
  def has_no_select?(*_arg0, &_arg1); end
  def has_no_selector?(*_arg0, &_arg1); end
  def has_no_table?(*_arg0, &_arg1); end
  def has_no_text?(*_arg0, &_arg1); end
  def has_no_title?(*_arg0, &_arg1); end
  def has_no_unchecked_field?(*_arg0, &_arg1); end
  def has_no_xpath?(*_arg0, &_arg1); end
  def has_select?(*_arg0, &_arg1); end
  def has_selector?(*_arg0, &_arg1); end
  def has_table?(*_arg0, &_arg1); end
  def has_text?(*_arg0, &_arg1); end
  def has_title?(*_arg0, &_arg1); end
  def has_unchecked_field?(*_arg0, &_arg1); end
  def has_xpath?(*_arg0, &_arg1); end

  # @return [String] A snapshot of the DOM of the current document, as it looks right now (potentially modified by JavaScript).
  def html; end

  def inspect; end

  # Returns the value of attribute mode.
  def mode; end

  # Open a new window.
  # The current window doesn't change as the result of this call.
  # It should be switched to explicitly.
  #
  # @return [Capybara::Window] window that has been opened
  def open_new_window(kind = T.unsafe(nil)); end

  def query(*_arg0, &_arg1); end

  # Disconnect from the current driver. A new driver will be instantiated on the next interaction.
  def quit; end

  # Raise errors encountered in the server.
  def raise_server_error!; end

  # Refresh the page.
  def refresh; end

  def refute_selector(*_arg0, &_arg1); end

  # Reset the session (i.e. remove cookies and navigate to blank page).
  #
  # This method does not:
  #
  # * accept modal dialogs if they are present (Selenium driver now does, others may not)
  # * clear browser cache/HTML 5 local storage/IndexedDB/Web SQL database/etc.
  # * modify state of the driver/underlying browser in any other way
  #
  # as doing so will result in performance downsides and it's not needed to do everything from the list above for most apps.
  #
  # If you want to do anything from the list above on a general basis you can:
  #
  # * write RSpec/Cucumber/etc. after hook
  # * monkeypatch this method
  # * use Ruby's `prepend` method
  def reset!; end

  # Reset the session (i.e. remove cookies and navigate to blank page).
  #
  # This method does not:
  #
  # * accept modal dialogs if they are present (Selenium driver now does, others may not)
  # * clear browser cache/HTML 5 local storage/IndexedDB/Web SQL database/etc.
  # * modify state of the driver/underlying browser in any other way
  #
  # as doing so will result in performance downsides and it's not needed to do everything from the list above for most apps.
  #
  # If you want to do anything from the list above on a general basis you can:
  #
  # * write RSpec/Cucumber/etc. after hook
  # * monkeypatch this method
  # * use Ruby's `prepend` method
  def reset_session!; end

  # Returns a hash of response headers. Not supported by all drivers (e.g. Selenium).
  #
  # @return [Hash<String, String>] A hash of response headers.
  def response_headers; end

  # Save a snapshot of the page and open it in a browser for inspection.
  #
  # If invoked without arguments it will save file to {Capybara.configure save_path}
  # and file will be given randomly generated filename. If invoked with a relative path
  # the path will be relative to {Capybara.configure save_path}.
  #
  # @param path [String] the path to where it should be saved
  def save_and_open_page(path = T.unsafe(nil)); end

  # Save a screenshot of the page and open it for inspection.
  #
  # If invoked without arguments it will save file to {Capybara.configure save_path}
  # and file will be given randomly generated filename. If invoked with a relative path
  # the path will be relative to {Capybara.configure save_path}.
  #
  # @param path [String] the path to where it should be saved
  # @param options [Hash] a customizable set of options
  def save_and_open_screenshot(path = T.unsafe(nil), **options); end

  # Save a snapshot of the page. If {Capybara.configure asset_host} is set it will inject `base` tag
  # pointing to {Capybara.configure asset_host}.
  #
  # If invoked without arguments it will save file to {Capybara.configure save_path}
  # and file will be given randomly generated filename. If invoked with a relative path
  # the path will be relative to {Capybara.configure save_path}.
  #
  # @param path [String] the path to where it should be saved
  # @return [String] the path to which the file was saved
  def save_page(path = T.unsafe(nil)); end

  # Save a screenshot of page.
  #
  # If invoked without arguments it will save file to {Capybara.configure save_path}
  # and file will be given randomly generated filename. If invoked with a relative path
  # the path will be relative to {Capybara.configure save_path}.
  #
  # @param path [String] the path to where it should be saved
  # @param options [Hash] a customizable set of options
  # @return [String] the path to which the file was saved
  def save_screenshot(path = T.unsafe(nil), **options); end

  def scroll_by(*_arg0, &_arg1); end
  def scroll_to(*_arg0, &_arg1); end
  def select(*_arg0, &_arg1); end
  def send_keys(*args, **kw_args); end

  # Returns the value of attribute server.
  def server; end

  def server_url; end

  # @return [String] A snapshot of the DOM of the current document, as it looks right now (potentially modified by JavaScript).
  def source; end

  # Returns the current HTTP status code as an integer. Not supported by all drivers (e.g. Selenium).
  #
  # @return [Integer] Current HTTP status code
  def status_code; end

  # Switch to the given frame.
  #
  # If you use this method you are responsible for making sure you switch back to the parent frame when done in the frame changed to.
  # {#within_frame} is preferred over this method and should be used when possible.
  # May not be supported by all drivers.
  #
  # @overload switch_to_frame
  # @overload switch_to_frame
  def switch_to_frame(frame); end

  # Switch to the given window.
  #
  # @overload switch_to_window
  # @overload switch_to_window
  # @raise [Capybara::ScopeError] if this method is invoked inside {#within} or
  #   {#within_frame} methods
  # @raise [ArgumentError] if both or neither arguments were provided
  # @return [Capybara::Window] window that has been switched to
  def switch_to_window(window = T.unsafe(nil), **options, &window_locator); end

  # Returns the value of attribute synchronized.
  def synchronized; end

  # Sets the attribute synchronized
  #
  # @param value the value to set the attribute synchronized to.
  def synchronized=(_arg0); end

  def text(*_arg0, &_arg1); end
  def title(*_arg0, &_arg1); end
  def uncheck(*_arg0, &_arg1); end
  def unselect(*_arg0, &_arg1); end

  # Yield a block using a specific maximum wait time.
  def using_wait_time(seconds, &block); end

  # Navigate to the given URL. The URL can either be a relative URL or an absolute URL
  # The behaviour of either depends on the driver.
  #
  #     session.visit('/foo')
  #     session.visit('http://google.com')
  #
  # For drivers which can run against an external application, such as the selenium driver
  # giving an absolute URL will navigate to that page. This allows testing applications
  # running on remote servers. For these drivers, setting {Capybara.configure app_host} will make the
  # remote server the default. For example:
  #
  #     Capybara.app_host = 'http://google.com'
  #     session.visit('/') # visits the google homepage
  #
  # If {Capybara.configure always_include_port} is set to `true` and this session is running against
  # a rack application, then the port that the rack application is running on will automatically
  # be inserted into the URL. Supposing the app is running on port `4567`, doing something like:
  #
  #     visit("http://google.com/test")
  #
  # Will actually navigate to `http://google.com:4567/test`.
  #
  # @param visit_uri [#to_s] The URL to navigate to. The parameter will be cast to a String.
  def visit(visit_uri); end

  # Get the window that has been opened by the passed block.
  # It will wait for it to be opened (in the same way as other Capybara methods wait).
  # It's better to use this method than `windows.last`
  # {https://dvcs.w3.org/hg/webdriver/raw-file/default/webdriver-spec.html#h_note_10 as order of windows isn't defined in some drivers}.
  #
  # @overload window_opened_by
  def window_opened_by(**options); end

  # Get all opened windows.
  # The order of windows in returned array is not defined.
  # The driver may sort windows by their creation time but it's not required.
  #
  # @return [Array<Capybara::Window>] an array of all windows
  def windows; end

  # Executes the given block within the context of a node. {#within} takes the
  # same options as {Capybara::Node::Finders#find #find}, as well as a block. For the duration of the
  # block, any command to Capybara will be handled as though it were scoped
  # to the given element.
  #
  #     within(:xpath, './/div[@id="delivery-address"]') do
  #       fill_in('Street', with: '12 Main Street')
  #     end
  #
  # Just as with `#find`, if multiple elements match the selector given to
  # {#within}, an error will be raised, and just as with `#find`, this
  # behaviour can be controlled through the `:match` and `:exact` options.
  #
  # It is possible to omit the first parameter, in that case, the selector is
  # assumed to be of the type set in {Capybara.configure default_selector}.
  #
  #     within('div#delivery-address') do
  #       fill_in('Street', with: '12 Main Street')
  #     end
  #
  # Note that a lot of uses of {#within} can be replaced more succinctly with
  # chaining:
  #
  #     find('div#delivery-address').fill_in('Street', with: '12 Main Street')
  #
  # @overload within
  # @overload within
  # @raise [Capybara::ElementNotFound] If the scope can't be found before time expires
  def within(*args, **kw_args); end

  # Executes the given block within the context of a node. {#within} takes the
  # same options as {Capybara::Node::Finders#find #find}, as well as a block. For the duration of the
  # block, any command to Capybara will be handled as though it were scoped
  # to the given element.
  #
  #     within(:xpath, './/div[@id="delivery-address"]') do
  #       fill_in('Street', with: '12 Main Street')
  #     end
  #
  # Just as with `#find`, if multiple elements match the selector given to
  # {#within}, an error will be raised, and just as with `#find`, this
  # behaviour can be controlled through the `:match` and `:exact` options.
  #
  # It is possible to omit the first parameter, in that case, the selector is
  # assumed to be of the type set in {Capybara.configure default_selector}.
  #
  #     within('div#delivery-address') do
  #       fill_in('Street', with: '12 Main Street')
  #     end
  #
  # Note that a lot of uses of {#within} can be replaced more succinctly with
  # chaining:
  #
  #     find('div#delivery-address').fill_in('Street', with: '12 Main Street')
  #
  # @overload within
  # @overload within
  # @raise [Capybara::ElementNotFound] If the scope can't be found before time expires
  def within_element(*args, **kw_args); end

  # Execute the given block within the a specific fieldset given the id or legend of that fieldset.
  #
  # @param locator [String] Id or legend of the fieldset
  def within_fieldset(locator, &block); end

  # Execute the given block within the given iframe using given frame, frame name/id or index.
  # May not be supported by all drivers.
  #
  # @overload within_frame
  # @overload within_frame
  # @overload within_frame
  def within_frame(*args, **kw_args); end

  # Execute the given block within the a specific table given the id or caption of that table.
  #
  # @param locator [String] Id or caption of the table
  def within_table(locator, &block); end

  # This method does the following:
  #
  # 1. Switches to the given window (it can be located by window instance/lambda/string).
  # 2. Executes the given block (within window located at previous step).
  # 3. Switches back (this step will be invoked even if an exception occurs at the second step).
  #
  # @overload within_window
  # @overload within_window
  # @raise [Capybara::ScopeError] if this method is invoked inside {#within_frame} method
  # @return value returned by the block
  def within_window(window_or_proc); end

  private

  def _find_frame(*args, **kw_args); end

  # @raise [Capybara::ScopeError]
  def _switch_to_window(window = T.unsafe(nil), **options, &window_locator); end

  # @raise [Capybara::WindowError]
  def _switch_to_window_by_locator; end

  def accept_modal(type, text_or_options, options, &blk); end
  def adjust_server_port(uri); end
  def default_fn(extension); end
  def dismiss_modal(type, text_or_options, options, &blk); end
  def driver_args(args); end
  def element_script_result(arg); end
  def modal_options(text = T.unsafe(nil), **options); end
  def open_file(path); end
  def prepare_path(path, extension); end
  def scopes; end
  def synchronize_windows(options, &block); end

  class << self
    # @return [Boolean]
    def instance_created?; end
  end
end

# @api private
Capybara::Session::DOCUMENT_METHODS = T.let(T.unsafe(nil), Array)

Capybara::Session::DSL_METHODS = T.let(T.unsafe(nil), Array)
Capybara::Session::MODAL_METHODS = T.let(T.unsafe(nil), Array)
Capybara::Session::NODE_METHODS = T.let(T.unsafe(nil), Array)
Capybara::Session::SESSION_METHODS = T.let(T.unsafe(nil), Array)

class Capybara::SessionConfig
  # See {Capybara.configure}
  def always_include_port; end

  def always_include_port=(_arg0); end

  # See {Capybara.configure}
  def app_host; end

  def app_host=(url); end

  # See {Capybara.configure}
  def asset_host; end

  def asset_host=(_arg0); end

  # See {Capybara.configure}
  def automatic_label_click; end

  def automatic_label_click=(_arg0); end

  # See {Capybara.configure}
  def automatic_reload; end

  def automatic_reload=(_arg0); end

  # See {Capybara.configure}
  def default_host; end

  def default_host=(url); end

  # See {Capybara.configure}
  def default_max_wait_time; end

  def default_max_wait_time=(_arg0); end

  # See {Capybara.configure}
  def default_normalize_ws; end

  def default_normalize_ws=(_arg0); end

  # See {Capybara.configure}
  def default_selector; end

  def default_selector=(_arg0); end

  # See {Capybara.configure}
  def default_set_options; end

  def default_set_options=(_arg0); end

  # See {Capybara.configure}
  def disable_animation; end

  def disable_animation=(_arg0); end

  # See {Capybara.configure}
  def enable_aria_label; end

  def enable_aria_label=(_arg0); end

  # See {Capybara.configure}
  def enable_aria_role; end

  def enable_aria_role=(_arg0); end

  # See {Capybara.configure}
  def exact; end

  def exact=(_arg0); end
  def exact_text; end
  def exact_text=(_arg0); end

  # See {Capybara.configure}
  def ignore_hidden_elements; end

  def ignore_hidden_elements=(_arg0); end

  # See {Capybara.configure}
  def match; end

  def match=(_arg0); end
  def predicates_wait; end
  def predicates_wait=(_arg0); end

  # See {Capybara.configure}
  def raise_server_errors; end

  def raise_server_errors=(_arg0); end

  # See {Capybara.configure}
  def run_server; end

  def run_server=(_arg0); end

  # See {Capybara.configure}
  def save_path; end

  def save_path=(_arg0); end

  # See {Capybara.configure}
  def server_errors; end

  def server_errors=(errors); end

  # @return [String] The IP address bound by default server
  def server_host; end

  def server_host=(_arg0); end

  # See {Capybara.configure}
  def server_port; end

  def server_port=(_arg0); end

  # See {Capybara.configure}
  def test_id; end

  # Set an attribue to be optionally matched against the locator for builtin selector types.
  # This attribute will be checked by builtin selector types whenever id would normally be checked.
  # If `nil` then it will be ignored.
  #
  # @param id [String, Symbol, nil] Name of the attribute to use as the test id
  def test_id=(id); end

  # See {Capybara.configure}
  def visible_text_only; end

  def visible_text_only=(_arg0); end

  # See {Capybara.configure}
  def w3c_click_offset; end

  def w3c_click_offset=(_arg0); end

  private

  def initialize_copy(other); end
end

Capybara::SessionConfig::OPTIONS = T.let(T.unsafe(nil), Array)

module Capybara::SessionMatchers
  # Asserts that the page has the given path.
  # By default, if passed a full url this will compare against the full url,
  # if passed a path only the path+query portion will be compared, if passed a regexp
  # the comparison will depend on the :url option (path+query by default)
  #
  # @option options
  # @option options
  # @option options
  # @overload assert_current_path
  # @overload assert_current_path
  # @param options [Hash] a customizable set of options
  # @raise [Capybara::ExpectationNotMet] if the assertion hasn't succeeded during wait time
  # @return [true]
  def assert_current_path(path, **options, &optional_filter_block); end

  # Asserts that the page doesn't have the given path.
  # By default, if passed a full url this will compare against the full url,
  # if passed a path only the path+query portion will be compared, if passed a regexp
  # the comparison will depend on the :url option
  #
  # @option options
  # @option options
  # @option options
  # @overload assert_no_current_path
  # @overload assert_no_current_path
  # @param options [Hash] a customizable set of options
  # @raise [Capybara::ExpectationNotMet] if the assertion hasn't succeeded during wait time
  # @return [true]
  def assert_no_current_path(path, **options, &optional_filter_block); end

  # Checks if the page has the given path.
  # By default, if passed a full url this will compare against the full url,
  # if passed a path only the path+query portion will be compared, if passed a regexp
  # the comparison will depend on the :url option
  #
  # @option options
  # @option options
  # @option options
  # @overload has_current_path?
  # @overload has_current_path?
  # @param options [Hash] a customizable set of options
  # @return [Boolean]
  def has_current_path?(path, **options, &optional_filter_block); end

  # Checks if the page doesn't have the given path.
  # By default, if passed a full url this will compare against the full url,
  # if passed a path only the path+query portion will be compared, if passed a regexp
  # the comparison will depend on the :url option
  #
  # @option options
  # @option options
  # @option options
  # @overload has_no_current_path?
  # @overload has_no_current_path?
  # @param options [Hash] a customizable set of options
  # @return [Boolean]
  def has_no_current_path?(path, **options, &optional_filter_block); end

  private

  def _verify_current_path(path, filter_block, **options); end
  def make_predicate(options); end
end

class Capybara::UnselectNotAllowed < ::Capybara::CapybaraError; end
Capybara::VERSION = T.let(T.unsafe(nil), String)

# The {Window} class represents a browser window.
#
# You can get an instance of the class by calling any of:
#
# * {Capybara::Session#windows}
# * {Capybara::Session#current_window}
# * {Capybara::Session#window_opened_by}
# * {Capybara::Session#switch_to_window}
#
# Note that some drivers (e.g. Selenium) support getting size of/resizing/closing only
# current window. So if you invoke such method for:
#
# * window that is current, Capybara will make 2 Selenium method invocations
#   (get handle of current window + get size/resize/close).
# * window that is not current, Capybara will make 4 Selenium method invocations
#   (get handle of current window + switch to given handle + get size/resize/close + switch to original handle)
class Capybara::Window
  # @api private
  # @return [Window] a new instance of Window
  def initialize(session, handle); end

  # @return [Boolean]
  def ==(other); end

  # Close window.
  #
  # If this method was called for window that is current, then after calling this method
  # future invocations of other Capybara methods should raise
  # {Capybara::Driver::Base#no_such_window_error session.driver.no_such_window_error} until another window will be switched to.
  #
  # If this method was called for window that is not current, then after calling this method
  # current window should remain the same as it was before calling this method.
  def close; end

  # @return [Boolean] whether the window is closed
  def closed?; end

  # @return [Boolean] whether this window is the window in which commands are being executed
  def current?; end

  # @return [Boolean]
  def eql?(other); end

  # @return [Boolean] whether the window is not closed
  def exists?; end

  # Fullscreen window.
  #
  # If a particular driver doesn't have concept of fullscreen it may not support this method.
  #
  # If this method was called for window that is not current, then after calling this method
  # current window should remain the same as it was before calling this method.
  def fullscreen; end

  # @return [String] a string that uniquely identifies window within session
  def handle; end

  def hash; end
  def inspect; end

  # Maximize window.
  #
  # If a particular driver (e.g. headless driver) doesn't have concept of maximizing it
  # may not support this method.
  #
  # If this method was called for window that is not current, then after calling this method
  # current window should remain the same as it was before calling this method.
  def maximize; end

  # Resize window.
  #
  # If this method was called for window that is not current, then after calling this method
  # current window should remain the same as it was before calling this method.
  #
  # @param width [Integer] the new window width in pixels
  # @param height [Integer] the new window height in pixels
  def resize_to(width, height); end

  # @return [Capybara::Session] session that this window belongs to
  def session; end

  # Get window size.
  #
  # If this method was called for window that is not current, then after calling this method
  # current window should remain the same as it was before calling this method.
  #
  # @return [Array<(Integer, Integer)>] an array with width and height
  def size; end

  private

  # @raise [Capybara::WindowError]
  def wait_for_stable_size(seconds = T.unsafe(nil)); end
end

class Capybara::WindowError < ::Capybara::CapybaraError; end

module XPath
  include ::XPath::DSL
  extend ::XPath::DSL

  class << self
    def generate; end
  end
end

module XPath::DSL
  def !(*args); end
  def !=(rhs); end
  def %(rhs); end
  def &(rhs); end
  def *(rhs); end
  def +(*expressions); end
  def /(rhs); end
  def <(rhs); end
  def <=(rhs); end
  def ==(rhs); end
  def >(rhs); end
  def >=(rhs); end
  def [](expression); end
  def ancestor(*element_names); end
  def ancestor_or_self(*element_names); end
  def and(rhs); end
  def anywhere(*expressions); end
  def attr(expression); end
  def attribute(*element_names); end
  def axis(name, *element_names); end
  def binary_operator(name, rhs); end
  def boolean(*args); end
  def ceiling(*args); end
  def child(*expressions); end
  def concat(*args); end
  def contains(*args); end
  def contains_word(word); end
  def count(*args); end
  def css(selector); end
  def current; end
  def descendant(*expressions); end
  def descendant_or_self(*element_names); end
  def divide(rhs); end
  def ends_with(suffix); end
  def equals(rhs); end
  def false(*args); end
  def floor(*args); end
  def following(*element_names); end
  def following_sibling(*element_names); end
  def function(name, *arguments); end
  def gt(rhs); end
  def gte(rhs); end
  def id(*args); end
  def inverse(*args); end
  def is(expression); end
  def join(*expressions); end
  def lang(*args); end
  def last; end
  def local_name(*args); end
  def lowercase; end
  def lt(rhs); end
  def lte(rhs); end
  def method(name, *arguments); end
  def minus(rhs); end
  def mod(rhs); end
  def multiply(rhs); end
  def n(*args); end
  def namespace(*element_names); end
  def namespace_uri(*args); end
  def next_sibling(*expressions); end
  def normalize(*args); end
  def normalize_space(*args); end
  def not(*args); end
  def not_equals(rhs); end
  def number(*args); end
  def one_of(*expressions); end
  def or(rhs); end
  def parent(*element_names); end
  def plus(rhs); end
  def position; end
  def preceding(*element_names); end
  def preceding_sibling(*element_names); end
  def previous_sibling(*expressions); end
  def qname; end
  def round(*args); end
  def self(*element_names); end
  def self_axis(*element_names); end
  def starts_with(*args); end
  def string(*args); end
  def string_length(*args); end
  def substring(*args); end
  def substring_after(*args); end
  def substring_before(*args); end
  def sum(*args); end
  def text; end
  def translate(*args); end
  def true(*args); end
  def union(*expressions); end
  def uppercase; end
  def where(expression); end
  def |(rhs); end
  def ~(*args); end
end

XPath::DSL::AXES = T.let(T.unsafe(nil), Array)
XPath::DSL::LOWERCASE_LETTERS = T.let(T.unsafe(nil), String)
XPath::DSL::METHODS = T.let(T.unsafe(nil), Array)
XPath::DSL::OPERATORS = T.let(T.unsafe(nil), Array)
XPath::DSL::UPPERCASE_LETTERS = T.let(T.unsafe(nil), String)

class XPath::Renderer
  def initialize(type); end

  def anywhere(element_names); end
  def attribute(current, name); end
  def axis(current, name, element_names); end
  def binary_operator(name, left, right); end
  def child(current, element_names); end
  def convert_argument(argument); end
  def css(current, selector); end
  def descendant(current, element_names); end
  def function(name, *arguments); end
  def is(one, two); end
  def join(*expressions); end
  def literal(node); end
  def render(node); end
  def string_literal(string); end
  def text(current); end
  def this_node; end
  def union(*expressions); end
  def variable(name); end
  def where(on, condition); end

  private

  def valid_xml_name?(name); end
  def with_element_conditions(expression, element_names); end

  class << self
    def render(node, type); end
  end
end
