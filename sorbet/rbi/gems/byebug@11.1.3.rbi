# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `byebug` gem.
# Please instead update this file by running `bin/tapioca gem byebug`.

# Reopen main module to define the library version
#
# source://byebug//lib/byebug/helpers/reflection.rb#3
module Byebug
  include ::Byebug::Helpers::ReflectionHelper
  extend ::Byebug::Helpers::ReflectionHelper
  extend ::Byebug

  # Debugger's display expressions
  #
  # source://byebug//lib/byebug/core.rb#31
  def displays; end

  # Debugger's display expressions
  #
  # source://byebug//lib/byebug/core.rb#31
  def displays=(_arg0); end

  # Configuration file used for startup commands. Default value is .byebugrc
  #
  # source://byebug//lib/byebug/core.rb#25
  def init_file; end

  # Configuration file used for startup commands. Default value is .byebugrc
  #
  # source://byebug//lib/byebug/core.rb#25
  def init_file=(_arg0); end

  # Running mode of the debugger. Can be either:
  #
  # * :attached => Attached to a running program through the `byebug` method.
  # * :standalone => Started through `byebug` script.
  # * :off => Ignoring any `byebug` method calls.
  #
  # source://byebug//lib/byebug/core.rb#41
  def mode; end

  # Running mode of the debugger. Can be either:
  #
  # * :attached => Attached to a running program through the `byebug` method.
  # * :standalone => Started through `byebug` script.
  # * :off => Ignoring any `byebug` method calls.
  #
  # source://byebug//lib/byebug/core.rb#41
  def mode=(_arg0); end

  # Runs normal byebug initialization scripts.
  #
  # Reads and executes the commands from init file (if any) in the current
  # working directory. This is only done if the current directory is different
  # from your home directory. Thus, you can have more than one init file, one
  # generic in your home directory, and another, specific to the program you
  # are debugging, in the directory where you invoke byebug.
  #
  # source://byebug//lib/byebug/core.rb#52
  def run_init_script; end

  private

  def add_catchpoint(_arg0); end
  def breakpoints; end
  def catchpoints; end
  def contexts; end
  def current_context; end
  def debug_load(*_arg0); end
  def lock; end
  def post_mortem=(_arg0); end
  def post_mortem?; end
  def raised_exception; end

  # List of folders to load rc files from
  #
  # @note Files will be loaded in the order specified here.
  #
  # source://byebug//lib/byebug/core.rb#102
  def rc_dirs; end

  # Runs a initialization script file
  #
  # source://byebug//lib/byebug/core.rb#91
  def run_rc_file(rc_file); end

  def start; end
  def started?; end
  def stop; end
  def stoppable?; end
  def thread_context(_arg0); end
  def tracing=(_arg0); end
  def tracing?; end
  def unlock; end
  def verbose=(_arg0); end
  def verbose?; end

  class << self
    # The actual port that the control server is started at
    #
    # source://byebug//lib/byebug/remote.rb#25
    def actual_control_port; end

    # The actual port that the server is started at
    #
    # source://byebug//lib/byebug/remote.rb#20
    def actual_port; end

    def add_catchpoint(_arg0); end

    # Starts byebug, and stops at the first line of user's code.
    #
    # source://byebug//lib/byebug/attacher.rb#10
    def attach; end

    def breakpoints; end
    def catchpoints; end
    def contexts; end
    def current_context; end
    def debug_load(*_arg0); end

    # Saves information about the unhandled exception and gives a byebug
    # prompt back to the user before program termination.
    #
    # source://byebug//lib/byebug/core.rb#76
    def handle_post_mortem; end

    # Interrupts the current thread
    #
    # source://byebug//lib/byebug/remote.rb#32
    def interrupt; end

    # source://byebug//lib/byebug/core.rb#61
    def load_settings; end

    def lock; end

    # source://byebug//lib/byebug/remote.rb#59
    def parse_host_and_port(host_port_spec); end

    def post_mortem=(_arg0); end
    def post_mortem?; end
    def raised_exception; end

    # source://byebug//lib/byebug/attacher.rb#21
    def spawn(host = T.unsafe(nil), port = T.unsafe(nil)); end

    def start; end

    # Connects to the remote byebug
    #
    # source://byebug//lib/byebug/remote.rb#55
    def start_client(host = T.unsafe(nil), port = T.unsafe(nil)); end

    # Starts the remote server control thread
    #
    # source://byebug//lib/byebug/remote.rb#48
    def start_control(host = T.unsafe(nil), port = T.unsafe(nil)); end

    # Starts the remote server main thread
    #
    # source://byebug//lib/byebug/remote.rb#39
    def start_server(host = T.unsafe(nil), port = T.unsafe(nil)); end

    def started?; end
    def stop; end
    def stoppable?; end
    def thread_context(_arg0); end
    def tracing=(_arg0); end
    def tracing?; end
    def unlock; end
    def verbose=(_arg0); end
    def verbose?; end

    # If in remote mode, wait for the remote connection
    #
    # source://byebug//lib/byebug/remote.rb#17
    def wait_connection; end

    # If in remote mode, wait for the remote connection
    #
    # source://byebug//lib/byebug/remote.rb#17
    def wait_connection=(_arg0); end

    private

    # source://byebug//lib/byebug/remote.rb#66
    def client; end

    # source://byebug//lib/byebug/remote.rb#76
    def control; end

    # source://byebug//lib/byebug/remote.rb#70
    def server; end
  end
end

# Setting for automatically invoking IRB on every stop.
#
# source://byebug//lib/byebug/settings/autoirb.rb#10
class Byebug::AutoirbSetting < ::Byebug::Setting
  # @return [AutoirbSetting] a new instance of AutoirbSetting
  #
  # source://byebug//lib/byebug/settings/autoirb.rb#13
  def initialize; end

  # source://byebug//lib/byebug/settings/autoirb.rb#17
  def banner; end

  # source://byebug//lib/byebug/settings/autoirb.rb#25
  def value; end

  # source://byebug//lib/byebug/settings/autoirb.rb#21
  def value=(val); end
end

# source://byebug//lib/byebug/settings/autoirb.rb#11
Byebug::AutoirbSetting::DEFAULT = T.let(T.unsafe(nil), Integer)

# Setting for automatically listing source code on every stop.
#
# source://byebug//lib/byebug/settings/autolist.rb#10
class Byebug::AutolistSetting < ::Byebug::Setting
  # @return [AutolistSetting] a new instance of AutolistSetting
  #
  # source://byebug//lib/byebug/settings/autolist.rb#13
  def initialize; end

  # source://byebug//lib/byebug/settings/autolist.rb#17
  def banner; end

  # source://byebug//lib/byebug/settings/autolist.rb#25
  def value; end

  # source://byebug//lib/byebug/settings/autolist.rb#21
  def value=(val); end
end

# source://byebug//lib/byebug/settings/autolist.rb#11
Byebug::AutolistSetting::DEFAULT = T.let(T.unsafe(nil), Integer)

# Setting for automatically invoking Pry on every stop.
#
# source://byebug//lib/byebug/settings/autopry.rb#10
class Byebug::AutoprySetting < ::Byebug::Setting
  # @return [AutoprySetting] a new instance of AutoprySetting
  #
  # source://byebug//lib/byebug/settings/autopry.rb#13
  def initialize; end

  # source://byebug//lib/byebug/settings/autopry.rb#17
  def banner; end

  # source://byebug//lib/byebug/settings/autopry.rb#25
  def value; end

  # source://byebug//lib/byebug/settings/autopry.rb#21
  def value=(val); end
end

# source://byebug//lib/byebug/settings/autopry.rb#11
Byebug::AutoprySetting::DEFAULT = T.let(T.unsafe(nil), Integer)

# Setting for automatically saving previously entered commands to history
# when exiting the debugger.
#
# source://byebug//lib/byebug/settings/autosave.rb#10
class Byebug::AutosaveSetting < ::Byebug::Setting
  # source://byebug//lib/byebug/settings/autosave.rb#13
  def banner; end
end

# source://byebug//lib/byebug/settings/autosave.rb#11
Byebug::AutosaveSetting::DEFAULT = T.let(T.unsafe(nil), TrueClass)

# Command to display short paths in file names.
#
# For example, when displaying source code information.
#
# source://byebug//lib/byebug/settings/basename.rb#11
class Byebug::BasenameSetting < ::Byebug::Setting
  # source://byebug//lib/byebug/settings/basename.rb#12
  def banner; end
end

# Implements breakpoint functionality
#
# source://byebug//lib/byebug/commands/break.rb#13
class Byebug::BreakCommand < ::Byebug::Command
  include ::Byebug::Helpers::EvalHelper
  include ::Byebug::Helpers::FileHelper
  include ::Byebug::Helpers::ParseHelper

  # source://byebug//lib/byebug/commands/break.rb#40
  def execute; end

  private

  # source://byebug//lib/byebug/commands/break.rb#83
  def add_line_breakpoint(file, line); end

  # source://byebug//lib/byebug/commands/break.rb#54
  def line_breakpoint(location); end

  # source://byebug//lib/byebug/commands/break.rb#65
  def method_breakpoint(location); end

  # source://byebug//lib/byebug/commands/break.rb#74
  def target_object(str); end

  # source://byebug//lib/byebug/commands/break.rb#104
  def valid_breakpoints_for(path, line); end

  class << self
    # source://byebug//lib/byebug/commands/break.rb#24
    def description; end

    # source://byebug//lib/byebug/commands/break.rb#20
    def regexp; end

    # source://byebug//lib/byebug/commands/break.rb#36
    def short_description; end
  end
end

# Implements breakpoints
#
# source://byebug//lib/byebug/breakpoint.rb#7
class Byebug::Breakpoint
  def initialize(_arg0, _arg1, _arg2); end

  def enabled=(_arg0); end
  def enabled?; end
  def expr; end
  def expr=(_arg0); end
  def hit_condition; end
  def hit_condition=(_arg0); end
  def hit_count; end
  def hit_value; end
  def hit_value=(_arg0); end
  def id; end

  # Prints all information associated to the breakpoint
  #
  # source://byebug//lib/byebug/breakpoint.rb#105
  def inspect; end

  def pos; end
  def source; end

  class << self
    # Adds a new breakpoint
    #
    # @param file [String]
    # @param line [Fixnum]
    # @param expr [String]
    #
    # source://byebug//lib/byebug/breakpoint.rb#29
    def add(file, line, expr = T.unsafe(nil)); end

    # First breakpoint, in order of creation
    #
    # source://byebug//lib/byebug/breakpoint.rb#11
    def first; end

    # Last breakpoint, in order of creation
    #
    # source://byebug//lib/byebug/breakpoint.rb#18
    def last; end

    # True if there's no breakpoints
    #
    # @return [Boolean]
    #
    # source://byebug//lib/byebug/breakpoint.rb#98
    def none?; end

    # Returns true if a breakpoint could be set in line number +lineno+ in file
    # name +filename.
    #
    # @return [Boolean]
    #
    # source://byebug//lib/byebug/breakpoint.rb#91
    def potential_line?(filename, lineno); end

    # Returns an array of line numbers in file named +filename+ where
    # breakpoints could be set. The list will contain an entry for each
    # distinct line event call so it is possible (and possibly useful) for a
    # line number appear more than once.
    #
    # @param filename [String] File name to inspect for possible breakpoints
    #
    # source://byebug//lib/byebug/breakpoint.rb#52
    def potential_lines(filename); end

    # Removes a breakpoint
    #
    # @param id [integer] breakpoint number
    #
    # source://byebug//lib/byebug/breakpoint.rb#40
    def remove(id); end

    private

    # source://byebug//lib/byebug/breakpoint.rb#63
    def potential_lines_with_trace_points(iseq, lines); end

    # source://byebug//lib/byebug/breakpoint.rb#74
    def potential_lines_without_trace_points(iseq, lines); end
  end
end

# Setting to customize the verbosity level for stack frames.
#
# source://byebug//lib/byebug/settings/callstyle.rb#9
class Byebug::CallstyleSetting < ::Byebug::Setting
  # source://byebug//lib/byebug/settings/callstyle.rb#12
  def banner; end

  # source://byebug//lib/byebug/settings/callstyle.rb#16
  def to_s; end
end

# source://byebug//lib/byebug/settings/callstyle.rb#10
Byebug::CallstyleSetting::DEFAULT = T.let(T.unsafe(nil), String)

# Implements exception catching.
#
# Enables the user to catch unhandled assertion when they happen.
#
# source://byebug//lib/byebug/commands/catch.rb#12
class Byebug::CatchCommand < ::Byebug::Command
  include ::Byebug::Helpers::EvalHelper

  # source://byebug//lib/byebug/commands/catch.rb#38
  def execute; end

  private

  # source://byebug//lib/byebug/commands/catch.rb#57
  def add(exception); end

  # source://byebug//lib/byebug/commands/catch.rb#64
  def clear; end

  # source://byebug//lib/byebug/commands/catch.rb#68
  def info; end

  # source://byebug//lib/byebug/commands/catch.rb#50
  def remove(exception); end

  class << self
    # source://byebug//lib/byebug/commands/catch.rb#21
    def description; end

    # source://byebug//lib/byebug/commands/catch.rb#17
    def regexp; end

    # source://byebug//lib/byebug/commands/catch.rb#34
    def short_description; end
  end
end

# Parent class of all byebug commands.
#
# Subclass it and name the subclass ending with the word Command to implement
# your own custom command.
#
# class MyCustomCommand < Command
#   def self.regexp
#     /custom_regexp/
#   end
#
#   def self.description
#     "Custom long desc"
#   end
#
#   def.short_description
#     "Custom short desc"
#   end
#
#   def execute
#     # My command's implementation
#   end
# end
#
# @example Define a custom command
#
# source://byebug//lib/byebug/command.rb#33
class Byebug::Command
  extend ::Forwardable
  extend ::Byebug::Helpers::StringHelper

  # @return [Command] a new instance of Command
  #
  # source://byebug//lib/byebug/command.rb#38
  def initialize(processor, input = T.unsafe(nil)); end

  # source://byebug//lib/byebug/command.rb#51
  def arguments; end

  # source://forwardable/1.3.3/forwardable.rb#231
  def confirm(*args, **_arg1, &block); end

  # source://byebug//lib/byebug/command.rb#43
  def context; end

  # source://forwardable/1.3.3/forwardable.rb#231
  def errmsg(*args, **_arg1, &block); end

  # source://byebug//lib/byebug/command.rb#47
  def frame; end

  # source://forwardable/1.3.3/forwardable.rb#231
  def help(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def match(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def pr(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def prc(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def print(*args, **_arg1, &block); end

  # Returns the value of attribute processor.
  #
  # source://byebug//lib/byebug/command.rb#36
  def processor; end

  # source://forwardable/1.3.3/forwardable.rb#231
  def prv(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def puts(*args, **_arg1, &block); end

  class << self
    # Special methods to allow command filtering in processors
    #
    # source://byebug//lib/byebug/command.rb#69
    def allow_in_control; end

    # Special methods to allow command filtering in processors
    #
    # source://byebug//lib/byebug/command.rb#69
    def allow_in_control=(_arg0); end

    # Special methods to allow command filtering in processors
    #
    # source://byebug//lib/byebug/command.rb#69
    def allow_in_post_mortem; end

    # Special methods to allow command filtering in processors
    #
    # source://byebug//lib/byebug/command.rb#69
    def allow_in_post_mortem=(_arg0); end

    # source://byebug//lib/byebug/command.rb#73
    def always_run; end

    # Sets the attribute always_run
    #
    # @param value the value to set the attribute always_run to.
    #
    # source://byebug//lib/byebug/command.rb#71
    def always_run=(_arg0); end

    # source://byebug//lib/byebug/command.rb#88
    def columnize(width); end

    # Default help text for a command.
    #
    # source://byebug//lib/byebug/command.rb#99
    def help; end

    # Command's regexp match against an input
    #
    # source://byebug//lib/byebug/command.rb#106
    def match(input); end

    # Name of the command, as executed by the user.
    #
    # source://byebug//lib/byebug/command.rb#80
    def to_s; end
  end
end

# Holds an array of subcommands for a command
#
# source://byebug//lib/byebug/command_list.rb#9
class Byebug::CommandList
  include ::Enumerable

  # @return [CommandList] a new instance of CommandList
  #
  # source://byebug//lib/byebug/command_list.rb#12
  def initialize(commands); end

  # source://byebug//lib/byebug/command_list.rb#20
  def each; end

  # source://byebug//lib/byebug/command_list.rb#16
  def match(input); end

  # source://byebug//lib/byebug/command_list.rb#24
  def to_s; end

  private

  # source://byebug//lib/byebug/command_list.rb#30
  def width; end
end

# Custom exception exception to signal "command not found" errors
#
# source://byebug//lib/byebug/errors.rb#7
class Byebug::CommandNotFound < ::NoMethodError
  # @return [CommandNotFound] a new instance of CommandNotFound
  #
  # source://byebug//lib/byebug/errors.rb#8
  def initialize(input, parent = T.unsafe(nil)); end

  private

  # source://byebug//lib/byebug/errors.rb#25
  def build_cmd(*args); end

  # source://byebug//lib/byebug/errors.rb#21
  def help; end

  # source://byebug//lib/byebug/errors.rb#17
  def name; end
end

# Processes commands in regular mode.
#
# You can override this class to create your own command processor that, for
# example, whitelists only certain commands to be executed.
#
# @see PostMortemProcessor for a example
#
# source://byebug//lib/byebug/processors/command_processor.rb#17
class Byebug::CommandProcessor
  include ::Byebug::Helpers::EvalHelper
  extend ::Forwardable

  # @return [CommandProcessor] a new instance of CommandProcessor
  #
  # source://byebug//lib/byebug/processors/command_processor.rb#23
  def initialize(context, interface = T.unsafe(nil)); end

  # source://byebug//lib/byebug/processors/command_processor.rb#64
  def at_breakpoint(brkpt); end

  # source://byebug//lib/byebug/processors/command_processor.rb#70
  def at_catchpoint(exception); end

  # source://byebug//lib/byebug/processors/command_processor.rb#80
  def at_end; end

  # source://byebug//lib/byebug/processors/command_processor.rb#54
  def at_line; end

  # source://byebug//lib/byebug/processors/command_processor.rb#74
  def at_return(return_value); end

  # source://byebug//lib/byebug/processors/command_processor.rb#58
  def at_tracing; end

  # Available commands
  #
  # source://byebug//lib/byebug/processors/command_processor.rb#50
  def command_list; end

  # source://forwardable/1.3.3/forwardable.rb#231
  def commands(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def confirm(*args, **_arg1, &block); end

  # Returns the value of attribute context.
  #
  # source://byebug//lib/byebug/processors/command_processor.rb#21
  def context; end

  # source://forwardable/1.3.3/forwardable.rb#231
  def errmsg(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def frame(*args, **_arg1, &block); end

  # Returns the value of attribute interface.
  #
  # source://byebug//lib/byebug/processors/command_processor.rb#21
  def interface; end

  # source://forwardable/1.3.3/forwardable.rb#231
  def pr(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def prc(*args, **_arg1, &block); end

  # Returns the value of attribute prev_line.
  #
  # source://byebug//lib/byebug/processors/command_processor.rb#20
  def prev_line; end

  # Sets the attribute prev_line
  #
  # @param value the value to set the attribute prev_line to.
  #
  # source://byebug//lib/byebug/processors/command_processor.rb#20
  def prev_line=(_arg0); end

  # source://byebug//lib/byebug/processors/command_processor.rb#31
  def printer; end

  # Let the execution continue
  #
  # source://byebug//lib/byebug/processors/command_processor.rb#87
  def proceed!; end

  # Handle byebug commands.
  #
  # source://byebug//lib/byebug/processors/command_processor.rb#94
  def process_commands; end

  # source://forwardable/1.3.3/forwardable.rb#231
  def prv(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def puts(*args, **_arg1, &block); end

  protected

  # source://byebug//lib/byebug/processors/command_processor.rb#119
  def after_repl; end

  # source://byebug//lib/byebug/processors/command_processor.rb#111
  def before_repl; end

  # Prompt shown before reading a command.
  #
  # source://byebug//lib/byebug/processors/command_processor.rb#107
  def prompt; end

  # Main byebug's REPL
  #
  # source://byebug//lib/byebug/processors/command_processor.rb#126
  def repl; end

  private

  # source://byebug//lib/byebug/processors/command_processor.rb#139
  def auto_cmds_for(run_level); end

  # Run permanent commands.
  #
  # source://byebug//lib/byebug/processors/command_processor.rb#146
  def run_auto_cmds(run_level); end

  # Executes the received input
  #
  # Instantiates a command matching the input and runs it. If a matching
  # command is not found, it evaluates the unknown input.
  #
  # source://byebug//lib/byebug/processors/command_processor.rb#158
  def run_cmd(input); end

  # source://byebug//lib/byebug/processors/command_processor.rb#167
  def safely; end
end

# Implements conditions on breakpoints.
#
# Adds the ability to stop on breakpoints only under certain conditions.
#
# source://byebug//lib/byebug/commands/condition.rb#12
class Byebug::ConditionCommand < ::Byebug::Command
  include ::Byebug::Helpers::ParseHelper

  # source://byebug//lib/byebug/commands/condition.rb#38
  def execute; end

  class << self
    # source://byebug//lib/byebug/commands/condition.rb#21
    def description; end

    # source://byebug//lib/byebug/commands/condition.rb#17
    def regexp; end

    # source://byebug//lib/byebug/commands/condition.rb#34
    def short_description; end
  end
end

# Mantains context information for the debugger and it's the main
# communication point between the library and the C-extension through the
# at_breakpoint, at_catchpoint, at_tracing, at_line and at_return callbacks
#
# source://byebug//lib/byebug/context.rb#14
class Byebug::Context
  include ::Byebug::Helpers::FileHelper
  extend ::Byebug::Helpers::PathHelper
  extend ::Forwardable

  # Breakpoint handler
  #
  # source://byebug//lib/byebug/context.rb#113
  def at_breakpoint(breakpoint); end

  # Catchpoint handler
  #
  # source://byebug//lib/byebug/context.rb#120
  def at_catchpoint(exception); end

  # End of class definition handler
  #
  # source://byebug//lib/byebug/context.rb#136
  def at_end; end

  # Line handler
  #
  # source://byebug//lib/byebug/context.rb#94
  def at_line; end

  # Return handler
  #
  # source://byebug//lib/byebug/context.rb#127
  def at_return(return_value); end

  # Tracing handler
  #
  # source://byebug//lib/byebug/context.rb#104
  def at_tracing; end

  def backtrace; end
  def dead?; end

  # source://forwardable/1.3.3/forwardable.rb#231
  def file(*args, **_arg1, &block); end

  # Reader for the current frame
  #
  # source://byebug//lib/byebug/context.rb#46
  def frame; end

  # Writer for the current frame
  #
  # source://byebug//lib/byebug/context.rb#53
  def frame=(pos); end

  def frame_binding(*_arg0); end
  def frame_class(*_arg0); end
  def frame_file(*_arg0); end
  def frame_line(*_arg0); end
  def frame_method(*_arg0); end
  def frame_self(*_arg0); end

  # Current file, line and source code information
  #
  # source://byebug//lib/byebug/context.rb#70
  def full_location; end

  def ignored?; end

  # source://byebug//lib/byebug/context.rb#87
  def interrupt; end

  # source://forwardable/1.3.3/forwardable.rb#231
  def line(*args, **_arg1, &block); end

  # Current file & line information
  #
  # source://byebug//lib/byebug/context.rb#63
  def location; end

  def resume; end

  # Context's stack size
  #
  # source://byebug//lib/byebug/context.rb#79
  def stack_size; end

  def step_into(*_arg0); end
  def step_out(*_arg0); end
  def step_over(*_arg0); end
  def stop_reason; end
  def suspend; end
  def suspended?; end
  def switch; end
  def thnum; end
  def thread; end
  def tracing; end
  def tracing=(_arg0); end

  private

  # Tells whether a file is ignored by the debugger.
  #
  # @param path [String] filename to be checked.
  # @return [Boolean]
  #
  # source://byebug//lib/byebug/context.rb#153
  def ignored_file?(path); end

  # source://byebug//lib/byebug/context.rb#144
  def processor; end

  class << self
    # List of files byebug will ignore while debugging
    #
    # source://byebug//lib/byebug/context.rb#25
    def ignored_files; end

    # Sets the attribute ignored_files
    #
    # @param value the value to set the attribute ignored_files to.
    #
    # source://byebug//lib/byebug/context.rb#20
    def ignored_files=(_arg0); end

    # source://byebug//lib/byebug/context.rb#32
    def interface; end

    # Sets the attribute interface
    #
    # @param value the value to set the attribute interface to.
    #
    # source://byebug//lib/byebug/context.rb#30
    def interface=(_arg0); end

    # source://byebug//lib/byebug/context.rb#38
    def processor; end

    # Sets the attribute processor
    #
    # @param value the value to set the attribute processor to.
    #
    # source://byebug//lib/byebug/context.rb#36
    def processor=(_arg0); end
  end
end

# Implements the continue command.
#
# Allows the user to continue execution until the next stopping point, a
# specific line number or until program termination.
#
# source://byebug//lib/byebug/commands/continue.rb#13
class Byebug::ContinueCommand < ::Byebug::Command
  include ::Byebug::Helpers::ParseHelper

  # source://byebug//lib/byebug/commands/continue.rb#37
  def execute; end

  private

  # source://byebug//lib/byebug/commands/continue.rb#64
  def modifier; end

  # @return [Boolean]
  #
  # source://byebug//lib/byebug/commands/continue.rb#60
  def unconditionally?; end

  # @return [Boolean]
  #
  # source://byebug//lib/byebug/commands/continue.rb#56
  def until_line?; end

  class << self
    # source://byebug//lib/byebug/commands/continue.rb#20
    def description; end

    # source://byebug//lib/byebug/commands/continue.rb#16
    def regexp; end

    # source://byebug//lib/byebug/commands/continue.rb#33
    def short_description; end
  end
end

# Processes commands when there's not program running
#
# source://byebug//lib/byebug/processors/control_processor.rb#9
class Byebug::ControlProcessor < ::Byebug::CommandProcessor
  # Available commands
  #
  # source://byebug//lib/byebug/processors/control_processor.rb#13
  def commands; end

  # Prompt shown before reading a command.
  #
  # source://byebug//lib/byebug/processors/control_processor.rb#20
  def prompt; end
end

# Spawns a subdebugger and evaluates the given expression
#
# source://byebug//lib/byebug/commands/debug.rb#10
class Byebug::DebugCommand < ::Byebug::Command
  include ::Byebug::Helpers::EvalHelper

  # source://byebug//lib/byebug/commands/debug.rb#32
  def execute; end

  class << self
    # source://byebug//lib/byebug/commands/debug.rb#17
    def description; end

    # source://byebug//lib/byebug/commands/debug.rb#13
    def regexp; end

    # source://byebug//lib/byebug/commands/debug.rb#28
    def short_description; end
  end
end

class Byebug::DebugThread < ::Thread
  class << self
    def inherited; end
  end
end

# Implements breakpoint deletion.
#
# source://byebug//lib/byebug/commands/delete.rb#10
class Byebug::DeleteCommand < ::Byebug::Command
  include ::Byebug::Helpers::ParseHelper

  # source://byebug//lib/byebug/commands/delete.rb#35
  def execute; end

  class << self
    # source://byebug//lib/byebug/commands/delete.rb#20
    def description; end

    # source://byebug//lib/byebug/commands/delete.rb#16
    def regexp; end

    # source://byebug//lib/byebug/commands/delete.rb#31
    def short_description; end
  end
end

# Disabling custom display expressions or breakpoints.
#
# source://byebug//lib/byebug/commands/disable/breakpoints.rb#9
class Byebug::DisableCommand < ::Byebug::Command
  include ::Byebug::Subcommands
  extend ::Byebug::Helpers::ReflectionHelper
  extend ::Byebug::Subcommands::ClassMethods

  class << self
    # source://byebug//lib/byebug/commands/disable.rb#21
    def description; end

    # source://byebug//lib/byebug/commands/disable.rb#17
    def regexp; end

    # source://byebug//lib/byebug/commands/disable.rb#29
    def short_description; end
  end
end

# Disables all or specific breakpoints
#
# source://byebug//lib/byebug/commands/disable/breakpoints.rb#13
class Byebug::DisableCommand::BreakpointsCommand < ::Byebug::Command
  include ::Byebug::Helpers::ParseHelper
  include ::Byebug::Helpers::ToggleHelper

  # source://byebug//lib/byebug/commands/disable/breakpoints.rb#37
  def execute; end

  class << self
    # source://byebug//lib/byebug/commands/disable/breakpoints.rb#22
    def description; end

    # source://byebug//lib/byebug/commands/disable/breakpoints.rb#18
    def regexp; end

    # source://byebug//lib/byebug/commands/disable/breakpoints.rb#33
    def short_description; end
  end
end

# Enables all or specific displays
#
# source://byebug//lib/byebug/commands/disable/display.rb#13
class Byebug::DisableCommand::DisplayCommand < ::Byebug::Command
  include ::Byebug::Helpers::ParseHelper
  include ::Byebug::Helpers::ToggleHelper

  # source://byebug//lib/byebug/commands/disable/display.rb#38
  def execute; end

  class << self
    # source://byebug//lib/byebug/commands/disable/display.rb#22
    def description; end

    # source://byebug//lib/byebug/commands/disable/display.rb#18
    def regexp; end

    # source://byebug//lib/byebug/commands/disable/display.rb#34
    def short_description; end
  end
end

# Custom expressions to be displayed every time the debugger stops.
#
# source://byebug//lib/byebug/commands/display.rb#10
class Byebug::DisplayCommand < ::Byebug::Command
  include ::Byebug::Helpers::EvalHelper

  # source://byebug//lib/byebug/commands/display.rb#35
  def execute; end

  private

  # source://byebug//lib/byebug/commands/display.rb#44
  def display_expression(exp); end

  # source://byebug//lib/byebug/commands/display.rb#60
  def eval_expr(expression); end

  # source://byebug//lib/byebug/commands/display.rb#50
  def print_display_expressions; end

  class << self
    # source://byebug//lib/byebug/commands/display.rb#20
    def description; end

    # source://byebug//lib/byebug/commands/display.rb#16
    def regexp; end

    # source://byebug//lib/byebug/commands/display.rb#31
    def short_description; end
  end
end

# Move the current frame down in the backtrace.
#
# source://byebug//lib/byebug/commands/down.rb#12
class Byebug::DownCommand < ::Byebug::Command
  include ::Byebug::Helpers::FrameHelper
  include ::Byebug::Helpers::ParseHelper

  # source://byebug//lib/byebug/commands/down.rb#36
  def execute; end

  class << self
    # source://byebug//lib/byebug/commands/down.rb#22
    def description; end

    # source://byebug//lib/byebug/commands/down.rb#18
    def regexp; end

    # source://byebug//lib/byebug/commands/down.rb#32
    def short_description; end
  end
end

# Edit a file from byebug's prompt.
#
# source://byebug//lib/byebug/commands/edit.rb#9
class Byebug::EditCommand < ::Byebug::Command
  # source://byebug//lib/byebug/commands/edit.rb#33
  def execute; end

  private

  # source://byebug//lib/byebug/commands/edit.rb#65
  def edit_error(type, file); end

  # source://byebug//lib/byebug/commands/edit.rb#61
  def editor; end

  # source://byebug//lib/byebug/commands/edit.rb#45
  def location(matched); end

  class << self
    # source://byebug//lib/byebug/commands/edit.rb#17
    def description; end

    # source://byebug//lib/byebug/commands/edit.rb#13
    def regexp; end

    # source://byebug//lib/byebug/commands/edit.rb#29
    def short_description; end
  end
end

# Enabling custom display expressions or breakpoints.
#
# source://byebug//lib/byebug/commands/enable/breakpoints.rb#9
class Byebug::EnableCommand < ::Byebug::Command
  include ::Byebug::Subcommands
  extend ::Byebug::Helpers::ReflectionHelper
  extend ::Byebug::Subcommands::ClassMethods

  class << self
    # source://byebug//lib/byebug/commands/enable.rb#21
    def description; end

    # source://byebug//lib/byebug/commands/enable.rb#17
    def regexp; end

    # source://byebug//lib/byebug/commands/enable.rb#29
    def short_description; end
  end
end

# Enables all or specific breakpoints
#
# source://byebug//lib/byebug/commands/enable/breakpoints.rb#13
class Byebug::EnableCommand::BreakpointsCommand < ::Byebug::Command
  include ::Byebug::Helpers::ParseHelper
  include ::Byebug::Helpers::ToggleHelper

  # source://byebug//lib/byebug/commands/enable/breakpoints.rb#37
  def execute; end

  class << self
    # source://byebug//lib/byebug/commands/enable/breakpoints.rb#22
    def description; end

    # source://byebug//lib/byebug/commands/enable/breakpoints.rb#18
    def regexp; end

    # source://byebug//lib/byebug/commands/enable/breakpoints.rb#33
    def short_description; end
  end
end

# Enables all or specific displays
#
# source://byebug//lib/byebug/commands/enable/display.rb#13
class Byebug::EnableCommand::DisplayCommand < ::Byebug::Command
  include ::Byebug::Helpers::ParseHelper
  include ::Byebug::Helpers::ToggleHelper

  # source://byebug//lib/byebug/commands/enable/display.rb#38
  def execute; end

  class << self
    # source://byebug//lib/byebug/commands/enable/display.rb#22
    def description; end

    # source://byebug//lib/byebug/commands/enable/display.rb#18
    def regexp; end

    # source://byebug//lib/byebug/commands/enable/display.rb#34
    def short_description; end
  end
end

# Implements the finish functionality.
#
# Allows the user to continue execution until certain frames are finished.
#
# source://byebug//lib/byebug/commands/finish.rb#12
class Byebug::FinishCommand < ::Byebug::Command
  include ::Byebug::Helpers::ParseHelper

  # source://byebug//lib/byebug/commands/finish.rb#37
  def execute; end

  private

  # source://byebug//lib/byebug/commands/finish.rb#53
  def max_frames; end

  class << self
    # source://byebug//lib/byebug/commands/finish.rb#21
    def description; end

    # source://byebug//lib/byebug/commands/finish.rb#17
    def regexp; end

    # source://byebug//lib/byebug/commands/finish.rb#33
    def short_description; end
  end
end

# Represents a frame in the stack trace
#
# source://byebug//lib/byebug/frame.rb#9
class Byebug::Frame
  include ::Byebug::Helpers::FileHelper

  # @return [Frame] a new instance of Frame
  #
  # source://byebug//lib/byebug/frame.rb#14
  def initialize(context, pos); end

  # source://byebug//lib/byebug/frame.rb#31
  def _binding; end

  # source://byebug//lib/byebug/frame.rb#35
  def _class; end

  # source://byebug//lib/byebug/frame.rb#39
  def _method; end

  # source://byebug//lib/byebug/frame.rb#27
  def _self; end

  # Gets current method arguments for the frame.
  #
  # source://byebug//lib/byebug/frame.rb#62
  def args; end

  # Checks whether the frame is a c-frame
  #
  # @return [Boolean]
  #
  # source://byebug//lib/byebug/frame.rb#141
  def c_frame?; end

  # @return [Boolean]
  #
  # source://byebug//lib/byebug/frame.rb#43
  def current?; end

  # Builds a string containing all available args in the frame number, in a
  # verbose or non verbose way according to the value of the +callstyle+
  # setting
  #
  # source://byebug//lib/byebug/frame.rb#89
  def deco_args; end

  # source://byebug//lib/byebug/frame.rb#76
  def deco_block; end

  # Builds a formatted string containing information about current method call
  #
  # source://byebug//lib/byebug/frame.rb#106
  def deco_call; end

  # Returns the current class in the frame or an empty string if the current
  # +callstyle+ setting is 'short'
  #
  # source://byebug//lib/byebug/frame.rb#72
  def deco_class; end

  # Formatted filename in frame
  #
  # source://byebug//lib/byebug/frame.rb#113
  def deco_file; end

  # source://byebug//lib/byebug/frame.rb#80
  def deco_method; end

  # Properly formatted frame number of frame
  #
  # source://byebug//lib/byebug/frame.rb#120
  def deco_pos; end

  # source://byebug//lib/byebug/frame.rb#19
  def file; end

  # source://byebug//lib/byebug/frame.rb#23
  def line; end

  # Gets local variables for the frame.
  #
  # source://byebug//lib/byebug/frame.rb#50
  def locals; end

  # Formatted mark for the frame.
  #
  # --> marks the current frame
  # Í±-- marks c-frames
  #     marks regular frames
  #
  # source://byebug//lib/byebug/frame.rb#131
  def mark; end

  # Returns the value of attribute pos.
  #
  # source://byebug//lib/byebug/frame.rb#12
  def pos; end

  # source://byebug//lib/byebug/frame.rb#145
  def to_hash; end

  private

  # source://byebug//lib/byebug/frame.rb#158
  def c_args; end

  # source://byebug//lib/byebug/frame.rb#178
  def prefix_and_default(arg_type); end

  # source://byebug//lib/byebug/frame.rb#164
  def ruby_args; end

  # @return [Boolean]
  #
  # source://byebug//lib/byebug/frame.rb#174
  def use_short_style?(arg); end
end

# Move to specific frames in the backtrace.
#
# source://byebug//lib/byebug/commands/frame.rb#12
class Byebug::FrameCommand < ::Byebug::Command
  include ::Byebug::Helpers::FrameHelper
  include ::Byebug::Helpers::ParseHelper

  # source://byebug//lib/byebug/commands/frame.rb#46
  def execute; end

  class << self
    # source://byebug//lib/byebug/commands/frame.rb#22
    def description; end

    # source://byebug//lib/byebug/commands/frame.rb#18
    def regexp; end

    # source://byebug//lib/byebug/commands/frame.rb#42
    def short_description; end
  end
end

# Setting to display full paths in backtraces.
#
# source://byebug//lib/byebug/settings/fullpath.rb#9
class Byebug::FullpathSetting < ::Byebug::Setting
  # source://byebug//lib/byebug/settings/fullpath.rb#12
  def banner; end
end

# source://byebug//lib/byebug/settings/fullpath.rb#10
Byebug::FullpathSetting::DEFAULT = T.let(T.unsafe(nil), TrueClass)

# Ask for help from byebug's prompt.
#
# source://byebug//lib/byebug/commands/help.rb#10
class Byebug::HelpCommand < ::Byebug::Command
  # source://byebug//lib/byebug/commands/help.rb#34
  def execute; end

  private

  # source://byebug//lib/byebug/commands/help.rb#54
  def command; end

  # @raise [CommandNotFound]
  #
  # source://byebug//lib/byebug/commands/help.rb#48
  def help_for(input, cmd); end

  # source://byebug//lib/byebug/commands/help.rb#44
  def help_for_all; end

  # source://byebug//lib/byebug/commands/help.rb#58
  def subcommand; end

  class << self
    # source://byebug//lib/byebug/commands/help.rb#18
    def description; end

    # source://byebug//lib/byebug/commands/help.rb#14
    def regexp; end

    # source://byebug//lib/byebug/commands/help.rb#30
    def short_description; end
  end
end

# source://byebug//lib/byebug/helpers/reflection.rb#4
module Byebug::Helpers; end

# Utilities for interaction with executables
#
# source://byebug//lib/byebug/helpers/bin.rb#8
module Byebug::Helpers::BinHelper
  # source://byebug//lib/byebug/helpers/bin.rb#38
  def executable_file_extensions; end

  # source://byebug//lib/byebug/helpers/bin.rb#24
  def find_executable(path, cmd); end

  # @return [Boolean]
  #
  # source://byebug//lib/byebug/helpers/bin.rb#42
  def real_executable?(file); end

  # source://byebug//lib/byebug/helpers/bin.rb#34
  def search_paths; end

  # Cross-platform way of finding an executable in the $PATH.
  # Adapted from: https://gist.github.com/steakknife/88b6c3837a5e90a08296
  #
  # source://byebug//lib/byebug/helpers/bin.rb#13
  def which(cmd); end
end

# Utilities to assist evaluation of code strings
#
# source://byebug//lib/byebug/helpers/eval.rb#8
module Byebug::Helpers::EvalHelper
  # Evaluates a string containing Ruby code in a specific binding,
  # handling the errors at an error level.
  #
  # source://byebug//lib/byebug/helpers/eval.rb#46
  def error_eval(str, binding = T.unsafe(nil)); end

  # Evaluates an +expression+ that might use or defer execution to threads
  # other than the current one.
  #
  # "frozen" so that nothing gets run. So we need to unlock threads prior
  # to evaluation or we will run into a deadlock.
  #
  # @note This is necessary because when in byebug's prompt, every thread is
  # @param expression [String] Expression to evaluate
  #
  # source://byebug//lib/byebug/helpers/eval.rb#30
  def multiple_thread_eval(expression); end

  # Evaluates an +expression+ in a separate thread.
  #
  # @param expression [String] Expression to evaluate
  #
  # source://byebug//lib/byebug/helpers/eval.rb#14
  def separate_thread_eval(expression); end

  # Evaluates a string containing Ruby code in a specific binding,
  # returning nil in an error happens.
  #
  # source://byebug//lib/byebug/helpers/eval.rb#38
  def silent_eval(str, binding = T.unsafe(nil)); end

  # Evaluates a string containing Ruby code in a specific binding,
  # handling the errors at a warning level.
  #
  # source://byebug//lib/byebug/helpers/eval.rb#54
  def warning_eval(str, binding = T.unsafe(nil)); end

  private

  # Run block temporarily ignoring all TracePoint events.
  #
  # Used to evaluate stuff within Byebug's prompt. Otherwise, any code
  # creating new threads won't be properly evaluated because new threads
  # will get blocked by byebug's main thread.
  #
  # source://byebug//lib/byebug/helpers/eval.rb#91
  def allowing_other_threads; end

  # source://byebug//lib/byebug/helpers/eval.rb#72
  def error_msg(exception); end

  # Runs the given block in a new thread, waits for it to finish and
  # returns the new thread's result.
  #
  # source://byebug//lib/byebug/helpers/eval.rb#105
  def in_new_thread; end

  # source://byebug//lib/byebug/helpers/eval.rb#66
  def msg(exception); end

  # source://byebug//lib/byebug/helpers/eval.rb#60
  def safe_eval(str, binding); end

  # source://byebug//lib/byebug/helpers/eval.rb#113
  def safe_inspect(var); end

  # source://byebug//lib/byebug/helpers/eval.rb#119
  def safe_to_s(var); end

  # source://byebug//lib/byebug/helpers/eval.rb#80
  def warning_msg(exception); end
end

# Utilities for interaction with files
#
# source://byebug//lib/byebug/helpers/file.rb#8
module Byebug::Helpers::FileHelper
  # Reads line number +lineno+ from file named +filename+
  #
  # source://byebug//lib/byebug/helpers/file.rb#19
  def get_line(filename, lineno); end

  # Reads lines of source file +filename+ into an array
  #
  # source://byebug//lib/byebug/helpers/file.rb#12
  def get_lines(filename); end

  # Returns the number of lines in file +filename+ in a portable,
  # one-line-at-a-time way.
  #
  # source://byebug//lib/byebug/helpers/file.rb#30
  def n_lines(filename); end

  # Regularize file name.
  #
  # source://byebug//lib/byebug/helpers/file.rb#37
  def normalize(filename); end

  # A short version of a long path
  #
  # source://byebug//lib/byebug/helpers/file.rb#48
  def shortpath(fullpath); end

  # True for special files like -e, false otherwise
  #
  # @return [Boolean]
  #
  # source://byebug//lib/byebug/helpers/file.rb#58
  def virtual_file?(name); end
end

# Utilities to assist frame navigation
#
# source://byebug//lib/byebug/helpers/frame.rb#8
module Byebug::Helpers::FrameHelper
  # source://byebug//lib/byebug/helpers/frame.rb#16
  def jump_frames(steps); end

  # source://byebug//lib/byebug/helpers/frame.rb#9
  def switch_to_frame(frame); end

  private

  # source://byebug//lib/byebug/helpers/frame.rb#22
  def adjust_frame(new_frame); end

  # @param step [Integer] A positive or negative integer
  # @return [Integer] +1 if step is positive / -1 if negative
  #
  # source://byebug//lib/byebug/helpers/frame.rb#60
  def direction(step); end

  # source://byebug//lib/byebug/helpers/frame.rb#51
  def frame_err(msg); end

  # Convert a possibly negative index to a positive index from the start
  # of the callstack. -1 is the last position in the stack and so on.
  #
  # @param i [Integer] Integer to be converted in a proper positive index.
  #
  # source://byebug//lib/byebug/helpers/frame.rb#70
  def index_from_start(index); end

  # source://byebug//lib/byebug/helpers/frame.rb#30
  def navigate_to_frame(jump_no); end

  # @return [Boolean]
  #
  # source://byebug//lib/byebug/helpers/frame.rb#47
  def out_of_bounds?(pos); end
end

# Utilities to assist command parsing
#
# source://byebug//lib/byebug/helpers/parse.rb#8
module Byebug::Helpers::ParseHelper
  # Parses +str+ of command +cmd+ as an integer between +min+ and +max+.
  #
  # If either +min+ or +max+ is nil, that value has no bound.
  #
  # purpose.
  #
  # @todo Remove the `cmd` parameter. It has nothing to do with the method's
  #
  # source://byebug//lib/byebug/helpers/parse.rb#17
  def get_int(str, cmd, min = T.unsafe(nil), max = T.unsafe(nil)); end

  # @return +str+ as an integer or 1 if +str+ is empty.
  #
  # source://byebug//lib/byebug/helpers/parse.rb#51
  def parse_steps(str, cmd); end

  # @return [Boolean] true if code is syntactically correct for Ruby, false otherwise
  #
  # source://byebug//lib/byebug/helpers/parse.rb#35
  def syntax_valid?(code); end

  private

  # Temporarily disable output to $stderr
  #
  # source://byebug//lib/byebug/helpers/parse.rb#65
  def without_stderr; end
end

# Utilities for managing gem paths
#
# source://byebug//lib/byebug/helpers/path.rb#8
module Byebug::Helpers::PathHelper
  # source://byebug//lib/byebug/helpers/path.rb#29
  def all_files; end

  # source://byebug//lib/byebug/helpers/path.rb#9
  def bin_file; end

  # source://byebug//lib/byebug/helpers/path.rb#25
  def gem_files; end

  # source://byebug//lib/byebug/helpers/path.rb#17
  def lib_files; end

  # source://byebug//lib/byebug/helpers/path.rb#13
  def root_path; end

  # source://byebug//lib/byebug/helpers/path.rb#21
  def test_files; end

  private

  # source://byebug//lib/byebug/helpers/path.rb#35
  def glob_for(dir); end
end

# Reflection utilitie
#
# source://byebug//lib/byebug/helpers/reflection.rb#8
module Byebug::Helpers::ReflectionHelper
  # List of "command" classes in the including module
  #
  # source://byebug//lib/byebug/helpers/reflection.rb#12
  def commands; end
end

# Utilities for interaction with strings
#
# source://byebug//lib/byebug/helpers/string.rb#8
module Byebug::Helpers::StringHelper
  # Converts +str+ from an_underscored-or-dasherized_string to
  # ACamelizedString.
  #
  # source://byebug//lib/byebug/helpers/string.rb#13
  def camelize(str); end

  # Removes a number of leading whitespace for each input line.
  #
  # source://byebug//lib/byebug/helpers/string.rb#28
  def deindent(str, leading_spaces: T.unsafe(nil)); end

  # Improves indentation and spacing in +str+ for readability in Byebug's
  # command prompt.
  #
  # source://byebug//lib/byebug/helpers/string.rb#21
  def prettify(str); end
end

# Utilities for thread subcommands
#
# source://byebug//lib/byebug/helpers/thread.rb#8
module Byebug::Helpers::ThreadHelper
  # source://byebug//lib/byebug/helpers/thread.rb#30
  def context_from_thread(thnum); end

  # @return [Boolean]
  #
  # source://byebug//lib/byebug/helpers/thread.rb#26
  def current_thread?(ctx); end

  # source://byebug//lib/byebug/helpers/thread.rb#9
  def display_context(ctx); end

  # source://byebug//lib/byebug/helpers/thread.rb#13
  def thread_arguments(ctx); end

  private

  # source://byebug//lib/byebug/helpers/thread.rb#62
  def debug_flag(ctx); end

  # @todo Check whether it is Byebug.current_context or context
  #
  # source://byebug//lib/byebug/helpers/thread.rb#47
  def location(ctx); end

  # source://byebug//lib/byebug/helpers/thread.rb#56
  def status_flag(ctx); end
end

# Utilities to assist breakpoint/display enabling/disabling.
#
# source://byebug//lib/byebug/helpers/toggle.rb#10
module Byebug::Helpers::ToggleHelper
  include ::Byebug::Helpers::ParseHelper

  # source://byebug//lib/byebug/helpers/toggle.rb#13
  def enable_disable_breakpoints(is_enable, args); end

  # source://byebug//lib/byebug/helpers/toggle.rb#26
  def enable_disable_display(is_enable, args); end

  private

  # source://byebug//lib/byebug/helpers/toggle.rb#57
  def n_displays; end

  # source://byebug//lib/byebug/helpers/toggle.rb#41
  def select_breakpoints(is_enable, args); end
end

# Utilities for variable subcommands
#
# source://byebug//lib/byebug/helpers/var.rb#10
module Byebug::Helpers::VarHelper
  include ::Byebug::Helpers::EvalHelper

  # source://byebug//lib/byebug/helpers/var.rb#42
  def var_args; end

  # source://byebug//lib/byebug/helpers/var.rb#21
  def var_global; end

  # source://byebug//lib/byebug/helpers/var.rb#29
  def var_instance(str); end

  # source://byebug//lib/byebug/helpers/var.rb#13
  def var_list(ary, binding = T.unsafe(nil)); end

  # source://byebug//lib/byebug/helpers/var.rb#35
  def var_local; end
end

# Setting to customize the file where byebug's history is saved.
#
# source://byebug//lib/byebug/settings/histfile.rb#9
class Byebug::HistfileSetting < ::Byebug::Setting
  # source://byebug//lib/byebug/settings/histfile.rb#12
  def banner; end

  # source://byebug//lib/byebug/settings/histfile.rb#16
  def to_s; end
end

# source://byebug//lib/byebug/settings/histfile.rb#10
Byebug::HistfileSetting::DEFAULT = T.let(T.unsafe(nil), String)

# Handles byebug's history of commands.
#
# source://byebug//lib/byebug/history.rb#19
class Byebug::History
  # @return [History] a new instance of History
  #
  # source://byebug//lib/byebug/history.rb#22
  def initialize; end

  # Array holding the list of commands in history
  #
  # source://byebug//lib/byebug/history.rb#29
  def buffer; end

  # Discards history.
  #
  # source://byebug//lib/byebug/history.rb#58
  def clear; end

  # Max number of commands to be displayed when no size has been specified.
  #
  # Never more than Setting[:histsize].
  #
  # source://byebug//lib/byebug/history.rb#105
  def default_max_size; end

  # Whether a specific command should not be stored in history.
  #
  # For now, empty lines and consecutive duplicates.
  #
  # @return [Boolean]
  #
  # source://byebug//lib/byebug/history.rb#123
  def ignore?(buf); end

  # Array of ids of the last +number+ commands.
  #
  # source://byebug//lib/byebug/history.rb#96
  def last_ids(number); end

  # Removes a command from Readline's history.
  #
  # source://byebug//lib/byebug/history.rb#75
  def pop; end

  # Adds a new command to Readline's history.
  #
  # source://byebug//lib/byebug/history.rb#65
  def push(cmd); end

  # Restores history from disk.
  #
  # source://byebug//lib/byebug/history.rb#36
  def restore; end

  # Saves history to disk.
  #
  # source://byebug//lib/byebug/history.rb#45
  def save; end

  # Returns the value of attribute size.
  #
  # source://byebug//lib/byebug/history.rb#20
  def size; end

  # Sets the attribute size
  #
  # @param value the value to set the attribute size to.
  #
  # source://byebug//lib/byebug/history.rb#20
  def size=(_arg0); end

  # Max number of commands to be displayed when a size has been specified.
  #
  # The only bound here is not showing more items than available.
  #
  # source://byebug//lib/byebug/history.rb#114
  def specific_max_size(number); end

  # Prints the requested numbers of history entries.
  #
  # source://byebug//lib/byebug/history.rb#83
  def to_s(n_cmds); end
end

# Show history of byebug commands.
#
# source://byebug//lib/byebug/commands/history.rb#10
class Byebug::HistoryCommand < ::Byebug::Command
  include ::Byebug::Helpers::ParseHelper

  # source://byebug//lib/byebug/commands/history.rb#31
  def execute; end

  class << self
    # source://byebug//lib/byebug/commands/history.rb#19
    def description; end

    # source://byebug//lib/byebug/commands/history.rb#15
    def regexp; end

    # source://byebug//lib/byebug/commands/history.rb#27
    def short_description; end
  end
end

# Setting to customize the number of byebug commands to be saved in history.
#
# source://byebug//lib/byebug/settings/histsize.rb#9
class Byebug::HistsizeSetting < ::Byebug::Setting
  # source://byebug//lib/byebug/settings/histsize.rb#12
  def banner; end

  # source://byebug//lib/byebug/settings/histsize.rb#16
  def to_s; end
end

# source://byebug//lib/byebug/settings/histsize.rb#10
Byebug::HistsizeSetting::DEFAULT = T.let(T.unsafe(nil), Integer)

# Shows info about different aspects of the debugger.
#
# source://byebug//lib/byebug/commands/info/breakpoints.rb#7
class Byebug::InfoCommand < ::Byebug::Command
  include ::Byebug::Subcommands
  extend ::Byebug::Helpers::ReflectionHelper
  extend ::Byebug::Subcommands::ClassMethods

  class << self
    # source://byebug//lib/byebug/commands/info.rb#25
    def description; end

    # source://byebug//lib/byebug/commands/info.rb#21
    def regexp; end

    # source://byebug//lib/byebug/commands/info.rb#33
    def short_description; end
  end
end

# Information about current breakpoints
#
# source://byebug//lib/byebug/commands/info/breakpoints.rb#11
class Byebug::InfoCommand::BreakpointsCommand < ::Byebug::Command
  # source://byebug//lib/byebug/commands/info/breakpoints.rb#30
  def execute; end

  private

  # source://byebug//lib/byebug/commands/info/breakpoints.rb#47
  def info_breakpoint(brkpt); end

  class << self
    # source://byebug//lib/byebug/commands/info/breakpoints.rb#18
    def description; end

    # source://byebug//lib/byebug/commands/info/breakpoints.rb#14
    def regexp; end

    # source://byebug//lib/byebug/commands/info/breakpoints.rb#26
    def short_description; end
  end
end

# Information about display expressions
#
# source://byebug//lib/byebug/commands/info/display.rb#11
class Byebug::InfoCommand::DisplayCommand < ::Byebug::Command
  # source://byebug//lib/byebug/commands/info/display.rb#30
  def execute; end

  class << self
    # source://byebug//lib/byebug/commands/info/display.rb#18
    def description; end

    # source://byebug//lib/byebug/commands/info/display.rb#14
    def regexp; end

    # source://byebug//lib/byebug/commands/info/display.rb#26
    def short_description; end
  end
end

# Information about a particular source file
#
# source://byebug//lib/byebug/commands/info/file.rb#13
class Byebug::InfoCommand::FileCommand < ::Byebug::Command
  include ::Byebug::Helpers::FileHelper
  include ::Byebug::Helpers::StringHelper

  # source://byebug//lib/byebug/commands/info/file.rb#38
  def execute; end

  private

  # source://byebug//lib/byebug/commands/info/file.rb#55
  def info_file_basic(file); end

  # source://byebug//lib/byebug/commands/info/file.rb#63
  def info_file_breakpoints(file); end

  # source://byebug//lib/byebug/commands/info/file.rb#70
  def info_file_mtime(file); end

  # source://byebug//lib/byebug/commands/info/file.rb#74
  def info_file_sha1(file); end

  class << self
    # source://byebug//lib/byebug/commands/info/file.rb#23
    def description; end

    # source://byebug//lib/byebug/commands/info/file.rb#19
    def regexp; end

    # source://byebug//lib/byebug/commands/info/file.rb#34
    def short_description; end
  end
end

# Information about current location
#
# source://byebug//lib/byebug/commands/info/line.rb#11
class Byebug::InfoCommand::LineCommand < ::Byebug::Command
  # source://byebug//lib/byebug/commands/info/line.rb#30
  def execute; end

  class << self
    # source://byebug//lib/byebug/commands/info/line.rb#18
    def description; end

    # source://byebug//lib/byebug/commands/info/line.rb#14
    def regexp; end

    # source://byebug//lib/byebug/commands/info/line.rb#26
    def short_description; end
  end
end

# Information about arguments of the current method/block
#
# source://byebug//lib/byebug/commands/info/program.rb#11
class Byebug::InfoCommand::ProgramCommand < ::Byebug::Command
  # source://byebug//lib/byebug/commands/info/program.rb#30
  def execute; end

  private

  # source://byebug//lib/byebug/commands/info/program.rb#37
  def format_stop_reason(stop_reason); end

  class << self
    # source://byebug//lib/byebug/commands/info/program.rb#18
    def description; end

    # source://byebug//lib/byebug/commands/info/program.rb#14
    def regexp; end

    # source://byebug//lib/byebug/commands/info/program.rb#26
    def short_description; end
  end
end

# Main Interface class
#
# Contains common functionality to all implemented interfaces.
#
# source://byebug//lib/byebug/interface.rb#16
class Byebug::Interface
  include ::Byebug::Helpers::FileHelper

  # @return [Interface] a new instance of Interface
  #
  # source://byebug//lib/byebug/interface.rb#22
  def initialize; end

  # Restores history according to +autosave+ setting.
  #
  # source://byebug//lib/byebug/interface.rb#118
  def autorestore; end

  # Saves or clears history according to +autosave+ setting.
  #
  # source://byebug//lib/byebug/interface.rb#111
  def autosave; end

  # source://byebug//lib/byebug/interface.rb#105
  def close; end

  # Returns the value of attribute command_queue.
  #
  # source://byebug//lib/byebug/interface.rb#19
  def command_queue; end

  # Sets the attribute command_queue
  #
  # @param value the value to set the attribute command_queue to.
  #
  # source://byebug//lib/byebug/interface.rb#19
  def command_queue=(_arg0); end

  # Confirms user introduced an affirmative response to the input stream.
  #
  # source://byebug//lib/byebug/interface.rb#101
  def confirm(prompt); end

  # Prints an error message to the error stream.
  #
  # source://byebug//lib/byebug/interface.rb#80
  def errmsg(message); end

  # Returns the value of attribute error.
  #
  # source://byebug//lib/byebug/interface.rb#20
  def error; end

  # Returns the value of attribute history.
  #
  # source://byebug//lib/byebug/interface.rb#19
  def history; end

  # Sets the attribute history
  #
  # @param value the value to set the attribute history to.
  #
  # source://byebug//lib/byebug/interface.rb#19
  def history=(_arg0); end

  # Returns the value of attribute input.
  #
  # source://byebug//lib/byebug/interface.rb#20
  def input; end

  # source://byebug//lib/byebug/interface.rb#28
  def last_if_empty(input); end

  # Returns the value of attribute output.
  #
  # source://byebug//lib/byebug/interface.rb#20
  def output; end

  # Reads a new line from the interface's input stream.
  #
  # read now was empty.
  #
  # @return [String] New string read or the previous string if the string
  #
  # source://byebug//lib/byebug/interface.rb#70
  def prepare_input(prompt); end

  # Prints an output message to the output stream without a final "\n".
  #
  # source://byebug//lib/byebug/interface.rb#94
  def print(message); end

  # Prints an output message to the output stream.
  #
  # source://byebug//lib/byebug/interface.rb#87
  def puts(message); end

  # Pops a command from the input stream.
  #
  # source://byebug//lib/byebug/interface.rb#35
  def read_command(prompt); end

  # Pushes lines in +filename+ to the command queue.
  #
  # source://byebug//lib/byebug/interface.rb#44
  def read_file(filename); end

  # Reads a new line from the interface's input stream, parses it into
  # commands and saves it to history.
  #
  # @return [String] Representing something to be run by the debugger.
  #
  # source://byebug//lib/byebug/interface.rb#54
  def read_input(prompt, save_hist = T.unsafe(nil)); end

  private

  # Splits a command line of the form "cmd1 ; cmd2 ; ... ; cmdN" into an
  # array of commands: [cmd1, cmd2, ..., cmdN]
  #
  # source://byebug//lib/byebug/interface.rb#128
  def split_commands(cmd_line); end
end

# Interrupting execution of current thread.
#
# source://byebug//lib/byebug/commands/interrupt.rb#9
class Byebug::InterruptCommand < ::Byebug::Command
  # source://byebug//lib/byebug/commands/interrupt.rb#28
  def execute; end

  class << self
    # source://byebug//lib/byebug/commands/interrupt.rb#16
    def description; end

    # source://byebug//lib/byebug/commands/interrupt.rb#12
    def regexp; end

    # source://byebug//lib/byebug/commands/interrupt.rb#24
    def short_description; end
  end
end

# Enter IRB from byebug's prompt
#
# source://byebug//lib/byebug/commands/irb.rb#11
class Byebug::IrbCommand < ::Byebug::Command
  # source://byebug//lib/byebug/commands/irb.rb#30
  def execute; end

  private

  # source://byebug//lib/byebug/commands/irb.rb#40
  def with_clean_argv; end

  class << self
    # source://byebug//lib/byebug/commands/irb.rb#18
    def description; end

    # source://byebug//lib/byebug/commands/irb.rb#14
    def regexp; end

    # source://byebug//lib/byebug/commands/irb.rb#26
    def short_description; end
  end
end

# Send custom signals to the debugged program.
#
# source://byebug//lib/byebug/commands/kill.rb#9
class Byebug::KillCommand < ::Byebug::Command
  # source://byebug//lib/byebug/commands/kill.rb#30
  def execute; end

  class << self
    # source://byebug//lib/byebug/commands/kill.rb#16
    def description; end

    # source://byebug//lib/byebug/commands/kill.rb#12
    def regexp; end

    # source://byebug//lib/byebug/commands/kill.rb#26
    def short_description; end
  end
end

# Setting to enable/disable linetracing.
#
# source://byebug//lib/byebug/settings/linetrace.rb#9
class Byebug::LinetraceSetting < ::Byebug::Setting
  # source://byebug//lib/byebug/settings/linetrace.rb#10
  def banner; end

  # source://byebug//lib/byebug/settings/linetrace.rb#18
  def value; end

  # source://byebug//lib/byebug/settings/linetrace.rb#14
  def value=(val); end
end

# List parts of the source code.
#
# source://byebug//lib/byebug/commands/list.rb#12
class Byebug::ListCommand < ::Byebug::Command
  include ::Byebug::Helpers::FileHelper
  include ::Byebug::Helpers::ParseHelper

  # source://forwardable/1.3.3/forwardable.rb#231
  def amend_final(*args, **_arg1, &block); end

  # source://byebug//lib/byebug/commands/list.rb#40
  def execute; end

  # source://forwardable/1.3.3/forwardable.rb#231
  def max_line(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def size(*args, **_arg1, &block); end

  private

  # Set line range to be printed by list
  #
  # @return first line number to list
  # @return last line number to list
  #
  # source://byebug//lib/byebug/commands/list.rb#79
  def auto_range(direction); end

  # Show a range of lines in the current file.
  #
  # @param min [Integer] Lower bound
  # @param max [Integer] Upper bound
  #
  # source://byebug//lib/byebug/commands/list.rb#115
  def display_lines(min, max); end

  # @param range [String] A string with an integer range format
  # @return [String] The lower bound of the given range
  #
  # source://byebug//lib/byebug/commands/list.rb#126
  def lower_bound(range); end

  # source://byebug//lib/byebug/commands/list.rb#105
  def move(line, size, direction = T.unsafe(nil)); end

  # source://byebug//lib/byebug/commands/list.rb#89
  def parse_range(input); end

  # Line range to be printed by `list`.
  #
  # If <input> is set, range is parsed from it.
  #
  # Otherwise it's automatically chosen.
  #
  # source://byebug//lib/byebug/commands/list.rb#60
  def range(input); end

  # source://byebug//lib/byebug/commands/list.rb#152
  def source_file_formatter; end

  # @param str [String] A string with an integer range format
  # @return [Array] The upper & lower bounds of the given range
  #
  # source://byebug//lib/byebug/commands/list.rb#144
  def split_range(str); end

  # @param range [String] A string with an integer range format
  # @return [String] The upper bound of the given range
  #
  # source://byebug//lib/byebug/commands/list.rb#135
  def upper_bound(range); end

  # @return [Boolean]
  #
  # source://byebug//lib/byebug/commands/list.rb#69
  def valid_range?(first, last); end

  class << self
    # source://byebug//lib/byebug/commands/list.rb#22
    def description; end

    # source://byebug//lib/byebug/commands/list.rb#18
    def regexp; end

    # source://byebug//lib/byebug/commands/list.rb#36
    def short_description; end
  end
end

# Setting to customize the number of source code lines to be displayed every
# time the "list" command is invoked.
#
# source://byebug//lib/byebug/settings/listsize.rb#10
class Byebug::ListsizeSetting < ::Byebug::Setting
  # source://byebug//lib/byebug/settings/listsize.rb#13
  def banner; end

  # source://byebug//lib/byebug/settings/listsize.rb#17
  def to_s; end
end

# source://byebug//lib/byebug/settings/listsize.rb#11
Byebug::ListsizeSetting::DEFAULT = T.let(T.unsafe(nil), Integer)

# Interface class for standard byebug use.
#
# source://byebug//lib/byebug/interfaces/local_interface.rb#7
class Byebug::LocalInterface < ::Byebug::Interface
  # @return [LocalInterface] a new instance of LocalInterface
  #
  # source://byebug//lib/byebug/interfaces/local_interface.rb#10
  def initialize; end

  # Reads a single line of input using Readline. If Ctrl-D is pressed, it
  # returns "continue", meaning that program's execution will go on.
  #
  # @param prompt Prompt to be displayed.
  #
  # source://byebug//lib/byebug/interfaces/local_interface.rb#23
  def readline(prompt); end

  # Yields the block handling Ctrl-C the following way: if pressed while
  # waiting for input, the line is reset to only the prompt and we ask for
  # input again.
  #
  # @note Any external 'INT' traps are overriden during this method.
  #
  # source://byebug//lib/byebug/interfaces/local_interface.rb#34
  def with_repl_like_sigint; end

  # Disable any Readline completion procs.
  #
  # Other gems, for example, IRB could've installed completion procs that are
  # dependent on them being loaded. Disable those while byebug is the REPL
  # making use of Readline.
  #
  # source://byebug//lib/byebug/interfaces/local_interface.rb#51
  def without_readline_completion; end
end

# source://byebug//lib/byebug/interfaces/local_interface.rb#8
Byebug::LocalInterface::EOF_ALIAS = T.let(T.unsafe(nil), String)

# Show methods of specific classes/modules/objects.
#
# source://byebug//lib/byebug/commands/method.rb#10
class Byebug::MethodCommand < ::Byebug::Command
  include ::Byebug::Helpers::EvalHelper

  # source://byebug//lib/byebug/commands/method.rb#37
  def execute; end

  class << self
    # source://byebug//lib/byebug/commands/method.rb#19
    def description; end

    # source://byebug//lib/byebug/commands/method.rb#15
    def regexp; end

    # source://byebug//lib/byebug/commands/method.rb#33
    def short_description; end
  end
end

# Implements the next functionality.
#
# Allows the user the continue execution until the next instruction in the
# current frame.
#
# source://byebug//lib/byebug/commands/next.rb#13
class Byebug::NextCommand < ::Byebug::Command
  include ::Byebug::Helpers::ParseHelper

  # source://byebug//lib/byebug/commands/next.rb#32
  def execute; end

  class << self
    # source://byebug//lib/byebug/commands/next.rb#20
    def description; end

    # source://byebug//lib/byebug/commands/next.rb#16
    def regexp; end

    # source://byebug//lib/byebug/commands/next.rb#28
    def short_description; end
  end
end

# Port number used for remote debugging
#
# source://byebug//lib/byebug/remote.rb#13
Byebug::PORT = T.let(T.unsafe(nil), Integer)

# Processes commands in post_mortem mode
#
# source://byebug//lib/byebug/processors/post_mortem_processor.rb#9
class Byebug::PostMortemProcessor < ::Byebug::CommandProcessor
  # source://byebug//lib/byebug/processors/post_mortem_processor.rb#10
  def commands; end

  # source://byebug//lib/byebug/processors/post_mortem_processor.rb#14
  def prompt; end
end

# Setting to enable/disable post_mortem mode, i.e., a debugger prompt after
# program termination by unhandled exception.
#
# source://byebug//lib/byebug/settings/post_mortem.rb#10
class Byebug::PostMortemSetting < ::Byebug::Setting
  # @return [PostMortemSetting] a new instance of PostMortemSetting
  #
  # source://byebug//lib/byebug/settings/post_mortem.rb#11
  def initialize; end

  # source://byebug//lib/byebug/settings/post_mortem.rb#15
  def banner; end

  # source://byebug//lib/byebug/settings/post_mortem.rb#23
  def value; end

  # source://byebug//lib/byebug/settings/post_mortem.rb#19
  def value=(val); end
end

# source://byebug//lib/byebug/printers/base.rb#6
module Byebug::Printers; end

# Base printer
#
# source://byebug//lib/byebug/printers/base.rb#10
class Byebug::Printers::Base
  # source://byebug//lib/byebug/printers/base.rb#16
  def type; end

  private

  # source://byebug//lib/byebug/printers/base.rb#55
  def array_of_args(collection, &_block); end

  # source://byebug//lib/byebug/printers/base.rb#49
  def contents; end

  # source://byebug//lib/byebug/printers/base.rb#63
  def contents_files; end

  # @raise [MissedPath]
  #
  # source://byebug//lib/byebug/printers/base.rb#22
  def locate(path); end

  # source://byebug//lib/byebug/printers/base.rb#45
  def parts(path); end

  # source://byebug//lib/byebug/printers/base.rb#35
  def translate(string, args = T.unsafe(nil)); end
end

# source://byebug//lib/byebug/printers/base.rb#12
class Byebug::Printers::Base::MissedArgument < ::StandardError; end

# source://byebug//lib/byebug/printers/base.rb#11
class Byebug::Printers::Base::MissedPath < ::StandardError; end

# source://byebug//lib/byebug/printers/base.rb#14
Byebug::Printers::Base::SEPARATOR = T.let(T.unsafe(nil), String)

# Plain text printer
#
# source://byebug//lib/byebug/printers/plain.rb#10
class Byebug::Printers::Plain < ::Byebug::Printers::Base
  # source://byebug//lib/byebug/printers/plain.rb#11
  def print(path, args = T.unsafe(nil)); end

  # source://byebug//lib/byebug/printers/plain.rb#17
  def print_collection(path, collection, &block); end

  # source://byebug//lib/byebug/printers/plain.rb#25
  def print_variables(variables, *_unused); end

  private

  # source://byebug//lib/byebug/printers/plain.rb#39
  def contents_files; end
end

# Enter Pry from byebug's prompt
#
# source://byebug//lib/byebug/commands/pry.rb#10
class Byebug::PryCommand < ::Byebug::Command
  # source://byebug//lib/byebug/commands/pry.rb#29
  def execute; end

  class << self
    # source://byebug//lib/byebug/commands/pry.rb#17
    def description; end

    # source://byebug//lib/byebug/commands/pry.rb#13
    def regexp; end

    # source://byebug//lib/byebug/commands/pry.rb#25
    def short_description; end
  end
end

# Exit from byebug.
#
# source://byebug//lib/byebug/commands/quit.rb#9
class Byebug::QuitCommand < ::Byebug::Command
  # source://byebug//lib/byebug/commands/quit.rb#33
  def execute; end

  class << self
    # source://byebug//lib/byebug/commands/quit.rb#17
    def description; end

    # source://byebug//lib/byebug/commands/quit.rb#13
    def regexp; end

    # source://byebug//lib/byebug/commands/quit.rb#29
    def short_description; end
  end
end

# source://byebug//lib/byebug/remote/server.rb#6
module Byebug::Remote; end

# Client for remote debugging
#
# source://byebug//lib/byebug/remote/client.rb#10
class Byebug::Remote::Client
  # @return [Client] a new instance of Client
  #
  # source://byebug//lib/byebug/remote/client.rb#13
  def initialize(interface); end

  # Returns the value of attribute interface.
  #
  # source://byebug//lib/byebug/remote/client.rb#11
  def interface; end

  # Returns the value of attribute socket.
  #
  # source://byebug//lib/byebug/remote/client.rb#11
  def socket; end

  # Connects to the remote byebug
  #
  # source://byebug//lib/byebug/remote/client.rb#21
  def start(host = T.unsafe(nil), port = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://byebug//lib/byebug/remote/client.rb#44
  def started?; end

  private

  # source://byebug//lib/byebug/remote/client.rb#50
  def connect_at(host, port); end
end

# Server for remote debugging
#
# source://byebug//lib/byebug/remote/server.rb#10
class Byebug::Remote::Server
  # @return [Server] a new instance of Server
  #
  # source://byebug//lib/byebug/remote/server.rb#13
  def initialize(wait_connection:, &block); end

  # Returns the value of attribute actual_port.
  #
  # source://byebug//lib/byebug/remote/server.rb#11
  def actual_port; end

  # Start the remote debugging server
  #
  # source://byebug//lib/byebug/remote/server.rb#22
  def start(host, port); end

  # Returns the value of attribute wait_connection.
  #
  # source://byebug//lib/byebug/remote/server.rb#11
  def wait_connection; end
end

# Interface class for remote use of byebug.
#
# source://byebug//lib/byebug/interfaces/remote_interface.rb#9
class Byebug::RemoteInterface < ::Byebug::Interface
  # @return [RemoteInterface] a new instance of RemoteInterface
  #
  # source://byebug//lib/byebug/interfaces/remote_interface.rb#10
  def initialize(socket); end

  # source://byebug//lib/byebug/interfaces/remote_interface.rb#41
  def close; end

  # source://byebug//lib/byebug/interfaces/remote_interface.rb#23
  def confirm(prompt); end

  # source://byebug//lib/byebug/interfaces/remote_interface.rb#29
  def print(message); end

  # source://byebug//lib/byebug/interfaces/remote_interface.rb#35
  def puts(message); end

  # source://byebug//lib/byebug/interfaces/remote_interface.rb#17
  def read_command(prompt); end

  # source://byebug//lib/byebug/interfaces/remote_interface.rb#45
  def readline(prompt); end
end

# Restart debugged program from within byebug.
#
# source://byebug//lib/byebug/commands/restart.rb#14
class Byebug::RestartCommand < ::Byebug::Command
  include ::Byebug::Helpers::BinHelper
  include ::Byebug::Helpers::PathHelper

  # source://byebug//lib/byebug/commands/restart.rb#40
  def execute; end

  private

  # source://byebug//lib/byebug/commands/restart.rb#54
  def prepend_byebug_bin(cmd); end

  # source://byebug//lib/byebug/commands/restart.rb#59
  def prepend_ruby_bin(cmd); end

  class << self
    # source://byebug//lib/byebug/commands/restart.rb#25
    def description; end

    # source://byebug//lib/byebug/commands/restart.rb#21
    def regexp; end

    # source://byebug//lib/byebug/commands/restart.rb#36
    def short_description; end
  end
end

# Save current settings to use them in another debug session.
#
# source://byebug//lib/byebug/commands/save.rb#9
class Byebug::SaveCommand < ::Byebug::Command
  # source://byebug//lib/byebug/commands/save.rb#36
  def execute; end

  private

  # source://byebug//lib/byebug/commands/save.rb#50
  def save_breakpoints(file); end

  # source://byebug//lib/byebug/commands/save.rb#56
  def save_catchpoints(file); end

  # source://byebug//lib/byebug/commands/save.rb#62
  def save_displays(file); end

  # source://byebug//lib/byebug/commands/save.rb#66
  def save_settings(file); end

  class << self
    # source://byebug//lib/byebug/commands/save.rb#17
    def description; end

    # source://byebug//lib/byebug/commands/save.rb#13
    def regexp; end

    # source://byebug//lib/byebug/commands/save.rb#32
    def short_description; end
  end
end

# Setting to customize the file where byebug's history is saved.
#
# source://byebug//lib/byebug/settings/savefile.rb#9
class Byebug::SavefileSetting < ::Byebug::Setting
  # source://byebug//lib/byebug/settings/savefile.rb#12
  def banner; end

  # source://byebug//lib/byebug/settings/savefile.rb#16
  def to_s; end
end

# source://byebug//lib/byebug/settings/savefile.rb#10
Byebug::SavefileSetting::DEFAULT = T.let(T.unsafe(nil), String)

# Interface class for command execution from script files.
#
# source://byebug//lib/byebug/interfaces/script_interface.rb#7
class Byebug::ScriptInterface < ::Byebug::Interface
  # @return [ScriptInterface] a new instance of ScriptInterface
  #
  # source://byebug//lib/byebug/interfaces/script_interface.rb#8
  def initialize(file, verbose = T.unsafe(nil)); end

  # source://byebug//lib/byebug/interfaces/script_interface.rb#20
  def close; end

  # source://byebug//lib/byebug/interfaces/script_interface.rb#16
  def read_command(prompt); end

  # source://byebug//lib/byebug/interfaces/script_interface.rb#24
  def readline(*_arg0); end
end

# Processes commands from a file
#
# source://byebug//lib/byebug/processors/script_processor.rb#9
class Byebug::ScriptProcessor < ::Byebug::CommandProcessor
  # source://byebug//lib/byebug/processors/script_processor.rb#28
  def after_repl; end

  # Available commands
  #
  # source://byebug//lib/byebug/processors/script_processor.rb#13
  def commands; end

  # Prompt shown before reading a command.
  #
  # source://byebug//lib/byebug/processors/script_processor.rb#37
  def prompt; end

  # source://byebug//lib/byebug/processors/script_processor.rb#17
  def repl; end

  private

  # source://byebug//lib/byebug/processors/script_processor.rb#43
  def without_exceptions; end
end

# Change byebug settings.
#
# source://byebug//lib/byebug/commands/set.rb#10
class Byebug::SetCommand < ::Byebug::Command
  include ::Byebug::Helpers::ParseHelper

  # source://byebug//lib/byebug/commands/set.rb#42
  def execute; end

  private

  # source://byebug//lib/byebug/commands/set.rb#66
  def get_onoff(arg, default); end

  class << self
    # source://byebug//lib/byebug/commands/set.rb#20
    def description; end

    # source://byebug//lib/byebug/commands/set.rb#38
    def help; end

    # source://byebug//lib/byebug/commands/set.rb#16
    def regexp; end

    # source://byebug//lib/byebug/commands/set.rb#34
    def short_description; end
  end
end

# Parent class for all byebug settings.
#
# source://byebug//lib/byebug/setting.rb#9
class Byebug::Setting
  # @return [Setting] a new instance of Setting
  #
  # source://byebug//lib/byebug/setting.rb#14
  def initialize; end

  # @return [Boolean]
  #
  # source://byebug//lib/byebug/setting.rb#18
  def boolean?; end

  # source://byebug//lib/byebug/setting.rb#28
  def help; end

  # @return [Boolean]
  #
  # source://byebug//lib/byebug/setting.rb#22
  def integer?; end

  # source://byebug//lib/byebug/setting.rb#37
  def to_s; end

  # source://byebug//lib/byebug/setting.rb#32
  def to_sym; end

  # Returns the value of attribute value.
  #
  # source://byebug//lib/byebug/setting.rb#10
  def value; end

  # Sets the attribute value
  #
  # @param value the value to set the attribute value to.
  #
  # source://byebug//lib/byebug/setting.rb#10
  def value=(_arg0); end

  class << self
    # source://byebug//lib/byebug/setting.rb#46
    def [](name); end

    # source://byebug//lib/byebug/setting.rb#50
    def []=(name, value); end

    # source://byebug//lib/byebug/setting.rb#54
    def find(shortcut); end

    # @todo DRY this up. Very similar code exists in the CommandList class
    #
    # source://byebug//lib/byebug/setting.rb#65
    def help_all; end

    # source://byebug//lib/byebug/setting.rb#42
    def settings; end
  end
end

# source://byebug//lib/byebug/setting.rb#12
Byebug::Setting::DEFAULT = T.let(T.unsafe(nil), FalseClass)

# Show byebug settings.
#
# source://byebug//lib/byebug/commands/show.rb#9
class Byebug::ShowCommand < ::Byebug::Command
  # source://byebug//lib/byebug/commands/show.rb#35
  def execute; end

  class << self
    # source://byebug//lib/byebug/commands/show.rb#17
    def description; end

    # source://byebug//lib/byebug/commands/show.rb#31
    def help; end

    # source://byebug//lib/byebug/commands/show.rb#13
    def regexp; end

    # source://byebug//lib/byebug/commands/show.rb#27
    def short_description; end
  end
end

# Allows the user to continue execution until the next breakpoint, as
# long as it is different from the current one
#
# source://byebug//lib/byebug/commands/skip.rb#11
class Byebug::SkipCommand < ::Byebug::Command
  include ::Byebug::Helpers::ParseHelper

  # source://byebug//lib/byebug/commands/skip.rb#70
  def auto_run; end

  # source://byebug//lib/byebug/commands/skip.rb#77
  def execute; end

  # source://byebug//lib/byebug/commands/skip.rb#53
  def initialize_attributes; end

  # source://byebug//lib/byebug/commands/skip.rb#60
  def keep_execution; end

  # source://byebug//lib/byebug/commands/skip.rb#64
  def reset_attributes; end

  class << self
    # source://byebug//lib/byebug/commands/skip.rb#41
    def description; end

    # source://byebug//lib/byebug/commands/skip.rb#18
    def file_line; end

    # Sets the attribute file_line
    #
    # @param value the value to set the attribute file_line to.
    #
    # source://byebug//lib/byebug/commands/skip.rb#15
    def file_line=(_arg0); end

    # source://byebug//lib/byebug/commands/skip.rb#22
    def file_path; end

    # Sets the attribute file_path
    #
    # @param value the value to set the attribute file_path to.
    #
    # source://byebug//lib/byebug/commands/skip.rb#15
    def file_path=(_arg0); end

    # Returns the value of attribute previous_autolist.
    #
    # source://byebug//lib/byebug/commands/skip.rb#16
    def previous_autolist; end

    # source://byebug//lib/byebug/commands/skip.rb#37
    def regexp; end

    # source://byebug//lib/byebug/commands/skip.rb#31
    def restore_autolist; end

    # source://byebug//lib/byebug/commands/skip.rb#26
    def setup_autolist(value); end

    # source://byebug//lib/byebug/commands/skip.rb#49
    def short_description; end
  end
end

# Execute a file containing byebug commands.
#
# It can be used to restore a previously saved debugging session.
#
# source://byebug//lib/byebug/commands/source.rb#11
class Byebug::SourceCommand < ::Byebug::Command
  # source://byebug//lib/byebug/commands/source.rb#31
  def execute; end

  class << self
    # source://byebug//lib/byebug/commands/source.rb#19
    def description; end

    # source://byebug//lib/byebug/commands/source.rb#15
    def regexp; end

    # source://byebug//lib/byebug/commands/source.rb#27
    def short_description; end
  end
end

# Formats specific line ranges in a source file
#
# source://byebug//lib/byebug/source_file_formatter.rb#10
class Byebug::SourceFileFormatter
  include ::Byebug::Helpers::FileHelper

  # @return [SourceFileFormatter] a new instance of SourceFileFormatter
  #
  # source://byebug//lib/byebug/source_file_formatter.rb#15
  def initialize(file, annotator); end

  # source://byebug//lib/byebug/source_file_formatter.rb#67
  def amend(line, ceiling); end

  # source://byebug//lib/byebug/source_file_formatter.rb#51
  def amend_final(line); end

  # source://byebug//lib/byebug/source_file_formatter.rb#47
  def amend_initial(line); end

  # Returns the value of attribute annotator.
  #
  # source://byebug//lib/byebug/source_file_formatter.rb#13
  def annotator; end

  # Returns the value of attribute file.
  #
  # source://byebug//lib/byebug/source_file_formatter.rb#13
  def file; end

  # source://byebug//lib/byebug/source_file_formatter.rb#20
  def lines(min, max); end

  # source://byebug//lib/byebug/source_file_formatter.rb#33
  def lines_around(center); end

  # source://byebug//lib/byebug/source_file_formatter.rb#55
  def max_initial_line; end

  # source://byebug//lib/byebug/source_file_formatter.rb#59
  def max_line; end

  # source://byebug//lib/byebug/source_file_formatter.rb#37
  def range_around(center); end

  # source://byebug//lib/byebug/source_file_formatter.rb#41
  def range_from(min); end

  # source://byebug//lib/byebug/source_file_formatter.rb#63
  def size; end
end

# Setting to enable/disable the display of backtraces when evaluations raise
# errors.
#
# source://byebug//lib/byebug/settings/stack_on_error.rb#10
class Byebug::StackOnErrorSetting < ::Byebug::Setting
  # source://byebug//lib/byebug/settings/stack_on_error.rb#11
  def banner; end
end

# Implements the step functionality.
#
# Allows the user the continue execution until the next instruction, possibily
# in a different frame. Use step to step into method calls or blocks.
#
# source://byebug//lib/byebug/commands/step.rb#13
class Byebug::StepCommand < ::Byebug::Command
  include ::Byebug::Helpers::ParseHelper

  # source://byebug//lib/byebug/commands/step.rb#32
  def execute; end

  class << self
    # source://byebug//lib/byebug/commands/step.rb#20
    def description; end

    # source://byebug//lib/byebug/commands/step.rb#16
    def regexp; end

    # source://byebug//lib/byebug/commands/step.rb#28
    def short_description; end
  end
end

# Subcommand additions.
#
# source://byebug//lib/byebug/subcommands.rb#12
module Byebug::Subcommands
  extend ::Forwardable

  mixes_in_class_methods ::Byebug::Subcommands::ClassMethods

  # Delegates to subcommands or prints help if no subcommand specified.
  #
  # @raise [CommandNotFound]
  #
  # source://byebug//lib/byebug/subcommands.rb#23
  def execute; end

  # source://forwardable/1.3.3/forwardable.rb#231
  def subcommand_list(*args, **_arg1, &block); end

  class << self
    # @private
    #
    # source://byebug//lib/byebug/subcommands.rb#13
    def included(command); end
  end
end

# Class methods added to subcommands
#
# source://byebug//lib/byebug/subcommands.rb#36
module Byebug::Subcommands::ClassMethods
  include ::Byebug::Helpers::ReflectionHelper

  # Default help text for a command with subcommands
  #
  # source://byebug//lib/byebug/subcommands.rb#42
  def help; end

  # Command's subcommands.
  #
  # source://byebug//lib/byebug/subcommands.rb#49
  def subcommand_list; end
end

# Manipulation of Ruby threads
#
# source://byebug//lib/byebug/commands/thread/current.rb#9
class Byebug::ThreadCommand < ::Byebug::Command
  include ::Byebug::Subcommands
  extend ::Byebug::Helpers::ReflectionHelper
  extend ::Byebug::Subcommands::ClassMethods

  class << self
    # source://byebug//lib/byebug/commands/thread.rb#22
    def description; end

    # source://byebug//lib/byebug/commands/thread.rb#18
    def regexp; end

    # source://byebug//lib/byebug/commands/thread.rb#30
    def short_description; end
  end
end

# Information about the current thread
#
# source://byebug//lib/byebug/commands/thread/current.rb#13
class Byebug::ThreadCommand::CurrentCommand < ::Byebug::Command
  include ::Byebug::Helpers::ThreadHelper

  # source://byebug//lib/byebug/commands/thread/current.rb#32
  def execute; end

  class << self
    # source://byebug//lib/byebug/commands/thread/current.rb#20
    def description; end

    # source://byebug//lib/byebug/commands/thread/current.rb#16
    def regexp; end

    # source://byebug//lib/byebug/commands/thread/current.rb#28
    def short_description; end
  end
end

# Information about threads
#
# source://byebug//lib/byebug/commands/thread/list.rb#13
class Byebug::ThreadCommand::ListCommand < ::Byebug::Command
  include ::Byebug::Helpers::ThreadHelper

  # source://byebug//lib/byebug/commands/thread/list.rb#32
  def execute; end

  class << self
    # source://byebug//lib/byebug/commands/thread/list.rb#20
    def description; end

    # source://byebug//lib/byebug/commands/thread/list.rb#16
    def regexp; end

    # source://byebug//lib/byebug/commands/thread/list.rb#28
    def short_description; end
  end
end

# Resumes the specified thread
#
# source://byebug//lib/byebug/commands/thread/resume.rb#13
class Byebug::ThreadCommand::ResumeCommand < ::Byebug::Command
  include ::Byebug::Helpers::ThreadHelper

  # source://byebug//lib/byebug/commands/thread/resume.rb#32
  def execute; end

  class << self
    # source://byebug//lib/byebug/commands/thread/resume.rb#20
    def description; end

    # source://byebug//lib/byebug/commands/thread/resume.rb#16
    def regexp; end

    # source://byebug//lib/byebug/commands/thread/resume.rb#28
    def short_description; end
  end
end

# Stops the specified thread
#
# source://byebug//lib/byebug/commands/thread/stop.rb#13
class Byebug::ThreadCommand::StopCommand < ::Byebug::Command
  include ::Byebug::Helpers::ThreadHelper

  # source://byebug//lib/byebug/commands/thread/stop.rb#32
  def execute; end

  class << self
    # source://byebug//lib/byebug/commands/thread/stop.rb#20
    def description; end

    # source://byebug//lib/byebug/commands/thread/stop.rb#16
    def regexp; end

    # source://byebug//lib/byebug/commands/thread/stop.rb#28
    def short_description; end
  end
end

# Switches to the specified thread
#
# source://byebug//lib/byebug/commands/thread/switch.rb#13
class Byebug::ThreadCommand::SwitchCommand < ::Byebug::Command
  include ::Byebug::Helpers::ThreadHelper

  # source://byebug//lib/byebug/commands/thread/switch.rb#32
  def execute; end

  class << self
    # source://byebug//lib/byebug/commands/thread/switch.rb#20
    def description; end

    # source://byebug//lib/byebug/commands/thread/switch.rb#16
    def regexp; end

    # source://byebug//lib/byebug/commands/thread/switch.rb#28
    def short_description; end
  end
end

class Byebug::ThreadsTable; end

# Show (and possibily stop) at every line that changes a global variable.
#
# source://byebug//lib/byebug/commands/tracevar.rb#9
class Byebug::TracevarCommand < ::Byebug::Command
  # source://byebug//lib/byebug/commands/tracevar.rb#32
  def execute; end

  private

  # source://byebug//lib/byebug/commands/tracevar.rb#48
  def on_change(name, value, stop); end

  class << self
    # source://byebug//lib/byebug/commands/tracevar.rb#16
    def description; end

    # source://byebug//lib/byebug/commands/tracevar.rb#10
    def regexp; end

    # source://byebug//lib/byebug/commands/tracevar.rb#28
    def short_description; end
  end
end

# Remove expressions from display list.
#
# source://byebug//lib/byebug/commands/undisplay.rb#10
class Byebug::UndisplayCommand < ::Byebug::Command
  include ::Byebug::Helpers::ParseHelper

  # source://byebug//lib/byebug/commands/undisplay.rb#35
  def execute; end

  class << self
    # source://byebug//lib/byebug/commands/undisplay.rb#19
    def description; end

    # source://byebug//lib/byebug/commands/undisplay.rb#15
    def regexp; end

    # source://byebug//lib/byebug/commands/undisplay.rb#31
    def short_description; end
  end
end

# Stop tracing a global variable.
#
# source://byebug//lib/byebug/commands/untracevar.rb#9
class Byebug::UntracevarCommand < ::Byebug::Command
  # source://byebug//lib/byebug/commands/untracevar.rb#26
  def execute; end

  class << self
    # source://byebug//lib/byebug/commands/untracevar.rb#14
    def description; end

    # source://byebug//lib/byebug/commands/untracevar.rb#10
    def regexp; end

    # source://byebug//lib/byebug/commands/untracevar.rb#22
    def short_description; end
  end
end

# Move the current frame up in the backtrace.
#
# source://byebug//lib/byebug/commands/up.rb#12
class Byebug::UpCommand < ::Byebug::Command
  include ::Byebug::Helpers::FrameHelper
  include ::Byebug::Helpers::ParseHelper

  # source://byebug//lib/byebug/commands/up.rb#36
  def execute; end

  class << self
    # source://byebug//lib/byebug/commands/up.rb#22
    def description; end

    # source://byebug//lib/byebug/commands/up.rb#18
    def regexp; end

    # source://byebug//lib/byebug/commands/up.rb#32
    def short_description; end
  end
end

# Shows variables and its values
#
# source://byebug//lib/byebug/commands/var/all.rb#9
class Byebug::VarCommand < ::Byebug::Command
  include ::Byebug::Subcommands
  extend ::Byebug::Helpers::ReflectionHelper
  extend ::Byebug::Subcommands::ClassMethods

  class << self
    # source://byebug//lib/byebug/commands/var.rb#25
    def description; end

    # source://byebug//lib/byebug/commands/var.rb#21
    def regexp; end

    # source://byebug//lib/byebug/commands/var.rb#33
    def short_description; end
  end
end

# Shows global, instance and local variables
#
# source://byebug//lib/byebug/commands/var/all.rb#13
class Byebug::VarCommand::AllCommand < ::Byebug::Command
  include ::Byebug::Helpers::EvalHelper
  include ::Byebug::Helpers::VarHelper

  # source://byebug//lib/byebug/commands/var/all.rb#34
  def execute; end

  class << self
    # source://byebug//lib/byebug/commands/var/all.rb#22
    def description; end

    # source://byebug//lib/byebug/commands/var/all.rb#18
    def regexp; end

    # source://byebug//lib/byebug/commands/var/all.rb#30
    def short_description; end
  end
end

# Information about arguments of the current method/block
#
# source://byebug//lib/byebug/commands/var/args.rb#13
class Byebug::VarCommand::ArgsCommand < ::Byebug::Command
  include ::Byebug::Helpers::EvalHelper
  include ::Byebug::Helpers::VarHelper

  # source://byebug//lib/byebug/commands/var/args.rb#34
  def execute; end

  class << self
    # source://byebug//lib/byebug/commands/var/args.rb#22
    def description; end

    # source://byebug//lib/byebug/commands/var/args.rb#18
    def regexp; end

    # source://byebug//lib/byebug/commands/var/args.rb#30
    def short_description; end
  end
end

# Shows constants
#
# source://byebug//lib/byebug/commands/var/const.rb#13
class Byebug::VarCommand::ConstCommand < ::Byebug::Command
  include ::Byebug::Helpers::EvalHelper

  # source://byebug//lib/byebug/commands/var/const.rb#34
  def execute; end

  private

  # source://byebug//lib/byebug/commands/var/const.rb#44
  def str_obj; end

  class << self
    # source://byebug//lib/byebug/commands/var/const.rb#22
    def description; end

    # source://byebug//lib/byebug/commands/var/const.rb#18
    def regexp; end

    # source://byebug//lib/byebug/commands/var/const.rb#30
    def short_description; end
  end
end

# Shows global variables
#
# source://byebug//lib/byebug/commands/var/global.rb#11
class Byebug::VarCommand::GlobalCommand < ::Byebug::Command
  include ::Byebug::Helpers::EvalHelper
  include ::Byebug::Helpers::VarHelper

  # source://byebug//lib/byebug/commands/var/global.rb#32
  def execute; end

  class << self
    # source://byebug//lib/byebug/commands/var/global.rb#20
    def description; end

    # source://byebug//lib/byebug/commands/var/global.rb#16
    def regexp; end

    # source://byebug//lib/byebug/commands/var/global.rb#28
    def short_description; end
  end
end

# Shows instance variables
#
# source://byebug//lib/byebug/commands/var/instance.rb#13
class Byebug::VarCommand::InstanceCommand < ::Byebug::Command
  include ::Byebug::Helpers::EvalHelper
  include ::Byebug::Helpers::VarHelper

  # source://byebug//lib/byebug/commands/var/instance.rb#34
  def execute; end

  class << self
    # source://byebug//lib/byebug/commands/var/instance.rb#22
    def description; end

    # source://byebug//lib/byebug/commands/var/instance.rb#18
    def regexp; end

    # source://byebug//lib/byebug/commands/var/instance.rb#30
    def short_description; end
  end
end

# Shows local variables in current scope
#
# source://byebug//lib/byebug/commands/var/local.rb#13
class Byebug::VarCommand::LocalCommand < ::Byebug::Command
  include ::Byebug::Helpers::EvalHelper
  include ::Byebug::Helpers::VarHelper

  # source://byebug//lib/byebug/commands/var/local.rb#34
  def execute; end

  class << self
    # source://byebug//lib/byebug/commands/var/local.rb#22
    def description; end

    # source://byebug//lib/byebug/commands/var/local.rb#18
    def regexp; end

    # source://byebug//lib/byebug/commands/var/local.rb#30
    def short_description; end
  end
end

# Show current backtrace.
#
# source://byebug//lib/byebug/commands/where.rb#11
class Byebug::WhereCommand < ::Byebug::Command
  include ::Byebug::Helpers::FrameHelper

  # source://byebug//lib/byebug/commands/where.rb#39
  def execute; end

  private

  # source://byebug//lib/byebug/commands/where.rb#45
  def print_backtrace; end

  class << self
    # source://byebug//lib/byebug/commands/where.rb#20
    def description; end

    # source://byebug//lib/byebug/commands/where.rb#16
    def regexp; end

    # source://byebug//lib/byebug/commands/where.rb#35
    def short_description; end
  end
end

# Setting to customize the maximum width of byebug's output.
#
# source://byebug//lib/byebug/settings/width.rb#9
class Byebug::WidthSetting < ::Byebug::Setting
  # source://byebug//lib/byebug/settings/width.rb#12
  def banner; end

  # source://byebug//lib/byebug/settings/width.rb#16
  def to_s; end
end

# source://byebug//lib/byebug/settings/width.rb#10
Byebug::WidthSetting::DEFAULT = T.let(T.unsafe(nil), Integer)

# Extends the extension class to be able to pass information about the
# debugging environment from the c-extension to the user.
#
# source://byebug//lib/byebug/core.rb#113
class Exception
  # Returns the value of attribute __bb_context.
  #
  # source://byebug//lib/byebug/core.rb#114
  def __bb_context; end
end

# Adds a `byebug` method to the Kernel module.
#
# Dropping a `byebug` call anywhere in your code, you get a debug prompt.
#
# source://byebug//lib/byebug/attacher.rb#34
module Kernel
  # source://byebug//lib/byebug/attacher.rb#35
  def byebug; end

  # source://byebug//lib/byebug/attacher.rb#35
  def debugger; end

  # source://byebug//lib/byebug/attacher.rb#41
  def remote_byebug(host = T.unsafe(nil), port = T.unsafe(nil)); end
end
