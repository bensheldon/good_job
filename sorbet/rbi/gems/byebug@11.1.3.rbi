# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `byebug` gem.
# Please instead update this file by running `bin/tapioca gem byebug`.

# Reopen main module to define the library version
module Byebug
  include ::Byebug::Helpers::ReflectionHelper
  extend ::Byebug::Helpers::ReflectionHelper
  extend ::Byebug

  # Debugger's display expressions
  def displays; end

  # Debugger's display expressions
  def displays=(_arg0); end

  # Configuration file used for startup commands. Default value is .byebugrc
  def init_file; end

  # Configuration file used for startup commands. Default value is .byebugrc
  def init_file=(_arg0); end

  # Running mode of the debugger. Can be either:
  #
  # * :attached => Attached to a running program through the `byebug` method.
  # * :standalone => Started through `byebug` script.
  # * :off => Ignoring any `byebug` method calls.
  def mode; end

  # Running mode of the debugger. Can be either:
  #
  # * :attached => Attached to a running program through the `byebug` method.
  # * :standalone => Started through `byebug` script.
  # * :off => Ignoring any `byebug` method calls.
  def mode=(_arg0); end

  # Runs normal byebug initialization scripts.
  #
  # Reads and executes the commands from init file (if any) in the current
  # working directory. This is only done if the current directory is different
  # from your home directory. Thus, you can have more than one init file, one
  # generic in your home directory, and another, specific to the program you
  # are debugging, in the directory where you invoke byebug.
  def run_init_script; end

  private

  def add_catchpoint(_arg0); end
  def breakpoints; end
  def catchpoints; end
  def contexts; end
  def current_context; end
  def debug_load(*_arg0); end
  def lock; end
  def post_mortem=(_arg0); end
  def post_mortem?; end
  def raised_exception; end

  # List of folders to load rc files from
  #
  # @note Files will be loaded in the order specified here.
  def rc_dirs; end

  # Runs a initialization script file
  def run_rc_file(rc_file); end

  def start; end
  def started?; end
  def stop; end
  def stoppable?; end
  def thread_context(_arg0); end
  def tracing=(_arg0); end
  def tracing?; end
  def unlock; end
  def verbose=(_arg0); end
  def verbose?; end

  class << self
    # The actual port that the control server is started at
    def actual_control_port; end

    # The actual port that the server is started at
    def actual_port; end

    def add_catchpoint(_arg0); end

    # Starts byebug, and stops at the first line of user's code.
    def attach; end

    def breakpoints; end
    def catchpoints; end
    def contexts; end
    def current_context; end
    def debug_load(*_arg0); end

    # Saves information about the unhandled exception and gives a byebug
    # prompt back to the user before program termination.
    def handle_post_mortem; end

    # Interrupts the current thread
    def interrupt; end

    def load_settings; end
    def lock; end
    def parse_host_and_port(host_port_spec); end
    def post_mortem=(_arg0); end
    def post_mortem?; end
    def raised_exception; end
    def spawn(host = T.unsafe(nil), port = T.unsafe(nil)); end
    def start; end

    # Connects to the remote byebug
    def start_client(host = T.unsafe(nil), port = T.unsafe(nil)); end

    # Starts the remote server control thread
    def start_control(host = T.unsafe(nil), port = T.unsafe(nil)); end

    # Starts the remote server main thread
    def start_server(host = T.unsafe(nil), port = T.unsafe(nil)); end

    def started?; end
    def stop; end
    def stoppable?; end
    def thread_context(_arg0); end
    def tracing=(_arg0); end
    def tracing?; end
    def unlock; end
    def verbose=(_arg0); end
    def verbose?; end

    # If in remote mode, wait for the remote connection
    def wait_connection; end

    # If in remote mode, wait for the remote connection
    def wait_connection=(_arg0); end

    private

    def client; end
    def control; end
    def server; end
  end
end

# Setting for automatically invoking IRB on every stop.
class Byebug::AutoirbSetting < ::Byebug::Setting
  # @return [AutoirbSetting] a new instance of AutoirbSetting
  def initialize; end

  def banner; end
  def value; end
  def value=(val); end
end

Byebug::AutoirbSetting::DEFAULT = T.let(T.unsafe(nil), Integer)

# Setting for automatically listing source code on every stop.
class Byebug::AutolistSetting < ::Byebug::Setting
  # @return [AutolistSetting] a new instance of AutolistSetting
  def initialize; end

  def banner; end
  def value; end
  def value=(val); end
end

Byebug::AutolistSetting::DEFAULT = T.let(T.unsafe(nil), Integer)

# Setting for automatically invoking Pry on every stop.
class Byebug::AutoprySetting < ::Byebug::Setting
  # @return [AutoprySetting] a new instance of AutoprySetting
  def initialize; end

  def banner; end
  def value; end
  def value=(val); end
end

Byebug::AutoprySetting::DEFAULT = T.let(T.unsafe(nil), Integer)

# Setting for automatically saving previously entered commands to history
# when exiting the debugger.
class Byebug::AutosaveSetting < ::Byebug::Setting
  def banner; end
end

Byebug::AutosaveSetting::DEFAULT = T.let(T.unsafe(nil), TrueClass)

# Command to display short paths in file names.
#
# For example, when displaying source code information.
class Byebug::BasenameSetting < ::Byebug::Setting
  def banner; end
end

# Implements breakpoint functionality
class Byebug::BreakCommand < ::Byebug::Command
  include ::Byebug::Helpers::EvalHelper
  include ::Byebug::Helpers::FileHelper
  include ::Byebug::Helpers::ParseHelper

  def execute; end

  private

  def add_line_breakpoint(file, line); end
  def line_breakpoint(location); end
  def method_breakpoint(location); end
  def target_object(str); end
  def valid_breakpoints_for(path, line); end

  class << self
    def description; end
    def regexp; end
    def short_description; end
  end
end

# Implements breakpoints
class Byebug::Breakpoint
  def initialize(_arg0, _arg1, _arg2); end

  def enabled=(_arg0); end
  def enabled?; end
  def expr; end
  def expr=(_arg0); end
  def hit_condition; end
  def hit_condition=(_arg0); end
  def hit_count; end
  def hit_value; end
  def hit_value=(_arg0); end
  def id; end

  # Prints all information associated to the breakpoint
  def inspect; end

  def pos; end
  def source; end

  class << self
    # Adds a new breakpoint
    #
    # @param file [String]
    # @param line [Fixnum]
    # @param expr [String]
    def add(file, line, expr = T.unsafe(nil)); end

    # First breakpoint, in order of creation
    def first; end

    # Last breakpoint, in order of creation
    def last; end

    # True if there's no breakpoints
    #
    # @return [Boolean]
    def none?; end

    # Returns true if a breakpoint could be set in line number +lineno+ in file
    # name +filename.
    #
    # @return [Boolean]
    def potential_line?(filename, lineno); end

    # Returns an array of line numbers in file named +filename+ where
    # breakpoints could be set. The list will contain an entry for each
    # distinct line event call so it is possible (and possibly useful) for a
    # line number appear more than once.
    #
    # @param filename [String] File name to inspect for possible breakpoints
    def potential_lines(filename); end

    # Removes a breakpoint
    #
    # @param id [integer] breakpoint number
    def remove(id); end

    private

    def potential_lines_with_trace_points(iseq, lines); end
    def potential_lines_without_trace_points(iseq, lines); end
  end
end

# Setting to customize the verbosity level for stack frames.
class Byebug::CallstyleSetting < ::Byebug::Setting
  def banner; end
  def to_s; end
end

Byebug::CallstyleSetting::DEFAULT = T.let(T.unsafe(nil), String)

# Implements exception catching.
#
# Enables the user to catch unhandled assertion when they happen.
class Byebug::CatchCommand < ::Byebug::Command
  include ::Byebug::Helpers::EvalHelper

  def execute; end

  private

  def add(exception); end
  def clear; end
  def info; end
  def remove(exception); end

  class << self
    def description; end
    def regexp; end
    def short_description; end
  end
end

# Parent class of all byebug commands.
#
# Subclass it and name the subclass ending with the word Command to implement
# your own custom command.
#
# class MyCustomCommand < Command
#   def self.regexp
#     /custom_regexp/
#   end
#
#   def self.description
#     "Custom long desc"
#   end
#
#   def.short_description
#     "Custom short desc"
#   end
#
#   def execute
#     # My command's implementation
#   end
# end
#
# @example Define a custom command
class Byebug::Command
  extend ::Forwardable
  extend ::Byebug::Helpers::StringHelper

  # @return [Command] a new instance of Command
  def initialize(processor, input = T.unsafe(nil)); end

  def arguments; end
  def confirm(*args, &block); end
  def context; end
  def errmsg(*args, &block); end
  def frame; end
  def help(*args, &block); end
  def match(*args, &block); end
  def pr(*args, &block); end
  def prc(*args, &block); end
  def print(*args, &block); end

  # Returns the value of attribute processor.
  def processor; end

  def prv(*args, &block); end
  def puts(*args, &block); end

  class << self
    # Special methods to allow command filtering in processors
    def allow_in_control; end

    # Special methods to allow command filtering in processors
    def allow_in_control=(_arg0); end

    # Special methods to allow command filtering in processors
    def allow_in_post_mortem; end

    # Special methods to allow command filtering in processors
    def allow_in_post_mortem=(_arg0); end

    def always_run; end

    # Sets the attribute always_run
    #
    # @param value the value to set the attribute always_run to.
    def always_run=(_arg0); end

    def columnize(width); end

    # Default help text for a command.
    def help; end

    # Command's regexp match against an input
    def match(input); end

    # Name of the command, as executed by the user.
    def to_s; end
  end
end

# Holds an array of subcommands for a command
class Byebug::CommandList
  include ::Enumerable

  # @return [CommandList] a new instance of CommandList
  def initialize(commands); end

  def each; end
  def match(input); end
  def to_s; end

  private

  def width; end
end

# Custom exception exception to signal "command not found" errors
class Byebug::CommandNotFound < ::NoMethodError
  # @return [CommandNotFound] a new instance of CommandNotFound
  def initialize(input, parent = T.unsafe(nil)); end

  private

  def build_cmd(*args); end
  def help; end
  def name; end
end

# Processes commands in regular mode.
#
# You can override this class to create your own command processor that, for
# example, whitelists only certain commands to be executed.
#
# @see PostMortemProcessor for a example
class Byebug::CommandProcessor
  include ::Byebug::Helpers::EvalHelper
  extend ::Forwardable

  # @return [CommandProcessor] a new instance of CommandProcessor
  def initialize(context, interface = T.unsafe(nil)); end

  def at_breakpoint(brkpt); end
  def at_catchpoint(exception); end
  def at_end; end
  def at_line; end
  def at_return(return_value); end
  def at_tracing; end

  # Available commands
  def command_list; end

  def commands(*args, &block); end
  def confirm(*args, &block); end

  # Returns the value of attribute context.
  def context; end

  def errmsg(*args, &block); end
  def frame(*args, &block); end

  # Returns the value of attribute interface.
  def interface; end

  def pr(*args, &block); end
  def prc(*args, &block); end

  # Returns the value of attribute prev_line.
  def prev_line; end

  # Sets the attribute prev_line
  #
  # @param value the value to set the attribute prev_line to.
  def prev_line=(_arg0); end

  def printer; end

  # Let the execution continue
  def proceed!; end

  # Handle byebug commands.
  def process_commands; end

  def prv(*args, &block); end
  def puts(*args, &block); end

  protected

  def after_repl; end
  def before_repl; end

  # Prompt shown before reading a command.
  def prompt; end

  # Main byebug's REPL
  def repl; end

  private

  def auto_cmds_for(run_level); end

  # Run permanent commands.
  def run_auto_cmds(run_level); end

  # Executes the received input
  #
  # Instantiates a command matching the input and runs it. If a matching
  # command is not found, it evaluates the unknown input.
  def run_cmd(input); end

  def safely; end
end

# Implements conditions on breakpoints.
#
# Adds the ability to stop on breakpoints only under certain conditions.
class Byebug::ConditionCommand < ::Byebug::Command
  include ::Byebug::Helpers::ParseHelper

  def execute; end

  class << self
    def description; end
    def regexp; end
    def short_description; end
  end
end

# Mantains context information for the debugger and it's the main
# communication point between the library and the C-extension through the
# at_breakpoint, at_catchpoint, at_tracing, at_line and at_return callbacks
class Byebug::Context
  include ::Byebug::Helpers::FileHelper
  extend ::Byebug::Helpers::PathHelper
  extend ::Forwardable

  # Breakpoint handler
  def at_breakpoint(breakpoint); end

  # Catchpoint handler
  def at_catchpoint(exception); end

  # End of class definition handler
  def at_end; end

  # Line handler
  def at_line; end

  # Return handler
  def at_return(return_value); end

  # Tracing handler
  def at_tracing; end

  def backtrace; end
  def dead?; end
  def file(*args, &block); end

  # Reader for the current frame
  def frame; end

  # Writer for the current frame
  def frame=(pos); end

  def frame_binding(*_arg0); end
  def frame_class(*_arg0); end
  def frame_file(*_arg0); end
  def frame_line(*_arg0); end
  def frame_method(*_arg0); end
  def frame_self(*_arg0); end

  # Current file, line and source code information
  def full_location; end

  def ignored?; end
  def interrupt; end
  def line(*args, &block); end

  # Current file & line information
  def location; end

  def resume; end

  # Context's stack size
  def stack_size; end

  def step_into(*_arg0); end
  def step_out(*_arg0); end
  def step_over(*_arg0); end
  def stop_reason; end
  def suspend; end
  def suspended?; end
  def switch; end
  def thnum; end
  def thread; end
  def tracing; end
  def tracing=(_arg0); end

  private

  # Tells whether a file is ignored by the debugger.
  #
  # @param path [String] filename to be checked.
  # @return [Boolean]
  def ignored_file?(path); end

  def processor; end

  class << self
    # List of files byebug will ignore while debugging
    def ignored_files; end

    # Sets the attribute ignored_files
    #
    # @param value the value to set the attribute ignored_files to.
    def ignored_files=(_arg0); end

    def interface; end

    # Sets the attribute interface
    #
    # @param value the value to set the attribute interface to.
    def interface=(_arg0); end

    def processor; end

    # Sets the attribute processor
    #
    # @param value the value to set the attribute processor to.
    def processor=(_arg0); end
  end
end

# Implements the continue command.
#
# Allows the user to continue execution until the next stopping point, a
# specific line number or until program termination.
class Byebug::ContinueCommand < ::Byebug::Command
  include ::Byebug::Helpers::ParseHelper

  def execute; end

  private

  def modifier; end

  # @return [Boolean]
  def unconditionally?; end

  # @return [Boolean]
  def until_line?; end

  class << self
    def description; end
    def regexp; end
    def short_description; end
  end
end

# Processes commands when there's not program running
class Byebug::ControlProcessor < ::Byebug::CommandProcessor
  # Available commands
  def commands; end

  # Prompt shown before reading a command.
  def prompt; end
end

# Spawns a subdebugger and evaluates the given expression
class Byebug::DebugCommand < ::Byebug::Command
  include ::Byebug::Helpers::EvalHelper

  def execute; end

  class << self
    def description; end
    def regexp; end
    def short_description; end
  end
end

class Byebug::DebugThread < ::Thread
  class << self
    def inherited; end
  end
end

# Implements breakpoint deletion.
class Byebug::DeleteCommand < ::Byebug::Command
  include ::Byebug::Helpers::ParseHelper

  def execute; end

  class << self
    def description; end
    def regexp; end
    def short_description; end
  end
end

# Disabling custom display expressions or breakpoints.
class Byebug::DisableCommand < ::Byebug::Command
  include ::Byebug::Subcommands
  extend ::Byebug::Helpers::ReflectionHelper
  extend ::Byebug::Subcommands::ClassMethods

  class << self
    def description; end
    def regexp; end
    def short_description; end
  end
end

# Disables all or specific breakpoints
class Byebug::DisableCommand::BreakpointsCommand < ::Byebug::Command
  include ::Byebug::Helpers::ParseHelper
  include ::Byebug::Helpers::ToggleHelper

  def execute; end

  class << self
    def description; end
    def regexp; end
    def short_description; end
  end
end

# Enables all or specific displays
class Byebug::DisableCommand::DisplayCommand < ::Byebug::Command
  include ::Byebug::Helpers::ParseHelper
  include ::Byebug::Helpers::ToggleHelper

  def execute; end

  class << self
    def description; end
    def regexp; end
    def short_description; end
  end
end

# Custom expressions to be displayed every time the debugger stops.
class Byebug::DisplayCommand < ::Byebug::Command
  include ::Byebug::Helpers::EvalHelper

  def execute; end

  private

  def display_expression(exp); end
  def eval_expr(expression); end
  def print_display_expressions; end

  class << self
    def description; end
    def regexp; end
    def short_description; end
  end
end

# Move the current frame down in the backtrace.
class Byebug::DownCommand < ::Byebug::Command
  include ::Byebug::Helpers::FrameHelper
  include ::Byebug::Helpers::ParseHelper

  def execute; end

  class << self
    def description; end
    def regexp; end
    def short_description; end
  end
end

# Edit a file from byebug's prompt.
class Byebug::EditCommand < ::Byebug::Command
  def execute; end

  private

  def edit_error(type, file); end
  def editor; end
  def location(matched); end

  class << self
    def description; end
    def regexp; end
    def short_description; end
  end
end

# Enabling custom display expressions or breakpoints.
class Byebug::EnableCommand < ::Byebug::Command
  include ::Byebug::Subcommands
  extend ::Byebug::Helpers::ReflectionHelper
  extend ::Byebug::Subcommands::ClassMethods

  class << self
    def description; end
    def regexp; end
    def short_description; end
  end
end

# Enables all or specific breakpoints
class Byebug::EnableCommand::BreakpointsCommand < ::Byebug::Command
  include ::Byebug::Helpers::ParseHelper
  include ::Byebug::Helpers::ToggleHelper

  def execute; end

  class << self
    def description; end
    def regexp; end
    def short_description; end
  end
end

# Enables all or specific displays
class Byebug::EnableCommand::DisplayCommand < ::Byebug::Command
  include ::Byebug::Helpers::ParseHelper
  include ::Byebug::Helpers::ToggleHelper

  def execute; end

  class << self
    def description; end
    def regexp; end
    def short_description; end
  end
end

# Implements the finish functionality.
#
# Allows the user to continue execution until certain frames are finished.
class Byebug::FinishCommand < ::Byebug::Command
  include ::Byebug::Helpers::ParseHelper

  def execute; end

  private

  def max_frames; end

  class << self
    def description; end
    def regexp; end
    def short_description; end
  end
end

# Represents a frame in the stack trace
class Byebug::Frame
  include ::Byebug::Helpers::FileHelper

  # @return [Frame] a new instance of Frame
  def initialize(context, pos); end

  def _binding; end
  def _class; end
  def _method; end
  def _self; end

  # Gets current method arguments for the frame.
  def args; end

  # Checks whether the frame is a c-frame
  #
  # @return [Boolean]
  def c_frame?; end

  # @return [Boolean]
  def current?; end

  # Builds a string containing all available args in the frame number, in a
  # verbose or non verbose way according to the value of the +callstyle+
  # setting
  def deco_args; end

  def deco_block; end

  # Builds a formatted string containing information about current method call
  def deco_call; end

  # Returns the current class in the frame or an empty string if the current
  # +callstyle+ setting is 'short'
  def deco_class; end

  # Formatted filename in frame
  def deco_file; end

  def deco_method; end

  # Properly formatted frame number of frame
  def deco_pos; end

  def file; end
  def line; end

  # Gets local variables for the frame.
  def locals; end

  # Formatted mark for the frame.
  #
  # --> marks the current frame
  # Í±-- marks c-frames
  #     marks regular frames
  def mark; end

  # Returns the value of attribute pos.
  def pos; end

  def to_hash; end

  private

  def c_args; end
  def prefix_and_default(arg_type); end
  def ruby_args; end

  # @return [Boolean]
  def use_short_style?(arg); end
end

# Move to specific frames in the backtrace.
class Byebug::FrameCommand < ::Byebug::Command
  include ::Byebug::Helpers::FrameHelper
  include ::Byebug::Helpers::ParseHelper

  def execute; end

  class << self
    def description; end
    def regexp; end
    def short_description; end
  end
end

# Setting to display full paths in backtraces.
class Byebug::FullpathSetting < ::Byebug::Setting
  def banner; end
end

Byebug::FullpathSetting::DEFAULT = T.let(T.unsafe(nil), TrueClass)

# Ask for help from byebug's prompt.
class Byebug::HelpCommand < ::Byebug::Command
  def execute; end

  private

  def command; end

  # @raise [CommandNotFound]
  def help_for(input, cmd); end

  def help_for_all; end
  def subcommand; end

  class << self
    def description; end
    def regexp; end
    def short_description; end
  end
end

module Byebug::Helpers; end

# Utilities for interaction with executables
module Byebug::Helpers::BinHelper
  def executable_file_extensions; end
  def find_executable(path, cmd); end

  # @return [Boolean]
  def real_executable?(file); end

  def search_paths; end

  # Cross-platform way of finding an executable in the $PATH.
  # Adapted from: https://gist.github.com/steakknife/88b6c3837a5e90a08296
  def which(cmd); end
end

# Utilities to assist evaluation of code strings
module Byebug::Helpers::EvalHelper
  # Evaluates a string containing Ruby code in a specific binding,
  # handling the errors at an error level.
  def error_eval(str, binding = T.unsafe(nil)); end

  # Evaluates an +expression+ that might use or defer execution to threads
  # other than the current one.
  #
  # "frozen" so that nothing gets run. So we need to unlock threads prior
  # to evaluation or we will run into a deadlock.
  #
  # @note This is necessary because when in byebug's prompt, every thread is
  # @param expression [String] Expression to evaluate
  def multiple_thread_eval(expression); end

  # Evaluates an +expression+ in a separate thread.
  #
  # @param expression [String] Expression to evaluate
  def separate_thread_eval(expression); end

  # Evaluates a string containing Ruby code in a specific binding,
  # returning nil in an error happens.
  def silent_eval(str, binding = T.unsafe(nil)); end

  # Evaluates a string containing Ruby code in a specific binding,
  # handling the errors at a warning level.
  def warning_eval(str, binding = T.unsafe(nil)); end

  private

  # Run block temporarily ignoring all TracePoint events.
  #
  # Used to evaluate stuff within Byebug's prompt. Otherwise, any code
  # creating new threads won't be properly evaluated because new threads
  # will get blocked by byebug's main thread.
  def allowing_other_threads; end

  def error_msg(exception); end

  # Runs the given block in a new thread, waits for it to finish and
  # returns the new thread's result.
  def in_new_thread; end

  def msg(exception); end
  def safe_eval(str, binding); end
  def safe_inspect(var); end
  def safe_to_s(var); end
  def warning_msg(exception); end
end

# Utilities for interaction with files
module Byebug::Helpers::FileHelper
  # Reads line number +lineno+ from file named +filename+
  def get_line(filename, lineno); end

  # Reads lines of source file +filename+ into an array
  def get_lines(filename); end

  # Returns the number of lines in file +filename+ in a portable,
  # one-line-at-a-time way.
  def n_lines(filename); end

  # Regularize file name.
  def normalize(filename); end

  # A short version of a long path
  def shortpath(fullpath); end

  # True for special files like -e, false otherwise
  #
  # @return [Boolean]
  def virtual_file?(name); end
end

# Utilities to assist frame navigation
module Byebug::Helpers::FrameHelper
  def jump_frames(steps); end
  def switch_to_frame(frame); end

  private

  def adjust_frame(new_frame); end

  # @param step [Integer] A positive or negative integer
  # @return [Integer] +1 if step is positive / -1 if negative
  def direction(step); end

  def frame_err(msg); end

  # Convert a possibly negative index to a positive index from the start
  # of the callstack. -1 is the last position in the stack and so on.
  #
  # @param i [Integer] Integer to be converted in a proper positive index.
  def index_from_start(index); end

  def navigate_to_frame(jump_no); end

  # @return [Boolean]
  def out_of_bounds?(pos); end
end

# Utilities to assist command parsing
module Byebug::Helpers::ParseHelper
  # Parses +str+ of command +cmd+ as an integer between +min+ and +max+.
  #
  # If either +min+ or +max+ is nil, that value has no bound.
  #
  # purpose.
  #
  # @todo Remove the `cmd` parameter. It has nothing to do with the method's
  def get_int(str, cmd, min = T.unsafe(nil), max = T.unsafe(nil)); end

  # @return +str+ as an integer or 1 if +str+ is empty.
  def parse_steps(str, cmd); end

  # @return [Boolean] true if code is syntactically correct for Ruby, false otherwise
  def syntax_valid?(code); end

  private

  # Temporarily disable output to $stderr
  def without_stderr; end
end

# Utilities for managing gem paths
module Byebug::Helpers::PathHelper
  def all_files; end
  def bin_file; end
  def gem_files; end
  def lib_files; end
  def root_path; end
  def test_files; end

  private

  def glob_for(dir); end
end

# Reflection utilitie
module Byebug::Helpers::ReflectionHelper
  # List of "command" classes in the including module
  def commands; end
end

# Utilities for interaction with strings
module Byebug::Helpers::StringHelper
  # Converts +str+ from an_underscored-or-dasherized_string to
  # ACamelizedString.
  def camelize(str); end

  # Removes a number of leading whitespace for each input line.
  def deindent(str, leading_spaces: T.unsafe(nil)); end

  # Improves indentation and spacing in +str+ for readability in Byebug's
  # command prompt.
  def prettify(str); end
end

# Utilities for thread subcommands
module Byebug::Helpers::ThreadHelper
  def context_from_thread(thnum); end

  # @return [Boolean]
  def current_thread?(ctx); end

  def display_context(ctx); end
  def thread_arguments(ctx); end

  private

  def debug_flag(ctx); end

  # @todo Check whether it is Byebug.current_context or context
  def location(ctx); end

  def status_flag(ctx); end
end

# Utilities to assist breakpoint/display enabling/disabling.
module Byebug::Helpers::ToggleHelper
  include ::Byebug::Helpers::ParseHelper

  def enable_disable_breakpoints(is_enable, args); end
  def enable_disable_display(is_enable, args); end

  private

  def n_displays; end
  def select_breakpoints(is_enable, args); end
end

# Utilities for variable subcommands
module Byebug::Helpers::VarHelper
  include ::Byebug::Helpers::EvalHelper

  def var_args; end
  def var_global; end
  def var_instance(str); end
  def var_list(ary, binding = T.unsafe(nil)); end
  def var_local; end
end

# Setting to customize the file where byebug's history is saved.
class Byebug::HistfileSetting < ::Byebug::Setting
  def banner; end
  def to_s; end
end

Byebug::HistfileSetting::DEFAULT = T.let(T.unsafe(nil), String)

# Handles byebug's history of commands.
class Byebug::History
  # @return [History] a new instance of History
  def initialize; end

  # Array holding the list of commands in history
  def buffer; end

  # Discards history.
  def clear; end

  # Max number of commands to be displayed when no size has been specified.
  #
  # Never more than Setting[:histsize].
  def default_max_size; end

  # Whether a specific command should not be stored in history.
  #
  # For now, empty lines and consecutive duplicates.
  #
  # @return [Boolean]
  def ignore?(buf); end

  # Array of ids of the last +number+ commands.
  def last_ids(number); end

  # Removes a command from Readline's history.
  def pop; end

  # Adds a new command to Readline's history.
  def push(cmd); end

  # Restores history from disk.
  def restore; end

  # Saves history to disk.
  def save; end

  # Returns the value of attribute size.
  def size; end

  # Sets the attribute size
  #
  # @param value the value to set the attribute size to.
  def size=(_arg0); end

  # Max number of commands to be displayed when a size has been specified.
  #
  # The only bound here is not showing more items than available.
  def specific_max_size(number); end

  # Prints the requested numbers of history entries.
  def to_s(n_cmds); end
end

# Show history of byebug commands.
class Byebug::HistoryCommand < ::Byebug::Command
  include ::Byebug::Helpers::ParseHelper

  def execute; end

  class << self
    def description; end
    def regexp; end
    def short_description; end
  end
end

# Setting to customize the number of byebug commands to be saved in history.
class Byebug::HistsizeSetting < ::Byebug::Setting
  def banner; end
  def to_s; end
end

Byebug::HistsizeSetting::DEFAULT = T.let(T.unsafe(nil), Integer)

# Shows info about different aspects of the debugger.
class Byebug::InfoCommand < ::Byebug::Command
  include ::Byebug::Subcommands
  extend ::Byebug::Helpers::ReflectionHelper
  extend ::Byebug::Subcommands::ClassMethods

  class << self
    def description; end
    def regexp; end
    def short_description; end
  end
end

# Information about current breakpoints
class Byebug::InfoCommand::BreakpointsCommand < ::Byebug::Command
  def execute; end

  private

  def info_breakpoint(brkpt); end

  class << self
    def description; end
    def regexp; end
    def short_description; end
  end
end

# Information about display expressions
class Byebug::InfoCommand::DisplayCommand < ::Byebug::Command
  def execute; end

  class << self
    def description; end
    def regexp; end
    def short_description; end
  end
end

# Information about a particular source file
class Byebug::InfoCommand::FileCommand < ::Byebug::Command
  include ::Byebug::Helpers::FileHelper
  include ::Byebug::Helpers::StringHelper

  def execute; end

  private

  def info_file_basic(file); end
  def info_file_breakpoints(file); end
  def info_file_mtime(file); end
  def info_file_sha1(file); end

  class << self
    def description; end
    def regexp; end
    def short_description; end
  end
end

# Information about current location
class Byebug::InfoCommand::LineCommand < ::Byebug::Command
  def execute; end

  class << self
    def description; end
    def regexp; end
    def short_description; end
  end
end

# Information about arguments of the current method/block
class Byebug::InfoCommand::ProgramCommand < ::Byebug::Command
  def execute; end

  private

  def format_stop_reason(stop_reason); end

  class << self
    def description; end
    def regexp; end
    def short_description; end
  end
end

# Main Interface class
#
# Contains common functionality to all implemented interfaces.
class Byebug::Interface
  include ::Byebug::Helpers::FileHelper

  # @return [Interface] a new instance of Interface
  def initialize; end

  # Restores history according to +autosave+ setting.
  def autorestore; end

  # Saves or clears history according to +autosave+ setting.
  def autosave; end

  def close; end

  # Returns the value of attribute command_queue.
  def command_queue; end

  # Sets the attribute command_queue
  #
  # @param value the value to set the attribute command_queue to.
  def command_queue=(_arg0); end

  # Confirms user introduced an affirmative response to the input stream.
  def confirm(prompt); end

  # Prints an error message to the error stream.
  def errmsg(message); end

  # Returns the value of attribute error.
  def error; end

  # Returns the value of attribute history.
  def history; end

  # Sets the attribute history
  #
  # @param value the value to set the attribute history to.
  def history=(_arg0); end

  # Returns the value of attribute input.
  def input; end

  def last_if_empty(input); end

  # Returns the value of attribute output.
  def output; end

  # Reads a new line from the interface's input stream.
  #
  # read now was empty.
  #
  # @return [String] New string read or the previous string if the string
  def prepare_input(prompt); end

  # Prints an output message to the output stream without a final "\n".
  def print(message); end

  # Prints an output message to the output stream.
  def puts(message); end

  # Pops a command from the input stream.
  def read_command(prompt); end

  # Pushes lines in +filename+ to the command queue.
  def read_file(filename); end

  # Reads a new line from the interface's input stream, parses it into
  # commands and saves it to history.
  #
  # @return [String] Representing something to be run by the debugger.
  def read_input(prompt, save_hist = T.unsafe(nil)); end

  private

  # Splits a command line of the form "cmd1 ; cmd2 ; ... ; cmdN" into an
  # array of commands: [cmd1, cmd2, ..., cmdN]
  def split_commands(cmd_line); end
end

# Interrupting execution of current thread.
class Byebug::InterruptCommand < ::Byebug::Command
  def execute; end

  class << self
    def description; end
    def regexp; end
    def short_description; end
  end
end

# Enter IRB from byebug's prompt
class Byebug::IrbCommand < ::Byebug::Command
  def execute; end

  private

  def with_clean_argv; end

  class << self
    def description; end
    def regexp; end
    def short_description; end
  end
end

# Send custom signals to the debugged program.
class Byebug::KillCommand < ::Byebug::Command
  def execute; end

  class << self
    def description; end
    def regexp; end
    def short_description; end
  end
end

# Setting to enable/disable linetracing.
class Byebug::LinetraceSetting < ::Byebug::Setting
  def banner; end
  def value; end
  def value=(val); end
end

# List parts of the source code.
class Byebug::ListCommand < ::Byebug::Command
  include ::Byebug::Helpers::FileHelper
  include ::Byebug::Helpers::ParseHelper

  def amend_final(*args, &block); end
  def execute; end
  def max_line(*args, &block); end
  def size(*args, &block); end

  private

  # Set line range to be printed by list
  #
  # @return first line number to list
  # @return last line number to list
  def auto_range(direction); end

  # Show a range of lines in the current file.
  #
  # @param min [Integer] Lower bound
  # @param max [Integer] Upper bound
  def display_lines(min, max); end

  # @param range [String] A string with an integer range format
  # @return [String] The lower bound of the given range
  def lower_bound(range); end

  def move(line, size, direction = T.unsafe(nil)); end
  def parse_range(input); end

  # Line range to be printed by `list`.
  #
  # If <input> is set, range is parsed from it.
  #
  # Otherwise it's automatically chosen.
  def range(input); end

  def source_file_formatter; end

  # @param str [String] A string with an integer range format
  # @return [Array] The upper & lower bounds of the given range
  def split_range(str); end

  # @param range [String] A string with an integer range format
  # @return [String] The upper bound of the given range
  def upper_bound(range); end

  # @return [Boolean]
  def valid_range?(first, last); end

  class << self
    def description; end
    def regexp; end
    def short_description; end
  end
end

# Setting to customize the number of source code lines to be displayed every
# time the "list" command is invoked.
class Byebug::ListsizeSetting < ::Byebug::Setting
  def banner; end
  def to_s; end
end

Byebug::ListsizeSetting::DEFAULT = T.let(T.unsafe(nil), Integer)

# Interface class for standard byebug use.
class Byebug::LocalInterface < ::Byebug::Interface
  # @return [LocalInterface] a new instance of LocalInterface
  def initialize; end

  # Reads a single line of input using Readline. If Ctrl-D is pressed, it
  # returns "continue", meaning that program's execution will go on.
  #
  # @param prompt Prompt to be displayed.
  def readline(prompt); end

  # Yields the block handling Ctrl-C the following way: if pressed while
  # waiting for input, the line is reset to only the prompt and we ask for
  # input again.
  #
  # @note Any external 'INT' traps are overriden during this method.
  def with_repl_like_sigint; end

  # Disable any Readline completion procs.
  #
  # Other gems, for example, IRB could've installed completion procs that are
  # dependent on them being loaded. Disable those while byebug is the REPL
  # making use of Readline.
  def without_readline_completion; end
end

Byebug::LocalInterface::EOF_ALIAS = T.let(T.unsafe(nil), String)

# Show methods of specific classes/modules/objects.
class Byebug::MethodCommand < ::Byebug::Command
  include ::Byebug::Helpers::EvalHelper

  def execute; end

  class << self
    def description; end
    def regexp; end
    def short_description; end
  end
end

# Implements the next functionality.
#
# Allows the user the continue execution until the next instruction in the
# current frame.
class Byebug::NextCommand < ::Byebug::Command
  include ::Byebug::Helpers::ParseHelper

  def execute; end

  class << self
    def description; end
    def regexp; end
    def short_description; end
  end
end

# Port number used for remote debugging
Byebug::PORT = T.let(T.unsafe(nil), Integer)

# Processes commands in post_mortem mode
class Byebug::PostMortemProcessor < ::Byebug::CommandProcessor
  def commands; end
  def prompt; end
end

# Setting to enable/disable post_mortem mode, i.e., a debugger prompt after
# program termination by unhandled exception.
class Byebug::PostMortemSetting < ::Byebug::Setting
  # @return [PostMortemSetting] a new instance of PostMortemSetting
  def initialize; end

  def banner; end
  def value; end
  def value=(val); end
end

module Byebug::Printers; end

# Base printer
class Byebug::Printers::Base
  def type; end

  private

  def array_of_args(collection, &_block); end
  def contents; end
  def contents_files; end

  # @raise [MissedPath]
  def locate(path); end

  def parts(path); end
  def translate(string, args = T.unsafe(nil)); end
end

class Byebug::Printers::Base::MissedArgument < ::StandardError; end
class Byebug::Printers::Base::MissedPath < ::StandardError; end
Byebug::Printers::Base::SEPARATOR = T.let(T.unsafe(nil), String)

# Plain text printer
class Byebug::Printers::Plain < ::Byebug::Printers::Base
  def print(path, args = T.unsafe(nil)); end
  def print_collection(path, collection, &block); end
  def print_variables(variables, *_unused); end

  private

  def contents_files; end
end

# Enter Pry from byebug's prompt
class Byebug::PryCommand < ::Byebug::Command
  def execute; end

  class << self
    def description; end
    def regexp; end
    def short_description; end
  end
end

# Exit from byebug.
class Byebug::QuitCommand < ::Byebug::Command
  def execute; end

  class << self
    def description; end
    def regexp; end
    def short_description; end
  end
end

module Byebug::Remote; end

# Client for remote debugging
class Byebug::Remote::Client
  # @return [Client] a new instance of Client
  def initialize(interface); end

  # Returns the value of attribute interface.
  def interface; end

  # Returns the value of attribute socket.
  def socket; end

  # Connects to the remote byebug
  def start(host = T.unsafe(nil), port = T.unsafe(nil)); end

  # @return [Boolean]
  def started?; end

  private

  def connect_at(host, port); end
end

# Server for remote debugging
class Byebug::Remote::Server
  # @return [Server] a new instance of Server
  def initialize(wait_connection:, &block); end

  # Returns the value of attribute actual_port.
  def actual_port; end

  # Start the remote debugging server
  def start(host, port); end

  # Returns the value of attribute wait_connection.
  def wait_connection; end
end

# Interface class for remote use of byebug.
class Byebug::RemoteInterface < ::Byebug::Interface
  # @return [RemoteInterface] a new instance of RemoteInterface
  def initialize(socket); end

  def close; end
  def confirm(prompt); end
  def print(message); end
  def puts(message); end
  def read_command(prompt); end
  def readline(prompt); end
end

# Restart debugged program from within byebug.
class Byebug::RestartCommand < ::Byebug::Command
  include ::Byebug::Helpers::BinHelper
  include ::Byebug::Helpers::PathHelper

  def execute; end

  private

  def prepend_byebug_bin(cmd); end
  def prepend_ruby_bin(cmd); end

  class << self
    def description; end
    def regexp; end
    def short_description; end
  end
end

# Save current settings to use them in another debug session.
class Byebug::SaveCommand < ::Byebug::Command
  def execute; end

  private

  def save_breakpoints(file); end
  def save_catchpoints(file); end
  def save_displays(file); end
  def save_settings(file); end

  class << self
    def description; end
    def regexp; end
    def short_description; end
  end
end

# Setting to customize the file where byebug's history is saved.
class Byebug::SavefileSetting < ::Byebug::Setting
  def banner; end
  def to_s; end
end

Byebug::SavefileSetting::DEFAULT = T.let(T.unsafe(nil), String)

# Interface class for command execution from script files.
class Byebug::ScriptInterface < ::Byebug::Interface
  # @return [ScriptInterface] a new instance of ScriptInterface
  def initialize(file, verbose = T.unsafe(nil)); end

  def close; end
  def read_command(prompt); end
  def readline(*_arg0); end
end

# Processes commands from a file
class Byebug::ScriptProcessor < ::Byebug::CommandProcessor
  def after_repl; end

  # Available commands
  def commands; end

  # Prompt shown before reading a command.
  def prompt; end

  def repl; end

  private

  def without_exceptions; end
end

# Change byebug settings.
class Byebug::SetCommand < ::Byebug::Command
  include ::Byebug::Helpers::ParseHelper

  def execute; end

  private

  def get_onoff(arg, default); end

  class << self
    def description; end
    def help; end
    def regexp; end
    def short_description; end
  end
end

# Parent class for all byebug settings.
class Byebug::Setting
  # @return [Setting] a new instance of Setting
  def initialize; end

  # @return [Boolean]
  def boolean?; end

  def help; end

  # @return [Boolean]
  def integer?; end

  def to_s; end
  def to_sym; end

  # Returns the value of attribute value.
  def value; end

  # Sets the attribute value
  #
  # @param value the value to set the attribute value to.
  def value=(_arg0); end

  class << self
    def [](name); end
    def []=(name, value); end
    def find(shortcut); end

    # @todo DRY this up. Very similar code exists in the CommandList class
    def help_all; end

    def settings; end
  end
end

# Show byebug settings.
class Byebug::ShowCommand < ::Byebug::Command
  def execute; end

  class << self
    def description; end
    def help; end
    def regexp; end
    def short_description; end
  end
end

# Allows the user to continue execution until the next breakpoint, as
# long as it is different from the current one
class Byebug::SkipCommand < ::Byebug::Command
  include ::Byebug::Helpers::ParseHelper

  def auto_run; end
  def execute; end
  def initialize_attributes; end
  def keep_execution; end
  def reset_attributes; end

  class << self
    def description; end
    def file_line; end

    # Sets the attribute file_line
    #
    # @param value the value to set the attribute file_line to.
    def file_line=(_arg0); end

    def file_path; end

    # Sets the attribute file_path
    #
    # @param value the value to set the attribute file_path to.
    def file_path=(_arg0); end

    # Returns the value of attribute previous_autolist.
    def previous_autolist; end

    def regexp; end
    def restore_autolist; end
    def setup_autolist(value); end
    def short_description; end
  end
end

# Execute a file containing byebug commands.
#
# It can be used to restore a previously saved debugging session.
class Byebug::SourceCommand < ::Byebug::Command
  def execute; end

  class << self
    def description; end
    def regexp; end
    def short_description; end
  end
end

# Formats specific line ranges in a source file
class Byebug::SourceFileFormatter
  include ::Byebug::Helpers::FileHelper

  # @return [SourceFileFormatter] a new instance of SourceFileFormatter
  def initialize(file, annotator); end

  def amend(line, ceiling); end
  def amend_final(line); end
  def amend_initial(line); end

  # Returns the value of attribute annotator.
  def annotator; end

  # Returns the value of attribute file.
  def file; end

  def lines(min, max); end
  def lines_around(center); end
  def max_initial_line; end
  def max_line; end
  def range_around(center); end
  def range_from(min); end
  def size; end
end

# Setting to enable/disable the display of backtraces when evaluations raise
# errors.
class Byebug::StackOnErrorSetting < ::Byebug::Setting
  def banner; end
end

# Implements the step functionality.
#
# Allows the user the continue execution until the next instruction, possibily
# in a different frame. Use step to step into method calls or blocks.
class Byebug::StepCommand < ::Byebug::Command
  include ::Byebug::Helpers::ParseHelper

  def execute; end

  class << self
    def description; end
    def regexp; end
    def short_description; end
  end
end

# Subcommand additions.
module Byebug::Subcommands
  extend ::Forwardable

  mixes_in_class_methods ::Byebug::Subcommands::ClassMethods

  # Delegates to subcommands or prints help if no subcommand specified.
  #
  # @raise [CommandNotFound]
  def execute; end

  def subcommand_list(*args, &block); end

  class << self
    # @private
    def included(command); end
  end
end

# Class methods added to subcommands
module Byebug::Subcommands::ClassMethods
  include ::Byebug::Helpers::ReflectionHelper

  # Default help text for a command with subcommands
  def help; end

  # Command's subcommands.
  def subcommand_list; end
end

# Manipulation of Ruby threads
class Byebug::ThreadCommand < ::Byebug::Command
  include ::Byebug::Subcommands
  extend ::Byebug::Helpers::ReflectionHelper
  extend ::Byebug::Subcommands::ClassMethods

  class << self
    def description; end
    def regexp; end
    def short_description; end
  end
end

# Information about the current thread
class Byebug::ThreadCommand::CurrentCommand < ::Byebug::Command
  include ::Byebug::Helpers::ThreadHelper

  def execute; end

  class << self
    def description; end
    def regexp; end
    def short_description; end
  end
end

# Information about threads
class Byebug::ThreadCommand::ListCommand < ::Byebug::Command
  include ::Byebug::Helpers::ThreadHelper

  def execute; end

  class << self
    def description; end
    def regexp; end
    def short_description; end
  end
end

# Resumes the specified thread
class Byebug::ThreadCommand::ResumeCommand < ::Byebug::Command
  include ::Byebug::Helpers::ThreadHelper

  def execute; end

  class << self
    def description; end
    def regexp; end
    def short_description; end
  end
end

# Stops the specified thread
class Byebug::ThreadCommand::StopCommand < ::Byebug::Command
  include ::Byebug::Helpers::ThreadHelper

  def execute; end

  class << self
    def description; end
    def regexp; end
    def short_description; end
  end
end

# Switches to the specified thread
class Byebug::ThreadCommand::SwitchCommand < ::Byebug::Command
  include ::Byebug::Helpers::ThreadHelper

  def execute; end

  class << self
    def description; end
    def regexp; end
    def short_description; end
  end
end

class Byebug::ThreadsTable; end

# Show (and possibily stop) at every line that changes a global variable.
class Byebug::TracevarCommand < ::Byebug::Command
  def execute; end

  private

  def on_change(name, value, stop); end

  class << self
    def description; end
    def regexp; end
    def short_description; end
  end
end

# Remove expressions from display list.
class Byebug::UndisplayCommand < ::Byebug::Command
  include ::Byebug::Helpers::ParseHelper

  def execute; end

  class << self
    def description; end
    def regexp; end
    def short_description; end
  end
end

# Stop tracing a global variable.
class Byebug::UntracevarCommand < ::Byebug::Command
  def execute; end

  class << self
    def description; end
    def regexp; end
    def short_description; end
  end
end

# Move the current frame up in the backtrace.
class Byebug::UpCommand < ::Byebug::Command
  include ::Byebug::Helpers::FrameHelper
  include ::Byebug::Helpers::ParseHelper

  def execute; end

  class << self
    def description; end
    def regexp; end
    def short_description; end
  end
end

# Shows variables and its values
class Byebug::VarCommand < ::Byebug::Command
  include ::Byebug::Subcommands
  extend ::Byebug::Helpers::ReflectionHelper
  extend ::Byebug::Subcommands::ClassMethods

  class << self
    def description; end
    def regexp; end
    def short_description; end
  end
end

# Shows global, instance and local variables
class Byebug::VarCommand::AllCommand < ::Byebug::Command
  include ::Byebug::Helpers::EvalHelper
  include ::Byebug::Helpers::VarHelper

  def execute; end

  class << self
    def description; end
    def regexp; end
    def short_description; end
  end
end

# Information about arguments of the current method/block
class Byebug::VarCommand::ArgsCommand < ::Byebug::Command
  include ::Byebug::Helpers::EvalHelper
  include ::Byebug::Helpers::VarHelper

  def execute; end

  class << self
    def description; end
    def regexp; end
    def short_description; end
  end
end

# Shows constants
class Byebug::VarCommand::ConstCommand < ::Byebug::Command
  include ::Byebug::Helpers::EvalHelper

  def execute; end

  private

  def str_obj; end

  class << self
    def description; end
    def regexp; end
    def short_description; end
  end
end

# Shows global variables
class Byebug::VarCommand::GlobalCommand < ::Byebug::Command
  include ::Byebug::Helpers::EvalHelper
  include ::Byebug::Helpers::VarHelper

  def execute; end

  class << self
    def description; end
    def regexp; end
    def short_description; end
  end
end

# Shows instance variables
class Byebug::VarCommand::InstanceCommand < ::Byebug::Command
  include ::Byebug::Helpers::EvalHelper
  include ::Byebug::Helpers::VarHelper

  def execute; end

  class << self
    def description; end
    def regexp; end
    def short_description; end
  end
end

# Shows local variables in current scope
class Byebug::VarCommand::LocalCommand < ::Byebug::Command
  include ::Byebug::Helpers::EvalHelper
  include ::Byebug::Helpers::VarHelper

  def execute; end

  class << self
    def description; end
    def regexp; end
    def short_description; end
  end
end

# Show current backtrace.
class Byebug::WhereCommand < ::Byebug::Command
  include ::Byebug::Helpers::FrameHelper

  def execute; end

  private

  def print_backtrace; end

  class << self
    def description; end
    def regexp; end
    def short_description; end
  end
end

# Setting to customize the maximum width of byebug's output.
class Byebug::WidthSetting < ::Byebug::Setting
  def banner; end
  def to_s; end
end

Byebug::WidthSetting::DEFAULT = T.let(T.unsafe(nil), Integer)

# Extends the extension class to be able to pass information about the
# debugging environment from the c-extension to the user.
class Exception
  include ::ActiveSupport::Dependencies::Blamable

  # Returns the value of attribute __bb_context.
  def __bb_context; end
end

# Adds a `byebug` method to the Kernel module.
#
# Dropping a `byebug` call anywhere in your code, you get a debug prompt.
module Kernel
  def byebug; end
  def debugger; end
  def remote_byebug(host = T.unsafe(nil), port = T.unsafe(nil)); end
end
