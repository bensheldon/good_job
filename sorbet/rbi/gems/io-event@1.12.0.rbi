# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `io-event` gem.
# Please instead update this file by running `bin/tapioca gem io-event`.


# source://io-event//lib/io/event/version.rb#7
class IO
  include ::Enumerable
  include ::File::Constants
end

class IO::Buffer
  include ::Comparable

  def initialize(*_arg0); end

  def &(_arg0); end
  def <=>(_arg0); end
  def ^(_arg0); end
  def and!(_arg0); end
  def clear(*_arg0); end
  def copy(*_arg0); end
  def each(*_arg0); end
  def each_byte(*_arg0); end
  def empty?; end
  def external?; end
  def free; end
  def get_string(*_arg0); end
  def get_value(_arg0, _arg1); end
  def get_values(_arg0, _arg1); end
  def hexdump(*_arg0); end
  def inspect; end
  def internal?; end
  def locked; end
  def locked?; end
  def mapped?; end
  def not!; end
  def null?; end
  def or!(_arg0); end
  def pread(*_arg0); end
  def private?; end
  def pwrite(*_arg0); end
  def read(*_arg0); end
  def readonly?; end
  def resize(_arg0); end
  def set_string(*_arg0); end
  def set_value(_arg0, _arg1, _arg2); end
  def set_values(_arg0, _arg1, _arg2); end
  def shared?; end
  def size; end
  def slice(*_arg0); end
  def to_s; end
  def transfer; end
  def valid?; end
  def values(*_arg0); end
  def write(*_arg0); end
  def xor!(_arg0); end
  def |(_arg0); end
  def ~; end

  private

  def initialize_copy(_arg0); end

  class << self
    def for(_arg0); end
    def map(*_arg0); end
    def size_of(_arg0); end
    def string(_arg0); end
  end
end

class IO::Buffer::AccessError < ::RuntimeError; end
class IO::Buffer::AllocationError < ::RuntimeError; end
IO::Buffer::BIG_ENDIAN = T.let(T.unsafe(nil), Integer)
IO::Buffer::DEFAULT_SIZE = T.let(T.unsafe(nil), Integer)
IO::Buffer::EXTERNAL = T.let(T.unsafe(nil), Integer)
IO::Buffer::HOST_ENDIAN = T.let(T.unsafe(nil), Integer)
IO::Buffer::INTERNAL = T.let(T.unsafe(nil), Integer)
class IO::Buffer::InvalidatedError < ::RuntimeError; end
IO::Buffer::LITTLE_ENDIAN = T.let(T.unsafe(nil), Integer)
IO::Buffer::LOCKED = T.let(T.unsafe(nil), Integer)
class IO::Buffer::LockedError < ::RuntimeError; end
IO::Buffer::MAPPED = T.let(T.unsafe(nil), Integer)
class IO::Buffer::MaskError < ::ArgumentError; end
IO::Buffer::NETWORK_ENDIAN = T.let(T.unsafe(nil), Integer)
IO::Buffer::PAGE_SIZE = T.let(T.unsafe(nil), Integer)
IO::Buffer::PRIVATE = T.let(T.unsafe(nil), Integer)
IO::Buffer::READONLY = T.let(T.unsafe(nil), Integer)
IO::Buffer::SHARED = T.let(T.unsafe(nil), Integer)
class IO::ConsoleMode; end

class IO::EAGAINWaitReadable < ::Errno::EAGAIN
  include ::IO::WaitReadable
end

class IO::EAGAINWaitWritable < ::Errno::EAGAIN
  include ::IO::WaitWritable
end

class IO::EINPROGRESSWaitReadable < ::Errno::EINPROGRESS
  include ::IO::WaitReadable
end

class IO::EINPROGRESSWaitWritable < ::Errno::EINPROGRESS
  include ::IO::WaitWritable
end

IO::EWOULDBLOCKWaitReadable = IO::EAGAINWaitReadable
IO::EWOULDBLOCKWaitWritable = IO::EAGAINWaitWritable

# source://io-event//lib/io/event/version.rb#9
module IO::Event; end

# source://io-event//lib/io/event/debug/selector.rb#10
module IO::Event::Debug; end

# Enforces the selector interface and delegates operations to a wrapped selector instance.
#
# You can enable this in the default selector by setting the `IO_EVENT_DEBUG_SELECTOR` environment variable. In addition, you can log all selector operations to a file by setting the `IO_EVENT_DEBUG_SELECTOR_LOG` environment variable. This is useful for debugging and understanding the behavior of the event loop.
#
# source://io-event//lib/io/event/debug/selector.rb#14
class IO::Event::Debug::Selector
  # Initialize the debug selector with the given selector and optional log.
  #
  # @return [Selector] a new instance of Selector
  #
  # source://io-event//lib/io/event/debug/selector.rb#33
  def initialize(selector, log: T.unsafe(nil)); end

  # Close the selector.
  #
  # source://io-event//lib/io/event/debug/selector.rb#78
  def close; end

  # The idle duration of the underlying selector.
  #
  # source://io-event//lib/io/event/debug/selector.rb#50
  def idle_duration; end

  # Read from the given IO, forwarded to the underlying selector.
  #
  # source://io-event//lib/io/event/debug/selector.rb#144
  def io_read(fiber, io, buffer, length, offset = T.unsafe(nil)); end

  # Wait for the given IO, forwarded to the underlying selector.
  #
  # source://io-event//lib/io/event/debug/selector.rb#138
  def io_wait(fiber, io, events); end

  # Write to the given IO, forwarded to the underlying selector.
  #
  # source://io-event//lib/io/event/debug/selector.rb#150
  def io_write(fiber, io, buffer, length, offset = T.unsafe(nil)); end

  # Log the given message.
  #
  # source://io-event//lib/io/event/debug/selector.rb#64
  def log(message); end

  # The current time.
  #
  # source://io-event//lib/io/event/debug/selector.rb#57
  def now; end

  # Wait for the given process, forwarded to the underlying selector.
  #
  # source://io-event//lib/io/event/debug/selector.rb#132
  def process_wait(*arguments); end

  # Push the given fiber to the selector ready list, such that it will be resumed on the next call to {select}.
  #
  # source://io-event//lib/io/event/debug/selector.rb#110
  def push(fiber); end

  # Raise the given exception on the given fiber.
  #
  # source://io-event//lib/io/event/debug/selector.rb#119
  def raise(fiber, *arguments); end

  # Check if the selector is ready.
  #
  # @return [Boolean]
  #
  # source://io-event//lib/io/event/debug/selector.rb#127
  def ready?; end

  # Forward the given method to the underlying selector.
  #
  # @return [Boolean]
  #
  # source://io-event//lib/io/event/debug/selector.rb#156
  def respond_to?(name, include_private = T.unsafe(nil)); end

  # Resume the given fiber with the given arguments.
  #
  # source://io-event//lib/io/event/debug/selector.rb#96
  def resume(*arguments); end

  # Select for the given duration, forwarded to the underlying selector.
  #
  # source://io-event//lib/io/event/debug/selector.rb#161
  def select(duration = T.unsafe(nil)); end

  # Transfer from the calling fiber to the selector.
  #
  # source://io-event//lib/io/event/debug/selector.rb#90
  def transfer; end

  # Wakeup the the selector.
  #
  # source://io-event//lib/io/event/debug/selector.rb#73
  def wakeup; end

  # Yield to the selector.
  #
  # source://io-event//lib/io/event/debug/selector.rb#102
  def yield; end

  class << self
    # Wrap the given selector with debugging.
    #
    # source://io-event//lib/io/event/debug/selector.rb#19
    def wrap(selector, env = T.unsafe(nil)); end
  end
end

# A thread safe synchronisation primative.
#
# source://io-event//lib/io/event/interrupt.rb#8
class IO::Event::Interrupt
  # @return [Interrupt] a new instance of Interrupt
  #
  # source://io-event//lib/io/event/interrupt.rb#13
  def initialize(selector); end

  # source://io-event//lib/io/event/interrupt.rb#36
  def close; end

  # Send a sigle byte interrupt.
  #
  # source://io-event//lib/io/event/interrupt.rb#29
  def signal; end

  class << self
    # source://io-event//lib/io/event/interrupt.rb#9
    def attach(selector); end
  end
end

# A priority queue implementation using a standard binary minheap. It uses straight comparison
# of its contents to determine priority.
# See <https://en.wikipedia.org/wiki/Binary_heap> for explanations of the main methods.
#
# source://io-event//lib/io/event/priority_heap.rb#12
class IO::Event::PriorityHeap
  # Initializes the heap.
  #
  # @return [PriorityHeap] a new instance of PriorityHeap
  #
  # source://io-event//lib/io/event/priority_heap.rb#14
  def initialize; end

  # Empties out the heap, discarding all elements
  #
  # source://io-event//lib/io/event/priority_heap.rb#78
  def clear!; end

  # source://io-event//lib/io/event/priority_heap.rb#22
  def peek; end

  # Removes and returns the smallest element in the heap, or nil if the heap is empty.
  #
  # source://io-event//lib/io/event/priority_heap.rb#34
  def pop; end

  # Add a new element to the heap, then rearrange elements until the heap invariant is true again.
  #
  # source://io-event//lib/io/event/priority_heap.rb#65
  def push(element); end

  # source://io-event//lib/io/event/priority_heap.rb#27
  def size; end

  # Validate the heap invariant. Every element except the root must not be smaller than its parent element. Note that it MAY be equal.
  #
  # @return [Boolean]
  #
  # source://io-event//lib/io/event/priority_heap.rb#83
  def valid?; end

  private

  # source://io-event//lib/io/event/priority_heap.rb#108
  def bubble_down(index); end

  # Left here for reference, but unused.
  # def swap(i, j)
  # 	@contents[i], @contents[j] = @contents[j], @contents[i]
  # end
  #
  # source://io-event//lib/io/event/priority_heap.rb#95
  def bubble_up(index); end
end

# source://io-event//lib/io/event/selector/select.rb#11
module IO::Event::Selector
  class << self
    # The default selector implementation, which is chosen based on the environment and available implementations.
    #
    # source://io-event//lib/io/event/selector.rb#17
    def default(env = T.unsafe(nil)); end

    # Create a new selector instance, according to the best available implementation.
    #
    # source://io-event//lib/io/event/selector.rb#38
    def new(loop, env = T.unsafe(nil)); end

    # Execute the given block in non-blocking mode.
    #
    # source://io-event//lib/io/event/native.rb#7
    def nonblock(_arg0); end
  end
end

class IO::Event::Selector::KQueue
  # source://io-event//lib/io/event/native.rb#7
  def initialize(_arg0); end

  # source://io-event//lib/io/event/native.rb#7
  def close; end

  # source://io-event//lib/io/event/native.rb#7
  def idle_duration; end

  # source://io-event//lib/io/event/native.rb#7
  def io_read(*_arg0); end

  # source://io-event//lib/io/event/native.rb#7
  def io_wait(_arg0, _arg1, _arg2); end

  # source://io-event//lib/io/event/native.rb#7
  def io_write(*_arg0); end

  # source://io-event//lib/io/event/native.rb#7
  def loop; end

  # source://io-event//lib/io/event/native.rb#7
  def process_wait(_arg0, _arg1, _arg2); end

  # source://io-event//lib/io/event/native.rb#7
  def push(_arg0); end

  # source://io-event//lib/io/event/native.rb#7
  def raise(*_arg0); end

  # source://io-event//lib/io/event/native.rb#7
  def ready?; end

  # source://io-event//lib/io/event/native.rb#7
  def resume(*_arg0); end

  # source://io-event//lib/io/event/native.rb#7
  def select(_arg0); end

  # source://io-event//lib/io/event/native.rb#7
  def transfer; end

  # source://io-event//lib/io/event/native.rb#7
  def wakeup; end

  # source://io-event//lib/io/event/native.rb#7
  def yield; end
end

# A pure-Ruby implementation of the event selector.
#
# source://io-event//lib/io/event/selector/select.rb#13
class IO::Event::Selector::Select
  # Initialize the selector with the given event loop fiber.
  #
  # @return [Select] a new instance of Select
  #
  # source://io-event//lib/io/event/selector/select.rb#15
  def initialize(loop); end

  # Close the selector and release any resources.
  #
  # source://io-event//lib/io/event/selector/select.rb#49
  def close; end

  # Returns the value of attribute idle_duration.
  #
  # source://io-event//lib/io/event/selector/select.rb#35
  def idle_duration; end

  # Ruby 3.2, most IO::Buffer support, but slightly clunky read/write methods.
  #
  # source://io-event//lib/io/event/selector/select.rb#194
  def io_read(fiber, io, buffer, length, offset = T.unsafe(nil)); end

  # Wait for multiple IO objects to become readable or writable.
  #
  # source://io-event//lib/io/event/selector/select.rb#173
  def io_select(readable, writable, priority, timeout); end

  # Wait for the given IO to become readable or writable.
  #
  # source://io-event//lib/io/event/selector/select.rb#160
  def io_wait(fiber, io, events); end

  # Write to the given IO from the buffer.
  #
  # source://io-event//lib/io/event/selector/select.rb#224
  def io_write(fiber, io, buffer, length, offset = T.unsafe(nil)); end

  # Returns the value of attribute loop.
  #
  # source://io-event//lib/io/event/selector/select.rb#32
  def loop; end

  # Wait for a process to change state.
  #
  # source://io-event//lib/io/event/selector/select.rb#316
  def process_wait(fiber, pid, flags); end

  # Append the given fiber into the ready list.
  #
  # source://io-event//lib/io/event/selector/select.rb#96
  def push(fiber); end

  # Transfer to the given fiber and raise an exception. Put the current fiber into the ready list.
  #
  # source://io-event//lib/io/event/selector/select.rb#101
  def raise(fiber, *arguments); end

  # @return [Boolean]
  #
  # source://io-event//lib/io/event/selector/select.rb#111
  def ready?; end

  # Transfer from the current fiber to the specified fiber. Put the current fiber into the ready list.
  #
  # source://io-event//lib/io/event/selector/select.rb#76
  def resume(fiber, *arguments); end

  # Wait for IO events or a timeout.
  #
  # source://io-event//lib/io/event/selector/select.rb#339
  def select(duration = T.unsafe(nil)); end

  # Transfer from the current fiber to the event loop.
  #
  # source://io-event//lib/io/event/selector/select.rb#71
  def transfer; end

  # Wake up the event loop if it is currently sleeping.
  #
  # source://io-event//lib/io/event/selector/select.rb#38
  def wakeup; end

  # Yield from the current fiber back to the event loop. Put the current fiber into the ready list.
  #
  # source://io-event//lib/io/event/selector/select.rb#86
  def yield; end

  protected

  # Whether the given error code indicates that the operation should be retried.
  #
  # @return [Boolean]
  #
  # source://io-event//lib/io/event/selector/select.rb#183
  def again?(errno); end

  private

  # source://io-event//lib/io/event/selector/select.rb#322
  def pop_ready; end
end

# source://io-event//lib/io/event/selector/select.rb#179
IO::Event::Selector::Select::EAGAIN = T.let(T.unsafe(nil), Integer)

# source://io-event//lib/io/event/selector/select.rb#180
IO::Event::Selector::Select::EWOULDBLOCK = T.let(T.unsafe(nil), Integer)

# source://io-event//lib/io/event/selector/select.rb#56
class IO::Event::Selector::Select::Optional < ::Struct
  # @return [Boolean]
  #
  # source://io-event//lib/io/event/selector/select.rb#61
  def alive?; end

  # Returns the value of attribute fiber
  #
  # @return [Object] the current value of fiber
  #
  # source://io-event//lib/io/event/selector/select.rb#56
  def fiber; end

  # Sets the attribute fiber
  #
  # @param value [Object] the value to set the attribute fiber to.
  # @return [Object] the newly set value
  #
  # source://io-event//lib/io/event/selector/select.rb#56
  def fiber=(_); end

  # source://io-event//lib/io/event/selector/select.rb#65
  def nullify; end

  # source://io-event//lib/io/event/selector/select.rb#57
  def transfer(*arguments); end

  class << self
    # source://io-event//lib/io/event/selector/select.rb#56
    def [](*_arg0); end

    # source://io-event//lib/io/event/selector/select.rb#56
    def inspect; end

    # source://io-event//lib/io/event/selector/select.rb#56
    def keyword_init?; end

    # source://io-event//lib/io/event/selector/select.rb#56
    def members; end

    # source://io-event//lib/io/event/selector/select.rb#56
    def new(*_arg0); end
  end
end

# source://io-event//lib/io/event/selector/select.rb#115
class IO::Event::Selector::Select::Waiter < ::Struct
  # @return [Boolean]
  #
  # source://io-event//lib/io/event/selector/select.rb#116
  def alive?; end

  # Dispatch the given events to the list of waiting fibers. If the fiber was not waiting for the given events, it is reactivated by calling the given block.
  #
  # source://io-event//lib/io/event/selector/select.rb#121
  def dispatch(events, &reactivate); end

  # source://io-event//lib/io/event/selector/select.rb#146
  def each(&block); end

  # Returns the value of attribute events
  #
  # @return [Object] the current value of events
  #
  # source://io-event//lib/io/event/selector/select.rb#115
  def events; end

  # Sets the attribute events
  #
  # @param value [Object] the value to set the attribute events to.
  # @return [Object] the newly set value
  #
  # source://io-event//lib/io/event/selector/select.rb#115
  def events=(_); end

  # Returns the value of attribute fiber
  #
  # @return [Object] the current value of fiber
  #
  # source://io-event//lib/io/event/selector/select.rb#115
  def fiber; end

  # Sets the attribute fiber
  #
  # @param value [Object] the value to set the attribute fiber to.
  # @return [Object] the newly set value
  #
  # source://io-event//lib/io/event/selector/select.rb#115
  def fiber=(_); end

  # source://io-event//lib/io/event/selector/select.rb#142
  def invalidate; end

  # Returns the value of attribute tail
  #
  # @return [Object] the current value of tail
  #
  # source://io-event//lib/io/event/selector/select.rb#115
  def tail; end

  # Sets the attribute tail
  #
  # @param value [Object] the value to set the attribute tail to.
  # @return [Object] the newly set value
  #
  # source://io-event//lib/io/event/selector/select.rb#115
  def tail=(_); end

  class << self
    # source://io-event//lib/io/event/selector/select.rb#115
    def [](*_arg0); end

    # source://io-event//lib/io/event/selector/select.rb#115
    def inspect; end

    # source://io-event//lib/io/event/selector/select.rb#115
    def keyword_init?; end

    # source://io-event//lib/io/event/selector/select.rb#115
    def members; end

    # source://io-event//lib/io/event/selector/select.rb#115
    def new(*_arg0); end
  end
end

# Helper methods for detecting support for various features.
#
# source://io-event//lib/io/event/support.rb#9
module IO::Event::Support
  class << self
    # Some features are only availble if the IO::Buffer class is available.
    #
    # @return [Boolean]
    #
    # source://io-event//lib/io/event/support.rb#13
    def buffer?; end

    # More advanced read/write methods and blocking controls were introduced in Ruby 3.2.
    #
    # To be removed on 31 Mar 2026.
    #
    # @return [Boolean]
    #
    # source://io-event//lib/io/event/support.rb#20
    def fiber_scheduler_v2?; end

    # Updated inferfaces for read/write and IO::Buffer were introduced in Ruby 3.3, including pread/pwrite.
    #
    # To become the default 31 Mar 2026.
    #
    # @return [Boolean]
    #
    # source://io-event//lib/io/event/support.rb#35
    def fiber_scheduler_v3?; end
  end
end

# An efficient sorted set of timers.
#
# source://io-event//lib/io/event/timers.rb#11
class IO::Event::Timers
  # Initialize the timers.
  #
  # @return [Timers] a new instance of Timers
  #
  # source://io-event//lib/io/event/timers.rb#62
  def initialize; end

  # Schedule a block to be called after a specific time offset, relative to the current time as returned by {#now}.
  #
  # source://io-event//lib/io/event/timers.rb#90
  def after(offset, &block); end

  # Fire all timers that are ready to fire.
  #
  # source://io-event//lib/io/event/timers.rb#118
  def fire(now = T.unsafe(nil)); end

  # source://io-event//lib/io/event/timers.rb#111
  def now; end

  # Schedule a block to be called at a specific time in the future.
  #
  # source://io-event//lib/io/event/timers.rb#78
  def schedule(time, block); end

  # source://io-event//lib/io/event/timers.rb#68
  def size; end

  # Compute the time interval until the next timer fires.
  #
  # source://io-event//lib/io/event/timers.rb#98
  def wait_interval(now = T.unsafe(nil)); end

  protected

  # Flush all scheduled timers into the heap.
  #
  # This is a small optimization which assumes that most timers (timeouts) will be cancelled.
  #
  # source://io-event//lib/io/event/timers.rb#141
  def flush!; end
end

# A handle to a scheduled timer.
#
# source://io-event//lib/io/event/timers.rb#13
class IO::Event::Timers::Handle
  # Initialize the handle with the given time and block.
  #
  # @return [Handle] a new instance of Handle
  #
  # source://io-event//lib/io/event/timers.rb#18
  def initialize(time, block); end

  # Compare the handle with another handle.
  #
  # source://io-event//lib/io/event/timers.rb#33
  def <(other); end

  # Compare the handle with another handle.
  #
  # source://io-event//lib/io/event/timers.rb#41
  def >(other); end

  # Returns the value of attribute block.
  #
  # source://io-event//lib/io/event/timers.rb#27
  def block; end

  # Invoke the block.
  #
  # source://io-event//lib/io/event/timers.rb#46
  def call(*_arg0, **_arg1, &_arg2); end

  # Cancel the timer.
  #
  # source://io-event//lib/io/event/timers.rb#51
  def cancel!; end

  # @return [Boolean]
  #
  # source://io-event//lib/io/event/timers.rb#56
  def cancelled?; end

  # Returns the value of attribute time.
  #
  # source://io-event//lib/io/event/timers.rb#24
  def time; end
end

# source://io-event//lib/io/event/version.rb#10
IO::Event::VERSION = T.let(T.unsafe(nil), String)

IO::PRIORITY = T.let(T.unsafe(nil), Integer)
IO::READABLE = T.let(T.unsafe(nil), Integer)
IO::WRITABLE = T.let(T.unsafe(nil), Integer)
