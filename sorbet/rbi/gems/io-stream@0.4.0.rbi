# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `io-stream` gem.
# Please instead update this file by running `bin/tapioca gem io-stream`.


# source://io-stream//lib/io/stream/shim/buffered.rb#21
class BasicSocket < ::IO
  # source://io-stream//lib/io/stream/shim/buffered.rb#38
  def buffered=(value); end

  # @return [Boolean]
  #
  # source://io-stream//lib/io/stream/shim/buffered.rb#28
  def buffered?; end

  # @return [Boolean]
  #
  # source://io-stream//lib/io/stream/shim/buffered.rb#22
  def ip_protocol_tcp?; end

  # @return [Boolean]
  #
  # source://io-stream//lib/io/stream/shim/readable.rb#19
  def readable?; end
end

# source://io-stream//lib/io/stream/shim/buffered.rb#7
class IO
  include ::Enumerable
  include ::File::Constants

  # source://io-stream//lib/io/stream/shim/buffered.rb#12
  def buffered=(value); end

  # @return [Boolean]
  #
  # source://io-stream//lib/io/stream/shim/buffered.rb#8
  def buffered?; end

  # @return [Boolean]
  #
  # source://io-stream//lib/io/stream/shim/readable.rb#8
  def readable?; end

  class << self
    # source://io-stream//lib/io/stream.rb#13
    def Stream(io); end
  end
end

class IO::Buffer
  include ::Comparable

  def initialize(*_arg0); end

  def &(_arg0); end
  def <=>(_arg0); end
  def ^(_arg0); end
  def and!(_arg0); end
  def clear(*_arg0); end
  def copy(*_arg0); end
  def each(*_arg0); end
  def each_byte(*_arg0); end
  def empty?; end
  def external?; end
  def free; end
  def get_string(*_arg0); end
  def get_value(_arg0, _arg1); end
  def get_values(_arg0, _arg1); end
  def hexdump(*_arg0); end
  def inspect; end
  def internal?; end
  def locked; end
  def locked?; end
  def mapped?; end
  def not!; end
  def null?; end
  def or!(_arg0); end
  def pread(*_arg0); end
  def private?; end
  def pwrite(*_arg0); end
  def read(*_arg0); end
  def readonly?; end
  def resize(_arg0); end
  def set_string(*_arg0); end
  def set_value(_arg0, _arg1, _arg2); end
  def set_values(_arg0, _arg1, _arg2); end
  def shared?; end
  def size; end
  def slice(*_arg0); end
  def to_s; end
  def transfer; end
  def valid?; end
  def values(*_arg0); end
  def write(*_arg0); end
  def xor!(_arg0); end
  def |(_arg0); end
  def ~; end

  private

  def initialize_copy(_arg0); end

  class << self
    def for(_arg0); end
    def map(*_arg0); end
    def size_of(_arg0); end
    def string(_arg0); end
  end
end

class IO::Buffer::AccessError < ::RuntimeError; end
class IO::Buffer::AllocationError < ::RuntimeError; end
IO::Buffer::BIG_ENDIAN = T.let(T.unsafe(nil), Integer)
IO::Buffer::DEFAULT_SIZE = T.let(T.unsafe(nil), Integer)
IO::Buffer::EXTERNAL = T.let(T.unsafe(nil), Integer)
IO::Buffer::HOST_ENDIAN = T.let(T.unsafe(nil), Integer)
IO::Buffer::INTERNAL = T.let(T.unsafe(nil), Integer)
class IO::Buffer::InvalidatedError < ::RuntimeError; end
IO::Buffer::LITTLE_ENDIAN = T.let(T.unsafe(nil), Integer)
IO::Buffer::LOCKED = T.let(T.unsafe(nil), Integer)
class IO::Buffer::LockedError < ::RuntimeError; end
IO::Buffer::MAPPED = T.let(T.unsafe(nil), Integer)
class IO::Buffer::MaskError < ::ArgumentError; end
IO::Buffer::NETWORK_ENDIAN = T.let(T.unsafe(nil), Integer)
IO::Buffer::PAGE_SIZE = T.let(T.unsafe(nil), Integer)
IO::Buffer::PRIVATE = T.let(T.unsafe(nil), Integer)
IO::Buffer::READONLY = T.let(T.unsafe(nil), Integer)
IO::Buffer::SHARED = T.let(T.unsafe(nil), Integer)

class IO::ConsoleMode
  def echo=(_arg0); end
  def raw(*_arg0); end
  def raw!(*_arg0); end

  private

  def initialize_copy(_arg0); end
end

class IO::EAGAINWaitReadable < ::Errno::EAGAIN
  include ::IO::WaitReadable
end

class IO::EAGAINWaitWritable < ::Errno::EAGAIN
  include ::IO::WaitWritable
end

class IO::EINPROGRESSWaitReadable < ::Errno::EINPROGRESS
  include ::IO::WaitReadable
end

class IO::EINPROGRESSWaitWritable < ::Errno::EINPROGRESS
  include ::IO::WaitWritable
end

IO::EWOULDBLOCKWaitReadable = IO::EAGAINWaitReadable
IO::EWOULDBLOCKWaitWritable = IO::EAGAINWaitWritable
IO::PRIORITY = T.let(T.unsafe(nil), Integer)
IO::READABLE = T.let(T.unsafe(nil), Integer)

# source://io-stream//lib/io/stream/version.rb#6
module IO::Stream; end

# The default block size for IO buffers. Defaults to 64KB (typical pipe buffer size).
#
# source://io-stream//lib/io/stream/generic.rb#16
IO::Stream::BLOCK_SIZE = T.let(T.unsafe(nil), Integer)

# source://io-stream//lib/io/stream/buffered.rb#9
class IO::Stream::Buffered < ::IO::Stream::Generic
  # @return [Buffered] a new instance of Buffered
  #
  # source://io-stream//lib/io/stream/buffered.rb#40
  def initialize(io, *_arg1, **_arg2, &_arg3); end

  # source://io-stream//lib/io/stream/buffered.rb#57
  def close_read; end

  # source://io-stream//lib/io/stream/buffered.rb#61
  def close_write; end

  # @return [Boolean]
  #
  # source://io-stream//lib/io/stream/buffered.rb#53
  def closed?; end

  # Returns the value of attribute io.
  #
  # source://io-stream//lib/io/stream/buffered.rb#51
  def io; end

  # @return [Boolean]
  #
  # source://io-stream//lib/io/stream/buffered.rb#67
  def readable?; end

  protected

  # source://io-stream//lib/io/stream/buffered.rb#73
  def sysclose; end

  # Reads data from the underlying stream as efficiently as possible.
  #
  # source://io-stream//lib/io/stream/buffered.rb#100
  def sysread(size, buffer); end

  # source://io-stream//lib/io/stream/buffered.rb#77
  def syswrite(buffer); end

  class << self
    # source://io-stream//lib/io/stream/buffered.rb#10
    def open(path, mode = T.unsafe(nil), **options); end

    # source://io-stream//lib/io/stream/buffered.rb#22
    def wrap(io, **options); end
  end
end

# source://io-stream//lib/io/stream/generic.rb#21
class IO::Stream::Generic
  # @return [Generic] a new instance of Generic
  #
  # source://io-stream//lib/io/stream/generic.rb#22
  def initialize(block_size: T.unsafe(nil), maximum_read_size: T.unsafe(nil)); end

  # Writes `string` to the stream and returns self.
  #
  # source://io-stream//lib/io/stream/generic.rb#164
  def <<(string); end

  # Returns the value of attribute block_size.
  #
  # source://io-stream//lib/io/stream/generic.rb#38
  def block_size; end

  # Sets the attribute block_size
  #
  # @param value the value to set the attribute block_size to.
  #
  # source://io-stream//lib/io/stream/generic.rb#38
  def block_size=(_arg0); end

  # Best effort to flush any unwritten data, and then close the underling IO.
  #
  # source://io-stream//lib/io/stream/generic.rb#190
  def close; end

  # source://io-stream//lib/io/stream/generic.rb#182
  def close_read; end

  # source://io-stream//lib/io/stream/generic.rb#185
  def close_write; end

  # @return [Boolean]
  #
  # source://io-stream//lib/io/stream/generic.rb#178
  def closed?; end

  # @raise [EOFError]
  #
  # source://io-stream//lib/io/stream/generic.rb#216
  def eof!; end

  # Determins if the stream has consumed all available data. May block if the stream is not readable.
  # See {readable?} for a non-blocking alternative.
  #
  # @return [Boolean]
  #
  # source://io-stream//lib/io/stream/generic.rb#206
  def eof?; end

  # Flushes buffered data to the stream.
  #
  # source://io-stream//lib/io/stream/generic.rb#133
  def flush; end

  # source://io-stream//lib/io/stream/generic.rb#128
  def gets(separator = T.unsafe(nil), **options); end

  # source://io-stream//lib/io/stream/generic.rb#111
  def peek(size = T.unsafe(nil)); end

  # source://io-stream//lib/io/stream/generic.rb#170
  def puts(*arguments, separator: T.unsafe(nil)); end

  # Reads `size` bytes from the stream. If size is not specified, read until end of file.
  #
  # source://io-stream//lib/io/stream/generic.rb#41
  def read(size = T.unsafe(nil)); end

  # @raise [exception]
  #
  # source://io-stream//lib/io/stream/generic.rb#72
  def read_exactly(size, exception: T.unsafe(nil)); end

  # Read at most `size` bytes from the stream. Will avoid reading from the underlying stream if possible.
  #
  # source://io-stream//lib/io/stream/generic.rb#62
  def read_partial(size = T.unsafe(nil)); end

  # Efficiently read data from the stream until encountering pattern.
  #
  # @param pattern [String] The pattern to match.
  # @return [String] The contents of the stream up until the pattern, which is consumed but not returned.
  #
  # source://io-stream//lib/io/stream/generic.rb#92
  def read_until(pattern, offset = T.unsafe(nil), chomp: T.unsafe(nil)); end

  # Whether there is a chance that a read operation will succeed or not.
  #
  # @return [Boolean]
  #
  # source://io-stream//lib/io/stream/generic.rb#225
  def readable?; end

  # This is a compatibility shim for existing code that uses `readpartial`.
  #
  # source://io-stream//lib/io/stream/generic.rb#85
  def readpartial(size = T.unsafe(nil)); end

  # Writes `string` to the buffer. When the buffer is full or #sync is true the
  # buffer is flushed to the underlying `io`.
  #
  # @param string the string to write to the buffer.
  # @return the number of bytes appended to the buffer.
  #
  # source://io-stream//lib/io/stream/generic.rb#153
  def write(string); end

  protected

  # @raise [NotImplementedError]
  #
  # source://io-stream//lib/io/stream/generic.rb#242
  def sysclose; end

  # Reads data from the underlying stream as efficiently as possible.
  #
  # @raise [NotImplementedError]
  #
  # source://io-stream//lib/io/stream/generic.rb#251
  def sysread(size, buffer); end

  # @raise [NotImplementedError]
  #
  # source://io-stream//lib/io/stream/generic.rb#246
  def syswrite(buffer); end

  private

  # Consumes at most `size` bytes from the buffer.
  #
  # @param size [Integer|nil] The amount of data to consume. If nil, consume entire buffer.
  #
  # source://io-stream//lib/io/stream/generic.rb#288
  def consume_read_buffer(size = T.unsafe(nil)); end

  # Fills the buffer from the underlying stream.
  #
  # source://io-stream//lib/io/stream/generic.rb#258
  def fill_read_buffer(size = T.unsafe(nil)); end
end

# The maximum read size when appending to IO buffers. Defaults to 8MB.
#
# source://io-stream//lib/io/stream/generic.rb#19
IO::Stream::MAXIMUM_READ_SIZE = T.let(T.unsafe(nil), Integer)

# source://io-stream//lib/io/stream/string_buffer.rb#7
class IO::Stream::StringBuffer < ::String
  # @return [StringBuffer] a new instance of StringBuffer
  #
  # source://io-stream//lib/io/stream/string_buffer.rb#10
  def initialize; end

  # source://io-stream//lib/io/stream/string_buffer.rb#16
  def <<(string); end

  # source://io-stream//lib/io/stream/string_buffer.rb#16
  def concat(string); end
end

# source://io-stream//lib/io/stream/string_buffer.rb#8
IO::Stream::StringBuffer::BINARY = T.let(T.unsafe(nil), Encoding)

# source://io-stream//lib/io/stream/version.rb#7
IO::Stream::VERSION = T.let(T.unsafe(nil), String)

# Compatibility shim.
class IO::TimeoutError < ::IOError; end

IO::WRITABLE = T.let(T.unsafe(nil), Integer)

# source://io-stream//lib/io/stream/shim/readable.rb#47
class OpenSSL::SSL::SSLSocket
  include ::Enumerable

  # source://io-stream//lib/io/stream/openssl.rb#12
  def close_read; end

  # source://io-stream//lib/io/stream/openssl.rb#18
  def close_write; end

  # @return [Boolean]
  #
  # source://io-stream//lib/io/stream/shim/readable.rb#49
  def readable?; end

  # source://io-stream//lib/io/stream/openssl.rb#36
  def timeout; end

  # source://io-stream//lib/io/stream/openssl.rb#42
  def timeout=(value); end

  # source://io-stream//lib/io/stream/openssl.rb#24
  def wait_readable(*_arg0, **_arg1, &_arg2); end

  # source://io-stream//lib/io/stream/openssl.rb#30
  def wait_writable(*_arg0, **_arg1, &_arg2); end
end

# source://io-stream//lib/io/stream/shim/buffered.rb#56
class StringIO
  include ::Enumerable

  # source://io-stream//lib/io/stream/shim/buffered.rb#61
  def buffered=(value); end

  # @return [Boolean]
  #
  # source://io-stream//lib/io/stream/shim/buffered.rb#57
  def buffered?; end

  # @return [Boolean]
  #
  # source://io-stream//lib/io/stream/shim/readable.rb#39
  def readable?; end
end
