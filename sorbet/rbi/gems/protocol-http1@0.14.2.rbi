# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `protocol-http1` gem.
# Please instead update this file by running `bin/tapioca gem protocol-http1`.

module Protocol; end
module Protocol::HTTP1; end
class Protocol::HTTP1::BadHeader < ::Protocol::HTTP1::Error; end

# The request was parsed correctly, but was invalid for some other reason.
class Protocol::HTTP1::BadRequest < ::Protocol::HTTP1::Error; end

class Protocol::HTTP1::BadResponse < ::Protocol::HTTP1::Error; end
module Protocol::HTTP1::Body; end

class Protocol::HTTP1::Body::Chunked < ::Protocol::HTTP::Body::Readable
  # @return [Chunked] a new instance of Chunked
  def initialize(stream, headers); end

  def close(error = T.unsafe(nil)); end

  # @return [Boolean]
  def empty?; end

  def inspect; end

  # Follows the procedure outlined in https://tools.ietf.org/html/rfc7230#section-4.1.3
  def read; end

  private

  def read_line; end

  # @return [Boolean]
  def read_line?; end

  def read_trailer; end
end

Protocol::HTTP1::Body::Chunked::CRLF = T.let(T.unsafe(nil), String)

class Protocol::HTTP1::Body::Fixed < ::Protocol::HTTP::Body::Readable
  # @return [Fixed] a new instance of Fixed
  def initialize(stream, length); end

  def close(error = T.unsafe(nil)); end

  # @return [Boolean]
  def empty?; end

  def inspect; end
  def join; end

  # Returns the value of attribute length.
  def length; end

  def read; end

  # Returns the value of attribute remaining.
  def remaining; end
end

class Protocol::HTTP1::Body::Remainder < ::Protocol::HTTP::Body::Readable
  # block_size may be removed in the future. It is better managed by stream.
  #
  # @return [Remainder] a new instance of Remainder
  def initialize(stream); end

  def call(stream); end
  def close(error = T.unsafe(nil)); end

  # @return [Boolean]
  def empty?; end

  def inspect; end
  def join; end

  # TODO this is a bit less efficient in order to maintain compatibility with `IO`.
  def read; end
end

Protocol::HTTP1::Body::Remainder::BLOCK_SIZE = T.let(T.unsafe(nil), Integer)
Protocol::HTTP1::CHUNKED = T.let(T.unsafe(nil), String)
Protocol::HTTP1::CLOSE = T.let(T.unsafe(nil), String)
Protocol::HTTP1::CONNECTION = T.let(T.unsafe(nil), String)
Protocol::HTTP1::CONTENT_LENGTH = T.let(T.unsafe(nil), String)

class Protocol::HTTP1::Connection
  # @return [Connection] a new instance of Connection
  def initialize(stream, persistent = T.unsafe(nil)); end

  # Close the connection and underlying stream.
  def close; end

  # The number of requests processed.
  def count; end

  # Effectively close the connection and return the underlying IO.
  #
  # @return [IO] the underlying non-blocking IO.
  def hijack!; end

  # Whether the connection is persistent.
  def persistent; end

  # @return [Boolean]
  def persistent?(version, method, headers); end

  def read_body(headers, remainder = T.unsafe(nil)); end
  def read_chunked_body(headers); end
  def read_fixed_body(length); end
  def read_head_body(length); end
  def read_headers; end
  def read_line; end

  # @return [Boolean]
  def read_line?; end

  def read_remainder_body; end
  def read_request; end
  def read_request_body(method, headers); end
  def read_response(method); end
  def read_response_body(method, status, headers); end
  def read_tunnel_body; end
  def read_upgrade_body(protocol); end

  # Returns the value of attribute stream.
  def stream; end

  # @return [Boolean]
  def upgrade?(headers); end

  def write_body(version, body, head = T.unsafe(nil), trailer = T.unsafe(nil)); end
  def write_body_and_close(body, head); end
  def write_chunked_body(body, head, trailer = T.unsafe(nil)); end

  # Write the appropriate header for connection persistence.
  def write_connection_header(version); end

  def write_empty_body(body); end
  def write_fixed_length_body(body, length, head); end
  def write_headers(headers); end
  def write_request(authority, method, path, version, headers); end
  def write_response(version, status, headers, reason = T.unsafe(nil)); end
  def write_tunnel_body(version, body = T.unsafe(nil)); end

  # @param protocol [String] the protocol to upgrade to.
  def write_upgrade_body(protocol, body = T.unsafe(nil)); end

  def write_upgrade_header(upgrade); end
end

Protocol::HTTP1::Connection::CONNECT = T.let(T.unsafe(nil), String)
Protocol::HTTP1::Connection::CRLF = T.let(T.unsafe(nil), String)
Protocol::HTTP1::Connection::HEAD = T.let(T.unsafe(nil), String)
Protocol::HTTP1::Connection::HTTP10 = T.let(T.unsafe(nil), String)
Protocol::HTTP1::Connection::HTTP11 = T.let(T.unsafe(nil), String)
class Protocol::HTTP1::Error < ::Protocol::HTTP::Error; end

# HTTP/1.x header parser:
Protocol::HTTP1::FIELD_NAME = T.let(T.unsafe(nil), Regexp)

Protocol::HTTP1::FIELD_VALUE = T.let(T.unsafe(nil), Regexp)
Protocol::HTTP1::HEADER = T.let(T.unsafe(nil), Regexp)
Protocol::HTTP1::HOST = T.let(T.unsafe(nil), String)
class Protocol::HTTP1::InvalidRequest < ::Protocol::HTTP1::Error; end
Protocol::HTTP1::KEEP_ALIVE = T.let(T.unsafe(nil), String)
Protocol::HTTP1::REQUEST_LINE = T.let(T.unsafe(nil), Regexp)
module Protocol::HTTP1::Reason; end
Protocol::HTTP1::Reason::DESCRIPTIONS = T.let(T.unsafe(nil), Hash)

# HTTP/1.x request line parser:
Protocol::HTTP1::TOKEN = T.let(T.unsafe(nil), Regexp)

Protocol::HTTP1::TRANSFER_ENCODING = T.let(T.unsafe(nil), String)
Protocol::HTTP1::UPGRADE = T.let(T.unsafe(nil), String)
Protocol::HTTP1::VALID_FIELD_NAME = T.let(T.unsafe(nil), Regexp)
Protocol::HTTP1::VALID_FIELD_VALUE = T.let(T.unsafe(nil), Regexp)
Protocol::HTTP1::VERSION = T.let(T.unsafe(nil), String)
