# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: true
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/async/all/async.rbi
#
# async-1.30.1

module Async
  def self.run(*arguments, &block); end
  extend Console
end
class Async::List
  def delete(item); end
  def each(&block); end
  def empty?; end
  def first; end
  def head; end
  def head=(arg0); end
  def include?(needle); end
  def initialize; end
  def insert(item); end
  def last; end
  def nil?; end
  def size; end
  def tail; end
  def tail=(arg0); end
end
class Async::Children < Async::List
  def delete(item); end
  def finished?; end
  def initialize; end
  def insert(item); end
  def transients?; end
end
class Async::Node
  def add_child(child); end
  def annotate(annotation); end
  def annotation; end
  def backtrace(*arguments); end
  def children; end
  def children?; end
  def consume; end
  def delete_child(child); end
  def description; end
  def finished?; end
  def head; end
  def head=(arg0); end
  def initialize(parent = nil, annotation: nil, transient: nil); end
  def parent; end
  def parent=(parent); end
  def print_backtrace(out, indent, node); end
  def print_hierarchy(out = nil, backtrace: nil); end
  def set_parent(parent); end
  def stop(later = nil); end
  def stop_children(later = nil); end
  def tail; end
  def tail=(arg0); end
  def terminate; end
  def to_s; end
  def transient?; end
  def traverse(level = nil, &block); end
end
class Async::Condition
  def empty?; end
  def initialize; end
  def signal(value = nil); end
  def wait; end
end
class Async::Stop < Exception
end
class Async::Stop::Later
  def alive?; end
  def initialize(task); end
  def resume; end
end
class Async::Task < Async::Node
  def alive?; end
  def async(*arguments, **options, &block); end
  def complete?; end
  def current?; end
  def fail!(exception = nil, propagate = nil); end
  def failed?; end
  def fiber; end
  def finish!; end
  def finished?; end
  def initialize(reactor, parent = nil, logger: nil, finished: nil, **options, &block); end
  def logger; end
  def make_fiber(&block); end
  def reactor; end
  def result; end
  def run(*arguments); end
  def running?; end
  def self.current; end
  def self.current?; end
  def self.yield; end
  def set!; end
  def sleep(*args, &block); end
  def status; end
  def stop!; end
  def stop(later = nil); end
  def stopped?; end
  def stopping?; end
  def to_s; end
  def wait; end
  def with_timeout(*args, &block); end
  def yield; end
  extend Forwardable
end
class Async::Wrapper
  def cancel_monitor; end
  def close; end
  def closed?; end
  def dup; end
  def initialize(io, reactor = nil); end
  def interests; end
  def io; end
  def monitor; end
  def reactor; end
  def reactor=(reactor); end
  def resume(*arguments); end
  def wait_any(timeout = nil); end
  def wait_for(timeout); end
  def wait_readable(timeout = nil); end
  def wait_writable(timeout = nil); end
end
class Async::Wrapper::Cancelled < StandardError
  def cause; end
  def initialize; end
end
class Async::Wrapper::Cancelled::From
  def backtrace; end
  def cause; end
  def initialize; end
  def message; end
end
class Async::Wrapper::WaitError < StandardError
  def initialize; end
end
class Async::Clock
  def initialize(total = nil); end
  def self.measure; end
  def self.now; end
  def self.start; end
  def start!; end
  def stop!; end
  def total; end
end
class Async::Scheduler
  def block(blocker, timeout); end
  def clear!; end
  def close; end
  def fiber(&block); end
  def from_io(io); end
  def initialize(reactor); end
  def io_wait(io, events, timeout = nil); end
  def kernel_sleep(duration); end
  def process_wait(pid, flags); end
  def self.supported?; end
  def set!; end
  def unblock(blocker, fiber); end
  def wrappers; end
end
class Async::TimeoutError < StandardError
end
class Async::Reactor < Async::Node
  def <<(fiber); end
  def async(*arguments, **options, &block); end
  def block(blocker, timeout); end
  def close; end
  def closed?; end
  def fiber(&block); end
  def finished?; end
  def initialize(parent = nil, selector: nil, logger: nil); end
  def interrupt; end
  def logger; end
  def register(io, interest, value = nil); end
  def run(*arguments, **options, &block); end
  def run_once(timeout = nil); end
  def scheduler; end
  def self.run(*arguments, **options, &block); end
  def self.selector; end
  def sleep(duration); end
  def stopped?; end
  def to_s; end
  def unblock(blocker, fiber); end
  def with_timeout(timeout, exception = nil); end
  def yield(fiber = nil); end
  extend Forwardable
end
module Kernel
  def Async(*arguments, **options, &block); end
  def Sync(&block); end
end
class Async::Barrier
  def async(*arguments, parent: nil, **options, &block); end
  def empty?; end
  def initialize(parent: nil); end
  def size; end
  def stop; end
  def tasks; end
  def wait; end
end
class Async::Semaphore
  def acquire; end
  def async(*arguments, parent: nil, **options); end
  def blocking?; end
  def count; end
  def empty?; end
  def initialize(limit = nil, parent: nil); end
  def limit; end
  def release; end
  def wait; end
  def waiting; end
end
class Async::Notification < Async::Condition
  def signal(value = nil, task: nil); end
end
class Async::Notification::Signal < Struct
  def alive?; end
  def resume; end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
  def value; end
  def value=(_); end
  def waiting; end
  def waiting=(_); end
end
class Async::Queue < Async::Notification
  def <<(item); end
  def async(parent: nil, &block); end
  def dequeue; end
  def each; end
  def empty?; end
  def enqueue(item); end
  def initialize(parent: nil); end
  def items; end
  def size; end
end
class Async::LimitedQueue < Async::Queue
  def dequeue; end
  def enqueue(item); end
  def initialize(limit = nil, **options); end
  def limit; end
  def limited?; end
end
