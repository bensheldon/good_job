# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `crass` gem.
# Please instead update this file by running `bin/tapioca sync`.

# typed: true

module Crass
  class << self
    def parse(input, options = T.unsafe(nil)); end
    def parse_properties(input, options = T.unsafe(nil)); end
  end
end

class Crass::Parser
  def initialize(input, options = T.unsafe(nil)); end

  def consume_at_rule(input = T.unsafe(nil)); end
  def consume_component_value(input = T.unsafe(nil)); end
  def consume_declaration(input = T.unsafe(nil)); end
  def consume_declarations(input = T.unsafe(nil), options = T.unsafe(nil)); end
  def consume_function(input = T.unsafe(nil)); end
  def consume_qualified_rule(input = T.unsafe(nil)); end
  def consume_rules(flags = T.unsafe(nil)); end
  def consume_simple_block(input = T.unsafe(nil)); end
  def create_node(type, properties = T.unsafe(nil)); end
  def create_selector(input); end
  def create_style_rule(rule); end
  def parse_component_value(input = T.unsafe(nil)); end
  def parse_component_values(input = T.unsafe(nil)); end
  def parse_declaration(input = T.unsafe(nil)); end
  def parse_declarations(input = T.unsafe(nil), options = T.unsafe(nil)); end
  def parse_properties(input = T.unsafe(nil)); end
  def parse_rule(input = T.unsafe(nil)); end
  def parse_value(nodes); end
  def tokens; end

  class << self
    def parse_properties(input, options = T.unsafe(nil)); end
    def parse_rules(input, options = T.unsafe(nil)); end
    def parse_stylesheet(input, options = T.unsafe(nil)); end
    def stringify(nodes, options = T.unsafe(nil)); end
  end
end

Crass::Parser::BLOCK_END_TOKENS = T.let(T.unsafe(nil), Hash)

class Crass::Scanner
  def initialize(input); end

  def consume; end
  def consume_rest; end
  def current; end
  def eos?; end
  def mark; end
  def marked; end
  def marker; end
  def marker=(_arg0); end
  def peek(length = T.unsafe(nil)); end
  def pos; end
  def pos=(_arg0); end
  def reconsume; end
  def reset; end
  def scan(pattern); end
  def scan_until(pattern); end
  def string; end
end

class Crass::TokenScanner
  def initialize(tokens); end

  def collect; end
  def consume; end
  def current; end
  def peek; end
  def pos; end
  def reconsume; end
  def reset; end
  def tokens; end
end

class Crass::Tokenizer
  def initialize(input, options = T.unsafe(nil)); end

  def consume; end
  def consume_bad_url; end
  def consume_comments; end
  def consume_escaped; end
  def consume_ident; end
  def consume_name; end
  def consume_number; end
  def consume_numeric; end
  def consume_string(ending = T.unsafe(nil)); end
  def consume_unicode_range; end
  def consume_url; end
  def convert_string_to_number(str); end
  def create_token(type, properties = T.unsafe(nil)); end
  def preprocess(input); end
  def start_identifier?(text = T.unsafe(nil)); end
  def start_number?(text = T.unsafe(nil)); end
  def tokenize; end
  def valid_escape?(text = T.unsafe(nil)); end

  class << self
    def tokenize(input, options = T.unsafe(nil)); end
  end
end

Crass::Tokenizer::RE_COMMENT_CLOSE = T.let(T.unsafe(nil), Regexp)

Crass::Tokenizer::RE_DIGIT = T.let(T.unsafe(nil), Regexp)

Crass::Tokenizer::RE_ESCAPE = T.let(T.unsafe(nil), Regexp)

Crass::Tokenizer::RE_HEX = T.let(T.unsafe(nil), Regexp)

Crass::Tokenizer::RE_NAME = T.let(T.unsafe(nil), Regexp)

Crass::Tokenizer::RE_NAME_START = T.let(T.unsafe(nil), Regexp)

Crass::Tokenizer::RE_NON_PRINTABLE = T.let(T.unsafe(nil), Regexp)

Crass::Tokenizer::RE_NUMBER_DECIMAL = T.let(T.unsafe(nil), Regexp)

Crass::Tokenizer::RE_NUMBER_EXPONENT = T.let(T.unsafe(nil), Regexp)

Crass::Tokenizer::RE_NUMBER_SIGN = T.let(T.unsafe(nil), Regexp)

Crass::Tokenizer::RE_NUMBER_STR = T.let(T.unsafe(nil), Regexp)

Crass::Tokenizer::RE_QUOTED_URL_START = T.let(T.unsafe(nil), Regexp)

Crass::Tokenizer::RE_UNICODE_RANGE_END = T.let(T.unsafe(nil), Regexp)

Crass::Tokenizer::RE_UNICODE_RANGE_START = T.let(T.unsafe(nil), Regexp)

Crass::Tokenizer::RE_WHITESPACE = T.let(T.unsafe(nil), Regexp)

Crass::Tokenizer::RE_WHITESPACE_ANCHORED = T.let(T.unsafe(nil), Regexp)
