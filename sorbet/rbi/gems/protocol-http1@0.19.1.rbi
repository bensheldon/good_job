# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `protocol-http1` gem.
# Please instead update this file by running `bin/tapioca gem protocol-http1`.


# source://protocol-http1//lib/protocol/http1/version.rb#6
module Protocol; end

# source://protocol-http1//lib/protocol/http1/version.rb#7
module Protocol::HTTP1; end

# source://protocol-http1//lib/protocol/http1/error.rb#24
class Protocol::HTTP1::BadHeader < ::Protocol::HTTP1::Error; end

# The request was parsed correctly, but was invalid for some other reason.
#
# source://protocol-http1//lib/protocol/http1/error.rb#21
class Protocol::HTTP1::BadRequest < ::Protocol::HTTP1::Error; end

# source://protocol-http1//lib/protocol/http1/error.rb#27
class Protocol::HTTP1::BadResponse < ::Protocol::HTTP1::Error; end

# source://protocol-http1//lib/protocol/http1/body/chunked.rb#11
module Protocol::HTTP1::Body; end

# source://protocol-http1//lib/protocol/http1/body/chunked.rb#12
class Protocol::HTTP1::Body::Chunked < ::Protocol::HTTP::Body::Readable
  # @return [Chunked] a new instance of Chunked
  #
  # source://protocol-http1//lib/protocol/http1/body/chunked.rb#15
  def initialize(stream, headers); end

  # source://protocol-http1//lib/protocol/http1/body/chunked.rb#29
  def close(error = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://protocol-http1//lib/protocol/http1/body/chunked.rb#25
  def empty?; end

  # source://protocol-http1//lib/protocol/http1/body/chunked.rb#74
  def inspect; end

  # Follows the procedure outlined in https://tools.ietf.org/html/rfc7230#section-4.1.3
  #
  # source://protocol-http1//lib/protocol/http1/body/chunked.rb#42
  def read; end

  private

  # source://protocol-http1//lib/protocol/http1/body/chunked.rb#84
  def read_line; end

  # @return [Boolean]
  #
  # source://protocol-http1//lib/protocol/http1/body/chunked.rb#80
  def read_line?; end

  # source://protocol-http1//lib/protocol/http1/body/chunked.rb#88
  def read_trailer; end
end

# source://protocol-http1//lib/protocol/http1/body/chunked.rb#13
Protocol::HTTP1::Body::Chunked::CRLF = T.let(T.unsafe(nil), String)

# source://protocol-http1//lib/protocol/http1/body/chunked.rb#39
Protocol::HTTP1::Body::Chunked::VALID_CHUNK_LENGTH = T.let(T.unsafe(nil), Regexp)

# source://protocol-http1//lib/protocol/http1/body/fixed.rb#11
class Protocol::HTTP1::Body::Fixed < ::Protocol::HTTP::Body::Readable
  # @return [Fixed] a new instance of Fixed
  #
  # source://protocol-http1//lib/protocol/http1/body/fixed.rb#12
  def initialize(stream, length); end

  # source://protocol-http1//lib/protocol/http1/body/fixed.rb#25
  def close(error = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://protocol-http1//lib/protocol/http1/body/fixed.rb#21
  def empty?; end

  # source://protocol-http1//lib/protocol/http1/body/fixed.rb#56
  def inspect; end

  # source://protocol-http1//lib/protocol/http1/body/fixed.rb#48
  def join; end

  # Returns the value of attribute length.
  #
  # source://protocol-http1//lib/protocol/http1/body/fixed.rb#18
  def length; end

  # source://protocol-http1//lib/protocol/http1/body/fixed.rb#35
  def read; end

  # Returns the value of attribute remaining.
  #
  # source://protocol-http1//lib/protocol/http1/body/fixed.rb#19
  def remaining; end
end

# source://protocol-http1//lib/protocol/http1/body/remainder.rb#11
class Protocol::HTTP1::Body::Remainder < ::Protocol::HTTP::Body::Readable
  # block_size may be removed in the future. It is better managed by stream.
  #
  # @return [Remainder] a new instance of Remainder
  #
  # source://protocol-http1//lib/protocol/http1/body/remainder.rb#15
  def initialize(stream); end

  # source://protocol-http1//lib/protocol/http1/body/remainder.rb#42
  def call(stream); end

  # source://protocol-http1//lib/protocol/http1/body/remainder.rb#24
  def close(error = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://protocol-http1//lib/protocol/http1/body/remainder.rb#20
  def empty?; end

  # source://protocol-http1//lib/protocol/http1/body/remainder.rb#56
  def inspect; end

  # source://protocol-http1//lib/protocol/http1/body/remainder.rb#50
  def join; end

  # TODO this is a bit less efficient in order to maintain compatibility with `IO`.
  #
  # source://protocol-http1//lib/protocol/http1/body/remainder.rb#33
  def read; end
end

# source://protocol-http1//lib/protocol/http1/body/remainder.rb#12
Protocol::HTTP1::Body::Remainder::BLOCK_SIZE = T.let(T.unsafe(nil), Integer)

# source://protocol-http1//lib/protocol/http1/connection.rb#27
Protocol::HTTP1::CHUNKED = T.let(T.unsafe(nil), String)

# source://protocol-http1//lib/protocol/http1/connection.rb#30
Protocol::HTTP1::CLOSE = T.let(T.unsafe(nil), String)

# source://protocol-http1//lib/protocol/http1/connection.rb#29
Protocol::HTTP1::CONNECTION = T.let(T.unsafe(nil), String)

# source://protocol-http1//lib/protocol/http1/connection.rb#24
Protocol::HTTP1::CONTENT_LENGTH = T.let(T.unsafe(nil), String)

# source://protocol-http1//lib/protocol/http1/connection.rb#48
class Protocol::HTTP1::Connection
  # @return [Connection] a new instance of Connection
  #
  # source://protocol-http1//lib/protocol/http1/connection.rb#53
  def initialize(stream, persistent = T.unsafe(nil)); end

  # Close the connection and underlying stream.
  #
  # source://protocol-http1//lib/protocol/http1/connection.rb#129
  def close; end

  # The number of requests processed.
  #
  # source://protocol-http1//lib/protocol/http1/connection.rb#74
  def count; end

  # source://protocol-http1//lib/protocol/http1/connection.rb#442
  def extract_content_length(headers); end

  # Effectively close the connection and return the underlying IO.
  #
  # @return [IO] the underlying non-blocking IO.
  #
  # source://protocol-http1//lib/protocol/http1/connection.rb#118
  def hijack!; end

  # Indicates whether the connection has been hijacked meaning its
  # IO has been handed over and is not usable anymore.
  #
  # @return [Boolean] hijack status
  #
  # source://protocol-http1//lib/protocol/http1/connection.rb#112
  def hijacked?; end

  # Whether the connection is persistent.
  # This determines what connection headers are sent in the response and whether
  # the connection can be reused after the response is sent.
  # This setting is automatically managed according to the nature of the request
  # and response.
  # Changing to false is safe.
  # Changing to true from outside this class should generally be avoided and,
  # depending on the response semantics, may be reset to false anyway.
  #
  # source://protocol-http1//lib/protocol/http1/connection.rb#71
  def persistent; end

  # Whether the connection is persistent.
  # This determines what connection headers are sent in the response and whether
  # the connection can be reused after the response is sent.
  # This setting is automatically managed according to the nature of the request
  # and response.
  # Changing to false is safe.
  # Changing to true from outside this class should generally be avoided and,
  # depending on the response semantics, may be reset to false anyway.
  #
  # source://protocol-http1//lib/protocol/http1/connection.rb#71
  def persistent=(_arg0); end

  # @return [Boolean]
  #
  # source://protocol-http1//lib/protocol/http1/connection.rb#76
  def persistent?(version, method, headers); end

  # source://protocol-http1//lib/protocol/http1/connection.rb#503
  def read_body(headers, remainder = T.unsafe(nil)); end

  # source://protocol-http1//lib/protocol/http1/connection.rb#417
  def read_chunked_body(headers); end

  # source://protocol-http1//lib/protocol/http1/connection.rb#421
  def read_fixed_body(length); end

  # source://protocol-http1//lib/protocol/http1/connection.rb#429
  def read_head_body(length); end

  # source://protocol-http1//lib/protocol/http1/connection.rb#233
  def read_headers; end

  # source://protocol-http1//lib/protocol/http1/connection.rb#180
  def read_line; end

  # @return [Boolean]
  #
  # source://protocol-http1//lib/protocol/http1/connection.rb#176
  def read_line?; end

  # source://protocol-http1//lib/protocol/http1/connection.rb#425
  def read_remainder_body; end

  # source://protocol-http1//lib/protocol/http1/connection.rb#196
  def read_request; end

  # source://protocol-http1//lib/protocol/http1/connection.rb#488
  def read_request_body(method, headers); end

  # source://protocol-http1//lib/protocol/http1/connection.rb#184
  def read_request_line; end

  # source://protocol-http1//lib/protocol/http1/connection.rb#219
  def read_response(method); end

  # source://protocol-http1//lib/protocol/http1/connection.rb#452
  def read_response_body(method, status, headers); end

  # source://protocol-http1//lib/protocol/http1/connection.rb#211
  def read_response_line; end

  # source://protocol-http1//lib/protocol/http1/connection.rb#433
  def read_tunnel_body; end

  # Returns the value of attribute stream.
  #
  # source://protocol-http1//lib/protocol/http1/connection.rb#61
  def stream; end

  # source://protocol-http1//lib/protocol/http1/connection.rb#386
  def write_body(version, body, head = T.unsafe(nil), trailer = T.unsafe(nil)); end

  # source://protocol-http1//lib/protocol/http1/connection.rb#365
  def write_body_and_close(body, head); end

  # source://protocol-http1//lib/protocol/http1/connection.rb#331
  def write_chunked_body(body, head, trailer = T.unsafe(nil)); end

  # Write the appropriate header for connection persistence.
  #
  # source://protocol-http1//lib/protocol/http1/connection.rb#97
  def write_connection_header(version); end

  # source://protocol-http1//lib/protocol/http1/connection.rb#292
  def write_empty_body(body); end

  # source://protocol-http1//lib/protocol/http1/connection.rb#299
  def write_fixed_length_body(body, length, head); end

  # source://protocol-http1//lib/protocol/http1/connection.rb#156
  def write_headers(headers); end

  # source://protocol-http1//lib/protocol/http1/connection.rb#147
  def write_interim_response(version, status, headers, reason = T.unsafe(nil)); end

  # source://protocol-http1//lib/protocol/http1/connection.rb#133
  def write_request(authority, method, path, version, headers); end

  # source://protocol-http1//lib/protocol/http1/connection.rb#140
  def write_response(version, status, headers, reason = T.unsafe(nil)); end

  # source://protocol-http1//lib/protocol/http1/connection.rb#272
  def write_tunnel_body(version, body = T.unsafe(nil)); end

  # @param protocol [String] the protocol to upgrade to.
  #
  # source://protocol-http1//lib/protocol/http1/connection.rb#251
  def write_upgrade_body(protocol, body = T.unsafe(nil)); end

  # source://protocol-http1//lib/protocol/http1/connection.rb#105
  def write_upgrade_header(upgrade); end
end

# source://protocol-http1//lib/protocol/http1/connection.rb#438
Protocol::HTTP1::Connection::CONNECT = T.let(T.unsafe(nil), String)

# source://protocol-http1//lib/protocol/http1/connection.rb#49
Protocol::HTTP1::Connection::CRLF = T.let(T.unsafe(nil), String)

# source://protocol-http1//lib/protocol/http1/connection.rb#437
Protocol::HTTP1::Connection::HEAD = T.let(T.unsafe(nil), String)

# source://protocol-http1//lib/protocol/http1/connection.rb#50
Protocol::HTTP1::Connection::HTTP10 = T.let(T.unsafe(nil), String)

# source://protocol-http1//lib/protocol/http1/connection.rb#51
Protocol::HTTP1::Connection::HTTP11 = T.let(T.unsafe(nil), String)

# source://protocol-http1//lib/protocol/http1/connection.rb#440
Protocol::HTTP1::Connection::VALID_CONTENT_LENGTH = T.let(T.unsafe(nil), Regexp)

# The specified content length and the given content's length do not match.
#
# source://protocol-http1//lib/protocol/http1/error.rb#17
class Protocol::HTTP1::ContentLengthError < ::Protocol::HTTP1::Error; end

# source://protocol-http1//lib/protocol/http1/error.rb#10
class Protocol::HTTP1::Error < ::Protocol::HTTP::Error; end

# HTTP/1.x header parser:
#
# source://protocol-http1//lib/protocol/http1/connection.rb#41
Protocol::HTTP1::FIELD_NAME = T.let(T.unsafe(nil), Regexp)

# source://protocol-http1//lib/protocol/http1/connection.rb#42
Protocol::HTTP1::FIELD_VALUE = T.let(T.unsafe(nil), Regexp)

# source://protocol-http1//lib/protocol/http1/connection.rb#43
Protocol::HTTP1::HEADER = T.let(T.unsafe(nil), Regexp)

# source://protocol-http1//lib/protocol/http1/connection.rb#33
Protocol::HTTP1::HOST = T.let(T.unsafe(nil), String)

# source://protocol-http1//lib/protocol/http1/error.rb#13
class Protocol::HTTP1::InvalidRequest < ::Protocol::HTTP1::Error; end

# source://protocol-http1//lib/protocol/http1/connection.rb#31
Protocol::HTTP1::KEEP_ALIVE = T.let(T.unsafe(nil), String)

# source://protocol-http1//lib/protocol/http1/connection.rb#38
Protocol::HTTP1::REQUEST_LINE = T.let(T.unsafe(nil), Regexp)

# source://protocol-http1//lib/protocol/http1/reason.rb#10
module Protocol::HTTP1::Reason; end

# source://protocol-http1//lib/protocol/http1/reason.rb#11
Protocol::HTTP1::Reason::DESCRIPTIONS = T.let(T.unsafe(nil), Hash)

# HTTP/1.x request line parser:
#
# source://protocol-http1//lib/protocol/http1/connection.rb#37
Protocol::HTTP1::TOKEN = T.let(T.unsafe(nil), Regexp)

# source://protocol-http1//lib/protocol/http1/connection.rb#26
Protocol::HTTP1::TRANSFER_ENCODING = T.let(T.unsafe(nil), String)

# source://protocol-http1//lib/protocol/http1/connection.rb#34
Protocol::HTTP1::UPGRADE = T.let(T.unsafe(nil), String)

# source://protocol-http1//lib/protocol/http1/connection.rb#45
Protocol::HTTP1::VALID_FIELD_NAME = T.let(T.unsafe(nil), Regexp)

# source://protocol-http1//lib/protocol/http1/connection.rb#46
Protocol::HTTP1::VALID_FIELD_VALUE = T.let(T.unsafe(nil), Regexp)

# source://protocol-http1//lib/protocol/http1/version.rb#8
Protocol::HTTP1::VERSION = T.let(T.unsafe(nil), String)
