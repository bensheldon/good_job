# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `async` gem.
# Please instead update this file by running `bin/tapioca gem async`.

module Async
  extend ::Console

  class << self
    # Invoke `Reactor.run` with all arguments/block.
    def run(*arguments, &block); end
  end
end

# A barrier is used to synchronize multiple tasks, waiting for them all to complete before continuing.
class Async::Barrier
  # @return [Barrier] a new instance of Barrier
  def initialize(parent: T.unsafe(nil)); end

  def async(*arguments, parent: T.unsafe(nil), **options, &block); end

  # @return [Boolean]
  def empty?; end

  def size; end
  def stop; end

  # All tasks which have been invoked into the barrier.
  def tasks; end

  # Wait for all tasks.
  def wait; end
end

class Async::Children < ::Async::List
  # @return [Children] a new instance of Children
  def initialize; end

  def delete(item); end

  # @return [Boolean]
  def finished?; end

  def insert(item); end

  # Does this node have (direct) transient children?
  #
  # @return [Boolean]
  def transients?; end
end

class Async::Clock
  # @return [Clock] a new instance of Clock
  def initialize(total = T.unsafe(nil)); end

  def start!; end
  def stop!; end
  def total; end

  class << self
    # Measure the execution of a block of code.
    def measure; end

    # Get the current elapsed monotonic time.
    def now; end

    def start; end
  end
end

# A synchronization primative, which allows fibers to wait until a particular condition is triggered. Signalling the condition directly resumes the waiting fibers and thus blocks the caller.
class Async::Condition
  # @return [Condition] a new instance of Condition
  def initialize; end

  # Is any fiber waiting on this notification?
  #
  # @return [Boolean]
  def empty?; end

  # Signal to a given task that it should resume operations.
  #
  # @param value The value to return to the waiting fibers.
  # @return [void]
  # @see Task.yield which is responsible for handling value.
  def signal(value = T.unsafe(nil)); end

  # Queue up the current fiber and wait on yielding the task.
  #
  # @return [Object]
  def wait; end
end

class Async::LimitedQueue < ::Async::Queue
  # @return [LimitedQueue] a new instance of LimitedQueue
  def initialize(limit = T.unsafe(nil), **options); end

  def dequeue; end
  def enqueue(item); end

  # Returns the value of attribute limit.
  def limit; end

  # @return [Boolean] Whether trying to enqueue an item would block.
  def limited?; end
end

# A double linked list.
class Async::List
  # @return [List] a new instance of List
  def initialize; end

  def delete(item); end
  def each(&block); end

  # @return [Boolean]
  def empty?; end

  def first; end

  # Returns the value of attribute head.
  def head; end

  # Sets the attribute head
  #
  # @param value the value to set the attribute head to.
  def head=(_arg0); end

  # @return [Boolean]
  def include?(needle); end

  # Inserts an item at the end of the list.
  def insert(item); end

  def last; end

  # @return [Boolean]
  def nil?; end

  # Returns the value of attribute size.
  def size; end

  # Returns the value of attribute tail.
  def tail; end

  # Sets the attribute tail
  #
  # @param value the value to set the attribute tail to.
  def tail=(_arg0); end
end

# Represents a node in a tree, used for nested {Task} instances.
class Async::Node
  # Create a new node in the tree.
  #
  # @param parent [Node, nil] This node will attach to the given parent.
  # @return [Node] a new instance of Node
  def initialize(parent = T.unsafe(nil), annotation: T.unsafe(nil), transient: T.unsafe(nil)); end

  def annotate(annotation); end

  # A useful identifier for the current node.
  def annotation; end

  def backtrace(*arguments); end

  # @attr children [List<Node>] Optional list of children.
  def children; end

  # Whether there are children?
  #
  # @return [Boolean]
  def children?; end

  # If the node has a parent, and is {finished?}, then remove this node from
  # the parent.
  def consume; end

  def description; end

  # Whether the node can be consumed safely. By default, checks if the
  # children set is empty.
  #
  # @return [Boolean]
  def finished?; end

  # You should not directly rely on these pointers but instead use `#children`.
  # List pointers:
  def head; end

  # You should not directly rely on these pointers but instead use `#children`.
  # List pointers:
  def head=(_arg0); end

  # @attr parent [Node, nil]
  def parent; end

  # Change the parent of this node.
  #
  # @param parent [Node, nil] the parent to attach to, or nil to detach.
  # @return [self]
  def parent=(parent); end

  def print_hierarchy(out = T.unsafe(nil), backtrace: T.unsafe(nil)); end

  # Attempt to stop the current node immediately, including all non-transient children.
  # Invokes {#stop_children} to stop all children.
  def stop(later = T.unsafe(nil)); end

  # Returns the value of attribute tail.
  def tail; end

  # Sets the attribute tail
  #
  # @param value the value to set the attribute tail to.
  def tail=(_arg0); end

  # Immediately terminate all children tasks, including transient tasks.
  # Internally invokes `stop(false)` on all children.
  def terminate; end

  def to_s; end

  # Is this node transient?
  #
  # @return [Boolean]
  def transient?; end

  # Traverse the tree.
  #
  # @yield [node, level] The node and the level relative to the given root.
  def traverse(level = T.unsafe(nil), &block); end

  protected

  def add_child(child); end
  def delete_child(child); end
  def set_parent(parent); end

  private

  def print_backtrace(out, indent, node); end

  # Attempt to stop all non-transient children.
  def stop_children(later = T.unsafe(nil)); end
end

# A synchronization primitive, which allows fibers to wait until a notification is received. Does not block the task which signals the notification. Waiting tasks are resumed on next iteration of the reactor.
class Async::Notification < ::Async::Condition
  # Signal to a given task that it should resume operations.
  #
  # @return [void]
  def signal(value = T.unsafe(nil), task: T.unsafe(nil)); end
end

class Async::Notification::Signal < ::Struct
  # @return [Boolean]
  def alive?; end

  def resume; end

  # Returns the value of attribute value
  #
  # @return [Object] the current value of value
  def value; end

  # Sets the attribute value
  #
  # @param value [Object] the value to set the attribute value to.
  # @return [Object] the newly set value
  def value=(_); end

  # Returns the value of attribute waiting
  #
  # @return [Object] the current value of waiting
  def waiting; end

  # Sets the attribute waiting
  #
  # @param value [Object] the value to set the attribute waiting to.
  # @return [Object] the newly set value
  def waiting=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def members; end
    def new(*_arg0); end
  end
end

# A queue which allows items to be processed in order.
class Async::Queue < ::Async::Notification
  # @return [Queue] a new instance of Queue
  def initialize(parent: T.unsafe(nil)); end

  def <<(item); end
  def async(parent: T.unsafe(nil), &block); end
  def dequeue; end
  def each; end

  # @return [Boolean]
  def empty?; end

  def enqueue(item); end

  # Returns the value of attribute items.
  def items; end

  def size; end
end

# An asynchronous, cooperatively scheduled event reactor.
class Async::Reactor < ::Async::Node
  extend ::Forwardable

  # @return [Reactor] a new instance of Reactor
  def initialize(parent = T.unsafe(nil), selector: T.unsafe(nil), logger: T.unsafe(nil)); end

  # Schedule a fiber (or equivalent object) to be resumed on the next loop through the reactor.
  #
  # @param fiber [#resume] The object to be resumed on the next iteration of the run-loop.
  def <<(fiber); end

  # Start an asynchronous task within the specified reactor. The task will be
  # executed until the first blocking call, at which point it will yield and
  # and this method will return.
  #
  # This is the main entry point for scheduling asynchronus tasks.
  #
  # @return [Task] The task that was scheduled into the reactor.
  # @yield [Task] Executed within the task.
  def async(*arguments, **options, &block); end

  def block(blocker, timeout); end

  # Stop each of the children tasks and close the selector.
  def close; end

  # Check if the selector has been closed.
  #
  # @return [Boolean]
  def closed?; end

  def fiber(&block); end

  # @return [Boolean]
  def finished?; end

  # Interrupt the reactor at the earliest convenience. Can be called from a different thread safely.
  def interrupt; end

  # Returns the value of attribute logger.
  def logger; end

  def register(io, interest, value = T.unsafe(nil)); end

  # Run the reactor until all tasks are finished. Proxies arguments to {#async} immediately before entering the loop, if a block is provided.
  def run(*arguments, **options, &block); end

  # Run one iteration of the event loop.
  #
  # @param timeout [Float | nil] the maximum timeout, or if nil, indefinite.
  # @return [Boolean] whether there is more work to do.
  def run_once(timeout = T.unsafe(nil)); end

  # Returns the value of attribute scheduler.
  def scheduler; end

  # Put the calling fiber to sleep for a given ammount of time.
  def sleep(duration); end

  # @return [Boolean]
  def stopped?; end

  def to_s; end
  def unblock(blocker, fiber); end

  # Invoke the block, but after the specified timeout, raise {TimeoutError} in any currenly blocking operation. If the block runs to completion before the timeout occurs or there are no non-blocking operations after the timeout expires, the code will complete without any exception.
  #
  # @param duration [Numeric] The time in seconds, in which the task should
  #   complete.
  def with_timeout(timeout, exception = T.unsafe(nil)); end

  # Yield the current fiber and resume it on the next iteration of the event loop.
  def yield(fiber = T.unsafe(nil)); end

  class << self
    # The preferred method to invoke asynchronous behavior at the top level.
    #
    # - When invoked within an existing reactor task, it will run the given block
    # asynchronously. Will return the task once it has been scheduled.
    # - When invoked at the top level, will create and run a reactor, and invoke
    # the block as an asynchronous task. Will block until the reactor finishes
    # running.
    def run(*arguments, **options, &block); end

    def selector; end
  end
end

class Async::Scheduler
  # @return [Scheduler] a new instance of Scheduler
  def initialize(reactor); end

  def block(blocker, timeout); end
  def clear!; end
  def close; end
  def fiber(&block); end
  def io_wait(io, events, timeout = T.unsafe(nil)); end
  def kernel_sleep(duration); end

  # Wait for the specified process ID to exit.
  def process_wait(pid, flags); end

  def set!; end
  def unblock(blocker, fiber); end

  # Returns the value of attribute wrappers.
  def wrappers; end

  private

  def from_io(io); end

  class << self
    # @return [Boolean]
    def supported?; end
  end
end

# A semaphore is used to control access to a common resource in a concurrent system. A useful way to think of a semaphore as used in the real-world systems is as a record of how many units of a particular resource are available, coupled with operations to adjust that record safely (i.e. to avoid race conditions) as units are required or become free, and, if necessary, wait until a unit of the resource becomes available.
class Async::Semaphore
  # @return [Semaphore] a new instance of Semaphore
  def initialize(limit = T.unsafe(nil), parent: T.unsafe(nil)); end

  # Acquire the semaphore, block if we are at the limit.
  # If no block is provided, you must call release manually.
  #
  # @return the result of the block if invoked
  # @yield when the semaphore can be acquired
  def acquire; end

  # Run an async task. Will wait until the semaphore is ready until spawning and running the task.
  def async(*arguments, parent: T.unsafe(nil), **options); end

  # Whether trying to acquire this semaphore would block.
  #
  # @return [Boolean]
  def blocking?; end

  # The current number of tasks that have acquired the semaphore.
  def count; end

  # Is the semaphore currently acquired?
  #
  # @return [Boolean]
  def empty?; end

  # The maximum number of tasks that can acquire the semaphore.
  def limit; end

  # Release the semaphore. Must match up with a corresponding call to `acquire`. Will release waiting fibers in FIFO order.
  def release; end

  # The tasks waiting on this semaphore.
  def waiting; end

  private

  # Wait until the semaphore becomes available.
  def wait; end
end

# Raised when a task is explicitly stopped.
class Async::Stop < ::Exception; end

class Async::Stop::Later
  # @return [Later] a new instance of Later
  def initialize(task); end

  # @return [Boolean]
  def alive?; end

  def resume; end
end

# A task represents the state associated with the execution of an asynchronous
# block.
class Async::Task < ::Async::Node
  extend ::Forwardable

  # Create a new task.
  #
  # @param reactor [Async::Reactor] the reactor this task will run within.
  # @param parent [Async::Task] the parent task.
  # @return [Task] a new instance of Task
  def initialize(reactor, parent = T.unsafe(nil), logger: T.unsafe(nil), finished: T.unsafe(nil), **options, &block); end

  # @return [Boolean]
  def alive?; end

  def async(*arguments, **options, &block); end
  def backtrace(*arguments); end

  # @return [Boolean]
  def complete?; end

  # @return [Boolean]
  def current?; end

  # @return [Boolean]
  def failed?; end

  # @attr fiber [Fiber] The fiber which is being used for the execution of this task.
  def fiber; end

  # Whether we can remove this node from the reactor graph.
  #
  # @return [Boolean]
  def finished?; end

  # Returns the value of attribute logger.
  def logger; end

  # @attr ios [Reactor] The reactor the task was created within.
  def reactor; end

  # Retrieve the current result of the task. Will cause the caller to wait until result is available.
  # Deprecated.
  #
  # @raise [RuntimeError] if the task's fiber is the current fiber.
  # @return [Object] the final expression/result of the task's block.
  def result; end

  # Begin the execution of the task.
  def run(*arguments); end

  # Check if the task is running.
  #
  # @return [Boolean]
  def running?; end

  def sleep(*args, &block); end

  # @attr status [Symbol] The status of the execution of the fiber, one of `:initialized`, `:running`, `:complete`, `:stopped` or `:failed`.
  def status; end

  # Stop the task and all of its children.
  def stop(later = T.unsafe(nil)); end

  # @return [Boolean]
  def stopped?; end

  # @return [Boolean]
  def stopping?; end

  def to_s; end

  # Retrieve the current result of the task. Will cause the caller to wait until result is available.
  #
  # @raise [RuntimeError] if the task's fiber is the current fiber.
  # @return [Object] the final expression/result of the task's block.
  def wait; end

  def with_timeout(*args, &block); end

  # Yield back to the reactor and allow other fibers to execute.
  def yield; end

  private

  # This is a very tricky aspect of tasks to get right. I've modelled it after `Thread` but it's slightly different in that the exception can propagate back up through the reactor. If the user writes code which raises an exception, that exception should always be visible, i.e. cause a failure. If it's not visible, such code fails silently and can be very difficult to debug.
  # As an explcit choice, the user can start a task which doesn't propagate exceptions. This only applies to `StandardError` and derived tasks. This allows tasks to internally capture their error state which is raised when invoking `Task#result` similar to how `Thread#join` works. This mode makes {ruby Async::Task} behave more like a promise, and you would need to ensure that someone calls `Task#result` otherwise you might miss important errors.
  def fail!(exception = T.unsafe(nil), propagate = T.unsafe(nil)); end

  # Finish the current task, and all bound bound IO objects.
  def finish!; end

  def make_fiber(&block); end

  # Set the current fiber's `:async_task` to this task.
  def set!; end

  def stop!; end

  class << self
    # Lookup the {Task} for the current fiber. Raise `RuntimeError` if none is available.
    #
    # @raise [RuntimeError] if task was not {set!} for the current fiber.
    # @return [Async::Task]
    def current; end

    # Check if there is a task defined for the current fiber.
    #
    # @return [Async::Task, nil]
    def current?; end

    # Yield the unerlying `result` for the task. If the result
    # is an Exception, then that result will be raised an its
    # exception.
    #
    # @raise [Exception] if the result is an exception
    # @return [Object] result of the task
    # @yield [result] result of the task if a block if given.
    def yield; end
  end
end

# Raised if a timeout occurs on a specific Fiber. Handled gracefully by `Task`.
class Async::TimeoutError < ::StandardError; end

Async::VERSION = T.let(T.unsafe(nil), String)

# Represents an asynchronous IO within a reactor.
class Async::Wrapper
  # @param io the native object to wrap.
  # @param reactor [Reactor] the reactor that is managing this wrapper, or not specified, it's looked up by way of {Task.current}.
  # @return [Wrapper] a new instance of Wrapper
  def initialize(io, reactor = T.unsafe(nil)); end

  # Close the io and monitor.
  def close; end

  # @return [Boolean]
  def closed?; end

  def dup; end

  # The underlying native `io`.
  def io; end

  # The monitor for this wrapper, if any.
  def monitor; end

  # The reactor this wrapper is associated with, if any.
  def reactor; end

  # Bind this wrapper to a different reactor. Assign nil to convert to an unbound wrapper (can be used from any reactor/task but with slightly increased overhead.)
  # Binding to a reactor is purely a performance consideration. Generally, I don't like APIs that exist only due to optimisations. This is borderline, so consider this functionality semi-private.
  def reactor=(reactor); end

  def resume(*arguments); end

  # Wait fo the io to become either readable or writable.
  #
  # @param duration [Float] timeout after the given duration if not `nil`.
  # @raise [WaitError]
  def wait_any(timeout = T.unsafe(nil)); end

  # Wait for the io to become readable.
  #
  # @raise [WaitError]
  def wait_readable(timeout = T.unsafe(nil)); end

  # Wait for the io to become writable.
  #
  # @raise [WaitError]
  def wait_writable(timeout = T.unsafe(nil)); end

  private

  def cancel_monitor; end

  # What an abomination.
  def interests; end

  def wait_for(timeout); end
end

class Async::Wrapper::Cancelled < ::StandardError
  # @return [Cancelled] a new instance of Cancelled
  def initialize; end

  # Returns the value of attribute cause.
  def cause; end
end

class Async::Wrapper::Cancelled::From
  # @return [From] a new instance of From
  def initialize; end

  # Returns the value of attribute backtrace.
  def backtrace; end

  def cause; end
  def message; end
end

# wait_readable, wait_writable and wait_any are not re-entrant, and will raise this failure.
class Async::Wrapper::WaitError < ::StandardError
  # @return [WaitError] a new instance of WaitError
  def initialize; end
end

module Kernel
  # Run the given block of code in a task, asynchronously, creating a reactor if necessary.
  def Async(*arguments, **options, &block); end

  # Run the given block of code synchronously, but within a reactor if not already in one.
  def Sync(&block); end
end
