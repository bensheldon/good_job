# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: strict
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/commander/all/commander.rbi
#
# commander-4.6.0

module Commander
  def configure(*configuration_opts, &configuration_block); end
  def self.configure(*configuration_opts, &configuration_block); end
end
module Blank
  def self.included(base); end
end
module Commander::UI
  def applescript(script); end
  def ask_editor(input = nil, preferred_editor = nil); end
  def available_editor(preferred = nil); end
  def choose(message = nil, *choices, &block); end
  def color(*args); end
  def converse(prompt, responses = nil); end
  def enable_paging; end
  def io(input = nil, output = nil, &block); end
  def log(action, *args); end
  def password(message = nil, mask = nil); end
  def progress(arr, options = nil); end
  def replace_tokens(str, hash); end
  def say_error(*args); end
  def say_ok(*args); end
  def say_warning(*args); end
  def self.applescript(script); end
  def self.ask_editor(input = nil, preferred_editor = nil); end
  def self.available_editor(preferred = nil); end
  def self.choose(message = nil, *choices, &block); end
  def self.color(*args); end
  def self.converse(prompt, responses = nil); end
  def self.enable_paging; end
  def self.io(input = nil, output = nil, &block); end
  def self.log(action, *args); end
  def self.password(message = nil, mask = nil); end
  def self.progress(arr, options = nil); end
  def self.replace_tokens(str, hash); end
  def self.say_error(*args); end
  def self.say_ok(*args); end
  def self.say_warning(*args); end
  def self.speak(message, voice = nil, rate = nil); end
  def speak(message, voice = nil, rate = nil); end
end
module Commander::UI::AskForClass
  def ask_for_array(prompt); end
  def ask_for_file(prompt); end
  def ask_for_float(prompt); end
  def ask_for_integer(prompt); end
  def ask_for_pathname(prompt); end
  def ask_for_regexp(prompt); end
  def ask_for_string(prompt); end
  def ask_for_symbol(prompt); end
  def method_missing(method_name, *arguments, &block); end
  def respond_to_missing?(method_name, include_private = nil); end
end
class Commander::UI::ProgressBar
  def completed?; end
  def erase_line; end
  def finished?; end
  def generate_tokens; end
  def increment(tokens = nil); end
  def initialize(total, options = nil); end
  def percent_complete; end
  def progress_bar; end
  def show; end
  def steps_remaining; end
  def time_elapsed; end
  def time_remaining; end
end
class Array
  def self.try_convert(arg0); end
end
class Object < BasicObject
  def get_binding; end
end
class Commander::Runner
  def active_command; end
  def add_command(command); end
  def alias?(name); end
  def alias_command(alias_name, name, *args); end
  def always_trace!; end
  def args_without_command_name; end
  def command(name, &block); end
  def command_exists?(name); end
  def command_name_from_args; end
  def commands; end
  def create_default_commands; end
  def default_command(name); end
  def expand_optionally_negative_switches(switches); end
  def global_option(*args, &block); end
  def global_option_proc(switches, &block); end
  def help_formatter; end
  def help_formatter_alias_defaults; end
  def help_formatter_aliases; end
  def initialize(args = nil); end
  def longest_valid_command_name_from(args); end
  def never_trace!; end
  def options; end
  def parse_global_options; end
  def program(key, *args, &block); end
  def program_defaults; end
  def remove_global_options(options, args); end
  def require_program(*keys); end
  def require_valid_command(command = nil); end
  def run!; end
  def run_active_command; end
  def say(*args); end
  def self.instance; end
  def self.separate_switches_from_description(*args); end
  def self.switch_to_sym(switch); end
  def valid_command_names_from(*args); end
  def version; end
end
class Commander::Runner::CommandError < StandardError
end
class Commander::Runner::InvalidCommandError < Commander::Runner::CommandError
end
class Commander::Command
  def action(*args, &block); end
  def call(args = nil); end
  def description; end
  def description=(arg0); end
  def example(description, command); end
  def examples; end
  def examples=(arg0); end
  def global_options; end
  def initialize(name); end
  def inspect; end
  def name; end
  def name=(arg0); end
  def option(*args, &block); end
  def option_proc(switches); end
  def options; end
  def options=(arg0); end
  def parse_options_and_call_procs(*args); end
  def proxy_option_struct; end
  def proxy_options; end
  def proxy_options=(arg0); end
  def run(*args); end
  def summary; end
  def summary=(arg0); end
  def syntax; end
  def syntax=(arg0); end
  def when_called(*args, &block); end
end
class Commander::Command::Options
  def __hash__; end
  def default(defaults = nil); end
  def initialize; end
  def inspect; end
  def method_missing(meth, *args); end
  include Blank
end
module Commander::HelpFormatter
  def indent(amount, text); end
  def self.indent(amount, text); end
end
class Commander::HelpFormatter::Context
  def decorate_binding(_bind); end
  def get_binding; end
  def initialize(target); end
end
class Commander::HelpFormatter::ProgramContext < Commander::HelpFormatter::Context
  def decorate_binding(bind); end
  def max_aliases_length(bind); end
  def max_command_length(bind); end
  def max_key_length(hash, default = nil); end
end
module Commander::Platform
  def self.jruby?; end
end
module Commander::Delegates
  def add_command(*args, &block); end
  def alias_command(*args, &block); end
  def always_trace!(*args, &block); end
  def command(*args, &block); end
  def default_command(*args, &block); end
  def defined_commands(*args, &block); end
  def global_option(*args, &block); end
  def never_trace!(*args, &block); end
  def program(*args, &block); end
  def run!(*args, &block); end
end
module Commander::Methods
  include Commander::Delegates
  include Commander::UI
  include Commander::UI::AskForClass
end
