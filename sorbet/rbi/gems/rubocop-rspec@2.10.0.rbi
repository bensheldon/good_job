# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `rubocop-rspec` gem.
# Please instead update this file by running `bin/tapioca gem rubocop-rspec`.

module RuboCop; end
module RuboCop::Cop; end

# @deprecated IgnoredPattern class has been replaced with AllowedPattern.
RuboCop::Cop::IgnoredPattern = RuboCop::Cop::AllowedPattern

module RuboCop::Cop::RSpec; end

# Checks that left braces for adjacent single line lets are aligned.
#
# @example
#
#   # bad
#   let(:foobar) { blahblah }
#   let(:baz) { bar }
#   let(:a) { b }
#
#   # good
#   let(:foobar) { blahblah }
#   let(:baz)    { bar }
#   let(:a)      { b }
class RuboCop::Cop::RSpec::AlignLeftLetBrace < ::RuboCop::Cop::RSpec::Base
  extend ::RuboCop::Cop::AutoCorrector

  def on_new_investigation; end

  private

  def token_aligner; end

  class << self
    def autocorrect_incompatible_with; end
  end
end

RuboCop::Cop::RSpec::AlignLeftLetBrace::MSG = T.let(T.unsafe(nil), String)

# Checks that right braces for adjacent single line lets are aligned.
#
# @example
#
#   # bad
#   let(:foobar) { blahblah }
#   let(:baz)    { bar }
#   let(:a)      { b }
#
#   # good
#   let(:foobar) { blahblah }
#   let(:baz)    { bar      }
#   let(:a)      { b        }
class RuboCop::Cop::RSpec::AlignRightLetBrace < ::RuboCop::Cop::RSpec::Base
  extend ::RuboCop::Cop::AutoCorrector

  def on_new_investigation; end

  private

  def token_aligner; end

  class << self
    def autocorrect_incompatible_with; end
  end
end

RuboCop::Cop::RSpec::AlignRightLetBrace::MSG = T.let(T.unsafe(nil), String)

# Check that instances are not being stubbed globally.
#
# Prefer instance doubles over stubbing any instance of a class
#
# @example
#   # bad
#   describe MyClass do
#   before { allow_any_instance_of(MyClass).to receive(:foo) }
#   end
#
#   # good
#   describe MyClass do
#   let(:my_instance) { instance_double(MyClass) }
#
#   before do
#   allow(MyClass).to receive(:new).and_return(my_instance)
#   allow(my_instance).to receive(:foo)
#   end
#   end
class RuboCop::Cop::RSpec::AnyInstance < ::RuboCop::Cop::RSpec::Base
  def on_send(node); end
end

RuboCop::Cop::RSpec::AnyInstance::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::RSpec::AnyInstance::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Checks that around blocks actually run the test.
#
# @example
#   # bad
#   around do
#   some_method
#   end
#
#   around do |test|
#   some_method
#   end
#
#   # good
#   around do |test|
#   some_method
#   test.call
#   end
#
#   around do |test|
#   some_method
#   test.run
#   end
class RuboCop::Cop::RSpec::AroundBlock < ::RuboCop::Cop::RSpec::Base
  def find_arg_usage(param0); end
  def hook(param0 = T.unsafe(nil)); end
  def on_block(node); end

  private

  def add_no_arg_offense(node); end
  def check_for_unused_proxy(block, proxy); end
end

RuboCop::Cop::RSpec::AroundBlock::MSG_NO_ARG = T.let(T.unsafe(nil), String)
RuboCop::Cop::RSpec::AroundBlock::MSG_UNUSED_ARG = T.let(T.unsafe(nil), String)

# @abstract parent class to RSpec cops
class RuboCop::Cop::RSpec::Base < ::RuboCop::Cop::Base
  include ::RuboCop::RSpec::Language
  extend ::RuboCop::RSpec::Language::NodePattern

  # Set the config for dynamic DSL configuration-aware helpers
  # that have no other means of accessing the configuration.
  def on_new_investigation; end

  class << self
    # Invoke the original inherited hook so our cops are recognized
    def inherited(subclass); end
  end
end

# Check for expectations where `be` is used without argument.
#
# The `be` matcher is too generic, as it pass on everything that is not
# nil or false. If that is the exact intend, use `be_truthy`. In all other
# cases it's better to specify what exactly is the expected value.
#
# @example
#
#   # bad
#   expect(foo).to be
#
#   # good
#   expect(foo).to be_truthy
#   expect(foo).to be 1.0
#   expect(foo).to be(true)
class RuboCop::Cop::RSpec::Be < ::RuboCop::Cop::RSpec::Base
  def be_without_args(param0 = T.unsafe(nil)); end
  def on_send(node); end
end

RuboCop::Cop::RSpec::Be::MSG = T.let(T.unsafe(nil), String)

# Check for expectations where `be(...)` can replace `eq(...)`.
#
# The `be` matcher compares by identity while the `eq` matcher compares
# using `==`. Booleans and nil can be compared by identity and therefore
# the `be` matcher is preferable as it is a more strict test.
#
# @example
#
#   # bad
#   expect(foo).to eq(true)
#   expect(foo).to eq(false)
#   expect(foo).to eq(nil)
#
#   # good
#   expect(foo).to be(true)
#   expect(foo).to be(false)
#   expect(foo).to be(nil)
class RuboCop::Cop::RSpec::BeEq < ::RuboCop::Cop::RSpec::Base
  extend ::RuboCop::Cop::AutoCorrector

  def eq_type_with_identity?(param0 = T.unsafe(nil)); end
  def on_send(node); end
end

RuboCop::Cop::RSpec::BeEq::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::RSpec::BeEq::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Check for expectations where `be(...)` can replace `eql(...)`.
#
# The `be` matcher compares by identity while the `eql` matcher
# compares using `eql?`. Integers, floats, booleans, symbols, and nil
# can be compared by identity and therefore the `be` matcher is
# preferable as it is a more strict test.
#
# This cop only looks for instances of `expect(...).to eql(...)`. We
# do not check `to_not` or `not_to` since `!eql?` is more strict
# than `!equal?`. We also do not try to flag `eq` because if
# `a == b`, and `b` is comparable by identity, `a` is still not
# necessarily the same type as `b` since the `#==` operator can
# coerce objects for comparison.
#
# @example
#
#   # bad
#   expect(foo).to eql(1)
#   expect(foo).to eql(1.0)
#   expect(foo).to eql(true)
#   expect(foo).to eql(false)
#   expect(foo).to eql(:bar)
#   expect(foo).to eql(nil)
#
#   # good
#   expect(foo).to be(1)
#   expect(foo).to be(1.0)
#   expect(foo).to be(true)
#   expect(foo).to be(false)
#   expect(foo).to be(:bar)
#   expect(foo).to be(nil)
class RuboCop::Cop::RSpec::BeEql < ::RuboCop::Cop::RSpec::Base
  extend ::RuboCop::Cop::AutoCorrector

  def eql_type_with_identity(param0 = T.unsafe(nil)); end
  def on_send(node); end
end

RuboCop::Cop::RSpec::BeEql::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::RSpec::BeEql::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Ensures a consistent style is used when matching `nil`.
#
# You can either use the more specific `be_nil` matcher, or the more
# generic `be` matcher with a `nil` argument.
#
# This cop can be configured using the `EnforcedStyle` option
#
# @example `EnforcedStyle: be_nil` (default)
#   # bad
#   expect(foo).to be(nil)
#
#   # good
#   expect(foo).to be_nil
# @example `EnforcedStyle: be`
#   # bad
#   expect(foo).to be_nil
#
#   # good
#   expect(foo).to be(nil)
class RuboCop::Cop::RSpec::BeNil < ::RuboCop::Cop::RSpec::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  extend ::RuboCop::Cop::AutoCorrector

  def be_nil_matcher?(param0 = T.unsafe(nil)); end
  def nil_value_expectation?(param0 = T.unsafe(nil)); end
  def on_send(node); end

  private

  def check_be_nil_style(node); end
  def check_be_style(node); end
end

RuboCop::Cop::RSpec::BeNil::BE_MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::RSpec::BeNil::BE_NIL_MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::RSpec::BeNil::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Check that before/after(:all) isn't being used.
#
# @example
#   # bad
#   #
#   # Faster but risk of state leaking between examples
#   #
#   describe MyClass do
#   before(:all) { Widget.create }
#   after(:all) { Widget.delete_all }
#   end
#
#   # good
#   #
#   # Slower but examples are properly isolated
#   #
#   describe MyClass do
#   before(:each) { Widget.create }
#   after(:each) { Widget.delete_all }
#   end
class RuboCop::Cop::RSpec::BeforeAfterAll < ::RuboCop::Cop::RSpec::Base
  def before_or_after_all(param0 = T.unsafe(nil)); end
  def on_send(node); end
end

RuboCop::Cop::RSpec::BeforeAfterAll::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::RSpec::BeforeAfterAll::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)
module RuboCop::Cop::RSpec::Capybara; end

# Checks that no expectations are set on Capybara's `current_path`.
#
# The
# https://www.rubydoc.info/github/teamcapybara/capybara/master/Capybara/RSpecMatchers#have_current_path-instance_method[`have_current_path` matcher]
# should be used on `page` to set expectations on Capybara's
# current path, since it uses
# https://github.com/teamcapybara/capybara/blob/master/README.md#asynchronous-javascript-ajax-and-friends[Capybara's waiting functionality]
# which ensures that preceding actions (like `click_link`) have
# completed.
#
# @example
#   # bad
#   expect(current_path).to eq('/callback')
#   expect(page.current_path).to match(/widgets/)
#
#   # good
#   expect(page).to have_current_path("/callback")
#   expect(page).to have_current_path(/widgets/)
class RuboCop::Cop::RSpec::Capybara::CurrentPathExpectation < ::RuboCop::Cop::RSpec::Base
  extend ::RuboCop::Cop::AutoCorrector

  # Supported matchers: eq(...) / match(/regexp/) / match('regexp')
  def as_is_matcher(param0 = T.unsafe(nil)); end

  def expectation_set_on_current_path(param0 = T.unsafe(nil)); end
  def on_send(node); end
  def regexp_str_matcher(param0 = T.unsafe(nil)); end

  private

  # `have_current_path` with no options will include the querystring
  # while `page.current_path` does not.
  # This ensures the option `ignore_query: true` is added
  # except when the expectation is a regexp or string
  def add_ignore_query_options(corrector, node); end

  def autocorrect(corrector, node); end
  def convert_regexp_str_to_literal(corrector, matcher_node, regexp_str); end
  def rewrite_expectation(corrector, node, to_symbol, matcher_node); end

  class << self
    def autocorrect_incompatible_with; end
  end
end

RuboCop::Cop::RSpec::Capybara::CurrentPathExpectation::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::RSpec::Capybara::CurrentPathExpectation::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Checks for consistent method usage in feature specs.
#
# By default, the cop disables all Capybara-specific methods that have
# the same native RSpec method (e.g. are just aliases). Some teams
# however may prefer using some of the Capybara methods (like `feature`)
# to make it obvious that the test uses Capybara, while still disable
# the rest of the methods, like `given` (alias for `let`), `background`
# (alias for `before`), etc. You can configure which of the methods to
# be enabled by using the EnabledMethods configuration option.
#
# @example
#   # bad
#   feature 'User logs in' do
#   given(:user) { User.new }
#
#   background do
#   visit new_session_path
#   end
#
#   scenario 'with OAuth' do
#   # ...
#   end
#   end
#
#   # good
#   describe 'User logs in' do
#   let(:user) { User.new }
#
#   before do
#   visit new_session_path
#   end
#
#   it 'with OAuth' do
#   # ...
#   end
#   end
class RuboCop::Cop::RSpec::Capybara::FeatureMethods < ::RuboCop::Cop::RSpec::Base
  include ::RuboCop::Cop::RSpec::InsideExampleGroup
  extend ::RuboCop::Cop::AutoCorrector

  def capybara_speak(param0 = T.unsafe(nil)); end
  def feature_method(param0 = T.unsafe(nil)); end
  def message(range); end
  def on_block(node); end

  private

  # @return [Boolean]
  def enabled?(method_name); end

  def enabled_methods; end
end

# https://git.io/v7Kwr
RuboCop::Cop::RSpec::Capybara::FeatureMethods::MAP = T.let(T.unsafe(nil), Hash)

RuboCop::Cop::RSpec::Capybara::FeatureMethods::MSG = T.let(T.unsafe(nil), String)

# Checks for boolean visibility in Capybara finders.
#
# Capybara lets you find elements that match a certain visibility using
# the `:visible` option. `:visible` accepts both boolean and symbols as
# values, however using booleans can have unwanted effects. `visible:
# false` does not find just invisible elements, but both visible and
# invisible elements. For expressiveness and clarity, use one of the
# symbol values, `:all`, `:hidden` or `:visible`.
# Read more in
# https://www.rubydoc.info/gems/capybara/Capybara%2FNode%2FFinders:all[the documentation].
#
# @example
#
#   # bad
#   expect(page).to have_selector('.foo', visible: false)
#   expect(page).to have_css('.foo', visible: true)
#   expect(page).to have_link('my link', visible: false)
#
#   # good
#   expect(page).to have_selector('.foo', visible: :visible)
#   expect(page).to have_css('.foo', visible: :all)
#   expect(page).to have_link('my link', visible: :hidden)
class RuboCop::Cop::RSpec::Capybara::VisibilityMatcher < ::RuboCop::Cop::RSpec::Base
  def on_send(node); end
  def visible_false?(param0 = T.unsafe(nil)); end
  def visible_true?(param0 = T.unsafe(nil)); end

  private

  # @return [Boolean]
  def capybara_matcher?(method_name); end
end

RuboCop::Cop::RSpec::Capybara::VisibilityMatcher::CAPYBARA_MATCHER_METHODS = T.let(T.unsafe(nil), Array)
RuboCop::Cop::RSpec::Capybara::VisibilityMatcher::MSG_FALSE = T.let(T.unsafe(nil), String)
RuboCop::Cop::RSpec::Capybara::VisibilityMatcher::MSG_TRUE = T.let(T.unsafe(nil), String)
RuboCop::Cop::RSpec::Capybara::VisibilityMatcher::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Help methods for working with nodes containing comments.
module RuboCop::Cop::RSpec::CommentsHelp
  include ::RuboCop::Cop::RSpec::FinalEndLocation

  def begin_pos_with_comment(node); end
  def buffer; end
  def end_line_position(node); end
  def source_range_with_comment(node); end
  def start_line_position(node); end
end

# `context` should not be used for specifying methods.
#
# @example
#   # bad
#   context '#foo_bar' do
#   # ...
#   end
#
#   context '.foo_bar' do
#   # ...
#   end
#
#   # good
#   describe '#foo_bar' do
#   # ...
#   end
#
#   describe '.foo_bar' do
#   # ...
#   end
class RuboCop::Cop::RSpec::ContextMethod < ::RuboCop::Cop::RSpec::Base
  extend ::RuboCop::Cop::AutoCorrector

  def context_method(param0 = T.unsafe(nil)); end
  def on_block(node); end

  private

  # @return [Boolean]
  def method_name?(description); end
end

RuboCop::Cop::RSpec::ContextMethod::MSG = T.let(T.unsafe(nil), String)

# Checks that `context` docstring starts with an allowed prefix.
#
# The default list of prefixes is minimal. Users are encouraged to tailor
# the configuration to meet project needs. Other acceptable prefixes may
# include `if`, `unless`, `for`, `before`, `after`, or `during`.
# They may consist of multiple words if desired.
#
# @example `Prefixes` configuration
#
#   # .rubocop.yml
#   # RSpec/ContextWording:
#   #   Prefixes:
#   #     - when
#   #     - with
#   #     - without
#   #     - if
#   #     - unless
#   #     - for
# @example
#   # bad
#   context 'the display name not present' do
#   # ...
#   end
#
#   # good
#   context 'when the display name is not present' do
#   # ...
#   end
# @see https://rspec.rubystyle.guide/#context-descriptions
# @see http://www.betterspecs.org/#contexts
class RuboCop::Cop::RSpec::ContextWording < ::RuboCop::Cop::RSpec::Base
  def context_wording(param0 = T.unsafe(nil)); end
  def on_block(node); end

  private

  # @return [Boolean]
  def bad_prefix?(description); end

  def joined_prefixes; end
  def prefix_regex; end
  def prefixes; end
end

RuboCop::Cop::RSpec::ContextWording::MSG = T.let(T.unsafe(nil), String)

# Check that the first argument to the top-level describe is a constant.
#
# It can be configured to ignore strings when certain metadata is passed.
#
# Ignores Rails and Aruba `type` metadata by default.
#
# @example `IgnoredMetadata` configuration
#
#   # .rubocop.yml
#   # RSpec/DescribeClass:
#   #   IgnoredMetadata:
#   #     type:
#   #       - request
#   #       - controller
# @example
#   # bad
#   describe 'Do something' do
#   end
#
#   # good
#   describe TestedClass do
#   subject { described_class }
#   end
#
#   describe 'TestedClass::VERSION' do
#   subject { Object.const_get(self.class.description) }
#   end
#
#   describe "A feature example", type: :feature do
#   end
class RuboCop::Cop::RSpec::DescribeClass < ::RuboCop::Cop::RSpec::Base
  include ::RuboCop::Cop::RSpec::TopLevelGroup

  def example_group_with_ignored_metadata?(param0 = T.unsafe(nil)); end
  def not_a_const_described(param0 = T.unsafe(nil)); end
  def on_top_level_group(node); end
  def sym_pair(param0 = T.unsafe(nil)); end

  private

  def ignored_metadata; end

  # @return [Boolean]
  def ignored_metadata?(node); end

  # @return [Boolean]
  def string_constant?(described); end
end

RuboCop::Cop::RSpec::DescribeClass::MSG = T.let(T.unsafe(nil), String)

# Checks that the second argument to `describe` specifies a method.
#
# @example
#   # bad
#   describe MyClass, 'do something' do
#   end
#
#   # good
#   describe MyClass, '#my_instance_method' do
#   end
#
#   describe MyClass, '.my_class_method' do
#   end
class RuboCop::Cop::RSpec::DescribeMethod < ::RuboCop::Cop::RSpec::Base
  include ::RuboCop::Cop::RSpec::TopLevelGroup

  def on_top_level_group(node); end
  def second_argument(param0 = T.unsafe(nil)); end
end

RuboCop::Cop::RSpec::DescribeMethod::MSG = T.let(T.unsafe(nil), String)

# Avoid describing symbols.
#
# @example
#   # bad
#   describe :my_method do
#   # ...
#   end
#
#   # good
#   describe '#my_method' do
#   # ...
#   end
# @see https://github.com/rspec/rspec-core/issues/1610
class RuboCop::Cop::RSpec::DescribeSymbol < ::RuboCop::Cop::RSpec::Base
  def describe_symbol?(param0 = T.unsafe(nil)); end
  def on_send(node); end
end

RuboCop::Cop::RSpec::DescribeSymbol::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::RSpec::DescribeSymbol::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Checks that tests use `described_class`.
#
# If the first argument of describe is a class, the class is exposed to
# each example via described_class.
#
# This cop can be configured using the `EnforcedStyle` and `SkipBlocks`
# options.
#
# There's a known caveat with rspec-rails's `controller` helper that
# runs its block in a different context, and `described_class` is not
# available to it. `SkipBlocks` option excludes detection in all
# non-RSpec related blocks.
#
# To narrow down this setting to only a specific directory, it is
# possible to use an overriding configuration file local to that
# directory.
#
# @example `EnforcedStyle: described_class`
#   # bad
#   describe MyClass do
#   subject { MyClass.do_something }
#   end
#
#   # good
#   describe MyClass do
#   subject { described_class.do_something }
#   end
# @example `EnforcedStyle: explicit`
#   # bad
#   describe MyClass do
#   subject { described_class.do_something }
#   end
#
#   # good
#   describe MyClass do
#   subject { MyClass.do_something }
#   end
# @example `SkipBlocks: true`
#   # spec/controllers/.rubocop.yml
#   # RSpec/DescribedClass:
#   #   SkipBlocks: true
#
#   # acceptable
#   describe MyConcern do
#   controller(ApplicationController) do
#   include MyConcern
#   end
#   end
class RuboCop::Cop::RSpec::DescribedClass < ::RuboCop::Cop::RSpec::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  extend ::RuboCop::Cop::AutoCorrector

  def common_instance_exec_closure?(param0 = T.unsafe(nil)); end
  def contains_described_class?(param0); end
  def described_constant(param0 = T.unsafe(nil)); end
  def on_block(node); end
  def rspec_block?(param0 = T.unsafe(nil)); end
  def scope_changing_syntax?(param0 = T.unsafe(nil)); end

  private

  def autocorrect(corrector, match); end

  # @example
  #   # nil represents base constant
  #   collapse_namespace([], :C)                 # => [:C]
  #   collapse_namespace([:A, :B], [:C)          # => [:A, :B, :C]
  #   collapse_namespace([:A, :B], [:B, :C)      # => [:A, :B, :C]
  #   collapse_namespace([:A, :B], [nil, :C)     # => [nil, :C]
  #   collapse_namespace([:A, :B], [nil, :B, :C) # => [nil, :B, :C]
  # @param namespace [Array<Symbol>]
  # @param const [Array<Symbol>]
  # @return [Array<Symbol>]
  def collapse_namespace(namespace, const); end

  # @example
  #   const_name(s(:const, nil, :C))                # => [:C]
  #   const_name(s(:const, s(:const, nil, :M), :C)) # => [:M, :C]
  #   const_name(s(:const, s(:cbase), :C))          # => [nil, :C]
  # @param node [RuboCop::AST::Node]
  # @return [Array<Symbol>]
  def const_name(node); end

  # @yield [node]
  def find_usage(node, &block); end

  def full_const_name(node); end
  def message(offense); end

  # @example
  #   namespace(node) # => [:A, :B, :C]
  # @param node [RuboCop::AST::Node]
  # @return [Array<Symbol>]
  def namespace(node); end

  # @return [Boolean]
  def offensive?(node); end

  # @return [Boolean]
  def offensive_described_class?(node); end

  # @return [Boolean]
  def scope_change?(node); end

  # @return [Boolean]
  def skip_blocks?; end

  # @return [Boolean]
  def skippable_block?(node); end
end

RuboCop::Cop::RSpec::DescribedClass::DESCRIBED_CLASS = T.let(T.unsafe(nil), String)
RuboCop::Cop::RSpec::DescribedClass::MSG = T.let(T.unsafe(nil), String)

# Avoid opening modules and defining specs within them.
#
# @example
#   # bad
#   module MyModule
#   RSpec.describe MyClass do
#   # ...
#   end
#   end
#
#   # good
#   RSpec.describe MyModule::MyClass do
#   # ...
#   end
# @see https://github.com/rubocop/rubocop-rspec/issues/735
class RuboCop::Cop::RSpec::DescribedClassModuleWrapping < ::RuboCop::Cop::RSpec::Base
  def find_rspec_blocks(param0); end
  def on_module(node); end
end

RuboCop::Cop::RSpec::DescribedClassModuleWrapping::MSG = T.let(T.unsafe(nil), String)

# This cop enforces custom RSpec dialects.
#
# A dialect can be based on the following RSpec methods:
#
# - describe, context, feature, example_group
# - xdescribe, xcontext, xfeature
# - fdescribe, fcontext, ffeature
# - shared_examples, shared_examples_for, shared_context
# - it, specify, example, scenario, its
# - fit, fspecify, fexample, fscenario, focus
# - xit, xspecify, xexample, xscenario, skip
# - pending
# - prepend_before, before, append_before,
# - around
# - prepend_after, after, append_after
# - let, let!
# - subject, subject!
# - expect, is_expected, expect_any_instance_of
#
# By default all of the RSpec methods and aliases are allowed. By setting
# a config like:
#
#   RSpec/Dialect:
#     PreferredMethods:
#       context: describe
#
# You can expect the following behavior:
#
# @example
#   # bad
#   context 'display name presence' do
#   # ...
#   end
#
#   # good
#   describe 'display name presence' do
#   # ...
#   end
class RuboCop::Cop::RSpec::Dialect < ::RuboCop::Cop::RSpec::Base
  include ::RuboCop::Cop::MethodPreference
  extend ::RuboCop::Cop::AutoCorrector

  def on_send(node); end
  def rspec_method?(param0 = T.unsafe(nil)); end
end

RuboCop::Cop::RSpec::Dialect::MSG = T.let(T.unsafe(nil), String)

# Checks if an example group does not include any tests.
#
# @example usage
#
#   # bad
#   describe Bacon do
#   let(:bacon)      { Bacon.new(chunkiness) }
#   let(:chunkiness) { false                 }
#
#   context 'extra chunky' do   # flagged by rubocop
#   let(:chunkiness) { true }
#   end
#
#   it 'is chunky' do
#   expect(bacon.chunky?).to be_truthy
#   end
#   end
#
#   # good
#   describe Bacon do
#   let(:bacon)      { Bacon.new(chunkiness) }
#   let(:chunkiness) { false                 }
#
#   it 'is chunky' do
#   expect(bacon.chunky?).to be_truthy
#   end
#   end
#
#   # good
#   describe Bacon do
#   pending 'will add tests later'
#   end
class RuboCop::Cop::RSpec::EmptyExampleGroup < ::RuboCop::Cop::RSpec::Base
  # Match example group blocks and yield their body
  #
  # @example source that matches
  #   describe 'example group' do
  #   it { is_expected.to be }
  #   end
  # @param node [RuboCop::AST::Node]
  # @yield [RuboCop::AST::Node] example group body
  def example_group_body(param0 = T.unsafe(nil)); end

  # Match examples, example groups and includes
  #
  # @example source that matches
  #   it { is_expected.to fly }
  #   describe('non-empty example groups too') { }
  #   it_behaves_like 'an animal'
  #   it_behaves_like('a cat') { let(:food) { 'milk' } }
  #   it_has_root_access
  #   skip
  #   it 'will be implemented later'
  # @param node [RuboCop::AST::Node]
  # @return [Array<RuboCop::AST::Node>] matching nodes
  def example_or_group_or_include?(param0 = T.unsafe(nil)); end

  # Matches examples defined in scopes where they could run
  #
  # @example source that matches
  #   it { expect(myself).to be_run }
  #   describe { it { i_run_as_well } }
  # @example source that does not match
  #   before { it { whatever here wont run anyway } }
  # @param node [RuboCop::AST::Node]
  # @return [Array<RuboCop::AST::Node>] matching nodes
  def examples?(param0 = T.unsafe(nil)); end

  # Match examples or examples inside blocks
  #
  # @example source that matches
  #   it { expect(drink).to be_cold }
  #   context('when winter') { it { expect(drink).to be_hot } }
  #   (1..5).each { |divisor| it { is_expected.to divide_by(divisor) } }
  # @param node [RuboCop::AST::Node]
  # @return [Array<RuboCop::AST::Node>] matching nodes
  def examples_directly_or_in_block?(param0 = T.unsafe(nil)); end

  # Match examples defined inside a block which is not a hook
  #
  # @example source that matches
  #   %w(r g b).each do |color|
  #   it { is_expected.to have_color(color) }
  #   end
  # @example source that does not match
  #   before do
  #   it { is_expected.to fall_into_oblivion }
  #   end
  # @param node [RuboCop::AST::Node]
  # @return [Array<RuboCop::AST::Node>] matching nodes
  def examples_inside_block?(param0 = T.unsafe(nil)); end

  def on_block(node); end

  private

  # @return [Boolean]
  def conditionals_with_examples?(body); end

  # @return [Boolean]
  def examples_in_branches?(condition_node); end

  # @return [Boolean]
  def offensive?(body); end
end

RuboCop::Cop::RSpec::EmptyExampleGroup::MSG = T.let(T.unsafe(nil), String)

# Checks for empty before and after hooks.
#
# @example
#   # bad
#   before {}
#   after do; end
#   before(:all) do
#   end
#   after(:all) { }
#
#   # good
#   before { create_users }
#   after do
#   cleanup_users
#   end
#   before(:all) do
#   create_feed
#   end
#   after(:all) { cleanup_feed }
class RuboCop::Cop::RSpec::EmptyHook < ::RuboCop::Cop::RSpec::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  def empty_hook?(param0 = T.unsafe(nil)); end
  def on_block(node); end
end

RuboCop::Cop::RSpec::EmptyHook::MSG = T.let(T.unsafe(nil), String)

# Checks if there is an empty line after example blocks.
#
# @example
#   # bad
#   RSpec.describe Foo do
#   it 'does this' do
#   end
#   it 'does that' do
#   end
#   end
#
#   # good
#   RSpec.describe Foo do
#   it 'does this' do
#   end
#
#   it 'does that' do
#   end
#   end
#
#   # fair - it's ok to have non-separated one-liners
#   RSpec.describe Foo do
#   it { one }
#   it { two }
#   end
# @example with AllowConsecutiveOneLiners configuration
#
#   # rubocop.yml
#   # RSpec/EmptyLineAfterExample:
#   #   AllowConsecutiveOneLiners: false
#
#   # bad
#   RSpec.describe Foo do
#   it { one }
#   it { two }
#   end
class RuboCop::Cop::RSpec::EmptyLineAfterExample < ::RuboCop::Cop::RSpec::Base
  include ::RuboCop::Cop::RSpec::FinalEndLocation
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::RSpec::EmptyLineSeparation
  extend ::RuboCop::Cop::AutoCorrector

  # @return [Boolean]
  def allow_consecutive_one_liners?; end

  # @return [Boolean]
  def allowed_one_liner?(node); end

  # @return [Boolean]
  def consecutive_one_liner?(node); end

  # @return [Boolean]
  def next_one_line_example?(node); end

  def next_sibling(node); end
  def on_block(node); end
end

RuboCop::Cop::RSpec::EmptyLineAfterExample::MSG = T.let(T.unsafe(nil), String)

# Checks if there is an empty line after example group blocks.
#
# @example
#   # bad
#   RSpec.describe Foo do
#   describe '#bar' do
#   end
#   describe '#baz' do
#   end
#   end
#
#   # good
#   RSpec.describe Foo do
#   describe '#bar' do
#   end
#
#   describe '#baz' do
#   end
#   end
class RuboCop::Cop::RSpec::EmptyLineAfterExampleGroup < ::RuboCop::Cop::RSpec::Base
  include ::RuboCop::Cop::RSpec::FinalEndLocation
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::RSpec::EmptyLineSeparation
  extend ::RuboCop::Cop::AutoCorrector

  def on_block(node); end
end

RuboCop::Cop::RSpec::EmptyLineAfterExampleGroup::MSG = T.let(T.unsafe(nil), String)

# Checks if there is an empty line after the last let block.
#
# @example
#   # bad
#   let(:foo) { bar }
#   let(:something) { other }
#   it { does_something }
#
#   # good
#   let(:foo) { bar }
#   let(:something) { other }
#
#   it { does_something }
class RuboCop::Cop::RSpec::EmptyLineAfterFinalLet < ::RuboCop::Cop::RSpec::Base
  include ::RuboCop::Cop::RSpec::FinalEndLocation
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::RSpec::EmptyLineSeparation
  extend ::RuboCop::Cop::AutoCorrector

  def on_block(node); end
end

RuboCop::Cop::RSpec::EmptyLineAfterFinalLet::MSG = T.let(T.unsafe(nil), String)

# Checks if there is an empty line after hook blocks.
#
# @example
#   # bad
#   before { do_something }
#   it { does_something }
#
#   # bad
#   after { do_something }
#   it { does_something }
#
#   # bad
#   around { |test| test.run }
#   it { does_something }
#
#   # good
#   before { do_something }
#
#   it { does_something }
#
#   # good
#   after { do_something }
#
#   it { does_something }
#
#   # good
#   around { |test| test.run }
#
#   it { does_something }
class RuboCop::Cop::RSpec::EmptyLineAfterHook < ::RuboCop::Cop::RSpec::Base
  include ::RuboCop::Cop::RSpec::FinalEndLocation
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::RSpec::EmptyLineSeparation
  extend ::RuboCop::Cop::AutoCorrector

  def on_block(node); end
end

RuboCop::Cop::RSpec::EmptyLineAfterHook::MSG = T.let(T.unsafe(nil), String)

# Checks if there is an empty line after subject block.
#
# @example
#   # bad
#   subject(:obj) { described_class }
#   let(:foo) { bar }
#
#   # good
#   subject(:obj) { described_class }
#
#   let(:foo) { bar }
class RuboCop::Cop::RSpec::EmptyLineAfterSubject < ::RuboCop::Cop::RSpec::Base
  include ::RuboCop::Cop::RSpec::FinalEndLocation
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::RSpec::EmptyLineSeparation
  include ::RuboCop::Cop::RSpec::InsideExampleGroup
  extend ::RuboCop::Cop::AutoCorrector

  def on_block(node); end
end

RuboCop::Cop::RSpec::EmptyLineAfterSubject::MSG = T.let(T.unsafe(nil), String)

# Helps determine the offending location if there is not an empty line
# following the node. Allows comments to follow directly after.
module RuboCop::Cop::RSpec::EmptyLineSeparation
  include ::RuboCop::Cop::RSpec::FinalEndLocation
  include ::RuboCop::Cop::RangeHelp

  # @return [Boolean]
  def last_child?(node); end

  # @yield [offending_loc(line)]
  def missing_separating_line(node); end

  def missing_separating_line_offense(node); end
  def offending_loc(last_line); end
end

# Checks for long examples.
#
# A long example is usually more difficult to understand. Consider
# extracting out some behaviour, e.g. with a `let` block, or a helper
# method.
#
# You can set literals you want to fold with `CountAsOne`.
# Available are: 'array', 'hash', and 'heredoc'. Each literal
# will be counted as one line regardless of its actual size.
#
# @example
#   # bad
#   it do
#   service = described_class.new
#   more_setup
#   more_setup
#   result = service.call
#   expect(result).to be(true)
#   end
#
#   # good
#   it do
#   service = described_class.new
#   result = service.call
#   expect(result).to be(true)
#   end
# @example CountAsOne: ['array', 'heredoc']
#
#   it do
#   array = [         # +1
#   1,
#   2
#   ]
#
#   hash = {          # +3
#   key: 'value'
#   }
#
#   msg = <<~HEREDOC  # +1
#   Heredoc
#   content.
#   HEREDOC
#   end                 # 5 points
class RuboCop::Cop::RSpec::ExampleLength < ::RuboCop::Cop::RSpec::Base
  include ::RuboCop::Cop::CodeLength

  def on_block(node); end

  private

  def cop_label; end
end

RuboCop::Cop::RSpec::ExampleLength::LABEL = T.let(T.unsafe(nil), String)

# Checks for examples without a description.
#
# RSpec allows for auto-generated example descriptions when there is no
# description provided or the description is an empty one.
#
# This cop removes empty descriptions.
# It also defines whether auto-generated description is allowed, based
# on the configured style.
#
# This cop can be configured using the `EnforcedStyle` option
#
# @example `EnforcedStyle: always_allow`
#   # bad
#   it('') { is_expected.to be_good }
#   it '' do
#   result = service.call
#   expect(result).to be(true)
#   end
#
#   # good
#   it { is_expected.to be_good }
#   it do
#   result = service.call
#   expect(result).to be(true)
#   end
# @example `EnforcedStyle: single_line_only`
#   # bad
#   it('') { is_expected.to be_good }
#   it do
#   result = service.call
#   expect(result).to be(true)
#   end
#
#   # good
#   it { is_expected.to be_good }
# @example `EnforcedStyle: disallow`
#   # bad
#   it { is_expected.to be_good }
#   it do
#   result = service.call
#   expect(result).to be(true)
#   end
class RuboCop::Cop::RSpec::ExampleWithoutDescription < ::RuboCop::Cop::RSpec::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle

  def example_description(param0 = T.unsafe(nil)); end
  def on_block(node); end

  private

  def check_example_without_description(node); end

  # @return [Boolean]
  def disallow_empty_description?(node); end
end

RuboCop::Cop::RSpec::ExampleWithoutDescription::MSG_ADD_DESCRIPTION = T.let(T.unsafe(nil), String)
RuboCop::Cop::RSpec::ExampleWithoutDescription::MSG_DEFAULT_ARGUMENT = T.let(T.unsafe(nil), String)

# Checks for common mistakes in example descriptions.
#
# This cop will correct docstrings that begin with 'should' and 'it'.
#
# The autocorrect is experimental - use with care! It can be configured
# with CustomTransform (e.g. have => has) and IgnoredWords (e.g. only).
#
# @example
#   # bad
#   it 'should find nothing' do
#   end
#
#   # good
#   it 'finds nothing' do
#   end
# @example
#   # bad
#   it 'it does things' do
#   end
#
#   # good
#   it 'does things' do
#   end
# @see http://betterspecs.org/#should
class RuboCop::Cop::RSpec::ExampleWording < ::RuboCop::Cop::RSpec::Base
  extend ::RuboCop::Cop::AutoCorrector

  def it_description(param0 = T.unsafe(nil)); end
  def on_block(node); end

  private

  def add_wording_offense(node, message); end
  def custom_transform; end
  def docstring(node); end
  def ignored_words; end
  def replacement_text(node); end

  # Recursive processing is required to process nested dstr nodes
  # that is the case for \-separated multiline strings with interpolation.
  def text(node); end
end

RuboCop::Cop::RSpec::ExampleWording::IT_PREFIX = T.let(T.unsafe(nil), Regexp)
RuboCop::Cop::RSpec::ExampleWording::MSG_IT = T.let(T.unsafe(nil), String)
RuboCop::Cop::RSpec::ExampleWording::MSG_SHOULD = T.let(T.unsafe(nil), String)
RuboCop::Cop::RSpec::ExampleWording::SHOULD_PREFIX = T.let(T.unsafe(nil), Regexp)

# Checks for excessive whitespace in example descriptions.
#
# @example
#   # bad
#   it '  has  excessive   spacing  ' do
#   end
#
#   # good
#   it 'has excessive spacing' do
#   end
# @example
#   # bad
#   context '  when a condition   is met  ' do
#   end
#
#   # good
#   context 'when a condition is met' do
#   end
class RuboCop::Cop::RSpec::ExcessiveDocstringSpacing < ::RuboCop::Cop::RSpec::Base
  extend ::RuboCop::Cop::AutoCorrector

  def example_description(param0 = T.unsafe(nil)); end
  def on_send(node); end

  private

  # @param node [RuboCop::AST::Node]
  # @param text [String]
  def add_whitespace_offense(node, text); end

  def docstring(node); end

  # @param text [String]
  # @return [Boolean]
  def excessive_whitespace?(text); end

  # @param text [String]
  def strip_excessive_whitespace(text); end

  # Recursive processing is required to process nested dstr nodes
  # that is the case for \-separated multiline strings with interpolation.
  def text(node); end
end

RuboCop::Cop::RSpec::ExcessiveDocstringSpacing::MSG = T.let(T.unsafe(nil), String)

# Checks for `expect(...)` calls containing literal values.
#
# @example
#   # bad
#   expect(5).to eq(price)
#   expect(/foo/).to eq(pattern)
#   expect("John").to eq(name)
#
#   # good
#   expect(price).to eq(5)
#   expect(pattern).to eq(/foo/)
#   expect(name).to eq("John")
class RuboCop::Cop::RSpec::ExpectActual < ::RuboCop::Cop::RSpec::Base
  extend ::RuboCop::Cop::AutoCorrector

  def expect_literal(param0 = T.unsafe(nil)); end
  def on_send(node); end

  private

  # @return [Boolean]
  def complex_literal?(node); end

  # This is not implement using a NodePattern because it seems
  # to not be able to match against an explicit (nil) sexp
  #
  # @return [Boolean]
  def literal?(node); end

  # @return [Boolean]
  def simple_literal?(node); end

  def swap(corrector, actual, expected); end
end

RuboCop::Cop::RSpec::ExpectActual::COMPLEX_LITERALS = T.let(T.unsafe(nil), Array)
RuboCop::Cop::RSpec::ExpectActual::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::RSpec::ExpectActual::SIMPLE_LITERALS = T.let(T.unsafe(nil), Array)
RuboCop::Cop::RSpec::ExpectActual::SUPPORTED_MATCHERS = T.let(T.unsafe(nil), Array)

# Checks for consistent style of change matcher.
#
# Enforces either passing object and attribute as arguments to the matcher
# or passing a block that reads the attribute value.
#
# This cop can be configured using the `EnforcedStyle` option.
#
# @example `EnforcedStyle: block`
#   # bad
#   expect { run }.to change(Foo, :bar)
#
#   # good
#   expect { run }.to change { Foo.bar }
# @example `EnforcedStyle: method_call`
#   # bad
#   expect { run }.to change { Foo.bar }
#   expect { run }.to change { foo.baz }
#
#   # good
#   expect { run }.to change(Foo, :bar)
#   expect { run }.to change(foo, :baz)
#   # also good when there are arguments or chained method calls
#   expect { run }.to change { Foo.bar(:count) }
#   expect { run }.to change { user.reload.name }
class RuboCop::Cop::RSpec::ExpectChange < ::RuboCop::Cop::RSpec::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  extend ::RuboCop::Cop::AutoCorrector

  def expect_change_with_arguments(param0 = T.unsafe(nil)); end
  def expect_change_with_block(param0 = T.unsafe(nil)); end
  def on_block(node); end
  def on_send(node); end
end

RuboCop::Cop::RSpec::ExpectChange::MSG_BLOCK = T.let(T.unsafe(nil), String)
RuboCop::Cop::RSpec::ExpectChange::MSG_CALL = T.let(T.unsafe(nil), String)
RuboCop::Cop::RSpec::ExpectChange::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Do not use `expect` in hooks such as `before`.
#
# @example
#   # bad
#   before do
#   expect(something).to eq 'foo'
#   end
#
#   # bad
#   after do
#   expect_any_instance_of(Something).to receive(:foo)
#   end
#
#   # good
#   it do
#   expect(something).to eq 'foo'
#   end
class RuboCop::Cop::RSpec::ExpectInHook < ::RuboCop::Cop::RSpec::Base
  def expectation(param0); end
  def on_block(node); end

  private

  def message(expect, hook); end
end

RuboCop::Cop::RSpec::ExpectInHook::MSG = T.let(T.unsafe(nil), String)

# Checks for opportunities to use `expect { ... }.to output`.
#
# @example
#   # bad
#   $stdout = StringIO.new
#   my_app.print_report
#   $stdout = STDOUT
#   expect($stdout.string).to eq('Hello World')
#
#   # good
#   expect { my_app.print_report }.to output('Hello World').to_stdout
class RuboCop::Cop::RSpec::ExpectOutput < ::RuboCop::Cop::RSpec::Base
  def on_gvasgn(node); end

  private

  # Detect if we are inside the scope of a single example
  #
  # We want to encourage using `expect { ... }.to output` so
  # we only care about situations where you would replace with
  # an expectation. Therefore, assignments to stderr or stdout
  # within a `before(:all)` or otherwise outside of an example
  # don't matter.
  #
  # @return [Boolean]
  def inside_example_scope?(node); end
end

RuboCop::Cop::RSpec::ExpectOutput::MSG = T.let(T.unsafe(nil), String)

# A helper for `explicit` style
module RuboCop::Cop::RSpec::ExplicitHelper
  include ::RuboCop::RSpec::Language
  extend ::RuboCop::AST::NodePattern::Macros

  def predicate_matcher?(param0 = T.unsafe(nil)); end
  def predicate_matcher_block?(param0 = T.unsafe(nil)); end

  private

  def allowed_explicit_matchers; end
  def check_explicit(node); end
  def corrector_explicit(corrector, to_node, actual, matcher, block_child); end
  def message_explicit(matcher); end
  def move_predicate(corrector, actual, matcher, block_child); end

  # @return [Boolean]
  def predicate_matcher_name?(name); end

  def replacement_matcher(node); end
  def to_predicate_method(matcher); end
end

RuboCop::Cop::RSpec::ExplicitHelper::BUILT_IN_MATCHERS = T.let(T.unsafe(nil), Array)
RuboCop::Cop::RSpec::ExplicitHelper::MSG_EXPLICIT = T.let(T.unsafe(nil), String)
module RuboCop::Cop::RSpec::FactoryBot; end

# Always declare attribute values as blocks.
#
# @example
#   # bad
#   kind [:active, :rejected].sample
#
#   # good
#   kind { [:active, :rejected].sample }
#
#   # bad
#   closed_at 1.day.from_now
#
#   # good
#   closed_at { 1.day.from_now }
#
#   # bad
#   count 1
#
#   # good
#   count { 1 }
class RuboCop::Cop::RSpec::FactoryBot::AttributeDefinedStatically < ::RuboCop::Cop::RSpec::Base
  extend ::RuboCop::Cop::AutoCorrector

  def association?(param0 = T.unsafe(nil)); end
  def factory_attributes(param0 = T.unsafe(nil)); end
  def on_block(node); end
  def value_matcher(param0 = T.unsafe(nil)); end

  private

  # @return [Boolean]
  def attribute_defining_method?(method_name); end

  def autocorrect(corrector, node); end
  def autocorrect_replacing_parens(corrector, node); end
  def autocorrect_without_parens(corrector, node); end
  def braces(node); end

  # @return [Boolean]
  def offensive_receiver?(receiver, node); end

  # @return [Boolean]
  def proc?(attribute); end

  # @return [Boolean]
  def receiver_matches_first_block_argument?(receiver, node); end

  # @return [Boolean]
  def reserved_method?(method_name); end

  # @return [Boolean]
  def value_hash_without_braces?(node); end
end

RuboCop::Cop::RSpec::FactoryBot::AttributeDefinedStatically::MSG = T.let(T.unsafe(nil), String)

# Checks for create_list usage.
#
# This cop can be configured using the `EnforcedStyle` option
#
# @example `EnforcedStyle: create_list`
#   # bad
#   3.times { create :user }
#
#   # good
#   create_list :user, 3
#
#   # good
#   3.times { |n| create :user, created_at: n.months.ago }
# @example `EnforcedStyle: n_times`
#   # bad
#   create_list :user, 3
#
#   # good
#   3.times { create :user }
class RuboCop::Cop::RSpec::FactoryBot::CreateList < ::RuboCop::Cop::RSpec::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::RSpec::FactoryBot::Language
  extend ::RuboCop::Cop::AutoCorrector

  def factory_call(param0 = T.unsafe(nil)); end
  def factory_list_call(param0 = T.unsafe(nil)); end
  def n_times_block_without_arg?(param0 = T.unsafe(nil)); end
  def on_block(node); end
  def on_send(node); end

  private

  # @return [Boolean]
  def contains_only_factory?(node); end
end

# :nodoc
module RuboCop::Cop::RSpec::FactoryBot::CreateList::Corrector
  private

  def build_options_string(options); end
  def format_method_call(node, method, arguments); end
  def format_receiver(receiver); end
end

class RuboCop::Cop::RSpec::FactoryBot::CreateList::CreateListCorrector
  include ::RuboCop::Cop::RSpec::FactoryBot::CreateList::Corrector

  # @return [CreateListCorrector] a new instance of CreateListCorrector
  def initialize(node); end

  def call(corrector); end

  private

  def build_arguments(node, count); end
  def call_replacement(node); end
  def call_with_block_replacement(node); end
  def format_block(node); end
  def format_multiline_block(node); end
  def format_singeline_block(node); end

  # Returns the value of attribute node.
  def node; end
end

RuboCop::Cop::RSpec::FactoryBot::CreateList::MSG_CREATE_LIST = T.let(T.unsafe(nil), String)
RuboCop::Cop::RSpec::FactoryBot::CreateList::MSG_N_TIMES = T.let(T.unsafe(nil), String)
RuboCop::Cop::RSpec::FactoryBot::CreateList::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# :nodoc
class RuboCop::Cop::RSpec::FactoryBot::CreateList::TimesCorrector
  include ::RuboCop::Cop::RSpec::FactoryBot::CreateList::Corrector

  # @return [TimesCorrector] a new instance of TimesCorrector
  def initialize(node); end

  def call(corrector); end

  private

  def generate_n_times_block(node); end

  # Returns the value of attribute node.
  def node; end
end

# Use string value when setting the class attribute explicitly.
#
# This cop would promote faster tests by lazy-loading of
# application files. Also, this could help you suppress potential bugs
# in combination with external libraries by avoiding a preload of
# application files from the factory files.
#
# @example
#   # bad
#   factory :foo, class: Foo do
#   end
#
#   # good
#   factory :foo, class: 'Foo' do
#   end
class RuboCop::Cop::RSpec::FactoryBot::FactoryClassName < ::RuboCop::Cop::RSpec::Base
  extend ::RuboCop::Cop::AutoCorrector

  def class_name(param0 = T.unsafe(nil)); end
  def on_send(node); end

  private

  # @return [Boolean]
  def allowed?(const_name); end
end

RuboCop::Cop::RSpec::FactoryBot::FactoryClassName::ALLOWED_CONSTANTS = T.let(T.unsafe(nil), Array)
RuboCop::Cop::RSpec::FactoryBot::FactoryClassName::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::RSpec::FactoryBot::FactoryClassName::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Use shorthands from `FactoryBot::Syntax::Methods` in your specs.
#
# @example
#   # bad
#   FactoryBot.create(:bar)
#   FactoryBot.build(:bar)
#   FactoryBot.attributes_for(:bar)
#
#   # good
#   create(:bar)
#   build(:bar)
#   attributes_for(:bar)
class RuboCop::Cop::RSpec::FactoryBot::SyntaxMethods < ::RuboCop::Cop::RSpec::Base
  include ::RuboCop::Cop::RSpec::InsideExampleGroup
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::RSpec::FactoryBot::Language
  extend ::RuboCop::Cop::AutoCorrector

  def on_send(node); end

  private

  def crime_scene(node); end
  def offense(node); end
end

RuboCop::Cop::RSpec::FactoryBot::SyntaxMethods::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::RSpec::FactoryBot::SyntaxMethods::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Set)

# Checks that spec file paths are consistent and well-formed.
#
# By default, this checks that spec file paths are consistent with the
# test subject and and enforces that it reflects the described
# class/module and its optionally called out method.
#
# With the configuration option `IgnoreMethods` the called out method will
# be ignored when determining the enforced path.
#
# With the configuration option `CustomTransform` modules or classes can
# be specified that should not as usual be transformed from CamelCase to
# snake_case (e.g. 'RuboCop' => 'rubocop' ).
#
# With the configuration option `SpecSuffixOnly` test files will only
# be checked to ensure they end in '_spec.rb'. This option disables
# checking for consistency in the test subject or test methods.
#
# @example
#   # bad
#   whatever_spec.rb         # describe MyClass
#
#   # bad
#   my_class_spec.rb         # describe MyClass, '#method'
#
#   # good
#   my_class_spec.rb         # describe MyClass
#
#   # good
#   my_class_method_spec.rb  # describe MyClass, '#method'
#
#   # good
#   my_class/method_spec.rb  # describe MyClass, '#method'
# @example when configuration is `IgnoreMethods: true`
#   # bad
#   whatever_spec.rb         # describe MyClass
#
#   # good
#   my_class_spec.rb         # describe MyClass
#
#   # good
#   my_class_spec.rb         # describe MyClass, '#method'
# @example when configuration is `SpecSuffixOnly: true`
#   # good
#   whatever_spec.rb         # describe MyClass
#
#   # good
#   my_class_spec.rb         # describe MyClass
#
#   # good
#   my_class_spec.rb         # describe MyClass, '#method'
class RuboCop::Cop::RSpec::FilePath < ::RuboCop::Cop::RSpec::Base
  include ::RuboCop::Cop::RSpec::TopLevelGroup

  def example_group(param0 = T.unsafe(nil)); end
  def on_top_level_example_group(node); end
  def routing_metadata?(param0); end

  private

  def camel_to_snake_case(string); end
  def custom_transform; end
  def ensure_correct_file_path(send_node, example_group, arguments); end
  def expected_path(constant); end

  # @return [Boolean]
  def filename_ends_with?(pattern); end

  # @return [Boolean]
  def ignore_methods?; end

  def name_pattern(method_name); end
  def pattern_for(example_group, method_name); end

  # @return [Boolean]
  def pattern_for_spec_suffix_only?; end

  # @return [Boolean]
  def relevant_rubocop_rspec_file?(_file); end

  # @return [Boolean]
  def routing_spec?(args); end

  # @return [Boolean]
  def spec_suffix_only?; end
end

RuboCop::Cop::RSpec::FilePath::MSG = T.let(T.unsafe(nil), String)

# Helps find the true end location of nodes which might contain heredocs.
module RuboCop::Cop::RSpec::FinalEndLocation
  def final_end_location(start_node); end
end

# Checks if examples are focused.
#
# @example
#   # bad
#   describe MyClass, focus: true do
#   end
#
#   describe MyClass, :focus do
#   end
#
#   fdescribe MyClass do
#   end
#
#   # good
#   describe MyClass do
#   end
class RuboCop::Cop::RSpec::Focus < ::RuboCop::Cop::RSpec::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  def focusable_selector?(param0 = T.unsafe(nil)); end
  def focused_block?(param0 = T.unsafe(nil)); end
  def metadata(param0 = T.unsafe(nil)); end
  def on_send(node); end

  private

  def correct_send(corrector, focus); end

  # @yield [node]
  def focus_metadata(node, &block); end

  def with_surrounding(focus); end
end

RuboCop::Cop::RSpec::Focus::MSG = T.let(T.unsafe(nil), String)

# Checks the arguments passed to `before`, `around`, and `after`.
#
# This cop checks for consistent style when specifying RSpec
# hooks which run for each example. There are three supported
# styles: "implicit", "each", and "example." All styles have
# the same behavior.
#
# @example when configuration is `EnforcedStyle: implicit`
#   # bad
#   before(:each) do
#   # ...
#   end
#
#   # bad
#   before(:example) do
#   # ...
#   end
#
#   # good
#   before do
#   # ...
#   end
# @example when configuration is `EnforcedStyle: each`
#   # bad
#   before(:example) do
#   # ...
#   end
#
#   # bad
#   before do
#   # ...
#   end
#
#   # good
#   before(:each) do
#   # ...
#   end
# @example when configuration is `EnforcedStyle: example`
#   # bad
#   before(:each) do
#   # ...
#   end
#
#   # bad
#   before do
#   # ...
#   end
#
#   # good
#   before(:example) do
#   # ...
#   end
class RuboCop::Cop::RSpec::HookArgument < ::RuboCop::Cop::RSpec::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  extend ::RuboCop::Cop::AutoCorrector

  def on_block(node); end
  def scoped_hook(param0 = T.unsafe(nil)); end
  def unscoped_hook(param0 = T.unsafe(nil)); end

  private

  def argument_range(send_node); end
  def check_implicit(method_send); end
  def explicit_message(scope); end
  def hook(node, &block); end

  # @return [Boolean]
  def implicit_style?; end
end

RuboCop::Cop::RSpec::HookArgument::EXPLICIT_MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::RSpec::HookArgument::IMPLICIT_MSG = T.let(T.unsafe(nil), String)

# Checks for before/around/after hooks that come after an example.
#
# @example
#   # Bad
#
#   it 'checks what foo does' do
#   expect(foo).to be
#   end
#
#   before { prepare }
#   after { clean_up }
#
#   # Good
#   before { prepare }
#   after { clean_up }
#
#   it 'checks what foo does' do
#   expect(foo).to be
#   end
class RuboCop::Cop::RSpec::HooksBeforeExamples < ::RuboCop::Cop::RSpec::Base
  extend ::RuboCop::Cop::AutoCorrector

  def example_or_group?(param0 = T.unsafe(nil)); end
  def on_block(node); end

  private

  def autocorrect(corrector, node, first_example); end
  def check_hooks(node); end
  def find_first_example(node); end

  # @return [Boolean]
  def multiline_block?(block); end
end

RuboCop::Cop::RSpec::HooksBeforeExamples::MSG = T.let(T.unsafe(nil), String)

# Checks for equality assertions with identical expressions on both sides.
#
# @example
#
#   # bad
#   expect(foo.bar).to eq(foo.bar)
#   expect(foo.bar).to eql(foo.bar)
#
#   # good
#   expect(foo.bar).to eq(2)
#   expect(foo.bar).to eql(2)
class RuboCop::Cop::RSpec::IdenticalEqualityAssertion < ::RuboCop::Cop::RSpec::Base
  def equality_check?(param0 = T.unsafe(nil)); end
  def on_send(node); end
end

RuboCop::Cop::RSpec::IdenticalEqualityAssertion::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::RSpec::IdenticalEqualityAssertion::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Check that implicit block expectation syntax is not used.
#
# Prefer using explicit block expectations.
#
# @example
#   # bad
#   subject { -> { do_something } }
#   it { is_expected.to change(something).to(new_value) }
#
#   # good
#   it 'changes something to a new value' do
#   expect { do_something }.to change(something).to(new_value)
#   end
class RuboCop::Cop::RSpec::ImplicitBlockExpectation < ::RuboCop::Cop::RSpec::Base
  def implicit_expect(param0 = T.unsafe(nil)); end
  def lambda?(param0 = T.unsafe(nil)); end
  def lambda_subject?(param0 = T.unsafe(nil)); end
  def on_send(node); end

  private

  def find_subject(block_node); end

  # @return [Boolean]
  def multi_statement_example_group?(node); end

  def nearest_subject(node); end
end

RuboCop::Cop::RSpec::ImplicitBlockExpectation::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::RSpec::ImplicitBlockExpectation::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Check that a consistent implicit expectation style is used.
#
# This cop can be configured using the `EnforcedStyle` option
# and supports the `--auto-gen-config` flag.
#
# @example `EnforcedStyle: is_expected`
#
#   # bad
#   it { should be_truthy }
#
#   # good
#   it { is_expected.to be_truthy }
# @example `EnforcedStyle: should`
#
#   # bad
#   it { is_expected.to be_truthy }
#
#   # good
#   it { should be_truthy }
class RuboCop::Cop::RSpec::ImplicitExpect < ::RuboCop::Cop::RSpec::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  extend ::RuboCop::Cop::AutoCorrector

  def implicit_expect(param0 = T.unsafe(nil)); end
  def on_send(node); end

  private

  def is_expected_range(source_map); end
  def offending_expect(node); end
  def offense_message(offending_source); end
  def replacement_source(offending_source); end
end

RuboCop::Cop::RSpec::ImplicitExpect::ENFORCED_REPLACEMENTS = T.let(T.unsafe(nil), Hash)
RuboCop::Cop::RSpec::ImplicitExpect::MSG = T.let(T.unsafe(nil), String)

# Checks for usage of implicit subject (`is_expected` / `should`).
#
# This cop can be configured using the `EnforcedStyle` option
#
# @example `EnforcedStyle: single_line_only` (default)
#   # bad
#   it do
#   is_expected.to be_truthy
#   end
#
#   # good
#   it { is_expected.to be_truthy }
#   it do
#   expect(subject).to be_truthy
#   end
# @example `EnforcedStyle: single_statement_only`
#   # bad
#   it do
#   foo = 1
#   is_expected.to be_truthy
#   end
#
#   # good
#   it do
#   foo = 1
#   expect(subject).to be_truthy
#   end
#   it do
#   is_expected.to be_truthy
#   end
# @example `EnforcedStyle: disallow`
#   # bad
#   it { is_expected.to be_truthy }
#
#   # good
#   it { expect(subject).to be_truthy }
class RuboCop::Cop::RSpec::ImplicitSubject < ::RuboCop::Cop::RSpec::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  extend ::RuboCop::Cop::AutoCorrector

  def implicit_subject?(param0 = T.unsafe(nil)); end
  def on_send(node); end

  private

  # @return [Boolean]
  def allowed_by_style?(example); end

  def autocorrect(corrector, node); end

  # @return [Boolean]
  def valid_usage?(node); end
end

RuboCop::Cop::RSpec::ImplicitSubject::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::RSpec::ImplicitSubject::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# A helper for `inflected` style
module RuboCop::Cop::RSpec::InflectedHelper
  include ::RuboCop::RSpec::Language
  extend ::RuboCop::AST::NodePattern::Macros

  def be_bool?(param0 = T.unsafe(nil)); end
  def be_boolthy?(param0 = T.unsafe(nil)); end
  def predicate_in_actual?(param0 = T.unsafe(nil)); end

  private

  # @return [Boolean]
  def boolean_matcher?(node); end

  def check_inflected(node); end
  def message_inflected(predicate); end

  # @return [Boolean]
  def predicate?(sym); end

  def remove_predicate(corrector, predicate); end
  def rewrite_matcher(corrector, predicate, matcher); end
  def to_predicate_matcher(name); end

  # @return [Boolean]
  def true?(to_symbol, matcher); end
end

RuboCop::Cop::RSpec::InflectedHelper::MSG_INFLECTED = T.let(T.unsafe(nil), String)

# Helps you identify whether a given node
# is within an example group or not.
module RuboCop::Cop::RSpec::InsideExampleGroup
  private

  # @return [Boolean]
  def example_group_root?(node); end

  # @return [Boolean]
  def example_group_root_with_siblings?(node); end

  # @return [Boolean]
  def inside_example_group?(node); end
end

# Checks for `instance_double` used with `have_received`.
#
# @example
#   # bad
#   it do
#   foo = instance_double(Foo).as_null_object
#   expect(foo).to have_received(:bar)
#   end
#
#   # good
#   it do
#   foo = instance_spy(Foo)
#   expect(foo).to have_received(:bar)
#   end
class RuboCop::Cop::RSpec::InstanceSpy < ::RuboCop::Cop::RSpec::Base
  extend ::RuboCop::Cop::AutoCorrector

  def have_received_usage(param0); end
  def null_double(param0); end
  def on_block(node); end

  private

  def autocorrect(corrector, node); end
end

RuboCop::Cop::RSpec::InstanceSpy::MSG = T.let(T.unsafe(nil), String)

# Checks for instance variable usage in specs.
#
# This cop can be configured with the option `AssignmentOnly` which
# will configure the cop to only register offenses on instance
# variable usage if the instance variable is also assigned within
# the spec
#
# @example
#   # bad
#   describe MyClass do
#   before { @foo = [] }
#   it { expect(@foo).to be_empty }
#   end
#
#   # good
#   describe MyClass do
#   let(:foo) { [] }
#   it { expect(foo).to be_empty }
#   end
# @example with AssignmentOnly configuration
#
#   # rubocop.yml
#   # RSpec/InstanceVariable:
#   #   AssignmentOnly: false
#
#   # bad
#   describe MyClass do
#   before { @foo = [] }
#   it { expect(@foo).to be_empty }
#   end
#
#   # allowed
#   describe MyClass do
#   it { expect(@foo).to be_empty }
#   end
#
#   # good
#   describe MyClass do
#   let(:foo) { [] }
#   it { expect(foo).to be_empty }
#   end
class RuboCop::Cop::RSpec::InstanceVariable < ::RuboCop::Cop::RSpec::Base
  include ::RuboCop::Cop::RSpec::TopLevelGroup

  def custom_matcher?(param0 = T.unsafe(nil)); end
  def dynamic_class?(param0 = T.unsafe(nil)); end
  def ivar_assigned?(param0, param1); end
  def ivar_usage(param0); end
  def on_top_level_group(node); end

  private

  # @return [Boolean]
  def assignment_only?; end

  # @return [Boolean]
  def valid_usage?(node); end
end

RuboCop::Cop::RSpec::InstanceVariable::MSG = T.let(T.unsafe(nil), String)

# Checks that only one `it_behaves_like` style is used.
#
# @example when configuration is `EnforcedStyle: it_behaves_like`
#   # bad
#   it_should_behave_like 'a foo'
#
#   # good
#   it_behaves_like 'a foo'
# @example when configuration is `EnforcedStyle: it_should_behave_like`
#   # bad
#   it_behaves_like 'a foo'
#
#   # good
#   it_should_behave_like 'a foo'
class RuboCop::Cop::RSpec::ItBehavesLike < ::RuboCop::Cop::RSpec::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  extend ::RuboCop::Cop::AutoCorrector

  def example_inclusion_offense(param0 = T.unsafe(nil), param1); end
  def on_send(node); end

  private

  def message(_node); end
end

RuboCop::Cop::RSpec::ItBehavesLike::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::RSpec::ItBehavesLike::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Check that `all` matcher is used instead of iterating over an array.
#
# @example
#   # bad
#   it 'validates users' do
#   [user1, user2, user3].each { |user| expect(user).to be_valid }
#   end
#
#   # good
#   it 'validates users' do
#   expect([user1, user2, user3]).to all(be_valid)
#   end
class RuboCop::Cop::RSpec::IteratedExpectation < ::RuboCop::Cop::RSpec::Base
  def each?(param0 = T.unsafe(nil)); end
  def expectation?(param0 = T.unsafe(nil), param1); end
  def on_block(node); end

  private

  # @return [Boolean]
  def only_expectations?(body, arg); end

  # @return [Boolean]
  def single_expectation?(body, arg); end
end

RuboCop::Cop::RSpec::IteratedExpectation::MSG = T.let(T.unsafe(nil), String)

# Enforce that subject is the first definition in the test.
#
# @example
#   # bad
#   let(:params) { blah }
#   subject { described_class.new(params) }
#
#   before { do_something }
#   subject { described_class.new(params) }
#
#   it { expect_something }
#   subject { described_class.new(params) }
#   it { expect_something_else }
#
#   # good
#   subject { described_class.new(params) }
#   let(:params) { blah }
#
#   # good
#   subject { described_class.new(params) }
#   before { do_something }
#
#   # good
#   subject { described_class.new(params) }
#   it { expect_something }
#   it { expect_something_else }
class RuboCop::Cop::RSpec::LeadingSubject < ::RuboCop::Cop::RSpec::Base
  include ::RuboCop::Cop::RSpec::InsideExampleGroup
  extend ::RuboCop::Cop::AutoCorrector

  def check_previous_nodes(node); end
  def on_block(node); end

  private

  def autocorrect(corrector, node, sibling); end

  # @return [Boolean]
  def offending?(node); end

  def offending_node(node); end
  def parent(node); end
end

RuboCop::Cop::RSpec::LeadingSubject::MSG = T.let(T.unsafe(nil), String)

# Checks that no class, module, or constant is declared.
#
# Constants, including classes and modules, when declared in a block
# scope, are defined in global namespace, and leak between examples.
#
# If several examples may define a `DummyClass`, instead of being a
# blank slate class as it will be in the first example, subsequent
# examples will be reopening it and modifying its behaviour in
# unpredictable ways.
# Even worse when a class that exists in the codebase is reopened.
#
# Anonymous classes are fine, since they don't result in global
# namespace name clashes.
#
# @example Constants leak between examples
#   # bad
#   describe SomeClass do
#   OtherClass = Struct.new
#   CONSTANT_HERE = 'I leak into global namespace'
#   end
#
#   # good
#   describe SomeClass do
#   before do
#   stub_const('OtherClass', Struct.new)
#   stub_const('CONSTANT_HERE', 'I only exist during this example')
#   end
#   end
# @example
#   # bad
#   describe SomeClass do
#   class FooClass < described_class
#   def double_that
#   some_base_method * 2
#   end
#   end
#
#   it { expect(FooClass.new.double_that).to eq(4) }
#   end
#
#   # good - anonymous class, no constant needs to be defined
#   describe SomeClass do
#   let(:foo_class) do
#   Class.new(described_class) do
#   def double_that
#   some_base_method * 2
#   end
#   end
#   end
#
#   it { expect(foo_class.new.double_that).to eq(4) }
#   end
#
#   # good - constant is stubbed
#   describe SomeClass do
#   before do
#   foo_class = Class.new(described_class) do
#   def do_something
#   end
#   end
#   stub_const('FooClass', foo_class)
#   end
#
#   it { expect(FooClass.new.double_that).to eq(4) }
#   end
# @example
#   # bad
#   describe SomeClass do
#   module SomeModule
#   class SomeClass
#   def do_something
#   end
#   end
#   end
#   end
#
#   # good
#   describe SomeClass do
#   before do
#   foo_class = Class.new(described_class) do
#   def do_something
#   end
#   end
#   stub_const('SomeModule::SomeClass', foo_class)
#   end
#   end
# @see https://relishapp.com/rspec/rspec-mocks/docs/mutating-constants
class RuboCop::Cop::RSpec::LeakyConstantDeclaration < ::RuboCop::Cop::RSpec::Base
  def on_casgn(node); end
  def on_class(node); end
  def on_module(node); end

  private

  # @return [Boolean]
  def inside_describe_block?(node); end
end

RuboCop::Cop::RSpec::LeakyConstantDeclaration::MSG_CLASS = T.let(T.unsafe(nil), String)
RuboCop::Cop::RSpec::LeakyConstantDeclaration::MSG_CONST = T.let(T.unsafe(nil), String)
RuboCop::Cop::RSpec::LeakyConstantDeclaration::MSG_MODULE = T.let(T.unsafe(nil), String)

# Checks for `let` definitions that come after an example.
#
# @example
#   # Bad
#   let(:foo) { bar }
#
#   it 'checks what foo does' do
#   expect(foo).to be
#   end
#
#   let(:some) { other }
#
#   it 'checks what some does' do
#   expect(some).to be
#   end
#
#   # Good
#   let(:foo) { bar }
#   let(:some) { other }
#
#   it 'checks what foo does' do
#   expect(foo).to be
#   end
#
#   it 'checks what some does' do
#   expect(some).to be
#   end
class RuboCop::Cop::RSpec::LetBeforeExamples < ::RuboCop::Cop::RSpec::Base
  extend ::RuboCop::Cop::AutoCorrector

  def example_or_group?(param0 = T.unsafe(nil)); end
  def on_block(node); end

  private

  def autocorrect(corrector, node, first_example); end
  def check_let_declarations(node); end
  def find_first_example(node); end

  # @return [Boolean]
  def multiline_block?(block); end
end

RuboCop::Cop::RSpec::LetBeforeExamples::MSG = T.let(T.unsafe(nil), String)

# Checks unreferenced `let!` calls being used for test setup.
#
# @example
#   # Bad
#   let!(:my_widget) { create(:widget) }
#
#   it 'counts widgets' do
#   expect(Widget.count).to eq(1)
#   end
#
#   # Good
#   it 'counts widgets' do
#   create(:widget)
#   expect(Widget.count).to eq(1)
#   end
#
#   # Good
#   before { create(:widget) }
#
#   it 'counts widgets' do
#   expect(Widget.count).to eq(1)
#   end
class RuboCop::Cop::RSpec::LetSetup < ::RuboCop::Cop::RSpec::Base
  def example_or_shared_group_or_including?(param0 = T.unsafe(nil)); end
  def let_bang(param0 = T.unsafe(nil)); end
  def method_called?(param0, param1); end
  def on_block(node); end

  private

  def child_let_bang(node, &block); end
  def unused_let_bang(node); end
end

RuboCop::Cop::RSpec::LetSetup::MSG = T.let(T.unsafe(nil), String)

# Check that chains of messages are not being stubbed.
#
# @example
#   # bad
#   allow(foo).to receive_message_chain(:bar, :baz).and_return(42)
#
#   # better
#   thing = Thing.new(baz: 42)
#   allow(foo).to receive(:bar).and_return(thing)
class RuboCop::Cop::RSpec::MessageChain < ::RuboCop::Cop::RSpec::Base
  def on_send(node); end
end

RuboCop::Cop::RSpec::MessageChain::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::RSpec::MessageChain::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Checks for consistent message expectation style.
#
# This cop can be configured in your configuration using the
# `EnforcedStyle` option and supports `--auto-gen-config`.
#
# @example `EnforcedStyle: allow`
#
#   # bad
#   expect(foo).to receive(:bar)
#
#   # good
#   allow(foo).to receive(:bar)
# @example `EnforcedStyle: expect`
#
#   # bad
#   allow(foo).to receive(:bar)
#
#   # good
#   expect(foo).to receive(:bar)
class RuboCop::Cop::RSpec::MessageExpectation < ::RuboCop::Cop::RSpec::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle

  def message_expectation(param0 = T.unsafe(nil)); end
  def on_send(node); end
  def receive_message?(param0); end

  private

  # @return [Boolean]
  def preferred_style?(expectation); end
end

RuboCop::Cop::RSpec::MessageExpectation::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::RSpec::MessageExpectation::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)
RuboCop::Cop::RSpec::MessageExpectation::SUPPORTED_STYLES = T.let(T.unsafe(nil), Array)

# Checks that message expectations are set using spies.
#
# This cop can be configured in your configuration using the
# `EnforcedStyle` option and supports `--auto-gen-config`.
#
# @example `EnforcedStyle: have_received`
#
#   # bad
#   expect(foo).to receive(:bar)
#
#   # good
#   expect(foo).to have_received(:bar)
# @example `EnforcedStyle: receive`
#
#   # bad
#   expect(foo).to have_received(:bar)
#
#   # good
#   expect(foo).to receive(:bar)
class RuboCop::Cop::RSpec::MessageSpies < ::RuboCop::Cop::RSpec::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle

  def message_expectation(param0 = T.unsafe(nil)); end
  def on_send(node); end
  def receive_message(param0); end

  private

  def error_message(receiver); end

  # @return [Boolean]
  def preferred_style?(expectation); end

  def receive_message_matcher(node); end
end

RuboCop::Cop::RSpec::MessageSpies::MSG_HAVE_RECEIVED = T.let(T.unsafe(nil), String)
RuboCop::Cop::RSpec::MessageSpies::MSG_RECEIVE = T.let(T.unsafe(nil), String)
RuboCop::Cop::RSpec::MessageSpies::SUPPORTED_STYLES = T.let(T.unsafe(nil), Array)

# Checks that the first argument to an example group is not empty.
#
# @example
#   # bad
#   describe do
#   end
#
#   RSpec.describe do
#   end
#
#   # good
#   describe TestedClass do
#   end
#
#   describe "A feature example" do
#   end
class RuboCop::Cop::RSpec::MissingExampleGroupArgument < ::RuboCop::Cop::RSpec::Base
  def on_block(node); end
end

RuboCop::Cop::RSpec::MissingExampleGroupArgument::MSG = T.let(T.unsafe(nil), String)

# Checks for multiple top-level example groups.
#
# Multiple descriptions for the same class or module should either
# be nested or separated into different test files.
#
# @example
#   # bad
#   describe MyClass, '.do_something' do
#   end
#   describe MyClass, '.do_something_else' do
#   end
#
#   # good
#   describe MyClass do
#   describe '.do_something' do
#   end
#   describe '.do_something_else' do
#   end
#   end
class RuboCop::Cop::RSpec::MultipleDescribes < ::RuboCop::Cop::RSpec::Base
  include ::RuboCop::Cop::RSpec::TopLevelGroup

  def on_top_level_group(node); end
end

RuboCop::Cop::RSpec::MultipleDescribes::MSG = T.let(T.unsafe(nil), String)

# Checks if examples contain too many `expect` calls.
#
# This cop is configurable using the `Max` option
# and works with `--auto-gen-config`.
#
# @example
#
#   # bad
#   describe UserCreator do
#   it 'builds a user' do
#   expect(user.name).to eq("John")
#   expect(user.age).to eq(22)
#   end
#   end
#
#   # good
#   describe UserCreator do
#   it 'sets the users name' do
#   expect(user.name).to eq("John")
#   end
#
#   it 'sets the users age' do
#   expect(user.age).to eq(22)
#   end
#   end
# @example configuration
#
#   # .rubocop.yml
#   # RSpec/MultipleExpectations:
#   #   Max: 2
#
#   # not flagged by rubocop
#   describe UserCreator do
#   it 'builds a user' do
#   expect(user.name).to eq("John")
#   expect(user.age).to eq(22)
#   end
#   end
# @see http://betterspecs.org/#single Single expectation test
class RuboCop::Cop::RSpec::MultipleExpectations < ::RuboCop::Cop::RSpec::Base
  include ::RuboCop::Cop::ConfigurableMax

  def aggregate_failures?(param0 = T.unsafe(nil), param1); end
  def aggregate_failures_block?(param0 = T.unsafe(nil)); end
  def expect?(param0 = T.unsafe(nil)); end
  def on_block(node); end

  private

  # @return [Boolean]
  def example_with_aggregate_failures?(example_node); end

  def find_aggregate_failures(example_node); end
  def find_expectation(node, &block); end
  def flag_example(node, expectation_count:); end
  def max_expectations; end
end

RuboCop::Cop::RSpec::MultipleExpectations::ANYTHING = T.let(T.unsafe(nil), Proc)
RuboCop::Cop::RSpec::MultipleExpectations::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::RSpec::MultipleExpectations::TRUE = T.let(T.unsafe(nil), Proc)

# Checks if example groups contain too many `let` and `subject` calls.
#
# This cop is configurable using the `Max` option and the `AllowSubject`
# which will configure the cop to only register offenses on calls to
# `let` and not calls to `subject`.
#
# @example
#   # bad
#   describe MyClass do
#   let(:foo) { [] }
#   let(:bar) { [] }
#   let!(:baz) { [] }
#   let(:qux) { [] }
#   let(:quux) { [] }
#   let(:quuz) { {} }
#   end
#
#   describe MyClass do
#   let(:foo) { [] }
#   let(:bar) { [] }
#   let!(:baz) { [] }
#
#   context 'when stuff' do
#   let(:qux) { [] }
#   let(:quux) { [] }
#   let(:quuz) { {} }
#   end
#   end
#
#   # good
#   describe MyClass do
#   let(:bar) { [] }
#   let!(:baz) { [] }
#   let(:qux) { [] }
#   let(:quux) { [] }
#   let(:quuz) { {} }
#   end
#
#   describe MyClass do
#   context 'when stuff' do
#   let(:foo) { [] }
#   let(:bar) { [] }
#   let!(:booger) { [] }
#   end
#
#   context 'when other stuff' do
#   let(:qux) { [] }
#   let(:quux) { [] }
#   let(:quuz) { {} }
#   end
#   end
# @example when disabling AllowSubject configuration
#
#   # rubocop.yml
#   # RSpec/MultipleMemoizedHelpers:
#   #   AllowSubject: false
#
#   # bad - `subject` counts towards memoized helpers
#   describe MyClass do
#   subject { {} }
#   let(:foo) { [] }
#   let(:bar) { [] }
#   let!(:baz) { [] }
#   let(:qux) { [] }
#   let(:quux) { [] }
#   end
# @example with Max configuration
#
#   # rubocop.yml
#   # RSpec/MultipleMemoizedHelpers:
#   #   Max: 1
#
#   # bad
#   describe MyClass do
#   let(:foo) { [] }
#   let(:bar) { [] }
#   end
class RuboCop::Cop::RSpec::MultipleMemoizedHelpers < ::RuboCop::Cop::RSpec::Base
  include ::RuboCop::Cop::ConfigurableMax
  include ::RuboCop::Cop::RSpec::Variable

  def on_block(node); end
  def on_new_investigation; end

  private

  def all_helpers(node); end

  # @return [Boolean]
  def allow_subject?; end

  # Returns the value of attribute example_group_memoized_helpers.
  def example_group_memoized_helpers; end

  def helpers(node); end
  def max; end
  def variable_nodes(node); end
end

RuboCop::Cop::RSpec::MultipleMemoizedHelpers::MSG = T.let(T.unsafe(nil), String)

# Checks if an example group defines `subject` multiple times.
#
# The autocorrect behavior for this cop depends on the type of
# duplication:
#
#   - If multiple named subjects are defined then this probably indicates
#     that the overwritten subjects (all subjects except the last
#     definition) are effectively being used to define helpers. In this
#     case they are replaced with `let`.
#
#   - If multiple unnamed subjects are defined though then this can *only*
#     be dead code and we remove the overwritten subject definitions.
#
#   - If subjects are defined with `subject!` then we don't autocorrect.
#     This is enough of an edge case that people can just move this to
#     a `before` hook on their own
#
# @example
#
#   # bad
#   describe Foo do
#   subject(:user) { User.new }
#   subject(:post) { Post.new }
#   end
#
#   # good
#   describe Foo do
#   let(:user) { User.new }
#   subject(:post) { Post.new }
#   end
class RuboCop::Cop::RSpec::MultipleSubjects < ::RuboCop::Cop::RSpec::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  def on_block(node); end

  private

  def autocorrect(corrector, subject); end

  # @return [Boolean]
  def named_subject?(node); end

  def remove_autocorrect(corrector, node); end
  def rename_autocorrect(corrector, node); end
end

RuboCop::Cop::RSpec::MultipleSubjects::MSG = T.let(T.unsafe(nil), String)

# Checks for explicitly referenced test subjects.
#
# RSpec lets you declare an "implicit subject" using `subject { ... }`
# which allows for tests like `it { is_expected.to be_valid }`.
# If you need to reference your test subject you should explicitly
# name it using `subject(:your_subject_name) { ... }`. Your test subjects
# should be the most important object in your tests so they deserve
# a descriptive name.
#
# This cop can be configured in your configuration using the
# `IgnoreSharedExamples` which will not report offenses for implicit
# subjects in shared example groups.
#
# @example
#   # bad
#   RSpec.describe User do
#   subject { described_class.new }
#
#   it 'is valid' do
#   expect(subject.valid?).to be(true)
#   end
#   end
#
#   # good
#   RSpec.describe Foo do
#   subject(:user) { described_class.new }
#
#   it 'is valid' do
#   expect(user.valid?).to be(true)
#   end
#   end
#
#   # also good
#   RSpec.describe Foo do
#   subject(:user) { described_class.new }
#
#   it { is_expected.to be_valid }
#   end
class RuboCop::Cop::RSpec::NamedSubject < ::RuboCop::Cop::RSpec::Base
  def example_or_hook_block?(param0 = T.unsafe(nil)); end

  # @return [Boolean]
  def ignored_shared_example?(node); end

  def on_block(node); end
  def shared_example?(param0 = T.unsafe(nil)); end
  def subject_usage(param0); end
end

RuboCop::Cop::RSpec::NamedSubject::MSG = T.let(T.unsafe(nil), String)

# Checks for nested example groups.
#
# This cop is configurable using the `Max` option
# and supports `--auto-gen-config`.
#
# @example
#   # bad
#   context 'when using some feature' do
#   let(:some)    { :various }
#   let(:feature) { :setup   }
#
#   context 'when user is signed in' do  # flagged by rubocop
#   let(:user) do
#   UserCreate.call(user_attributes)
#   end
#
#   let(:user_attributes) do
#   {
#   name: 'John',
#   age:  22,
#   role: role
#   }
#   end
#
#   context 'when user is an admin' do # flagged by rubocop
#   let(:role) { 'admin' }
#
#   it 'blah blah'
#   it 'yada yada'
#   end
#   end
#   end
#
#   # better
#   context 'using some feature as an admin' do
#   let(:some)    { :various }
#   let(:feature) { :setup   }
#
#   let(:user) do
#   UserCreate.call(
#   name: 'John',
#   age:  22,
#   role: 'admin'
#   )
#   end
#
#   it 'blah blah'
#   it 'yada yada'
#   end
# @example configuration
#
#   # .rubocop.yml
#   # RSpec/NestedGroups:
#   #   Max: 2
#
#   context 'when using some feature' do
#   let(:some)    { :various }
#   let(:feature) { :setup   }
#
#   context 'when user is signed in' do
#   let(:user) do
#   UserCreate.call(user_attributes)
#   end
#
#   let(:user_attributes) do
#   {
#   name: 'John',
#   age:  22,
#   role: role
#   }
#   end
#
#   context 'when user is an admin' do # flagged by rubocop
#   let(:role) { 'admin' }
#
#   it 'blah blah'
#   it 'yada yada'
#   end
#   end
#   end
class RuboCop::Cop::RSpec::NestedGroups < ::RuboCop::Cop::RSpec::Base
  include ::RuboCop::Cop::ConfigurableMax
  include ::RuboCop::Cop::RSpec::TopLevelGroup

  def on_top_level_group(node); end

  private

  # @yield [node, nesting]
  def find_nested_example_groups(node, nesting: T.unsafe(nil), &block); end

  def max_nesting; end
  def max_nesting_config; end
  def message(nesting); end
end

RuboCop::Cop::RSpec::NestedGroups::DEPRECATED_MAX_KEY = T.let(T.unsafe(nil), String)
RuboCop::Cop::RSpec::NestedGroups::DEPRECATION_WARNING = T.let(T.unsafe(nil), String)
RuboCop::Cop::RSpec::NestedGroups::MSG = T.let(T.unsafe(nil), String)

# Checks for consistent method usage for negating expectations.
#
# @example
#   # bad
#   it '...' do
#   expect(false).to_not be_true
#   end
#
#   # good
#   it '...' do
#   expect(false).not_to be_true
#   end
class RuboCop::Cop::RSpec::NotToNot < ::RuboCop::Cop::RSpec::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  extend ::RuboCop::Cop::AutoCorrector

  def not_to_not_offense(param0 = T.unsafe(nil), param1); end
  def on_send(node); end

  private

  def message(_node); end
end

RuboCop::Cop::RSpec::NotToNot::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::RSpec::NotToNot::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Checks if there is a let/subject that overwrites an existing one.
#
# @example
#   # bad
#   let(:foo) { bar }
#   let(:foo) { baz }
#
#   subject(:foo) { bar }
#   let(:foo) { baz }
#
#   let(:foo) { bar }
#   let!(:foo) { baz }
#
#   # good
#   subject(:test) { something }
#   let(:foo) { bar }
#   let(:baz) { baz }
#   let!(:other) { other }
class RuboCop::Cop::RSpec::OverwritingSetup < ::RuboCop::Cop::RSpec::Base
  def first_argument_name(param0 = T.unsafe(nil)); end
  def on_block(node); end
  def setup?(param0 = T.unsafe(nil)); end

  private

  # @return [Boolean]
  def common_setup?(node); end

  def find_duplicates(node); end
end

RuboCop::Cop::RSpec::OverwritingSetup::MSG = T.let(T.unsafe(nil), String)

# Checks for any pending or skipped examples.
#
# @example
#   # bad
#   describe MyClass do
#   it "should be true"
#   end
#
#   describe MyClass do
#   it "should be true", skip: true do
#   expect(1).to eq(2)
#   end
#   end
#
#   describe MyClass do
#   it "should be true" do
#   pending
#   end
#   end
#
#   describe MyClass do
#   xit "should be true" do
#   end
#   end
#
#   # good
#   describe MyClass do
#   end
class RuboCop::Cop::RSpec::Pending < ::RuboCop::Cop::RSpec::Base
  def on_send(node); end
  def pending_block?(param0 = T.unsafe(nil)); end
  def skip_or_pending?(param0 = T.unsafe(nil)); end
  def skippable?(param0 = T.unsafe(nil)); end
  def skipped_in_metadata?(param0 = T.unsafe(nil)); end

  private

  # @return [Boolean]
  def skipped?(node); end
end

RuboCop::Cop::RSpec::Pending::MSG = T.let(T.unsafe(nil), String)

# Prefer using predicate matcher over using predicate method directly.
#
# RSpec defines magic matchers for predicate methods.
# This cop recommends to use the predicate matcher instead of using
# predicate method directly.
#
# @example Strict: true, EnforcedStyle: inflected (default)
#   # bad
#   expect(foo.something?).to be_truthy
#
#   # good
#   expect(foo).to be_something
#
#   # also good - It checks "true" strictly.
#   expect(foo.something?).to be(true)
# @example Strict: false, EnforcedStyle: inflected
#   # bad
#   expect(foo.something?).to be_truthy
#   expect(foo.something?).to be(true)
#
#   # good
#   expect(foo).to be_something
# @example Strict: true, EnforcedStyle: explicit
#   # bad
#   expect(foo).to be_something
#
#   # good - the above code is rewritten to it by this cop
#   expect(foo.something?).to be(true)
# @example Strict: false, EnforcedStyle: explicit
#   # bad
#   expect(foo).to be_something
#
#   # good - the above code is rewritten to it by this cop
#   expect(foo.something?).to be_truthy
class RuboCop::Cop::RSpec::PredicateMatcher < ::RuboCop::Cop::RSpec::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RSpec::InflectedHelper
  include ::RuboCop::Cop::RSpec::ExplicitHelper
  extend ::RuboCop::Cop::AutoCorrector

  def on_block(node); end
  def on_send(node); end

  private

  # returns args location with whitespace
  #
  # @example
  #   foo 1, 2
  #   ^^^^^
  def args_loc(send_node); end

  # returns block location with whitespace
  #
  # @example
  #   foo { bar }
  #   ^^^^^^^^
  def block_loc(send_node); end
end

module RuboCop::Cop::RSpec::Rails; end

# Checks that tests use RSpec `before` hook over Rails `setup` method.
#
# @example
#
#   # bad
#   setup do
#   allow(foo).to receive(:bar)
#   end
#
#   # good
#   before do
#   allow(foo).to receive(:bar)
#   end
class RuboCop::Cop::RSpec::Rails::AvoidSetupHook < ::RuboCop::Cop::RSpec::Base
  extend ::RuboCop::Cop::AutoCorrector

  def on_block(node); end
  def setup_call(param0 = T.unsafe(nil)); end
end

RuboCop::Cop::RSpec::Rails::AvoidSetupHook::MSG = T.let(T.unsafe(nil), String)

# Enforces use of symbolic or numeric value to describe HTTP status.
#
# @example `EnforcedStyle: symbolic` (default)
#   # bad
#   it { is_expected.to have_http_status 200 }
#   it { is_expected.to have_http_status 404 }
#
#   # good
#   it { is_expected.to have_http_status :ok }
#   it { is_expected.to have_http_status :not_found }
#   it { is_expected.to have_http_status :success }
#   it { is_expected.to have_http_status :error }
# @example `EnforcedStyle: numeric`
#   # bad
#   it { is_expected.to have_http_status :ok }
#   it { is_expected.to have_http_status :not_found }
#
#   # good
#   it { is_expected.to have_http_status 200 }
#   it { is_expected.to have_http_status 404 }
#   it { is_expected.to have_http_status :success }
#   it { is_expected.to have_http_status :error }
class RuboCop::Cop::RSpec::Rails::HttpStatus < ::RuboCop::Cop::RSpec::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  extend ::RuboCop::Cop::AutoCorrector

  def http_status(param0 = T.unsafe(nil)); end
  def on_send(node); end

  private

  def checker_class; end
end

class RuboCop::Cop::RSpec::Rails::HttpStatus::NumericStyleChecker
  # @return [NumericStyleChecker] a new instance of NumericStyleChecker
  def initialize(node); end

  def message; end

  # Returns the value of attribute node.
  def node; end

  # @return [Boolean]
  def offensive?; end

  def preferred_style; end

  private

  # @return [Boolean]
  def allowed_symbol?; end

  def number; end
  def symbol; end
end

RuboCop::Cop::RSpec::Rails::HttpStatus::NumericStyleChecker::ALLOWED_STATUSES = T.let(T.unsafe(nil), Array)
RuboCop::Cop::RSpec::Rails::HttpStatus::NumericStyleChecker::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::RSpec::Rails::HttpStatus::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::RSpec::Rails::HttpStatus::SymbolicStyleChecker
  # @return [SymbolicStyleChecker] a new instance of SymbolicStyleChecker
  def initialize(node); end

  def message; end

  # Returns the value of attribute node.
  def node; end

  # @return [Boolean]
  def offensive?; end

  def preferred_style; end

  private

  # @return [Boolean]
  def custom_http_status_code?; end

  def number; end
  def symbol; end
end

RuboCop::Cop::RSpec::Rails::HttpStatus::SymbolicStyleChecker::MSG = T.let(T.unsafe(nil), String)

# Check for `once` and `twice` receive counts matchers usage.
#
# @example
#
#   # bad
#   expect(foo).to receive(:bar).exactly(1).times
#   expect(foo).to receive(:bar).exactly(2).times
#   expect(foo).to receive(:bar).at_least(1).times
#   expect(foo).to receive(:bar).at_least(2).times
#   expect(foo).to receive(:bar).at_most(1).times
#   expect(foo).to receive(:bar).at_most(2).times
#
#   # good
#   expect(foo).to receive(:bar).once
#   expect(foo).to receive(:bar).twice
#   expect(foo).to receive(:bar).at_least(:once)
#   expect(foo).to receive(:bar).at_least(:twice)
#   expect(foo).to receive(:bar).at_most(:once)
#   expect(foo).to receive(:bar).at_most(:twice).times
class RuboCop::Cop::RSpec::ReceiveCounts < ::RuboCop::Cop::RSpec::Base
  extend ::RuboCop::Cop::AutoCorrector

  def on_send(node); end
  def receive_counts(param0 = T.unsafe(nil)); end
  def stub?(param0); end

  private

  def autocorrect(corrector, node, range); end
  def matcher_for(method, count); end
  def message_for(node, source); end
  def range(node, offending_node); end
end

RuboCop::Cop::RSpec::ReceiveCounts::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::RSpec::ReceiveCounts::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Prefer `not_to receive(...)` over `receive(...).never`.
#
# @example
#
#   # bad
#   expect(foo).to receive(:bar).never
#
#   # good
#   expect(foo).not_to receive(:bar)
class RuboCop::Cop::RSpec::ReceiveNever < ::RuboCop::Cop::RSpec::Base
  extend ::RuboCop::Cop::AutoCorrector

  def method_on_stub?(param0); end
  def on_send(node); end

  private

  def autocorrect(corrector, node); end
end

RuboCop::Cop::RSpec::ReceiveNever::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::RSpec::ReceiveNever::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Check for repeated description strings in example groups.
#
# @example
#
#   # bad
#   RSpec.describe User do
#   it 'is valid' do
#   # ...
#   end
#
#   it 'is valid' do
#   # ...
#   end
#   end
#
#   # good
#   RSpec.describe User do
#   it 'is valid when first and last name are present' do
#   # ...
#   end
#
#   it 'is valid when last name only is present' do
#   # ...
#   end
#   end
#
#   # good
#   RSpec.describe User do
#   it 'is valid' do
#   # ...
#   end
#
#   it 'is valid', :flag do
#   # ...
#   end
#   end
class RuboCop::Cop::RSpec::RepeatedDescription < ::RuboCop::Cop::RSpec::Base
  def on_block(node); end

  private

  def example_signature(example); end

  # Select examples in the current scope with repeated description strings
  def repeated_descriptions(node); end
end

RuboCop::Cop::RSpec::RepeatedDescription::MSG = T.let(T.unsafe(nil), String)

# Check for repeated examples within example groups.
#
# @example
#
#   it 'is valid' do
#   expect(user).to be_valid
#   end
#
#   it 'validates the user' do
#   expect(user).to be_valid
#   end
class RuboCop::Cop::RSpec::RepeatedExample < ::RuboCop::Cop::RSpec::Base
  def on_block(node); end

  private

  def example_signature(example); end
  def repeated_examples(node); end
end

RuboCop::Cop::RSpec::RepeatedExample::MSG = T.let(T.unsafe(nil), String)

# Check for repeated describe and context block body.
#
# @example
#
#   # bad
#   describe 'cool feature x' do
#   it { cool_predicate }
#   end
#
#   describe 'cool feature y' do
#   it { cool_predicate }
#   end
#
#   # good
#   describe 'cool feature' do
#   it { cool_predicate }
#   end
#
#   describe 'another cool feature' do
#   it { another_predicate }
#   end
#
#   # good
#   context 'when case x', :tag do
#   it { cool_predicate }
#   end
#
#   context 'when case y' do
#   it { cool_predicate }
#   end
#
#   # good
#   context Array do
#   it { is_expected.to respond_to :each }
#   end
#
#   context Hash do
#   it { is_expected.to respond_to :each }
#   end
class RuboCop::Cop::RSpec::RepeatedExampleGroupBody < ::RuboCop::Cop::RSpec::Base
  def body(param0 = T.unsafe(nil)); end
  def const_arg(param0 = T.unsafe(nil)); end
  def metadata(param0 = T.unsafe(nil)); end
  def on_begin(node); end
  def several_example_groups?(param0 = T.unsafe(nil)); end
  def skip_or_pending?(param0 = T.unsafe(nil)); end

  private

  def add_repeated_lines(groups); end
  def message(group, repeats); end
  def repeated_group_bodies(node); end
  def signature_keys(group); end
end

RuboCop::Cop::RSpec::RepeatedExampleGroupBody::MSG = T.let(T.unsafe(nil), String)

# Check for repeated example group descriptions.
#
# @example
#
#   # bad
#   describe 'cool feature' do
#   # example group
#   end
#
#   describe 'cool feature' do
#   # example group
#   end
#
#   # bad
#   context 'when case x' do
#   # example group
#   end
#
#   describe 'when case x' do
#   # example group
#   end
#
#   # good
#   describe 'cool feature' do
#   # example group
#   end
#
#   describe 'another cool feature' do
#   # example group
#   end
#
#   # good
#   context 'when case x' do
#   # example group
#   end
#
#   context 'when another case' do
#   # example group
#   end
class RuboCop::Cop::RSpec::RepeatedExampleGroupDescription < ::RuboCop::Cop::RSpec::Base
  def doc_string_and_metadata(param0 = T.unsafe(nil)); end
  def empty_description?(param0 = T.unsafe(nil)); end
  def on_begin(node); end
  def several_example_groups?(param0 = T.unsafe(nil)); end
  def skip_or_pending?(param0 = T.unsafe(nil)); end

  private

  def add_repeated_lines(groups); end
  def message(group, repeats); end
  def repeated_group_descriptions(node); end
end

RuboCop::Cop::RSpec::RepeatedExampleGroupDescription::MSG = T.let(T.unsafe(nil), String)

# Check for repeated include of shared examples.
#
# @example
#
#   # bad
#   describe 'foo' do
#   include_examples 'cool stuff'
#   include_examples 'cool stuff'
#   end
#
#   # bad
#   describe 'foo' do
#   it_behaves_like 'a cool', 'thing'
#   it_behaves_like 'a cool', 'thing'
#   end
#
#   # bad
#   context 'foo' do
#   it_should_behave_like 'a duck'
#   it_should_behave_like 'a duck'
#   end
#
#   # good
#   describe 'foo' do
#   include_examples 'cool stuff'
#   end
#
#   describe 'bar' do
#   include_examples 'cool stuff'
#   end
#
#   # good
#   describe 'foo' do
#   it_behaves_like 'a cool', 'thing'
#   it_behaves_like 'a cool', 'person'
#   end
#
#   # good
#   context 'foo' do
#   it_should_behave_like 'a duck'
#   it_should_behave_like 'a goose'
#   end
class RuboCop::Cop::RSpec::RepeatedIncludeExample < ::RuboCop::Cop::RSpec::Base
  def include_examples?(param0 = T.unsafe(nil)); end
  def on_begin(node); end
  def several_include_examples?(param0 = T.unsafe(nil)); end
  def shared_examples_name(param0 = T.unsafe(nil)); end

  private

  def add_repeated_lines(items); end

  # @return [Boolean]
  def literal_include_examples?(node); end

  def message(item, repeats); end
  def repeated_include_examples(node); end
  def signature_keys(item); end
end

RuboCop::Cop::RSpec::RepeatedIncludeExample::MSG = T.let(T.unsafe(nil), String)

# Checks for consistent style of stub's return setting.
#
# Enforces either `and_return` or block-style return in the cases
# where the returned value is constant. Ignores dynamic returned values
# are the result would be different
#
# This cop can be configured using the `EnforcedStyle` option
#
# @example `EnforcedStyle: block`
#   # bad
#   allow(Foo).to receive(:bar).and_return("baz")
#   expect(Foo).to receive(:bar).and_return("baz")
#
#   # good
#   allow(Foo).to receive(:bar) { "baz" }
#   expect(Foo).to receive(:bar) { "baz" }
#   # also good as the returned value is dynamic
#   allow(Foo).to receive(:bar).and_return(bar.baz)
# @example `EnforcedStyle: and_return`
#   # bad
#   allow(Foo).to receive(:bar) { "baz" }
#   expect(Foo).to receive(:bar) { "baz" }
#
#   # good
#   allow(Foo).to receive(:bar).and_return("baz")
#   expect(Foo).to receive(:bar).and_return("baz")
#   # also good as the returned value is dynamic
#   allow(Foo).to receive(:bar) { bar.baz }
class RuboCop::Cop::RSpec::ReturnFromStub < ::RuboCop::Cop::RSpec::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  extend ::RuboCop::Cop::AutoCorrector

  def and_return_value(param0); end
  def contains_stub?(param0); end
  def on_block(node); end
  def on_send(node); end
  def stub_with_block?(param0 = T.unsafe(nil)); end

  private

  def check_and_return_call(node); end
  def check_block_body(block); end

  # @return [Boolean]
  def dynamic?(node); end
end

class RuboCop::Cop::RSpec::ReturnFromStub::AndReturnCallCorrector
  # @return [AndReturnCallCorrector] a new instance of AndReturnCallCorrector
  def initialize(node); end

  def call(corrector); end

  private

  # Returns the value of attribute arg.
  def arg; end

  # @return [Boolean]
  def hash_without_braces?; end

  # @return [Boolean]
  def heredoc?; end

  # Returns the value of attribute node.
  def node; end

  def range; end

  # Returns the value of attribute receiver.
  def receiver; end

  def replacement; end
end

class RuboCop::Cop::RSpec::ReturnFromStub::BlockBodyCorrector
  # @return [BlockBodyCorrector] a new instance of BlockBodyCorrector
  def initialize(block); end

  def call(corrector); end

  private

  # Returns the value of attribute block.
  def block; end

  # Returns the value of attribute body.
  def body; end

  # @return [Boolean]
  def heredoc?; end

  # Returns the value of attribute node.
  def node; end
end

RuboCop::Cop::RSpec::ReturnFromStub::BlockBodyCorrector::NULL_BLOCK_BODY = T.let(T.unsafe(nil), T.untyped)
RuboCop::Cop::RSpec::ReturnFromStub::MSG_AND_RETURN = T.let(T.unsafe(nil), String)
RuboCop::Cop::RSpec::ReturnFromStub::MSG_BLOCK = T.let(T.unsafe(nil), String)
RuboCop::Cop::RSpec::ReturnFromStub::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Checks for let scattered across the example group.
#
# Group lets together
#
# @example
#   # bad
#   describe Foo do
#   let(:foo) { 1 }
#   subject { Foo }
#   let(:bar) { 2 }
#   before { prepare }
#   let!(:baz) { 3 }
#   end
#
#   # good
#   describe Foo do
#   subject { Foo }
#   before { prepare }
#   let(:foo) { 1 }
#   let(:bar) { 2 }
#   let!(:baz) { 3 }
#   end
class RuboCop::Cop::RSpec::ScatteredLet < ::RuboCop::Cop::RSpec::Base
  extend ::RuboCop::Cop::AutoCorrector

  def on_block(node); end

  private

  def check_let_declarations(body); end
  def find_first_let(node); end
end

RuboCop::Cop::RSpec::ScatteredLet::MSG = T.let(T.unsafe(nil), String)

# Checks for setup scattered across multiple hooks in an example group.
#
# Unify `before`, `after`, and `around` hooks when possible.
#
# @example
#   # bad
#   describe Foo do
#   before { setup1 }
#   before { setup2 }
#   end
#
#   # good
#   describe Foo do
#   before do
#   setup1
#   setup2
#   end
#   end
class RuboCop::Cop::RSpec::ScatteredSetup < ::RuboCop::Cop::RSpec::Base
  def lines_msg(numbers); end
  def on_block(node); end
  def repeated_hooks(node); end
end

RuboCop::Cop::RSpec::ScatteredSetup::MSG = T.let(T.unsafe(nil), String)

# Checks for proper shared_context and shared_examples usage.
#
# If there are no examples defined, use shared_context.
# If there is no setup defined, use shared_examples.
#
# @example
#   # bad
#   RSpec.shared_context 'only examples here' do
#   it 'does x' do
#   end
#
#   it 'does y' do
#   end
#   end
#
#   # good
#   RSpec.shared_examples 'only examples here' do
#   it 'does x' do
#   end
#
#   it 'does y' do
#   end
#   end
# @example
#   # bad
#   RSpec.shared_examples 'only setup here' do
#   subject(:foo) { :bar }
#
#   let(:baz) { :bazz }
#
#   before do
#   something
#   end
#   end
#
#   # good
#   RSpec.shared_context 'only setup here' do
#   subject(:foo) { :bar }
#
#   let(:baz) { :bazz }
#
#   before do
#   something
#   end
#   end
class RuboCop::Cop::RSpec::SharedContext < ::RuboCop::Cop::RSpec::Base
  extend ::RuboCop::Cop::AutoCorrector

  def context?(param0); end
  def examples?(param0); end
  def on_block(node); end
  def shared_context(param0 = T.unsafe(nil)); end
  def shared_example(param0 = T.unsafe(nil)); end

  private

  def context_with_only_examples(node); end
  def examples_with_only_context(node); end
end

RuboCop::Cop::RSpec::SharedContext::MSG_CONTEXT = T.let(T.unsafe(nil), String)
RuboCop::Cop::RSpec::SharedContext::MSG_EXAMPLES = T.let(T.unsafe(nil), String)

# Enforces use of string to titleize shared examples.
#
# @example
#   # bad
#   it_behaves_like :foo_bar_baz
#   it_should_behave_like :foo_bar_baz
#   shared_examples :foo_bar_baz
#   shared_examples_for :foo_bar_baz
#   include_examples :foo_bar_baz
#
#   # good
#   it_behaves_like 'foo bar baz'
#   it_should_behave_like 'foo bar baz'
#   shared_examples 'foo bar baz'
#   shared_examples_for 'foo bar baz'
#   include_examples 'foo bar baz'
class RuboCop::Cop::RSpec::SharedExamples < ::RuboCop::Cop::RSpec::Base
  extend ::RuboCop::Cop::AutoCorrector

  def on_send(node); end
  def shared_examples(param0 = T.unsafe(nil)); end
end

class RuboCop::Cop::RSpec::SharedExamples::Checker
  # @return [Checker] a new instance of Checker
  def initialize(node); end

  def message; end

  # Returns the value of attribute node.
  def node; end

  def preferred_style; end

  private

  def symbol; end
  def wrap_with_single_quotes(string); end
end

RuboCop::Cop::RSpec::SharedExamples::Checker::MSG = T.let(T.unsafe(nil), String)

# Checks that chains of messages contain more than one element.
#
# @example
#   # bad
#   allow(foo).to receive_message_chain(:bar).and_return(42)
#
#   # good
#   allow(foo).to receive(:bar).and_return(42)
#
#   # also good
#   allow(foo).to receive(:bar, :baz)
#   allow(foo).to receive("bar.baz")
class RuboCop::Cop::RSpec::SingleArgumentMessageChain < ::RuboCop::Cop::RSpec::Base
  extend ::RuboCop::Cop::AutoCorrector

  def message_chain(param0 = T.unsafe(nil)); end
  def on_send(node); end
  def single_key_hash?(param0 = T.unsafe(nil)); end

  private

  def autocorrect(corrector, node, method, arg); end
  def autocorrect_array_arg(corrector, arg); end
  def autocorrect_hash_arg(corrector, arg); end
  def key_to_arg(node); end
  def replacement(method); end

  # @return [Boolean]
  def single_element_array?(node); end

  # @return [Boolean]
  def valid_usage?(node); end
end

RuboCop::Cop::RSpec::SingleArgumentMessageChain::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::RSpec::SingleArgumentMessageChain::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Checks that message expectations do not have a configured response.
#
# @example
#
#   # bad
#   expect(foo).to receive(:bar).with(42).and_return("hello world")
#
#   # good (without spies)
#   allow(foo).to receive(:bar).with(42).and_return("hello world")
#   expect(foo).to receive(:bar).with(42)
class RuboCop::Cop::RSpec::StubbedMock < ::RuboCop::Cop::RSpec::Base
  def configured_response?(param0 = T.unsafe(nil)); end

  # Match expectation
  #
  # @example source that matches
  #   is_expected.to be_in_the_bar
  # @example source that matches
  #   expect(cocktail).to contain_exactly(:fresh_orange_juice, :campari)
  # @example source that matches
  #   expect_any_instance_of(Officer).to be_alert
  # @param node [RuboCop::AST::Node]
  # @yield [RuboCop::AST::Node] expectation, method name, matcher
  def expectation(param0 = T.unsafe(nil)); end

  # Match matcher with a configured response in block-pass
  #
  # @example source that matches
  #   receive(:foo, &canned)
  # @example source that matches
  #   receive_message_chain(:foo, :bar, &canned)
  # @example source that matches
  #   receive(:foo).with('bar', &canned)
  # @param node [RuboCop::AST::Node]
  # @yield [RuboCop::AST::Node] matcher
  def matcher_with_blockpass(param0 = T.unsafe(nil)); end

  # Match matcher with a configured response
  #
  # @example source that matches
  #   receive(:foo).and_return('bar')
  # @example source that matches
  #   receive(:lower).and_raise(SomeError)
  # @example source that matches
  #   receive(:redirect).and_call_original
  # @param node [RuboCop::AST::Node]
  # @yield [RuboCop::AST::Node] matcher
  def matcher_with_configured_response(param0 = T.unsafe(nil)); end

  # Match matcher with a configured response defined as a hash
  #
  # @example source that matches
  #   receive_messages(foo: 'bar', baz: 'qux')
  # @example source that matches
  #   receive_message_chain(:foo, bar: 'baz')
  # @param node [RuboCop::AST::Node]
  # @yield [RuboCop::AST::Node] matcher
  def matcher_with_hash(param0 = T.unsafe(nil)); end

  # Match matcher with a return block
  #
  # @example source that matches
  #   receive(:foo) { 'bar' }
  # @param node [RuboCop::AST::Node]
  # @yield [RuboCop::AST::Node] matcher
  def matcher_with_return_block(param0 = T.unsafe(nil)); end

  # Match message expectation matcher
  #
  # @example source that matches
  #   receive(:foo)
  # @example source that matches
  #   receive_message_chain(:foo, :bar)
  # @example source that matches
  #   receive(:foo).with('bar')
  # @param node [RuboCop::AST::Node]
  # @return [Array<RuboCop::AST::Node>] matching nodes
  def message_expectation?(param0 = T.unsafe(nil)); end

  def on_send(node); end

  private

  def msg(method_name); end
  def on_expectation(expectation, method_name, matcher); end
  def replacement(method_name); end
end

RuboCop::Cop::RSpec::StubbedMock::MSG = T.let(T.unsafe(nil), String)

# Ensure that subject is defined using subject helper.
#
# @example
#
#   # bad
#   let(:subject) { foo }
#   let!(:subject) { foo }
#   subject(:subject) { foo }
#   subject!(:subject) { foo }
#
#   # bad
#   block = -> {}
#   let(:subject, &block)
#
#   # good
#   subject(:test_subject) { foo }
class RuboCop::Cop::RSpec::SubjectDeclaration < ::RuboCop::Cop::RSpec::Base
  def offensive_subject_declaration?(param0 = T.unsafe(nil)); end
  def on_send(node); end

  private

  def message_for(offense); end
end

RuboCop::Cop::RSpec::SubjectDeclaration::MSG_LET = T.let(T.unsafe(nil), String)
RuboCop::Cop::RSpec::SubjectDeclaration::MSG_REDUNDANT = T.let(T.unsafe(nil), String)

# Checks for stubbed test subjects.
#
# Checks nested subject stubs for innermost subject definition
# when subject is also defined in parent example groups.
#
# @example
#   # bad
#   describe Article do
#   subject(:article) { Article.new }
#
#   it 'indicates that the author is unknown' do
#   allow(article).to receive(:author).and_return(nil)
#   expect(article.description).to include('by an unknown author')
#   end
#   end
#
#   # bad
#   describe Article do
#   subject(:foo) { Article.new }
#
#   context 'nested subject' do
#   subject(:article) { Article.new }
#
#   it 'indicates that the author is unknown' do
#   allow(article).to receive(:author).and_return(nil)
#   expect(article.description).to include('by an unknown author')
#   end
#   end
#   end
#
#   # good
#   describe Article do
#   subject(:article) { Article.new(author: nil) }
#
#   it 'indicates that the author is unknown' do
#   expect(article.description).to include('by an unknown author')
#   end
#   end
# @see https://robots.thoughtbot.com/don-t-stub-the-system-under-test
# @see https://samphippen.com/introducing-rspec-smells-and-where-to-find-them#smell-1-stubject
# @see https://github.com/rubocop-hq/rspec-style-guide#dont-stub-subject
class RuboCop::Cop::RSpec::SubjectStub < ::RuboCop::Cop::RSpec::Base
  include ::RuboCop::Cop::RSpec::TopLevelGroup

  # Find a memoized helper
  def let?(param0 = T.unsafe(nil)); end

  # Match `allow` and `expect(...).to receive`
  #
  # @example source that matches
  #   allow(foo).to  receive(:bar)
  #   allow(foo).to  receive(:bar).with(1)
  #   allow(foo).to  receive(:bar).with(1).and_return(2)
  #   expect(foo).to receive(:bar)
  #   expect(foo).to receive(:bar).with(1)
  #   expect(foo).to receive(:bar).with(1).and_return(2)
  def message_expectation?(param0 = T.unsafe(nil), param1); end

  def message_expectation_matcher?(param0); end
  def on_top_level_group(node); end

  # Find a named or unnamed subject definition
  #
  # @example anonymous subject
  #   subject?(parse('subject { foo }').ast) do |name|
  #   name # => :subject
  #   end
  # @example named subject
  #   subject?(parse('subject(:thing) { foo }').ast) do |name|
  #   name # => :thing
  #   end
  # @param node [RuboCop::AST::Node]
  # @yield [Symbol] subject name
  def subject?(param0 = T.unsafe(nil)); end

  private

  def find_all_explicit(node); end
  def find_subject_expectations(node, subject_names = T.unsafe(nil), &block); end
end

RuboCop::Cop::RSpec::SubjectStub::MSG = T.let(T.unsafe(nil), String)

# Helper methods for top level example group cops
module RuboCop::Cop::RSpec::TopLevelGroup
  extend ::RuboCop::AST::NodePattern::Macros

  def on_new_investigation; end
  def top_level_groups; end

  private

  # Dummy methods to be overridden in the consumer
  def on_top_level_example_group(_node); end

  def on_top_level_group(_node); end
  def root_node; end

  # @return [Boolean]
  def top_level_group?(node); end

  def top_level_nodes(node); end
end

# Checks for a specified error in checking raised errors.
#
# Enforces one of an Exception type, a string, or a regular
# expression to match against the exception message as a parameter
# to `raise_error`
#
# @example
#
#   # bad
#   expect {
#   raise StandardError.new('error')
#   }.to raise_error
#
#   # good
#   expect {
#   raise StandardError.new('error')
#   }.to raise_error(StandardError)
#
#   expect {
#   raise StandardError.new('error')
#   }.to raise_error('error')
#
#   expect {
#   raise StandardError.new('error')
#   }.to raise_error(/err/)
#
#   expect { do_something }.not_to raise_error
class RuboCop::Cop::RSpec::UnspecifiedException < ::RuboCop::Cop::RSpec::Base
  # @return [Boolean]
  def block_with_args?(node); end

  # @return [Boolean]
  def empty_exception_matcher?(node); end

  def empty_raise_error_or_exception(param0 = T.unsafe(nil)); end
  def on_send(node); end
end

RuboCop::Cop::RSpec::UnspecifiedException::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::RSpec::UnspecifiedException::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Helps check offenses with variable definitions
module RuboCop::Cop::RSpec::Variable
  extend ::RuboCop::AST::NodePattern::Macros

  def variable_definition?(param0 = T.unsafe(nil)); end
end

RuboCop::Cop::RSpec::Variable::Helpers = RuboCop::RSpec::Language::Helpers
RuboCop::Cop::RSpec::Variable::Subjects = RuboCop::RSpec::Language::Subjects

# Checks that memoized helpers names are symbols or strings.
#
# @example EnforcedStyle: symbols (default)
#   # bad
#   subject('user') { create_user }
#   let('user_name') { 'Adam' }
#
#   # good
#   subject(:user) { create_user }
#   let(:user_name) { 'Adam' }
# @example EnforcedStyle: strings
#   # bad
#   subject(:user) { create_user }
#   let(:user_name) { 'Adam' }
#
#   # good
#   subject('user') { create_user }
#   let('user_name') { 'Adam' }
class RuboCop::Cop::RSpec::VariableDefinition < ::RuboCop::Cop::RSpec::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RSpec::Variable
  extend ::RuboCop::Cop::AutoCorrector

  def on_send(node); end

  private

  def correct_variable(variable); end

  # @return [Boolean]
  def string?(node); end

  # @return [Boolean]
  def style_violation?(variable); end

  # @return [Boolean]
  def symbol?(node); end
end

RuboCop::Cop::RSpec::VariableDefinition::MSG = T.let(T.unsafe(nil), String)

# Checks that memoized helper names use the configured style.
#
# Variables can be excluded from checking using the `IgnoredPatterns`
# option.
#
# @example EnforcedStyle: snake_case (default)
#   # bad
#   subject(:userName1) { 'Adam' }
#   let(:userName2) { 'Adam' }
#
#   # good
#   subject(:user_name_1) { 'Adam' }
#   let(:user_name_2) { 'Adam' }
# @example EnforcedStyle: camelCase
#   # bad
#   subject(:user_name_1) { 'Adam' }
#   let(:user_name_2) { 'Adam' }
#
#   # good
#   subject(:userName1) { 'Adam' }
#   let(:userName2) { 'Adam' }
# @example IgnoredPatterns configuration
#
#   # rubocop.yml
#   # RSpec/VariableName:
#   #   EnforcedStyle: snake_case
#   #   IgnoredPatterns:
#   #     - ^userFood
# @example
#   # okay because it matches the `^userFood` regex in `IgnoredPatterns`
#   subject(:userFood_1) { 'spaghetti' }
#   let(:userFood_2) { 'fettuccine' }
class RuboCop::Cop::RSpec::VariableName < ::RuboCop::Cop::RSpec::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::ConfigurableFormatting
  include ::RuboCop::Cop::ConfigurableNaming
  include ::RuboCop::Cop::AllowedPattern
  include ::RuboCop::Cop::RSpec::Variable

  def on_send(node); end

  private

  def message(style); end
end

RuboCop::Cop::RSpec::VariableName::MSG = T.let(T.unsafe(nil), String)

# Checks for consistent verified double reference style.
#
# Only investigates references that are one of the supported styles.
#
# This cop can be configured in your configuration using the
# `EnforcedStyle` option and supports `--auto-gen-config`.
#
# @example `EnforcedStyle: constant` (default)
#   # bad
#   let(:foo) do
#   instance_double('ClassName', method_name: 'returned_value')
#   end
#
#   # good
#   let(:foo) do
#   instance_double(ClassName, method_name: 'returned_value')
#   end
# @example `EnforcedStyle: string`
#   # bad
#   let(:foo) do
#   instance_double(ClassName, method_name: 'returned_value')
#   end
#
#   # good
#   let(:foo) do
#   instance_double('ClassName', method_name: 'returned_value')
#   end
# @example Reference is not in the supported style list. No enforcement
#
#   # good
#   let(:foo) do
#   instance_double(@klass, method_name: 'returned_value')
#   end
# @see https://relishapp.com/rspec/rspec-mocks/docs/verifying-doubles
class RuboCop::Cop::RSpec::VerifiedDoubleReference < ::RuboCop::Cop::RSpec::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  extend ::RuboCop::Cop::AutoCorrector

  def on_send(node); end
  def verified_double(param0 = T.unsafe(nil)); end

  private

  def correct_style(violation); end

  # @return [Boolean]
  def opposing_style?(class_reference); end
end

RuboCop::Cop::RSpec::VerifiedDoubleReference::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::RSpec::VerifiedDoubleReference::REFERENCE_TYPE_STYLES = T.let(T.unsafe(nil), Hash)
RuboCop::Cop::RSpec::VerifiedDoubleReference::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Set)

# Prefer using verifying doubles over normal doubles.
#
# @example
#   # bad
#   let(:foo) do
#   double(method_name: 'returned value')
#   end
#
#   # bad
#   let(:foo) do
#   double("ClassName", method_name: 'returned value')
#   end
#
#   # good
#   let(:foo) do
#   instance_double("ClassName", method_name: 'returned value')
#   end
# @see https://relishapp.com/rspec/rspec-mocks/docs/verifying-doubles
class RuboCop::Cop::RSpec::VerifiedDoubles < ::RuboCop::Cop::RSpec::Base
  def on_send(node); end
  def unverified_double(param0 = T.unsafe(nil)); end

  private

  # @return [Boolean]
  def symbol?(name); end
end

RuboCop::Cop::RSpec::VerifiedDoubles::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::RSpec::VerifiedDoubles::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# This cop checks void `expect()`.
#
# @example
#   # bad
#   expect(something)
#
#   # good
#   expect(something).to be(1)
class RuboCop::Cop::RSpec::VoidExpect < ::RuboCop::Cop::RSpec::Base
  def expect?(param0 = T.unsafe(nil)); end
  def expect_block?(param0 = T.unsafe(nil)); end
  def on_block(node); end
  def on_send(node); end

  private

  def check_expect(node); end

  # @return [Boolean]
  def void?(expect); end
end

RuboCop::Cop::RSpec::VoidExpect::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::RSpec::VoidExpect::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# This cop checks for calling a block within a stub.
#
# @example
#   # bad
#   allow(foo).to receive(:bar) { |&block| block.call(1) }
#
#   # good
#   expect(foo).to receive(:bar).and_yield(1)
class RuboCop::Cop::RSpec::Yield < ::RuboCop::Cop::RSpec::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  def block_arg(param0 = T.unsafe(nil)); end
  def block_call?(param0 = T.unsafe(nil), param1); end
  def method_on_stub?(param0); end
  def on_block(node); end

  private

  def autocorrect(corrector, node, range); end
  def block_range(node); end

  # @return [Boolean]
  def calling_block?(node, block); end

  def convert_block_to_yield(node); end
  def generate_replacement(node); end
end

RuboCop::Cop::RSpec::Yield::MSG = T.let(T.unsafe(nil), String)
RuboCop::NodePattern = RuboCop::AST::NodePattern
RuboCop::ProcessedSource = RuboCop::AST::ProcessedSource
module RuboCop::RSpec; end

# Shared behavior for aligning braces for single line lets
class RuboCop::RSpec::AlignLetBrace
  include ::RuboCop::RSpec::Language
  include ::RuboCop::PathUtil
  include ::RuboCop::Cop::Util

  # @return [AlignLetBrace] a new instance of AlignLetBrace
  def initialize(root, token); end

  def indent_for(node); end
  def offending_tokens; end

  private

  def adjacent_let_chunks; end
  def let_group_for(let); end
  def let_token(node); end

  # Returns the value of attribute root.
  def root; end

  def single_line_lets; end
  def target_column_for(let); end

  # Returns the value of attribute token.
  def token; end
end

# Wrapper for RSpec DSL methods
class RuboCop::RSpec::Concept
  include ::RuboCop::RSpec::Language
  extend ::RuboCop::AST::NodePattern::Macros
  extend ::RuboCop::RSpec::Language::NodePattern

  # @return [Concept] a new instance of Concept
  def initialize(node); end

  # @return [Boolean]
  def ==(other); end

  # @return [Boolean]
  def eql?(other); end

  def hash; end
  def to_node; end

  protected

  # Returns the value of attribute node.
  def node; end
end

module RuboCop::RSpec::Corrector; end

# Helper methods to move a node
class RuboCop::RSpec::Corrector::MoveNode
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::RSpec::FinalEndLocation
  include ::RuboCop::Cop::RSpec::CommentsHelp

  # @return [MoveNode] a new instance of MoveNode
  def initialize(node, corrector, processed_source); end

  # Returns the value of attribute corrector.
  def corrector; end

  def move_after(other); end
  def move_before(other); end

  # Returns the value of attribute original.
  def original; end

  # Returns the value of attribute processed_source.
  def processed_source; end

  private

  def node_range(node); end
  def node_range_with_surrounding_space(node); end
  def source(node); end
end

# Wrapper for RSpec examples
class RuboCop::RSpec::Example < ::RuboCop::RSpec::Concept
  def definition; end
  def doc_string; end
  def extract_doc_string(param0 = T.unsafe(nil)); end
  def extract_implementation(param0 = T.unsafe(nil)); end
  def extract_metadata(param0 = T.unsafe(nil)); end
  def implementation; end
  def metadata; end
end

# Wrapper for RSpec example groups
class RuboCop::RSpec::ExampleGroup < ::RuboCop::RSpec::Concept
  def examples; end
  def hooks; end
  def lets; end

  # Detect if the node is an example group or shared example
  #
  # Selectors which indicate that we should stop searching
  def scope_change?(param0 = T.unsafe(nil)); end

  def subjects; end

  private

  def find_all(node, predicate); end

  # Recursively search for predicate within the current scope
  #
  # Searches node and halts when a scope change is detected
  #
  # @param node [RuboCop::AST::Node] node to recursively search
  # @param predicate [Symbol] method to call with node as argument
  # @return [Array<RuboCop::AST::Node>] discovered nodes
  def find_all_in_scope(node, predicate); end
end

# RuboCop FactoryBot project namespace
module RuboCop::RSpec::FactoryBot
  class << self
    def attribute_defining_methods; end
    def reserved_methods; end
  end
end

RuboCop::RSpec::FactoryBot::ATTRIBUTE_DEFINING_METHODS = T.let(T.unsafe(nil), Array)
RuboCop::RSpec::FactoryBot::DEFINITION_PROXY_METHODS = T.let(T.unsafe(nil), Array)

# Contains node matchers for common FactoryBot DSL.
module RuboCop::RSpec::FactoryBot::Language
  extend ::RuboCop::AST::NodePattern::Macros

  def factory_bot?(param0 = T.unsafe(nil)); end
end

RuboCop::RSpec::FactoryBot::RESERVED_METHODS = T.let(T.unsafe(nil), Array)
RuboCop::RSpec::FactoryBot::UNPROXIED_METHODS = T.let(T.unsafe(nil), Array)

# Wrapper for RSpec hook
class RuboCop::RSpec::Hook < ::RuboCop::RSpec::Concept
  # @return [Boolean]
  def example?; end

  def extract_metadata(param0 = T.unsafe(nil)); end

  # @return [Boolean]
  def knowable_scope?; end

  def metadata; end
  def name; end
  def scope; end

  private

  def scope_argument; end
  def scope_name; end
  def transform_metadata(meta); end
  def transform_true(node); end

  # @return [Boolean]
  def valid_scope?(node); end
end

# Because RuboCop doesn't yet support plugins, we have to monkey patch in a
# bit of our configuration.
module RuboCop::RSpec::Inject
  class << self
    def defaults!; end
  end
end

# Contains node matchers for common RSpec DSL.
#
# RSpec allows for configuring aliases for commonly used DSL elements, e.g.
# example groups and hooks. It is possible to configure RuboCop RSpec to
# be able to properly detect these elements in the `RSpec/Language` section
# of the RuboCop YAML configuration file.
#
# In addition to providing useful matchers, this class is responsible for
# using the configured aliases.
module RuboCop::RSpec::Language
  extend ::RuboCop::AST::NodePattern::Macros
  extend ::RuboCop::RSpec::Language::NodePattern

  def example?(param0 = T.unsafe(nil)); end
  def example_group?(param0 = T.unsafe(nil)); end
  def example_group_with_body?(param0 = T.unsafe(nil)); end
  def hook?(param0 = T.unsafe(nil)); end
  def include?(param0 = T.unsafe(nil)); end
  def let?(param0 = T.unsafe(nil)); end
  def rspec?(param0 = T.unsafe(nil)); end
  def shared_group?(param0 = T.unsafe(nil)); end
  def spec_group?(param0 = T.unsafe(nil)); end
  def subject?(param0 = T.unsafe(nil)); end

  class << self
    # Returns the value of attribute config.
    def config; end

    # Sets the attribute config
    #
    # @param value the value to set the attribute config to.
    def config=(_arg0); end
  end
end

# This is used in Dialect and DescribeClass cops to detect RSpec blocks.
module RuboCop::RSpec::Language::ALL
  class << self
    def all(element); end
  end
end

module RuboCop::RSpec::Language::ExampleGroups
  class << self
    def all(element); end
    def focused(element); end
    def regular(element); end
    def skipped(element); end
  end
end

module RuboCop::RSpec::Language::Examples
  class << self
    def all(element); end
    def focused(element); end
    def pending(element); end
    def regular(element); end
    def skipped(element); end
  end
end

module RuboCop::RSpec::Language::Expectations
  class << self
    def all(element); end
  end
end

module RuboCop::RSpec::Language::Helpers
  class << self
    def all(element); end
  end
end

module RuboCop::RSpec::Language::HookScopes
  class << self
    def all(element); end
  end
end

module RuboCop::RSpec::Language::Hooks
  class << self
    def all(element); end
  end
end

module RuboCop::RSpec::Language::Includes
  class << self
    def all(element); end
    def context(element); end
    def examples(element); end
  end
end

# Helper methods to detect RSpec DSL used with send and block
module RuboCop::RSpec::Language::NodePattern
  def block_pattern(string); end
  def send_pattern(string); end
end

module RuboCop::RSpec::Language::Runners
  class << self
    def all(element); end
  end
end

module RuboCop::RSpec::Language::SharedGroups
  class << self
    def all(element); end
    def context(element); end
    def examples(element); end
  end
end

module RuboCop::RSpec::Language::Subjects
  class << self
    def all(element); end
  end
end

# RuboCop RSpec specific extensions of RuboCop::AST::Node
module RuboCop::RSpec::Node
  # In various cops we want to regard const as literal althought it's not
  # strictly literal.
  #
  # @return [Boolean]
  def recursive_literal_or_const?; end
end

# Version information for the RSpec RuboCop plugin.
module RuboCop::RSpec::Version; end

RuboCop::RSpec::Version::STRING = T.let(T.unsafe(nil), String)

# RSpec example wording rewriter
class RuboCop::RSpec::Wording
  # @return [Wording] a new instance of Wording
  def initialize(text, ignore:, replace:); end

  def rewrite; end

  private

  def append_suffix(word, suffix); end

  # @return [Boolean]
  def ignored_word?(word); end

  # Returns the value of attribute ignores.
  def ignores; end

  def remove_should_and_pluralize; end
  def replace_prefix(pattern, replacement); end

  # Returns the value of attribute replacements.
  def replacements; end

  def substitute(word); end

  # Returns the value of attribute text.
  def text; end

  # @return [Boolean]
  def uppercase?(word); end
end

RuboCop::RSpec::Wording::ES_SUFFIX_PATTERN = T.let(T.unsafe(nil), Regexp)
RuboCop::RSpec::Wording::IES_SUFFIX_PATTERN = T.let(T.unsafe(nil), Regexp)
RuboCop::RSpec::Wording::SHOULDNT_BE_PREFIX = T.let(T.unsafe(nil), Regexp)
RuboCop::RSpec::Wording::SHOULDNT_PREFIX = T.let(T.unsafe(nil), Regexp)
RuboCop::Token = RuboCop::AST::Token
