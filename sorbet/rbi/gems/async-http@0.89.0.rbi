# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `async-http` gem.
# Please instead update this file by running `bin/tapioca gem async-http`.


# source://async-http//lib/async/http/protocol/configurable.rb#6
module Async; end

# source://async-http//lib/async/http/protocol/configurable.rb#7
module Async::HTTP; end

# source://async-http//lib/async/http/body/writable.rb#11
module Async::HTTP::Body; end

# source://async-http//lib/async/http/body/pipe.rb#12
class Async::HTTP::Body::Pipe
  # If the input stream is closed first, it's likely the output stream will also be closed.
  #
  # @return [Pipe] a new instance of Pipe
  #
  # source://async-http//lib/async/http/body/pipe.rb#14
  def initialize(input, output = T.unsafe(nil), task: T.unsafe(nil)); end

  # source://async-http//lib/async/http/body/pipe.rb#34
  def close; end

  # source://async-http//lib/async/http/body/pipe.rb#30
  def to_io; end

  private

  # source://async-http//lib/async/http/body/pipe.rb#81
  def close_head; end

  # Read from the @input stream and write to the head of the pipe.
  #
  # source://async-http//lib/async/http/body/pipe.rb#44
  def reader(task); end

  # Read from the head of the pipe and write to the @output stream.
  # If the @tail is closed, this will cause chunk to be nil, which in turn will call `@output.close` and `@head.close`
  #
  # source://async-http//lib/async/http/body/pipe.rb#65
  def writer(task); end
end

# source://async-http//lib/async/http/body/writable.rb#12
Async::HTTP::Body::Writable = Protocol::HTTP::Body::Writable

# source://async-http//lib/async/http/client.rb#22
class Async::HTTP::Client < ::Protocol::HTTP::Methods
  include ::Async::HTTP::Proxy::Client

  # Provides a robust interface to a server.
  # * If there are no connections, it will create one.
  # * If there are already connections, it will reuse it.
  # * If a request fails, it will retry it up to N times if it was idempotent.
  # The client object will never become unusable. It internally manages persistent connections (or non-persistent connections if that's required).
  #
  # @param endpoint [Endpoint] the endpoint to connnect to.
  # @param protocol [Protocol::HTTP1 | Protocol::HTTP2 | Protocol::HTTPS] the protocol to use.
  # @param scheme [String] The default scheme to set to requests.
  # @param authority [String] The default authority to set to requests.
  # @return [Client] a new instance of Client
  #
  # source://async-http//lib/async/http/client.rb#32
  def initialize(endpoint, protocol: T.unsafe(nil), scheme: T.unsafe(nil), authority: T.unsafe(nil), retries: T.unsafe(nil), **options); end

  # source://async-http//lib/async/http/client.rb#43
  def as_json(*_arg0, **_arg1, &_arg2); end

  # Returns the value of attribute authority.
  #
  # source://async-http//lib/async/http/client.rb#64
  def authority; end

  # source://async-http//lib/async/http/client.rb#91
  def call(request); end

  # source://async-http//lib/async/http/client.rb#82
  def close; end

  # Returns the value of attribute endpoint.
  #
  # source://async-http//lib/async/http/client.rb#57
  def endpoint; end

  # source://async-http//lib/async/http/client.rb#139
  def inspect; end

  # Returns the value of attribute pool.
  #
  # source://async-http//lib/async/http/client.rb#61
  def pool; end

  # Returns the value of attribute protocol.
  #
  # source://async-http//lib/async/http/client.rb#58
  def protocol; end

  # Returns the value of attribute retries.
  #
  # source://async-http//lib/async/http/client.rb#60
  def retries; end

  # Returns the value of attribute scheme.
  #
  # source://async-http//lib/async/http/client.rb#63
  def scheme; end

  # @return [Boolean]
  #
  # source://async-http//lib/async/http/client.rb#66
  def secure?; end

  # source://async-http//lib/async/http/client.rb#53
  def to_json(*_arg0, **_arg1, &_arg2); end

  protected

  # source://async-http//lib/async/http/client.rb#153
  def assign_default_tags(tags); end

  # source://async-http//lib/async/http/client.rb#158
  def make_pool(**options); end

  # source://async-http//lib/async/http/client.rb#145
  def make_response(request, connection, attempt); end

  class << self
    # source://async-http//lib/async/http/client.rb#70
    def open(*arguments, **options, &block); end
  end
end

# source://async-http//lib/async/http/client.rb#20
Async::HTTP::DEFAULT_RETRIES = T.let(T.unsafe(nil), Integer)

# Represents a way to connect to a remote HTTP server.
#
# source://async-http//lib/async/http/endpoint.rb#25
class Async::HTTP::Endpoint < ::IO::Endpoint::Generic
  # @option hostname
  # @option scheme
  # @option port
  # @option ssl_context
  # @option alpn_protocols
  # @param hostname [Hash] a customizable set of options
  # @param scheme [Hash] a customizable set of options
  # @param port [Hash] a customizable set of options
  # @param ssl_context [Hash] a customizable set of options
  # @param alpn_protocols [Hash] a customizable set of options
  # @raise [ArgumentError]
  # @return [Endpoint] a new instance of Endpoint
  #
  # source://async-http//lib/async/http/endpoint.rb#71
  def initialize(url, endpoint = T.unsafe(nil), **options); end

  # source://async-http//lib/async/http/endpoint.rb#105
  def address; end

  # source://async-http//lib/async/http/endpoint.rb#163
  def alpn_protocols; end

  # source://async-http//lib/async/http/endpoint.rb#144
  def authority(ignore_default_port = T.unsafe(nil)); end

  # source://async-http//lib/async/http/endpoint.rb#215
  def bind(*arguments, &block); end

  # source://async-http//lib/async/http/endpoint.rb#192
  def build_endpoint(endpoint = T.unsafe(nil)); end

  # source://async-http//lib/async/http/endpoint.rb#219
  def connect(&block); end

  # source://async-http//lib/async/http/endpoint.rb#123
  def default_port; end

  # @return [Boolean]
  #
  # source://async-http//lib/async/http/endpoint.rb#127
  def default_port?; end

  # source://async-http//lib/async/http/endpoint.rb#223
  def each; end

  # source://async-http//lib/async/http/endpoint.rb#207
  def endpoint; end

  # source://async-http//lib/async/http/endpoint.rb#211
  def endpoint=(endpoint); end

  # @return [Boolean]
  #
  # source://async-http//lib/async/http/endpoint.rb#235
  def eql?(other); end

  # source://async-http//lib/async/http/endpoint.rb#239
  def hash; end

  # The hostname is the server we are connecting to:
  #
  # source://async-http//lib/async/http/endpoint.rb#136
  def hostname; end

  # source://async-http//lib/async/http/endpoint.rb#99
  def inspect; end

  # source://async-http//lib/async/http/endpoint.rb#231
  def key; end

  # @return [Boolean]
  #
  # source://async-http//lib/async/http/endpoint.rb#167
  def localhost?; end

  # Return the path and query components of the given URL.
  #
  # source://async-http//lib/async/http/endpoint.rb#153
  def path; end

  # source://async-http//lib/async/http/endpoint.rb#131
  def port; end

  # source://async-http//lib/async/http/endpoint.rb#113
  def protocol; end

  # source://async-http//lib/async/http/endpoint.rb#140
  def scheme; end

  # @return [Boolean]
  #
  # source://async-http//lib/async/http/endpoint.rb#109
  def secure?; end

  # source://async-http//lib/async/http/endpoint.rb#180
  def ssl_context; end

  # We don't try to validate peer certificates when talking to localhost because they would always be self-signed.
  #
  # source://async-http//lib/async/http/endpoint.rb#172
  def ssl_verify_mode; end

  # source://async-http//lib/async/http/endpoint.rb#95
  def to_s; end

  # source://async-http//lib/async/http/endpoint.rb#85
  def to_url; end

  # Returns the value of attribute url.
  #
  # source://async-http//lib/async/http/endpoint.rb#103
  def url; end

  protected

  # source://async-http//lib/async/http/endpoint.rb#258
  def tcp_endpoint; end

  # source://async-http//lib/async/http/endpoint.rb#245
  def tcp_options; end

  class << self
    # Coerce the given object into an endpoint.
    #
    # source://async-http//lib/async/http/endpoint.rb#58
    def [](url); end

    # Construct an endpoint with a specified scheme, hostname, optional path, and options.
    #
    # source://async-http//lib/async/http/endpoint.rb#44
    def for(scheme, hostname, path = T.unsafe(nil), **options); end

    # source://async-http//lib/async/http/endpoint.rb#33
    def parse(string, endpoint = T.unsafe(nil), **options); end
  end
end

# source://async-http//lib/async/http/endpoint.rb#26
Async::HTTP::Endpoint::SCHEMES = T.let(T.unsafe(nil), Hash)

# A protocol specifies a way in which to communicate with a remote peer.
#
# source://async-http//lib/async/http/protocol/configurable.rb#8
module Async::HTTP::Protocol; end

# source://async-http//lib/async/http/protocol/configurable.rb#36
module Async::HTTP::Protocol::Configurable
  # source://async-http//lib/async/http/protocol/configurable.rb#37
  def new(**options); end
end

# source://async-http//lib/async/http/protocol/configurable.rb#9
class Async::HTTP::Protocol::Configured
  # @return [Configured] a new instance of Configured
  #
  # source://async-http//lib/async/http/protocol/configurable.rb#10
  def initialize(protocol, **options); end

  # source://async-http//lib/async/http/protocol/configurable.rb#21
  def client(peer, **options); end

  # source://async-http//lib/async/http/protocol/configurable.rb#31
  def names; end

  # Returns the value of attribute options.
  #
  # source://async-http//lib/async/http/protocol/configurable.rb#19
  def options; end

  # Returns the value of attribute protocol.
  #
  # source://async-http//lib/async/http/protocol/configurable.rb#16
  def protocol; end

  # source://async-http//lib/async/http/protocol/configurable.rb#26
  def server(peer, **options); end
end

# This module provides a default instance of the protocol, which can be used to create clients and servers. The name is a play on "Default" + "Singleton".
#
# source://async-http//lib/async/http/protocol/defaulton.rb#10
module Async::HTTP::Protocol::Defaulton
  # Create a client for an outbound connection, using the default instance.
  #
  # source://async-http//lib/async/http/protocol/defaulton.rb#18
  def client(peer, **options); end

  # Returns the value of attribute default.
  #
  # source://async-http//lib/async/http/protocol/defaulton.rb#15
  def default; end

  # Sets the attribute default
  #
  # @param value the value to set the attribute default to.
  #
  # source://async-http//lib/async/http/protocol/defaulton.rb#15
  def default=(_arg0); end

  # source://async-http//lib/async/http/protocol/defaulton.rb#28
  def names; end

  # Create a server for an inbound connection, using the default instance.
  #
  # source://async-http//lib/async/http/protocol/defaulton.rb#23
  def server(peer, **options); end

  class << self
    # @private
    #
    # source://async-http//lib/async/http/protocol/defaulton.rb#11
    def extended(base); end
  end
end

# HTTP is an http:// server that auto-selects HTTP/1.1 or HTTP/2 by detecting the HTTP/2 connection preface.
#
# source://async-http//lib/async/http/protocol/http.rb#16
class Async::HTTP::Protocol::HTTP
  extend ::Async::HTTP::Protocol::Defaulton

  # Create a new HTTP protocol instance.
  #
  # @return [HTTP] a new instance of HTTP
  #
  # source://async-http//lib/async/http/protocol/http.rb#24
  def initialize(http1: T.unsafe(nil), http2: T.unsafe(nil)); end

  # Create a client for an outbound connection. Defaults to HTTP/1 for plaintext connections.
  #
  # source://async-http//lib/async/http/protocol/http.rb#56
  def client(peer, **options); end

  # Determine if the inbound connection is HTTP/1 or HTTP/2.
  #
  # source://async-http//lib/async/http/protocol/http.rb#33
  def protocol_for(stream); end

  # Create a server for an inbound connection. Able to detect HTTP1 and HTTP2.
  #
  # source://async-http//lib/async/http/protocol/http.rb#66
  def server(peer, **options); end
end

# source://async-http//lib/async/http/protocol/http1/request.rb#11
module Async::HTTP::Protocol::HTTP1
  extend ::Async::HTTP::Protocol::Configurable

  class << self
    # @return [Boolean]
    #
    # source://async-http//lib/async/http/protocol/http1.rb#23
    def bidirectional?; end

    # Create a client for an outbound connection.
    #
    # source://async-http//lib/async/http/protocol/http1.rb#36
    def client(peer, **options); end

    # source://async-http//lib/async/http/protocol/http1.rb#53
    def names; end

    # Create a server for an inbound connection.
    #
    # source://async-http//lib/async/http/protocol/http1.rb#46
    def server(peer, **options); end

    # @return [Boolean]
    #
    # source://async-http//lib/async/http/protocol/http1.rb#28
    def trailer?; end
  end
end

# source://async-http//lib/async/http/protocol/http10.rb#12
module Async::HTTP::Protocol::HTTP10
  extend ::Async::HTTP::Protocol::Configurable

  class << self
    # @return [Boolean]
    #
    # source://async-http//lib/async/http/protocol/http10.rb#18
    def bidirectional?; end

    # Create a client for an outbound connection.
    #
    # source://async-http//lib/async/http/protocol/http10.rb#31
    def client(peer, **options); end

    # source://async-http//lib/async/http/protocol/http10.rb#48
    def names; end

    # Create a server for an inbound connection.
    #
    # source://async-http//lib/async/http/protocol/http10.rb#41
    def server(peer, **options); end

    # @return [Boolean]
    #
    # source://async-http//lib/async/http/protocol/http10.rb#23
    def trailer?; end
  end
end

# source://async-http//lib/async/http/protocol/http10.rb#15
Async::HTTP::Protocol::HTTP10::VERSION = T.let(T.unsafe(nil), String)

# source://async-http//lib/async/http/protocol/http11.rb#13
module Async::HTTP::Protocol::HTTP11
  extend ::Async::HTTP::Protocol::Configurable

  class << self
    # @return [Boolean]
    #
    # source://async-http//lib/async/http/protocol/http11.rb#19
    def bidirectional?; end

    # Create a client for an outbound connection.
    #
    # source://async-http//lib/async/http/protocol/http11.rb#32
    def client(peer, **options); end

    # source://async-http//lib/async/http/protocol/http11.rb#49
    def names; end

    # Create a server for an inbound connection.
    #
    # source://async-http//lib/async/http/protocol/http11.rb#42
    def server(peer, **options); end

    # @return [Boolean]
    #
    # source://async-http//lib/async/http/protocol/http11.rb#24
    def trailer?; end
  end
end

# source://async-http//lib/async/http/protocol/http11.rb#16
Async::HTTP::Protocol::HTTP11::VERSION = T.let(T.unsafe(nil), String)

# source://async-http//lib/async/http/protocol/http1/client.rb#14
class Async::HTTP::Protocol::HTTP1::Client < ::Async::HTTP::Protocol::HTTP1::Connection
  # @return [Client] a new instance of Client
  #
  # source://async-http//lib/async/http/protocol/http1/client.rb#15
  def initialize(*_arg0, **_arg1, &_arg2); end

  # Used by the client to send requests to the remote server.
  #
  # source://async-http//lib/async/http/protocol/http1/client.rb#34
  def call(request, task: T.unsafe(nil)); end

  # source://async-http//lib/async/http/protocol/http1/client.rb#23
  def closed(error = T.unsafe(nil)); end

  # Returns the value of attribute pool.
  #
  # source://async-http//lib/async/http/protocol/http1/client.rb#21
  def pool; end

  # Sets the attribute pool
  #
  # @param value the value to set the attribute pool to.
  #
  # source://async-http//lib/async/http/protocol/http1/client.rb#21
  def pool=(_arg0); end
end

# source://async-http//lib/async/http/protocol/http1/connection.rb#16
class Async::HTTP::Protocol::HTTP1::Connection < ::Protocol::HTTP1::Connection
  # @return [Connection] a new instance of Connection
  #
  # source://async-http//lib/async/http/protocol/http1/connection.rb#17
  def initialize(stream, version, **options); end

  # source://async-http//lib/async/http/protocol/http1/connection.rb#28
  def as_json(*_arg0, **_arg1, &_arg2); end

  # source://async-http//lib/async/http/protocol/http1/connection.rb#52
  def concurrency; end

  # Returns the value of attribute count.
  #
  # source://async-http//lib/async/http/protocol/http1/connection.rb#50
  def count; end

  # @return [Boolean]
  #
  # source://async-http//lib/async/http/protocol/http1/connection.rb#38
  def http1?; end

  # @return [Boolean]
  #
  # source://async-http//lib/async/http/protocol/http1/connection.rb#42
  def http2?; end

  # source://async-http//lib/async/http/protocol/http1/connection.rb#46
  def peer; end

  # @return [Boolean]
  #
  # source://async-http//lib/async/http/protocol/http1/connection.rb#61
  def reusable?; end

  # source://async-http//lib/async/http/protocol/http1/connection.rb#32
  def to_json(*_arg0, **_arg1, &_arg2); end

  # source://async-http//lib/async/http/protocol/http1/connection.rb#24
  def to_s; end

  # Returns the value of attribute version.
  #
  # source://async-http//lib/async/http/protocol/http1/connection.rb#36
  def version; end

  # Can we use this connection to make requests?
  #
  # @return [Boolean]
  #
  # source://async-http//lib/async/http/protocol/http1/connection.rb#57
  def viable?; end
end

# Keeps track of whether a body is being read, and if so, waits for it to be closed.
#
# source://async-http//lib/async/http/protocol/http1/finishable.rb#14
class Async::HTTP::Protocol::HTTP1::Finishable < ::Protocol::HTTP::Body::Wrapper
  # @return [Finishable] a new instance of Finishable
  #
  # source://async-http//lib/async/http/protocol/http1/finishable.rb#15
  def initialize(body); end

  # source://async-http//lib/async/http/protocol/http1/finishable.rb#34
  def close(error = T.unsafe(nil)); end

  # source://async-http//lib/async/http/protocol/http1/finishable.rb#55
  def inspect; end

  # source://async-http//lib/async/http/protocol/http1/finishable.rb#28
  def read; end

  # @return [Boolean]
  #
  # source://async-http//lib/async/http/protocol/http1/finishable.rb#24
  def reading?; end

  # source://async-http//lib/async/http/protocol/http1/finishable.rb#43
  def wait(persistent = T.unsafe(nil)); end
end

# source://async-http//lib/async/http/protocol/http1/request.rb#12
class Async::HTTP::Protocol::HTTP1::Request < ::Async::HTTP::Protocol::Request
  # @return [Request] a new instance of Request
  #
  # source://async-http//lib/async/http/protocol/http1/request.rb#45
  def initialize(connection, scheme, authority, method, path, version, headers, body); end

  # source://async-http//lib/async/http/protocol/http1/request.rb#54
  def connection; end

  # source://async-http//lib/async/http/protocol/http1/request.rb#62
  def hijack!; end

  # @return [Boolean]
  #
  # source://async-http//lib/async/http/protocol/http1/request.rb#58
  def hijack?; end

  # source://async-http//lib/async/http/protocol/http1/request.rb#66
  def write_interim_response(status, headers = T.unsafe(nil)); end

  class << self
    # source://async-http//lib/async/http/protocol/http1/request.rb#25
    def read(connection); end

    # @return [Boolean]
    #
    # source://async-http//lib/async/http/protocol/http1/request.rb#13
    def valid_path?(target); end
  end
end

# source://async-http//lib/async/http/protocol/http1/request.rb#43
Async::HTTP::Protocol::HTTP1::Request::UPGRADE = T.let(T.unsafe(nil), String)

# source://async-http//lib/async/http/protocol/http1/request.rb#23
Async::HTTP::Protocol::HTTP1::Request::URI_PATTERN = T.let(T.unsafe(nil), Regexp)

# source://async-http//lib/async/http/protocol/http1/response.rb#13
class Async::HTTP::Protocol::HTTP1::Response < ::Async::HTTP::Protocol::Response
  # @return [Response] a new instance of Response
  #
  # source://async-http//lib/async/http/protocol/http1/response.rb#32
  def initialize(connection, version, status, reason, headers, body); end

  # source://async-http//lib/async/http/protocol/http1/response.rb#50
  def connection; end

  # source://async-http//lib/async/http/protocol/http1/response.rb#58
  def hijack!; end

  # @return [Boolean]
  #
  # source://async-http//lib/async/http/protocol/http1/response.rb#54
  def hijack?; end

  # source://async-http//lib/async/http/protocol/http1/response.rb#42
  def pool=(pool); end

  # Returns the value of attribute reason.
  #
  # source://async-http//lib/async/http/protocol/http1/response.rb#29
  def reason; end

  class << self
    # source://async-http//lib/async/http/protocol/http1/response.rb#14
    def read(connection, request); end
  end
end

# source://async-http//lib/async/http/protocol/http1/response.rb#26
Async::HTTP::Protocol::HTTP1::Response::UPGRADE = T.let(T.unsafe(nil), String)

# source://async-http//lib/async/http/protocol/http1/server.rb#19
class Async::HTTP::Protocol::HTTP1::Server < ::Async::HTTP::Protocol::HTTP1::Connection
  # @return [Server] a new instance of Server
  #
  # source://async-http//lib/async/http/protocol/http1/server.rb#20
  def initialize(*_arg0, **_arg1, &_arg2); end

  # source://async-http//lib/async/http/protocol/http1/server.rb#26
  def closed(error = T.unsafe(nil)); end

  # Server loop.
  #
  # source://async-http//lib/async/http/protocol/http1/server.rb#63
  def each(task: T.unsafe(nil)); end

  # source://async-http//lib/async/http/protocol/http1/server.rb#32
  def fail_request(status); end

  # source://async-http//lib/async/http/protocol/http1/server.rb#41
  def next_request; end
end

# source://async-http//lib/async/http/protocol/http1.rb#20
Async::HTTP::Protocol::HTTP1::VERSION = T.let(T.unsafe(nil), String)

# source://async-http//lib/async/http/protocol/http2/input.rb#11
module Async::HTTP::Protocol::HTTP2
  extend ::Async::HTTP::Protocol::Configurable

  class << self
    # @return [Boolean]
    #
    # source://async-http//lib/async/http/protocol/http2.rb#23
    def bidirectional?; end

    # Create a client for an outbound connection.
    #
    # source://async-http//lib/async/http/protocol/http2.rb#54
    def client(peer, settings: T.unsafe(nil)); end

    # source://async-http//lib/async/http/protocol/http2.rb#79
    def names; end

    # Create a server for an inbound connection.
    #
    # source://async-http//lib/async/http/protocol/http2.rb#68
    def server(peer, settings: T.unsafe(nil)); end

    # @return [Boolean]
    #
    # source://async-http//lib/async/http/protocol/http2.rb#28
    def trailer?; end
  end
end

# source://async-http//lib/async/http/protocol/http2/connection.rb#21
Async::HTTP::Protocol::HTTP2::AUTHORITY = T.let(T.unsafe(nil), String)

# The default settings for the client.
#
# source://async-http//lib/async/http/protocol/http2.rb#33
Async::HTTP::Protocol::HTTP2::CLIENT_SETTINGS = T.let(T.unsafe(nil), Hash)

# source://async-http//lib/async/http/protocol/http2/connection.rb#26
Async::HTTP::Protocol::HTTP2::CONNECTION = T.let(T.unsafe(nil), String)

# source://async-http//lib/async/http/protocol/http2/connection.rb#25
Async::HTTP::Protocol::HTTP2::CONTENT_LENGTH = T.let(T.unsafe(nil), String)

# source://async-http//lib/async/http/protocol/http2/client.rb#16
class Async::HTTP::Protocol::HTTP2::Client < ::Protocol::HTTP2::Client
  include ::Async::HTTP::Protocol::HTTP2::Connection

  # @return [Client] a new instance of Client
  #
  # source://async-http//lib/async/http/protocol/http2/client.rb#19
  def initialize(stream); end

  # Used by the client to send requests to the remote server.
  #
  # @raise [::Protocol::HTTP2::Error]
  #
  # source://async-http//lib/async/http/protocol/http2/client.rb#32
  def call(request); end

  # source://async-http//lib/async/http/protocol/http2/client.rb#27
  def create_response; end

  # source://async-http//lib/async/http/protocol/http2/client.rb#46
  def read_response(response); end

  # source://async-http//lib/async/http/protocol/http2/client.rb#42
  def write_request(response, request); end
end

# source://async-http//lib/async/http/protocol/http2/connection.rb#29
module Async::HTTP::Protocol::HTTP2::Connection
  # source://async-http//lib/async/http/protocol/http2/connection.rb#30
  def initialize(*_arg0, **_arg1, &_arg2); end

  # source://async-http//lib/async/http/protocol/http2/connection.rb#47
  def as_json(*_arg0, **_arg1, &_arg2); end

  # source://async-http//lib/async/http/protocol/http2/connection.rb#69
  def close(error = T.unsafe(nil)); end

  # source://async-http//lib/async/http/protocol/http2/connection.rb#121
  def concurrency; end

  # Returns the value of attribute count.
  #
  # source://async-http//lib/async/http/protocol/http2/connection.rb#119
  def count; end

  # @return [Boolean]
  #
  # source://async-http//lib/async/http/protocol/http2/connection.rb#57
  def http1?; end

  # @return [Boolean]
  #
  # source://async-http//lib/async/http/protocol/http2/connection.rb#61
  def http2?; end

  # source://async-http//lib/async/http/protocol/http2/connection.rb#115
  def peer; end

  # Returns the value of attribute promises.
  #
  # source://async-http//lib/async/http/protocol/http2/connection.rb#113
  def promises; end

  # @raise [RuntimeError]
  #
  # source://async-http//lib/async/http/protocol/http2/connection.rb#80
  def read_in_background(parent: T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://async-http//lib/async/http/protocol/http2/connection.rb#130
  def reusable?; end

  # source://async-http//lib/async/http/protocol/http2/connection.rb#65
  def start_connection; end

  # Returns the value of attribute stream.
  #
  # source://async-http//lib/async/http/protocol/http2/connection.rb#55
  def stream; end

  # source://async-http//lib/async/http/protocol/http2/connection.rb#39
  def synchronize(&block); end

  # source://async-http//lib/async/http/protocol/http2/connection.rb#51
  def to_json(*_arg0, **_arg1, &_arg2); end

  # source://async-http//lib/async/http/protocol/http2/connection.rb#43
  def to_s; end

  # source://async-http//lib/async/http/protocol/http2/connection.rb#134
  def version; end

  # Can we use this connection to make requests?
  #
  # @return [Boolean]
  #
  # source://async-http//lib/async/http/protocol/http2/connection.rb#126
  def viable?; end
end

# source://async-http//lib/async/http/protocol/http2/connection.rb#17
Async::HTTP::Protocol::HTTP2::HTTPS = T.let(T.unsafe(nil), String)

# A writable body which requests window updates when data is read from it.
#
# source://async-http//lib/async/http/protocol/http2/input.rb#13
class Async::HTTP::Protocol::HTTP2::Input < ::Protocol::HTTP::Body::Writable
  # @return [Input] a new instance of Input
  #
  # source://async-http//lib/async/http/protocol/http2/input.rb#14
  def initialize(stream, length); end

  # source://async-http//lib/async/http/protocol/http2/input.rb#21
  def read; end
end

# source://async-http//lib/async/http/protocol/http2/connection.rb#19
Async::HTTP::Protocol::HTTP2::METHOD = T.let(T.unsafe(nil), String)

# source://async-http//lib/async/http/protocol/http2/output.rb#12
class Async::HTTP::Protocol::HTTP2::Output
  # @return [Output] a new instance of Output
  #
  # source://async-http//lib/async/http/protocol/http2/output.rb#13
  def initialize(stream, body, trailer = T.unsafe(nil)); end

  # This method should only be called from within the context of the output task.
  #
  # source://async-http//lib/async/http/protocol/http2/output.rb#73
  def close(error = T.unsafe(nil)); end

  # source://async-http//lib/async/http/protocol/http2/output.rb#65
  def close_write(error = T.unsafe(nil)); end

  # source://async-http//lib/async/http/protocol/http2/output.rb#26
  def start(parent: T.unsafe(nil)); end

  # This method should only be called from within the context of the HTTP/2 stream.
  #
  # source://async-http//lib/async/http/protocol/http2/output.rb#79
  def stop(error); end

  # Returns the value of attribute trailer.
  #
  # source://async-http//lib/async/http/protocol/http2/output.rb#24
  def trailer; end

  # source://async-http//lib/async/http/protocol/http2/output.rb#36
  def window_updated(size); end

  # source://async-http//lib/async/http/protocol/http2/output.rb#44
  def write(chunk); end

  private

  # Reads chunks from the given body and writes them to the stream as fast as possible.
  #
  # source://async-http//lib/async/http/protocol/http2/output.rb#101
  def passthrough(task); end

  # Send `maximum_size` bytes of data using the specified `stream`. If the buffer has no more chunks, `END_STREAM` will be sent on the final chunk.
  #
  # @param maximum_size [Integer] send up to this many bytes of data.
  # @param stream [Stream] the stream to use for sending data frames.
  # @return [String, nil] any data that could not be written.
  #
  # source://async-http//lib/async/http/protocol/http2/output.rb#127
  def send_data(chunk, maximum_size); end

  # source://async-http//lib/async/http/protocol/http2/output.rb#88
  def stream(task); end
end

# source://async-http//lib/async/http/protocol/http2/connection.rb#20
Async::HTTP::Protocol::HTTP2::PATH = T.let(T.unsafe(nil), String)

# source://async-http//lib/async/http/protocol/http2/connection.rb#23
Async::HTTP::Protocol::HTTP2::PROTOCOL = T.let(T.unsafe(nil), String)

# Typically used on the server side to represent an incoming request, and write the response.
#
# source://async-http//lib/async/http/protocol/http2/request.rb#14
class Async::HTTP::Protocol::HTTP2::Request < ::Async::HTTP::Protocol::Request
  # @return [Request] a new instance of Request
  #
  # source://async-http//lib/async/http/protocol/http2/request.rb#89
  def initialize(stream); end

  # source://async-http//lib/async/http/protocol/http2/request.rb#97
  def connection; end

  # @return [Boolean]
  #
  # source://async-http//lib/async/http/protocol/http2/request.rb#105
  def hijack?; end

  # source://async-http//lib/async/http/protocol/http2/request.rb#113
  def send_response(response); end

  # Returns the value of attribute stream.
  #
  # source://async-http//lib/async/http/protocol/http2/request.rb#95
  def stream; end

  # @return [Boolean]
  #
  # source://async-http//lib/async/http/protocol/http2/request.rb#101
  def valid?; end

  # source://async-http//lib/async/http/protocol/http2/request.rb#143
  def write_interim_response(status, headers = T.unsafe(nil)); end
end

# source://async-http//lib/async/http/protocol/http2/request.rb#109
Async::HTTP::Protocol::HTTP2::Request::NO_RESPONSE = T.let(T.unsafe(nil), Array)

# source://async-http//lib/async/http/protocol/http2/request.rb#15
class Async::HTTP::Protocol::HTTP2::Request::Stream < ::Async::HTTP::Protocol::HTTP2::Stream
  # @return [Stream] a new instance of Stream
  #
  # source://async-http//lib/async/http/protocol/http2/request.rb#16
  def initialize(*_arg0); end

  # source://async-http//lib/async/http/protocol/http2/request.rb#82
  def closed(error); end

  # source://async-http//lib/async/http/protocol/http2/request.rb#25
  def receive_initial_headers(headers, end_stream); end

  # Returns the value of attribute request.
  #
  # source://async-http//lib/async/http/protocol/http2/request.rb#23
  def request; end
end

# Typically used on the client side for writing a request and reading the incoming response.
#
# source://async-http//lib/async/http/protocol/http2/response.rb#14
class Async::HTTP::Protocol::HTTP2::Response < ::Async::HTTP::Protocol::Response
  # @return [Response] a new instance of Response
  #
  # source://async-http//lib/async/http/protocol/http2/response.rb#130
  def initialize(stream); end

  # source://async-http//lib/async/http/protocol/http2/response.rb#166
  def build_request(headers); end

  # source://async-http//lib/async/http/protocol/http2/response.rb#150
  def connection; end

  # @return [Boolean]
  #
  # source://async-http//lib/async/http/protocol/http2/response.rb#158
  def head?; end

  # source://async-http//lib/async/http/protocol/http2/response.rb#140
  def pool=(pool); end

  # Returns the value of attribute request.
  #
  # source://async-http//lib/async/http/protocol/http2/response.rb#138
  def request; end

  # Send a request and read it into this response.
  #
  # source://async-http//lib/async/http/protocol/http2/response.rb#199
  def send_request(request); end

  # Returns the value of attribute stream.
  #
  # source://async-http//lib/async/http/protocol/http2/response.rb#137
  def stream; end

  # @return [Boolean]
  #
  # source://async-http//lib/async/http/protocol/http2/response.rb#162
  def valid?; end

  # source://async-http//lib/async/http/protocol/http2/response.rb#154
  def wait; end
end

# source://async-http//lib/async/http/protocol/http2/response.rb#15
class Async::HTTP::Protocol::HTTP2::Response::Stream < ::Async::HTTP::Protocol::HTTP2::Stream
  # @return [Stream] a new instance of Stream
  #
  # source://async-http//lib/async/http/protocol/http2/response.rb#16
  def initialize(*_arg0); end

  # @raise [ProtocolError]
  #
  # source://async-http//lib/async/http/protocol/http2/response.rb#35
  def accept_push_promise_stream(promised_stream_id, headers); end

  # source://async-http//lib/async/http/protocol/http2/response.rb#117
  def closed(error); end

  # Notify anyone waiting on the response headers to be received (or failure).
  #
  # source://async-http//lib/async/http/protocol/http2/response.rb#100
  def notify!; end

  # This should be invoked from the background reader, and notifies the task waiting for the headers that we are done.
  #
  # source://async-http//lib/async/http/protocol/http2/response.rb#40
  def receive_initial_headers(headers, end_stream); end

  # source://async-http//lib/async/http/protocol/http2/response.rb#89
  def receive_interim_headers(status, headers); end

  # Returns the value of attribute response.
  #
  # source://async-http//lib/async/http/protocol/http2/response.rb#25
  def response; end

  # Wait for the headers to be received or for stream reset.
  #
  # source://async-http//lib/async/http/protocol/http2/response.rb#108
  def wait; end

  # source://async-http//lib/async/http/protocol/http2/response.rb#27
  def wait_for_input; end
end

# source://async-http//lib/async/http/protocol/http2/connection.rb#18
Async::HTTP::Protocol::HTTP2::SCHEME = T.let(T.unsafe(nil), String)

# The default settings for the server.
#
# source://async-http//lib/async/http/protocol/http2.rb#41
Async::HTTP::Protocol::HTTP2::SERVER_SETTINGS = T.let(T.unsafe(nil), Hash)

# source://async-http//lib/async/http/protocol/http2/connection.rb#22
Async::HTTP::Protocol::HTTP2::STATUS = T.let(T.unsafe(nil), String)

# source://async-http//lib/async/http/protocol/http2/server.rb#15
class Async::HTTP::Protocol::HTTP2::Server < ::Protocol::HTTP2::Server
  include ::Async::HTTP::Protocol::HTTP2::Connection

  # @return [Server] a new instance of Server
  #
  # source://async-http//lib/async/http/protocol/http2/server.rb#18
  def initialize(stream); end

  # source://async-http//lib/async/http/protocol/http2/server.rb#31
  def accept_stream(stream_id); end

  # source://async-http//lib/async/http/protocol/http2/server.rb#37
  def close(error = T.unsafe(nil)); end

  # source://async-http//lib/async/http/protocol/http2/server.rb#47
  def each(task: T.unsafe(nil)); end

  # Returns the value of attribute requests.
  #
  # source://async-http//lib/async/http/protocol/http2/server.rb#29
  def requests; end
end

# source://async-http//lib/async/http/protocol/http2/stream.rb#17
class Async::HTTP::Protocol::HTTP2::Stream < ::Protocol::HTTP2::Stream
  # @return [Stream] a new instance of Stream
  #
  # source://async-http//lib/async/http/protocol/http2/stream.rb#18
  def initialize(*_arg0); end

  # source://async-http//lib/async/http/protocol/http2/stream.rb#39
  def add_header(key, value); end

  # When the stream transitions to the closed state, this method is called. There are roughly two ways this can happen:
  # - A frame is received which causes this stream to enter the closed state. This method will be invoked from the background reader task.
  # - A frame is sent which causes this stream to enter the closed state. This method will be invoked from that task.
  # While the input stream is relatively straight forward, the output stream can trigger the second case above
  #
  # source://async-http//lib/async/http/protocol/http2/stream.rb#153
  def closed(error); end

  # Called when the output terminates normally.
  #
  # source://async-http//lib/async/http/protocol/http2/stream.rb#122
  def finish_output(error = T.unsafe(nil)); end

  # Returns the value of attribute headers.
  #
  # source://async-http//lib/async/http/protocol/http2/stream.rb#33
  def headers; end

  # Sets the attribute headers
  #
  # @param value the value to set the attribute headers to.
  #
  # source://async-http//lib/async/http/protocol/http2/stream.rb#33
  def headers=(_arg0); end

  # Returns the value of attribute input.
  #
  # source://async-http//lib/async/http/protocol/http2/stream.rb#37
  def input; end

  # Returns the value of attribute pool.
  #
  # source://async-http//lib/async/http/protocol/http2/stream.rb#35
  def pool; end

  # Sets the attribute pool
  #
  # @param value the value to set the attribute pool to.
  #
  # source://async-http//lib/async/http/protocol/http2/stream.rb#35
  def pool=(_arg0); end

  # Prepare the input stream which will be used for incoming data frames.
  #
  # @return [Input] the input body.
  #
  # source://async-http//lib/async/http/protocol/http2/stream.rb#79
  def prepare_input(length); end

  # source://async-http//lib/async/http/protocol/http2/stream.rb#94
  def process_data(frame); end

  # source://async-http//lib/async/http/protocol/http2/stream.rb#57
  def process_headers(frame); end

  # source://async-http//lib/async/http/protocol/http2/stream.rb#51
  def receive_trailing_headers(headers, end_stream); end

  # Set the body and begin sending it.
  #
  # source://async-http//lib/async/http/protocol/http2/stream.rb#115
  def send_body(body, trailer = T.unsafe(nil)); end

  # source://async-http//lib/async/http/protocol/http2/stream.rb#87
  def update_local_window(frame); end

  # source://async-http//lib/async/http/protocol/http2/stream.rb#73
  def wait_for_input; end

  # source://async-http//lib/async/http/protocol/http2/stream.rb#141
  def window_updated(size); end
end

# source://async-http//lib/async/http/protocol/http2/connection.rb#27
Async::HTTP::Protocol::HTTP2::TRAILER = T.let(T.unsafe(nil), String)

# source://async-http//lib/async/http/protocol/http2.rb#20
Async::HTTP::Protocol::HTTP2::VERSION = T.let(T.unsafe(nil), String)

# source://async-http//lib/async/http/protocol/http.rb#17
Async::HTTP::Protocol::HTTP::HTTP2_PREFACE = T.let(T.unsafe(nil), String)

# source://async-http//lib/async/http/protocol/http.rb#18
Async::HTTP::Protocol::HTTP::HTTP2_PREFACE_SIZE = T.let(T.unsafe(nil), Integer)

# A server that supports both HTTP1.0 and HTTP1.1 semantics by detecting the version of the request.
#
# source://async-http//lib/async/http/protocol/https.rb#17
class Async::HTTP::Protocol::HTTPS
  extend ::Async::HTTP::Protocol::Defaulton

  # @return [HTTPS] a new instance of HTTPS
  #
  # source://async-http//lib/async/http/protocol/https.rb#26
  def initialize(handlers = T.unsafe(nil), **options); end

  # source://async-http//lib/async/http/protocol/https.rb#31
  def add(name, protocol, **options); end

  # Create a client for an outbound connection.
  #
  # source://async-http//lib/async/http/protocol/https.rb#59
  def client(peer, **options); end

  # source://async-http//lib/async/http/protocol/https.rb#78
  def names; end

  # Determine the protocol of the peer and return the appropriate protocol class.
  #
  # Use TLS Application Layer Protocol Negotiation (ALPN) to determine the protocol.
  #
  # source://async-http//lib/async/http/protocol/https.rb#42
  def protocol_for(peer); end

  # Create a server for an inbound connection.
  #
  # source://async-http//lib/async/http/protocol/https.rb#70
  def server(peer, **options); end
end

# The protocol classes for each supported protocol.
#
# source://async-http//lib/async/http/protocol/https.rb#19
Async::HTTP::Protocol::HTTPS::HANDLERS = T.let(T.unsafe(nil), Hash)

# This is generated by server protocols.
#
# source://async-http//lib/async/http/protocol/request.rb#19
class Async::HTTP::Protocol::Request < ::Protocol::HTTP::Request
  # source://async-http//lib/async/http/protocol/request.rb#20
  def connection; end

  # @return [Boolean]
  #
  # source://async-http//lib/async/http/protocol/request.rb#24
  def hijack?; end

  # source://async-http//lib/async/http/protocol/request.rb#39
  def inspect; end

  # source://async-http//lib/async/http/protocol/request.rb#31
  def peer; end

  # source://async-http//lib/async/http/protocol/request.rb#35
  def remote_address; end

  # source://async-http//lib/async/http/protocol/request.rb#28
  def write_interim_response(status, headers = T.unsafe(nil)); end
end

# Failed to send the request. The request body has NOT been consumed (i.e. #read) and you should retry the request.
#
# source://async-http//lib/async/http/protocol/request.rb#15
class Async::HTTP::Protocol::RequestFailed < ::StandardError; end

# This is generated by client protocols.
#
# source://async-http//lib/async/http/protocol/response.rb#14
class Async::HTTP::Protocol::Response < ::Protocol::HTTP::Response
  # source://async-http//lib/async/http/protocol/response.rb#15
  def connection; end

  # @return [Boolean]
  #
  # source://async-http//lib/async/http/protocol/response.rb#19
  def hijack?; end

  # source://async-http//lib/async/http/protocol/response.rb#31
  def inspect; end

  # source://async-http//lib/async/http/protocol/response.rb#23
  def peer; end

  # source://async-http//lib/async/http/protocol/response.rb#27
  def remote_address; end
end

# Wraps a client, address and headers required to initiate a connectio to a remote host using the CONNECT verb.
# Behaves like a TCP endpoint for the purposes of connecting to a remote host.
#
# source://async-http//lib/async/http/proxy.rb#15
class Async::HTTP::Proxy
  # @param client [Async::HTTP::Client] the client which will be used as a proxy server.
  # @param address [String] the address to connect to.
  # @param headers [Array] an optional list of headers to use when establishing the connection.
  # @return [Proxy] a new instance of Proxy
  #
  # source://async-http//lib/async/http/proxy.rb#67
  def initialize(client, address, headers = T.unsafe(nil)); end

  # Returns the value of attribute client.
  #
  # source://async-http//lib/async/http/proxy.rb#73
  def client; end

  # Close the underlying client connection.
  #
  # source://async-http//lib/async/http/proxy.rb#76
  def close; end

  # Establish a TCP connection to the specified host.
  #
  # @return [Socket] a connected bi-directional socket.
  #
  # source://async-http//lib/async/http/proxy.rb#82
  def connect(&block); end

  # @return [Async::HTTP::Endpoint] an endpoint that connects via the specified proxy.
  #
  # source://async-http//lib/async/http/proxy.rb#107
  def wrap_endpoint(endpoint); end

  class << self
    # Construct a endpoint that will use the given client as a proxy for HTTP requests.
    #
    # @param client [Async::HTTP::Client] the client which will be used as a proxy server.
    # @param endpoint [Async::HTTP::Endpoint] the endpoint to connect to.
    # @param headers [Array] an optional list of headers to use when establishing the connection.
    #
    # source://async-http//lib/async/http/proxy.rb#58
    def endpoint(client, endpoint, headers = T.unsafe(nil)); end

    # Prepare and endpoint which can establish a TCP connection to the remote system.
    #
    # @param client [Async::HTTP::Client] the client which will be used as a proxy server.
    # @param host [String] the hostname or address to connect to.
    # @param port [String] the port number to connect to.
    # @param headers [Array] an optional list of headers to use when establishing the connection.
    # @see IO::Endpoint#tcp
    #
    # source://async-http//lib/async/http/proxy.rb#50
    def tcp(client, host, port, headers = T.unsafe(nil)); end
  end
end

# source://async-http//lib/async/http/proxy.rb#25
module Async::HTTP::Proxy::Client
  # Create a client that will proxy requests through the current client.
  #
  # source://async-http//lib/async/http/proxy.rb#31
  def proxied_client(endpoint, headers = T.unsafe(nil)); end

  # source://async-http//lib/async/http/proxy.rb#37
  def proxied_endpoint(endpoint, headers = T.unsafe(nil)); end

  # source://async-http//lib/async/http/proxy.rb#26
  def proxy(endpoint, headers = T.unsafe(nil)); end
end

# source://async-http//lib/async/http/proxy.rb#16
class Async::HTTP::Proxy::ConnectFailure < ::StandardError
  # @return [ConnectFailure] a new instance of ConnectFailure
  #
  # source://async-http//lib/async/http/proxy.rb#17
  def initialize(response); end

  # Returns the value of attribute response.
  #
  # source://async-http//lib/async/http/proxy.rb#22
  def response; end
end
