# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `protocol-http` gem.
# Please instead update this file by running `bin/tapioca gem protocol-http`.

# source://protocol-http//lib/protocol/http/body/readable.rb#6
module Protocol; end

# source://protocol-http//lib/protocol/http/body/readable.rb#7
module Protocol::HTTP; end

# source://protocol-http//lib/protocol/http/body/readable.rb#8
module Protocol::HTTP::Body; end

# A body which buffers all it's contents.
#
# source://protocol-http//lib/protocol/http/body/buffered.rb#13
class Protocol::HTTP::Body::Buffered < ::Protocol::HTTP::Body::Readable
  # @return [Buffered] a new instance of Buffered
  #
  # source://protocol-http//lib/protocol/http/body/buffered.rb#38
  def initialize(chunks = T.unsafe(nil), length = T.unsafe(nil)); end

  # Returns the value of attribute chunks.
  #
  # source://protocol-http//lib/protocol/http/body/buffered.rb#45
  def chunks; end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/body/buffered.rb#55
  def empty?; end

  # source://protocol-http//lib/protocol/http/body/buffered.rb#47
  def finish; end

  # source://protocol-http//lib/protocol/http/body/buffered.rb#80
  def inspect; end

  # source://protocol-http//lib/protocol/http/body/buffered.rb#51
  def length; end

  # source://protocol-http//lib/protocol/http/body/buffered.rb#64
  def read; end

  # A buffered response is always ready.
  #
  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/body/buffered.rb#60
  def ready?; end

  # source://protocol-http//lib/protocol/http/body/buffered.rb#76
  def rewind; end

  # source://protocol-http//lib/protocol/http/body/buffered.rb#72
  def write(chunk); end

  class << self
    # source://protocol-http//lib/protocol/http/body/buffered.rb#28
    def for(body); end

    # Wraps an array into a buffered body.
    #
    # @return [Readable, nil] the wrapped body or nil if nil was given.
    #
    # source://protocol-http//lib/protocol/http/body/buffered.rb#16
    def wrap(body); end
  end
end

# Invokes a callback once the body has completed, either successfully or due to an error.
#
# source://protocol-http//lib/protocol/http/body/completable.rb#12
class Protocol::HTTP::Body::Completable < ::Protocol::HTTP::Body::Wrapper
  # @return [Completable] a new instance of Completable
  #
  # source://protocol-http//lib/protocol/http/body/completable.rb#21
  def initialize(body, callback); end

  # source://protocol-http//lib/protocol/http/body/completable.rb#39
  def close(error = T.unsafe(nil)); end

  # source://protocol-http//lib/protocol/http/body/completable.rb#27
  def finish; end

  class << self
    # source://protocol-http//lib/protocol/http/body/completable.rb#13
    def wrap(message, &block); end
  end
end

# source://protocol-http//lib/protocol/http/body/head.rb#11
class Protocol::HTTP::Body::Head < ::Protocol::HTTP::Body::Readable
  # @return [Head] a new instance of Head
  #
  # source://protocol-http//lib/protocol/http/body/head.rb#20
  def initialize(length); end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/body/head.rb#24
  def empty?; end

  # source://protocol-http//lib/protocol/http/body/head.rb#32
  def length; end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/body/head.rb#28
  def ready?; end

  class << self
    # source://protocol-http//lib/protocol/http/body/head.rb#12
    def for(body); end
  end
end

# def finish -> buffer the stream and close it.
# 	def close(error = nil) -> close the stream immediately.
# end
#
# source://protocol-http//lib/protocol/http/body/readable.rb#18
class Protocol::HTTP::Body::Readable
  # Write the body to the given stream.
  #
  # source://protocol-http//lib/protocol/http/body/readable.rb#53
  def call(stream); end

  # The consumer can call stop to signal that the stream output has terminated.
  #
  # source://protocol-http//lib/protocol/http/body/readable.rb#20
  def close(error = T.unsafe(nil)); end

  # Enumerate all chunks until finished, then invoke `#close`.
  #
  # source://protocol-http//lib/protocol/http/body/readable.rb#68
  def each; end

  # Optimistically determine whether read (may) return any data.
  # If this returns true, then calling read will definitely return nil.
  # If this returns false, then calling read may return nil.
  #
  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/body/readable.rb#26
  def empty?; end

  # Read all remaining chunks into a buffered body and close the underlying input.
  #
  # source://protocol-http//lib/protocol/http/body/readable.rb#62
  def finish; end

  # Read all remaining chunks into a single binary string using `#each`.
  #
  # source://protocol-http//lib/protocol/http/body/readable.rb#77
  def join; end

  # source://protocol-http//lib/protocol/http/body/readable.rb#37
  def length; end

  # Read the next available chunk.
  #
  # source://protocol-http//lib/protocol/http/body/readable.rb#42
  def read; end

  # Whether calling read will return a chunk of data without blocking.
  # We prefer pessimistic implementation, and thus default to `false`.
  #
  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/body/readable.rb#33
  def ready?; end

  # Should the internal mechanism prefer to use {call}?
  #
  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/body/readable.rb#48
  def stream?; end
end

# General operations for interacting with a request or response body.
#
# source://protocol-http//lib/protocol/http/body/reader.rb#11
module Protocol::HTTP::Body::Reader
  # Whether there is a body?
  #
  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/body/reader.rb#63
  def body?; end

  # Close the connection as quickly as possible. Discards body. May close the underlying connection if necessary to terminate the stream.
  #
  # source://protocol-http//lib/protocol/http/body/reader.rb#55
  def close(error = T.unsafe(nil)); end

  # Read chunks from the body.
  #
  # @yield [String] read chunks from the body.
  #
  # source://protocol-http//lib/protocol/http/body/reader.rb#14
  def each(&block); end

  # Gracefully finish reading the body. This will buffer the remainder of the body.
  #
  # @return [Buffered] buffers the entire body.
  #
  # source://protocol-http//lib/protocol/http/body/reader.rb#34
  def finish; end

  # Reads the entire request/response body.
  #
  # @return [String] the entire body as a string.
  #
  # source://protocol-http//lib/protocol/http/body/reader.rb#23
  def read; end

  # Write the body of the response to the given file path.
  #
  # source://protocol-http//lib/protocol/http/body/reader.rb#44
  def save(path, mode = T.unsafe(nil), **options); end
end

# The input stream is an IO-like object which contains the raw HTTP POST data. When applicable, its external encoding must be “ASCII-8BIT” and it must be opened in binary mode, for Ruby 1.9 compatibility. The input stream must respond to gets, each, read and rewind.
#
# source://protocol-http//lib/protocol/http/body/stream.rb#12
class Protocol::HTTP::Body::Stream
  include ::Protocol::HTTP::Body::Stream::Reader

  # @raise [ArgumentError]
  # @return [Stream] a new instance of Stream
  #
  # source://protocol-http//lib/protocol/http/body/stream.rb#13
  def initialize(input = T.unsafe(nil), output = T.unsafe(nil)); end

  # source://protocol-http//lib/protocol/http/body/stream.rb#142
  def <<(buffer); end

  # Close the input and output bodies.
  #
  # source://protocol-http//lib/protocol/http/body/stream.rb#164
  def close(error = T.unsafe(nil)); end

  # source://protocol-http//lib/protocol/http/body/stream.rb#149
  def close_read; end

  # close must never be called on the input stream. huh?
  #
  # source://protocol-http//lib/protocol/http/body/stream.rb#158
  def close_write; end

  # Whether the stream has been closed.
  #
  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/body/stream.rb#174
  def closed?; end

  # Whether there are any output chunks remaining?
  #
  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/body/stream.rb#179
  def empty?; end

  # source://protocol-http//lib/protocol/http/body/stream.rb#146
  def flush; end

  # Returns the value of attribute input.
  #
  # source://protocol-http//lib/protocol/http/body/stream.rb#25
  def input; end

  # Returns the value of attribute output.
  #
  # source://protocol-http//lib/protocol/http/body/stream.rb#26
  def output; end

  # source://protocol-http//lib/protocol/http/body/stream.rb#129
  def write(buffer); end

  # source://protocol-http//lib/protocol/http/body/stream.rb#138
  def write_nonblock(buffer); end

  private

  # source://protocol-http//lib/protocol/http/body/stream.rb#185
  def read_next; end
end

# This provides a read-only interface for data, which is surprisingly tricky to implement correctly.
#
# source://protocol-http//lib/protocol/http/body/stream.rb#29
module Protocol::HTTP::Body::Stream::Reader
  # read behaves like IO#read. Its signature is read([length, [buffer]]). If given, length must be a non-negative Integer (>= 0) or nil, and buffer must be a String and may not be nil. If length is given and not nil, then this method reads at most length bytes from the input stream. If length is not given or nil, then this method reads all data until EOF. When EOF is reached, this method returns nil if length is given and not nil, or “” if length is not given or is nil. If buffer is given, then the read data will be placed into buffer instead of a newly created String object.
  #
  # @param length [Integer] the amount of data to read
  # @param buffer [String] the buffer which will receive the data
  # @return a buffer containing the data
  #
  # source://protocol-http//lib/protocol/http/body/stream.rb#37
  def read(length = T.unsafe(nil), buffer = T.unsafe(nil)); end

  # source://protocol-http//lib/protocol/http/body/stream.rb#100
  def read_nonblock(length, buffer = T.unsafe(nil)); end

  # Read at most `length` bytes from the stream. Will avoid reading from the underlying stream if possible.
  #
  # source://protocol-http//lib/protocol/http/body/stream.rb#79
  def read_partial(length = T.unsafe(nil)); end
end

# Wrapping body instance. Typically you'd override `#read`.
#
# source://protocol-http//lib/protocol/http/body/wrapper.rb#12
class Protocol::HTTP::Body::Wrapper < ::Protocol::HTTP::Body::Readable
  # @return [Wrapper] a new instance of Wrapper
  #
  # source://protocol-http//lib/protocol/http/body/wrapper.rb#19
  def initialize(body); end

  # The wrapped body.
  #
  # source://protocol-http//lib/protocol/http/body/wrapper.rb#24
  def body; end

  # source://protocol-http//lib/protocol/http/body/wrapper.rb#62
  def call(stream); end

  # source://protocol-http//lib/protocol/http/body/wrapper.rb#31
  def close(error = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/body/wrapper.rb#37
  def empty?; end

  # Buffer any remaining body.
  #
  # source://protocol-http//lib/protocol/http/body/wrapper.rb#27
  def finish; end

  # source://protocol-http//lib/protocol/http/body/wrapper.rb#54
  def inspect; end

  # source://protocol-http//lib/protocol/http/body/wrapper.rb#45
  def length; end

  # Read the next available chunk.
  #
  # source://protocol-http//lib/protocol/http/body/wrapper.rb#50
  def read; end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/body/wrapper.rb#41
  def ready?; end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/body/wrapper.rb#58
  def stream?; end

  class << self
    # source://protocol-http//lib/protocol/http/body/wrapper.rb#13
    def wrap(message); end
  end
end

# Represents an individual cookie key-value pair.
#
# source://protocol-http//lib/protocol/http/cookie.rb#12
class Protocol::HTTP::Cookie
  # @return [Cookie] a new instance of Cookie
  #
  # source://protocol-http//lib/protocol/http/cookie.rb#13
  def initialize(name, value, directives); end

  # Returns the value of attribute directives.
  #
  # source://protocol-http//lib/protocol/http/cookie.rb#21
  def directives; end

  # source://protocol-http//lib/protocol/http/cookie.rb#23
  def encoded_name; end

  # source://protocol-http//lib/protocol/http/cookie.rb#27
  def encoded_value; end

  # Returns the value of attribute name.
  #
  # source://protocol-http//lib/protocol/http/cookie.rb#19
  def name; end

  # source://protocol-http//lib/protocol/http/cookie.rb#31
  def to_s; end

  # Returns the value of attribute value.
  #
  # source://protocol-http//lib/protocol/http/cookie.rb#20
  def value; end

  class << self
    # source://protocol-http//lib/protocol/http/cookie.rb#52
    def parse(string); end

    # source://protocol-http//lib/protocol/http/cookie.rb#65
    def parse_directives(strings); end
  end
end

# A generic, HTTP protocol error.
#
# source://protocol-http//lib/protocol/http/error.rb#9
class Protocol::HTTP::Error < ::StandardError; end

# source://protocol-http//lib/protocol/http/header/split.rb#8
module Protocol::HTTP::Header; end

# Used for basic authorization.
#
# ~~~ ruby
# headers.add('authorization', Authorization.basic("my_username", "my_password"))
# ~~~
#
# source://protocol-http//lib/protocol/http/header/authorization.rb#16
class Protocol::HTTP::Header::Authorization < ::String
  # Splits the header and
  #
  # @return [Tuple(String, String)]
  #
  # source://protocol-http//lib/protocol/http/header/authorization.rb#19
  def credentials; end

  class << self
    # source://protocol-http//lib/protocol/http/header/authorization.rb#23
    def basic(username, password); end
  end
end

# source://protocol-http//lib/protocol/http/header/cache_control.rb#11
class Protocol::HTTP::Header::CacheControl < ::Protocol::HTTP::Header::Split
  # @return [CacheControl] a new instance of CacheControl
  #
  # source://protocol-http//lib/protocol/http/header/cache_control.rb#22
  def initialize(value = T.unsafe(nil)); end

  # source://protocol-http//lib/protocol/http/header/cache_control.rb#26
  def <<(value); end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/header/cache_control.rb#34
  def dynamic?; end

  # source://protocol-http//lib/protocol/http/header/cache_control.rb#58
  def max_age; end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/header/cache_control.rb#50
  def no_cache?; end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/header/cache_control.rb#54
  def no_store?; end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/header/cache_control.rb#42
  def private?; end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/header/cache_control.rb#46
  def public?; end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/header/cache_control.rb#30
  def static?; end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/header/cache_control.rb#38
  def streaming?; end
end

# source://protocol-http//lib/protocol/http/header/cache_control.rb#19
Protocol::HTTP::Header::CacheControl::DYNAMIC = T.let(T.unsafe(nil), String)

# source://protocol-http//lib/protocol/http/header/cache_control.rb#16
Protocol::HTTP::Header::CacheControl::MAX_AGE = T.let(T.unsafe(nil), String)

# source://protocol-http//lib/protocol/http/header/cache_control.rb#14
Protocol::HTTP::Header::CacheControl::NO_CACHE = T.let(T.unsafe(nil), String)

# source://protocol-http//lib/protocol/http/header/cache_control.rb#15
Protocol::HTTP::Header::CacheControl::NO_STORE = T.let(T.unsafe(nil), String)

# source://protocol-http//lib/protocol/http/header/cache_control.rb#12
Protocol::HTTP::Header::CacheControl::PRIVATE = T.let(T.unsafe(nil), String)

# source://protocol-http//lib/protocol/http/header/cache_control.rb#13
Protocol::HTTP::Header::CacheControl::PUBLIC = T.let(T.unsafe(nil), String)

# source://protocol-http//lib/protocol/http/header/cache_control.rb#18
Protocol::HTTP::Header::CacheControl::STATIC = T.let(T.unsafe(nil), String)

# source://protocol-http//lib/protocol/http/header/cache_control.rb#20
Protocol::HTTP::Header::CacheControl::STREAMING = T.let(T.unsafe(nil), String)

# source://protocol-http//lib/protocol/http/header/connection.rb#11
class Protocol::HTTP::Header::Connection < ::Protocol::HTTP::Header::Split
  # @return [Connection] a new instance of Connection
  #
  # source://protocol-http//lib/protocol/http/header/connection.rb#16
  def initialize(value = T.unsafe(nil)); end

  # source://protocol-http//lib/protocol/http/header/connection.rb#20
  def <<(value); end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/header/connection.rb#28
  def close?; end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/header/connection.rb#24
  def keep_alive?; end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/header/connection.rb#32
  def upgrade?; end
end

# source://protocol-http//lib/protocol/http/header/connection.rb#13
Protocol::HTTP::Header::Connection::CLOSE = T.let(T.unsafe(nil), String)

# source://protocol-http//lib/protocol/http/header/connection.rb#12
Protocol::HTTP::Header::Connection::KEEP_ALIVE = T.let(T.unsafe(nil), String)

# source://protocol-http//lib/protocol/http/header/connection.rb#14
Protocol::HTTP::Header::Connection::UPGRADE = T.let(T.unsafe(nil), String)

# The Cookie HTTP request header contains stored HTTP cookies previously sent by the server with the Set-Cookie header.
#
# source://protocol-http//lib/protocol/http/header/cookie.rb#13
class Protocol::HTTP::Header::Cookie < ::Protocol::HTTP::Header::Multiple
  # source://protocol-http//lib/protocol/http/header/cookie.rb#14
  def to_h; end
end

# source://protocol-http//lib/protocol/http/header/etag.rb#9
class Protocol::HTTP::Header::ETag < ::String
  # source://protocol-http//lib/protocol/http/header/etag.rb#10
  def <<(value); end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/header/etag.rb#14
  def weak?; end
end

# This implementation is not strictly correct according to the RFC-specified format.
#
# source://protocol-http//lib/protocol/http/header/etags.rb#12
class Protocol::HTTP::Header::ETags < ::Protocol::HTTP::Header::Split
  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/header/etags.rb#17
  def match?(etag); end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/header/etags.rb#13
  def wildcard?; end
end

# Header value which is split by newline charaters (e.g. cookies).
#
# source://protocol-http//lib/protocol/http/header/multiple.rb#10
class Protocol::HTTP::Header::Multiple < ::Array
  # @return [Multiple] a new instance of Multiple
  #
  # source://protocol-http//lib/protocol/http/header/multiple.rb#11
  def initialize(value); end

  # source://protocol-http//lib/protocol/http/header/multiple.rb#17
  def to_s; end
end

# The Set-Cookie HTTP response header sends cookies from the server to the user agent.
#
# source://protocol-http//lib/protocol/http/header/cookie.rb#24
class Protocol::HTTP::Header::SetCookie < ::Protocol::HTTP::Header::Cookie; end

# Header value which is split by commas.
#
# source://protocol-http//lib/protocol/http/header/split.rb#10
class Protocol::HTTP::Header::Split < ::Array
  # @return [Split] a new instance of Split
  #
  # source://protocol-http//lib/protocol/http/header/split.rb#13
  def initialize(value); end

  # source://protocol-http//lib/protocol/http/header/split.rb#21
  def <<(value); end

  # source://protocol-http//lib/protocol/http/header/split.rb#25
  def to_s; end
end

# source://protocol-http//lib/protocol/http/header/split.rb#11
Protocol::HTTP::Header::Split::COMMA = T.let(T.unsafe(nil), Regexp)

# source://protocol-http//lib/protocol/http/header/vary.rb#11
class Protocol::HTTP::Header::Vary < ::Protocol::HTTP::Header::Split
  # @return [Vary] a new instance of Vary
  #
  # source://protocol-http//lib/protocol/http/header/vary.rb#12
  def initialize(value); end

  # source://protocol-http//lib/protocol/http/header/vary.rb#16
  def <<(value); end
end

# Headers are an array of key-value pairs. Some header keys represent multiple values.
#
# source://protocol-http//lib/protocol/http/headers.rb#19
class Protocol::HTTP::Headers
  # @return [Headers] a new instance of Headers
  #
  # source://protocol-http//lib/protocol/http/headers.rb#49
  def initialize(fields = T.unsafe(nil), indexed = T.unsafe(nil)); end

  # source://protocol-http//lib/protocol/http/headers.rb#299
  def ==(other); end

  # source://protocol-http//lib/protocol/http/headers.rb#282
  def [](key); end

  # Append the value to the given key. Some values can be appended multiple times, others can only be set once.
  #
  # @param key [String] The header key.
  # @param value The header value.
  #
  # source://protocol-http//lib/protocol/http/headers.rb#195
  def []=(key, value); end

  # Add the specified header key value pair.
  #
  # @param key [String] the header key.
  # @param value [String] the header value to assign.
  #
  # source://protocol-http//lib/protocol/http/headers.rb#167
  def add(key, value); end

  # source://protocol-http//lib/protocol/http/headers.rb#64
  def clear; end

  # Delete all headers with the given key, and return the merged value.
  #
  # source://protocol-http//lib/protocol/http/headers.rb#245
  def delete(key); end

  # source://protocol-http//lib/protocol/http/headers.rb#135
  def each(&block); end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/headers.rb#131
  def empty?; end

  # source://protocol-http//lib/protocol/http/headers.rb#149
  def extract(keys); end

  # An array of `[key, value]` pairs.
  #
  # source://protocol-http//lib/protocol/http/headers.rb#85
  def fields; end

  # source://protocol-http//lib/protocol/http/headers.rb#80
  def flatten; end

  # Flatten trailer into the headers.
  #
  # source://protocol-http//lib/protocol/http/headers.rb#71
  def flatten!; end

  # source://protocol-http//lib/protocol/http/headers.rb#119
  def freeze; end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/headers.rb#139
  def include?(key); end

  # source://protocol-http//lib/protocol/http/headers.rb#295
  def inspect; end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/headers.rb#139
  def key?(key); end

  # source://protocol-http//lib/protocol/http/headers.rb#145
  def keys; end

  # source://protocol-http//lib/protocol/http/headers.rb#188
  def merge(headers); end

  # source://protocol-http//lib/protocol/http/headers.rb#180
  def merge!(headers); end

  # Set the specified header key to the specified value, replacing any existing header keys with the same name.
  #
  # @param key [String] the header key to replace.
  # @param value [String] the header value to assign.
  #
  # source://protocol-http//lib/protocol/http/headers.rb#174
  def set(key, value); end

  # A hash table of `{key, policy[key].map(values)}`
  #
  # source://protocol-http//lib/protocol/http/headers.rb#287
  def to_h; end

  # Enumerate all headers in the trailer, if there are any.
  #
  # source://protocol-http//lib/protocol/http/headers.rb#111
  def trailer(&block); end

  # Record the current headers, and prepare to add trailers.
  #
  # This method is typically used after headers are sent to capture any
  # additional headers which should then be sent as trailers.
  #
  # A sender that intends to generate one or more trailer fields in a
  # message should generate a trailer header field in the header section of
  # that message to indicate which fields might be present in the trailers.
  #
  # source://protocol-http//lib/protocol/http/headers.rb#104
  def trailer!(&block); end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/headers.rb#88
  def trailer?; end

  protected

  # source://protocol-http//lib/protocol/http/headers.rb#269
  def merge_into(hash, key, value); end

  private

  # source://protocol-http//lib/protocol/http/headers.rb#57
  def initialize_dup(other); end

  class << self
    # Construct an instance from a headers Array or Hash. No-op if already an instance of `Headers`. If the underlying array is frozen, it will be duped.
    #
    # @return [Headers] an instance of headers.
    #
    # source://protocol-http//lib/protocol/http/headers.rb#27
    def [](headers); end
  end
end

# Used for merging objects into a sequential list of headers. Normalizes header keys and values.
#
# source://protocol-http//lib/protocol/http/headers.rb#311
class Protocol::HTTP::Headers::Merged
  include ::Enumerable

  # @return [Merged] a new instance of Merged
  #
  # source://protocol-http//lib/protocol/http/headers.rb#314
  def initialize(*all); end

  # source://protocol-http//lib/protocol/http/headers.rb#330
  def <<(headers); end

  # source://protocol-http//lib/protocol/http/headers.rb#326
  def clear; end

  # source://protocol-http//lib/protocol/http/headers.rb#337
  def each(&block); end

  # source://protocol-http//lib/protocol/http/headers.rb#318
  def fields; end

  # source://protocol-http//lib/protocol/http/headers.rb#322
  def flatten; end
end

# source://protocol-http//lib/protocol/http/headers.rb#21
Protocol::HTTP::Headers::Multiple = Protocol::HTTP::Header::Multiple

# source://protocol-http//lib/protocol/http/headers.rb#203
Protocol::HTTP::Headers::POLICY = T.let(T.unsafe(nil), Hash)

# source://protocol-http//lib/protocol/http/headers.rb#20
Protocol::HTTP::Headers::Split = Protocol::HTTP::Header::Split

# source://protocol-http//lib/protocol/http/headers.rb#23
Protocol::HTTP::Headers::TRAILER = T.let(T.unsafe(nil), String)

# All supported HTTP methods
#
# source://protocol-http//lib/protocol/http/methods.rb#9
class Protocol::HTTP::Methods
  # source://protocol-http//lib/protocol/http/methods.rb#37
  def connect(location, headers = T.unsafe(nil), body = T.unsafe(nil)); end

  # source://protocol-http//lib/protocol/http/methods.rb#37
  def delete(location, headers = T.unsafe(nil), body = T.unsafe(nil)); end

  # source://protocol-http//lib/protocol/http/methods.rb#37
  def get(location, headers = T.unsafe(nil), body = T.unsafe(nil)); end

  # source://protocol-http//lib/protocol/http/methods.rb#37
  def head(location, headers = T.unsafe(nil), body = T.unsafe(nil)); end

  # source://protocol-http//lib/protocol/http/methods.rb#37
  def link(location, headers = T.unsafe(nil), body = T.unsafe(nil)); end

  # source://protocol-http//lib/protocol/http/methods.rb#37
  def options(location, headers = T.unsafe(nil), body = T.unsafe(nil)); end

  # source://protocol-http//lib/protocol/http/methods.rb#37
  def patch(location, headers = T.unsafe(nil), body = T.unsafe(nil)); end

  # source://protocol-http//lib/protocol/http/methods.rb#37
  def post(location, headers = T.unsafe(nil), body = T.unsafe(nil)); end

  # source://protocol-http//lib/protocol/http/methods.rb#37
  def put(location, headers = T.unsafe(nil), body = T.unsafe(nil)); end

  # source://protocol-http//lib/protocol/http/methods.rb#37
  def trace(location, headers = T.unsafe(nil), body = T.unsafe(nil)); end

  # source://protocol-http//lib/protocol/http/methods.rb#37
  def unlink(location, headers = T.unsafe(nil), body = T.unsafe(nil)); end

  class << self
    # source://protocol-http//lib/protocol/http/methods.rb#29
    def each; end

    # @return [Boolean]
    #
    # source://protocol-http//lib/protocol/http/methods.rb#22
    def valid?(name); end
  end
end

# source://protocol-http//lib/protocol/http/methods.rb#20
Protocol::HTTP::Methods::CONNECT = T.let(T.unsafe(nil), String)

# source://protocol-http//lib/protocol/http/methods.rb#14
Protocol::HTTP::Methods::DELETE = T.let(T.unsafe(nil), String)

# source://protocol-http//lib/protocol/http/methods.rb#10
Protocol::HTTP::Methods::GET = T.let(T.unsafe(nil), String)

# source://protocol-http//lib/protocol/http/methods.rb#15
Protocol::HTTP::Methods::HEAD = T.let(T.unsafe(nil), String)

# source://protocol-http//lib/protocol/http/methods.rb#17
Protocol::HTTP::Methods::LINK = T.let(T.unsafe(nil), String)

# source://protocol-http//lib/protocol/http/methods.rb#16
Protocol::HTTP::Methods::OPTIONS = T.let(T.unsafe(nil), String)

# source://protocol-http//lib/protocol/http/methods.rb#13
Protocol::HTTP::Methods::PATCH = T.let(T.unsafe(nil), String)

# source://protocol-http//lib/protocol/http/methods.rb#11
Protocol::HTTP::Methods::POST = T.let(T.unsafe(nil), String)

# source://protocol-http//lib/protocol/http/methods.rb#12
Protocol::HTTP::Methods::PUT = T.let(T.unsafe(nil), String)

# source://protocol-http//lib/protocol/http/methods.rb#19
Protocol::HTTP::Methods::TRACE = T.let(T.unsafe(nil), String)

# source://protocol-http//lib/protocol/http/methods.rb#18
Protocol::HTTP::Methods::UNLINK = T.let(T.unsafe(nil), String)

# source://protocol-http//lib/protocol/http/request.rb#14
class Protocol::HTTP::Request
  include ::Protocol::HTTP::Body::Reader

  # @return [Request] a new instance of Request
  #
  # source://protocol-http//lib/protocol/http/request.rb#17
  def initialize(scheme = T.unsafe(nil), authority = T.unsafe(nil), method = T.unsafe(nil), path = T.unsafe(nil), version = T.unsafe(nil), headers = T.unsafe(nil), body = T.unsafe(nil), protocol = T.unsafe(nil)); end

  # The request authority, usually a hostname and port number.
  #
  # source://protocol-http//lib/protocol/http/request.rb#32
  def authority; end

  # The request authority, usually a hostname and port number.
  #
  # source://protocol-http//lib/protocol/http/request.rb#32
  def authority=(_arg0); end

  # The request body, an instance of Protocol::HTTP::Body::Readable or similar.
  #
  # source://protocol-http//lib/protocol/http/request.rb#47
  def body; end

  # The request body, an instance of Protocol::HTTP::Body::Readable or similar.
  #
  # source://protocol-http//lib/protocol/http/request.rb#47
  def body=(_arg0); end

  # Send the request to the given connection.
  #
  # source://protocol-http//lib/protocol/http/request.rb#53
  def call(connection); end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/request.rb#61
  def connect?; end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/request.rb#57
  def head?; end

  # The request headers, contains metadata associated with the request such as the user agent, accept (content type), accept-language, etc.
  #
  # source://protocol-http//lib/protocol/http/request.rb#44
  def headers; end

  # The request headers, contains metadata associated with the request such as the user agent, accept (content type), accept-language, etc.
  #
  # source://protocol-http//lib/protocol/http/request.rb#44
  def headers=(_arg0); end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/request.rb#72
  def idempotent?; end

  # The request method, usually one of "GET", "HEAD", "POST", "PUT", "DELETE", "CONNECT" or "OPTIONS".
  #
  # source://protocol-http//lib/protocol/http/request.rb#35
  def method; end

  # The request method, usually one of "GET", "HEAD", "POST", "PUT", "DELETE", "CONNECT" or "OPTIONS".
  #
  # source://protocol-http//lib/protocol/http/request.rb#35
  def method=(_arg0); end

  # The request path, usually a path and query string.
  #
  # source://protocol-http//lib/protocol/http/request.rb#38
  def path; end

  # The request path, usually a path and query string.
  #
  # source://protocol-http//lib/protocol/http/request.rb#38
  def path=(_arg0); end

  # The request protocol, usually empty, but occasionally "websocket" or "webtransport", can be either single value `String` or multi-value `Array` of `String` instances. In HTTP/1, it is used to request a connection upgrade, and in HTTP/2 it is used to indicate a specfic protocol for the stream.
  #
  # source://protocol-http//lib/protocol/http/request.rb#50
  def protocol; end

  # The request protocol, usually empty, but occasionally "websocket" or "webtransport", can be either single value `String` or multi-value `Array` of `String` instances. In HTTP/1, it is used to request a connection upgrade, and in HTTP/2 it is used to indicate a specfic protocol for the stream.
  #
  # source://protocol-http//lib/protocol/http/request.rb#50
  def protocol=(_arg0); end

  # The request scheme, usually one of "http" or "https".
  #
  # source://protocol-http//lib/protocol/http/request.rb#29
  def scheme; end

  # The request scheme, usually one of "http" or "https".
  #
  # source://protocol-http//lib/protocol/http/request.rb#29
  def scheme=(_arg0); end

  # source://protocol-http//lib/protocol/http/request.rb#76
  def to_s; end

  # The request version, usually "http/1.0", "http/1.1", "h2", or "h3".
  #
  # source://protocol-http//lib/protocol/http/request.rb#41
  def version; end

  # The request version, usually "http/1.0", "http/1.1", "h2", or "h3".
  #
  # source://protocol-http//lib/protocol/http/request.rb#41
  def version=(_arg0); end

  class << self
    # source://protocol-http//lib/protocol/http/request.rb#65
    def [](method, path, headers = T.unsafe(nil), body = T.unsafe(nil)); end
  end
end

# source://protocol-http//lib/protocol/http/response.rb#11
class Protocol::HTTP::Response
  include ::Protocol::HTTP::Body::Reader

  # @return [Response] a new instance of Response
  #
  # source://protocol-http//lib/protocol/http/response.rb#14
  def initialize(version = T.unsafe(nil), status = T.unsafe(nil), headers = T.unsafe(nil), body = T.unsafe(nil), protocol = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/response.rb#64
  def bad_request?; end

  # Returns the value of attribute body.
  #
  # source://protocol-http//lib/protocol/http/response.rb#25
  def body; end

  # Sets the attribute body
  #
  # @param value the value to set the attribute body to.
  #
  # source://protocol-http//lib/protocol/http/response.rb#25
  def body=(_arg0); end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/response.rb#32
  def continue?; end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/response.rb#60
  def failure?; end

  # Returns the value of attribute headers.
  #
  # source://protocol-http//lib/protocol/http/response.rb#24
  def headers; end

  # Sets the attribute headers
  #
  # @param value the value to set the attribute headers to.
  #
  # source://protocol-http//lib/protocol/http/response.rb#24
  def headers=(_arg0); end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/response.rb#28
  def hijack?; end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/response.rb#68
  def internal_server_error?; end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/response.rb#52
  def not_modified?; end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/response.rb#36
  def ok?; end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/response.rb#44
  def partial?; end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/response.rb#56
  def preserve_method?; end

  # Returns the value of attribute protocol.
  #
  # source://protocol-http//lib/protocol/http/response.rb#26
  def protocol; end

  # Sets the attribute protocol
  #
  # @param value the value to set the attribute protocol to.
  #
  # source://protocol-http//lib/protocol/http/response.rb#26
  def protocol=(_arg0); end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/response.rb#48
  def redirection?; end

  # @deprecated Use {#internal_server_error?} instead.
  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/response.rb#68
  def server_failure?; end

  # Returns the value of attribute status.
  #
  # source://protocol-http//lib/protocol/http/response.rb#23
  def status; end

  # Sets the attribute status
  #
  # @param value the value to set the attribute status to.
  #
  # source://protocol-http//lib/protocol/http/response.rb#23
  def status=(_arg0); end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/response.rb#40
  def success?; end

  # source://protocol-http//lib/protocol/http/response.rb#90
  def to_ary; end

  # source://protocol-http//lib/protocol/http/response.rb#86
  def to_s; end

  # Returns the value of attribute version.
  #
  # source://protocol-http//lib/protocol/http/response.rb#22
  def version; end

  # Sets the attribute version
  #
  # @param value the value to set the attribute version to.
  #
  # source://protocol-http//lib/protocol/http/response.rb#22
  def version=(_arg0); end

  class << self
    # source://protocol-http//lib/protocol/http/response.rb#75
    def [](status, headers = T.unsafe(nil), body = T.unsafe(nil), protocol = T.unsafe(nil)); end

    # source://protocol-http//lib/protocol/http/response.rb#82
    def for_exception(exception); end
  end
end

# source://protocol-http//lib/protocol/http/url.rb#9
module Protocol::HTTP::URL
  class << self
    # source://protocol-http//lib/protocol/http/url.rb#71
    def assign(keys, value, parent); end

    # TODO use native C extension from `Trenni::Reference`.
    #
    # source://protocol-http//lib/protocol/http/url.rb#92
    def decode(string, maximum = T.unsafe(nil), symbolize_keys: T.unsafe(nil)); end

    # Encodes a hash or array into a query string.
    #
    # source://protocol-http//lib/protocol/http/url.rb#36
    def encode(value, prefix = T.unsafe(nil)); end

    # Escapes a string using percent encoding.
    #
    # source://protocol-http//lib/protocol/http/url.rb#11
    def escape(string, encoding = T.unsafe(nil)); end

    # Escapes non-path characters using percent encoding.
    #
    # source://protocol-http//lib/protocol/http/url.rb#28
    def escape_path(path); end

    # Scan a string for URL-encoded key/value pairs.
    #
    # source://protocol-http//lib/protocol/http/url.rb#59
    def scan(string); end

    # source://protocol-http//lib/protocol/http/url.rb#67
    def split(name); end

    # Unescapes a percent encoded string.
    #
    # source://protocol-http//lib/protocol/http/url.rb#18
    def unescape(string, encoding = T.unsafe(nil)); end
  end
end

# According to https://tools.ietf.org/html/rfc3986#section-3.3, we escape non-pchar.
#
# source://protocol-http//lib/protocol/http/url.rb#25
Protocol::HTTP::URL::NON_PCHAR = T.let(T.unsafe(nil), Regexp)
