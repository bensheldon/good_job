# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `async` gem.
# Please instead update this file by running `bin/tapioca sync`.

# typed: true

module Async
  extend(::Console)

  class << self
    def run(*arguments, &block); end
  end
end

class Async::Barrier
  def initialize(parent: T.unsafe(nil)); end

  def async(*arguments, parent: T.unsafe(nil), **options, &block); end
  def empty?; end
  def size; end
  def tasks; end
  def wait; end
end

class Async::Children
  def initialize; end

  def delete(item); end
  def finished?; end
  def insert(item); end
  def transients?; end
end

class Async::Clock
  def initialize(total = T.unsafe(nil)); end

  def start!; end
  def stop!; end
  def total; end

  class << self
    def measure; end
    def now; end
    def start; end
  end
end

class Async::Condition
  def initialize; end

  def empty?; end
  def signal(value = T.unsafe(nil)); end
  def wait; end
end

class Async::LimitedQueue < ::Async::Queue
  def initialize(limit = T.unsafe(nil), **options); end

  def dequeue; end
  def enqueue(item); end
  def limit; end
  def limited?; end
end

class Async::Node
  def initialize(parent = T.unsafe(nil), annotation: T.unsafe(nil), transient: T.unsafe(nil)); end

  def annotate(annotation); end
  def annotation; end
  def backtrace(*arguments); end
  def children; end
  def children?; end
  def consume; end
  def description; end
  def finished?; end
  def head; end
  def head=(_arg0); end
  def parent; end
  def parent=(parent); end
  def print_hierarchy(out = T.unsafe(nil), backtrace: T.unsafe(nil)); end
  def stop; end
  def tail; end
  def tail=(_arg0); end
  def to_s; end
  def transient?; end
  def traverse(level = T.unsafe(nil), &block); end

  protected

  def add_child(child); end
  def delete_child(child); end
  def set_parent(parent); end

  private

  def print_backtrace(out, indent, node); end
end

class Async::Notification < ::Async::Condition
  def signal(value = T.unsafe(nil), task: T.unsafe(nil)); end
end

class Async::Notification::Signal < ::Struct
  def alive?; end
  def resume; end
  def value; end
  def value=(_); end
  def waiting; end
  def waiting=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def members; end
    def new(*_arg0); end
  end
end

class Async::Queue < ::Async::Notification
  def initialize(parent: T.unsafe(nil)); end

  def <<(item); end
  def async(parent: T.unsafe(nil), &block); end
  def dequeue; end
  def each; end
  def empty?; end
  def enqueue(item); end
  def items; end
  def size; end
end

class Async::Reactor < ::Async::Node
  extend(::Forwardable)

  def initialize(parent = T.unsafe(nil), selector: T.unsafe(nil), logger: T.unsafe(nil)); end

  def <<(fiber); end
  def async(*arguments, **options, &block); end
  def block(blocker, timeout); end
  def close; end
  def closed?; end
  def fiber(&block); end
  def finished?; end
  def interrupt; end
  def logger; end
  def register(io, interest, value = T.unsafe(nil)); end
  def run(*arguments, **options, &block); end
  def run_once(timeout = T.unsafe(nil)); end
  def scheduler; end
  def sleep(duration); end
  def stop(later = T.unsafe(nil)); end
  def stopped?; end
  def to_s; end
  def unblock(blocker, fiber); end
  def with_timeout(timeout, exception = T.unsafe(nil)); end
  def yield(fiber = T.unsafe(nil)); end

  class << self
    def run(*arguments, **options, &block); end
    def selector; end
  end
end

class Async::Scheduler
  def initialize(reactor); end

  def block(blocker, timeout); end
  def clear!; end
  def close; end
  def fiber(&block); end
  def io_wait(io, events, timeout = T.unsafe(nil)); end
  def kernel_sleep(duration); end
  def process_wait(pid, flags); end
  def set!; end
  def unblock(blocker, fiber); end
  def wrappers; end

  private

  def from_io(io); end

  class << self
    def supported?; end
  end
end

class Async::Semaphore
  def initialize(limit = T.unsafe(nil), parent: T.unsafe(nil)); end

  def acquire; end
  def async(*arguments, parent: T.unsafe(nil), **options); end
  def blocking?; end
  def count; end
  def empty?; end
  def limit; end
  def release; end
  def waiting; end

  private

  def wait; end
end

class Async::Stop < ::Exception
end

class Async::Stop::Later
  def initialize(task); end

  def alive?; end
  def resume; end
end

class Async::Task < ::Async::Node
  extend(::Forwardable)

  def initialize(reactor, parent = T.unsafe(nil), logger: T.unsafe(nil), finished: T.unsafe(nil), **options, &block); end

  def alive?; end
  def async(*arguments, **options, &block); end
  def complete?; end
  def current?; end
  def failed?; end
  def fiber; end
  def finished?; end
  def logger; end
  def reactor; end
  def result; end
  def run(*arguments); end
  def running?; end
  def sleep(*args, &block); end
  def status; end
  def stop(later = T.unsafe(nil)); end
  def stopped?; end
  def stopping?; end
  def to_s; end
  def wait; end
  def with_timeout(*args, &block); end
  def yield; end

  private

  def fail!(exception = T.unsafe(nil), propagate = T.unsafe(nil)); end
  def finish!; end
  def make_fiber(&block); end
  def set!; end
  def stop!; end

  class << self
    def current; end
    def current?; end
    def yield; end
  end
end

class Async::TimeoutError < ::StandardError
end

Async::VERSION = T.let(T.unsafe(nil), String)

class Async::Wrapper
  def initialize(io, reactor = T.unsafe(nil)); end

  def close; end
  def closed?; end
  def dup; end
  def io; end
  def monitor; end
  def reactor; end
  def reactor=(reactor); end
  def resume(*arguments); end
  def wait_any(timeout = T.unsafe(nil)); end
  def wait_readable(timeout = T.unsafe(nil)); end
  def wait_writable(timeout = T.unsafe(nil)); end

  private

  def cancel_monitor; end
  def interests; end
  def wait_for(timeout); end
end

class Async::Wrapper::Cancelled < ::StandardError
  def initialize; end

  def cause; end
end

class Async::Wrapper::Cancelled::From
  def initialize; end

  def backtrace; end
  def cause; end
  def message; end
end

class Async::Wrapper::WaitError < ::StandardError
  def initialize; end
end

module Kernel
  def Async(*arguments, **options, &block); end
  def Sync(&block); end
end
