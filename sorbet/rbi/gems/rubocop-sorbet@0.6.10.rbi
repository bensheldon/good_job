# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `rubocop-sorbet` gem.
# Please instead update this file by running `bin/tapioca gem rubocop-sorbet`.

module RuboCop; end
module RuboCop::Cop; end

# @deprecated IgnoredPattern class has been replaced with AllowedPattern.
RuboCop::Cop::IgnoredPattern = RuboCop::Cop::AllowedPattern

module RuboCop::Cop::Sorbet; end

# This cop disallows using `.override(allow_incompatible: true)`.
# Using `allow_incompatible` suggests a violation of the Liskov
# Substitution Principle, meaning that a subclass is not a valid
# subtype of it's superclass. This Cop prevents these design smells
# from occurring.
#
# @example
#
#   # bad
#   sig.override(allow_incompatible: true)
#
#   # good
#   sig.override
class RuboCop::Cop::Sorbet::AllowIncompatibleOverride < ::RuboCop::Cop::Cop
  def allow_incompatible?(param0); end
  def allow_incompatible_override?(param0 = T.unsafe(nil)); end

  # @return [Boolean]
  def not_nil?(node); end

  def on_send(node); end
  def sig?(param0); end
end

# This cop disallows binding the return value of `T.any`, `T.all`, `T.enum`
# to a constant directly. To bind the value, one must use `T.type_alias`.
#
# @example
#
#   # bad
#   FooOrBar = T.any(Foo, Bar)
#
#   # good
#   FooOrBar = T.type_alias { T.any(Foo, Bar) }
class RuboCop::Cop::Sorbet::BindingConstantWithoutTypeAlias < ::RuboCop::Cop::Cop
  def autocorrect(node); end
  def binding_unaliased_type?(param0 = T.unsafe(nil)); end
  def dynamic_type_creation_with_block?(param0 = T.unsafe(nil)); end
  def generic_parameter_decl_block_call?(param0 = T.unsafe(nil)); end
  def generic_parameter_decl_call?(param0 = T.unsafe(nil)); end
  def method_needing_aliasing_on_t?(param0); end

  # @return [Boolean]
  def not_dynamic_type_creation_with_block?(node); end

  # @return [Boolean]
  def not_generic_parameter_decl?(node); end

  # @return [Boolean]
  def not_nil?(node); end

  # @return [Boolean]
  def not_t_let?(node); end

  def on_casgn(node); end
  def t_let?(param0 = T.unsafe(nil)); end
  def using_deprecated_type_alias_syntax?(param0 = T.unsafe(nil)); end
  def using_type_alias?(param0 = T.unsafe(nil)); end
end

# This cop ensures that callback conditionals are bound to the right type
# so that they are type checked properly.
#
# Auto-correction is unsafe because other libraries define similar style callbacks as Rails, but don't always need
# binding to the attached class. Auto-correcting those usages can lead to false positives and auto-correction
# introduces new typing errors.
#
# @example
#
#   # bad
#   class Post < ApplicationRecord
#   before_create :do_it, if: -> { should_do_it? }
#
#   def should_do_it?
#   true
#   end
#   end
#
#   # good
#   class Post < ApplicationRecord
#   before_create :do_it, if: -> {
#   T.bind(self, Post)
#   should_do_it?
#   }
#
#   def should_do_it?
#   true
#   end
#   end
class RuboCop::Cop::Sorbet::CallbackConditionalsBinding < ::RuboCop::Cop::Cop
  def autocorrect(node); end
  def on_send(node); end
end

RuboCop::Cop::Sorbet::CallbackConditionalsBinding::CALLBACKS = T.let(T.unsafe(nil), Array)

# This cop disallows the usage of `checked(true)`. This usage could cause
# confusion; it could lead some people to believe that a method would be checked
# even if runtime checks have not been enabled on the class or globally.
# Additionally, in the event where checks are enabled, `checked(true)` would
# be redundant; only `checked(false)` or `soft` would change the behaviour.
#
# @example
#
#   # bad
#   sig { void.checked(true) }
#
#   # good
#   sig { void }
class RuboCop::Cop::Sorbet::CheckedTrueInSignature < ::RuboCop::Cop::Sorbet::SignatureCop
  include ::RuboCop::Cop::RangeHelp

  def offending_node(param0); end
  def on_signature(node); end
end

RuboCop::Cop::Sorbet::CheckedTrueInSignature::MESSAGE = T.let(T.unsafe(nil), String)

# This cop disallows the calls that are used to get constants fom Strings
# such as +constantize+, +const_get+, and +constants+.
#
# The goal of this cop is to make the code easier to statically analyze,
# more IDE-friendly, and more predictable. It leads to code that clearly
# expresses which values the constant can have.
#
# @example
#
#   # bad
#   class_name.constantize
#
#   # bad
#   constants.detect { |c| c.name == "User" }
#
#   # bad
#   const_get(class_name)
#
#   # good
#   case class_name
#   when "User"
#   User
#   else
#   raise ArgumentError
#   end
#
#   # good
#   { "User" => User }.fetch(class_name)
class RuboCop::Cop::Sorbet::ConstantsFromStrings < ::RuboCop::Cop::Cop
  def constant_from_string?(param0 = T.unsafe(nil)); end
  def on_send(node); end
end

# This cop checks that the Sorbet sigil comes as the first magic comment in the file.
#
# The expected order for magic comments is: typed, (en)?coding, warn_indent then frozen_string_literal.
#
# For example, the following bad ordering:
#
# ```ruby
# class Foo; end
# ```
#
# Will be corrected as:
#
# ```ruby
# class Foo; end
# ```
#
# Only `typed`, `(en)?coding`, `warn_indent` and `frozen_string_literal` magic comments are considered,
# other comments or magic comments are left in the same place.
class RuboCop::Cop::Sorbet::EnforceSigilOrder < ::RuboCop::Cop::Sorbet::ValidSigil
  include ::RuboCop::Cop::RangeHelp

  def autocorrect(_node); end
  def investigate(processed_source); end

  protected

  # checks
  def check_magic_comments_order(tokens); end

  # Get all the tokens in `processed_source` that match `MAGIC_REGEX`
  def extract_magic_comments(processed_source); end
end

RuboCop::Cop::Sorbet::EnforceSigilOrder::CODING_REGEX = T.let(T.unsafe(nil), Regexp)
RuboCop::Cop::Sorbet::EnforceSigilOrder::FROZEN_REGEX = T.let(T.unsafe(nil), Regexp)
RuboCop::Cop::Sorbet::EnforceSigilOrder::INDENT_REGEX = T.let(T.unsafe(nil), Regexp)
RuboCop::Cop::Sorbet::EnforceSigilOrder::MAGIC_REGEX = T.let(T.unsafe(nil), Regexp)
RuboCop::Cop::Sorbet::EnforceSigilOrder::PREFERRED_ORDER = T.let(T.unsafe(nil), Hash)

# This cop checks that every method definition and attribute accessor has a Sorbet signature.
#
# It also suggest an autocorrect with placeholders so the following code:
#
# ```
# def foo(a, b, c); end
# ```
#
# Will be corrected as:
#
# ```
# sig { params(a: T.untyped, b: T.untyped, c: T.untyped).returns(T.untyped)
# def foo(a, b, c); end
# ```
#
# You can configure the placeholders used by changing the following options:
#
# * `ParameterTypePlaceholder`: placeholders used for parameter types (default: 'T.untyped')
# * `ReturnTypePlaceholder`: placeholders used for return types (default: 'T.untyped')
class RuboCop::Cop::Sorbet::EnforceSignatures < ::RuboCop::Cop::Sorbet::SignatureCop
  # @return [EnforceSignatures] a new instance of EnforceSignatures
  def initialize(config = T.unsafe(nil), options = T.unsafe(nil)); end

  def accessor?(param0 = T.unsafe(nil)); end
  def autocorrect(node); end
  def on_def(node); end
  def on_defs(node); end
  def on_send(node); end
  def on_signature(node); end
  def scope(node); end

  private

  def check_node(node); end
  def param_type_placeholder; end
  def return_type_placeholder; end
end

class RuboCop::Cop::Sorbet::EnforceSignatures::SigSuggestion
  # @return [SigSuggestion] a new instance of SigSuggestion
  def initialize(indent, param_placeholder, return_placeholder); end

  # Returns the value of attribute params.
  def params; end

  # Sets the attribute params
  #
  # @param value the value to set the attribute params to.
  def params=(_arg0); end

  # Returns the value of attribute returns.
  def returns; end

  # Sets the attribute returns
  #
  # @param value the value to set the attribute returns to.
  def returns=(_arg0); end

  def to_autocorrect; end

  private

  def generate_params; end
  def generate_return; end
end

# This cop checks that there is only one Sorbet sigil in a given file
#
# For example, the following class with two sigils
#
# ```ruby
# class Foo; end
# ```
#
# Will be corrected as:
#
# ```ruby
# class Foo; end
# ```
#
# Other comments or magic comments are left in place.
class RuboCop::Cop::Sorbet::EnforceSingleSigil < ::RuboCop::Cop::Sorbet::ValidSigil
  include ::RuboCop::Cop::RangeHelp

  def autocorrect(_node); end
  def investigate(processed_source); end

  protected

  def extract_all_sigils(processed_source); end
end

# This cop makes the Sorbet `false` sigil mandatory in all files.
class RuboCop::Cop::Sorbet::FalseSigil < ::RuboCop::Cop::Sorbet::HasSigil
  def minimum_strictness; end
end

# This cop ensures RBI shims do not include a call to extend T::Sig
# or to extend T::Helpers
#
# @example
#
#   # bad
#   module SomeModule
#   extend T::Sig
#   extend T::Helpers
#
#   sig { returns(String) }
#   def foo; end
#   end
#
#   # good
#   module SomeModule
#   sig { returns(String) }
#   def foo; end
#   end
class RuboCop::Cop::Sorbet::ForbidExtendTSigHelpersInShims < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::RangeHelp

  def autocorrect(node); end
  def extend_t_helpers?(param0 = T.unsafe(nil)); end
  def extend_t_sig?(param0 = T.unsafe(nil)); end
  def on_send(node); end
end

RuboCop::Cop::Sorbet::ForbidExtendTSigHelpersInShims::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Sorbet::ForbidExtendTSigHelpersInShims::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Sorbet::ForbidIncludeConstLiteral < ::RuboCop::Cop::Cop
  # @return [ForbidIncludeConstLiteral] a new instance of ForbidIncludeConstLiteral
  def initialize(*_arg0); end

  def autocorrect(node); end
  def not_lit_const_include?(param0 = T.unsafe(nil)); end
  def on_send(node); end

  # Returns the value of attribute used_names.
  def used_names; end

  # Sets the attribute used_names
  #
  # @param value the value to set the attribute used_names to.
  def used_names=(_arg0); end
end

RuboCop::Cop::Sorbet::ForbidIncludeConstLiteral::MSG = T.let(T.unsafe(nil), String)

# This cop makes sure that RBI files are always located under the defined allowed paths.
#
# Options:
#
# * `AllowedPaths`: A list of the paths where RBI files are allowed (default: ["sorbet/rbi/**"])
#
# @example
#   # bad
#   # lib/some_file.rbi
#   # other_file.rbi
#
#   # good
#   # sorbet/rbi/some_file.rbi
#   # sorbet/rbi/any/path/for/file.rbi
class RuboCop::Cop::Sorbet::ForbidRBIOutsideOfAllowedPaths < ::RuboCop::Cop::Cop
  include ::RuboCop::Cop::RangeHelp

  def investigate(processed_source); end

  private

  def allowed_paths; end
end

class RuboCop::Cop::Sorbet::ForbidSuperclassConstLiteral < ::RuboCop::Cop::Cop
  def not_lit_const_superclass?(param0 = T.unsafe(nil)); end
  def on_class(node); end
end

RuboCop::Cop::Sorbet::ForbidSuperclassConstLiteral::MSG = T.let(T.unsafe(nil), String)

# This cop disallows using `T.unsafe` anywhere.
#
# @example
#
#   # bad
#   T.unsafe(foo)
#
#   # good
#   foo
class RuboCop::Cop::Sorbet::ForbidTUnsafe < ::RuboCop::Cop::Cop
  def on_send(node); end
  def t_unsafe?(param0 = T.unsafe(nil)); end
end

# This cop disallows using `T.untyped` anywhere.
#
# @example
#
#   # bad
#   sig { params(my_argument: T.untyped).void }
#   def foo(my_argument); end
#
#   # good
#   sig { params(my_argument: String).void }
#   def foo(my_argument); end
class RuboCop::Cop::Sorbet::ForbidTUntyped < ::RuboCop::Cop::Cop
  def on_send(node); end
  def t_untyped?(param0 = T.unsafe(nil)); end
end

# This cop disallows use of `T.untyped` or `T.nilable(T.untyped)`
# as a prop type for `T::Struct`.
#
# @example
#
#   # bad
#   class SomeClass
#   const :foo, T.untyped
#   prop :bar, T.nilable(T.untyped)
#   end
#
#   # good
#   class SomeClass
#   const :foo, Integer
#   prop :bar, T.nilable(String)
#   end
class RuboCop::Cop::Sorbet::ForbidUntypedStructProps < ::RuboCop::Cop::Cop
  def on_class(node); end
  def subclass_of_t_struct?(param0 = T.unsafe(nil)); end
  def t_nilable_untyped(param0 = T.unsafe(nil)); end
  def t_struct(param0 = T.unsafe(nil)); end
  def t_untyped(param0 = T.unsafe(nil)); end
  def untyped_props(param0); end
end

RuboCop::Cop::Sorbet::ForbidUntypedStructProps::MSG = T.let(T.unsafe(nil), String)

# This cop makes the Sorbet typed sigil mandatory in all files.
#
# Options:
#
# * `SuggestedStrictness`: Sorbet strictness level suggested in offense messages (default: 'false')
# * `MinimumStrictness`: If set, make offense if the strictness level in the file is below this one
#
# If a `MinimumStrictness` level is specified, it will be used in offense messages and autocorrect.
class RuboCop::Cop::Sorbet::HasSigil < ::RuboCop::Cop::Sorbet::ValidSigil
  # @return [Boolean]
  def require_sigil_on_all_files?; end
end

# This cop makes the Sorbet `ignore` sigil mandatory in all files.
class RuboCop::Cop::Sorbet::IgnoreSigil < ::RuboCop::Cop::Sorbet::HasSigil
  def minimum_strictness; end
end

# This cop checks for the ordering of keyword arguments required by
# sorbet-runtime. The ordering requires that all keyword arguments
# are at the end of the parameters list, and all keyword arguments
# with a default value must be after those without default values.
#
# @example
#
#   # bad
#   sig { params(a: Integer, b: String).void }
#   def foo(a: 1, b:); end
#
#   # good
#   sig { params(b: String, a: Integer).void }
#   def foo(b:, a: 1); end
class RuboCop::Cop::Sorbet::KeywordArgumentOrdering < ::RuboCop::Cop::Sorbet::SignatureCop
  def on_signature(node); end

  private

  def check_order_for_kwoptargs(parameters); end
end

module RuboCop::Cop::Sorbet::MutableConstantSorbetAwareBehaviour
  def on_assignment(value); end

  class << self
    def prepended(base); end
  end
end

# This cop ensures one ancestor per requires_ancestor line
# rather than chaining them as a comma-separated list.
#
# @example
#
#   # bad
#   module SomeModule
#   requires_ancestor Kernel, Minitest::Assertions
#   end
#
#   # good
#   module SomeModule
#   requires_ancestor Kernel
#   requires_ancestor Minitest::Assertions
#   end
class RuboCop::Cop::Sorbet::OneAncestorPerLine < ::RuboCop::Cop::Cop
  def abstract?(param0); end
  def autocorrect(node); end
  def more_than_one_ancestor(param0 = T.unsafe(nil)); end
  def on_class(node); end
  def on_module(node); end
  def requires_ancestors(param0); end

  private

  def new_ra_line(indent_count); end
  def process_node(node); end
end

RuboCop::Cop::Sorbet::OneAncestorPerLine::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Sorbet::SignatureBuildOrder < ::RuboCop::Cop::Sorbet::SignatureCop
  def autocorrect(node); end
  def on_signature(node); end
  def root_call(param0); end

  private

  def call_chain(sig_child_node); end

  # @return [Boolean]
  def can_autocorrect?; end

  # This method exists to reparse the current node with modern features enabled.
  # Modern features include "index send" emitting, which is necessary to unparse
  # "index sends" (i.e. `[]` calls) back to index accessors (i.e. as `foo[bar]``).
  # Otherwise, we would get the unparsed node as `foo.[](bar)`.
  def node_reparsed_with_modern_features(node); end
end

# Create a subclass of AST Builder that has modern features turned on
class RuboCop::Cop::Sorbet::SignatureBuildOrder::ModernBuilder < ::RuboCop::AST::Builder; end

RuboCop::Cop::Sorbet::SignatureBuildOrder::ORDER = T.let(T.unsafe(nil), Hash)

# Abstract cop specific to Sorbet signatures
#
# You can subclass it to use the `on_signature` trigger and the `signature?` node matcher.
class RuboCop::Cop::Sorbet::SignatureCop < ::RuboCop::Cop::Cop
  def allowed_recv(recv); end
  def on_block(node); end
  def on_signature(_); end
  def signature?(param0 = T.unsafe(nil)); end
  def with_runtime?(param0 = T.unsafe(nil)); end
  def without_runtime?(param0 = T.unsafe(nil)); end
end

# This cop ensures empty class/module definitions in RBI files are
# done on a single line rather than being split across multiple lines.
#
# @example
#
#   # bad
#   module SomeModule
#   end
#
#   # good
#   module SomeModule; end
class RuboCop::Cop::Sorbet::SingleLineRbiClassModuleDefinitions < ::RuboCop::Cop::Cop
  def autocorrect(node); end
  def on_class(node); end
  def on_module(node); end

  protected

  def convert_newlines(source); end
  def process_node(node); end
end

RuboCop::Cop::Sorbet::SingleLineRbiClassModuleDefinitions::MSG = T.let(T.unsafe(nil), String)

# This cop makes the Sorbet `strict` sigil mandatory in all files.
class RuboCop::Cop::Sorbet::StrictSigil < ::RuboCop::Cop::Sorbet::HasSigil
  def minimum_strictness; end
end

# This cop makes the Sorbet `strong` sigil mandatory in all files.
class RuboCop::Cop::Sorbet::StrongSigil < ::RuboCop::Cop::Sorbet::HasSigil
  def minimum_strictness; end
end

# This cop makes the Sorbet `true` sigil mandatory in all files.
class RuboCop::Cop::Sorbet::TrueSigil < ::RuboCop::Cop::Sorbet::HasSigil
  def minimum_strictness; end
end

# This cop ensures all constants used as `T.type_alias` are using CamelCase.
#
# @example
#
#   # bad
#   FOO_OR_BAR = T.type_alias { T.any(Foo, Bar) }
#
#   # good
#   FooOrBar = T.type_alias { T.any(Foo, Bar) }
class RuboCop::Cop::Sorbet::TypeAliasName < ::RuboCop::Cop::Cop
  def casgn_type_alias?(param0 = T.unsafe(nil)); end
  def on_casgn(node); end
end

RuboCop::Cop::Sorbet::TypeAliasName::MSG = T.let(T.unsafe(nil), String)

# This cop checks that every Ruby file contains a valid Sorbet sigil.
# Adapted from: https://gist.github.com/clarkdave/85aca4e16f33fd52aceb6a0a29936e52
#
# Options:
#
# * `RequireSigilOnAllFiles`: make offense if the Sorbet typed is not found in the file (default: false)
# * `SuggestedStrictness`: Sorbet strictness level suggested in offense messages (default: 'false')
# * `MinimumStrictness`: If set, make offense if the strictness level in the file is below this one
#
# If a `MinimumStrictness` level is specified, it will be used in offense messages and autocorrect.
class RuboCop::Cop::Sorbet::ValidSigil < ::RuboCop::Cop::Cop
  def autocorrect(_node); end
  def investigate(processed_source); end

  protected

  # checks
  def check_sigil_present(sigil); end

  def check_strictness_level(sigil, strictness); end
  def check_strictness_not_empty(sigil, strictness); end
  def check_strictness_valid(sigil, strictness); end

  # extraction
  def extract_sigil(processed_source); end

  def extract_strictness(sigil); end

  # Default is `nil`
  def minimum_strictness; end

  # Default is `false`
  #
  # @return [Boolean]
  def require_sigil_on_all_files?; end

  # Default is `'false'`
  def suggested_strictness; end

  def suggested_strictness_level(minimum_strictness, suggested_strictness); end
end

RuboCop::Cop::Sorbet::ValidSigil::SIGIL_REGEX = T.let(T.unsafe(nil), Regexp)
RuboCop::Cop::Sorbet::ValidSigil::STRICTNESS_LEVELS = T.let(T.unsafe(nil), Array)
RuboCop::NodePattern = RuboCop::AST::NodePattern
RuboCop::ProcessedSource = RuboCop::AST::ProcessedSource
module RuboCop::Sorbet; end
RuboCop::Sorbet::CONFIG = T.let(T.unsafe(nil), Hash)
RuboCop::Sorbet::CONFIG_DEFAULT = T.let(T.unsafe(nil), Pathname)
class RuboCop::Sorbet::Error < ::StandardError; end

# Because RuboCop doesn't yet support plugins, we have to monkey patch in a
# bit of our configuration.
module RuboCop::Sorbet::Inject
  class << self
    def defaults!; end
  end
end

RuboCop::Sorbet::PROJECT_ROOT = T.let(T.unsafe(nil), Pathname)
RuboCop::Sorbet::VERSION = T.let(T.unsafe(nil), String)
RuboCop::Token = RuboCop::AST::Token
