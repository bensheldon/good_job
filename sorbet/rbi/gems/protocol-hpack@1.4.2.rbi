# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `protocol-hpack` gem.
# Please instead update this file by running `bin/tapioca gem protocol-hpack`.

# source://protocol-hpack//lib/protocol/hpack/version.rb#23
module Protocol; end

# Implementation of header compression for HTTP 2.0 (HPACK) format adapted
# to efficiently represent HTTP headers in the context of HTTP 2.0.
#
# - http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-10
#
# source://protocol-hpack//lib/protocol/hpack/version.rb#24
module Protocol::HPACK; end

# source://protocol-hpack//lib/protocol/hpack/error.rb#29
class Protocol::HPACK::CompressionError < ::Protocol::HPACK::Error; end

# Responsible for encoding header key-value pairs using HPACK algorithm.
#
# source://protocol-hpack//lib/protocol/hpack/compressor.rb#52
class Protocol::HPACK::Compressor
  # @return [Compressor] a new instance of Compressor
  #
  # source://protocol-hpack//lib/protocol/hpack/compressor.rb#53
  def initialize(buffer, context = T.unsafe(nil), table_size_limit: T.unsafe(nil)); end

  # Returns the value of attribute buffer.
  #
  # source://protocol-hpack//lib/protocol/hpack/compressor.rb#62
  def buffer; end

  # Returns the value of attribute context.
  #
  # source://protocol-hpack//lib/protocol/hpack/compressor.rb#63
  def context; end

  # Encodes provided list of HTTP headers.
  #
  # @param headers [Array] +[[name, value], ...]+
  # @return [Buffer]
  #
  # source://protocol-hpack//lib/protocol/hpack/compressor.rb#188
  def encode(headers, table_size = T.unsafe(nil)); end

  # source://protocol-hpack//lib/protocol/hpack/compressor.rb#108
  def huffman; end

  # Returns the value of attribute offset.
  #
  # source://protocol-hpack//lib/protocol/hpack/compressor.rb#64
  def offset; end

  # Returns the value of attribute table_size_limit.
  #
  # source://protocol-hpack//lib/protocol/hpack/compressor.rb#60
  def table_size_limit; end

  # source://protocol-hpack//lib/protocol/hpack/compressor.rb#66
  def write_byte(byte); end

  # source://protocol-hpack//lib/protocol/hpack/compressor.rb#70
  def write_bytes(bytes); end

  # Encodes header command with appropriate header representation.
  #
  # @param h [Hash] header command
  # @param buffer [String]
  # @return [Buffer]
  #
  # source://protocol-hpack//lib/protocol/hpack/compressor.rb#159
  def write_header(command); end

  # Encodes provided value via integer representation.
  # - http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-10#section-5.1
  #
  #  If I < 2^N - 1, encode I on N bits
  #  Else
  #      encode 2^N - 1 on N bits
  #      I = I - (2^N - 1)
  #      While I >= 128
  #           Encode (I % 128 + 128) on 8 bits
  #           I = I / 128
  #      encode (I) on 8 bits
  #
  # @param value [Integer] value to encode
  # @param bits [Integer] number of available bits
  # @return [String] binary string
  #
  # source://protocol-hpack//lib/protocol/hpack/compressor.rb#89
  def write_integer(value, bits); end

  # Encodes provided value via string literal representation.
  # - http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-10#section-5.2
  #
  # * The string length, defined as the number of bytes needed to store
  #   its UTF-8 representation, is represented as an integer with a seven
  #   bits prefix. If the string length is strictly less than 127, it is
  #   represented as one byte.
  # * If the bit 7 of the first byte is 1, the string value is represented
  #   as a list of Huffman encoded octets
  #   (padded with bit 1's until next octet boundary).
  # * If the bit 7 of the first byte is 0, the string value is
  #   represented as a list of UTF-8 encoded octets.
  #
  #  :never   Do not use Huffman encoding
  #  :always  Always use Huffman encoding
  #  :shorter Use Huffman when the result is strictly shorter
  #
  # @param string [String]
  # @return [String] binary string
  #
  # source://protocol-hpack//lib/protocol/hpack/compressor.rb#132
  def write_string(string, huffman = T.unsafe(nil)); end
end

# To decompress header blocks, a decoder only needs to maintain a
# dynamic table as a decoding context.
# No other state information is needed.
#
# source://protocol-hpack//lib/protocol/hpack/context.rb#44
class Protocol::HPACK::Context
  # Initializes compression context with appropriate client/server defaults and maximum size of the dynamic table.
  #
  # @option huffman
  # @option table_size
  # @option index
  # @param table_size [Hash] a customizable set of options
  # @param huffman [Hash] a customizable set of options
  # @param table [Array] Table of header key-value pairs.
  # @param index [Hash] a customizable set of options
  # @return [Context] a new instance of Context
  #
  # source://protocol-hpack//lib/protocol/hpack/context.rb#117
  def initialize(table = T.unsafe(nil), huffman: T.unsafe(nil), index: T.unsafe(nil), table_size: T.unsafe(nil)); end

  # Emits command for a header.
  # Prefer static table over dynamic table.
  # Prefer exact match over name-only match.
  #
  # +@index+ controls whether to use the dynamic table,
  # static table, or both.
  #  :never   Do not use dynamic table or static table reference at all.
  #  :static  Use static table only.
  #  :all     Use all of them.
  #
  # @param header [Array] +[name, value]+
  # @return [Hash] command
  #
  # source://protocol-hpack//lib/protocol/hpack/context.rb#251
  def add_command(*header); end

  # source://protocol-hpack//lib/protocol/hpack/context.rb#292
  def change_table_size(size); end

  # Returns current table size in octets
  #
  # @return [Integer]
  #
  # source://protocol-hpack//lib/protocol/hpack/context.rb#301
  def current_table_size; end

  # Header Block Processing
  # - http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-10#section-4.1
  #
  # @param command [Hash] {type:, name:, value:, index:}
  # @return [Array] +[name, value]+ header field that is added to the decoded header list
  #
  # source://protocol-hpack//lib/protocol/hpack/context.rb#167
  def decode(command); end

  # Finds an entry in current dynamic table by index.
  # Note that index is zero-based in this module.
  #
  # If the index is greater than the last index in the static table,
  # an entry in the dynamic table is dereferenced.
  #
  # If the index is greater than the last header index, an error is raised.
  #
  # @param index [Integer] zero-based index in the dynamic table.
  # @return [Array] +[key, value]+
  #
  # source://protocol-hpack//lib/protocol/hpack/context.rb#151
  def dereference(index); end

  # Plan header compression according to +@index+
  #  :never   Do not use dynamic table or static table reference at all.
  #  :static  Use static table only.
  #  :all     Use all of them.
  #
  # @param headers [Array] +[[name, value], ...]+
  # @return [Array] array of commands
  #
  # source://protocol-hpack//lib/protocol/hpack/context.rb#222
  def encode(headers); end

  # Returns the value of attribute huffman.
  #
  # source://protocol-hpack//lib/protocol/hpack/context.rb#136
  def huffman; end

  # Returns the value of attribute index.
  #
  # source://protocol-hpack//lib/protocol/hpack/context.rb#137
  def index; end

  # Current table of header key-value pairs.
  #
  # source://protocol-hpack//lib/protocol/hpack/context.rb#134
  def table; end

  # Returns the value of attribute table_size.
  #
  # source://protocol-hpack//lib/protocol/hpack/context.rb#139
  def table_size; end

  # Alter dynamic table size.
  #  When the size is reduced, some headers might be evicted.
  #
  # source://protocol-hpack//lib/protocol/hpack/context.rb#287
  def table_size=(size); end

  private

  # Add a name-value pair to the dynamic table. Older entries might have been evicted so that the new entry fits in the dynamic table. The command and the component strings will be frozen.
  #
  # @param command [Array] +[name, value]+
  #
  # source://protocol-hpack//lib/protocol/hpack/context.rb#310
  def add_to_table(command); end

  # source://protocol-hpack//lib/protocol/hpack/context.rb#126
  def initialize_copy(other); end

  # To keep the dynamic table size lower than or equal to @table_size,
  # remove one or more entries at the end of the dynamic table.
  #
  # @param command [Hash]
  # @return [Boolean] whether +command+ fits in the dynamic table.
  #
  # source://protocol-hpack//lib/protocol/hpack/context.rb#324
  def size_check(command); end
end

# Static header table.
# https://tools.ietf.org/html/rfc7541#appendix-A
#
# source://protocol-hpack//lib/protocol/hpack/context.rb#47
Protocol::HPACK::Context::STATIC_TABLE = T.let(T.unsafe(nil), Array)

# source://protocol-hpack//lib/protocol/hpack/error.rb#32
class Protocol::HPACK::DecompressionError < ::Protocol::HPACK::Error; end

# Responsible for decoding received headers and maintaining compression
# context of the opposing peer. Decompressor must be initialized with
# appropriate starting context based on local role: client or server.
#
# source://protocol-hpack//lib/protocol/hpack/decompressor.rb#32
class Protocol::HPACK::Decompressor
  # @return [Decompressor] a new instance of Decompressor
  #
  # source://protocol-hpack//lib/protocol/hpack/decompressor.rb#33
  def initialize(buffer, context = T.unsafe(nil), table_size_limit: T.unsafe(nil)); end

  # Returns the value of attribute buffer.
  #
  # source://protocol-hpack//lib/protocol/hpack/decompressor.rb#41
  def buffer; end

  # Returns the value of attribute context.
  #
  # source://protocol-hpack//lib/protocol/hpack/decompressor.rb#42
  def context; end

  # Decodes and processes header commands within provided buffer.
  #
  # @param buffer [Buffer]
  # @return [Array] +[[name, value], ...]+
  #
  # source://protocol-hpack//lib/protocol/hpack/decompressor.rb#155
  def decode(list = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://protocol-hpack//lib/protocol/hpack/decompressor.rb#47
  def end?; end

  # Returns the value of attribute offset.
  #
  # source://protocol-hpack//lib/protocol/hpack/decompressor.rb#43
  def offset; end

  # source://protocol-hpack//lib/protocol/hpack/decompressor.rb#59
  def peek_byte; end

  # source://protocol-hpack//lib/protocol/hpack/decompressor.rb#51
  def read_byte; end

  # source://protocol-hpack//lib/protocol/hpack/decompressor.rb#63
  def read_bytes(length); end

  # Decodes header command from provided buffer.
  #
  # @param buffer [Buffer]
  # @raise [CompressionError]
  # @return [Hash] command
  #
  # source://protocol-hpack//lib/protocol/hpack/decompressor.rb#115
  def read_header; end

  # Decodes integer value from provided buffer.
  #
  # @param bits [Integer] number of available bits
  # @return [Integer]
  #
  # source://protocol-hpack//lib/protocol/hpack/decompressor.rb#75
  def read_integer(bits); end

  # Decodes string value from provided buffer.
  #
  # @raise [CompressionError] when input is malformed
  # @return [String] UTF-8 encoded string
  #
  # source://protocol-hpack//lib/protocol/hpack/decompressor.rb#95
  def read_string; end

  # Returns the value of attribute table_size_limit.
  #
  # source://protocol-hpack//lib/protocol/hpack/decompressor.rb#45
  def table_size_limit; end
end

# source://protocol-hpack//lib/protocol/hpack/error.rb#26
class Protocol::HPACK::Error < ::StandardError; end

# Header representation as defined by the spec.
#
# source://protocol-hpack//lib/protocol/hpack/context.rb#33
Protocol::HPACK::HEADER_REPRESENTATION = T.let(T.unsafe(nil), Hash)

# Implementation of huffman encoding for HPACK.
#
# source://protocol-hpack//lib/protocol/hpack/huffman/machine.rb#29
class Protocol::HPACK::Huffman
  # Decodes provided Huffman coded string.
  #
  # @param buf [Buffer]
  # @raise [CompressionError] when Huffman coded string is malformed
  # @return [String] binary string
  #
  # source://protocol-hpack//lib/protocol/hpack/huffman.rb#50
  def decode(buffer); end

  # Encodes provided value via huffman encoding.
  # Length is not encoded in this method.
  #
  # @param str [String]
  # @return [String] binary string
  #
  # source://protocol-hpack//lib/protocol/hpack/huffman.rb#39
  def encode(str); end
end

# source://protocol-hpack//lib/protocol/hpack/huffman.rb#31
Protocol::HPACK::Huffman::BITS_AT_ONCE = T.let(T.unsafe(nil), Integer)

# Huffman table as specified in https://tools.ietf.org/html/rfc7541#appendix-B
#
# source://protocol-hpack//lib/protocol/hpack/huffman.rb#79
Protocol::HPACK::Huffman::CODES = T.let(T.unsafe(nil), Array)

# source://protocol-hpack//lib/protocol/hpack/huffman.rb#339
Protocol::HPACK::Huffman::ENCODE_TABLE = T.let(T.unsafe(nil), Array)

# source://protocol-hpack//lib/protocol/hpack/huffman.rb#32
Protocol::HPACK::Huffman::EOS = T.let(T.unsafe(nil), Integer)

# source://protocol-hpack//lib/protocol/hpack/huffman/machine.rb#32
Protocol::HPACK::Huffman::MACHINE = T.let(T.unsafe(nil), Array)

# source://protocol-hpack//lib/protocol/hpack/huffman/machine.rb#31
Protocol::HPACK::Huffman::MAX_FINAL_STATE = T.let(T.unsafe(nil), Integer)

# source://protocol-hpack//lib/protocol/hpack/compressor.rb#32
Protocol::HPACK::LINEAR = T.let(T.unsafe(nil), Hash)

# source://protocol-hpack//lib/protocol/hpack/compressor.rb#36
Protocol::HPACK::LINEAR_HUFFMAN = T.let(T.unsafe(nil), Hash)

# source://protocol-hpack//lib/protocol/hpack/compressor.rb#40
Protocol::HPACK::MODES = T.let(T.unsafe(nil), Hash)

# Predefined options set for Compressor
# http://mew.org/~kazu/material/2014-hpack.pdf
#
# source://protocol-hpack//lib/protocol/hpack/compressor.rb#31
Protocol::HPACK::NAIVE = T.let(T.unsafe(nil), Hash)

# source://protocol-hpack//lib/protocol/hpack/compressor.rb#35
Protocol::HPACK::NAIVE_HUFFMAN = T.let(T.unsafe(nil), Hash)

# source://protocol-hpack//lib/protocol/hpack/compressor.rb#34
Protocol::HPACK::SHORTER = T.let(T.unsafe(nil), Hash)

# source://protocol-hpack//lib/protocol/hpack/compressor.rb#38
Protocol::HPACK::SHORTER_HUFFMAN = T.let(T.unsafe(nil), Hash)

# source://protocol-hpack//lib/protocol/hpack/compressor.rb#33
Protocol::HPACK::STATIC = T.let(T.unsafe(nil), Hash)

# source://protocol-hpack//lib/protocol/hpack/compressor.rb#37
Protocol::HPACK::STATIC_HUFFMAN = T.let(T.unsafe(nil), Hash)

# source://protocol-hpack//lib/protocol/hpack/version.rb#25
Protocol::HPACK::VERSION = T.let(T.unsafe(nil), String)
