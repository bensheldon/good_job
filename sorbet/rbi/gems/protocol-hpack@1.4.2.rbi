# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `protocol-hpack` gem.
# Please instead update this file by running `bin/tapioca gem protocol-hpack`.

module Protocol; end

# Implementation of header compression for HTTP 2.0 (HPACK) format adapted
# to efficiently represent HTTP headers in the context of HTTP 2.0.
#
# - http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-10
module Protocol::HPACK; end

class Protocol::HPACK::CompressionError < ::Protocol::HPACK::Error; end

# Responsible for encoding header key-value pairs using HPACK algorithm.
class Protocol::HPACK::Compressor
  # @return [Compressor] a new instance of Compressor
  def initialize(buffer, context = T.unsafe(nil), table_size_limit: T.unsafe(nil)); end

  # Returns the value of attribute buffer.
  def buffer; end

  # Returns the value of attribute context.
  def context; end

  # Encodes provided list of HTTP headers.
  #
  # @param headers [Array] +[[name, value], ...]+
  # @return [Buffer]
  def encode(headers, table_size = T.unsafe(nil)); end

  def huffman; end

  # Returns the value of attribute offset.
  def offset; end

  # Returns the value of attribute table_size_limit.
  def table_size_limit; end

  def write_byte(byte); end
  def write_bytes(bytes); end

  # Encodes header command with appropriate header representation.
  #
  # @param h [Hash] header command
  # @param buffer [String]
  # @return [Buffer]
  def write_header(command); end

  # Encodes provided value via integer representation.
  # - http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-10#section-5.1
  #
  #  If I < 2^N - 1, encode I on N bits
  #  Else
  #      encode 2^N - 1 on N bits
  #      I = I - (2^N - 1)
  #      While I >= 128
  #           Encode (I % 128 + 128) on 8 bits
  #           I = I / 128
  #      encode (I) on 8 bits
  #
  # @param value [Integer] value to encode
  # @param bits [Integer] number of available bits
  # @return [String] binary string
  def write_integer(value, bits); end

  # Encodes provided value via string literal representation.
  # - http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-10#section-5.2
  #
  # * The string length, defined as the number of bytes needed to store
  #   its UTF-8 representation, is represented as an integer with a seven
  #   bits prefix. If the string length is strictly less than 127, it is
  #   represented as one byte.
  # * If the bit 7 of the first byte is 1, the string value is represented
  #   as a list of Huffman encoded octets
  #   (padded with bit 1's until next octet boundary).
  # * If the bit 7 of the first byte is 0, the string value is
  #   represented as a list of UTF-8 encoded octets.
  #
  #  :never   Do not use Huffman encoding
  #  :always  Always use Huffman encoding
  #  :shorter Use Huffman when the result is strictly shorter
  #
  # @param string [String]
  # @return [String] binary string
  def write_string(string, huffman = T.unsafe(nil)); end
end

# To decompress header blocks, a decoder only needs to maintain a
# dynamic table as a decoding context.
# No other state information is needed.
class Protocol::HPACK::Context
  # Initializes compression context with appropriate client/server defaults and maximum size of the dynamic table.
  #
  # @option huffman
  # @option table_size
  # @option index
  # @param table_size [Hash] a customizable set of options
  # @param huffman [Hash] a customizable set of options
  # @param table [Array] Table of header key-value pairs.
  # @param index [Hash] a customizable set of options
  # @return [Context] a new instance of Context
  def initialize(table = T.unsafe(nil), huffman: T.unsafe(nil), index: T.unsafe(nil), table_size: T.unsafe(nil)); end

  # Emits command for a header.
  # Prefer static table over dynamic table.
  # Prefer exact match over name-only match.
  #
  # +@index+ controls whether to use the dynamic table,
  # static table, or both.
  #  :never   Do not use dynamic table or static table reference at all.
  #  :static  Use static table only.
  #  :all     Use all of them.
  #
  # @param header [Array] +[name, value]+
  # @return [Hash] command
  def add_command(*header); end

  def change_table_size(size); end

  # Returns current table size in octets
  #
  # @return [Integer]
  def current_table_size; end

  # Header Block Processing
  # - http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-10#section-4.1
  #
  # @param command [Hash] {type:, name:, value:, index:}
  # @return [Array] +[name, value]+ header field that is added to the decoded header list
  def decode(command); end

  # Finds an entry in current dynamic table by index.
  # Note that index is zero-based in this module.
  #
  # If the index is greater than the last index in the static table,
  # an entry in the dynamic table is dereferenced.
  #
  # If the index is greater than the last header index, an error is raised.
  #
  # @param index [Integer] zero-based index in the dynamic table.
  # @return [Array] +[key, value]+
  def dereference(index); end

  # Plan header compression according to +@index+
  #  :never   Do not use dynamic table or static table reference at all.
  #  :static  Use static table only.
  #  :all     Use all of them.
  #
  # @param headers [Array] +[[name, value], ...]+
  # @return [Array] array of commands
  def encode(headers); end

  # Returns the value of attribute huffman.
  def huffman; end

  # Returns the value of attribute index.
  def index; end

  # Current table of header key-value pairs.
  def table; end

  # Returns the value of attribute table_size.
  def table_size; end

  # Alter dynamic table size.
  #  When the size is reduced, some headers might be evicted.
  def table_size=(size); end

  private

  # Add a name-value pair to the dynamic table. Older entries might have been evicted so that the new entry fits in the dynamic table. The command and the component strings will be frozen.
  #
  # @param command [Array] +[name, value]+
  def add_to_table(command); end

  def initialize_copy(other); end

  # To keep the dynamic table size lower than or equal to @table_size,
  # remove one or more entries at the end of the dynamic table.
  #
  # @param command [Hash]
  # @return [Boolean] whether +command+ fits in the dynamic table.
  def size_check(command); end
end

# Static header table.
# https://tools.ietf.org/html/rfc7541#appendix-A
Protocol::HPACK::Context::STATIC_TABLE = T.let(T.unsafe(nil), Array)

class Protocol::HPACK::DecompressionError < ::Protocol::HPACK::Error; end

# Responsible for decoding received headers and maintaining compression
# context of the opposing peer. Decompressor must be initialized with
# appropriate starting context based on local role: client or server.
class Protocol::HPACK::Decompressor
  # @return [Decompressor] a new instance of Decompressor
  def initialize(buffer, context = T.unsafe(nil), table_size_limit: T.unsafe(nil)); end

  # Returns the value of attribute buffer.
  def buffer; end

  # Returns the value of attribute context.
  def context; end

  # Decodes and processes header commands within provided buffer.
  #
  # @param buffer [Buffer]
  # @return [Array] +[[name, value], ...]+
  def decode(list = T.unsafe(nil)); end

  # @return [Boolean]
  def end?; end

  # Returns the value of attribute offset.
  def offset; end

  def peek_byte; end
  def read_byte; end
  def read_bytes(length); end

  # Decodes header command from provided buffer.
  #
  # @param buffer [Buffer]
  # @raise [CompressionError]
  # @return [Hash] command
  def read_header; end

  # Decodes integer value from provided buffer.
  #
  # @param bits [Integer] number of available bits
  # @return [Integer]
  def read_integer(bits); end

  # Decodes string value from provided buffer.
  #
  # @raise [CompressionError] when input is malformed
  # @return [String] UTF-8 encoded string
  def read_string; end

  # Returns the value of attribute table_size_limit.
  def table_size_limit; end
end

class Protocol::HPACK::Error < ::StandardError; end

# Header representation as defined by the spec.
Protocol::HPACK::HEADER_REPRESENTATION = T.let(T.unsafe(nil), Hash)

# Implementation of huffman encoding for HPACK.
class Protocol::HPACK::Huffman
  # Decodes provided Huffman coded string.
  #
  # @param buf [Buffer]
  # @raise [CompressionError] when Huffman coded string is malformed
  # @return [String] binary string
  def decode(buffer); end

  # Encodes provided value via huffman encoding.
  # Length is not encoded in this method.
  #
  # @param str [String]
  # @return [String] binary string
  def encode(str); end
end

Protocol::HPACK::Huffman::BITS_AT_ONCE = T.let(T.unsafe(nil), Integer)

# Huffman table as specified in https://tools.ietf.org/html/rfc7541#appendix-B
Protocol::HPACK::Huffman::CODES = T.let(T.unsafe(nil), Array)

Protocol::HPACK::Huffman::ENCODE_TABLE = T.let(T.unsafe(nil), Array)
Protocol::HPACK::Huffman::EOS = T.let(T.unsafe(nil), Integer)
Protocol::HPACK::Huffman::MACHINE = T.let(T.unsafe(nil), Array)
Protocol::HPACK::Huffman::MAX_FINAL_STATE = T.let(T.unsafe(nil), Integer)
Protocol::HPACK::LINEAR = T.let(T.unsafe(nil), Hash)
Protocol::HPACK::LINEAR_HUFFMAN = T.let(T.unsafe(nil), Hash)
Protocol::HPACK::MODES = T.let(T.unsafe(nil), Hash)

# Predefined options set for Compressor
# http://mew.org/~kazu/material/2014-hpack.pdf
Protocol::HPACK::NAIVE = T.let(T.unsafe(nil), Hash)

Protocol::HPACK::NAIVE_HUFFMAN = T.let(T.unsafe(nil), Hash)
Protocol::HPACK::SHORTER = T.let(T.unsafe(nil), Hash)
Protocol::HPACK::SHORTER_HUFFMAN = T.let(T.unsafe(nil), Hash)
Protocol::HPACK::STATIC = T.let(T.unsafe(nil), Hash)
Protocol::HPACK::STATIC_HUFFMAN = T.let(T.unsafe(nil), Hash)
Protocol::HPACK::VERSION = T.let(T.unsafe(nil), String)
