# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `protocol-http1` gem.
# Please instead update this file by running `bin/tapioca gem protocol-http1`.


# source://protocol-http1//lib/protocol/http1/version.rb#6
module Protocol; end

# source://protocol-http1//lib/protocol/http1/version.rb#7
module Protocol::HTTP1; end

# A header name or value was invalid, e.g. contains invalid characters.
#
# source://protocol-http1//lib/protocol/http1/error.rb#27
class Protocol::HTTP1::BadHeader < ::Protocol::HTTP1::BadRequest; end

# The request was not able to be parsed correctly, or failed some kind of validation.
#
# source://protocol-http1//lib/protocol/http1/error.rb#23
class Protocol::HTTP1::BadRequest < ::Protocol::HTTP1::Error; end

# A collection of classes for handling HTTP/1.1 request and response bodies.
#
# source://protocol-http1//lib/protocol/http1/body/chunked.rb#11
module Protocol::HTTP1::Body; end

# Represents a chunked body, which is a series of chunks, each with a length prefix.
#
# See https://tools.ietf.org/html/rfc7230#section-4.1 for more details on the chunked transfer encoding.
#
# source://protocol-http1//lib/protocol/http1/body/chunked.rb#15
class Protocol::HTTP1::Body::Chunked < ::Protocol::HTTP::Body::Readable
  # Initialize the chunked body.
  #
  # @return [Chunked] a new instance of Chunked
  #
  # source://protocol-http1//lib/protocol/http1/body/chunked.rb#22
  def initialize(connection, headers); end

  # Close the connection and mark the body as finished.
  #
  # source://protocol-http1//lib/protocol/http1/body/chunked.rb#51
  def close(error = T.unsafe(nil)); end

  # Returns the value of attribute count.
  #
  # source://protocol-http1//lib/protocol/http1/body/chunked.rb#33
  def count; end

  # @return [Boolean]
  #
  # source://protocol-http1//lib/protocol/http1/body/chunked.rb#44
  def empty?; end

  # source://protocol-http1//lib/protocol/http1/body/chunked.rb#118
  def inspect; end

  # source://protocol-http1//lib/protocol/http1/body/chunked.rb#36
  def length; end

  # Read a chunk of data.
  #
  # Follows the procedure outlined in https://tools.ietf.org/html/rfc7230#section-4.1.3
  #
  # source://protocol-http1//lib/protocol/http1/body/chunked.rb#71
  def read; end

  private

  # Read the trailer from the connection, and add any headers to the trailer.
  #
  # source://protocol-http1//lib/protocol/http1/body/chunked.rb#125
  def read_trailer; end
end

# source://protocol-http1//lib/protocol/http1/body/chunked.rb#16
Protocol::HTTP1::Body::Chunked::CRLF = T.let(T.unsafe(nil), String)

# source://protocol-http1//lib/protocol/http1/body/chunked.rb#63
Protocol::HTTP1::Body::Chunked::VALID_CHUNK_LENGTH = T.let(T.unsafe(nil), Regexp)

# Represents a fixed length body.
#
# source://protocol-http1//lib/protocol/http1/body/fixed.rb#12
class Protocol::HTTP1::Body::Fixed < ::Protocol::HTTP::Body::Readable
  # Initialize the body with the given connection and length.
  #
  # @return [Fixed] a new instance of Fixed
  #
  # source://protocol-http1//lib/protocol/http1/body/fixed.rb#17
  def initialize(connection, length); end

  # Close the connection.
  #
  # source://protocol-http1//lib/protocol/http1/body/fixed.rb#38
  def close(error = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://protocol-http1//lib/protocol/http1/body/fixed.rb#31
  def empty?; end

  # source://protocol-http1//lib/protocol/http1/body/fixed.rb#76
  def inspect; end

  # Returns the value of attribute length.
  #
  # source://protocol-http1//lib/protocol/http1/body/fixed.rb#25
  def length; end

  # Read a chunk of data.
  #
  # source://protocol-http1//lib/protocol/http1/body/fixed.rb#54
  def read; end

  # Returns the value of attribute remaining.
  #
  # source://protocol-http1//lib/protocol/http1/body/fixed.rb#28
  def remaining; end
end

# Represents the remainder of the body, which reads all the data from the connection until it is finished.
#
# source://protocol-http1//lib/protocol/http1/body/remainder.rb#12
class Protocol::HTTP1::Body::Remainder < ::Protocol::HTTP::Body::Readable
  # Initialize the body with the given connection.
  #
  # @return [Remainder] a new instance of Remainder
  #
  # source://protocol-http1//lib/protocol/http1/body/remainder.rb#18
  def initialize(connection, block_size: T.unsafe(nil)); end

  # Close the connection.
  #
  # source://protocol-http1//lib/protocol/http1/body/remainder.rb#41
  def close(error = T.unsafe(nil)); end

  # Discard the body, which will close the connection and prevent further reads.
  #
  # source://protocol-http1//lib/protocol/http1/body/remainder.rb#29
  def discard; end

  # @return [Boolean]
  #
  # source://protocol-http1//lib/protocol/http1/body/remainder.rb#24
  def empty?; end

  # source://protocol-http1//lib/protocol/http1/body/remainder.rb#62
  def inspect; end

  # Read a chunk of data.
  #
  # source://protocol-http1//lib/protocol/http1/body/remainder.rb#50
  def read; end
end

# source://protocol-http1//lib/protocol/http1/body/remainder.rb#13
Protocol::HTTP1::Body::Remainder::BLOCK_SIZE = T.let(T.unsafe(nil), Integer)

# source://protocol-http1//lib/protocol/http1/connection.rb#25
Protocol::HTTP1::CHUNKED = T.let(T.unsafe(nil), String)

# source://protocol-http1//lib/protocol/http1/connection.rb#28
Protocol::HTTP1::CLOSE = T.let(T.unsafe(nil), String)

# source://protocol-http1//lib/protocol/http1/connection.rb#27
Protocol::HTTP1::CONNECTION = T.let(T.unsafe(nil), String)

# source://protocol-http1//lib/protocol/http1/connection.rb#22
Protocol::HTTP1::CONTENT_LENGTH = T.let(T.unsafe(nil), String)

# Represents a single HTTP/1.x connection, which may be used to send and receive multiple requests and responses.
#
# source://protocol-http1//lib/protocol/http1/connection.rb#51
class Protocol::HTTP1::Connection
  # Initialize the connection with the given stream.
  #
  # @return [Connection] a new instance of Connection
  #
  # source://protocol-http1//lib/protocol/http1/connection.rb#65
  def initialize(stream, persistent: T.unsafe(nil), state: T.unsafe(nil), maximum_line_length: T.unsafe(nil)); end

  # Close the connection and underlying stream and transition to the closed state.
  #
  # source://protocol-http1//lib/protocol/http1/connection.rb#225
  def close(error = T.unsafe(nil)); end

  # Transition to the closed state.
  #
  # If no error occurred, and the connection is persistent, this will immediately transition to the idle state.
  #
  # source://protocol-http1//lib/protocol/http1/connection.rb#719
  def close!(error = T.unsafe(nil)); end

  # Close the read end of the connection and transition to the half-closed remote state (or closed if already in the half-closed local state).
  #
  # source://protocol-http1//lib/protocol/http1/connection.rb#216
  def close_read; end

  # The connection (stream) was closed. It may now be in the idle state.
  #
  # Sub-classes may override this method to perform additional cleanup.
  #
  # source://protocol-http1//lib/protocol/http1/connection.rb#711
  def closed(error = T.unsafe(nil)); end

  # @return [Boolean] whether the connection is in the closed state.
  #
  # source://protocol-http1//lib/protocol/http1/connection.rb#144
  def closed?; end

  # Returns the value of attribute count.
  #
  # source://protocol-http1//lib/protocol/http1/connection.rb#149
  def count; end

  # Extract the content length from the headers, if possible.
  #
  # source://protocol-http1//lib/protocol/http1/connection.rb#854
  def extract_content_length(headers); end

  # @return [Boolean] whether the connection is in the half-closed local state.
  #
  # source://protocol-http1//lib/protocol/http1/connection.rb#134
  def half_closed_local?; end

  # @return [Boolean] whether the connection is in the half-closed remote state.
  #
  # source://protocol-http1//lib/protocol/http1/connection.rb#139
  def half_closed_remote?; end

  # Hijack the connection - that is, take over the underlying IO and close the connection.
  #
  # source://protocol-http1//lib/protocol/http1/connection.rb#201
  def hijack!; end

  # Indicates whether the connection has been hijacked meaning its IO has been handed over and is not usable anymore.
  #
  # @return [Boolean]
  #
  # source://protocol-http1//lib/protocol/http1/connection.rb#194
  def hijacked?; end

  # @return [Boolean] whether the connection is in the idle state.
  #
  # source://protocol-http1//lib/protocol/http1/connection.rb#124
  def idle?; end

  # Indicates whether the status code is an interim status code.
  #
  # @return [Boolean]
  #
  # source://protocol-http1//lib/protocol/http1/connection.rb#437
  def interim_status?(status); end

  # Force a transition to the open state.
  #
  # source://protocol-http1//lib/protocol/http1/connection.rb#242
  def open!; end

  # @return [Boolean] whether the connection is in the open state.
  #
  # source://protocol-http1//lib/protocol/http1/connection.rb#129
  def open?; end

  # This determines what connection headers are sent in the response and whether the connection can be reused after the response is sent. This setting is automatically managed according to the nature of the request and response. Changing to false is safe. Changing to true from outside this class should generally be avoided and, depending on the response semantics, may be reset to false anyway.
  #
  # source://protocol-http1//lib/protocol/http1/connection.rb#82
  def persistent; end

  # This determines what connection headers are sent in the response and whether the connection can be reused after the response is sent. This setting is automatically managed according to the nature of the request and response. Changing to false is safe. Changing to true from outside this class should generally be avoided and, depending on the response semantics, may be reset to false anyway.
  #
  # source://protocol-http1//lib/protocol/http1/connection.rb#82
  def persistent=(_arg0); end

  # Indicates whether the connection is persistent given the version, method, and headers.
  #
  # @return [Boolean] whether the connection can be persistent.
  #
  # source://protocol-http1//lib/protocol/http1/connection.rb#157
  def persistent?(version, method, headers); end

  # Read some data from the connection.
  #
  # source://protocol-http1//lib/protocol/http1/connection.rb#342
  def read(length); end

  # Read the body of the message.
  #
  # - The `transfer-encoding` header is used to determine if the body is chunked.
  # - Otherwise, if the `content-length` is present, the body is read until the content length is reached.
  # - Otherwise, if `remainder` is true, the body is read until the connection is closed.
  #
  # source://protocol-http1//lib/protocol/http1/connection.rb#952
  def read_body(headers, remainder = T.unsafe(nil)); end

  # Read the body, assuming it is using the chunked transfer encoding.
  #
  # source://protocol-http1//lib/protocol/http1/connection.rb#788
  def read_chunked_body(headers); end

  # Read the body, assuming it has a fixed length.
  #
  # source://protocol-http1//lib/protocol/http1/connection.rb#796
  def read_fixed_body(length); end

  # Read the body, assuming that we are not receiving any actual data, but just the length.
  #
  # source://protocol-http1//lib/protocol/http1/connection.rb#812
  def read_head_body(length); end

  # Read headers from the connection until an empty line is encountered.
  #
  # source://protocol-http1//lib/protocol/http1/connection.rb#483
  def read_headers; end

  # Read a line from the connection.
  #
  # source://protocol-http1//lib/protocol/http1/connection.rb#366
  def read_line; end

  # Read a line from the connection.
  #
  # @return [Boolean]
  #
  # source://protocol-http1//lib/protocol/http1/connection.rb#351
  def read_line?; end

  # Read the body, assuming that we read until the connection is closed.
  #
  # source://protocol-http1//lib/protocol/http1/connection.rb#803
  def read_remainder_body; end

  # Read a request from the connection, including the request line and request headers, and prepares to read the request body.
  #
  # Transitions to the open state.
  #
  # source://protocol-http1//lib/protocol/http1/connection.rb#392
  def read_request; end

  # Read the body of the request.
  #
  # - The `CONNECT` method is used to establish a tunnel, so the body is read until the connection is closed.
  # - The `UPGRADE` method is used to upgrade the connection to a different protocol (typically WebSockets), so the body is read until the connection is closed.
  # - Otherwise, the body is read according to {read_body}.
  #
  # source://protocol-http1//lib/protocol/http1/connection.rb#923
  def read_request_body(method, headers); end

  # Read a request line from the connection.
  #
  # source://protocol-http1//lib/protocol/http1/connection.rb#373
  def read_request_line; end

  # Read a response from the connection.
  #
  # source://protocol-http1//lib/protocol/http1/connection.rb#448
  def read_response(method); end

  # Read the body of the response.
  #
  # - The `HEAD` method is used to retrieve the headers of the response without the body, so {read_head_body} is invoked if there is a content length, otherwise nil is returned.
  # - A 101 status code indicates that the connection will be upgraded, so {read_upgrade_body} is invoked.
  # - Interim status codes (1xx), no content (204) and not modified (304) status codes do not have a body, so nil is returned.
  # - The `CONNECT` method is used to establish a tunnel, so {read_tunnel_body} is invoked.
  # - Otherwise, the body is read according to {read_body}.
  #
  # source://protocol-http1//lib/protocol/http1/connection.rb#875
  def read_response_body(method, status, headers); end

  # Read a response line from the connection.
  #
  # source://protocol-http1//lib/protocol/http1/connection.rb#425
  def read_response_line; end

  # Read the body, assuming it is a tunnel.
  #
  # Invokes {read_remainder_body}.
  #
  # source://protocol-http1//lib/protocol/http1/connection.rb#824
  def read_tunnel_body; end

  # Read the body, assuming it is an upgrade.
  #
  # Invokes {read_remainder_body}.
  #
  # source://protocol-http1//lib/protocol/http1/connection.rb#833
  def read_upgrade_body; end

  # Read some data from the connection.
  #
  # source://protocol-http1//lib/protocol/http1/connection.rb#335
  def readpartial(length); end

  # Indicate that the end of the stream (body) has been received.
  #
  # This will transition to the half-closed remote state if the connection is open, or the closed state if the connection is half-closed local.
  #
  # source://protocol-http1//lib/protocol/http1/connection.rb#774
  def receive_end_stream!; end

  # Transition to the half-closed local state, in other words, the connection is closed for writing.
  #
  # If the connection is already in the half-closed remote state, it will transition to the closed state.
  #
  # source://protocol-http1//lib/protocol/http1/connection.rb#505
  def send_end_stream!; end

  # The current state of the connection.
  #
  # ```
  #                          ┌────────┐
  #                          │        │
  # ┌───────────────────────►│  idle  │
  # │                        │        │
  # │                        └───┬────┘
  # │                            │
  # │                            │ send request /
  # │                            │ receive request
  # │                            │
  # │                            ▼
  # │                        ┌────────┐
  # │                recv ES │        │ send ES
  # │           ┌────────────┤  open  ├────────────┐
  # │           │            │        │            │
  # │           ▼            └───┬────┘            ▼
  # │      ┌──────────┐          │           ┌──────────┐
  # │      │   half   │          │           │   half   │
  # │      │  closed  │          │ send R /  │  closed  │
  # │      │ (remote) │          │ recv R    │ (local)  │
  # │      └────┬─────┘          │           └─────┬────┘
  # │           │                │                 │
  # │           │ send ES /      │       recv ES / │
  # │           │ close          ▼           close │
  # │           │            ┌────────┐            │
  # │           └───────────►│        │◄───────────┘
  # │                        │ closed │
  # └────────────────────────┤        │
  #         persistent       └────────┘
  # ```
  #
  # - `ES`: the body was fully received or sent (end of stream).
  # - `R`: the connection was closed unexpectedly (reset).
  #
  # State transition methods use a trailing "!".
  #
  # source://protocol-http1//lib/protocol/http1/connection.rb#121
  def state; end

  # The current state of the connection.
  #
  # ```
  #                          ┌────────┐
  #                          │        │
  # ┌───────────────────────►│  idle  │
  # │                        │        │
  # │                        └───┬────┘
  # │                            │
  # │                            │ send request /
  # │                            │ receive request
  # │                            │
  # │                            ▼
  # │                        ┌────────┐
  # │                recv ES │        │ send ES
  # │           ┌────────────┤  open  ├────────────┐
  # │           │            │        │            │
  # │           ▼            └───┬────┘            ▼
  # │      ┌──────────┐          │           ┌──────────┐
  # │      │   half   │          │           │   half   │
  # │      │  closed  │          │ send R /  │  closed  │
  # │      │ (remote) │          │ recv R    │ (local)  │
  # │      └────┬─────┘          │           └─────┬────┘
  # │           │                │                 │
  # │           │ send ES /      │       recv ES / │
  # │           │ close          ▼           close │
  # │           │            ┌────────┐            │
  # │           └───────────►│        │◄───────────┘
  # │                        │ closed │
  # └────────────────────────┤        │
  #         persistent       └────────┘
  # ```
  #
  # - `ES`: the body was fully received or sent (end of stream).
  # - `R`: the connection was closed unexpectedly (reset).
  #
  # State transition methods use a trailing "!".
  #
  # source://protocol-http1//lib/protocol/http1/connection.rb#121
  def state=(_arg0); end

  # The underlying IO stream.
  #
  # source://protocol-http1//lib/protocol/http1/connection.rb#77
  def stream; end

  # Write a body to the connection.
  #
  # The behavior of this method is determined by the HTTP version, the body, and the request method. We try to choose the best approach possible, given the constraints, connection persistence, whether the length is known, etc.
  #
  # source://protocol-http1//lib/protocol/http1/connection.rb#738
  def write_body(version, body, head = T.unsafe(nil), trailer = T.unsafe(nil)); end

  # Write the body to the connection and close the connection.
  #
  # source://protocol-http1//lib/protocol/http1/connection.rb#683
  def write_body_and_close(body, head); end

  # Write a chunked body to the connection.
  #
  # If the request was a `HEAD` request, the body will be closed, and no data will be written.
  #
  # If trailers are given, they will be written after the body.
  #
  # source://protocol-http1//lib/protocol/http1/connection.rb#643
  def write_chunked_body(body, head, trailer = T.unsafe(nil)); end

  # Write the appropriate header for connection persistence.
  #
  # source://protocol-http1//lib/protocol/http1/connection.rb#178
  def write_connection_header(version); end

  # Write an empty body to the connection.
  #
  # If given, the body will be closed.
  #
  # source://protocol-http1//lib/protocol/http1/connection.rb#583
  def write_empty_body(body = T.unsafe(nil)); end

  # Write a fixed length body to the connection.
  #
  # If the request was a `HEAD` request, the body will be closed, and no data will be written.
  #
  # source://protocol-http1//lib/protocol/http1/connection.rb#600
  def write_fixed_length_body(body, length, head); end

  # Write headers to the connection.
  #
  # source://protocol-http1//lib/protocol/http1/connection.rb#312
  def write_headers(headers); end

  # Write an interim response to the connection. It is expected you will eventually write the final response after this method.
  #
  # source://protocol-http1//lib/protocol/http1/connection.rb#295
  def write_interim_response(version, status, headers, reason = T.unsafe(nil)); end

  # Write a request to the connection. It is expected you will write the body after this method.
  #
  # Transitions to the open state.
  #
  # source://protocol-http1//lib/protocol/http1/connection.rb#262
  def write_request(authority, method, target, version, headers); end

  # Write a response to the connection. It is expected you will write the body after this method.
  #
  # source://protocol-http1//lib/protocol/http1/connection.rb#277
  def write_response(version, status, headers, reason = T.unsafe(nil)); end

  # Write a tunnel body to the connection.
  #
  # This writes the connection header and the body to the connection. If the body is `nil`, you should coordinate writing to the stream.
  #
  # The connection will not be persistent after this method is called.
  #
  # source://protocol-http1//lib/protocol/http1/connection.rb#556
  def write_tunnel_body(version, body = T.unsafe(nil)); end

  # Write an upgrade body to the connection.
  #
  # This writes the upgrade header and the body to the connection. If the body is `nil`, you should coordinate writing to the stream.
  #
  # The connection will not be persistent after this method is called.
  #
  # source://protocol-http1//lib/protocol/http1/connection.rb#524
  def write_upgrade_body(protocol, body = T.unsafe(nil)); end

  # Write the appropriate header for connection upgrade.
  #
  # source://protocol-http1//lib/protocol/http1/connection.rb#187
  def write_upgrade_header(upgrade); end
end

# The HTTP `CONNECT` method.
#
# source://protocol-http1//lib/protocol/http1/connection.rb#843
Protocol::HTTP1::Connection::CONNECT = T.let(T.unsafe(nil), String)

# source://protocol-http1//lib/protocol/http1/connection.rb#52
Protocol::HTTP1::Connection::CRLF = T.let(T.unsafe(nil), String)

# The HTTP `HEAD` method.
#
# source://protocol-http1//lib/protocol/http1/connection.rb#840
Protocol::HTTP1::Connection::HEAD = T.let(T.unsafe(nil), String)

# The HTTP/1.0 version string.
#
# source://protocol-http1//lib/protocol/http1/connection.rb#55
Protocol::HTTP1::Connection::HTTP10 = T.let(T.unsafe(nil), String)

# The HTTP/1.1 version string.
#
# source://protocol-http1//lib/protocol/http1/connection.rb#58
Protocol::HTTP1::Connection::HTTP11 = T.let(T.unsafe(nil), String)

# The pattern for valid content length values.
#
# source://protocol-http1//lib/protocol/http1/connection.rb#846
Protocol::HTTP1::Connection::VALID_CONTENT_LENGTH = T.let(T.unsafe(nil), Regexp)

# The specified content length and the given content's length do not match.
#
# source://protocol-http1//lib/protocol/http1/error.rb#35
class Protocol::HTTP1::ContentLengthError < ::Protocol::HTTP1::Error; end

# source://protocol-http1//lib/protocol/http1/connection.rb#48
Protocol::HTTP1::DEFAULT_MAXIMUM_LINE_LENGTH = T.let(T.unsafe(nil), Integer)

# The base class for all HTTP/1.x errors.
#
# source://protocol-http1//lib/protocol/http1/error.rb#11
class Protocol::HTTP1::Error < ::Protocol::HTTP::Error; end

# HTTP/1.x header parser:
#
# source://protocol-http1//lib/protocol/http1/connection.rb#39
Protocol::HTTP1::FIELD_NAME = T.let(T.unsafe(nil), Regexp)

# A field value is any string of characters that does not contain a null character, CR, or LF. After reflecting on the RFCs and surveying real implementations, I came to the conclusion that the RFCs are too restrictive. Most servers only check for the presence of null bytes, and obviously CR/LF characters have semantic meaning in the parser. So, I decided to follow this defacto standard, even if I'm not entirely happy with it.
#
# source://protocol-http1//lib/protocol/http1/connection.rb#42
Protocol::HTTP1::FIELD_VALUE = T.let(T.unsafe(nil), Regexp)

# source://protocol-http1//lib/protocol/http1/connection.rb#43
Protocol::HTTP1::HEADER = T.let(T.unsafe(nil), Regexp)

# source://protocol-http1//lib/protocol/http1/connection.rb#31
Protocol::HTTP1::HOST = T.let(T.unsafe(nil), String)

# Indicates that the request is invalid for some reason, e.g. syntax error, invalid headers, etc.
#
# source://protocol-http1//lib/protocol/http1/error.rb#31
class Protocol::HTTP1::InvalidRequest < ::Protocol::HTTP1::BadRequest; end

# source://protocol-http1//lib/protocol/http1/connection.rb#29
Protocol::HTTP1::KEEP_ALIVE = T.let(T.unsafe(nil), String)

# The request line was too long.
#
# source://protocol-http1//lib/protocol/http1/error.rb#19
class Protocol::HTTP1::LineLengthError < ::Protocol::HTTP1::Error; end

# source://protocol-http1//lib/protocol/http1/connection.rb#40
Protocol::HTTP1::OWS = T.let(T.unsafe(nil), Regexp)

# The protocol was violated in some way, e.g. trying to write a request while reading a response.
#
# source://protocol-http1//lib/protocol/http1/error.rb#15
class Protocol::HTTP1::ProtocolError < ::Protocol::HTTP1::Error; end

# source://protocol-http1//lib/protocol/http1/connection.rb#36
Protocol::HTTP1::REQUEST_LINE = T.let(T.unsafe(nil), Regexp)

# Reason phrases for HTTP status codes.
#
# source://protocol-http1//lib/protocol/http1/reason.rb#11
module Protocol::HTTP1::Reason; end

# Get the reason phrase for the given status code.
#
# source://protocol-http1//lib/protocol/http1/reason.rb#13
Protocol::HTTP1::Reason::DESCRIPTIONS = T.let(T.unsafe(nil), Hash)

# HTTP/1.x request line parser:
#
# source://protocol-http1//lib/protocol/http1/connection.rb#35
Protocol::HTTP1::TOKEN = T.let(T.unsafe(nil), Regexp)

# source://protocol-http1//lib/protocol/http1/connection.rb#24
Protocol::HTTP1::TRANSFER_ENCODING = T.let(T.unsafe(nil), String)

# source://protocol-http1//lib/protocol/http1/connection.rb#32
Protocol::HTTP1::UPGRADE = T.let(T.unsafe(nil), String)

# source://protocol-http1//lib/protocol/http1/connection.rb#45
Protocol::HTTP1::VALID_FIELD_NAME = T.let(T.unsafe(nil), Regexp)

# source://protocol-http1//lib/protocol/http1/connection.rb#46
Protocol::HTTP1::VALID_FIELD_VALUE = T.let(T.unsafe(nil), Regexp)

# source://protocol-http1//lib/protocol/http1/version.rb#8
Protocol::HTTP1::VERSION = T.let(T.unsafe(nil), String)
