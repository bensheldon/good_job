# typed: false

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `rubocop-rails` gem.
# Please instead update this file by running `bin/tapioca gem rubocop-rails`.

module RuboCop; end
module RuboCop::Cop; end

# A mixin to extend cops for Active Record features
module RuboCop::Cop::ActiveRecordHelper
  extend ::RuboCop::AST::NodePattern::Macros

  def active_record?(param0 = T.unsafe(nil)); end
  def external_dependency_checksum; end
  def find_belongs_to(param0); end
  def find_set_table_name(param0); end
  def foreign_key_of(belongs_to); end

  # @return [Boolean]
  def in_where?(node); end

  # @return [Boolean]
  def inherit_active_record_base?(node); end

  # @return [Boolean]
  def polymorphic?(belongs_to); end

  # Resolve relation into column name.
  # It just returns column_name if the column exists.
  # Or it tries to resolve column_name as a relation.
  # Returns an array of column names if the relation is polymorphic.
  # It returns `nil` if it can't resolve.
  #
  # @param name [String]
  # @param class_node [RuboCop::AST::Node]
  # @param table [RuboCop::Rails::SchemaLoader::Table]
  # @return [Array, String, nil]
  def resolve_relation_into_column(name:, class_node:, table:); end

  def schema; end
  def table_name(class_node); end
end

RuboCop::Cop::ActiveRecordHelper::WHERE_METHODS = T.let(T.unsafe(nil), Array)

# A mixin to extend cops for Active Record features
module RuboCop::Cop::ActiveRecordMigrationsHelper
  extend ::RuboCop::AST::NodePattern::Macros

  def create_table_with_block?(param0 = T.unsafe(nil)); end
end

RuboCop::Cop::ActiveRecordMigrationsHelper::MYSQL_SCHEMA_DEFINITIONS = T.let(T.unsafe(nil), Array)
RuboCop::Cop::ActiveRecordMigrationsHelper::POSTGRES_SCHEMA_DEFINITIONS = T.let(T.unsafe(nil), Array)
RuboCop::Cop::ActiveRecordMigrationsHelper::RAILS_ABSTRACT_SCHEMA_DEFINITIONS = T.let(T.unsafe(nil), Array)
RuboCop::Cop::ActiveRecordMigrationsHelper::RAILS_ABSTRACT_SCHEMA_DEFINITIONS_HELPERS = T.let(T.unsafe(nil), Array)

# A mixin to return all of the class send nodes.
module RuboCop::Cop::ClassSendNodeHelper
  def class_send_nodes(class_node); end
end

# Common functionality for enforcing a specific superclass.
module RuboCop::Cop::EnforceSuperclass
  # @api private
  def on_class(node); end

  # @api private
  def on_send(node); end

  private

  def register_offense(offense_node); end

  class << self
    # @api private
    # @private
    # @private
    def included(base); end
  end
end

# @deprecated IgnoredPattern class has been replaced with AllowedPattern.
RuboCop::Cop::IgnoredPattern = RuboCop::Cop::AllowedPattern

# Common functionality for Rails/IndexBy and Rails/IndexWith
module RuboCop::Cop::IndexMethod
  def on_block(node); end
  def on_csend(node); end
  def on_send(node); end

  private

  def execute_correction(corrector, node, correction); end
  def extract_captures(match); end
  def handle_possible_offense(node, match, match_desc); end

  # @raise [NotImplementedError]
  def new_method_name; end

  # @abstract Implemented with `def_node_matcher`
  # @raise [NotImplementedError]
  def on_bad_each_with_object(_node); end

  # @abstract Implemented with `def_node_matcher`
  # @raise [NotImplementedError]
  def on_bad_hash_brackets_map(_node); end

  # @abstract Implemented with `def_node_matcher`
  # @raise [NotImplementedError]
  def on_bad_map_to_h(_node); end

  # @abstract Implemented with `def_node_matcher`
  # @raise [NotImplementedError]
  def on_bad_to_h(_node); end

  def prepare_correction(node); end
end

# Internal helper class to hold autocorrect data
class RuboCop::Cop::IndexMethod::Autocorrection < ::Struct
  # Returns the value of attribute block_node
  #
  # @return [Object] the current value of block_node
  def block_node; end

  # Sets the attribute block_node
  #
  # @param value [Object] the value to set the attribute block_node to.
  # @return [Object] the newly set value
  def block_node=(_); end

  # Returns the value of attribute leading
  #
  # @return [Object] the current value of leading
  def leading; end

  # Sets the attribute leading
  #
  # @param value [Object] the value to set the attribute leading to.
  # @return [Object] the newly set value
  def leading=(_); end

  # Returns the value of attribute match
  #
  # @return [Object] the current value of match
  def match; end

  # Sets the attribute match
  #
  # @param value [Object] the value to set the attribute match to.
  # @return [Object] the newly set value
  def match=(_); end

  def set_new_arg_name(transformed_argname, corrector); end
  def set_new_body_expression(transforming_body_expr, corrector); end
  def set_new_method_name(new_method_name, corrector); end
  def strip_prefix_and_suffix(node, corrector); end

  # Returns the value of attribute trailing
  #
  # @return [Object] the current value of trailing
  def trailing; end

  # Sets the attribute trailing
  #
  # @param value [Object] the value to set the attribute trailing to.
  # @return [Object] the newly set value
  def trailing=(_); end

  class << self
    def [](*_arg0); end
    def from_each_with_object(node, match); end
    def from_hash_brackets_map(node, match); end
    def from_map_to_h(node, match); end
    def from_to_h(node, match); end
    def inspect; end
    def members; end
    def new(*_arg0); end
  end
end

# Internal helper class to hold match data
class RuboCop::Cop::IndexMethod::Captures < ::Struct
  # @return [Boolean]
  def noop_transformation?; end

  # Returns the value of attribute transformed_argname
  #
  # @return [Object] the current value of transformed_argname
  def transformed_argname; end

  # Sets the attribute transformed_argname
  #
  # @param value [Object] the value to set the attribute transformed_argname to.
  # @return [Object] the newly set value
  def transformed_argname=(_); end

  # Returns the value of attribute transforming_body_expr
  #
  # @return [Object] the current value of transforming_body_expr
  def transforming_body_expr; end

  # Sets the attribute transforming_body_expr
  #
  # @param value [Object] the value to set the attribute transforming_body_expr to.
  # @return [Object] the newly set value
  def transforming_body_expr=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def members; end
    def new(*_arg0); end
  end
end

RuboCop::Cop::IndexMethod::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Common functionality for cops working with migrations
module RuboCop::Cop::MigrationsHelper
  extend ::RuboCop::AST::NodePattern::Macros

  # @return [Boolean]
  def in_migration?(node); end

  def migration_class?(param0 = T.unsafe(nil)); end
end

module RuboCop::Cop::Rails; end

# Using `ActionController::TestCase`` is discouraged and should be replaced by
# `ActionDispatch::IntegrationTest``. Controller tests are too close to the
# internals of a controller whereas integration tests mimic the browser/user.
#
# @example
#   # bad
#   class MyControllerTest < ActionController::TestCase
#   end
#
#   # good
#   class MyControllerTest < ActionDispatch::IntegrationTest
#   end
class RuboCop::Cop::Rails::ActionControllerTestCase < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector
  extend ::RuboCop::Cop::TargetRailsVersion

  def action_controller_test_case?(param0 = T.unsafe(nil)); end
  def on_class(node); end
end

RuboCop::Cop::Rails::ActionControllerTestCase::MSG = T.let(T.unsafe(nil), String)

# This cop enforces the consistent use of action filter methods.
#
# The cop is configurable and can enforce the use of the older
# something_filter methods or the newer something_action methods.
#
# @example EnforcedStyle: action (default)
#   # bad
#   after_filter :do_stuff
#   append_around_filter :do_stuff
#   skip_after_filter :do_stuff
#
#   # good
#   after_action :do_stuff
#   append_around_action :do_stuff
#   skip_after_action :do_stuff
# @example EnforcedStyle: filter
#   # bad
#   after_action :do_stuff
#   append_around_action :do_stuff
#   skip_after_action :do_stuff
#
#   # good
#   after_filter :do_stuff
#   append_around_filter :do_stuff
#   skip_after_filter :do_stuff
class RuboCop::Cop::Rails::ActionFilter < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  extend ::RuboCop::Cop::AutoCorrector

  def on_block(node); end
  def on_send(node); end

  private

  def bad_methods; end
  def check_method_node(node); end
  def good_methods; end
  def preferred_method(method); end
end

RuboCop::Cop::Rails::ActionFilter::ACTION_METHODS = T.let(T.unsafe(nil), Array)
RuboCop::Cop::Rails::ActionFilter::FILTER_METHODS = T.let(T.unsafe(nil), Array)
RuboCop::Cop::Rails::ActionFilter::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Rails::ActionFilter::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Checks that ActiveRecord aliases are not used. The direct method names
# are more clear and easier to read.
#
# @example
#   #bad
#   book.update_attributes!(author: 'Alice')
#
#   #good
#   book.update!(author: 'Alice')
class RuboCop::Cop::Rails::ActiveRecordAliases < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  def on_csend(node); end
  def on_send(node); end
end

RuboCop::Cop::Rails::ActiveRecordAliases::ALIASES = T.let(T.unsafe(nil), Hash)
RuboCop::Cop::Rails::ActiveRecordAliases::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Rails::ActiveRecordAliases::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# This cop checks that Active Record callbacks are declared
# in the order in which they will be executed.
#
# @example
#   # bad
#   class Person < ApplicationRecord
#   after_commit :after_commit_callback
#   before_validation :before_validation_callback
#   end
#
#   # good
#   class Person < ApplicationRecord
#   before_validation :before_validation_callback
#   after_commit :after_commit_callback
#   end
class RuboCop::Cop::Rails::ActiveRecordCallbacksOrder < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  def on_class(class_node); end

  private

  # Autocorrect by swapping between two nodes autocorrecting them
  def autocorrect(corrector, node); end

  def begin_pos_with_comment(node); end
  def buffer; end

  # @return [Boolean]
  def callback?(node); end

  def defined_callbacks(class_node); end
  def end_position_for(node); end

  # @return [Boolean]
  def inline_comment?(comment); end

  def source_range_with_comment(node); end
  def start_line_position(node); end
end

RuboCop::Cop::Rails::ActiveRecordCallbacksOrder::CALLBACKS_IN_ORDER = T.let(T.unsafe(nil), Array)
RuboCop::Cop::Rails::ActiveRecordCallbacksOrder::CALLBACKS_ORDER_MAP = T.let(T.unsafe(nil), Hash)
RuboCop::Cop::Rails::ActiveRecordCallbacksOrder::MSG = T.let(T.unsafe(nil), String)

# Checks for overriding built-in Active Record methods instead of using
# callbacks.
#
# @example
#   # bad
#   class Book < ApplicationRecord
#   def save
#   self.title = title.upcase!
#   super
#   end
#   end
#
#   # good
#   class Book < ApplicationRecord
#   before_save :upcase_title
#
#   def upcase_title
#   self.title = title.upcase!
#   end
#   end
class RuboCop::Cop::Rails::ActiveRecordOverride < ::RuboCop::Cop::Base
  def on_def(node); end

  private

  # @return [Boolean]
  def active_model?(parent_class_name); end

  def callback_names(method_name); end
  def find_parent_class_name(node); end
  def message(method_name); end
end

RuboCop::Cop::Rails::ActiveRecordOverride::ACTIVE_RECORD_CLASSES = T.let(T.unsafe(nil), Array)
RuboCop::Cop::Rails::ActiveRecordOverride::BAD_METHODS = T.let(T.unsafe(nil), Array)
RuboCop::Cop::Rails::ActiveRecordOverride::MSG = T.let(T.unsafe(nil), String)

# This cop checks that ActiveSupport aliases to core ruby methods
# are not used.
#
# @example
#   # good
#   'some_string'.start_with?('prefix')
#   'some_string'.end_with?('suffix')
#   [1, 2, 'a'] << 'b'
#   [1, 2, 'a'].unshift('b')
#
#   # bad
#   'some_string'.starts_with?('prefix')
#   'some_string'.ends_with?('suffix')
#   [1, 2, 'a'].append('b')
#   [1, 2, 'a'].prepend('b')
class RuboCop::Cop::Rails::ActiveSupportAliases < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  def append(param0 = T.unsafe(nil)); end
  def ends_with?(param0 = T.unsafe(nil)); end
  def on_send(node); end
  def prepend(param0 = T.unsafe(nil)); end
  def starts_with?(param0 = T.unsafe(nil)); end
end

RuboCop::Cop::Rails::ActiveSupportAliases::ALIASES = T.let(T.unsafe(nil), Hash)
RuboCop::Cop::Rails::ActiveSupportAliases::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Rails::ActiveSupportAliases::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# This cop checks for migrations using `add_column` that have an `index`
# key. `add_column` does not accept `index`, but also does not raise an
# error for extra keys, so it is possible to mistakenly add the key without
# realizing it will not actually add an index.
#
# @example
#   # bad (will not add an index)
#   add_column :table, :column, :integer, index: true
#
#   # good
#   add_column :table, :column, :integer
#   add_index :table, :column
class RuboCop::Cop::Rails::AddColumnIndex < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  def add_column_with_index(param0 = T.unsafe(nil)); end
  def on_send(node); end

  private

  def index_range(pair_node); end
end

RuboCop::Cop::Rails::AddColumnIndex::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Rails::AddColumnIndex::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# This cop enforces that there is only one call to `after_commit`
# (and its aliases - `after_create_commit`, `after_update_commit`,
# and `after_destroy_commit`) with the same callback name per model.
#
# @example
#   # bad
#   # This won't be triggered.
#   after_create_commit :log_action
#
#   # This will override the callback added by
#   # after_create_commit.
#   after_update_commit :log_action
#
#   # bad
#   # This won't be triggered.
#   after_commit :log_action, on: :create
#   # This won't be triggered.
#   after_update_commit :log_action
#   # This will override both previous callbacks.
#   after_commit :log_action, on: :destroy
#
#   # good
#   after_save_commit :log_action
#
#   # good
#   after_create_commit :log_create_action
#   after_update_commit :log_update_action
class RuboCop::Cop::Rails::AfterCommitOverride < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ClassSendNodeHelper

  def on_class(class_node); end

  private

  # @return [Boolean]
  def after_commit_callback?(node); end

  def each_after_commit_callback(class_node); end

  # @return [Boolean]
  def named_callback?(node); end
end

RuboCop::Cop::Rails::AfterCommitOverride::AFTER_COMMIT_CALLBACKS = T.let(T.unsafe(nil), Array)
RuboCop::Cop::Rails::AfterCommitOverride::MSG = T.let(T.unsafe(nil), String)

# This cop checks that controllers subclass `ApplicationController`.
#
# @example
#
#   # good
#   class MyController < ApplicationController
#   # ...
#   end
#
#   # bad
#   class MyController < ActionController::Base
#   # ...
#   end
class RuboCop::Cop::Rails::ApplicationController < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::EnforceSuperclass
  extend ::RuboCop::Cop::AutoCorrector

  def class_definition(param0 = T.unsafe(nil)); end
  def class_new_definition(param0 = T.unsafe(nil)); end
end

RuboCop::Cop::Rails::ApplicationController::BASE_PATTERN = T.let(T.unsafe(nil), String)
RuboCop::Cop::Rails::ApplicationController::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Rails::ApplicationController::SUPERCLASS = T.let(T.unsafe(nil), String)

# This cop checks that jobs subclass `ApplicationJob` with Rails 5.0.
#
# @example
#
#   # good
#   class Rails5Job < ApplicationJob
#   # ...
#   end
#
#   # bad
#   class Rails4Job < ActiveJob::Base
#   # ...
#   end
class RuboCop::Cop::Rails::ApplicationJob < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::EnforceSuperclass
  extend ::RuboCop::Cop::AutoCorrector
  extend ::RuboCop::Cop::TargetRailsVersion

  def autocorrect(node); end
  def class_definition(param0 = T.unsafe(nil)); end
  def class_new_definition(param0 = T.unsafe(nil)); end
end

RuboCop::Cop::Rails::ApplicationJob::BASE_PATTERN = T.let(T.unsafe(nil), String)
RuboCop::Cop::Rails::ApplicationJob::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Rails::ApplicationJob::SUPERCLASS = T.let(T.unsafe(nil), String)

# This cop checks that mailers subclass `ApplicationMailer` with Rails 5.0.
#
# @example
#
#   # good
#   class MyMailer < ApplicationMailer
#   # ...
#   end
#
#   # bad
#   class MyMailer < ActionMailer::Base
#   # ...
#   end
class RuboCop::Cop::Rails::ApplicationMailer < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::EnforceSuperclass
  extend ::RuboCop::Cop::AutoCorrector
  extend ::RuboCop::Cop::TargetRailsVersion

  def class_definition(param0 = T.unsafe(nil)); end
  def class_new_definition(param0 = T.unsafe(nil)); end
end

RuboCop::Cop::Rails::ApplicationMailer::BASE_PATTERN = T.let(T.unsafe(nil), String)
RuboCop::Cop::Rails::ApplicationMailer::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Rails::ApplicationMailer::SUPERCLASS = T.let(T.unsafe(nil), String)

# This cop checks that models subclass `ApplicationRecord` with Rails 5.0.
#
# @example
#
#   # good
#   class Rails5Model < ApplicationRecord
#   # ...
#   end
#
#   # bad
#   class Rails4Model < ActiveRecord::Base
#   # ...
#   end
class RuboCop::Cop::Rails::ApplicationRecord < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::EnforceSuperclass
  extend ::RuboCop::Cop::AutoCorrector
  extend ::RuboCop::Cop::TargetRailsVersion

  def class_definition(param0 = T.unsafe(nil)); end
  def class_new_definition(param0 = T.unsafe(nil)); end
end

RuboCop::Cop::Rails::ApplicationRecord::BASE_PATTERN = T.let(T.unsafe(nil), String)
RuboCop::Cop::Rails::ApplicationRecord::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Rails::ApplicationRecord::SUPERCLASS = T.let(T.unsafe(nil), String)

# This cop prevents usage of `"*"` on an Arel::Table column reference.
#
# Using `arel_table["*"]` causes the outputted string to be a literal
# quoted asterisk (e.g. <tt>`my_model`.`*`</tt>). This causes the
# database to look for a column named <tt>`*`</tt> (or `"*"`) as opposed
# to expanding the column list as one would likely expect.
#
# @example
#   # bad
#   MyTable.arel_table["*"]
#
#   # good
#   MyTable.arel_table[Arel.star]
class RuboCop::Cop::Rails::ArelStar < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  def on_send(node); end
  def star_bracket?(param0 = T.unsafe(nil)); end
end

RuboCop::Cop::Rails::ArelStar::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Rails::ArelStar::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Use `assert_not` instead of `assert !`.
#
# @example
#   # bad
#   assert !x
#
#   # good
#   assert_not x
class RuboCop::Cop::Rails::AssertNot < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  def offensive?(param0 = T.unsafe(nil)); end
  def on_send(node); end

  private

  def corrected_source(source); end
end

RuboCop::Cop::Rails::AssertNot::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Rails::AssertNot::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# This cop looks for `attribute` class methods that specify a `:default` option
# which value is an array, string literal or method call without a block.
# It will accept all other values, such as string, symbol, integer and float literals
# as well as constants.
#
# @example
#   # bad
#   class User < ApplicationRecord
#   attribute :confirmed_at, :datetime, default: Time.zone.now
#   end
#
#   # good
#   class User < ApplicationRecord
#   attribute :confirmed_at, :datetime, default: -> { Time.zone.now }
#   end
#
#   # bad
#   class User < ApplicationRecord
#   attribute :roles, :string, array: true, default: []
#   end
#
#   # good
#   class User < ApplicationRecord
#   attribute :roles, :string, array: true, default: -> { [] }
#   end
#
#   # bad
#   class User < ApplicationRecord
#   attribute :configuration, default: {}
#   end
#
#   # good
#   class User < ApplicationRecord
#   attribute :configuration, default: -> { {} }
#   end
#
#   # good
#   class User < ApplicationRecord
#   attribute :role, :string, default: :customer
#   end
#
#   # good
#   class User < ApplicationRecord
#   attribute :activated, :boolean, default: false
#   end
#
#   # good
#   class User < ApplicationRecord
#   attribute :login_count, :integer, default: 0
#   end
#
#   # good
#   class User < ApplicationRecord
#   FOO = 123
#   attribute :custom_attribute, :integer, default: FOO
#   end
class RuboCop::Cop::Rails::AttributeDefaultBlockValue < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  def attribute(param0 = T.unsafe(nil)); end
  def default_attribute(param0 = T.unsafe(nil)); end
  def on_send(node); end
end

RuboCop::Cop::Rails::AttributeDefaultBlockValue::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Rails::AttributeDefaultBlockValue::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)
RuboCop::Cop::Rails::AttributeDefaultBlockValue::TYPE_OFFENDERS = T.let(T.unsafe(nil), Array)

# This cop looks for belongs_to associations where we control whether the
# association is required via the deprecated `required` option instead.
#
# Since Rails 5, belongs_to associations are required by default and this
# can be controlled through the use of `optional: true`.
#
# From the release notes:
#
#     belongs_to will now trigger a validation error by default if the
#     association is not present. You can turn this off on a
#     per-association basis with optional: true. Also deprecate required
#     option in favor of optional for belongs_to. (Pull Request)
#
# In the case that the developer is doing `required: false`, we
# definitely want to autocorrect to `optional: true`.
#
# However, without knowing whether they've set overridden the default
# value of `config.active_record.belongs_to_required_by_default`, we
# can't say whether it's safe to remove `required: true` or whether we
# should replace it with `optional: false` (or, similarly, remove a
# superfluous `optional: false`). Therefore, in the cases we're using
# `required: true`, we'll simply invert it to `optional: false` and the
# user can remove depending on their defaults.
#
# @example
#   # bad
#   class Post < ApplicationRecord
#   belongs_to :blog, required: false
#   end
#
#   # good
#   class Post < ApplicationRecord
#   belongs_to :blog, optional: true
#   end
#
#   # bad
#   class Post < ApplicationRecord
#   belongs_to :blog, required: true
#   end
#
#   # good
#   class Post < ApplicationRecord
#   belongs_to :blog, optional: false
#   end
# @see https://guides.rubyonrails.org/5_0_release_notes.html
# @see https://github.com/rails/rails/pull/18937
class RuboCop::Cop::Rails::BelongsTo < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector
  extend ::RuboCop::Cop::TargetRailsVersion

  def match_belongs_to_with_options(param0 = T.unsafe(nil)); end
  def on_send(node); end
end

RuboCop::Cop::Rails::BelongsTo::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)
RuboCop::Cop::Rails::BelongsTo::SUPERFLOUS_REQUIRE_FALSE_MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Rails::BelongsTo::SUPERFLOUS_REQUIRE_TRUE_MSG = T.let(T.unsafe(nil), String)

# This cop checks for code that can be written with simpler conditionals
# using `Object#blank?` defined by Active Support.
#
# Interaction with `Style/UnlessElse`:
# The configuration of `NotPresent` will not produce an offense in the
# context of `unless else` if `Style/UnlessElse` is inabled. This is
# to prevent interference between the auto-correction of the two cops.
#
# @example NilOrEmpty: true (default)
#   # Converts usages of `nil? || empty?` to `blank?`
#
#   # bad
#   foo.nil? || foo.empty?
#   foo == nil || foo.empty?
#
#   # good
#   foo.blank?
# @example NotPresent: true (default)
#   # Converts usages of `!present?` to `blank?`
#
#   # bad
#   !foo.present?
#
#   # good
#   foo.blank?
# @example UnlessPresent: true (default)
#   # Converts usages of `unless present?` to `if blank?`
#
#   # bad
#   something unless foo.present?
#
#   # good
#   something if foo.blank?
#
#   # bad
#   unless foo.present?
#   something
#   end
#
#   # good
#   if foo.blank?
#   something
#   end
#
#   # good
#   def blank?
#   !present?
#   end
class RuboCop::Cop::Rails::Blank < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  def defining_blank?(param0 = T.unsafe(nil)); end
  def nil_or_empty?(param0 = T.unsafe(nil)); end
  def not_present?(param0 = T.unsafe(nil)); end
  def on_if(node); end
  def on_or(node); end
  def on_send(node); end
  def unless_present?(param0 = T.unsafe(nil)); end

  private

  def autocorrect(corrector, node); end
  def replacement(node); end
  def unless_condition(node, method_call); end
end

RuboCop::Cop::Rails::Blank::MSG_NIL_OR_EMPTY = T.let(T.unsafe(nil), String)
RuboCop::Cop::Rails::Blank::MSG_NOT_PRESENT = T.let(T.unsafe(nil), String)
RuboCop::Cop::Rails::Blank::MSG_UNLESS_PRESENT = T.let(T.unsafe(nil), String)
RuboCop::Cop::Rails::Blank::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# This Cop checks whether alter queries are combinable.
# If combinable queries are detected, it suggests to you
# to use `change_table` with `bulk: true` instead.
# This option causes the migration to generate a single
# ALTER TABLE statement combining multiple column alterations.
#
# The `bulk` option is only supported on the MySQL and
# the PostgreSQL (5.2 later) adapter; thus it will
# automatically detect an adapter from `development` environment
# in `config/database.yml` when the `Database` option is not set.
# If the adapter is not `mysql2` or `postgresql`,
# this Cop ignores offenses.
#
# @example
#   # bad
#   def change
#   add_column :users, :name, :string, null: false
#   add_column :users, :nickname, :string
#
#   # ALTER TABLE `users` ADD `name` varchar(255) NOT NULL
#   # ALTER TABLE `users` ADD `nickname` varchar(255)
#   end
#
#   # good
#   def change
#   change_table :users, bulk: true do |t|
#   t.string :name, null: false
#   t.string :nickname
#   end
#
#   # ALTER TABLE `users` ADD `name` varchar(255) NOT NULL,
#   #                     ADD `nickname` varchar(255)
#   end
# @example
#   # bad
#   def change
#   change_table :users do |t|
#   t.string :name, null: false
#   t.string :nickname
#   end
#   end
#
#   # good
#   def change
#   change_table :users, bulk: true do |t|
#   t.string :name, null: false
#   t.string :nickname
#   end
#   end
#
#   # good
#   # When you don't want to combine alter queries.
#   def change
#   change_table :users, bulk: false do |t|
#   t.string :name, null: false
#   t.string :nickname
#   end
#   end
# @see https://api.rubyonrails.org/classes/ActiveRecord/ConnectionAdapters/SchemaStatements.html#method-i-change_table
# @see https://api.rubyonrails.org/classes/ActiveRecord/ConnectionAdapters/Table.html
class RuboCop::Cop::Rails::BulkChangeTable < ::RuboCop::Cop::Base
  def on_def(node); end
  def on_send(node); end

  private

  # @param node [RuboCop::AST::SendNode]
  def add_offense_for_alter_methods(node); end

  # @param node [RuboCop::AST::SendNode]
  def add_offense_for_change_table(node); end

  # @return [Boolean]
  def call_to_combinable_alter_method?(child_node); end

  def combinable_alter_methods; end
  def combinable_transformations; end
  def count_transformations(send_nodes); end
  def database; end
  def database_from_yaml; end
  def database_yaml; end

  # @param node [RuboCop::AST::SendNode] (send nil? :change_table ...)
  # @return [Boolean]
  def include_bulk_options?(node); end

  def send_nodes_from_change_table_block(body); end

  # @return [Boolean]
  def support_bulk_alter?; end
end

# Record combinable alter methods and register offensive nodes.
class RuboCop::Cop::Rails::BulkChangeTable::AlterMethodsRecorder
  # @return [AlterMethodsRecorder] a new instance of AlterMethodsRecorder
  def initialize; end

  def flush; end
  def offensive_nodes; end

  # @param new_node [RuboCop::AST::SendNode]
  def process(new_node); end
end

RuboCop::Cop::Rails::BulkChangeTable::COMBINABLE_ALTER_METHODS = T.let(T.unsafe(nil), Array)
RuboCop::Cop::Rails::BulkChangeTable::COMBINABLE_TRANSFORMATIONS = T.let(T.unsafe(nil), Array)
RuboCop::Cop::Rails::BulkChangeTable::MIGRATION_METHODS = T.let(T.unsafe(nil), Array)
RuboCop::Cop::Rails::BulkChangeTable::MSG_FOR_ALTER_METHODS = T.let(T.unsafe(nil), String)
RuboCop::Cop::Rails::BulkChangeTable::MSG_FOR_CHANGE_TABLE = T.let(T.unsafe(nil), String)
RuboCop::Cop::Rails::BulkChangeTable::MYSQL = T.let(T.unsafe(nil), String)
RuboCop::Cop::Rails::BulkChangeTable::MYSQL_COMBINABLE_ALTER_METHODS = T.let(T.unsafe(nil), Array)
RuboCop::Cop::Rails::BulkChangeTable::MYSQL_COMBINABLE_TRANSFORMATIONS = T.let(T.unsafe(nil), Array)
RuboCop::Cop::Rails::BulkChangeTable::POSTGRESQL = T.let(T.unsafe(nil), String)
RuboCop::Cop::Rails::BulkChangeTable::POSTGRESQL_COMBINABLE_ALTER_METHODS = T.let(T.unsafe(nil), Array)
RuboCop::Cop::Rails::BulkChangeTable::POSTGRESQL_COMBINABLE_TRANSFORMATIONS = T.let(T.unsafe(nil), Array)

# Checks if collection can be blank-compacted with `compact_blank`.
#
# @example
#
#   # bad
#   collection.reject(&:blank?)
#   collection.reject { |_k, v| v.blank? }
#
#   # good
#   collection.compact_blank
#
#   # bad
#   collection.delete_if(&:blank?)            # Same behavior as `Array#compact_blank!` and `Hash#compact_blank!`
#   collection.delete_if { |_k, v| v.blank? } # Same behavior as `Array#compact_blank!` and `Hash#compact_blank!`
#   collection.reject!(&:blank?)              # Same behavior as `ActionController::Parameters#compact_blank!`
#   collection.reject! { |_k, v| v.blank? }   # Same behavior as `ActionController::Parameters#compact_blank!`
#
#   # good
#   collection.compact_blank!
class RuboCop::Cop::Rails::CompactBlank < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector
  extend ::RuboCop::Cop::TargetRailsVersion

  def on_send(node); end
  def reject_with_block?(param0 = T.unsafe(nil)); end
  def reject_with_block_pass?(param0 = T.unsafe(nil)); end

  private

  # @return [Boolean]
  def bad_method?(node); end

  def offense_range(node); end
  def preferred_method(node); end

  # @return [Boolean]
  def use_hash_value_block_argument?(arguments, receiver_in_block); end

  # @return [Boolean]
  def use_single_value_block_argument?(arguments, receiver_in_block); end
end

RuboCop::Cop::Rails::CompactBlank::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Rails::CompactBlank::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# This cop checks legacy syntax usage of `tag`
#
# NOTE: Allow `tag` when the first argument is a variable because
# `tag(name)` is simpler rather than `tag.public_send(name)`.
# And this cop will be renamed to something like `LegacyTag` in the future. (e.g. RuboCop Rails 2.0)
#
# @example
#   # bad
#   tag(:p)
#   tag(:br, class: 'classname')
#
#   # good
#   tag.p
#   tag.br(class: 'classname')
#   tag(name, class: 'classname')
class RuboCop::Cop::Rails::ContentTag < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector
  extend ::RuboCop::Cop::TargetRailsVersion

  def on_new_investigation; end
  def on_send(node); end

  private

  # @return [Boolean]
  def allowed_argument?(argument); end

  # @return [Boolean]
  def allowed_name?(argument); end

  def autocorrect(corrector, node, preferred_method); end

  # @return [Boolean]
  def corrected_ancestor?(node); end

  def correction_range(node); end
  def register_offense(node, message, preferred_method); end
end

RuboCop::Cop::Rails::ContentTag::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Rails::ContentTag::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# This cop checks the migration for which timestamps are not included
# when creating a new table.
# In many cases, timestamps are useful information and should be added.
#
# @example
#   # bad
#   create_table :users
#
#   # bad
#   create_table :users do |t|
#   t.string :name
#   t.string :email
#   end
#
#   # good
#   create_table :users do |t|
#   t.string :name
#   t.string :email
#
#   t.timestamps
#   end
#
#   # good
#   create_table :users do |t|
#   t.string :name
#   t.string :email
#
#   t.datetime :created_at, default: -> { 'CURRENT_TIMESTAMP' }
#   end
#
#   # good
#   create_table :users do |t|
#   t.string :name
#   t.string :email
#
#   t.datetime :updated_at, default: -> { 'CURRENT_TIMESTAMP' }
#   end
class RuboCop::Cop::Rails::CreateTableWithTimestamps < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ActiveRecordMigrationsHelper

  def create_table_with_timestamps_proc?(param0 = T.unsafe(nil)); end
  def created_at_or_updated_at_included?(param0); end
  def on_send(node); end
  def timestamps_included?(param0); end

  private

  # @return [Boolean]
  def time_columns_included?(node); end
end

RuboCop::Cop::Rails::CreateTableWithTimestamps::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Rails::CreateTableWithTimestamps::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# This cop checks for the correct use of Date methods,
# such as Date.today, Date.current etc.
#
# Using `Date.today` is dangerous, because it doesn't know anything about
# Rails time zone. You must use `Time.zone.today` instead.
#
# The cop also reports warnings when you are using `to_time` method,
# because it doesn't know about Rails time zone either.
#
# Two styles are supported for this cop. When `EnforcedStyle` is 'strict'
# then the Date methods `today`, `current`, `yesterday`, and `tomorrow`
# are prohibited and the usage of both `to_time`
# and 'to_time_in_current_zone' are reported as warning.
#
# When `EnforcedStyle` is `flexible` then only `Date.today` is prohibited.
#
# And you can set a warning for `to_time` with `AllowToTime: false`.
# `AllowToTime` is `true` by default to prevent false positive on `DateTime` object.
#
# @example EnforcedStyle: strict
#   # bad
#   Date.current
#   Date.yesterday
#   Date.today
#
#   # good
#   Time.zone.today
#   Time.zone.today - 1.day
# @example EnforcedStyle: flexible (default)
#   # bad
#   Date.today
#
#   # good
#   Time.zone.today
#   Time.zone.today - 1.day
#   Date.current
#   Date.yesterday
#   date.in_time_zone
# @example AllowToTime: true (default)
#   # good
#   date.to_time
# @example AllowToTime: false
#   # bad
#   date.to_time
class RuboCop::Cop::Rails::Date < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle

  def on_const(node); end
  def on_csend(node); end
  def on_send(node); end

  private

  # @return [Boolean]
  def allow_to_time?; end

  def bad_days; end
  def bad_methods; end
  def check_date_node(node); end
  def check_deprecated_methods(node); end
  def extract_method_chain(node); end
  def good_days; end
  def good_methods; end

  # checks that parent node of send_type
  # and receiver is the given node
  #
  # @return [Boolean]
  def method_send?(node); end

  # @return [Boolean]
  def safe_chain?(node); end

  # @return [Boolean]
  def safe_to_time?(node); end
end

RuboCop::Cop::Rails::Date::BAD_DAYS = T.let(T.unsafe(nil), Array)
RuboCop::Cop::Rails::Date::DEPRECATED_METHODS = T.let(T.unsafe(nil), Array)
RuboCop::Cop::Rails::Date::DEPRECATED_MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Rails::Date::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Rails::Date::MSG_SEND = T.let(T.unsafe(nil), String)
RuboCop::Cop::Rails::Date::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# This cop looks for uses of `default_scope`.
#
# @example
#   # bad
#   default_scope -> { where(hidden: false) }
#
#   # good
#   scope :published, -> { where(hidden: false) }
#
#   # bad
#   def self.default_scope
#   where(hidden: false)
#   end
#
#   # good
#   def self.published
#   where(hidden: false)
#   end
class RuboCop::Cop::Rails::DefaultScope < ::RuboCop::Cop::Base
  def class_method_definition?(param0 = T.unsafe(nil)); end
  def eigenclass_method_definition?(param0 = T.unsafe(nil)); end
  def method_call?(param0 = T.unsafe(nil)); end
  def on_defs(node); end
  def on_sclass(node); end
  def on_send(node); end
end

RuboCop::Cop::Rails::DefaultScope::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Rails::DefaultScope::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# This cop looks for delegations that could have been created
# automatically with the `delegate` method.
#
# Safe navigation `&.` is ignored because Rails' `allow_nil`
# option checks not just for nil but also delegates if nil
# responds to the delegated method.
#
# The `EnforceForPrefixed` option (defaulted to `true`) means that
# using the target object as a prefix of the method name
# without using the `delegate` method will be a violation.
# When set to `false`, this case is legal.
#
# @example
#   # bad
#   def bar
#   foo.bar
#   end
#
#   # good
#   delegate :bar, to: :foo
#
#   # good
#   def bar
#   foo&.bar
#   end
#
#   # good
#   private
#   def bar
#   foo.bar
#   end
# @example EnforceForPrefixed: true (default)
#   # bad
#   def foo_bar
#   foo.bar
#   end
#
#   # good
#   delegate :bar, to: :foo, prefix: true
# @example EnforceForPrefixed: false
#   # good
#   def foo_bar
#   foo.bar
#   end
#
#   # good
#   delegate :bar, to: :foo, prefix: true
class RuboCop::Cop::Rails::Delegate < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  def delegate?(param0 = T.unsafe(nil)); end
  def on_def(node); end

  private

  # @return [Boolean]
  def arguments_match?(arg_array, body); end

  # @return [Boolean]
  def include_prefix_case?; end

  # @return [Boolean]
  def method_name_matches?(method_name, body); end

  def prefixed_method_name(body); end
  def private_or_protected_before(line); end
  def private_or_protected_delegation(node); end
  def private_or_protected_inline(line); end
  def register_offense(node); end

  # @return [Boolean]
  def trivial_delegate?(def_node); end
end

RuboCop::Cop::Rails::Delegate::MSG = T.let(T.unsafe(nil), String)

# This cop looks for delegations that pass :allow_blank as an option
# instead of :allow_nil. :allow_blank is not a valid option to pass
# to ActiveSupport#delegate.
#
# @example
#   # bad
#   delegate :foo, to: :bar, allow_blank: true
#
#   # good
#   delegate :foo, to: :bar, allow_nil: true
class RuboCop::Cop::Rails::DelegateAllowBlank < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  def allow_blank_option(param0 = T.unsafe(nil)); end
  def on_send(node); end
end

RuboCop::Cop::Rails::DelegateAllowBlank::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Rails::DelegateAllowBlank::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# This cop checks direct manipulation of ActiveModel#errors as hash.
# These operations are deprecated in Rails 6.1 and will not work in Rails 7.
#
# @example
#   # bad
#   user.errors[:name] << 'msg'
#   user.errors.messages[:name] << 'msg'
#
#   # good
#   user.errors.add(:name, 'msg')
#
#   # bad
#   user.errors[:name].clear
#   user.errors.messages[:name].clear
#
#   # good
#   user.errors.delete(:name)
class RuboCop::Cop::Rails::DeprecatedActiveModelErrorsMethods < ::RuboCop::Cop::Base
  def any_manipulation?(param0 = T.unsafe(nil)); end
  def messages_details_assignment?(param0 = T.unsafe(nil)); end
  def messages_details_manipulation?(param0 = T.unsafe(nil)); end
  def on_send(node); end
  def receiver_matcher_inside_model(param0 = T.unsafe(nil)); end
  def receiver_matcher_outside_model(param0 = T.unsafe(nil)); end
  def root_assignment?(param0 = T.unsafe(nil)); end
  def root_manipulation?(param0 = T.unsafe(nil)); end

  private

  # @return [Boolean]
  def model_file?; end

  def receiver_matcher(node); end
end

RuboCop::Cop::Rails::DeprecatedActiveModelErrorsMethods::MANIPULATIVE_METHODS = T.let(T.unsafe(nil), Set)
RuboCop::Cop::Rails::DeprecatedActiveModelErrorsMethods::MSG = T.let(T.unsafe(nil), String)

# This cop looks for associations that have been defined multiple times in the same file.
#
# When an association is defined multiple times on a model, Active Record overrides the
# previously defined association with the new one. Because of this, this cop's autocorrection
# simply keeps the last of any duplicates and discards the rest.
#
# @example
#
#   # bad
#   belongs_to :foo
#   belongs_to :bar
#   has_one :foo
#
#   # good
#   belongs_to :bar
#   has_one :foo
class RuboCop::Cop::Rails::DuplicateAssociation < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::ClassSendNodeHelper
  extend ::RuboCop::Cop::AutoCorrector

  def association(param0 = T.unsafe(nil)); end
  def on_class(class_node); end

  private

  def offenses(class_node); end
end

RuboCop::Cop::Rails::DuplicateAssociation::MSG = T.let(T.unsafe(nil), String)

# This cop checks for multiple scopes in a model that have the same `where` clause. This
# often means you copy/pasted a scope, updated the name, and forgot to change the condition.
#
# @example
#
#   # bad
#   scope :visible, -> { where(visible: true) }
#   scope :hidden, -> { where(visible: true) }
#
#   # good
#   scope :visible, -> { where(visible: true) }
#   scope :hidden, -> { where(visible: false) }
class RuboCop::Cop::Rails::DuplicateScope < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ClassSendNodeHelper

  def on_class(class_node); end
  def scope(param0 = T.unsafe(nil)); end

  private

  def offenses(class_node); end
end

RuboCop::Cop::Rails::DuplicateScope::MSG = T.let(T.unsafe(nil), String)

# This cop checks if a duration is added to or subtracted from `Time.current`.
#
# @example
#   # bad
#   Time.current - 1.minute
#   Time.current + 2.days
#
#   # good - using relative would make it harder to express and read
#   Date.yesterday + 3.days
#   created_at - 1.minute
#   3.days - 1.hour
#
#   # good
#   1.minute.ago
#   2.days.from_now
class RuboCop::Cop::Rails::DurationArithmetic < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # Match a literal Duration
  #
  # @example source that matches
  #   1.hour
  # @example source that matches
  #   9.5.weeks
  # @param node [RuboCop::AST::Node]
  # @return [Boolean] true if matches
  def duration?(param0 = T.unsafe(nil)); end

  # Match duration subtraction or addition with current time.
  #
  # @example source that matches
  #   Time.current - 1.hour
  # @example source that matches
  #   ::Time.zone.now + 1.hour
  # @param node [RuboCop::AST::Node]
  # @yield operator and duration
  def duration_arithmetic_argument?(param0 = T.unsafe(nil)); end

  def on_send(node); end

  # Match Time.current
  #
  # @example source that matches
  #   Time.current
  # @example source that matches
  #   ::Time.zone.now
  # @param node [RuboCop::AST::Node]
  # @return [Boolean] true if matches
  def time_current?(param0 = T.unsafe(nil)); end

  private

  def corrected_source(operator, duration); end
end

RuboCop::Cop::Rails::DurationArithmetic::DURATIONS = T.let(T.unsafe(nil), Set)
RuboCop::Cop::Rails::DurationArithmetic::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Rails::DurationArithmetic::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# This cop checks dynamic `find_by_*` methods.
# Use `find_by` instead of dynamic method.
# See. https://rails.rubystyle.guide#find_by
#
# @example
#   # bad
#   User.find_by_name(name)
#   User.find_by_name_and_email(name)
#   User.find_by_email!(name)
#
#   # good
#   User.find_by(name: name)
#   User.find_by(name: name, email: email)
#   User.find_by!(email: email)
# @example AllowedMethods: find_by_sql
#   # bad
#   User.find_by_query(users_query)
#
#   # good
#   User.find_by_sql(users_sql)
# @example AllowedReceivers: Gem::Specification
#   # bad
#   Specification.find_by_name('backend').gem_dir
#
#   # good
#   Gem::Specification.find_by_name('backend').gem_dir
class RuboCop::Cop::Rails::DynamicFindBy < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ActiveRecordHelper
  extend ::RuboCop::Cop::AutoCorrector

  def on_csend(node); end
  def on_send(node); end

  private

  # @return [Boolean]
  def allowed_invocation?(node); end

  # @return [Boolean]
  def allowed_method?(node); end

  # @return [Boolean]
  def allowed_receiver?(node); end

  def autocorrect(corrector, node); end
  def autocorrect_argument_keywords(corrector, node, keywords); end
  def autocorrect_method_name(corrector, node); end
  def column_keywords(method); end

  # Returns static method name.
  # If code isn't wrong, returns nil
  def static_method_name(method_name); end

  # config option `WhiteList` will be deprecated soon
  #
  # @return [Boolean]
  def whitelisted?(node); end
end

RuboCop::Cop::Rails::DynamicFindBy::IGNORED_ARGUMENT_TYPES = T.let(T.unsafe(nil), Array)
RuboCop::Cop::Rails::DynamicFindBy::METHOD_PATTERN = T.let(T.unsafe(nil), Regexp)
RuboCop::Cop::Rails::DynamicFindBy::MSG = T.let(T.unsafe(nil), String)

# This cop checks that blocks are used for interpolated strings passed to
# `Rails.logger.debug`.
#
# By default, Rails production environments use the `:info` log level.
# At the `:info` log level, `Rails.logger.debug` statements do not result
# in log output. However, Ruby must eagerly evaluate interpolated string
# arguments passed as method arguments. Passing a block to
# `Rails.logger.debug` prevents costly evaluation of interpolated strings
# when no output would be produced anyway.
#
# @example
#   #bad
#   Rails.logger.debug "The time is #{Time.zone.now}."
#
#   #good
#   Rails.logger.debug { "The time is #{Time.zone.now}." }
class RuboCop::Cop::Rails::EagerEvaluationLogMessage < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  def interpolated_string_passed_to_debug(param0 = T.unsafe(nil)); end
  def on_send(node); end

  private

  def replacement_range(node); end
  def replacement_source(node, arguments); end
end

RuboCop::Cop::Rails::EagerEvaluationLogMessage::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Rails::EagerEvaluationLogMessage::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# This cop looks for enums written with array syntax.
#
# When using array syntax, adding an element in a
# position other than the last causes all previous
# definitions to shift. Explicitly specifying the
# value for each key prevents this from happening.
#
# @example
#   # bad
#   enum status: [:active, :archived]
#
#   # good
#   enum status: { active: 0, archived: 1 }
class RuboCop::Cop::Rails::EnumHash < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  def array_pair?(param0 = T.unsafe(nil)); end
  def enum?(param0 = T.unsafe(nil)); end
  def on_send(node); end

  private

  def enum_name(key); end
  def source(elem); end
end

RuboCop::Cop::Rails::EnumHash::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Rails::EnumHash::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# This cop looks for duplicate values in enum declarations.
#
# @example
#   # bad
#   enum status: { active: 0, archived: 0 }
#
#   # good
#   enum status: { active: 0, archived: 1 }
#
#   # bad
#   enum status: [:active, :archived, :active]
#
#   # good
#   enum status: [:active, :archived]
class RuboCop::Cop::Rails::EnumUniqueness < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::Duplication

  def enum?(param0 = T.unsafe(nil)); end
  def enum_values(param0 = T.unsafe(nil)); end
  def on_send(node); end

  private

  def enum_name(key); end
end

RuboCop::Cop::Rails::EnumUniqueness::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Rails::EnumUniqueness::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# This cop checks that Rails.env is compared using `.production?`-like
# methods instead of equality against a string or symbol.
#
# @example
#   # bad
#   Rails.env == 'production'
#
#   # bad, always returns false
#   Rails.env == :test
#
#   # good
#   Rails.env.production?
class RuboCop::Cop::Rails::EnvironmentComparison < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  def comparing_str_env_with_rails_env_on_lhs?(param0 = T.unsafe(nil)); end
  def comparing_str_env_with_rails_env_on_rhs?(param0 = T.unsafe(nil)); end
  def comparing_sym_env_with_rails_env_on_lhs?(param0 = T.unsafe(nil)); end
  def comparing_sym_env_with_rails_env_on_rhs?(param0 = T.unsafe(nil)); end
  def content(param0 = T.unsafe(nil)); end
  def on_send(node); end

  private

  def autocorrect(corrector, node); end
  def build_predicate_method(node); end
  def build_predicate_method_for_rails_env_on_lhs(node); end
  def build_predicate_method_for_rails_env_on_rhs(node); end

  # @return [Boolean]
  def rails_env_on_lhs?(node); end
end

RuboCop::Cop::Rails::EnvironmentComparison::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Rails::EnvironmentComparison::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)
RuboCop::Cop::Rails::EnvironmentComparison::SYM_MSG = T.let(T.unsafe(nil), String)

# This cop looks for direct access to environment variables through the
# `ENV` variable within the application code. This can lead to runtime
# errors due to misconfiguration that could have been discovered at boot
# time if the environment variables were loaded as part of initialization
# and copied into the application's configuration or secrets. The cop can
# be configured to allow either reads or writes if required.
#
# @example
#   # good
#   Rails.application.config.foo
#   Rails.application.config.x.foo.bar
#   Rails.application.secrets.foo
#   Rails.application.config.foo = "bar"
# @example AllowReads: false (default)
#   # bad
#   ENV["FOO"]
#   ENV.fetch("FOO")
# @example AllowReads: true
#   # good
#   ENV["FOO"]
#   ENV.fetch("FOO")
# @example AllowWrites: false (default)
#   # bad
#   ENV["FOO"] = "bar"
# @example AllowWrites: true
#   # good
#   ENV["FOO"] = "bar"
class RuboCop::Cop::Rails::EnvironmentVariableAccess < ::RuboCop::Cop::Base
  def env_read?(param0); end
  def env_write?(param0); end
  def on_const(node); end

  private

  # @return [Boolean]
  def allow_reads?; end

  # @return [Boolean]
  def allow_writes?; end
end

RuboCop::Cop::Rails::EnvironmentVariableAccess::READ_MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Rails::EnvironmentVariableAccess::WRITE_MSG = T.let(T.unsafe(nil), String)

# This cop enforces that `exit` calls are not used within a rails app.
# Valid options are instead to raise an error, break, return, or some
# other form of stopping execution of current request.
#
# There are two obvious cases where `exit` is particularly harmful:
#
# * Usage in library code for your application. Even though Rails will
# rescue from a `SystemExit` and continue on, unit testing that library
# code will result in specs exiting (potentially silently if `exit(0)`
# is used.)
# * Usage in application code outside of the web process could result in
# the program exiting, which could result in the code failing to run and
# do its job.
#
# @example
#   # bad
#   exit(0)
#
#   # good
#   raise 'a bad error has happened'
class RuboCop::Cop::Rails::Exit < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle

  def on_send(node); end

  private

  # @return [Boolean]
  def offending_node?(node); end

  # More than 1 argument likely means it is a different
  # `exit` implementation than the one we are preventing.
  #
  # @return [Boolean]
  def right_argument_count?(arg_nodes); end

  # Only register if exit is being called explicitly on `Kernel`,
  # `Process`, or if receiver node is nil for plain `exit` calls.
  #
  # @return [Boolean]
  def right_receiver?(receiver_node); end
end

RuboCop::Cop::Rails::Exit::EXPLICIT_RECEIVERS = T.let(T.unsafe(nil), Array)
RuboCop::Cop::Rails::Exit::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Rails::Exit::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# This cop checks for expanded date range. It only compatible `..` range is targeted.
# Incompatible `...` range is ignored.
#
# @example
#   # bad
#   date.beginning_of_day..date.end_of_day
#   date.beginning_of_week..date.end_of_week
#   date.beginning_of_month..date.end_of_month
#   date.beginning_of_quarter..date.end_of_quarter
#   date.beginning_of_year..date.end_of_year
#
#   # good
#   date.all_day
#   date.all_week
#   date.all_month
#   date.all_quarter
#   date.all_year
class RuboCop::Cop::Rails::ExpandedDateRange < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector
  extend ::RuboCop::Cop::TargetRailsVersion

  def expanded_date_range(param0 = T.unsafe(nil)); end
  def on_irange(node); end

  private

  # @return [Boolean]
  def same_receiver?(begin_node, end_node); end

  # @return [Boolean]
  def use_mapped_methods?(beginning_method, end_method); end
end

RuboCop::Cop::Rails::ExpandedDateRange::MAPPED_DATE_RANGE_METHODS = T.let(T.unsafe(nil), Hash)
RuboCop::Cop::Rails::ExpandedDateRange::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Rails::ExpandedDateRange::PREFERRED_METHODS = T.let(T.unsafe(nil), Hash)

# This cop is used to identify usages of file path joining process
# to use `Rails.root.join` clause. It is used to add uniformity when
# joining paths.
#
# @example EnforcedStyle: arguments
#   # bad
#   Rails.root.join('app/models/goober')
#   File.join(Rails.root, 'app/models/goober')
#   "#{Rails.root}/app/models/goober"
#
#   # good
#   Rails.root.join('app', 'models', 'goober')
# @example EnforcedStyle: slashes (default)
#   # bad
#   Rails.root.join('app', 'models', 'goober')
#   File.join(Rails.root, 'app/models/goober')
#   "#{Rails.root}/app/models/goober"
#
#   # good
#   Rails.root.join('app/models/goober')
class RuboCop::Cop::Rails::FilePath < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp

  def file_join_nodes?(param0 = T.unsafe(nil)); end
  def on_dstr(node); end
  def on_send(node); end
  def rails_root_join_nodes?(param0 = T.unsafe(nil)); end
  def rails_root_nodes?(param0); end

  private

  def check_for_file_join_with_rails_root(node); end
  def check_for_rails_root_join_with_slash_separated_path(node); end
  def check_for_rails_root_join_with_string_arguments(node); end
  def message(_range); end
  def register_offense(node); end

  # @return [Boolean]
  def string_with_slash?(node); end
end

RuboCop::Cop::Rails::FilePath::MSG_ARGUMENTS = T.let(T.unsafe(nil), String)
RuboCop::Cop::Rails::FilePath::MSG_SLASHES = T.let(T.unsafe(nil), String)
RuboCop::Cop::Rails::FilePath::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# This cop is used to identify usages of `where.take` and change them to use `find_by` instead.
#
# And `where(...).first` can return different results from `find_by`.
# (They order records differently, so the "first" record can be different.)
#
# If you also want to detect `where.first`, you can set `IgnoreWhereFirst` to false.
#
# @example
#   # bad
#   User.where(name: 'Bruce').take
#
#   # good
#   User.find_by(name: 'Bruce')
# @example IgnoreWhereFirst: true (default)
#   # good
#   User.where(name: 'Bruce').first
# @example IgnoreWhereFirst: false
#   # bad
#   User.where(name: 'Bruce').first
class RuboCop::Cop::Rails::FindBy < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  def on_csend(node); end
  def on_send(node); end

  private

  def autocorrect(corrector, node); end

  # @return [Boolean]
  def ignore_where_first?; end

  def offense_range(node); end

  # @return [Boolean]
  def where_method?(receiver); end
end

RuboCop::Cop::Rails::FindBy::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Rails::FindBy::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# This cop enforces that `ActiveRecord#find` is used instead of
# `where.take!`, `find_by!`, and `find_by_id!` to retrieve a single record
# by primary key when you expect it to be found.
#
# @example
#   # bad
#   User.where(id: id).take!
#   User.find_by_id!(id)
#   User.find_by!(id: id)
#
#   # good
#   User.find(id)
class RuboCop::Cop::Rails::FindById < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  def find_by?(param0 = T.unsafe(nil)); end
  def on_send(node); end
  def where_take?(param0 = T.unsafe(nil)); end

  private

  def build_find_by_bad_method(node, id_value); end
  def build_good_method(id_value); end
  def build_where_take_bad_method(id_value); end
  def find_by_offense_range(node); end
  def register_offense(range, id_value, bad_method); end
  def where_take_offense_range(node, where); end
end

RuboCop::Cop::Rails::FindById::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Rails::FindById::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# This cop is used to identify usages of `all.each` and
# change them to use `all.find_each` instead.
#
# @example
#   # bad
#   User.all.each
#
#   # good
#   User.all.find_each
# @example IgnoredMethods: ['order']
#   # good
#   User.order(:foo).each
class RuboCop::Cop::Rails::FindEach < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ActiveRecordHelper
  extend ::RuboCop::Cop::AutoCorrector

  def on_send(node); end

  private

  # @return [Boolean]
  def active_model_error?(node); end

  # @return [Boolean]
  def active_model_error_where?(node); end

  # @return [Boolean]
  def ignored?(node); end
end

RuboCop::Cop::Rails::FindEach::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Rails::FindEach::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)
RuboCop::Cop::Rails::FindEach::SCOPE_METHODS = T.let(T.unsafe(nil), Array)

# This cop checks for the use of the has_and_belongs_to_many macro.
#
# @example
#   # bad
#   # has_and_belongs_to_many :ingredients
#
#   # good
#   # has_many :ingredients, through: :recipe_ingredients
class RuboCop::Cop::Rails::HasAndBelongsToMany < ::RuboCop::Cop::Base
  def on_send(node); end
end

RuboCop::Cop::Rails::HasAndBelongsToMany::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Rails::HasAndBelongsToMany::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# This cop looks for `has_many` or `has_one` associations that don't
# specify a `:dependent` option.
#
# It doesn't register an offense if `:through` or `dependent: nil`
# is specified, or if the model is read-only.
#
# @example
#   # bad
#   class User < ActiveRecord::Base
#   has_many :comments
#   has_one :avatar
#   end
#
#   # good
#   class User < ActiveRecord::Base
#   has_many :comments, dependent: :restrict_with_exception
#   has_one :avatar, dependent: :destroy
#   has_many :articles, dependent: nil
#   has_many :patients, through: :appointments
#   end
#
#   class User < ActiveRecord::Base
#   has_many :comments
#   has_one :avatar
#
#   def readonly?
#   true
#   end
#   end
class RuboCop::Cop::Rails::HasManyOrHasOneDependent < ::RuboCop::Cop::Base
  def active_resource_class?(param0); end
  def association_extension_block?(param0 = T.unsafe(nil)); end
  def association_with_options?(param0 = T.unsafe(nil)); end
  def association_without_options?(param0 = T.unsafe(nil)); end
  def dependent_option?(param0 = T.unsafe(nil)); end
  def on_send(node); end
  def present_option?(param0 = T.unsafe(nil)); end
  def readonly?(param0 = T.unsafe(nil)); end
  def with_options_block(param0 = T.unsafe(nil)); end

  private

  # @return [Boolean]
  def active_resource?(node); end

  # @return [Boolean]
  def contain_valid_options_in_with_options_block?(node); end

  # @return [Boolean]
  def readonly_model?(node); end

  # @return [Boolean]
  def valid_options?(options); end

  # @return [Boolean]
  def valid_options_in_with_options_block?(node); end
end

RuboCop::Cop::Rails::HasManyOrHasOneDependent::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Rails::HasManyOrHasOneDependent::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# This cop checks for use of the helper methods which reference
# instance variables.
#
# Relying on instance variables makes it difficult to re-use helper
# methods.
#
# If it seems awkward to explicitly pass in each dependent
# variable, consider moving the behaviour elsewhere, for
# example to a model, decorator or presenter.
#
# Provided that a class inherits `ActionView::Helpers::FormBuilder`,
# an offense will not be registered.
#
# @example
#   # bad
#   def welcome_message
#   "Hello #{@user.name}"
#   end
#
#   # good
#   def welcome_message(user)
#   "Hello #{user.name}"
#   end
#
#   # good
#   class MyFormBuilder < ActionView::Helpers::FormBuilder
#   @template.do_something
#   end
class RuboCop::Cop::Rails::HelperInstanceVariable < ::RuboCop::Cop::Base
  def form_builder_class?(param0 = T.unsafe(nil)); end
  def on_ivar(node); end
  def on_ivasgn(node); end

  private

  # @return [Boolean]
  def inherit_form_builder?(node); end
end

RuboCop::Cop::Rails::HelperInstanceVariable::MSG = T.let(T.unsafe(nil), String)

# This cop is used to identify usages of http methods like `get`, `post`,
# `put`, `patch` without the usage of keyword arguments in your tests and
# change them to use keyword args. This cop only applies to Rails >= 5.
# If you are running Rails < 5 you should disable the
# Rails/HttpPositionalArguments cop or set your TargetRailsVersion in your
# .rubocop.yml file to 4.2.
#
# @example
#   # bad
#   get :new, { user_id: 1}
#
#   # good
#   get :new, params: { user_id: 1 }
#   get :new, **options
class RuboCop::Cop::Rails::HttpPositionalArguments < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector
  extend ::RuboCop::Cop::TargetRailsVersion

  def http_request?(param0 = T.unsafe(nil)); end
  def kwsplat_hash?(param0 = T.unsafe(nil)); end
  def on_send(node); end

  private

  def convert_hash_data(data, type); end
  def correction(node); end
  def correction_template(node); end

  # @return [Boolean]
  def format_arg?(node); end

  def highlight_range(node); end

  # @return [Boolean]
  def in_routing_block?(node); end

  # @return [Boolean]
  def needs_conversion?(data); end

  # @return [Boolean]
  def special_keyword_arg?(node); end
end

RuboCop::Cop::Rails::HttpPositionalArguments::KEYWORD_ARGS = T.let(T.unsafe(nil), Array)
RuboCop::Cop::Rails::HttpPositionalArguments::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Rails::HttpPositionalArguments::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)
RuboCop::Cop::Rails::HttpPositionalArguments::ROUTING_METHODS = T.let(T.unsafe(nil), Array)

# Enforces use of symbolic or numeric value to define HTTP status.
#
# @example EnforcedStyle: symbolic (default)
#   # bad
#   render :foo, status: 200
#   render json: { foo: 'bar' }, status: 200
#   render plain: 'foo/bar', status: 304
#   redirect_to root_url, status: 301
#   head 200
#
#   # good
#   render :foo, status: :ok
#   render json: { foo: 'bar' }, status: :ok
#   render plain: 'foo/bar', status: :not_modified
#   redirect_to root_url, status: :moved_permanently
#   head :ok
# @example EnforcedStyle: numeric
#   # bad
#   render :foo, status: :ok
#   render json: { foo: 'bar' }, status: :not_found
#   render plain: 'foo/bar', status: :not_modified
#   redirect_to root_url, status: :moved_permanently
#   head :ok
#
#   # good
#   render :foo, status: 200
#   render json: { foo: 'bar' }, status: 404
#   render plain: 'foo/bar', status: 304
#   redirect_to root_url, status: 301
#   head 200
class RuboCop::Cop::Rails::HttpStatus < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  extend ::RuboCop::Cop::AutoCorrector

  def http_status(param0 = T.unsafe(nil)); end
  def on_send(node); end
  def status_code(param0 = T.unsafe(nil)); end

  private

  def checker_class; end
end

class RuboCop::Cop::Rails::HttpStatus::NumericStyleChecker
  # @return [NumericStyleChecker] a new instance of NumericStyleChecker
  def initialize(node); end

  def message; end

  # Returns the value of attribute node.
  def node; end

  # @return [Boolean]
  def offensive?; end

  def preferred_style; end

  private

  def number; end

  # @return [Boolean]
  def permitted_symbol?; end

  def symbol; end
end

RuboCop::Cop::Rails::HttpStatus::NumericStyleChecker::DEFAULT_MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Rails::HttpStatus::NumericStyleChecker::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Rails::HttpStatus::NumericStyleChecker::PERMITTED_STATUS = T.let(T.unsafe(nil), Array)
RuboCop::Cop::Rails::HttpStatus::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Rails::HttpStatus::SymbolicStyleChecker
  # @return [SymbolicStyleChecker] a new instance of SymbolicStyleChecker
  def initialize(node); end

  def message; end

  # Returns the value of attribute node.
  def node; end

  # @return [Boolean]
  def offensive?; end

  def preferred_style; end

  private

  # @return [Boolean]
  def custom_http_status_code?; end

  def number; end
  def symbol; end
end

RuboCop::Cop::Rails::HttpStatus::SymbolicStyleChecker::DEFAULT_MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Rails::HttpStatus::SymbolicStyleChecker::MSG = T.let(T.unsafe(nil), String)

# This cop checks for places where I18n "lazy" lookup can be used.
#
# @example
#   # en.yml
#   # en:
#   #   books:
#   #     create:
#   #       success: Book created!
#
#   # bad
#   class BooksController < ApplicationController
#   def create
#   # ...
#   redirect_to books_url, notice: t('books.create.success')
#   end
#   end
#
#   # good
#   class BooksController < ApplicationController
#   def create
#   # ...
#   redirect_to books_url, notice: t('.success')
#   end
#   end
class RuboCop::Cop::Rails::I18nLazyLookup < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::VisibilityHelp
  extend ::RuboCop::Cop::AutoCorrector

  def on_send(node); end
  def translate_call?(param0 = T.unsafe(nil)); end

  private

  def controller_and_action(node); end
  def controller_path(controller); end
  def get_scoped_key(key_node, controller, action); end
end

RuboCop::Cop::Rails::I18nLazyLookup::MSG = T.let(T.unsafe(nil), String)

# This cop checks for the use of `I18n.locale=` method.
#
# The `locale` attribute persists for the rest of the Ruby runtime, potentially causing
# unexpected behavior at a later time.
# Using `I18n.with_locale` ensures the code passed in the block is the only place `I18n.locale` is affected.
# It eliminates the possibility of a `locale` sticking around longer than intended.
#
# @example
#   # bad
#   I18n.locale = :fr
#
#   # good
#   I18n.with_locale(:fr) do
#   end
class RuboCop::Cop::Rails::I18nLocaleAssignment < ::RuboCop::Cop::Base
  def i18n_locale_assignment?(param0 = T.unsafe(nil)); end
  def on_send(node); end
end

RuboCop::Cop::Rails::I18nLocaleAssignment::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Rails::I18nLocaleAssignment::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Enforces use of I18n and locale files instead of locale specific strings.
#
# @example
#   # bad
#   class User < ApplicationRecord
#   validates :email, presence: { message: "must be present" }
#   end
#
#   # good
#   # config/locales/en.yml
#   # en:
#   #   activerecord:
#   #     errors:
#   #       models:
#   #         user:
#   #           blank: "must be present"
#
#   class User < ApplicationRecord
#   validates :email, presence: true
#   end
#
#   # bad
#   class PostsController < ApplicationController
#   def create
#   # ...
#   redirect_to root_path, notice: "Post created!"
#   end
#   end
#
#   # good
#   # config/locales/en.yml
#   # en:
#   #   posts:
#   #     create:
#   #       success: "Post created!"
#
#   class PostsController < ApplicationController
#   def create
#   # ...
#   redirect_to root_path, notice: t(".success")
#   end
#   end
#
#   # bad
#   class UserMailer < ApplicationMailer
#   def welcome(user)
#   mail(to: user.email, subject: "Welcome to My Awesome Site")
#   end
#   end
#
#   # good
#   # config/locales/en.yml
#   # en:
#   #   user_mailer:
#   #     welcome:
#   #       subject: "Welcome to My Awesome Site"
#
#   class UserMailer < ApplicationMailer
#   def welcome(user)
#   mail(to: user.email)
#   end
#   end
class RuboCop::Cop::Rails::I18nLocaleTexts < ::RuboCop::Cop::Base
  def flash_assignment?(param0 = T.unsafe(nil)); end
  def mail_subject(param0); end
  def on_send(node); end
  def redirect_to_flash(param0); end
  def validation_message(param0); end
end

RuboCop::Cop::Rails::I18nLocaleTexts::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Rails::I18nLocaleTexts::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# This cop checks that `if` and `only` (or `except`) are not used together
# as options of `skip_*` action filter.
#
# The `if` option will be ignored when `if` and `only` are used together.
# Similarly, the `except` option will be ignored when `if` and `except`
# are used together.
#
# @example
#   # bad
#   class MyPageController < ApplicationController
#   skip_before_action :login_required,
#   only: :show, if: :trusted_origin?
#   end
#
#   # good
#   class MyPageController < ApplicationController
#   skip_before_action :login_required,
#   if: -> { trusted_origin? && action_name == "show" }
#   end
# @example
#   # bad
#   class MyPageController < ApplicationController
#   skip_before_action :login_required,
#   except: :admin, if: :trusted_origin?
#   end
#
#   # good
#   class MyPageController < ApplicationController
#   skip_before_action :login_required,
#   if: -> { trusted_origin? && action_name != "admin" }
#   end
# @see https://api.rubyonrails.org/classes/AbstractController/Callbacks/ClassMethods.html#method-i-_normalize_callback_options
class RuboCop::Cop::Rails::IgnoredSkipActionFilterOption < ::RuboCop::Cop::Base
  def filter_options(param0 = T.unsafe(nil)); end
  def on_send(node); end

  private

  # @return [Boolean]
  def if_and_except?(options); end

  # @return [Boolean]
  def if_and_only?(options); end

  def options_hash(options); end
end

RuboCop::Cop::Rails::IgnoredSkipActionFilterOption::FILTERS = T.let(T.unsafe(nil), Array)
RuboCop::Cop::Rails::IgnoredSkipActionFilterOption::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Rails::IgnoredSkipActionFilterOption::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# This cop looks for uses of `each_with_object({}) { ... }`,
# `map { ... }.to_h`, and `Hash[map { ... }]` that are transforming
# an enumerable into a hash where the values are the original elements.
# Rails provides the `index_by` method for this purpose.
#
# @example
#   # bad
#   [1, 2, 3].each_with_object({}) { |el, h| h[foo(el)] = el }
#   [1, 2, 3].to_h { |el| [foo(el), el] }
#   [1, 2, 3].map { |el| [foo(el), el] }.to_h
#   Hash[[1, 2, 3].collect { |el| [foo(el), el] }]
#
#   # good
#   [1, 2, 3].index_by { |el| foo(el) }
class RuboCop::Cop::Rails::IndexBy < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::IndexMethod
  extend ::RuboCop::Cop::AutoCorrector

  def on_bad_each_with_object(param0 = T.unsafe(nil)); end
  def on_bad_hash_brackets_map(param0 = T.unsafe(nil)); end
  def on_bad_map_to_h(param0 = T.unsafe(nil)); end
  def on_bad_to_h(param0 = T.unsafe(nil)); end

  private

  def new_method_name; end
end

# This cop looks for uses of `each_with_object({}) { ... }`,
# `map { ... }.to_h`, and `Hash[map { ... }]` that are transforming
# an enumerable into a hash where the keys are the original elements.
# Rails provides the `index_with` method for this purpose.
#
# @example
#   # bad
#   [1, 2, 3].each_with_object({}) { |el, h| h[el] = foo(el) }
#   [1, 2, 3].to_h { |el| [el, foo(el)] }
#   [1, 2, 3].map { |el| [el, foo(el)] }.to_h
#   Hash[[1, 2, 3].collect { |el| [el, foo(el)] }]
#
#   # good
#   [1, 2, 3].index_with { |el| foo(el) }
class RuboCop::Cop::Rails::IndexWith < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::IndexMethod
  extend ::RuboCop::Cop::AutoCorrector
  extend ::RuboCop::Cop::TargetRailsVersion

  def on_bad_each_with_object(param0 = T.unsafe(nil)); end
  def on_bad_hash_brackets_map(param0 = T.unsafe(nil)); end
  def on_bad_map_to_h(param0 = T.unsafe(nil)); end
  def on_bad_to_h(param0 = T.unsafe(nil)); end

  private

  def new_method_name; end
end

# This cop checks that Active Support's `inquiry` method is not used.
#
# @example
#   # bad - String#inquiry
#   ruby = 'two'.inquiry
#   ruby.two?
#
#   # good
#   ruby = 'two'
#   ruby == 'two'
#
#   # bad - Array#inquiry
#   pets = %w(cat dog).inquiry
#   pets.gopher?
#
#   # good
#   pets = %w(cat dog)
#   pets.include? 'cat'
class RuboCop::Cop::Rails::Inquiry < ::RuboCop::Cop::Base
  def on_send(node); end
end

RuboCop::Cop::Rails::Inquiry::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Rails::Inquiry::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# This cop looks for has_(one|many) and belongs_to associations where
# Active Record can't automatically determine the inverse association
# because of a scope or the options used. Using the blog with order scope
# example below, traversing the a Blog's association in both directions
# with `blog.posts.first.blog` would cause the `blog` to be loaded from
# the database twice.
#
# `:inverse_of` must be manually specified for Active Record to use the
# associated object in memory, or set to `false` to opt-out. Note that
# setting `nil` does not stop Active Record from trying to determine the
# inverse automatically, and is not considered a valid value for this.
#
# @example
#   # good
#   class Blog < ApplicationRecord
#   has_many :posts
#   end
#
#   class Post < ApplicationRecord
#   belongs_to :blog
#   end
# @example
#   # bad
#   class Blog < ApplicationRecord
#   has_many :posts, -> { order(published_at: :desc) }
#   end
#
#   class Post < ApplicationRecord
#   belongs_to :blog
#   end
#
#   # good
#   class Blog < ApplicationRecord
#   has_many(:posts,
#   -> { order(published_at: :desc) },
#   inverse_of: :blog)
#   end
#
#   class Post < ApplicationRecord
#   belongs_to :blog
#   end
#
#   # good
#   class Blog < ApplicationRecord
#   with_options inverse_of: :blog do
#   has_many :posts, -> { order(published_at: :desc) }
#   end
#   end
#
#   class Post < ApplicationRecord
#   belongs_to :blog
#   end
#
#   # good
#   # When you don't want to use the inverse association.
#   class Blog < ApplicationRecord
#   has_many(:posts,
#   -> { order(published_at: :desc) },
#   inverse_of: false)
#   end
# @example
#   # bad
#   class Picture < ApplicationRecord
#   belongs_to :imageable, polymorphic: true
#   end
#
#   class Employee < ApplicationRecord
#   has_many :pictures, as: :imageable
#   end
#
#   class Product < ApplicationRecord
#   has_many :pictures, as: :imageable
#   end
#
#   # good
#   class Picture < ApplicationRecord
#   belongs_to :imageable, polymorphic: true
#   end
#
#   class Employee < ApplicationRecord
#   has_many :pictures, as: :imageable, inverse_of: :imageable
#   end
#
#   class Product < ApplicationRecord
#   has_many :pictures, as: :imageable, inverse_of: :imageable
#   end
# @example
#   # bad
#   # However, RuboCop can not detect this pattern...
#   class Physician < ApplicationRecord
#   has_many :appointments
#   has_many :patients, through: :appointments
#   end
#
#   class Appointment < ApplicationRecord
#   belongs_to :physician
#   belongs_to :patient
#   end
#
#   class Patient < ApplicationRecord
#   has_many :appointments
#   has_many :physicians, through: :appointments
#   end
#
#   # good
#   class Physician < ApplicationRecord
#   has_many :appointments
#   has_many :patients, through: :appointments
#   end
#
#   class Appointment < ApplicationRecord
#   belongs_to :physician, inverse_of: :appointments
#   belongs_to :patient, inverse_of: :appointments
#   end
#
#   class Patient < ApplicationRecord
#   has_many :appointments
#   has_many :physicians, through: :appointments
#   end
# @example IgnoreScopes: false (default)
#   # bad
#   class Blog < ApplicationRecord
#   has_many :posts, -> { order(published_at: :desc) }
#   end
# @example IgnoreScopes: true
#   # good
#   class Blog < ApplicationRecord
#   has_many :posts, -> { order(published_at: :desc) }
#   end
# @see https://guides.rubyonrails.org/association_basics.html#bi-directional-associations
# @see https://api.rubyonrails.org/classes/ActiveRecord/Associations/ClassMethods.html#module-ActiveRecord::Associations::ClassMethods-label-Setting+Inverses
class RuboCop::Cop::Rails::InverseOf < ::RuboCop::Cop::Base
  def as_option?(param0 = T.unsafe(nil)); end
  def association_recv_arguments(param0 = T.unsafe(nil)); end
  def conditions_option?(param0 = T.unsafe(nil)); end
  def foreign_key_option?(param0 = T.unsafe(nil)); end
  def inverse_of_nil_option?(param0 = T.unsafe(nil)); end
  def inverse_of_option?(param0 = T.unsafe(nil)); end
  def on_send(node); end

  # @return [Boolean]
  def options_contain_inverse_of?(options); end

  def options_from_argument(param0 = T.unsafe(nil)); end

  # @return [Boolean]
  def options_ignoring_inverse_of?(options); end

  # @return [Boolean]
  def options_requiring_inverse_of?(options); end

  def polymorphic_option?(param0 = T.unsafe(nil)); end

  # @return [Boolean]
  def same_context_in_with_options?(arg, recv); end

  # @return [Boolean]
  def scope?(arguments); end

  def through_option?(param0 = T.unsafe(nil)); end
  def with_options_arguments(recv, node); end

  private

  # @return [Boolean]
  def ignore_scopes?; end

  def message(options); end
end

RuboCop::Cop::Rails::InverseOf::NIL_MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Rails::InverseOf::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)
RuboCop::Cop::Rails::InverseOf::SPECIFY_MSG = T.let(T.unsafe(nil), String)

# This cop checks that methods specified in the filter's `only` or
# `except` options are defined within the same class or module.
#
# @example
#   # bad
#   class LoginController < ApplicationController
#   before_action :require_login, only: %i[index settings logout]
#
#   def index
#   end
#   end
#
#   # good
#   class LoginController < ApplicationController
#   before_action :require_login, only: %i[index settings logout]
#
#   def index
#   end
#
#   def settings
#   end
#
#   def logout
#   end
#   end
# @example
#   # bad
#   module FooMixin
#   extend ActiveSupport::Concern
#
#   included do
#   before_action proc { authenticate }, only: :foo
#   end
#   end
#
#   # good
#   module FooMixin
#   extend ActiveSupport::Concern
#
#   included do
#   before_action proc { authenticate }, only: :foo
#   end
#
#   def foo
#   # something
#   end
#   end
# @example
#   class ContentController < ApplicationController
#   def update
#   @content.update(content_attributes)
#   end
#   end
#
#   class ArticlesController < ContentController
#   before_action :load_article, only: [:update]
#
#   # the cop requires this method, but it relies on behaviour defined
#   # in the superclass, so needs to invoke `super`
#   def update
#   super
#   end
#
#   private
#
#   def load_article
#   @content = Article.find(params[:article_id])
#   end
#   end
class RuboCop::Cop::Rails::LexicallyScopedActionFilter < ::RuboCop::Cop::Base
  def on_send(node); end
  def only_or_except_filter_methods(param0 = T.unsafe(nil)); end

  private

  def aliased_action_methods(node, defined_methods); end

  # @param node [RuboCop::AST::Node]
  # @return [Array<Symbol>]
  def array_values(node); end

  def defined_action_methods(block); end

  # @param methods [Array<String>]
  # @param parent [RuboCop::AST::Node]
  # @return [String]
  def message(methods, parent); end
end

RuboCop::Cop::Rails::LexicallyScopedActionFilter::FILTERS = T.let(T.unsafe(nil), Array)
RuboCop::Cop::Rails::LexicallyScopedActionFilter::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Rails::LexicallyScopedActionFilter::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# This cop checks for calls to `link_to` that contain a
# `target: '_blank'` but no `rel: 'noopener'`. This can be a security
# risk as the loaded page will have control over the previous page
# and could change its location for phishing purposes.
#
# The option `rel: 'noreferrer'` also blocks this behavior
# and removes the http-referrer header.
#
# @example
#   # bad
#   link_to 'Click here', url, target: '_blank'
#
#   # good
#   link_to 'Click here', url, target: '_blank', rel: 'noopener'
#
#   # good
#   link_to 'Click here', url, target: '_blank', rel: 'noreferrer'
class RuboCop::Cop::Rails::LinkToBlank < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  def blank_target?(param0 = T.unsafe(nil)); end
  def includes_noopener?(param0 = T.unsafe(nil)); end
  def on_send(node); end
  def rel_node?(param0 = T.unsafe(nil)); end

  private

  def add_rel(send_node, offense_node, corrector); end
  def append_to_rel(rel_node, corrector); end
  def autocorrect(corrector, send_node, node, option_nodes); end

  # @return [Boolean]
  def contains_noopener?(value); end
end

RuboCop::Cop::Rails::LinkToBlank::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Rails::LinkToBlank::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# This cop enforces that mailer names end with `Mailer` suffix.
#
# Without the `Mailer` suffix it isn't immediately apparent what's a mailer
# and which views are related to the mailer.
#
# @example
#   # bad
#   class User < ActionMailer::Base
#   end
#
#   class User < ApplicationMailer
#   end
#
#   # good
#   class UserMailer < ActionMailer::Base
#   end
#
#   class UserMailer < ApplicationMailer
#   end
class RuboCop::Cop::Rails::MailerName < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  def class_definition?(param0 = T.unsafe(nil)); end
  def class_new_definition?(param0 = T.unsafe(nil)); end
  def mailer_base_class?(param0 = T.unsafe(nil)); end
  def on_class(node); end
  def on_send(node); end

  private

  def autocorrect(corrector, node); end

  # @return [Boolean]
  def mailer_suffix?(mailer_name); end
end

RuboCop::Cop::Rails::MailerName::MSG = T.let(T.unsafe(nil), String)

# This cop identifies places where defining routes with `match`
# can be replaced with a specific HTTP method.
#
# Don't use `match` to define any routes unless there is a need to map multiple request types
# among [:get, :post, :patch, :put, :delete] to a single action using the `:via` option.
#
# @example
#   # bad
#   match ':controller/:action/:id'
#   match 'photos/:id', to: 'photos#show', via: :get
#
#   # good
#   get ':controller/:action/:id'
#   get 'photos/:id', to: 'photos#show'
#   match 'photos/:id', to: 'photos#show', via: [:get, :post]
#   match 'photos/:id', to: 'photos#show', via: :all
class RuboCop::Cop::Rails::MatchRoute < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  def match_method_call?(param0 = T.unsafe(nil)); end
  def on_send(node); end
  def routes_draw?(param0 = T.unsafe(nil)); end

  private

  def extract_via(node); end

  # @return [Boolean]
  def http_method?(method); end

  def http_method_and_options(node); end
  def register_offense(node, http_method); end
  def replacement(path_node, options_node); end
  def via_pair(node); end

  # @return [Boolean]
  def within_routes?(node); end
end

RuboCop::Cop::Rails::MatchRoute::HTTP_METHODS = T.let(T.unsafe(nil), Array)
RuboCop::Cop::Rails::MatchRoute::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Rails::MatchRoute::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# This cop makes sure that each migration file defines a migration class
# whose name matches the file name.
# (e.g. `20220224111111_create_users.rb` should define `CreateUsers` class.)
#
# @example
#   # db/migrate/20220224111111_create_users.rb
#
#   # bad
#   class SellBooks < ActiveRecord::Migration[7.0]
#   end
#
#   # good
#   class CreateUsers < ActiveRecord::Migration[7.0]
#   end
class RuboCop::Cop::Rails::MigrationClassName < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::MigrationsHelper
  extend ::RuboCop::Cop::AutoCorrector

  def on_class(node); end

  private

  def basename_without_timestamp_and_suffix(filepath); end
  def camelize(word); end

  # e.g.: from `add_blobs.active_storage` to `add_blobs`.
  def remove_gem_suffix(file_name); end
end

RuboCop::Cop::Rails::MigrationClassName::MSG = T.let(T.unsafe(nil), String)

# This cop enforces the use of `collection.exclude?(obj)`
# over `!collection.include?(obj)`.
#
# @example
#   # bad
#   !array.include?(2)
#   !hash.include?(:key)
#
#   # good
#   array.exclude?(2)
#   hash.exclude?(:key)
class RuboCop::Cop::Rails::NegateInclude < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  def negate_include_call?(param0 = T.unsafe(nil)); end
  def on_send(node); end
end

RuboCop::Cop::Rails::NegateInclude::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Rails::NegateInclude::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# This cop checks for add_column call with NOT NULL constraint
# in migration file.
#
# @example
#   # bad
#   add_column :users, :name, :string, null: false
#   add_reference :products, :category, null: false
#
#   # good
#   add_column :users, :name, :string, null: true
#   add_column :users, :name, :string, null: false, default: ''
#   add_reference :products, :category
#   add_reference :products, :category, null: false, default: 1
class RuboCop::Cop::Rails::NotNullColumn < ::RuboCop::Cop::Base
  def add_not_null_column?(param0 = T.unsafe(nil)); end
  def add_not_null_reference?(param0 = T.unsafe(nil)); end
  def default_option?(param0 = T.unsafe(nil)); end
  def null_false?(param0 = T.unsafe(nil)); end
  def on_send(node); end

  private

  def check_add_column(node); end
  def check_add_reference(node); end
  def check_pairs(pairs); end
end

RuboCop::Cop::Rails::NotNullColumn::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Rails::NotNullColumn::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# This cop checks for places where ordering by `id` column is used.
#
# Don't use the `id` column for ordering. The sequence of ids is not guaranteed
# to be in any particular order, despite often (incidentally) being chronological.
# Use a timestamp column to order chronologically. As a bonus the intent is clearer.
#
# NOTE: Make sure the changed order column does not introduce performance
# bottlenecks and appropriate database indexes are added.
#
# @example
#   # bad
#   scope :chronological, -> { order(id: :asc) }
#   scope :chronological, -> { order(primary_key => :asc) }
#
#   # good
#   scope :chronological, -> { order(created_at: :asc) }
class RuboCop::Cop::Rails::OrderById < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp

  def on_send(node); end
  def order_by_id?(param0 = T.unsafe(nil)); end

  private

  def offense_range(node); end
end

RuboCop::Cop::Rails::OrderById::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Rails::OrderById::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# This cop checks for the use of output calls like puts and print
#
# @example
#   # bad
#   puts 'A debug message'
#   pp 'A debug message'
#   print 'A debug message'
#
#   # good
#   Rails.logger.debug 'A debug message'
class RuboCop::Cop::Rails::Output < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  def io_output?(param0 = T.unsafe(nil)); end
  def on_send(node); end
  def output?(param0 = T.unsafe(nil)); end

  private

  # @return [Boolean]
  def match_gvar?(sym); end

  def offense_range(node); end
end

RuboCop::Cop::Rails::Output::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Rails::Output::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# This cop checks for the use of output safety calls like `html_safe`,
# `raw`, and `safe_concat`. These methods do not escape content. They
# simply return a SafeBuffer containing the content as is. Instead,
# use `safe_join` to join content and escape it and concat to
# concatenate content and escape it, ensuring its safety.
#
# @example
#   user_content = "<b>hi</b>"
#
#   # bad
#   "<p>#{user_content}</p>".html_safe
#   # => ActiveSupport::SafeBuffer "<p><b>hi</b></p>"
#
#   # good
#   content_tag(:p, user_content)
#   # => ActiveSupport::SafeBuffer "<p>&lt;b&gt;hi&lt;/b&gt;</p>"
#
#   # bad
#   out = ""
#   out << "<li>#{user_content}</li>"
#   out << "<li>#{user_content}</li>"
#   out.html_safe
#   # => ActiveSupport::SafeBuffer "<li><b>hi</b></li><li><b>hi</b></li>"
#
#   # good
#   out = []
#   out << content_tag(:li, user_content)
#   out << content_tag(:li, user_content)
#   safe_join(out)
#   # => ActiveSupport::SafeBuffer
#   #    "<li>&lt;b&gt;hi&lt;/b&gt;</li><li>&lt;b&gt;hi&lt;/b&gt;</li>"
#
#   # bad
#   out = "<h1>trusted content</h1>".html_safe
#   out.safe_concat(user_content)
#   # => ActiveSupport::SafeBuffer "<h1>trusted_content</h1><b>hi</b>"
#
#   # good
#   out = "<h1>trusted content</h1>".html_safe
#   out.concat(user_content)
#   # => ActiveSupport::SafeBuffer
#   #    "<h1>trusted_content</h1>&lt;b&gt;hi&lt;/b&gt;"
#
#   # safe, though maybe not good style
#   out = "trusted content"
#   result = out.concat(user_content)
#   # => String "trusted content<b>hi</b>"
#   # because when rendered in ERB the String will be escaped:
#   # <%= result %>
#   # => trusted content&lt;b&gt;hi&lt;/b&gt;
#
#   # bad
#   (user_content + " " + content_tag(:span, user_content)).html_safe
#   # => ActiveSupport::SafeBuffer "<b>hi</b> <span><b>hi</b></span>"
#
#   # good
#   safe_join([user_content, " ", content_tag(:span, user_content)])
#   # => ActiveSupport::SafeBuffer
#   #    "&lt;b&gt;hi&lt;/b&gt; <span>&lt;b&gt;hi&lt;/b&gt;</span>"
class RuboCop::Cop::Rails::OutputSafety < ::RuboCop::Cop::Base
  def on_csend(node); end
  def on_send(node); end

  private

  # @return [Boolean]
  def looks_like_rails_html_safe?(node); end

  # @return [Boolean]
  def looks_like_rails_raw?(node); end

  # @return [Boolean]
  def looks_like_rails_safe_concat?(node); end

  # @return [Boolean]
  def non_interpolated_string?(node); end
end

RuboCop::Cop::Rails::OutputSafety::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Rails::OutputSafety::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# This cop enforces the use of `pick` over `pluck(...).first`.
#
# Using `pluck` followed by `first` creates an intermediate array, which
# `pick` avoids. When called on an Active Record relation, `pick` adds a
# limit to the query so that only one value is fetched from the database.
#
# @example
#   # bad
#   Model.pluck(:a).first
#   [{ a: :b, c: :d }].pluck(:a, :b).first
#
#   # good
#   Model.pick(:a)
#   [{ a: :b, c: :d }].pick(:a, :b)
class RuboCop::Cop::Rails::Pick < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector
  extend ::RuboCop::Cop::TargetRailsVersion

  def on_send(node); end
  def pick_candidate?(param0 = T.unsafe(nil)); end

  private

  def message(receiver); end
end

RuboCop::Cop::Rails::Pick::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Rails::Pick::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# This cop enforces the use of `pluck` over `map`.
#
# `pluck` can be used instead of `map` to extract a single key from each
# element in an enumerable. When called on an Active Record relation, it
# results in a more efficient query that only selects the necessary key.
#
# @example
#   # bad
#   Post.published.map { |post| post[:title] }
#   [{ a: :b, c: :d }].collect { |el| el[:a] }
#
#   # good
#   Post.published.pluck(:title)
#   [{ a: :b, c: :d }].pluck(:a)
class RuboCop::Cop::Rails::Pluck < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector
  extend ::RuboCop::Cop::TargetRailsVersion

  def on_block(node); end
  def on_numblock(node); end
  def pluck_candidate?(param0 = T.unsafe(nil)); end

  private

  def message(value, node); end
  def offense_range(node); end
end

RuboCop::Cop::Rails::Pluck::MSG = T.let(T.unsafe(nil), String)

# This cop enforces the use of `ids` over `pluck(:id)` and `pluck(primary_key)`.
#
# @example
#   # bad
#   User.pluck(:id)
#   user.posts.pluck(:id)
#
#   def self.user_ids
#   pluck(primary_key)
#   end
#
#   # good
#   User.ids
#   user.posts.ids
#
#   def self.user_ids
#   ids
#   end
class RuboCop::Cop::Rails::PluckId < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::ActiveRecordHelper
  extend ::RuboCop::Cop::AutoCorrector

  def on_send(node); end
  def pluck_id_call?(param0 = T.unsafe(nil)); end

  private

  def offense_range(node); end
end

RuboCop::Cop::Rails::PluckId::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Rails::PluckId::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# This cop identifies places where `pluck` is used in `where` query methods
# and can be replaced with `select`.
#
# Since `pluck` is an eager method and hits the database immediately,
# using `select` helps to avoid additional database queries.
#
# This cop has two different enforcement modes. When the `EnforcedStyle`
# is `conservative` (the default) then only calls to `pluck` on a constant
# (i.e. a model class) in the `where` is used as offenses.
#
# @example
#   # bad
#   Post.where(user_id: User.active.pluck(:id))
#
#   # good
#   Post.where(user_id: User.active.select(:id))
#   Post.where(user_id: active_users.select(:id))
# @example EnforcedStyle: conservative (default)
#   # good
#   Post.where(user_id: active_users.pluck(:id))
# @example EnforcedStyle: aggressive
#   # bad
#   Post.where(user_id: active_users.pluck(:id))
class RuboCop::Cop::Rails::PluckInWhere < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ActiveRecordHelper
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  extend ::RuboCop::Cop::AutoCorrector

  def on_send(node); end

  private

  def root_receiver(node); end
end

RuboCop::Cop::Rails::PluckInWhere::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Rails::PluckInWhere::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# This cop checks for correct grammar when using ActiveSupport's
# core extensions to the numeric classes.
#
# @example
#   # bad
#   3.day.ago
#   1.months.ago
#
#   # good
#   3.days.ago
#   1.month.ago
class RuboCop::Cop::Rails::PluralizationGrammar < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  def on_send(node); end

  private

  def correct_method(method_name); end

  # @return [Boolean]
  def duration_method?(method_name); end

  # @return [Boolean]
  def literal_number?(node); end

  def message(number, method_name); end

  # @return [Boolean]
  def offense?(node); end

  # @return [Boolean]
  def plural_method?(method_name); end

  # @return [Boolean]
  def plural_receiver?(number); end

  def pluralize(method_name); end

  # @return [Boolean]
  def singular_method?(method_name); end

  # @return [Boolean]
  def singular_receiver?(number); end

  def singularize(method_name); end
end

RuboCop::Cop::Rails::PluralizationGrammar::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Rails::PluralizationGrammar::PLURAL_DURATION_METHODS = T.let(T.unsafe(nil), Hash)
RuboCop::Cop::Rails::PluralizationGrammar::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)
RuboCop::Cop::Rails::PluralizationGrammar::SINGULAR_DURATION_METHODS = T.let(T.unsafe(nil), Hash)

# This cop checks code that can be written more easily using
# `Object#presence` defined by Active Support.
#
# @example
#   # bad
#   a.present? ? a : nil
#
#   # bad
#   !a.present? ? nil : a
#
#   # bad
#   a.blank? ? nil : a
#
#   # bad
#   !a.blank? ? a : nil
#
#   # good
#   a.presence
# @example
#   # bad
#   a.present? ? a : b
#
#   # bad
#   !a.present? ? b : a
#
#   # bad
#   a.blank? ? b : a
#
#   # bad
#   !a.blank? ? a : b
#
#   # good
#   a.presence || b
class RuboCop::Cop::Rails::Presence < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  def on_if(node); end
  def redundant_negative_receiver_and_other(param0 = T.unsafe(nil)); end
  def redundant_receiver_and_other(param0 = T.unsafe(nil)); end

  private

  def build_source_for_or_method(other); end

  # @return [Boolean]
  def ignore_if_node?(node); end

  # @return [Boolean]
  def ignore_other_node?(node); end

  def message(node, receiver, other); end
  def register_offense(node, receiver, other); end
  def replacement(receiver, other); end
end

RuboCop::Cop::Rails::Presence::MSG = T.let(T.unsafe(nil), String)

# This cop checks for code that can be written with simpler conditionals
# using `Object#present?` defined by Active Support.
#
# Interaction with `Style/UnlessElse`:
# The configuration of `NotBlank` will not produce an offense in the
# context of `unless else` if `Style/UnlessElse` is inabled. This is
# to prevent interference between the auto-correction of the two cops.
#
# @example NotNilAndNotEmpty: true (default)
#   # Converts usages of `!nil? && !empty?` to `present?`
#
#   # bad
#   !foo.nil? && !foo.empty?
#
#   # bad
#   foo != nil && !foo.empty?
#
#   # good
#   foo.present?
# @example NotBlank: true (default)
#   # Converts usages of `!blank?` to `present?`
#
#   # bad
#   !foo.blank?
#
#   # bad
#   not foo.blank?
#
#   # good
#   foo.present?
# @example UnlessBlank: true (default)
#   # Converts usages of `unless blank?` to `if present?`
#
#   # bad
#   something unless foo.blank?
#
#   # good
#   something if foo.present?
class RuboCop::Cop::Rails::Present < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  def autocorrect(corrector, node); end
  def exists_and_not_empty?(param0 = T.unsafe(nil)); end
  def not_blank?(param0 = T.unsafe(nil)); end
  def on_and(node); end
  def on_if(node); end
  def on_or(node); end
  def on_send(node); end
  def unless_blank?(param0 = T.unsafe(nil)); end

  private

  def replacement(node); end
  def unless_condition(node, method_call); end
end

RuboCop::Cop::Rails::Present::MSG_EXISTS_AND_NOT_EMPTY = T.let(T.unsafe(nil), String)
RuboCop::Cop::Rails::Present::MSG_NOT_BLANK = T.let(T.unsafe(nil), String)
RuboCop::Cop::Rails::Present::MSG_UNLESS_BLANK = T.let(T.unsafe(nil), String)
RuboCop::Cop::Rails::Present::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# This cop checks for Rake tasks without the `:environment` task
# dependency. The `:environment` task loads application code for other
# Rake tasks. Without it, tasks cannot make use of application code like
# models.
#
# You can ignore the offense if the task satisfies at least one of the
# following conditions:
#
# * The task does not need application code.
# * The task invokes the `:environment` task.
#
# @example
#   # bad
#   task :foo do
#   do_something
#   end
#
#   # good
#   task foo: :environment do
#   do_something
#   end
class RuboCop::Cop::Rails::RakeEnvironment < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  def on_block(node); end
  def task_definition?(param0 = T.unsafe(nil)); end

  private

  def correct_task_dependency(task_name); end
  def task_name(node); end

  # @return [Boolean]
  def with_dependencies?(node); end

  # @return [Boolean]
  def with_hash_style_dependencies?(hash_node); end
end

RuboCop::Cop::Rails::RakeEnvironment::MSG = T.let(T.unsafe(nil), String)

# This cop checks for the use of the `read_attribute` or `write_attribute`
# methods and recommends square brackets instead.
#
# If an attribute is missing from the instance (for example, when
# initialized by a partial `select`) then `read_attribute`
# will return nil, but square brackets will raise
# an `ActiveModel::MissingAttributeError`.
#
# Explicitly raising an error in this situation is preferable, and that
# is why rubocop recommends using square brackets.
#
# When called from within a method with the same name as the attribute,
# `read_attribute` and `write_attribute` must be used to prevent an
# infinite loop:
#
# @example
#
#   # bad
#   x = read_attribute(:attr)
#   write_attribute(:attr, val)
#
#   # good
#   x = self[:attr]
#   self[:attr] = val
# @example
#
#   # good
#   def foo
#   bar || read_attribute(:foo)
#   end
class RuboCop::Cop::Rails::ReadWriteAttribute < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  def on_send(node); end
  def read_write_attribute?(param0 = T.unsafe(nil)); end

  private

  def build_message(node); end
  def multi_line_message(node); end
  def node_replacement(node); end
  def read_attribute_replacement(node); end
  def single_line_message(node); end

  # @return [Boolean]
  def within_shadowing_method?(node); end

  def write_attribute_replacement(node); end
end

RuboCop::Cop::Rails::ReadWriteAttribute::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Rails::ReadWriteAttribute::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Checks Rails model validations for a redundant `allow_nil` when
# `allow_blank` is present.
#
# @example
#   # bad
#   validates :x, length: { is: 5 }, allow_nil: true, allow_blank: true
#
#   # bad
#   validates :x, length: { is: 5 }, allow_nil: false, allow_blank: true
#
#   # bad
#   validates :x, length: { is: 5 }, allow_nil: false, allow_blank: false
#
#   # good
#   validates :x, length: { is: 5 }, allow_blank: true
#
#   # good
#   validates :x, length: { is: 5 }, allow_blank: false
#
#   # good
#   # Here, `nil` is valid but `''` is not
#   validates :x, length: { is: 5 }, allow_nil: true, allow_blank: false
class RuboCop::Cop::Rails::RedundantAllowNil < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  def on_send(node); end

  private

  def find_allow_nil_and_allow_blank(node); end
  def node_beg(node); end
  def node_end(node); end
  def register_offense(allow_nil, message); end
end

RuboCop::Cop::Rails::RedundantAllowNil::MSG_ALLOW_NIL_FALSE = T.let(T.unsafe(nil), String)
RuboCop::Cop::Rails::RedundantAllowNil::MSG_SAME = T.let(T.unsafe(nil), String)
RuboCop::Cop::Rails::RedundantAllowNil::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# This cop detects cases where the `:foreign_key` option on associations
# is redundant.
#
# @example
#   # bad
#   class Post
#   has_many :comments, foreign_key: 'post_id'
#   end
#
#   class Comment
#   belongs_to :post, foreign_key: 'post_id'
#   end
#
#   # good
#   class Post
#   has_many :comments
#   end
#
#   class Comment
#   belongs_to :author, foreign_key: 'user_id'
#   end
class RuboCop::Cop::Rails::RedundantForeignKey < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  def association_with_foreign_key(param0 = T.unsafe(nil)); end
  def on_send(node); end

  private

  def default_foreign_key(node, association_type, association_name, options); end
  def find_as_option(options); end

  # @return [Boolean]
  def redundant?(node, association_type, association_name, options, foreign_key); end
end

RuboCop::Cop::Rails::RedundantForeignKey::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Rails::RedundantForeignKey::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Since Rails 5.0 the default for `belongs_to` is `optional: false`
# unless `config.active_record.belongs_to_required_by_default` is
# explicitly set to `false`. The presence validator is added
# automatically, and explicit presence validation is redundant.
#
# @example
#   # bad
#   belongs_to :user
#   validates :user, presence: true
#
#   # bad
#   belongs_to :user
#   validates :user_id, presence: true
#
#   # bad
#   belongs_to :author, foreign_key: :user_id
#   validates :user_id, presence: true
#
#   # good
#   belongs_to :user
#
#   # good
#   belongs_to :author, foreign_key: :user_id
class RuboCop::Cop::Rails::RedundantPresenceValidationOnBelongsTo < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector
  extend ::RuboCop::Cop::TargetRailsVersion

  # Match a class with `belongs_to` with no regard to `foreign_key` option
  #
  # @example source that matches
  #   belongs_to :user
  # @example source that matches - regardless of `foreign_key`
  #   belongs_to :author, foreign_key: :user_id
  # @param node [RuboCop::AST::Node]
  # @param association [Symbol]
  # @return [Array<RuboCop::AST::Node>, nil] matching node
  def any_belongs_to?(param0 = T.unsafe(nil), association:); end

  # Match a class with a matching association, either by name or an explicit
  # `foreign_key` option
  #
  # @example source that matches - fk matches `foreign_key` option
  #   belongs_to :author, foreign_key: :user_id
  # @example source that matches - key matches association name
  #   belongs_to :user
  # @example source that does not match - explicit `foreign_key` does not match
  #   belongs_to :user, foreign_key: :account_id
  # @param node [RuboCop::AST::Node]
  # @param key [Symbol] e.g. `:user`
  # @param fk [Symbol] e.g. `:user_id`
  # @return [Array<RuboCop::AST::Node>] matching nodes
  def belongs_to?(param0 = T.unsafe(nil), key:, fk:); end

  # Match a matching `belongs_to` association with a matching explicit `foreign_key` option
  #
  # @example source that matches
  #   belongs_to :author, foreign_key: :user_id
  # @param node [RuboCop::AST::Node]
  # @param fk [Symbol] e.g. `:user_id`
  # @return [Array<RuboCop::AST::Node>] matching nodes
  def belongs_to_with_a_matching_fk?(param0 = T.unsafe(nil), param1); end

  # Match a matching `belongs_to` association, without an explicit `foreign_key` option
  #
  # @param node [RuboCop::AST::Node]
  # @param key [Symbol] e.g. `:user`
  # @return [Array<RuboCop::AST::Node>] matching nodes
  def belongs_to_without_fk?(param0 = T.unsafe(nil), param1); end

  def on_send(node); end

  # Match a `belongs_to` association with an optional option in a hash
  def optional?(param0 = T.unsafe(nil)); end

  # Match an optional option in a hash
  def optional_option?(param0 = T.unsafe(nil)); end

  # Match a `validates` statement with a presence check
  #
  # @example source that matches - by association
  #   validates :user, presence: true
  # @example source that matches - by association
  #   validates :name, :user, presence: true
  # @example source that matches - by a foreign key
  #   validates :user_id, presence: true
  # @example source that DOES NOT match - strict validation
  #   validates :user_id, presence: true, strict: true
  # @example source that DOES NOT match - custom strict validation
  #   validates :user_id, presence: true, strict: MissingUserError
  def presence_validation?(param0 = T.unsafe(nil)); end

  private

  def add_offense_and_correct(node, all_keys, keys, options, presence); end
  def belongs_to_for(model_class_node, key); end
  def extract_validation_for_keys(corrector, node, keys, options); end
  def message_for(keys); end
  def non_optional_belongs_to(node, keys); end
  def remove_keys_from_validation(corrector, node, keys); end
  def remove_presence_option(corrector, presence); end
  def remove_validation(corrector, node); end
  def validation_range(node); end
end

RuboCop::Cop::Rails::RedundantPresenceValidationOnBelongsTo::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Rails::RedundantPresenceValidationOnBelongsTo::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# This cop checks for redundant receiver in `with_options`.
# Receiver is implicit from Rails 4.2 or higher.
#
# @example
#   # bad
#   class Account < ApplicationRecord
#   with_options dependent: :destroy do |assoc|
#   assoc.has_many :customers
#   assoc.has_many :products
#   assoc.has_many :invoices
#   assoc.has_many :expenses
#   end
#   end
#
#   # good
#   class Account < ApplicationRecord
#   with_options dependent: :destroy do
#   has_many :customers
#   has_many :products
#   has_many :invoices
#   has_many :expenses
#   end
#   end
# @example
#   # bad
#   with_options options: false do |merger|
#   merger.invoke(merger.something)
#   end
#
#   # good
#   with_options options: false do
#   invoke(something)
#   end
#
#   # good
#   client = Client.new
#   with_options options: false do |merger|
#   client.invoke(merger.something, something)
#   end
#
#   # ok
#   # When `with_options` includes a block, all scoping scenarios
#   # cannot be evaluated. Thus, it is ok to include the explicit
#   # receiver.
#   with_options options: false do |merger|
#   merger.invoke
#   with_another_method do |another_receiver|
#   merger.invoke(another_receiver)
#   end
#   end
class RuboCop::Cop::Rails::RedundantReceiverInWithOptions < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  def all_block_nodes_in(param0); end
  def all_send_nodes_in(param0); end
  def on_block(node); end
  def with_options?(param0 = T.unsafe(nil)); end

  private

  def autocorrect(corrector, node); end
  def block_argument_range(node); end

  # @return [Boolean]
  def same_value?(arg_node, recv_node); end

  def search_begin_pos_of_space_before_block_argument(begin_pos); end
end

RuboCop::Cop::Rails::RedundantReceiverInWithOptions::MSG = T.let(T.unsafe(nil), String)

# This cop checks for redundant `travel_back` calls.
# Since Rails 5.2, `travel_back` is automatically called at the end of the test.
#
# @example
#
#   # bad
#   def teardown
#   do_something
#   travel_back
#   end
#
#   # good
#   def teardown
#   do_something
#   end
#
#   # bad
#   after do
#   do_something
#   travel_back
#   end
#
#   # good
#   after do
#   do_something
#   end
class RuboCop::Cop::Rails::RedundantTravelBack < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector
  extend ::RuboCop::Cop::TargetRailsVersion

  def on_send(node); end
end

RuboCop::Cop::Rails::RedundantTravelBack::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Rails::RedundantTravelBack::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# This cop checks if the value of the option `class_name`, in
# the definition of a reflection is a string.
#
# @example
#   # bad
#   has_many :accounts, class_name: Account
#   has_many :accounts, class_name: Account.name
#
#   # good
#   has_many :accounts, class_name: 'Account'
class RuboCop::Cop::Rails::ReflectionClassName < ::RuboCop::Cop::Base
  def association_with_reflection(param0 = T.unsafe(nil)); end
  def on_send(node); end
  def reflection_class_name(param0 = T.unsafe(nil)); end

  private

  # @return [Boolean]
  def reflection_class_value?(class_value); end
end

RuboCop::Cop::Rails::ReflectionClassName::ALLOWED_REFLECTION_CLASS_TYPES = T.let(T.unsafe(nil), Array)
RuboCop::Cop::Rails::ReflectionClassName::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Rails::ReflectionClassName::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Use `assert_not` methods instead of `refute` methods.
#
# @example EnforcedStyle: assert_not (default)
#   # bad
#   refute false
#   refute_empty [1, 2, 3]
#   refute_equal true, false
#
#   # good
#   assert_not false
#   assert_not_empty [1, 2, 3]
#   assert_not_equal true, false
# @example EnforcedStyle: refute
#   # bad
#   assert_not false
#   assert_not_empty [1, 2, 3]
#   assert_not_equal true, false
#
#   # good
#   refute false
#   refute_empty [1, 2, 3]
#   refute_equal true, false
class RuboCop::Cop::Rails::RefuteMethods < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  extend ::RuboCop::Cop::AutoCorrector

  def offensive?(param0 = T.unsafe(nil)); end
  def on_send(node); end

  private

  # @return [Boolean]
  def bad_method?(method_name); end

  def convert_good_method(bad_method); end
  def offense_message(method_name); end
end

RuboCop::Cop::Rails::RefuteMethods::ASSERT_NOT_METHODS = T.let(T.unsafe(nil), Array)
RuboCop::Cop::Rails::RefuteMethods::CORRECTIONS = T.let(T.unsafe(nil), Hash)
RuboCop::Cop::Rails::RefuteMethods::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Rails::RefuteMethods::REFUTE_METHODS = T.let(T.unsafe(nil), Array)
RuboCop::Cop::Rails::RefuteMethods::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# This cop checks whether constant value isn't relative date.
# Because the relative date will be evaluated only once.
#
# @example
#   # bad
#   class SomeClass
#   EXPIRED_AT = 1.week.since
#   end
#
#   # good
#   class SomeClass
#   EXPIRES = 1.week
#
#   def self.expired_at
#   EXPIRES.since
#   end
#   end
#
#   # good
#   class SomeClass
#   def self.expired_at
#   1.week.since
#   end
#   end
class RuboCop::Cop::Rails::RelativeDateConstant < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  def on_casgn(node); end
  def on_masgn(node); end
  def on_or_asgn(node); end
  def relative_date(param0 = T.unsafe(nil)); end
  def relative_date_or_assignment(param0 = T.unsafe(nil)); end

  private

  def autocorrect(corrector, node); end
  def message(method_name); end
  def nested_relative_date(node, &callback); end
  def offense_range(name, value); end
end

RuboCop::Cop::Rails::RelativeDateConstant::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Rails::RelativeDateConstant::RELATIVE_DATE_METHODS = T.let(T.unsafe(nil), Set)

# This cop looks for inline rendering within controller actions.
#
# @example
#   # bad
#   class ProductsController < ApplicationController
#   def index
#   render inline: "<% products.each do |p| %><p><%= p.name %></p><% end %>", type: :erb
#   end
#   end
#
#   # good
#   # app/views/products/index.html.erb
#   # <% products.each do |p| %>
#   #   <p><%= p.name %></p>
#   # <% end %>
#
#   class ProductsController < ApplicationController
#   def index
#   end
#   end
class RuboCop::Cop::Rails::RenderInline < ::RuboCop::Cop::Base
  def on_send(node); end
  def render_with_inline_option?(param0 = T.unsafe(nil)); end
end

RuboCop::Cop::Rails::RenderInline::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Rails::RenderInline::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# This cop identifies places where `render text:` can be
# replaced with `render plain:`.
#
# @example
#   # bad - explicit MIME type to `text/plain`
#   render text: 'Ruby!', content_type: 'text/plain'
#
#   # good - short and precise
#   render plain: 'Ruby!'
#
#   # good - explicit MIME type not to `text/plain`
#   render text: 'Ruby!', content_type: 'text/html'
# @example ContentTypeCompatibility: true (default)
#   # good - sets MIME type to `text/html`
#   render text: 'Ruby!'
# @example ContentTypeCompatibility: false
#   # bad - sets MIME type to `text/html`
#   render text: 'Ruby!'
class RuboCop::Cop::Rails::RenderPlainText < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  def on_send(node); end
  def render_plain_text?(param0 = T.unsafe(nil)); end

  private

  # @return [Boolean]
  def compatible_content_type?(node); end

  def find_content_type(node); end
  def replacement(rest_options, option_value); end
end

RuboCop::Cop::Rails::RenderPlainText::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Rails::RenderPlainText::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# This cop checks for consistent uses of `request.referer` or
# `request.referrer`, depending on the cop's configuration.
#
# @example EnforcedStyle: referer (default)
#   # bad
#   request.referrer
#
#   # good
#   request.referer
# @example EnforcedStyle: referrer
#   # bad
#   request.referer
#
#   # good
#   request.referrer
class RuboCop::Cop::Rails::RequestReferer < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  extend ::RuboCop::Cop::AutoCorrector

  def on_send(node); end
  def referer?(param0 = T.unsafe(nil)); end

  private

  def message(_range); end
  def wrong_method_name; end
end

RuboCop::Cop::Rails::RequestReferer::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Rails::RequestReferer::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# This cop checks for the usage of `require_dependency`.
#
# `require_dependency` is an obsolete method for Rails applications running in Zeitwerk mode.
# In Zeitwerk mode, the semantics should match Ruby's and no need to be defensive with load order,
# just refer to classes and modules normally.
# If the constant name is dynamic, camelize if needed, and constantize.
#
# Applications running in Zeitwerk mode should not use `require_dependency`.
#
# NOTE: This cop is disabled by default. Please enable it if you are using Zeitwerk mode.
#
# @example
#   # bad
#   require_dependency 'some_lib'
class RuboCop::Cop::Rails::RequireDependency < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::TargetRailsVersion

  def on_send(node); end
  def require_dependency_call?(param0 = T.unsafe(nil)); end
end

RuboCop::Cop::Rails::RequireDependency::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Rails::RequireDependency::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# This cop checks whether the change method of the migration file is
# reversible.
#
# @example
#   # bad
#   def change
#   change_table :users do |t|
#   t.remove :name
#   end
#   end
#
#   # good
#   def change
#   create_table :users do |t|
#   t.string :name
#   end
#   end
#
#   # good
#   def change
#   reversible do |dir|
#   change_table :users do |t|
#   dir.up do
#   t.column :name, :string
#   end
#
#   dir.down do
#   t.remove :name
#   end
#   end
#   end
#   end
# @example
#   # drop_table
#
#   # bad
#   def change
#   drop_table :users
#   end
#
#   # good
#   def change
#   drop_table :users do |t|
#   t.string :name
#   end
#   end
# @example
#   # change_column_default
#
#   # bad
#   def change
#   change_column_default(:suppliers, :qualification, 'new')
#   end
#
#   # good
#   def change
#   change_column_default(:posts, :state, from: nil, to: "draft")
#   end
# @example
#   # remove_column
#
#   # bad
#   def change
#   remove_column(:suppliers, :qualification)
#   end
#
#   # good
#   def change
#   remove_column(:suppliers, :qualification, :string)
#   end
# @example
#   # remove_foreign_key
#
#   # bad
#   def change
#   remove_foreign_key :accounts, column: :owner_id
#   end
#
#   # good
#   def change
#   remove_foreign_key :accounts, :branches
#   end
#
#   # good
#   def change
#   remove_foreign_key :accounts, to_table: :branches
#   end
# @example
#   # change_table
#
#   # bad
#   def change
#   change_table :users do |t|
#   t.remove :name
#   t.change_default :authorized, 1
#   t.change :price, :string
#   end
#   end
#
#   # good
#   def change
#   change_table :users do |t|
#   t.string :name
#   end
#   end
#
#   # good
#   def change
#   reversible do |dir|
#   change_table :users do |t|
#   dir.up do
#   t.change :price, :string
#   end
#
#   dir.down do
#   t.change :price, :integer
#   end
#   end
#   end
#   end
# @example
#   # remove_columns
#
#   # bad
#   def change
#   remove_columns :users, :name, :email
#   end
#
#   # good
#   def change
#   reversible do |dir|
#   dir.up do
#   remove_columns :users, :name, :email
#   end
#
#   dir.down do
#   add_column :users, :name, :string
#   add_column :users, :email, :string
#   end
#   end
#   end
#
#   # good (Rails >= 6.1, see https://github.com/rails/rails/pull/36589)
#   def change
#   remove_columns :users, :name, :email, type: :string
#   end
# @example
#   # remove_index
#
#   # bad
#   def change
#   remove_index :users, name: :index_users_on_email
#   end
#
#   # good
#   def change
#   remove_index :users, :email
#   end
#
#   # good
#   def change
#   remove_index :users, column: :email
#   end
# @see https://api.rubyonrails.org/classes/ActiveRecord/Migration/CommandRecorder.html
class RuboCop::Cop::Rails::ReversibleMigration < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::MigrationsHelper

  def change_table_call(param0 = T.unsafe(nil)); end
  def drop_table_call(param0 = T.unsafe(nil)); end
  def irreversible_schema_statement_call(param0 = T.unsafe(nil)); end
  def on_block(node); end
  def on_send(node); end
  def remove_column_call(param0 = T.unsafe(nil)); end
  def remove_columns_call(param0 = T.unsafe(nil)); end
  def remove_foreign_key_call(param0 = T.unsafe(nil)); end
  def remove_index_call(param0 = T.unsafe(nil)); end

  private

  # @return [Boolean]
  def all_hash_key?(args, *keys); end

  def check_change_table_node(node, block); end
  def check_change_table_offense(receiver, node); end
  def check_drop_table_node(node); end
  def check_irreversible_schema_statement_node(node); end
  def check_remove_column_node(node); end
  def check_remove_columns_node(node); end
  def check_remove_foreign_key_node(node); end
  def check_remove_index_node(node); end
  def check_reversible_hash_node(node); end

  # @return [Boolean]
  def reversible_change_table_call?(node); end

  # @return [Boolean]
  def within_change_method?(node); end

  # @return [Boolean]
  def within_reversible_or_up_only_block?(node); end
end

RuboCop::Cop::Rails::ReversibleMigration::MSG = T.let(T.unsafe(nil), String)

# This cop checks whether the migration implements
# either a `change` method or both an `up` and a `down`
# method.
#
# @example
#   # bad
#   class SomeMigration < ActiveRecord::Migration[6.0]
#   def up
#   # up migration
#   end
#
#   # <----- missing down method
#   end
#
#   class SomeMigration < ActiveRecord::Migration[6.0]
#   # <----- missing up method
#
#   def down
#   # down migration
#   end
#   end
#
#   # good
#   class SomeMigration < ActiveRecord::Migration[6.0]
#   def change
#   # reversible migration
#   end
#   end
#
#   # good
#   class SomeMigration < ActiveRecord::Migration[6.0]
#   def up
#   # up migration
#   end
#
#   def down
#   # down migration
#   end
#   end
class RuboCop::Cop::Rails::ReversibleMigrationMethodDefinition < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::MigrationsHelper

  def change_method?(param0 = T.unsafe(nil)); end
  def on_class(node); end
  def up_and_down_methods?(param0 = T.unsafe(nil)); end
end

RuboCop::Cop::Rails::ReversibleMigrationMethodDefinition::MSG = T.let(T.unsafe(nil), String)

# Use a single `#join` instead of chaining on `Rails.root` or `Rails.public_path`.
#
# @example
#   # bad
#   Rails.root.join('db').join('schema.rb')
#   Rails.root.join('db').join(migrate).join('migration.rb')
#   Rails.public_path.join('path').join('file.pdf')
#   Rails.public_path.join('path').join(to).join('file.pdf')
#
#   # good
#   Rails.root.join('db', 'schema.rb')
#   Rails.root.join('db', migrate, 'migration.rb')
#   Rails.public_path.join('path', 'file.pdf')
#   Rails.public_path.join('path', to, 'file.pdf')
class RuboCop::Cop::Rails::RootJoinChain < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  def join?(param0 = T.unsafe(nil)); end
  def on_send(node); end
  def rails_root?(param0 = T.unsafe(nil)); end

  private

  def evidence(node); end
end

RuboCop::Cop::Rails::RootJoinChain::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Rails::RootJoinChain::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Set)

# This cop converts usages of `try!` to `&.`. It can also be configured
# to convert `try`. It will convert code to use safe navigation.
#
# @example ConvertTry: false (default)
#   # bad
#   foo.try!(:bar)
#   foo.try!(:bar, baz)
#   foo.try!(:bar) { |e| e.baz }
#
#   foo.try!(:[], 0)
#
#   # good
#   foo.try(:bar)
#   foo.try(:bar, baz)
#   foo.try(:bar) { |e| e.baz }
#
#   foo&.bar
#   foo&.bar(baz)
#   foo&.bar { |e| e.baz }
# @example ConvertTry: true
#   # bad
#   foo.try!(:bar)
#   foo.try!(:bar, baz)
#   foo.try!(:bar) { |e| e.baz }
#   foo.try(:bar)
#   foo.try(:bar, baz)
#   foo.try(:bar) { |e| e.baz }
#
#   # good
#   foo&.bar
#   foo&.bar(baz)
#   foo&.bar { |e| e.baz }
class RuboCop::Cop::Rails::SafeNavigation < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  def on_send(node); end
  def try_call(param0 = T.unsafe(nil)); end

  private

  def autocorrect(corrector, node); end
  def replacement(method, params); end

  class << self
    def autocorrect_incompatible_with; end
  end
end

RuboCop::Cop::Rails::SafeNavigation::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Rails::SafeNavigation::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# This cop checks to make sure safe navigation isn't used with `blank?` in
# a conditional.
#
# @example
#   # bad
#   do_something if foo&.blank?
#   do_something unless foo&.blank?
#
#   # good
#   do_something if foo.blank?
#   do_something unless foo.blank?
class RuboCop::Cop::Rails::SafeNavigationWithBlank < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  def on_if(node); end
  def safe_navigation_blank_in_conditional?(param0 = T.unsafe(nil)); end
end

RuboCop::Cop::Rails::SafeNavigationWithBlank::MSG = T.let(T.unsafe(nil), String)

# This cop identifies possible cases where Active Record save! or related
# should be used instead of save because the model might have failed to
# save and an exception is better than unhandled failure.
#
# This will allow:
#
# * update or save calls, assigned to a variable,
#   or used as a condition in an if/unless/case statement.
# * create calls, assigned to a variable that then has a
#   call to `persisted?`, or whose return value is checked by
#   `persisted?` immediately
# * calls if the result is explicitly returned from methods and blocks,
#   or provided as arguments.
# * calls whose signature doesn't look like an ActiveRecord
#   persistence method.
#
# By default it will also allow implicit returns from methods and blocks.
# that behavior can be turned off with `AllowImplicitReturn: false`.
#
# You can permit receivers that are giving false positives with
# `AllowedReceivers: []`
#
# @example
#
#   # bad
#   user.save
#   user.update(name: 'Joe')
#   user.find_or_create_by(name: 'Joe')
#   user.destroy
#
#   # good
#   unless user.save
#   # ...
#   end
#   user.save!
#   user.update!(name: 'Joe')
#   user.find_or_create_by!(name: 'Joe')
#   user.destroy!
#
#   user = User.find_or_create_by(name: 'Joe')
#   unless user.persisted?
#   # ...
#   end
#
#   def save_user
#   return user.save
#   end
# @example AllowImplicitReturn: true (default)
#
#   # good
#   users.each { |u| u.save }
#
#   def save_user
#   user.save
#   end
# @example AllowImplicitReturn: false
#
#   # bad
#   users.each { |u| u.save }
#   def save_user
#   user.save
#   end
#
#   # good
#   users.each { |u| u.save! }
#
#   def save_user
#   user.save!
#   end
#
#   def save_user
#   return user.save
#   end
# @example AllowedReceivers: ['merchant.customers', 'Service::Mailer']
#
#   # bad
#   merchant.create
#   customers.builder.save
#   Mailer.create
#
#   module Service::Mailer
#   self.create
#   end
#
#   # good
#   merchant.customers.create
#   MerchantService.merchant.customers.destroy
#   Service::Mailer.update(message: 'Message')
#   ::Service::Mailer.update
#   Services::Service::Mailer.update(message: 'Message')
#   Service::Mailer::update
class RuboCop::Cop::Rails::SaveBang < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::NegativeConditional
  extend ::RuboCop::Cop::AutoCorrector

  def after_leaving_scope(scope, _variable_table); end
  def check_assignment(assignment); end
  def on_csend(node); end
  def on_send(node); end

  private

  # @return [Boolean]
  def allowed_receiver?(node); end

  # @return [Boolean]
  def argument?(node); end

  def array_parent(node); end
  def assignable_node(node); end

  # @return [Boolean]
  def call_to_persisted?(node); end

  def check_used_in_condition_or_compound_boolean(node); end

  # @return [Boolean]
  def checked_immediately?(node); end

  # @return [Boolean]
  def conditional?(parent); end

  # Const == Const
  # ::Const == ::Const
  # ::Const == Const
  # Const == ::Const
  # NameSpace::Const == Const
  # NameSpace::Const == NameSpace::Const
  # NameSpace::Const != ::Const
  # Const != NameSpace::Const
  #
  # @return [Boolean]
  def const_matches?(const, allowed_const); end

  # Check argument signature as no arguments or one hash
  #
  # @return [Boolean]
  def expected_signature?(node); end

  # @return [Boolean]
  def explicit_return?(node); end

  def find_method_with_sibling_index(node, sibling_index = T.unsafe(nil)); end
  def hash_parent(node); end

  # @return [Boolean]
  def implicit_return?(node); end

  # @return [Boolean]
  def in_condition_or_compound_boolean?(node); end

  # @return [Boolean]
  def operator_or_single_negative?(node); end

  # @return [Boolean]
  def persist_method?(node, methods = T.unsafe(nil)); end

  # @return [Boolean]
  def persisted_referenced?(assignment); end

  # @return [Boolean]
  def receiver_chain_matches?(node, allowed_receiver); end

  def register_offense(node, msg); end

  # @return [Boolean]
  def return_value_assigned?(node); end

  def right_assignment_node(assignment); end

  class << self
    def joining_forces; end
  end
end

RuboCop::Cop::Rails::SaveBang::CREATE_CONDITIONAL_MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Rails::SaveBang::CREATE_MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Rails::SaveBang::CREATE_PERSIST_METHODS = T.let(T.unsafe(nil), Array)
RuboCop::Cop::Rails::SaveBang::MODIFY_PERSIST_METHODS = T.let(T.unsafe(nil), Array)
RuboCop::Cop::Rails::SaveBang::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Rails::SaveBang::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# This cop enforces the use of the `comment` option when adding a new table or column
# to the database during a migration.
#
# @example
#   # bad (no comment for a new column or table)
#   add_column :table, :column, :integer
#
#   create_table :table do |t|
#   t.type :column
#   end
#
#   # good
#   add_column :table, :column, :integer, comment: 'Number of offenses'
#
#   create_table :table, comment: 'Table of offenses data' do |t|
#   t.type :column, comment: 'Number of offenses'
#   end
class RuboCop::Cop::Rails::SchemaComment < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ActiveRecordMigrationsHelper

  def add_column?(param0 = T.unsafe(nil)); end
  def add_column_with_comment?(param0 = T.unsafe(nil)); end
  def comment_present?(param0 = T.unsafe(nil)); end
  def create_table?(param0 = T.unsafe(nil)); end
  def create_table_with_comment?(param0 = T.unsafe(nil)); end
  def on_send(node); end
  def t_column?(param0 = T.unsafe(nil)); end
  def t_column_with_comment?(param0 = T.unsafe(nil)); end

  private

  # @return [Boolean]
  def add_column_without_comment?(node); end

  # @return [Boolean]
  def create_table_column_call_without_comment?(node); end

  # @return [Boolean]
  def create_table_without_comment?(node); end
end

RuboCop::Cop::Rails::SchemaComment::COLUMN_MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Rails::SchemaComment::CREATE_TABLE_COLUMN_METHODS = T.let(T.unsafe(nil), Set)
RuboCop::Cop::Rails::SchemaComment::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)
RuboCop::Cop::Rails::SchemaComment::TABLE_MSG = T.let(T.unsafe(nil), String)

# This cop checks for scope calls where it was passed
# a method (usually a scope) instead of a lambda/proc.
#
# @example
#
#   # bad
#   scope :something, where(something: true)
#
#   # good
#   scope :something, -> { where(something: true) }
class RuboCop::Cop::Rails::ScopeArgs < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  def on_send(node); end
  def scope?(param0 = T.unsafe(nil)); end
end

RuboCop::Cop::Rails::ScopeArgs::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Rails::ScopeArgs::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# This cop enforces that short forms of `I18n` methods are used:
# `t` instead of `translate` and `l` instead of `localize`.
#
# This cop has two different enforcement modes. When the EnforcedStyle
# is conservative (the default) then only `I18n.translate` and `I18n.localize`
# calls are added as offenses.
#
# When the EnforcedStyle is aggressive then all `translate` and `localize` calls
# without a receiver are added as offenses.
#
# @example
#   # bad
#   I18n.translate :key
#   I18n.localize Time.now
#
#   # good
#   I18n.t :key
#   I18n.l Time.now
# @example EnforcedStyle: conservative (default)
#   # good
#   translate :key
#   localize Time.now
#   t :key
#   l Time.now
# @example EnforcedStyle: aggressive
#   # bad
#   translate :key
#   localize Time.now
#
#   # good
#   t :key
#   l Time.now
class RuboCop::Cop::Rails::ShortI18n < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  extend ::RuboCop::Cop::AutoCorrector

  def long_i18n?(param0 = T.unsafe(nil)); end
  def on_send(node); end
end

RuboCop::Cop::Rails::ShortI18n::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Rails::ShortI18n::PREFERRED_METHODS = T.let(T.unsafe(nil), Hash)
RuboCop::Cop::Rails::ShortI18n::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# This cop checks for the use of methods which skip
# validations which are listed in
# https://guides.rubyonrails.org/active_record_validations.html#skipping-validations
#
# Methods may be ignored from this rule by configuring a `AllowedMethods`.
#
# @example
#   # bad
#   Article.first.decrement!(:view_count)
#   DiscussionBoard.decrement_counter(:post_count, 5)
#   Article.first.increment!(:view_count)
#   DiscussionBoard.increment_counter(:post_count, 5)
#   person.toggle :active
#   product.touch
#   Billing.update_all("category = 'authorized', author = 'David'")
#   user.update_attribute(:website, 'example.com')
#   user.update_columns(last_request_at: Time.current)
#   Post.update_counters 5, comment_count: -1, action_count: 1
#
#   # good
#   user.update(website: 'example.com')
#   FileUtils.touch('file')
# @example AllowedMethods: ["touch"]
#   # bad
#   DiscussionBoard.decrement_counter(:post_count, 5)
#   DiscussionBoard.increment_counter(:post_count, 5)
#   person.toggle :active
#
#   # good
#   user.touch
class RuboCop::Cop::Rails::SkipsModelValidations < ::RuboCop::Cop::Base
  # @return [SkipsModelValidations] a new instance of SkipsModelValidations
  def initialize(*_arg0); end

  def good_insert?(param0 = T.unsafe(nil)); end
  def good_touch?(param0 = T.unsafe(nil)); end
  def on_csend(node); end
  def on_send(node); end

  private

  # @return [Boolean]
  def allowed_method?(node); end

  def allowed_methods; end
  def forbidden_methods; end
  def message(node); end
end

RuboCop::Cop::Rails::SkipsModelValidations::METHODS_WITH_ARGUMENTS = T.let(T.unsafe(nil), Array)
RuboCop::Cop::Rails::SkipsModelValidations::MSG = T.let(T.unsafe(nil), String)

# Checks SQL heredocs to use `.squish`.
#
# @example
#   # bad
#   <<-SQL
#   SELECT * FROM posts;
#   SQL
#
#   <<-SQL
#   SELECT * FROM posts
#   WHERE id = 1
#   SQL
#
#   execute(<<~SQL, "Post Load")
#   SELECT * FROM posts
#   WHERE post_id = 1
#   SQL
#
#   # good
#   <<-SQL.squish
#   SELECT * FROM posts;
#   SQL
#
#   <<~SQL.squish
#   SELECT * FROM table
#   WHERE id = 1
#   SQL
#
#   execute(<<~SQL.squish, "Post Load")
#   SELECT * FROM posts
#   WHERE post_id = 1
#   SQL
class RuboCop::Cop::Rails::SquishedSQLHeredocs < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::Heredoc
  extend ::RuboCop::Cop::AutoCorrector

  def on_heredoc(node); end

  private

  def message(node); end

  # @return [Boolean]
  def offense_detected?(node); end

  # @return [Boolean]
  def sql_heredoc?(node); end

  # @return [Boolean]
  def using_squish?(node); end
end

RuboCop::Cop::Rails::SquishedSQLHeredocs::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Rails::SquishedSQLHeredocs::SQL = T.let(T.unsafe(nil), String)
RuboCop::Cop::Rails::SquishedSQLHeredocs::SQUISH = T.let(T.unsafe(nil), String)

# This cop enforces the absence of explicit table name assignment.
#
# `self.table_name=` should only be used for very good reasons,
# such as not having control over the database, or working
# on a legacy project.
#
# If you need to change how your model's name is translated to
# a table name, you may want to look at Inflections:
# https://api.rubyonrails.org/classes/ActiveSupport/Inflector/Inflections.html
#
# If you wish to add a prefix in front of your model, or wish to change
# the default prefix, `self.table_name_prefix` might better suit your needs:
# https://api.rubyonrails.org/classes/ActiveRecord/ModelSchema.html#method-c-table_name_prefix-3D
#
# STI base classes named `Base` are ignored by this cop.
# For more information: https://api.rubyonrails.org/classes/ActiveRecord/Inheritance.html
#
# @example
#   # bad
#   self.table_name = 'some_table_name'
#   self.table_name = :some_other_name
class RuboCop::Cop::Rails::TableNameAssignment < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ActiveRecordHelper

  def base_class?(param0 = T.unsafe(nil)); end
  def on_class(class_node); end
end

RuboCop::Cop::Rails::TableNameAssignment::MSG = T.let(T.unsafe(nil), String)

# This cop checks for the use of Time methods without zone.
#
# Built on top of Ruby on Rails style guide (https://rails.rubystyle.guide#time)
# and the article http://danilenko.org/2012/7/6/rails_timezones/
#
# Two styles are supported for this cop. When `EnforcedStyle` is 'strict'
# then only use of `Time.zone` is allowed.
#
# When EnforcedStyle is 'flexible' then it's also allowed
# to use `Time#in_time_zone`.
#
# @example
#   # bad
#   Time.now
#   Time.parse('2015-03-02T19:05:37')
#
#   # good
#   Time.current
#   Time.zone.now
#   Time.zone.parse('2015-03-02T19:05:37')
#   Time.zone.parse('2015-03-02T19:05:37Z') # Respect ISO 8601 format with timezone specifier.
# @example EnforcedStyle: strict
#   # `strict` means that `Time` should be used with `zone`.
#
#   # bad
#   Time.at(timestamp).in_time_zone
# @example EnforcedStyle: flexible (default)
#   # `flexible` allows usage of `in_time_zone` instead of `zone`.
#
#   # good
#   Time.at(timestamp).in_time_zone
class RuboCop::Cop::Rails::TimeZone < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  extend ::RuboCop::Cop::AutoCorrector

  def on_const(node); end

  private

  def acceptable_methods(klass, method_name, node); end

  # @return [Boolean]
  def attach_timezone_specifier?(date); end

  def autocorrect(corrector, node); end
  def autocorrect_time_new(node, corrector); end
  def build_message(klass, method_name, node); end
  def check_localtime(node); end
  def check_time_node(klass, node); end
  def extract_method_chain(node); end

  # @return [Boolean]
  def flexible?; end

  def good_methods; end

  # Only add the method to the chain if the method being
  # called is part of the time class.
  #
  # @return [Boolean]
  def method_from_time_class?(node); end

  # checks that parent node of send_type
  # and receiver is the given node
  #
  # @return [Boolean]
  def method_send?(node); end

  # @return [Boolean]
  def need_check_localtime?(chain); end

  # @return [Boolean]
  def not_danger_chain?(chain); end

  # Time.new can be called with a time zone offset
  # When it is, that should be considered safe
  # Example:
  # Time.new(1988, 3, 15, 3, 0, 0, "-05:00")
  #
  # @return [Boolean]
  def offset_provided?(node); end

  # remove redundant `.in_time_zone` from `Time.zone.now.in_time_zone`
  def remove_redundant_in_time_zone(corrector, node); end

  def safe_method(method_name, node); end

  # @return [Boolean]
  def strict?; end
end

RuboCop::Cop::Rails::TimeZone::ACCEPTED_METHODS = T.let(T.unsafe(nil), Array)
RuboCop::Cop::Rails::TimeZone::DANGEROUS_METHODS = T.let(T.unsafe(nil), Array)
RuboCop::Cop::Rails::TimeZone::GOOD_METHODS = T.let(T.unsafe(nil), Array)
RuboCop::Cop::Rails::TimeZone::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Rails::TimeZone::MSG_ACCEPTABLE = T.let(T.unsafe(nil), String)
RuboCop::Cop::Rails::TimeZone::MSG_LOCALTIME = T.let(T.unsafe(nil), String)
RuboCop::Cop::Rails::TimeZone::TIMEZONE_SPECIFIER = T.let(T.unsafe(nil), Regexp)

# This cop checks for the use of `Time.zone=` method.
#
# The `zone` attribute persists for the rest of the Ruby runtime, potentially causing
# unexpected behavior at a later time.
# Using `Time.use_zone` ensures the code passed in the block is the only place Time.zone is affected.
# It eliminates the possibility of a `zone` sticking around longer than intended.
#
# @example
#   # bad
#   Time.zone = 'EST'
#
#   # good
#   Time.use_zone('EST') do
#   end
class RuboCop::Cop::Rails::TimeZoneAssignment < ::RuboCop::Cop::Base
  def on_send(node); end
  def time_zone_assignement?(param0 = T.unsafe(nil)); end
end

RuboCop::Cop::Rails::TimeZoneAssignment::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Rails::TimeZoneAssignment::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# This cop checks for the use of exit statements (namely `return`,
# `break` and `throw`) in transactions. This is due to the eventual
# unexpected behavior when using ActiveRecord >= 7, where transactions
# exitted using these statements are being rollbacked rather than
# committed (pre ActiveRecord 7 behavior).
#
# As alternatives, it would be more intuitive to explicitly raise an
# error when rollback is desired, and to use `next` when commit is
# desired.
#
# @example
#   # bad
#   ApplicationRecord.transaction do
#   return if user.active?
#   end
#
#   # bad
#   ApplicationRecord.transaction do
#   break if user.active?
#   end
#
#   # bad
#   ApplicationRecord.transaction do
#   throw if user.active?
#   end
#
#   # good
#   ApplicationRecord.transaction do
#   # Rollback
#   raise "User is active" if user.active?
#   end
#
#   # good
#   ApplicationRecord.transaction do
#   # Commit
#   next if user.active?
#   end
# @see https://github.com/rails/rails/commit/15aa4200e083
class RuboCop::Cop::Rails::TransactionExitStatement < ::RuboCop::Cop::Base
  def exit_statements(param0); end
  def on_send(node); end

  private

  # @return [Boolean]
  def in_rescue?(statement_node); end

  # @return [Boolean]
  def nested_block?(statement_node); end

  def statement(statement_node); end
end

RuboCop::Cop::Rails::TransactionExitStatement::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Rails::TransactionExitStatement::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Prefer using `distinct` before `pluck` instead of `uniq` after `pluck`.
#
# The use of distinct before pluck is preferred because it executes by
# the database.
#
# This cop has two different enforcement modes. When the EnforcedStyle
# is `conservative` (the default), then only calls to `pluck` on a constant
# (i.e. a model class) before `uniq` are added as offenses.
#
# When the EnforcedStyle is `aggressive` then all calls to `pluck` before
# distinct are added as offenses. This may lead to false positives
# as the cop cannot distinguish between calls to `pluck` on an
# ActiveRecord::Relation vs a call to pluck on an
# ActiveRecord::Associations::CollectionProxy.
#
# @example EnforcedStyle: conservative (default)
#   # bad - redundantly fetches duplicate values
#   Album.pluck(:band_name).uniq
#
#   # good
#   Album.distinct.pluck(:band_name)
# @example EnforcedStyle: aggressive
#   # bad - redundantly fetches duplicate values
#   Album.pluck(:band_name).uniq
#
#   # bad - redundantly fetches duplicate values
#   Album.where(year: 1985).pluck(:band_name).uniq
#
#   # bad - redundantly fetches duplicate values
#   customer.favourites.pluck(:color).uniq
#
#   # good
#   Album.distinct.pluck(:band_name)
#   Album.distinct.where(year: 1985).pluck(:band_name)
#   customer.favourites.distinct.pluck(:color)
class RuboCop::Cop::Rails::UniqBeforePluck < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  def aggressive_node_match(param0 = T.unsafe(nil)); end
  def conservative_node_match(param0 = T.unsafe(nil)); end
  def on_send(node); end

  private

  def dot_method_begin_pos(method, node); end
  def dot_method_with_whitespace(method, node); end
end

RuboCop::Cop::Rails::UniqBeforePluck::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Rails::UniqBeforePluck::NEWLINE = T.let(T.unsafe(nil), String)
RuboCop::Cop::Rails::UniqBeforePluck::PATTERN = T.let(T.unsafe(nil), String)
RuboCop::Cop::Rails::UniqBeforePluck::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# When you define a uniqueness validation in Active Record model,
# you also should add a unique index for the column. There are two reasons
# First, duplicated records may occur even if Active Record's validation
# is defined.
# Second, it will cause slow queries. The validation executes a `SELECT`
# statement with the target column when inserting/updating a record.
# If the column does not have an index and the table is large,
# the query will be heavy.
#
# Note that the cop does nothing if db/schema.rb does not exist.
#
# @example
#   # bad - if the schema does not have a unique index
#   validates :account, uniqueness: true
#
#   # good - if the schema has a unique index
#   validates :account, uniqueness: true
#
#   # good - even if the schema does not have a unique index
#   validates :account, length: { minimum: MIN_LENGTH }
class RuboCop::Cop::Rails::UniqueValidationWithoutIndex < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ActiveRecordHelper

  def on_send(node); end

  private

  def array_node_to_array(node); end
  def class_node(node); end
  def column_names(node); end
  def column_names_from_scope(node); end

  # @return [Boolean]
  def condition_part?(node); end

  def find_schema_information(node); end
  def find_scope(pairs); end

  # @return [Boolean]
  def include_column_names_in_expression_index?(index, column_names); end

  def unfreeze_scope(scope); end
  def uniqueness_part(node); end

  # @return [Boolean]
  def with_index?(klass, table, names); end
end

RuboCop::Cop::Rails::UniqueValidationWithoutIndex::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Rails::UniqueValidationWithoutIndex::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# This cop checks that environments called with `Rails.env` predicates
# exist.
# By default the cop allows three environments which Rails ships with:
# `development`, `test`, and `production`.
# More can be added to the `Environments` config parameter.
#
# @example
#   # bad
#   Rails.env.proudction?
#   Rails.env == 'proudction'
#
#   # good
#   Rails.env.production?
#   Rails.env == 'production'
class RuboCop::Cop::Rails::UnknownEnv < ::RuboCop::Cop::Base
  def on_send(node); end
  def rails_env?(param0 = T.unsafe(nil)); end
  def unknown_environment_equal?(param0 = T.unsafe(nil)); end
  def unknown_environment_predicate?(param0 = T.unsafe(nil)); end

  private

  def collect_variable_like_names(_scope); end
  def environments; end
  def message(name); end

  # @return [Boolean]
  def unknown_env_name?(name); end

  # @return [Boolean]
  def unknown_env_predicate?(name); end
end

RuboCop::Cop::Rails::UnknownEnv::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Rails::UnknownEnv::MSG_SIMILAR = T.let(T.unsafe(nil), String)

# This cop suggests you remove a column that does not exist in the schema from `ignored_columns`.
# `ignored_columns` is necessary to drop a column from RDBMS, but you don't need it after the migration
# to drop the column. You avoid forgetting to remove `ignored_columns` by this cop.
#
# @example
#   # bad
#   class User < ApplicationRecord
#   self.ignored_columns = [:already_removed_column]
#   end
#
#   # good
#   class User < ApplicationRecord
#   self.ignored_columns = [:still_existing_column]
#   end
class RuboCop::Cop::Rails::UnusedIgnoredColumns < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ActiveRecordHelper

  def column_name(param0 = T.unsafe(nil)); end
  def ignored_columns(param0 = T.unsafe(nil)); end
  def on_send(node); end

  private

  def check_column_existence(column_node, table); end
  def class_node(node); end
  def table(node); end
end

RuboCop::Cop::Rails::UnusedIgnoredColumns::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Rails::UnusedIgnoredColumns::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# This cop checks for the use of old-style attribute validation macros.
#
# @example
#   # bad
#   validates_acceptance_of :foo
#   validates_confirmation_of :foo
#   validates_exclusion_of :foo
#   validates_format_of :foo
#   validates_inclusion_of :foo
#   validates_length_of :foo
#   validates_numericality_of :foo
#   validates_presence_of :foo
#   validates_absence_of :foo
#   validates_size_of :foo
#   validates_uniqueness_of :foo
#
#   # good
#   validates :foo, acceptance: true
#   validates :foo, confirmation: true
#   validates :foo, exclusion: true
#   validates :foo, format: true
#   validates :foo, inclusion: true
#   validates :foo, length: true
#   validates :foo, numericality: true
#   validates :foo, presence: true
#   validates :foo, absence: true
#   validates :foo, size: true
#   validates :foo, uniqueness: true
class RuboCop::Cop::Rails::Validation < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  def on_send(node); end

  private

  def braced_options(options); end
  def correct_validate_type(corrector, node); end
  def correct_validate_type_for_array(corrector, node, arguments, loc); end
  def correct_validate_type_for_hash(corrector, node, arguments); end

  # @return [Boolean]
  def frozen_array_argument?(argument); end

  def message(node); end
  def preferred_method(method); end
  def validate_type(node); end
end

RuboCop::Cop::Rails::Validation::ALLOWLIST = T.let(T.unsafe(nil), Array)
RuboCop::Cop::Rails::Validation::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Rails::Validation::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)
RuboCop::Cop::Rails::Validation::TYPES = T.let(T.unsafe(nil), Array)

# This cop identifies places where manually constructed SQL
# in `where` can be replaced with `where(attribute: value)`.
#
# @example
#   # bad
#   User.where('name = ?', 'Gabe')
#   User.where('name = :name', name: 'Gabe')
#   User.where('name IS NULL')
#   User.where('name IN (?)', ['john', 'jane'])
#   User.where('name IN (:names)', names: ['john', 'jane'])
#   User.where('users.name = :name', name: 'Gabe')
#
#   # good
#   User.where(name: 'Gabe')
#   User.where(name: nil)
#   User.where(name: ['john', 'jane'])
#   User.where(users: { name: 'Gabe' })
class RuboCop::Cop::Rails::WhereEquals < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  def on_send(node); end
  def where_method_call?(param0 = T.unsafe(nil)); end

  private

  def build_good_method(column, value); end
  def extract_column_and_value(template_node, value_node); end
  def offense_range(node); end
end

# column = ?
RuboCop::Cop::Rails::WhereEquals::EQ_ANONYMOUS_RE = T.let(T.unsafe(nil), Regexp)

# column = :column
RuboCop::Cop::Rails::WhereEquals::EQ_NAMED_RE = T.let(T.unsafe(nil), Regexp)

# column IN (?)
RuboCop::Cop::Rails::WhereEquals::IN_ANONYMOUS_RE = T.let(T.unsafe(nil), Regexp)

# column IN (:column)
RuboCop::Cop::Rails::WhereEquals::IN_NAMED_RE = T.let(T.unsafe(nil), Regexp)

# column IS NULL
RuboCop::Cop::Rails::WhereEquals::IS_NULL_RE = T.let(T.unsafe(nil), Regexp)

RuboCop::Cop::Rails::WhereEquals::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Rails::WhereEquals::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# This cop enforces consistent style when using `exists?`.
#
# Two styles are supported for this cop. When EnforcedStyle is 'exists'
# then the cop enforces `exists?(...)` over `where(...).exists?`.
#
# When EnforcedStyle is 'where' then the cop enforces
# `where(...).exists?` over `exists?(...)`.
#
# @example EnforcedStyle: exists (default)
#   # bad
#   User.where(name: 'john').exists?
#   User.where(['name = ?', 'john']).exists?
#   User.where('name = ?', 'john').exists?
#   user.posts.where(published: true).exists?
#
#   # good
#   User.exists?(name: 'john')
#   User.where('length(name) > 10').exists?
#   user.posts.exists?(published: true)
# @example EnforcedStyle: where
#   # bad
#   User.exists?(name: 'john')
#   User.exists?(['name = ?', 'john'])
#   User.exists?('name = ?', 'john')
#   user.posts.exists?(published: true)
#
#   # good
#   User.where(name: 'john').exists?
#   User.where(['name = ?', 'john']).exists?
#   User.where('name = ?', 'john').exists?
#   user.posts.where(published: true).exists?
#   User.where('length(name) > 10').exists?
class RuboCop::Cop::Rails::WhereExists < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  extend ::RuboCop::Cop::AutoCorrector

  def exists_with_args?(param0 = T.unsafe(nil)); end
  def on_send(node); end
  def where_exists_call?(param0 = T.unsafe(nil)); end

  private

  def build_good_method(args); end
  def build_good_method_exists(args); end
  def build_good_method_where(args); end

  # @return [Boolean]
  def convertable_args?(args); end

  def correction_range(node); end

  # @return [Boolean]
  def exists_style?; end

  def find_offenses(node, &block); end

  # @return [Boolean]
  def where_style?; end
end

RuboCop::Cop::Rails::WhereExists::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Rails::WhereExists::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# This cop identifies places where manually constructed SQL
# in `where` can be replaced with `where.not(...)`.
#
# @example
#   # bad
#   User.where('name != ?', 'Gabe')
#   User.where('name != :name', name: 'Gabe')
#   User.where('name <> ?', 'Gabe')
#   User.where('name <> :name', name: 'Gabe')
#   User.where('name IS NOT NULL')
#   User.where('name NOT IN (?)', ['john', 'jane'])
#   User.where('name NOT IN (:names)', names: ['john', 'jane'])
#   User.where('users.name != :name', name: 'Gabe')
#
#   # good
#   User.where.not(name: 'Gabe')
#   User.where.not(name: nil)
#   User.where.not(name: ['john', 'jane'])
#   User.where.not(users: { name: 'Gabe' })
class RuboCop::Cop::Rails::WhereNot < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  def on_send(node); end
  def where_method_call?(param0 = T.unsafe(nil)); end

  private

  def build_good_method(column, value); end
  def extract_column_and_value(template_node, value_node); end
  def offense_range(node); end
end

# column IS NOT NULL
RuboCop::Cop::Rails::WhereNot::IS_NOT_NULL_RE = T.let(T.unsafe(nil), Regexp)

RuboCop::Cop::Rails::WhereNot::MSG = T.let(T.unsafe(nil), String)

# column != ?, column <> ?
RuboCop::Cop::Rails::WhereNot::NOT_EQ_ANONYMOUS_RE = T.let(T.unsafe(nil), Regexp)

# column != :column, column <> :column
RuboCop::Cop::Rails::WhereNot::NOT_EQ_NAMED_RE = T.let(T.unsafe(nil), Regexp)

# column NOT IN (?)
RuboCop::Cop::Rails::WhereNot::NOT_IN_ANONYMOUS_RE = T.let(T.unsafe(nil), Regexp)

# column NOT IN (:column)
RuboCop::Cop::Rails::WhereNot::NOT_IN_NAMED_RE = T.let(T.unsafe(nil), Regexp)

RuboCop::Cop::Rails::WhereNot::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Common functionality for checking target rails version.
module RuboCop::Cop::TargetRailsVersion
  def minimum_target_rails_version(version); end

  # @return [Boolean]
  def support_target_rails_version?(version); end
end

RuboCop::NodePattern = RuboCop::AST::NodePattern
RuboCop::ProcessedSource = RuboCop::AST::ProcessedSource

# RuboCop Rails project namespace
module RuboCop::Rails; end

RuboCop::Rails::CONFIG = T.let(T.unsafe(nil), Hash)
RuboCop::Rails::CONFIG_DEFAULT = T.let(T.unsafe(nil), Pathname)

# Because RuboCop doesn't yet support plugins, we have to monkey patch in a
# bit of our configuration.
module RuboCop::Rails::Inject
  class << self
    def defaults!; end
  end
end

RuboCop::Rails::PROJECT_ROOT = T.let(T.unsafe(nil), Pathname)

# It loads db/schema.rb and return Schema object.
# Cops refers database schema information with this module.
module RuboCop::Rails::SchemaLoader
  extend ::RuboCop::Rails::SchemaLoader

  def db_schema_path; end

  # It parses `db/schema.rb` and return it.
  # It returns `nil` if it can't find `db/schema.rb`.
  # So a cop that uses the loader should handle `nil` properly.
  #
  # @return [Schema, nil]
  def load(target_ruby_version); end

  def reset!; end

  private

  def load!(target_ruby_version); end
  def parse(path, target_ruby_version); end
end

# Represent an `add_index`
class RuboCop::Rails::SchemaLoader::AddIndex < ::RuboCop::Rails::SchemaLoader::Index
  # @return [AddIndex] a new instance of AddIndex
  def initialize(node); end

  # Returns the value of attribute table_name.
  def table_name; end
end

# Represent a column
class RuboCop::Rails::SchemaLoader::Column
  # @return [Column] a new instance of Column
  def initialize(node); end

  # Returns the value of attribute name.
  def name; end

  # Returns the value of attribute not_null.
  def not_null; end

  # Returns the value of attribute type.
  def type; end

  private

  def analyze_keywords!(node); end
end

# Represent an index
class RuboCop::Rails::SchemaLoader::Index
  # @return [Index] a new instance of Index
  def initialize(node); end

  # Returns the value of attribute columns.
  def columns; end

  # Returns the value of attribute expression.
  def expression; end

  # Returns the value of attribute name.
  def name; end

  # Returns the value of attribute unique.
  def unique; end

  private

  def analyze_keywords!(node); end
  def build_columns_or_expr(columns); end
end

# Represent db/schema.rb
class RuboCop::Rails::SchemaLoader::Schema
  # @return [Schema] a new instance of Schema
  def initialize(ast); end

  # Returns the value of attribute add_indicies.
  def add_indicies; end

  def add_indicies_by(table_name:); end
  def table_by(name:); end

  # Returns the value of attribute tables.
  def tables; end

  private

  def build!(ast); end
  def each_add_index(ast); end
  def each_table(ast); end
end

# Represent a table
class RuboCop::Rails::SchemaLoader::Table
  # @return [Table] a new instance of Table
  def initialize(node); end

  # Returns the value of attribute columns.
  def columns; end

  # Returns the value of attribute indices.
  def indices; end

  # Returns the value of attribute name.
  def name; end

  # @return [Boolean]
  def with_column?(name:); end

  private

  def build_columns(node); end
  def build_indices(node); end
  def each_content(node, &block); end
end

# This module holds the RuboCop Rails version information.
module RuboCop::Rails::Version
  class << self
    def document_version; end
  end
end

RuboCop::Rails::Version::STRING = T.let(T.unsafe(nil), String)
RuboCop::Token = RuboCop::AST::Token
