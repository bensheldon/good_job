# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `async-http` gem.
# Please instead update this file by running `bin/tapioca sync`.

# typed: true

module Async
  extend(::Console)

  class << self
    def run(*arguments, &block); end
  end
end

module Async::HTTP
end

module Async::HTTP::Body
  include(::Protocol::HTTP::Body)
end

class Async::HTTP::Body::Stream
  def initialize(input, output = T.unsafe(nil)); end

  def close(error = T.unsafe(nil)); end
  def close_read; end
  def close_write; end
  def closed?; end
  def empty?; end
  def flush; end
  def input; end
  def output; end
  def read(size = T.unsafe(nil), buffer = T.unsafe(nil)); end
  def read_nonblock(length, buffer = T.unsafe(nil)); end
  def read_partial(size = T.unsafe(nil)); end
  def write(buffer); end
  def write_nonblock(buffer); end

  private

  def read_next; end
end

class Async::HTTP::Body::Writable < ::Protocol::HTTP::Body::Readable
  def initialize(length = T.unsafe(nil), queue: T.unsafe(nil)); end

  def <<(chunk); end
  def close(error = T.unsafe(nil)); end
  def closed?; end
  def empty?; end
  def inspect; end
  def length; end
  def read; end
  def ready?; end
  def write(chunk); end

  private

  def status; end
end

class Async::HTTP::Body::Writable::Closed < ::StandardError
end

class Async::HTTP::Client < ::Protocol::HTTP::Methods
  def initialize(endpoint, protocol: T.unsafe(nil), scheme: T.unsafe(nil), authority: T.unsafe(nil), retries: T.unsafe(nil), connection_limit: T.unsafe(nil)); end

  def authority; end
  def call(request); end
  def close; end
  def endpoint; end
  def pool; end
  def protocol; end
  def retries; end
  def scheme; end
  def secure?; end

  protected

  def make_pool(connection_limit); end
  def make_response(request, connection); end

  class << self
    def open(*arguments, **options, &block); end
  end
end

Async::HTTP::DEFAULT_RETRIES = T.let(T.unsafe(nil), Integer)

class Async::HTTP::Endpoint < ::Async::IO::Endpoint
  def initialize(url, endpoint = T.unsafe(nil), **options); end

  def address; end
  def alpn_protocols; end
  def authority(ignore_default_port = T.unsafe(nil)); end
  def bind(*arguments, &block); end
  def build_endpoint(endpoint = T.unsafe(nil)); end
  def connect(&block); end
  def default_port; end
  def default_port?; end
  def each; end
  def endpoint; end
  def eql?(other); end
  def hash; end
  def hostname; end
  def inspect; end
  def key; end
  def localhost?; end
  def path; end
  def port; end
  def protocol; end
  def scheme; end
  def secure?; end
  def ssl_context; end
  def ssl_verify_mode; end
  def to_s; end
  def to_url; end
  def url; end

  protected

  def tcp_endpoint; end
  def tcp_options; end

  class << self
    def for(scheme, hostname, **options); end
    def parse(string, endpoint = T.unsafe(nil), **options); end
  end
end

class Async::HTTP::Internet
  def initialize(**options); end

  def call(method, url, headers = T.unsafe(nil), body = T.unsafe(nil)); end
  def client_for(endpoint); end
  def clients; end
  def close; end
  def connect(url, headers = T.unsafe(nil), body = T.unsafe(nil)); end
  def delete(url, headers = T.unsafe(nil), body = T.unsafe(nil)); end
  def get(url, headers = T.unsafe(nil), body = T.unsafe(nil)); end
  def head(url, headers = T.unsafe(nil), body = T.unsafe(nil)); end
  def link(url, headers = T.unsafe(nil), body = T.unsafe(nil)); end
  def options(url, headers = T.unsafe(nil), body = T.unsafe(nil)); end
  def patch(url, headers = T.unsafe(nil), body = T.unsafe(nil)); end
  def post(url, headers = T.unsafe(nil), body = T.unsafe(nil)); end
  def put(url, headers = T.unsafe(nil), body = T.unsafe(nil)); end
  def trace(url, headers = T.unsafe(nil), body = T.unsafe(nil)); end
  def unlink(url, headers = T.unsafe(nil), body = T.unsafe(nil)); end

  private

  def host_key(endpoint); end
end

module Async::HTTP::Protocol
end

module Async::HTTP::Protocol::HTTP1
  class << self
    def bidirectional?; end
    def client(peer); end
    def names; end
    def server(peer); end
    def trailers?; end
  end
end

class Async::HTTP::Protocol::HTTP1::Client < ::Async::HTTP::Protocol::HTTP1::Connection
  def call(request, task: T.unsafe(nil)); end
end

class Async::HTTP::Protocol::HTTP1::Connection < ::Protocol::HTTP1::Connection
  def initialize(stream, version); end

  def concurrency; end
  def count; end
  def http1?; end
  def http2?; end
  def peer; end
  def read_line; end
  def read_line?; end
  def reusable?; end
  def version; end
  def viable?; end
end

class Async::HTTP::Protocol::HTTP1::Request < ::Async::HTTP::Protocol::Request
  def initialize(connection, authority, method, path, version, headers, body); end

  def connection; end
  def hijack!; end
  def hijack?; end

  class << self
    def read(connection); end
  end
end

class Async::HTTP::Protocol::HTTP1::Response < ::Async::HTTP::Protocol::Response
  def initialize(connection, version, status, reason, headers, body); end

  def connection; end
  def hijack!; end
  def hijack?; end

  class << self
    def read(connection, request); end
  end
end

class Async::HTTP::Protocol::HTTP1::Server < ::Async::HTTP::Protocol::HTTP1::Connection
  def each(task: T.unsafe(nil)); end
  def fail_request(status); end
  def next_request; end
end

Async::HTTP::Protocol::HTTP1::VERSION = T.let(T.unsafe(nil), String)

module Async::HTTP::Protocol::HTTP10
  class << self
    def bidirectional?; end
    def client(peer); end
    def names; end
    def server(peer); end
    def trailers?; end
  end
end

Async::HTTP::Protocol::HTTP10::VERSION = T.let(T.unsafe(nil), String)

module Async::HTTP::Protocol::HTTP11
  class << self
    def bidirectional?; end
    def client(peer); end
    def names; end
    def server(peer); end
    def trailers?; end
  end
end

Async::HTTP::Protocol::HTTP11::VERSION = T.let(T.unsafe(nil), String)

module Async::HTTP::Protocol::HTTP2
  class << self
    def bidirectional?; end
    def client(peer, settings = T.unsafe(nil)); end
    def names; end
    def server(peer, settings = T.unsafe(nil)); end
    def trailers?; end
  end
end

Async::HTTP::Protocol::HTTP2::AUTHORITY = T.let(T.unsafe(nil), String)

Async::HTTP::Protocol::HTTP2::CLIENT_SETTINGS = T.let(T.unsafe(nil), Hash)

Async::HTTP::Protocol::HTTP2::CONNECTION = T.let(T.unsafe(nil), String)

Async::HTTP::Protocol::HTTP2::CONTENT_LENGTH = T.let(T.unsafe(nil), String)

class Async::HTTP::Protocol::HTTP2::Client < ::Protocol::HTTP2::Client
  include(::Async::HTTP::Protocol::HTTP2::Connection)

  def initialize(stream); end

  def call(request); end
  def create_response; end
end

module Async::HTTP::Protocol::HTTP2::Connection
  def initialize(*_arg0); end

  def close(error = T.unsafe(nil)); end
  def concurrency; end
  def count; end
  def http1?; end
  def http2?; end
  def peer; end
  def promises; end
  def read_in_background(parent: T.unsafe(nil)); end
  def reusable?; end
  def start_connection; end
  def stream; end
  def to_s; end
  def version; end
  def viable?; end
  def write_frame(frame); end
  def write_frames(&block); end
end

Async::HTTP::Protocol::HTTP2::HTTPS = T.let(T.unsafe(nil), String)

class Async::HTTP::Protocol::HTTP2::Input < ::Async::HTTP::Body::Writable
  def initialize(stream, length); end

  def read; end
end

Async::HTTP::Protocol::HTTP2::METHOD = T.let(T.unsafe(nil), String)

class Async::HTTP::Protocol::HTTP2::Output
  def initialize(stream, body, trailers = T.unsafe(nil)); end

  def close(error = T.unsafe(nil)); end
  def start(parent: T.unsafe(nil)); end
  def stop(error); end
  def trailers; end
  def window_updated(size); end
  def write(chunk); end

  private

  def passthrough(task); end
  def send_data(chunk, maximum_size); end
  def stream(task); end
end

Async::HTTP::Protocol::HTTP2::PATH = T.let(T.unsafe(nil), String)

Async::HTTP::Protocol::HTTP2::PROTOCOL = T.let(T.unsafe(nil), String)

class Async::HTTP::Protocol::HTTP2::Request < ::Async::HTTP::Protocol::Request
  def initialize(stream); end

  def connection; end
  def hijack?; end
  def send_response(response); end
  def stream; end
  def valid?; end
end

Async::HTTP::Protocol::HTTP2::Request::NO_RESPONSE = T.let(T.unsafe(nil), Array)

class Async::HTTP::Protocol::HTTP2::Request::Stream < ::Async::HTTP::Protocol::HTTP2::Stream
  def initialize(*_arg0); end

  def closed(error); end
  def receive_initial_headers(headers, end_stream); end
  def request; end
end

class Async::HTTP::Protocol::HTTP2::Response < ::Async::HTTP::Protocol::Response
  def initialize(stream); end

  def build_request(headers); end
  def connection; end
  def head?; end
  def request; end
  def send_request(request); end
  def stream; end
  def valid?; end
  def wait; end
end

class Async::HTTP::Protocol::HTTP2::Response::Stream < ::Async::HTTP::Protocol::HTTP2::Stream
  def initialize(*_arg0); end

  def accept_push_promise_stream(promised_stream_id, headers); end
  def closed(error); end
  def notify!; end
  def receive_initial_headers(headers, end_stream); end
  def response; end
  def wait; end
  def wait_for_input; end
end

Async::HTTP::Protocol::HTTP2::SCHEME = T.let(T.unsafe(nil), String)

Async::HTTP::Protocol::HTTP2::SERVER_SETTINGS = T.let(T.unsafe(nil), Hash)

Async::HTTP::Protocol::HTTP2::STATUS = T.let(T.unsafe(nil), String)

class Async::HTTP::Protocol::HTTP2::Server < ::Protocol::HTTP2::Server
  include(::Async::HTTP::Protocol::HTTP2::Connection)

  def initialize(stream); end

  def accept_stream(stream_id); end
  def close(error = T.unsafe(nil)); end
  def each(task: T.unsafe(nil)); end
  def requests; end
end

class Async::HTTP::Protocol::HTTP2::Stream < ::Protocol::HTTP2::Stream
  def initialize(*_arg0); end

  def add_header(key, value); end
  def closed(error); end
  def finish_output(error = T.unsafe(nil)); end
  def headers; end
  def headers=(_arg0); end
  def input; end
  def prepare_input(length); end
  def process_data(frame); end
  def process_headers(frame); end
  def receive_trailing_headers(headers, end_stream); end
  def send_body(body, trailers = T.unsafe(nil)); end
  def update_local_window(frame); end
  def wait_for_input; end
  def window_updated(size); end
end

Async::HTTP::Protocol::HTTP2::TRAILERS = T.let(T.unsafe(nil), String)

Async::HTTP::Protocol::HTTP2::VERSION = T.let(T.unsafe(nil), String)

module Async::HTTP::Protocol::HTTPS
  class << self
    def client(peer); end
    def names; end
    def protocol_for(peer); end
    def server(peer); end
  end
end

Async::HTTP::Protocol::HTTPS::HANDLERS = T.let(T.unsafe(nil), Hash)

class Async::HTTP::Protocol::Request < ::Protocol::HTTP::Request
  def connection; end
  def hijack?; end
  def peer; end
  def remote_address; end
  def remote_address=(value); end
end

class Async::HTTP::Protocol::RequestFailed < ::StandardError
end

class Async::HTTP::Protocol::Response < ::Protocol::HTTP::Response
  def connection; end
  def hijack?; end
  def peer; end
  def remote_address; end
  def remote_address=(value); end
end

Async::VERSION = T.let(T.unsafe(nil), String)
