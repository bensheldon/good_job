# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: strict
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/async-io/all/async-io.rbi
#
# async-io-1.32.2

module Async
end
module Async::IO
  def self.pipe; end
  def self.try_convert(io, &block); end
end
module Async::IO::Peer
  def connected?; end
  def eof; end
  def eof?; end
  def protocol; end
  def sync; end
  def sync=(value); end
  def type; end
  include Socket::Constants
end
module Async::IO::Server
  def accept_each(timeout: nil, task: nil); end
end
class Async::IO::Generic < Async::Wrapper
  def <<(buffer); end
  def advise(*args, &block); end
  def async_send(*arguments, timeout: nil); end
  def autoclose=(*args, &block); end
  def autoclose?(*args, &block); end
  def binmode(*args, &block); end
  def binmode?(*args, &block); end
  def close_on_exec=(*args, &block); end
  def close_on_exec?(*args, &block); end
  def close_read(*args, &block); end
  def close_write(*args, &block); end
  def closed?(*args, &block); end
  def connected?; end
  def dup; end
  def eof(*args, &block); end
  def eof?(*args, &block); end
  def external_encoding(*args, &block); end
  def fcntl(*args, &block); end
  def fdatasync(*args, &block); end
  def fileno(*args, &block); end
  def flush(*args, &block); end
  def fsync(*args, &block); end
  def internal_encoding(*args, &block); end
  def ioctl(*args, &block); end
  def isatty(*args, &block); end
  def nonblock; end
  def nonblock=(value); end
  def nonblock?; end
  def nread(*args, &block); end
  def pathconf(*args, &block); end
  def pid(*args, &block); end
  def pos(*args, &block); end
  def pos=(*args, &block); end
  def pread(*args, &block); end
  def pwrite(*args, &block); end
  def read(length = nil, buffer = nil); end
  def read_nonblock(*args, exception: nil); end
  def readpartial(*args, exception: nil); end
  def ready?(*args, &block); end
  def reopen(*args, &block); end
  def rewind(*args, &block); end
  def seek(*args, &block); end
  def self.wrap(*args); end
  def self.wrap_blocking_method(new_name, method_name, invert: nil, &block); end
  def self.wrapped_klass; end
  def self.wraps(klass, *additional_methods); end
  def set_encoding(*args, &block); end
  def set_encoding_by_bom(*args, &block); end
  def stat(*args, &block); end
  def sync(*args, &block); end
  def sync=(*args, &block); end
  def sysread(*args); end
  def sysseek(*args, &block); end
  def syswrite(*args); end
  def tell(*args, &block); end
  def timeout; end
  def timeout=(arg0); end
  def to_i(*args, &block); end
  def to_io(*args, &block); end
  def tty?(*args, &block); end
  def wait(timeout = nil, mode = nil); end
  def write(buffer); end
  def write_nonblock(*args, exception: nil); end
  extend Forwardable
end
class Async::IO::BasicSocket < Async::IO::Generic
  def close_read(*args, &block); end
  def close_write(*args, &block); end
  def connect_address(*args, &block); end
  def do_not_reverse_lookup(*args, &block); end
  def do_not_reverse_lookup=(*args, &block); end
  def getpeereid(*args, &block); end
  def getpeername(*args, &block); end
  def getsockname(*args, &block); end
  def getsockopt(*args, &block); end
  def local_address(*args, &block); end
  def recv(*args); end
  def recv_nonblock(*args, exception: nil); end
  def recvmsg(*args); end
  def recvmsg_nonblock(*args, exception: nil); end
  def remote_address(*args, &block); end
  def send(*args); end
  def sendmsg(*args); end
  def sendmsg_nonblock(*args, exception: nil); end
  def setsockopt(*args, &block); end
  def shutdown(*args, &block); end
  include Async::IO::Peer
end
class Async::IO::Socket < Async::IO::BasicSocket
  def accept(timeout: nil, task: nil); end
  def accept_nonblock(timeout: nil, task: nil); end
  def bind(*args, &block); end
  def connect(*args); end
  def connect_nonblock(*args); end
  def ipv6only!(*args, &block); end
  def listen(*args, &block); end
  def recvfrom(*args); end
  def recvfrom_nonblock(*args, exception: nil); end
  def self.accept(*args, backlog: nil, &block); end
  def self.bind(local_address, protocol: nil, task: nil, **options, &block); end
  def self.build(*args, timeout: nil, reuse_address: nil, reuse_port: nil, linger: nil, task: nil); end
  def self.connect(remote_address, local_address: nil, task: nil, **options); end
  def self.pair(*args); end
  def sysaccept(timeout: nil, task: nil); end
  include Async::IO::Server
end
class Async::IO::IPSocket < Async::IO::BasicSocket
  def addr(*args, &block); end
  def peeraddr(*args, &block); end
  def recvfrom(*args); end
  def recvfrom_nonblock(*args, exception: nil); end
end
class Async::IO::Endpoint
  def accept(backlog = nil, &block); end
  def bound; end
  def each; end
  def hostname; end
  def initialize(**options); end
  def linger; end
  def local_address; end
  def options; end
  def options=(arg0); end
  def reuse_address; end
  def reuse_port; end
  def self.parse(string, **options); end
  def self.ssl(*args, ssl_context: nil, hostname: nil, **options); end
  def self.tcp(*args, **options); end
  def self.udp(*args, **options); end
  def timeout; end
  def with(**options); end
end
class Async::IO::Buffer < String
  def <<(string); end
  def concat(string); end
  def initialize; end
end
class Async::IO::Stream
  def <<(string); end
  def block_size; end
  def close; end
  def close_read; end
  def close_write; end
  def closed?; end
  def connected?; end
  def consume_read_buffer(size = nil); end
  def eof!; end
  def eof; end
  def eof?; end
  def fill_read_buffer(size = nil); end
  def flush; end
  def gets(separator = nil, **options); end
  def initialize(io, block_size: nil, maximum_read_size: nil, sync: nil, deferred: nil); end
  def io; end
  def peek; end
  def puts(*arguments, separator: nil); end
  def read(size = nil); end
  def read_exactly(size, exception: nil); end
  def read_partial(size = nil); end
  def read_until(pattern, offset = nil, chomp: nil); end
  def readpartial(size = nil); end
  def self.open(path, mode = nil, **options); end
  def write(string); end
end
class Async::IO::AddressEndpoint < Async::IO::Endpoint
  def address; end
  def bind(&block); end
  def connect(&block); end
  def initialize(address, **options); end
  def to_s; end
end
class Async::IO::HostEndpoint < Async::IO::Endpoint
  def address; end
  def bind(&block); end
  def connect; end
  def each; end
  def hostname; end
  def initialize(specification, **options); end
  def to_s; end
end
class Async::IO::SSLSocket < Async::IO::Generic
  def accept(*args); end
  def accept_nonblock(*args, exception: nil); end
  def alpn_protocol(*args, &block); end
  def cert(*args, &block); end
  def cipher(*args, &block); end
  def client_ca(*args, &block); end
  def close_read; end
  def close_write; end
  def connect(*args); end
  def connect_nonblock(*args, exception: nil); end
  def context(*args, &block); end
  def finished_message(*args, &block); end
  def getsockopt(*args, &block); end
  def hostname(*args, &block); end
  def hostname=(*args, &block); end
  def initialize(socket, context); end
  def local_address; end
  def npn_protocol(*args, &block); end
  def peer_cert(*args, &block); end
  def peer_cert_chain(*args, &block); end
  def peer_finished_message(*args, &block); end
  def pending(*args, &block); end
  def post_connection_check(*args, &block); end
  def remote_address; end
  def self.connect(socket, context, hostname = nil, &block); end
  def session(*args, &block); end
  def session=(*args, &block); end
  def session_reused?(*args, &block); end
  def setsockopt(*args, &block); end
  def shutdown(how); end
  def ssl_version(*args, &block); end
  def state(*args, &block); end
  def sync_close(*args, &block); end
  def sync_close=(*args, &block); end
  def sysclose(*args, &block); end
  def tmp_key(*args, &block); end
  def verify_result(*args, &block); end
  include Async::IO::Peer
end
class Async::IO::SSLServer
  def accept(task: nil, **options); end
  def close(*args, &block); end
  def close_on_exec=(*args, &block); end
  def context; end
  def dup; end
  def fileno; end
  def getsockopt(*args, &block); end
  def initialize(server, context); end
  def listen(*args); end
  def local_address(*args, &block); end
  def reactor=(*args, &block); end
  def server; end
  def setsockopt(*args, &block); end
  def timeout(*args, &block); end
  def timeout=(*args, &block); end
  extend Forwardable
  include Async::IO::Server
end
class Async::IO::SSLEndpoint < Async::IO::Endpoint
  def address; end
  def bind; end
  def build_context(context = nil); end
  def connect(&block); end
  def context; end
  def each; end
  def endpoint; end
  def hostname; end
  def initialize(endpoint, **options); end
  def options; end
  def params; end
  def to_s; end
end
