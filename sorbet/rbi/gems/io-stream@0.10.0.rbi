# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `io-stream` gem.
# Please instead update this file by running `bin/tapioca gem io-stream`.


# Socket extensions for buffering support.
#
# source://io-stream//lib/io/stream/shim/buffered.rb#26
class BasicSocket < ::IO
  # Set the buffered state of the socket.
  #
  # source://io-stream//lib/io/stream/shim/buffered.rb#49
  def buffered=(value); end

  # Check if the socket is buffered.
  #
  # @return [Boolean]
  #
  # source://io-stream//lib/io/stream/shim/buffered.rb#37
  def buffered?; end

  # Check if this socket uses TCP protocol.
  #
  # @return [Boolean]
  #
  # source://io-stream//lib/io/stream/shim/buffered.rb#29
  def ip_protocol_tcp?; end

  # Check if the socket is readable.
  #
  # @return [Boolean]
  #
  # source://io-stream//lib/io/stream/shim/readable.rb#23
  def readable?; end
end

# source://io-stream//lib/io/stream/shim/buffered.rb#7
class IO
  include ::Enumerable
  include ::File::Constants

  # Set the buffered state of the IO.
  #
  # source://io-stream//lib/io/stream/shim/buffered.rb#16
  def buffered=(value); end

  # Check if the IO is buffered.
  #
  # @return [Boolean]
  #
  # source://io-stream//lib/io/stream/shim/buffered.rb#10
  def buffered?; end

  # Check if the IO is readable.
  #
  # @return [Boolean]
  #
  # source://io-stream//lib/io/stream/shim/readable.rb#10
  def readable?; end

  class << self
    # Convert any IO-like object into a buffered stream.
    #
    # source://io-stream//lib/io/stream.rb#18
    def Stream(io); end
  end
end

class IO::Buffer
  include ::Comparable

  def initialize(*_arg0); end

  def &(_arg0); end
  def <=>(_arg0); end
  def ^(_arg0); end
  def and!(_arg0); end
  def clear(*_arg0); end
  def copy(*_arg0); end
  def each(*_arg0); end
  def each_byte(*_arg0); end
  def empty?; end
  def external?; end
  def free; end
  def get_string(*_arg0); end
  def get_value(_arg0, _arg1); end
  def get_values(_arg0, _arg1); end
  def hexdump(*_arg0); end
  def inspect; end
  def internal?; end
  def locked; end
  def locked?; end
  def mapped?; end
  def not!; end
  def null?; end
  def or!(_arg0); end
  def pread(*_arg0); end
  def private?; end
  def pwrite(*_arg0); end
  def read(*_arg0); end
  def readonly?; end
  def resize(_arg0); end
  def set_string(*_arg0); end
  def set_value(_arg0, _arg1, _arg2); end
  def set_values(_arg0, _arg1, _arg2); end
  def shared?; end
  def size; end
  def slice(*_arg0); end
  def to_s; end
  def transfer; end
  def valid?; end
  def values(*_arg0); end
  def write(*_arg0); end
  def xor!(_arg0); end
  def |(_arg0); end
  def ~; end

  private

  def initialize_copy(_arg0); end

  class << self
    def for(_arg0); end
    def map(*_arg0); end
    def size_of(_arg0); end
    def string(_arg0); end
  end
end

class IO::Buffer::AccessError < ::RuntimeError; end
class IO::Buffer::AllocationError < ::RuntimeError; end
IO::Buffer::BIG_ENDIAN = T.let(T.unsafe(nil), Integer)
IO::Buffer::DEFAULT_SIZE = T.let(T.unsafe(nil), Integer)
IO::Buffer::EXTERNAL = T.let(T.unsafe(nil), Integer)
IO::Buffer::HOST_ENDIAN = T.let(T.unsafe(nil), Integer)
IO::Buffer::INTERNAL = T.let(T.unsafe(nil), Integer)
class IO::Buffer::InvalidatedError < ::RuntimeError; end
IO::Buffer::LITTLE_ENDIAN = T.let(T.unsafe(nil), Integer)
IO::Buffer::LOCKED = T.let(T.unsafe(nil), Integer)
class IO::Buffer::LockedError < ::RuntimeError; end
IO::Buffer::MAPPED = T.let(T.unsafe(nil), Integer)
class IO::Buffer::MaskError < ::ArgumentError; end
IO::Buffer::NETWORK_ENDIAN = T.let(T.unsafe(nil), Integer)
IO::Buffer::PAGE_SIZE = T.let(T.unsafe(nil), Integer)
IO::Buffer::PRIVATE = T.let(T.unsafe(nil), Integer)
IO::Buffer::READONLY = T.let(T.unsafe(nil), Integer)
IO::Buffer::SHARED = T.let(T.unsafe(nil), Integer)
class IO::ConsoleMode; end

class IO::EAGAINWaitReadable < ::Errno::EAGAIN
  include ::IO::WaitReadable
end

class IO::EAGAINWaitWritable < ::Errno::EAGAIN
  include ::IO::WaitWritable
end

class IO::EINPROGRESSWaitReadable < ::Errno::EINPROGRESS
  include ::IO::WaitReadable
end

class IO::EINPROGRESSWaitWritable < ::Errno::EINPROGRESS
  include ::IO::WaitWritable
end

IO::EWOULDBLOCKWaitReadable = IO::EAGAINWaitReadable
IO::EWOULDBLOCKWaitWritable = IO::EAGAINWaitWritable
IO::PRIORITY = T.let(T.unsafe(nil), Integer)
IO::READABLE = T.let(T.unsafe(nil), Integer)

# source://io-stream//lib/io/stream/version.rb#6
module IO::Stream; end

# The default block size for IO buffers. Defaults to 256KB (optimized for modern SSDs and networks).
#
# source://io-stream//lib/io/stream/readable.rb#10
IO::Stream::BLOCK_SIZE = T.let(T.unsafe(nil), Integer)

# A buffered stream implementation that wraps an underlying IO object to provide efficient buffered reading and writing.
#
# source://io-stream//lib/io/stream/buffered.rb#10
class IO::Stream::Buffered < ::IO::Stream::Generic
  # Initialize a new buffered stream.
  #
  # @return [Buffered] a new instance of Buffered
  #
  # source://io-stream//lib/io/stream/buffered.rb#52
  def initialize(io, *_arg1, **_arg2, &_arg3); end

  # Close the read end of the stream.
  #
  # source://io-stream//lib/io/stream/buffered.rb#79
  def close_read; end

  # Close the write end of the stream.
  #
  # source://io-stream//lib/io/stream/buffered.rb#84
  def close_write; end

  # Check if the stream is closed.
  #
  # @return [Boolean]
  #
  # source://io-stream//lib/io/stream/buffered.rb#74
  def closed?; end

  # Returns the value of attribute io.
  #
  # source://io-stream//lib/io/stream/buffered.rb#64
  def io; end

  # Check if the stream is readable.
  #
  # @return [Boolean]
  #
  # source://io-stream//lib/io/stream/buffered.rb#92
  def readable?; end

  # Get the underlying IO object.
  #
  # source://io-stream//lib/io/stream/buffered.rb#68
  def to_io; end

  protected

  # source://io-stream//lib/io/stream/buffered.rb#104
  def sysclose; end

  # Reads data from the underlying stream as efficiently as possible.
  #
  # source://io-stream//lib/io/stream/buffered.rb#135
  def sysread(size, buffer); end

  # source://io-stream//lib/io/stream/buffered.rb#110
  def syswrite(buffer); end

  class << self
    # Open a file and wrap it in a buffered stream.
    #
    # source://io-stream//lib/io/stream/buffered.rb#16
    def open(path, mode = T.unsafe(nil), **options); end

    # Wrap an existing IO object in a buffered stream.
    #
    # source://io-stream//lib/io/stream/buffered.rb#32
    def wrap(io, **options); end
  end
end

# Base class for stream implementations providing common functionality.
#
# source://io-stream//lib/io/stream/generic.rb#17
class IO::Stream::Generic
  include ::IO::Stream::Readable
  include ::IO::Stream::Writable

  # Initialize a new generic stream.
  #
  # @return [Generic] a new instance of Generic
  #
  # source://io-stream//lib/io/stream/generic.rb#23
  def initialize(**options); end

  # Best effort to flush any unwritten data, and then close the underling IO.
  #
  # source://io-stream//lib/io/stream/generic.rb#34
  def close; end

  # Check if the stream is closed.
  #
  # @return [Boolean]
  #
  # source://io-stream//lib/io/stream/generic.rb#29
  def closed?; end

  protected

  # Closes the underlying IO stream.
  # This method should be implemented by subclasses to handle the specific closing logic.
  #
  # @raise [NotImplementedError]
  #
  # source://io-stream//lib/io/stream/generic.rb#50
  def sysclose; end

  # Reads data from the underlying stream as efficiently as possible.
  # This method should be implemented by subclasses to handle the specific reading logic.
  #
  # @raise [NotImplementedError]
  #
  # source://io-stream//lib/io/stream/generic.rb#64
  def sysread(size, buffer); end

  # Writes data to the underlying stream.
  # This method should be implemented by subclasses to handle the specific writing logic.
  #
  # @raise [NotImplementedError]
  #
  # source://io-stream//lib/io/stream/generic.rb#58
  def syswrite(buffer); end
end

# The maximum read size for a single read operation. This limit exists because:
# 1. System calls like read() cannot handle requests larger than SSIZE_MAX
# 2. Very large reads can cause memory pressure and poor interactive performance
# 3. Most socket buffers and pipe capacities are much smaller anyway
# On 64-bit systems SSIZE_MAX is ~8.8 million MB, on 32-bit it's ~2GB.
# Our default of 16MB provides a good balance of throughput and responsiveness, and is page aligned.
# It is also a multiple of the minimum read size, so that we can read in chunks without exceeding the maximum.
#
# source://io-stream//lib/io/stream/readable.rb#22
IO::Stream::MAXIMUM_READ_SIZE = T.let(T.unsafe(nil), Integer)

# The minimum read size for efficient I/O operations. Defaults to the same as BLOCK_SIZE.
#
# source://io-stream//lib/io/stream/readable.rb#13
IO::Stream::MINIMUM_READ_SIZE = T.let(T.unsafe(nil), Integer)

# The minimum write size before flushing. Defaults to 64KB.
#
# source://io-stream//lib/io/stream/writable.rb#10
IO::Stream::MINIMUM_WRITE_SIZE = T.let(T.unsafe(nil), Integer)

# A module providing readable stream functionality.
#
# You must implement the `sysread` method to read data from the underlying IO.
#
# source://io-stream//lib/io/stream/readable.rb#27
module IO::Stream::Readable
  # Initialize readable stream functionality.
  #
  # source://io-stream//lib/io/stream/readable.rb#32
  def initialize(minimum_read_size: T.unsafe(nil), maximum_read_size: T.unsafe(nil), block_size: T.unsafe(nil), **_arg3, &block); end

  # Legacy accessor for backwards compatibility
  #
  # source://io-stream//lib/io/stream/readable.rb#49
  def block_size; end

  # Legacy setter for backwards compatibility
  #
  # source://io-stream//lib/io/stream/readable.rb#55
  def block_size=(value); end

  # Close the read end of the stream.
  #
  # source://io-stream//lib/io/stream/readable.rb#330
  def close_read; end

  # Efficiently discard data from the stream until encountering pattern.
  #
  # source://io-stream//lib/io/stream/readable.rb#203
  def discard_until(pattern, offset = T.unsafe(nil), limit: T.unsafe(nil)); end

  # Mark the stream as finished and raise `EOFError`.
  #
  # @raise [EOFError]
  #
  # source://io-stream//lib/io/stream/readable.rb#310
  def eof!; end

  # Determins if the stream has consumed all available data. May block if the stream is not readable.
  # See {readable?} for a non-blocking alternative.
  #
  # @return [Boolean]
  #
  # source://io-stream//lib/io/stream/readable.rb#300
  def eof?; end

  # Mark the stream as finished and raise `EOFError`.
  #
  # @raise [EOFError]
  #
  # source://io-stream//lib/io/stream/readable.rb#303
  def finish!; end

  # Determins if the stream has consumed all available data. May block if the stream is not readable.
  # See {readable?} for a non-blocking alternative.
  #
  # @return [Boolean]
  #
  # source://io-stream//lib/io/stream/readable.rb#290
  def finished?; end

  # Read a line from the stream, similar to IO#gets.
  #
  # source://io-stream//lib/io/stream/readable.rb#245
  def gets(separator = T.unsafe(nil), limit = T.unsafe(nil), chomp: T.unsafe(nil)); end

  # Returns the value of attribute minimum_read_size.
  #
  # source://io-stream//lib/io/stream/readable.rb#45
  def minimum_read_size; end

  # Sets the attribute minimum_read_size
  #
  # @param value the value to set the attribute minimum_read_size to.
  #
  # source://io-stream//lib/io/stream/readable.rb#45
  def minimum_read_size=(_arg0); end

  # Peek at data in the buffer without consuming it.
  #
  # source://io-stream//lib/io/stream/readable.rb#223
  def peek(size = T.unsafe(nil)); end

  # Read data from the stream.
  #
  # source://io-stream//lib/io/stream/readable.rb#63
  def read(size = T.unsafe(nil), buffer = T.unsafe(nil)); end

  # Read exactly the specified number of bytes.
  #
  # @raise [exception]
  #
  # source://io-stream//lib/io/stream/readable.rb#128
  def read_exactly(size, buffer = T.unsafe(nil), exception: T.unsafe(nil)); end

  # Read at most `size` bytes from the stream. Will avoid reading from the underlying stream if possible.
  #
  # source://io-stream//lib/io/stream/readable.rb#106
  def read_partial(size = T.unsafe(nil), buffer = T.unsafe(nil)); end

  # Efficiently read data from the stream until encountering pattern.
  #
  # source://io-stream//lib/io/stream/readable.rb#186
  def read_until(pattern, offset = T.unsafe(nil), limit: T.unsafe(nil), chomp: T.unsafe(nil)); end

  # Whether there is a chance that a read operation will succeed or not.
  #
  # @return [Boolean]
  #
  # source://io-stream//lib/io/stream/readable.rb#314
  def readable?; end

  # This is a compatibility shim for existing code that uses `readpartial`.
  #
  # source://io-stream//lib/io/stream/readable.rb#144
  def readpartial(size = T.unsafe(nil), buffer = T.unsafe(nil)); end

  private

  # Consumes at most `size` bytes from the buffer.
  #
  # source://io-stream//lib/io/stream/readable.rb#369
  def consume_read_buffer(size = T.unsafe(nil), buffer = T.unsafe(nil)); end

  # Fills the buffer from the underlying stream.
  #
  # source://io-stream//lib/io/stream/readable.rb#336
  def fill_read_buffer(size = T.unsafe(nil)); end

  # Find the index of a pattern in the read buffer, reading more data if needed.
  #
  # source://io-stream//lib/io/stream/readable.rb#153
  def index_of(pattern, offset, limit, discard = T.unsafe(nil)); end
end

# A specialized string buffer for binary data with automatic encoding handling.
#
# source://io-stream//lib/io/stream/string_buffer.rb#8
class IO::Stream::StringBuffer < ::String
  # Initialize a new string buffer with binary encoding.
  #
  # @return [StringBuffer] a new instance of StringBuffer
  #
  # source://io-stream//lib/io/stream/string_buffer.rb#12
  def initialize; end

  # Append a string to the buffer, converting to binary encoding if necessary.
  #
  # source://io-stream//lib/io/stream/string_buffer.rb#21
  def <<(string); end

  # Append a string to the buffer, converting to binary encoding if necessary.
  #
  # source://io-stream//lib/io/stream/string_buffer.rb#31
  def concat(string); end
end

# source://io-stream//lib/io/stream/string_buffer.rb#9
IO::Stream::StringBuffer::BINARY = T.let(T.unsafe(nil), Encoding)

# source://io-stream//lib/io/stream/version.rb#7
IO::Stream::VERSION = T.let(T.unsafe(nil), String)

# A module providing writable stream functionality.
#
# You must implement the `syswrite` method to write data to the underlying IO.
#
# source://io-stream//lib/io/stream/writable.rb#15
module IO::Stream::Writable
  # Initialize writable stream functionality.
  #
  # source://io-stream//lib/io/stream/writable.rb#18
  def initialize(minimum_write_size: T.unsafe(nil), **_arg1, &block); end

  # Appends `string` to the buffer and returns self for method chaining.
  #
  # source://io-stream//lib/io/stream/writable.rb#57
  def <<(string); end

  # Close the write end of the stream by flushing any remaining data.
  #
  # source://io-stream//lib/io/stream/writable.rb#79
  def close_write; end

  # Flushes buffered data to the stream.
  #
  # source://io-stream//lib/io/stream/writable.rb#29
  def flush; end

  # Returns the value of attribute minimum_write_size.
  #
  # source://io-stream//lib/io/stream/writable.rb#26
  def minimum_write_size; end

  # Sets the attribute minimum_write_size
  #
  # @param value the value to set the attribute minimum_write_size to.
  #
  # source://io-stream//lib/io/stream/writable.rb#26
  def minimum_write_size=(_arg0); end

  # Write arguments to the stream followed by a separator and flush immediately.
  #
  # source://io-stream//lib/io/stream/writable.rb#66
  def puts(*arguments, separator: T.unsafe(nil)); end

  # Writes `string` to the buffer. When the buffer is full or #sync is true the
  # buffer is flushed to the underlying `io`.
  #
  # source://io-stream//lib/io/stream/writable.rb#41
  def write(string, flush: T.unsafe(nil)); end

  private

  # source://io-stream//lib/io/stream/writable.rb#83
  def drain(buffer); end
end

IO::WRITABLE = T.let(T.unsafe(nil), Integer)

class OpenSSL::Config
  include ::Enumerable
end

class OpenSSL::Provider; end
class OpenSSL::Provider::ProviderError < ::OpenSSL::OpenSSLError; end

class OpenSSL::SSL::SSLErrorWaitReadable < ::OpenSSL::SSL::SSLError
  include ::IO::WaitReadable
end

class OpenSSL::SSL::SSLErrorWaitWritable < ::OpenSSL::SSL::SSLError
  include ::IO::WaitWritable
end

# SSL socket extensions for stream compatibility.
#
# source://io-stream//lib/io/stream/shim/readable.rb#53
class OpenSSL::SSL::SSLSocket
  include ::Enumerable

  # Set the buffered state of the SSL socket.
  #
  # source://io-stream//lib/io/stream/openssl.rb#69
  def buffered=(value); end

  # Check if the SSL socket is buffered.
  #
  # @return [Boolean]
  #
  # source://io-stream//lib/io/stream/openssl.rb#61
  def buffered?; end

  # Check if the SSL socket is readable.
  #
  # @return [Boolean]
  #
  # source://io-stream//lib/io/stream/shim/readable.rb#57
  def readable?; end
end

module OpenSSL::Timestamp; end
class OpenSSL::Timestamp::Factory; end
class OpenSSL::Timestamp::Request; end
class OpenSSL::Timestamp::Response; end
class OpenSSL::Timestamp::TimestampError < ::OpenSSL::OpenSSLError; end
class OpenSSL::Timestamp::TokenInfo; end

# StringIO extensions for buffering support.
#
# source://io-stream//lib/io/stream/shim/buffered.rb#68
class StringIO
  include ::Enumerable

  # Set the buffered state of the StringIO.
  #
  # source://io-stream//lib/io/stream/shim/buffered.rb#77
  def buffered=(value); end

  # Check if the StringIO is buffered.
  #
  # @return [Boolean]
  #
  # source://io-stream//lib/io/stream/shim/buffered.rb#71
  def buffered?; end

  # Check if the StringIO is readable.
  #
  # @return [Boolean]
  #
  # source://io-stream//lib/io/stream/shim/readable.rb#45
  def readable?; end
end
