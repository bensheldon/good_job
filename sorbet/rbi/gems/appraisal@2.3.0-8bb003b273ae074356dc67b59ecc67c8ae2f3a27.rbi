# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `appraisal` gem.
# Please instead update this file by running `bin/tapioca sync`.

# typed: true

module Appraisal
end

class Appraisal::Appraisal
  def initialize(name, source_gemfile); end

  def gem(*args); end
  def gemfile; end
  def gemfile_path; end
  def gemspec(options = T.unsafe(nil)); end
  def git(*args, &block); end
  def git_source(*args, &block); end
  def group(*args, &block); end
  def install(options = T.unsafe(nil)); end
  def name; end
  def path(*args, &block); end
  def platforms(*args, &block); end
  def relative_gemfile_path; end
  def relativize; end
  def remove_gem(*args); end
  def ruby(*args); end
  def source(*args, &block); end
  def update(gems = T.unsafe(nil)); end
  def write_gemfile; end

  private

  def bundle_options(options); end
  def check_command; end
  def clean_name; end
  def gemfile_name; end
  def gemfile_root; end
  def install_command(options = T.unsafe(nil)); end
  def lockfile_path; end
  def project_root; end
  def update_command(gems); end
end

Appraisal::Appraisal::DEFAULT_INSTALL_OPTIONS = T.let(T.unsafe(nil), Hash)

class Appraisal::AppraisalFile
  def initialize; end

  def appraisals; end
  def appraise(name, &block); end
  def each(&block); end
  def gemfile; end

  private

  def path; end
  def run(definitions); end

  class << self
    def each(&block); end
  end
end

class Appraisal::AppraisalsNotFound < ::StandardError
  def message; end
end

class Appraisal::BundlerDSL
  def initialize; end

  def dependencies; end
  def for_dup; end
  def gem(name, *requirements); end
  def gemspec(options = T.unsafe(nil)); end
  def git(source, options = T.unsafe(nil), &block); end
  def git_source(source, &block); end
  def group(*names, &block); end
  def path(source, options = T.unsafe(nil), &block); end
  def platform(*names, &block); end
  def platforms(*names, &block); end
  def remove_gem(name); end
  def ruby(ruby_version); end
  def run(&block); end
  def source(source, &block); end
  def to_s; end

  protected

  def git_sources=(_arg0); end

  private

  def dependencies_entry; end
  def dependencies_entry_for_dup; end
  def gemspec_entry; end
  def gemspec_entry_for_dup; end
  def gits_entry; end
  def gits_entry_for_dup; end
  def groups_entry; end
  def groups_entry_for_dup; end
  def indent(string); end
  def paths_entry; end
  def paths_entry_for_dup; end
  def platforms_entry; end
  def platforms_entry_for_dup; end
  def ruby_version_entry; end
  def ruby_version_entry_for_dup; end
  def source_blocks_entry; end
  def source_blocks_entry_for_dup; end
  def source_entry; end
  def source_entry_for_dup; end
  def substitute_git_source(requirements); end
end

Appraisal::BundlerDSL::PARTS = T.let(T.unsafe(nil), Array)

class Appraisal::Command
  def initialize(command, options = T.unsafe(nil)); end

  def command; end
  def env; end
  def gemfile; end
  def run; end

  private

  def announce; end
  def command_as_string; end
  def command_starting_with_bundle(original_command); end
  def command_starts_with_bundle?(original_command); end
  def ensure_bundler_is_available; end
end

class Appraisal::Dependency
  def initialize(name, requirements); end

  def for_dup; end
  def name; end
  def requirements; end
  def requirements=(_arg0); end
  def to_s; end

  private

  def formatted_output(output_requirements); end
  def gem_name; end
  def no_requirements?; end
  def path_prefixed_requirements; end
end

class Appraisal::DependencyList
  def initialize; end

  def add(name, requirements); end
  def for_dup; end
  def remove(name); end
  def to_s; end
end

class Appraisal::Gemfile < ::Appraisal::BundlerDSL
  def dup; end
  def load(path); end
  def run(definitions); end
end

class Appraisal::Gemspec
  def initialize(options = T.unsafe(nil)); end

  def for_dup; end
  def options; end
  def to_s; end

  private

  def exported_options; end
end

class Appraisal::Git < ::Appraisal::BundlerDSL
  def initialize(source, options = T.unsafe(nil)); end

  def for_dup; end
  def to_s; end
end

class Appraisal::Group < ::Appraisal::BundlerDSL
  def initialize(group_names); end

  def for_dup; end
  def to_s; end

  private

  def formatted_output(output_dependencies); end
end

class Appraisal::Path < ::Appraisal::BundlerDSL
  def initialize(source, options = T.unsafe(nil)); end

  def for_dup; end
  def to_s; end
end

class Appraisal::Platform < ::Appraisal::BundlerDSL
  def initialize(platform_names); end

  def for_dup; end
  def to_s; end

  private

  def formatted_output(output_dependencies); end
end

class Appraisal::Source < ::Appraisal::BundlerDSL
  def initialize(source); end

  def for_dup; end
  def to_s; end

  private

  def formatted_output(output_dependencies); end
end

class Appraisal::Task < ::Rake::TaskLib
  def initialize; end
end

module Appraisal::Utils
  class << self
    def bundler_version; end
    def format_arguments(arguments); end
    def format_hash_value(key, value); end
    def format_string(object, enclosing_object = T.unsafe(nil)); end
    def join_parts(parts); end
    def prefix_path(path); end
    def support_parallel_installation?; end
  end
end

Appraisal::VERSION = T.let(T.unsafe(nil), String)
