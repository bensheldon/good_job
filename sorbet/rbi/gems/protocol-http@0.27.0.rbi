# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `protocol-http` gem.
# Please instead update this file by running `bin/tapioca gem protocol-http`.


# source://protocol-http//lib/protocol/http/body/readable.rb#7
module Protocol; end

# source://protocol-http//lib/protocol/http/body/readable.rb#8
module Protocol::HTTP; end

# source://protocol-http//lib/protocol/http/body/readable.rb#9
module Protocol::HTTP::Body; end

# A body which buffers all it's contents.
#
# source://protocol-http//lib/protocol/http/body/buffered.rb#13
class Protocol::HTTP::Body::Buffered < ::Protocol::HTTP::Body::Readable
  # @return [Buffered] a new instance of Buffered
  #
  # source://protocol-http//lib/protocol/http/body/buffered.rb#42
  def initialize(chunks = T.unsafe(nil), length = T.unsafe(nil)); end

  # Returns the value of attribute chunks.
  #
  # source://protocol-http//lib/protocol/http/body/buffered.rb#49
  def chunks; end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/body/buffered.rb#59
  def empty?; end

  # source://protocol-http//lib/protocol/http/body/buffered.rb#51
  def finish; end

  # source://protocol-http//lib/protocol/http/body/buffered.rb#84
  def inspect; end

  # source://protocol-http//lib/protocol/http/body/buffered.rb#55
  def length; end

  # source://protocol-http//lib/protocol/http/body/buffered.rb#68
  def read; end

  # A buffered response is always ready.
  #
  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/body/buffered.rb#64
  def ready?; end

  # source://protocol-http//lib/protocol/http/body/buffered.rb#80
  def rewind; end

  # source://protocol-http//lib/protocol/http/body/buffered.rb#76
  def write(chunk); end

  class << self
    # source://protocol-http//lib/protocol/http/body/buffered.rb#32
    def for(body); end

    # Wraps an array into a buffered body.
    #
    # For compatibility, also accepts anything that behaves like an `Array(String)`.
    #
    # source://protocol-http//lib/protocol/http/body/buffered.rb#20
    def wrap(body); end
  end
end

# Invokes a callback once the body has completed, either successfully or due to an error.
#
# source://protocol-http//lib/protocol/http/body/completable.rb#12
class Protocol::HTTP::Body::Completable < ::Protocol::HTTP::Body::Wrapper
  # @return [Completable] a new instance of Completable
  #
  # source://protocol-http//lib/protocol/http/body/completable.rb#21
  def initialize(body, callback); end

  # source://protocol-http//lib/protocol/http/body/completable.rb#36
  def close(error = T.unsafe(nil)); end

  # source://protocol-http//lib/protocol/http/body/completable.rb#27
  def finish; end

  class << self
    # source://protocol-http//lib/protocol/http/body/completable.rb#13
    def wrap(message, &block); end
  end
end

# source://protocol-http//lib/protocol/http/body/head.rb#11
class Protocol::HTTP::Body::Head < ::Protocol::HTTP::Body::Readable
  # @return [Head] a new instance of Head
  #
  # source://protocol-http//lib/protocol/http/body/head.rb#20
  def initialize(length); end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/body/head.rb#24
  def empty?; end

  # source://protocol-http//lib/protocol/http/body/head.rb#32
  def length; end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/body/head.rb#28
  def ready?; end

  class << self
    # source://protocol-http//lib/protocol/http/body/head.rb#12
    def for(body); end
  end
end

# An interface for reading data from a body.
#
# Typically, you'd override `#read` to return chunks of data.
#
# source://protocol-http//lib/protocol/http/body/readable.rb#13
class Protocol::HTTP::Body::Readable
  # source://protocol-http//lib/protocol/http/body/readable.rb#97
  def as_json(*_arg0, **_arg1, &_arg2); end

  # Write the body to the given stream.
  #
  # source://protocol-http//lib/protocol/http/body/readable.rb#49
  def call(stream); end

  # Close the stream immediately.
  #
  # source://protocol-http//lib/protocol/http/body/readable.rb#15
  def close(error = T.unsafe(nil)); end

  # Enumerate all chunks until finished, then invoke `#close`.
  #
  # source://protocol-http//lib/protocol/http/body/readable.rb#68
  def each; end

  # Optimistically determine whether read (may) return any data.
  # If this returns true, then calling read will definitely return nil.
  # If this returns false, then calling read may return nil.
  #
  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/body/readable.rb#21
  def empty?; end

  # Read all remaining chunks into a buffered body and close the underlying input.
  #
  # source://protocol-http//lib/protocol/http/body/readable.rb#59
  def finish; end

  # Read all remaining chunks into a single binary string using `#each`.
  #
  # source://protocol-http//lib/protocol/http/body/readable.rb#83
  def join; end

  # source://protocol-http//lib/protocol/http/body/readable.rb#32
  def length; end

  # Read the next available chunk.
  #
  # source://protocol-http//lib/protocol/http/body/readable.rb#38
  def read; end

  # Whether calling read will return a chunk of data without blocking.
  # We prefer pessimistic implementation, and thus default to `false`.
  #
  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/body/readable.rb#28
  def ready?; end

  # Should the internal mechanism prefer to use {call}?
  #
  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/body/readable.rb#44
  def stream?; end

  # source://protocol-http//lib/protocol/http/body/readable.rb#107
  def to_json(*_arg0, **_arg1, &_arg2); end
end

# General operations for interacting with a request or response body.
#
# source://protocol-http//lib/protocol/http/body/reader.rb#11
module Protocol::HTTP::Body::Reader
  # Whether there is a body?
  #
  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/body/reader.rb#63
  def body?; end

  # Close the connection as quickly as possible. Discards body. May close the underlying connection if necessary to terminate the stream.
  #
  # source://protocol-http//lib/protocol/http/body/reader.rb#55
  def close(error = T.unsafe(nil)); end

  # Read chunks from the body.
  #
  # @yield [String] read chunks from the body.
  #
  # source://protocol-http//lib/protocol/http/body/reader.rb#14
  def each(&block); end

  # Gracefully finish reading the body. This will buffer the remainder of the body.
  #
  # @return [Buffered] buffers the entire body.
  #
  # source://protocol-http//lib/protocol/http/body/reader.rb#34
  def finish; end

  # Reads the entire request/response body.
  #
  # @return [String] the entire body as a string.
  #
  # source://protocol-http//lib/protocol/http/body/reader.rb#23
  def read; end

  # Write the body of the response to the given file path.
  #
  # source://protocol-http//lib/protocol/http/body/reader.rb#44
  def save(path, mode = T.unsafe(nil), **options); end
end

# The input stream is an IO-like object which contains the raw HTTP POST data. When applicable, its external encoding must be “ASCII-8BIT” and it must be opened in binary mode, for Ruby 1.9 compatibility. The input stream must respond to gets, each, read and rewind.
#
# source://protocol-http//lib/protocol/http/body/stream.rb#13
class Protocol::HTTP::Body::Stream
  include ::Protocol::HTTP::Body::Stream::Reader

  # @raise [ArgumentError]
  # @return [Stream] a new instance of Stream
  #
  # source://protocol-http//lib/protocol/http/body/stream.rb#16
  def initialize(input = T.unsafe(nil), output = T.unsafe(nil)); end

  # Write data to the stream using {write}.
  #
  # source://protocol-http//lib/protocol/http/body/stream.rb#214
  def <<(buffer); end

  # Close the input and output bodies.
  #
  # source://protocol-http//lib/protocol/http/body/stream.rb#260
  def close(error = T.unsafe(nil)); end

  # Close the input body.
  #
  # source://protocol-http//lib/protocol/http/body/stream.rb#241
  def close_read; end

  # Close the output body.
  #
  # source://protocol-http//lib/protocol/http/body/stream.rb#252
  def close_write; end

  # Whether the stream has been closed.
  #
  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/body/stream.rb#270
  def closed?; end

  # Whether there are any output chunks remaining?
  #
  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/body/stream.rb#275
  def empty?; end

  # Flush the output stream.
  #
  # This is currently a no-op.
  #
  # source://protocol-http//lib/protocol/http/body/stream.rb#237
  def flush; end

  # Returns the value of attribute input.
  #
  # source://protocol-http//lib/protocol/http/body/stream.rb#28
  def input; end

  # Returns the value of attribute output.
  #
  # source://protocol-http//lib/protocol/http/body/stream.rb#29
  def output; end

  # Write lines to the stream.
  #
  # The current implementation buffers the lines and writes them in a single operation.
  #
  # source://protocol-http//lib/protocol/http/body/stream.rb#224
  def puts(*arguments, separator: T.unsafe(nil)); end

  # Write data to the underlying stream.
  #
  # source://protocol-http//lib/protocol/http/body/stream.rb#193
  def write(buffer); end

  # Write data to the stream using {write}.
  #
  # Provided for compatibility with IO-like objects.
  #
  # source://protocol-http//lib/protocol/http/body/stream.rb#209
  def write_nonblock(buffer, exception: T.unsafe(nil)); end

  private

  # source://protocol-http//lib/protocol/http/body/stream.rb#281
  def read_next; end
end

# source://protocol-http//lib/protocol/http/body/stream.rb#14
Protocol::HTTP::Body::Stream::NEWLINE = T.let(T.unsafe(nil), String)

# This provides a read-only interface for data, which is surprisingly tricky to implement correctly.
#
# source://protocol-http//lib/protocol/http/body/stream.rb#32
module Protocol::HTTP::Body::Stream::Reader
  # Read a single line from the stream.
  #
  # source://protocol-http//lib/protocol/http/body/stream.rb#181
  def gets(separator = T.unsafe(nil), **options); end

  # Read data from the underlying stream.
  #
  # If given a non-negative length, it will read at most that many bytes from the stream. If the stream is at EOF, it will return nil.
  #
  # If the length is not given, it will read all data until EOF, or return an empty string if the stream is already at EOF.
  #
  # If buffer is given, then the read data will be placed into buffer instead of a newly created String object.
  #
  # @param length [Integer] the amount of data to read
  # @param buffer [String] the buffer which will receive the data
  # @return a buffer containing the data
  #
  # source://protocol-http//lib/protocol/http/body/stream.rb#44
  def read(length = T.unsafe(nil), buffer = T.unsafe(nil)); end

  # Read data from the stream without blocking if possible.
  #
  # source://protocol-http//lib/protocol/http/body/stream.rb#119
  def read_nonblock(length, buffer = T.unsafe(nil), exception: T.unsafe(nil)); end

  # Read some bytes from the stream.
  #
  # If the length is given, at most length bytes will be read. Otherwise, one chunk of data from the underlying stream will be read.
  #
  # Will avoid reading from the underlying stream if there is buffered data available.
  #
  # source://protocol-http//lib/protocol/http/body/stream.rb#92
  def read_partial(length = T.unsafe(nil)); end

  # Read data from the stream until encountering pattern.
  #
  # source://protocol-http//lib/protocol/http/body/stream.rb#151
  def read_until(pattern, offset = T.unsafe(nil), chomp: T.unsafe(nil)); end

  # Similar to {read_partial} but raises an `EOFError` if the stream is at EOF.
  #
  # source://protocol-http//lib/protocol/http/body/stream.rb#114
  def readpartial(length); end
end

# Wrapping body instance. Typically you'd override `#read`.
#
# source://protocol-http//lib/protocol/http/body/wrapper.rb#12
class Protocol::HTTP::Body::Wrapper < ::Protocol::HTTP::Body::Readable
  # @return [Wrapper] a new instance of Wrapper
  #
  # source://protocol-http//lib/protocol/http/body/wrapper.rb#19
  def initialize(body); end

  # source://protocol-http//lib/protocol/http/body/wrapper.rb#54
  def as_json(*_arg0, **_arg1, &_arg2); end

  # The wrapped body.
  #
  # source://protocol-http//lib/protocol/http/body/wrapper.rb#24
  def body; end

  # source://protocol-http//lib/protocol/http/body/wrapper.rb#73
  def call(stream); end

  # source://protocol-http//lib/protocol/http/body/wrapper.rb#31
  def close(error = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/body/wrapper.rb#37
  def empty?; end

  # Buffer any remaining body.
  #
  # source://protocol-http//lib/protocol/http/body/wrapper.rb#27
  def finish; end

  # source://protocol-http//lib/protocol/http/body/wrapper.rb#65
  def inspect; end

  # source://protocol-http//lib/protocol/http/body/wrapper.rb#45
  def length; end

  # Read the next available chunk.
  #
  # source://protocol-http//lib/protocol/http/body/wrapper.rb#50
  def read; end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/body/wrapper.rb#41
  def ready?; end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/body/wrapper.rb#69
  def stream?; end

  # source://protocol-http//lib/protocol/http/body/wrapper.rb#61
  def to_json(*_arg0, **_arg1, &_arg2); end

  class << self
    # source://protocol-http//lib/protocol/http/body/wrapper.rb#13
    def wrap(message); end
  end
end

# Represents an individual cookie key-value pair.
#
# source://protocol-http//lib/protocol/http/cookie.rb#12
class Protocol::HTTP::Cookie
  # @return [Cookie] a new instance of Cookie
  #
  # source://protocol-http//lib/protocol/http/cookie.rb#13
  def initialize(name, value, directives); end

  # Returns the value of attribute directives.
  #
  # source://protocol-http//lib/protocol/http/cookie.rb#21
  def directives; end

  # source://protocol-http//lib/protocol/http/cookie.rb#23
  def encoded_name; end

  # source://protocol-http//lib/protocol/http/cookie.rb#27
  def encoded_value; end

  # Returns the value of attribute name.
  #
  # source://protocol-http//lib/protocol/http/cookie.rb#19
  def name; end

  # source://protocol-http//lib/protocol/http/cookie.rb#31
  def to_s; end

  # Returns the value of attribute value.
  #
  # source://protocol-http//lib/protocol/http/cookie.rb#20
  def value; end

  class << self
    # source://protocol-http//lib/protocol/http/cookie.rb#52
    def parse(string); end

    # source://protocol-http//lib/protocol/http/cookie.rb#65
    def parse_directives(strings); end
  end
end

# A generic, HTTP protocol error.
#
# source://protocol-http//lib/protocol/http/error.rb#9
class Protocol::HTTP::Error < ::StandardError; end

# source://protocol-http//lib/protocol/http/header/split.rb#8
module Protocol::HTTP::Header; end

# Used for basic authorization.
#
# ~~~ ruby
# headers.add('authorization', Authorization.basic("my_username", "my_password"))
# ~~~
#
# source://protocol-http//lib/protocol/http/header/authorization.rb#15
class Protocol::HTTP::Header::Authorization < ::String
  # Splits the header and
  #
  # @return [Tuple(String, String)]
  #
  # source://protocol-http//lib/protocol/http/header/authorization.rb#18
  def credentials; end

  class << self
    # source://protocol-http//lib/protocol/http/header/authorization.rb#22
    def basic(username, password); end
  end
end

# source://protocol-http//lib/protocol/http/header/cache_control.rb#12
class Protocol::HTTP::Header::CacheControl < ::Protocol::HTTP::Header::Split
  # @return [CacheControl] a new instance of CacheControl
  #
  # source://protocol-http//lib/protocol/http/header/cache_control.rb#27
  def initialize(value = T.unsafe(nil)); end

  # source://protocol-http//lib/protocol/http/header/cache_control.rb#31
  def <<(value); end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/header/cache_control.rb#39
  def dynamic?; end

  # The maximum time, in seconds, a response should be considered fresh.
  # See https://www.rfc-editor.org/rfc/rfc9111.html#name-max-age-2
  #
  # source://protocol-http//lib/protocol/http/header/cache_control.rb#77
  def max_age; end

  # Indicates that a response must not be used once it is stale.
  # See https://www.rfc-editor.org/rfc/rfc9111.html#name-must-revalidate
  #
  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/header/cache_control.rb#65
  def must_revalidate?; end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/header/cache_control.rb#55
  def no_cache?; end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/header/cache_control.rb#59
  def no_store?; end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/header/cache_control.rb#47
  def private?; end

  # Like must-revalidate, but for shared caches only.
  # See https://www.rfc-editor.org/rfc/rfc9111.html#name-proxy-revalidate
  #
  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/header/cache_control.rb#71
  def proxy_revalidate?; end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/header/cache_control.rb#51
  def public?; end

  # Like max-age, but for shared caches only, which should use it before
  # max-age when present.
  # See https://www.rfc-editor.org/rfc/rfc9111.html#name-s-maxage
  #
  # source://protocol-http//lib/protocol/http/header/cache_control.rb#84
  def s_maxage; end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/header/cache_control.rb#35
  def static?; end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/header/cache_control.rb#43
  def streaming?; end

  private

  # source://protocol-http//lib/protocol/http/header/cache_control.rb#90
  def find_integer_value(value_name); end
end

# source://protocol-http//lib/protocol/http/header/cache_control.rb#21
Protocol::HTTP::Header::CacheControl::DYNAMIC = T.let(T.unsafe(nil), String)

# source://protocol-http//lib/protocol/http/header/cache_control.rb#17
Protocol::HTTP::Header::CacheControl::MAX_AGE = T.let(T.unsafe(nil), String)

# source://protocol-http//lib/protocol/http/header/cache_control.rb#24
Protocol::HTTP::Header::CacheControl::MUST_REVALIDATE = T.let(T.unsafe(nil), String)

# source://protocol-http//lib/protocol/http/header/cache_control.rb#15
Protocol::HTTP::Header::CacheControl::NO_CACHE = T.let(T.unsafe(nil), String)

# source://protocol-http//lib/protocol/http/header/cache_control.rb#16
Protocol::HTTP::Header::CacheControl::NO_STORE = T.let(T.unsafe(nil), String)

# source://protocol-http//lib/protocol/http/header/cache_control.rb#13
Protocol::HTTP::Header::CacheControl::PRIVATE = T.let(T.unsafe(nil), String)

# source://protocol-http//lib/protocol/http/header/cache_control.rb#25
Protocol::HTTP::Header::CacheControl::PROXY_REVALIDATE = T.let(T.unsafe(nil), String)

# source://protocol-http//lib/protocol/http/header/cache_control.rb#14
Protocol::HTTP::Header::CacheControl::PUBLIC = T.let(T.unsafe(nil), String)

# source://protocol-http//lib/protocol/http/header/cache_control.rb#20
Protocol::HTTP::Header::CacheControl::STATIC = T.let(T.unsafe(nil), String)

# source://protocol-http//lib/protocol/http/header/cache_control.rb#22
Protocol::HTTP::Header::CacheControl::STREAMING = T.let(T.unsafe(nil), String)

# source://protocol-http//lib/protocol/http/header/cache_control.rb#18
Protocol::HTTP::Header::CacheControl::S_MAXAGE = T.let(T.unsafe(nil), String)

# source://protocol-http//lib/protocol/http/header/connection.rb#12
class Protocol::HTTP::Header::Connection < ::Protocol::HTTP::Header::Split
  # @return [Connection] a new instance of Connection
  #
  # source://protocol-http//lib/protocol/http/header/connection.rb#17
  def initialize(value = T.unsafe(nil)); end

  # source://protocol-http//lib/protocol/http/header/connection.rb#21
  def <<(value); end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/header/connection.rb#29
  def close?; end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/header/connection.rb#25
  def keep_alive?; end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/header/connection.rb#33
  def upgrade?; end
end

# source://protocol-http//lib/protocol/http/header/connection.rb#14
Protocol::HTTP::Header::Connection::CLOSE = T.let(T.unsafe(nil), String)

# source://protocol-http//lib/protocol/http/header/connection.rb#13
Protocol::HTTP::Header::Connection::KEEP_ALIVE = T.let(T.unsafe(nil), String)

# source://protocol-http//lib/protocol/http/header/connection.rb#15
Protocol::HTTP::Header::Connection::UPGRADE = T.let(T.unsafe(nil), String)

# The Cookie HTTP request header contains stored HTTP cookies previously sent by the server with the Set-Cookie header.
#
# source://protocol-http//lib/protocol/http/header/cookie.rb#13
class Protocol::HTTP::Header::Cookie < ::Protocol::HTTP::Header::Multiple
  # source://protocol-http//lib/protocol/http/header/cookie.rb#14
  def to_h; end
end

# source://protocol-http//lib/protocol/http/header/date.rb#11
class Protocol::HTTP::Header::Date < ::String
  # source://protocol-http//lib/protocol/http/header/date.rb#12
  def <<(value); end

  # source://protocol-http//lib/protocol/http/header/date.rb#16
  def to_time; end
end

# source://protocol-http//lib/protocol/http/header/etag.rb#9
class Protocol::HTTP::Header::ETag < ::String
  # source://protocol-http//lib/protocol/http/header/etag.rb#10
  def <<(value); end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/header/etag.rb#14
  def weak?; end
end

# source://protocol-http//lib/protocol/http/header/etags.rb#12
class Protocol::HTTP::Header::ETags < ::Protocol::HTTP::Header::Split
  # This implementation is not strictly correct according to the RFC-specified format.
  #
  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/header/etags.rb#18
  def match?(etag); end

  # Useful with If-Match
  #
  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/header/etags.rb#23
  def strong_match?(etag); end

  # Useful with If-None-Match
  #
  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/header/etags.rb#28
  def weak_match?(etag); end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/header/etags.rb#13
  def wildcard?; end

  private

  # source://protocol-http//lib/protocol/http/header/etags.rb#34
  def opposite_tag(etag); end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/header/etags.rb#38
  def weak_tag?(tag); end
end

# Header value which is split by newline charaters (e.g. cookies).
#
# source://protocol-http//lib/protocol/http/header/multiple.rb#10
class Protocol::HTTP::Header::Multiple < ::Array
  # @return [Multiple] a new instance of Multiple
  #
  # source://protocol-http//lib/protocol/http/header/multiple.rb#11
  def initialize(value); end

  # source://protocol-http//lib/protocol/http/header/multiple.rb#17
  def to_s; end
end

# The Set-Cookie HTTP response header sends cookies from the server to the user agent.
#
# source://protocol-http//lib/protocol/http/header/cookie.rb#24
class Protocol::HTTP::Header::SetCookie < ::Protocol::HTTP::Header::Cookie; end

# Header value which is split by commas.
#
# source://protocol-http//lib/protocol/http/header/split.rb#10
class Protocol::HTTP::Header::Split < ::Array
  # @return [Split] a new instance of Split
  #
  # source://protocol-http//lib/protocol/http/header/split.rb#13
  def initialize(value); end

  # source://protocol-http//lib/protocol/http/header/split.rb#21
  def <<(value); end

  # source://protocol-http//lib/protocol/http/header/split.rb#25
  def to_s; end
end

# source://protocol-http//lib/protocol/http/header/split.rb#11
Protocol::HTTP::Header::Split::COMMA = T.let(T.unsafe(nil), Regexp)

# source://protocol-http//lib/protocol/http/header/vary.rb#11
class Protocol::HTTP::Header::Vary < ::Protocol::HTTP::Header::Split
  # @return [Vary] a new instance of Vary
  #
  # source://protocol-http//lib/protocol/http/header/vary.rb#12
  def initialize(value); end

  # source://protocol-http//lib/protocol/http/header/vary.rb#16
  def <<(value); end
end

# Headers are an array of key-value pairs. Some header keys represent multiple values.
#
# source://protocol-http//lib/protocol/http/headers.rb#20
class Protocol::HTTP::Headers
  # @return [Headers] a new instance of Headers
  #
  # source://protocol-http//lib/protocol/http/headers.rb#50
  def initialize(fields = T.unsafe(nil), indexed = T.unsafe(nil)); end

  # source://protocol-http//lib/protocol/http/headers.rb#308
  def ==(other); end

  # source://protocol-http//lib/protocol/http/headers.rb#289
  def [](key); end

  # Append the value to the given key. Some values can be appended multiple times, others can only be set once.
  #
  # @param key [String] The header key.
  # @param value The header value.
  #
  # source://protocol-http//lib/protocol/http/headers.rb#196
  def []=(key, value); end

  # Add the specified header key value pair.
  #
  # @param key [String] the header key.
  # @param value [String] the header value to assign.
  #
  # source://protocol-http//lib/protocol/http/headers.rb#168
  def add(key, value); end

  # A hash table of `{key, policy[key].map(values)}`
  #
  # source://protocol-http//lib/protocol/http/headers.rb#294
  def as_json; end

  # source://protocol-http//lib/protocol/http/headers.rb#65
  def clear; end

  # Delete all headers with the given key, and return the merged value.
  #
  # source://protocol-http//lib/protocol/http/headers.rb#252
  def delete(key); end

  # source://protocol-http//lib/protocol/http/headers.rb#136
  def each(&block); end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/headers.rb#132
  def empty?; end

  # source://protocol-http//lib/protocol/http/headers.rb#150
  def extract(keys); end

  # An array of `[key, value]` pairs.
  #
  # source://protocol-http//lib/protocol/http/headers.rb#86
  def fields; end

  # source://protocol-http//lib/protocol/http/headers.rb#81
  def flatten; end

  # Flatten trailer into the headers.
  #
  # source://protocol-http//lib/protocol/http/headers.rb#72
  def flatten!; end

  # source://protocol-http//lib/protocol/http/headers.rb#120
  def freeze; end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/headers.rb#140
  def include?(key); end

  # source://protocol-http//lib/protocol/http/headers.rb#304
  def inspect; end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/headers.rb#140
  def key?(key); end

  # source://protocol-http//lib/protocol/http/headers.rb#146
  def keys; end

  # source://protocol-http//lib/protocol/http/headers.rb#189
  def merge(headers); end

  # source://protocol-http//lib/protocol/http/headers.rb#181
  def merge!(headers); end

  # Set the specified header key to the specified value, replacing any existing header keys with the same name.
  #
  # @param key [String] the header key to replace.
  # @param value [String] the header value to assign.
  #
  # source://protocol-http//lib/protocol/http/headers.rb#175
  def set(key, value); end

  # A hash table of `{key, policy[key].map(values)}`
  #
  # source://protocol-http//lib/protocol/http/headers.rb#294
  def to_h; end

  # Enumerate all headers in the trailer, if there are any.
  #
  # source://protocol-http//lib/protocol/http/headers.rb#112
  def trailer(&block); end

  # Record the current headers, and prepare to add trailers.
  #
  # This method is typically used after headers are sent to capture any
  # additional headers which should then be sent as trailers.
  #
  # A sender that intends to generate one or more trailer fields in a
  # message should generate a trailer header field in the header section of
  # that message to indicate which fields might be present in the trailers.
  #
  # source://protocol-http//lib/protocol/http/headers.rb#105
  def trailer!(&block); end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/headers.rb#89
  def trailer?; end

  protected

  # source://protocol-http//lib/protocol/http/headers.rb#276
  def merge_into(hash, key, value); end

  private

  # source://protocol-http//lib/protocol/http/headers.rb#58
  def initialize_dup(other); end

  class << self
    # Construct an instance from a headers Array or Hash. No-op if already an instance of `Headers`. If the underlying array is frozen, it will be duped.
    #
    # @return [Headers] an instance of headers.
    #
    # source://protocol-http//lib/protocol/http/headers.rb#28
    def [](headers); end
  end
end

# Used for merging objects into a sequential list of headers. Normalizes header keys and values.
#
# source://protocol-http//lib/protocol/http/headers.rb#320
class Protocol::HTTP::Headers::Merged
  include ::Enumerable

  # @return [Merged] a new instance of Merged
  #
  # source://protocol-http//lib/protocol/http/headers.rb#323
  def initialize(*all); end

  # source://protocol-http//lib/protocol/http/headers.rb#339
  def <<(headers); end

  # source://protocol-http//lib/protocol/http/headers.rb#335
  def clear; end

  # source://protocol-http//lib/protocol/http/headers.rb#346
  def each(&block); end

  # source://protocol-http//lib/protocol/http/headers.rb#327
  def fields; end

  # source://protocol-http//lib/protocol/http/headers.rb#331
  def flatten; end
end

# source://protocol-http//lib/protocol/http/headers.rb#22
Protocol::HTTP::Headers::Multiple = Protocol::HTTP::Header::Multiple

# source://protocol-http//lib/protocol/http/headers.rb#204
Protocol::HTTP::Headers::POLICY = T.let(T.unsafe(nil), Hash)

# source://protocol-http//lib/protocol/http/headers.rb#21
Protocol::HTTP::Headers::Split = Protocol::HTTP::Header::Split

# source://protocol-http//lib/protocol/http/headers.rb#24
Protocol::HTTP::Headers::TRAILER = T.let(T.unsafe(nil), String)

# Provides a convenient interface for commonly supported HTTP methods.
#
# | Method Name | Request Body | Response Body | Safe | Idempotent | Cacheable |
# | ----------- | ------------ | ------------- | ---- | ---------- | --------- |
# | GET         | Optional     | Yes           | Yes  | Yes        | Yes       |
# | HEAD        | Optional     | No            | Yes  | Yes        | Yes       |
# | POST        | Yes          | Yes           | No   | No         | Yes       |
# | PUT         | Yes          | Yes           | No   | Yes        | No        |
# | DELETE      | Optional     | Yes           | No   | Yes        | No        |
# | CONNECT     | Optional     | Yes           | No   | No         | No        |
# | OPTIONS     | Optional     | Yes           | Yes  | Yes        | No        |
# | TRACE       | No           | Yes           | Yes  | Yes        | No        |
# | PATCH       | Yes          | Yes           | No   | No         | No        |
#
# These methods are defined in this module using lower case names. They are for convenience only and you should not overload those methods.
#
# See <https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods> for more details.
#
# source://protocol-http//lib/protocol/http/methods.rb#25
class Protocol::HTTP::Methods
  # source://protocol-http//lib/protocol/http/methods.rb#73
  def connect(location, headers = T.unsafe(nil), body = T.unsafe(nil)); end

  # source://protocol-http//lib/protocol/http/methods.rb#73
  def delete(location, headers = T.unsafe(nil), body = T.unsafe(nil)); end

  # source://protocol-http//lib/protocol/http/methods.rb#73
  def get(location, headers = T.unsafe(nil), body = T.unsafe(nil)); end

  # source://protocol-http//lib/protocol/http/methods.rb#73
  def head(location, headers = T.unsafe(nil), body = T.unsafe(nil)); end

  # source://protocol-http//lib/protocol/http/methods.rb#73
  def options(location, headers = T.unsafe(nil), body = T.unsafe(nil)); end

  # source://protocol-http//lib/protocol/http/methods.rb#73
  def patch(location, headers = T.unsafe(nil), body = T.unsafe(nil)); end

  # source://protocol-http//lib/protocol/http/methods.rb#73
  def post(location, headers = T.unsafe(nil), body = T.unsafe(nil)); end

  # source://protocol-http//lib/protocol/http/methods.rb#73
  def put(location, headers = T.unsafe(nil), body = T.unsafe(nil)); end

  # source://protocol-http//lib/protocol/http/methods.rb#73
  def trace(location, headers = T.unsafe(nil), body = T.unsafe(nil)); end

  class << self
    # Enumerate all HTTP methods.
    #
    # source://protocol-http//lib/protocol/http/methods.rb#64
    def each; end

    # @return [Boolean]
    #
    # source://protocol-http//lib/protocol/http/methods.rb#53
    def valid?(name); end
  end
end

# The CONNECT method establishes a tunnel to the server identified by the target resource.
#
# source://protocol-http//lib/protocol/http/methods.rb#42
Protocol::HTTP::Methods::CONNECT = T.let(T.unsafe(nil), String)

# The DELETE method deletes the specified resource.
#
# source://protocol-http//lib/protocol/http/methods.rb#39
Protocol::HTTP::Methods::DELETE = T.let(T.unsafe(nil), String)

# The GET method requests a representation of the specified resource. Requests using GET should only retrieve data.
#
# source://protocol-http//lib/protocol/http/methods.rb#27
Protocol::HTTP::Methods::GET = T.let(T.unsafe(nil), String)

# The HEAD method asks for a response identical to a GET request, but without the response body.
#
# source://protocol-http//lib/protocol/http/methods.rb#30
Protocol::HTTP::Methods::HEAD = T.let(T.unsafe(nil), String)

# The OPTIONS method describes the communication options for the target resource.
#
# source://protocol-http//lib/protocol/http/methods.rb#45
Protocol::HTTP::Methods::OPTIONS = T.let(T.unsafe(nil), String)

# The PATCH method applies partial modifications to a resource.
#
# source://protocol-http//lib/protocol/http/methods.rb#51
Protocol::HTTP::Methods::PATCH = T.let(T.unsafe(nil), String)

# The POST method submits an entity to the specified resource, often causing a change in state or side effects on the server.
#
# source://protocol-http//lib/protocol/http/methods.rb#33
Protocol::HTTP::Methods::POST = T.let(T.unsafe(nil), String)

# The PUT method replaces all current representations of the target resource with the request payload.
#
# source://protocol-http//lib/protocol/http/methods.rb#36
Protocol::HTTP::Methods::PUT = T.let(T.unsafe(nil), String)

# The TRACE method performs a message loop-back test along the path to the target resource.
#
# source://protocol-http//lib/protocol/http/methods.rb#48
Protocol::HTTP::Methods::TRACE = T.let(T.unsafe(nil), String)

# Represents an HTTP request which can be used both server and client-side.
#
# ~~~ ruby
# require 'protocol/http'
#
# # Long form:
# Protocol::HTTP::Request.new("http", "example.com", "GET", "/index.html", "HTTP/1.1", Protocol::HTTP::Headers[["accept", "text/html"]])
#
# # Short form:
# Protocol::HTTP::Request["GET", "/index.html", {"accept" => "text/html"}]
# ~~~
#
# source://protocol-http//lib/protocol/http/request.rb#25
class Protocol::HTTP::Request
  include ::Protocol::HTTP::Body::Reader

  # @return [Request] a new instance of Request
  #
  # source://protocol-http//lib/protocol/http/request.rb#28
  def initialize(scheme = T.unsafe(nil), authority = T.unsafe(nil), method = T.unsafe(nil), path = T.unsafe(nil), version = T.unsafe(nil), headers = T.unsafe(nil), body = T.unsafe(nil), protocol = T.unsafe(nil)); end

  # source://protocol-http//lib/protocol/http/request.rb#96
  def as_json(*_arg0, **_arg1, &_arg2); end

  # Returns the value of attribute authority.
  #
  # source://protocol-http//lib/protocol/http/request.rb#43
  def authority; end

  # Sets the attribute authority
  #
  # @param value the value to set the attribute authority to.
  #
  # source://protocol-http//lib/protocol/http/request.rb#43
  def authority=(_arg0); end

  # Returns the value of attribute body.
  #
  # source://protocol-http//lib/protocol/http/request.rb#58
  def body; end

  # Sets the attribute body
  #
  # @param value the value to set the attribute body to.
  #
  # source://protocol-http//lib/protocol/http/request.rb#58
  def body=(_arg0); end

  # Send the request to the given connection.
  #
  # source://protocol-http//lib/protocol/http/request.rb#64
  def call(connection); end

  # Whether this is a CONNECT request: typically used to establish a tunnel.
  #
  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/request.rb#74
  def connect?; end

  # Whether this is a HEAD request: no body is expected in the response.
  #
  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/request.rb#69
  def head?; end

  # Returns the value of attribute headers.
  #
  # source://protocol-http//lib/protocol/http/request.rb#55
  def headers; end

  # Sets the attribute headers
  #
  # @param value the value to set the attribute headers to.
  #
  # source://protocol-http//lib/protocol/http/request.rb#55
  def headers=(_arg0); end

  # Whether the request can be replayed without side-effects.
  #
  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/request.rb#92
  def idempotent?; end

  # Returns the value of attribute method.
  #
  # source://protocol-http//lib/protocol/http/request.rb#46
  def method; end

  # Sets the attribute method
  #
  # @param value the value to set the attribute method to.
  #
  # source://protocol-http//lib/protocol/http/request.rb#46
  def method=(_arg0); end

  # Returns the value of attribute path.
  #
  # source://protocol-http//lib/protocol/http/request.rb#49
  def path; end

  # Sets the attribute path
  #
  # @param value the value to set the attribute path to.
  #
  # source://protocol-http//lib/protocol/http/request.rb#49
  def path=(_arg0); end

  # Returns the value of attribute protocol.
  #
  # source://protocol-http//lib/protocol/http/request.rb#61
  def protocol; end

  # Sets the attribute protocol
  #
  # @param value the value to set the attribute protocol to.
  #
  # source://protocol-http//lib/protocol/http/request.rb#61
  def protocol=(_arg0); end

  # Returns the value of attribute scheme.
  #
  # source://protocol-http//lib/protocol/http/request.rb#40
  def scheme; end

  # Sets the attribute scheme
  #
  # @param value the value to set the attribute scheme to.
  #
  # source://protocol-http//lib/protocol/http/request.rb#40
  def scheme=(_arg0); end

  # source://protocol-http//lib/protocol/http/request.rb#109
  def to_json(*_arg0, **_arg1, &_arg2); end

  # source://protocol-http//lib/protocol/http/request.rb#113
  def to_s; end

  # Returns the value of attribute version.
  #
  # source://protocol-http//lib/protocol/http/request.rb#52
  def version; end

  # Sets the attribute version
  #
  # @param value the value to set the attribute version to.
  #
  # source://protocol-http//lib/protocol/http/request.rb#52
  def version=(_arg0); end

  class << self
    # A short-cut method which exposes the main request variables that you'd typically care about.
    #
    # source://protocol-http//lib/protocol/http/request.rb#84
    def [](method, path, headers = T.unsafe(nil), body = T.unsafe(nil)); end
  end
end

# Represents an HTTP response which can be used both server and client-side.
#
# ~~~ ruby
# require 'protocol/http'
#
# # Long form:
# Protocol::HTTP::Response.new("http/1.1", 200, Protocol::HTTP::Headers[["content-type", "text/html"]], Protocol::HTTP::Body::Buffered.wrap("Hello, World!"))
#
# # Short form:
# Protocol::HTTP::Response[200, {"content-type" => "text/html"}, ["Hello, World!"]]
# ~~~
#
# source://protocol-http//lib/protocol/http/response.rb#22
class Protocol::HTTP::Response
  include ::Protocol::HTTP::Body::Reader

  # Create a new response.
  #
  # @return [Response] a new instance of Response
  #
  # source://protocol-http//lib/protocol/http/response.rb#32
  def initialize(version = T.unsafe(nil), status = T.unsafe(nil), headers = T.unsafe(nil), body = T.unsafe(nil), protocol = T.unsafe(nil)); end

  # source://protocol-http//lib/protocol/http/response.rb#147
  def as_json(*_arg0, **_arg1, &_arg2); end

  # Whether the status is 400 (bad request).
  #
  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/response.rb#112
  def bad_request?; end

  # Returns the value of attribute body.
  #
  # source://protocol-http//lib/protocol/http/response.rb#50
  def body; end

  # Sets the attribute body
  #
  # @param value the value to set the attribute body to.
  #
  # source://protocol-http//lib/protocol/http/response.rb#50
  def body=(_arg0); end

  # Whether the status is 100 (continue).
  #
  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/response.rb#61
  def continue?; end

  # Whether the status is considered a failure.
  #
  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/response.rb#107
  def failure?; end

  # Whether the status is considered final. Note that 101 is considered final.
  #
  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/response.rb#71
  def final?; end

  # Returns the value of attribute headers.
  #
  # source://protocol-http//lib/protocol/http/response.rb#47
  def headers; end

  # Sets the attribute headers
  #
  # @param value the value to set the attribute headers to.
  #
  # source://protocol-http//lib/protocol/http/response.rb#47
  def headers=(_arg0); end

  # Whether the response is considered a hijack: the connection has been taken over by the application and the server should not send any more data.
  #
  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/response.rb#56
  def hijack?; end

  # Whether the status is considered informational.
  #
  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/response.rb#66
  def informational?; end

  # Whether the status is 500 (internal server error).
  #
  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/response.rb#117
  def internal_server_error?; end

  # Whether the status is 304 (not modified).
  #
  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/response.rb#97
  def not_modified?; end

  # Whether the status is 200 (ok).
  #
  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/response.rb#77
  def ok?; end

  # Whether the status is 206 (partial content).
  #
  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/response.rb#87
  def partial?; end

  # Whether the status is 307 (temporary redirect) and should preserve the method of the request when following the redirect.
  #
  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/response.rb#102
  def preserve_method?; end

  # Returns the value of attribute protocol.
  #
  # source://protocol-http//lib/protocol/http/response.rb#53
  def protocol; end

  # Sets the attribute protocol
  #
  # @param value the value to set the attribute protocol to.
  #
  # source://protocol-http//lib/protocol/http/response.rb#53
  def protocol=(_arg0); end

  # Whether the status is considered a redirection.
  #
  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/response.rb#92
  def redirection?; end

  # Whether the status is 500 (internal server error).
  #
  # @deprecated Use {#internal_server_error?} instead.
  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/response.rb#117
  def server_failure?; end

  # Returns the value of attribute status.
  #
  # source://protocol-http//lib/protocol/http/response.rb#44
  def status; end

  # Sets the attribute status
  #
  # @param value the value to set the attribute status to.
  #
  # source://protocol-http//lib/protocol/http/response.rb#44
  def status=(_arg0); end

  # Whether the status is considered successful.
  #
  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/response.rb#82
  def success?; end

  # source://protocol-http//lib/protocol/http/response.rb#165
  def to_ary; end

  # source://protocol-http//lib/protocol/http/response.rb#157
  def to_json(*_arg0, **_arg1, &_arg2); end

  # source://protocol-http//lib/protocol/http/response.rb#161
  def to_s; end

  # Returns the value of attribute version.
  #
  # source://protocol-http//lib/protocol/http/response.rb#41
  def version; end

  # Sets the attribute version
  #
  # @param value the value to set the attribute version to.
  #
  # source://protocol-http//lib/protocol/http/response.rb#41
  def version=(_arg0); end

  class << self
    # A short-cut method which exposes the main response variables that you'd typically care about. It follows the same order as the `Rack` response tuple, but also includes the protocol.
    #
    # ~~~ ruby
    # 	Response[200, {"content-type" => "text/html"}, ["Hello, World!"]]
    # ~~~
    #
    # source://protocol-http//lib/protocol/http/response.rb#133
    def [](status, headers = T.unsafe(nil), body = T.unsafe(nil), protocol = T.unsafe(nil)); end

    # Create a response for the given exception.
    #
    # source://protocol-http//lib/protocol/http/response.rb#143
    def for_exception(exception); end
  end
end

# source://protocol-http//lib/protocol/http/url.rb#9
module Protocol::HTTP::URL
  class << self
    # Assign a value to a nested hash.
    #
    # source://protocol-http//lib/protocol/http/url.rb#77
    def assign(keys, value, parent); end

    # TODO use native C extension from `Trenni::Reference`.
    #
    # source://protocol-http//lib/protocol/http/url.rb#98
    def decode(string, maximum = T.unsafe(nil), symbolize_keys: T.unsafe(nil)); end

    # Encodes a hash or array into a query string.
    #
    # source://protocol-http//lib/protocol/http/url.rb#36
    def encode(value, prefix = T.unsafe(nil)); end

    # Escapes a string using percent encoding.
    #
    # source://protocol-http//lib/protocol/http/url.rb#11
    def escape(string, encoding = T.unsafe(nil)); end

    # Escapes non-path characters using percent encoding.
    #
    # source://protocol-http//lib/protocol/http/url.rb#28
    def escape_path(path); end

    # Scan a string for URL-encoded key/value pairs.
    #
    # source://protocol-http//lib/protocol/http/url.rb#59
    def scan(string); end

    # source://protocol-http//lib/protocol/http/url.rb#69
    def split(name); end

    # Unescapes a percent encoded string.
    #
    # source://protocol-http//lib/protocol/http/url.rb#18
    def unescape(string, encoding = T.unsafe(nil)); end
  end
end

# According to https://tools.ietf.org/html/rfc3986#section-3.3, we escape non-pchar.
#
# source://protocol-http//lib/protocol/http/url.rb#25
Protocol::HTTP::URL::NON_PCHAR = T.let(T.unsafe(nil), Regexp)
