# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `protocol-http2` gem.
# Please instead update this file by running `bin/tapioca sync`.

# typed: true

module Protocol
end

module Protocol::HTTP2
end

Protocol::HTTP2::ACKNOWLEDGEMENT = T.let(T.unsafe(nil), Integer)

module Protocol::HTTP2::Acknowledgement
  def acknowledge; end
  def acknowledgement?; end
end

Protocol::HTTP2::CANCEL = T.let(T.unsafe(nil), Integer)

Protocol::HTTP2::COMPRESSION_ERROR = T.let(T.unsafe(nil), Integer)

Protocol::HTTP2::CONNECTION_PREFACE_MAGIC = T.let(T.unsafe(nil), String)

Protocol::HTTP2::CONNECT_ERROR = T.let(T.unsafe(nil), Integer)

class Protocol::HTTP2::Client < ::Protocol::HTTP2::Connection
  def initialize(framer); end

  def create_push_promise_stream; end
  def local_stream_id?(id); end
  def receive_push_promise(frame); end
  def remote_stream_id?(id); end
  def send_connection_preface(settings = T.unsafe(nil)); end
  def valid_remote_stream_id?(stream_id); end
end

class Protocol::HTTP2::Connection
  include(::Protocol::HTTP2::FlowControlled)

  def initialize(framer, local_stream_id); end

  def [](id); end
  def accept_push_promise_stream(stream_id, &block); end
  def accept_stream(stream_id, &block); end
  def client_stream_id?(id); end
  def close(error = T.unsafe(nil)); end
  def close!; end
  def closed?; end
  def closed_stream_id?(id); end
  def consume_window(size = T.unsafe(nil)); end
  def create_push_promise_stream(&block); end
  def create_stream(id = T.unsafe(nil), &block); end
  def decode_headers(data); end
  def delete(id); end
  def dependencies; end
  def dependency; end
  def encode_headers(headers, buffer = T.unsafe(nil)); end
  def framer; end
  def id; end
  def idle_stream_id?(id); end
  def ignore_frame?(frame); end
  def local_settings; end
  def local_settings=(_arg0); end
  def local_window; end
  def maximum_concurrent_streams; end
  def maximum_frame_size; end
  def next_stream_id; end
  def open!; end
  def process_settings(frame); end
  def read_frame; end
  def receive_continuation(frame); end
  def receive_data(frame); end
  def receive_frame(frame); end
  def receive_goaway(frame); end
  def receive_headers(frame); end
  def receive_ping(frame); end
  def receive_priority(frame); end
  def receive_push_promise(frame); end
  def receive_reset_stream(frame); end
  def receive_settings(frame); end
  def receive_window_update(frame); end
  def remote_settings; end
  def remote_settings=(_arg0); end
  def remote_stream_id; end
  def remote_window; end
  def send_goaway(error_code = T.unsafe(nil), message = T.unsafe(nil)); end
  def send_ping(data); end
  def send_priority(stream_id, priority); end
  def send_settings(changes); end
  def server_stream_id?(id); end
  def state; end
  def state=(_arg0); end
  def streams; end
  def update_local_settings(changes); end
  def update_remote_settings(changes); end
  def valid_remote_stream_id?; end
  def write_frame(frame); end
  def write_frames; end
end

class Protocol::HTTP2::ContinuationFrame < ::Protocol::HTTP2::Frame
  include(::Protocol::HTTP2::Continued)

  def apply(connection); end
  def inspect; end
end

Protocol::HTTP2::ContinuationFrame::TYPE = T.let(T.unsafe(nil), Integer)

module Protocol::HTTP2::Continued
  def initialize(*_arg0); end

  def continuation; end
  def continuation=(_arg0); end
  def end_headers?; end
  def pack(data, **options); end
  def read(stream, maximum_frame_size); end
  def unpack; end
  def write(stream); end
end

Protocol::HTTP2::DEFAULT_WEIGHT = T.let(T.unsafe(nil), Integer)

class Protocol::HTTP2::DataFrame < ::Protocol::HTTP2::Frame
  include(::Protocol::HTTP2::Padded)

  def apply(connection); end
  def end_stream?; end
  def inspect; end
  def pack(data, *arguments, **options); end
end

Protocol::HTTP2::DataFrame::TYPE = T.let(T.unsafe(nil), Integer)

class Protocol::HTTP2::Dependency
  def initialize(connection, id, weight = T.unsafe(nil)); end

  def <=>(other); end
  def add_child(dependency); end
  def children; end
  def children=(_arg0); end
  def clear_cache!; end
  def connection; end
  def consume_window(size); end
  def delete!; end
  def exclusive_child(parent); end
  def id; end
  def ordered_children; end
  def parent; end
  def parent=(_arg0); end
  def print_hierarchy(buffer, indent: T.unsafe(nil)); end
  def priority(exclusive = T.unsafe(nil)); end
  def priority=(priority); end
  def process_priority(priority); end
  def receive_priority(frame); end
  def remove_child(dependency); end
  def send_priority(priority); end
  def stream; end
  def to_s; end
  def total_weight; end
  def weight; end
  def weight=(_arg0); end

  class << self
    def create(connection, id, priority = T.unsafe(nil)); end
  end
end

Protocol::HTTP2::END_HEADERS = T.let(T.unsafe(nil), Integer)

Protocol::HTTP2::END_STREAM = T.let(T.unsafe(nil), Integer)

Protocol::HTTP2::ENHANCE_YOUR_CALM = T.let(T.unsafe(nil), Integer)

class Protocol::HTTP2::Error < ::Protocol::HTTP::Error
end

Protocol::HTTP2::Error::CANCEL = T.let(T.unsafe(nil), Integer)

Protocol::HTTP2::Error::COMPRESSION_ERROR = T.let(T.unsafe(nil), Integer)

Protocol::HTTP2::Error::CONNECT_ERROR = T.let(T.unsafe(nil), Integer)

Protocol::HTTP2::Error::ENHANCE_YOUR_CALM = T.let(T.unsafe(nil), Integer)

Protocol::HTTP2::Error::FLOW_CONTROL_ERROR = T.let(T.unsafe(nil), Integer)

Protocol::HTTP2::Error::FRAME_SIZE_ERROR = T.let(T.unsafe(nil), Integer)

Protocol::HTTP2::Error::HTTP_1_1_REQUIRED = T.let(T.unsafe(nil), Integer)

Protocol::HTTP2::Error::INADEQUATE_SECURITY = T.let(T.unsafe(nil), Integer)

Protocol::HTTP2::Error::INTERNAL_ERROR = T.let(T.unsafe(nil), Integer)

Protocol::HTTP2::Error::NO_ERROR = T.let(T.unsafe(nil), Integer)

Protocol::HTTP2::Error::PROTOCOL_ERROR = T.let(T.unsafe(nil), Integer)

Protocol::HTTP2::Error::REFUSED_STREAM = T.let(T.unsafe(nil), Integer)

Protocol::HTTP2::Error::SETTINGS_TIMEOUT = T.let(T.unsafe(nil), Integer)

Protocol::HTTP2::Error::STREAM_CLOSED = T.let(T.unsafe(nil), Integer)

Protocol::HTTP2::FLOW_CONTROL_ERROR = T.let(T.unsafe(nil), Integer)

Protocol::HTTP2::FRAMES = T.let(T.unsafe(nil), Array)

Protocol::HTTP2::FRAME_SIZE_ERROR = T.let(T.unsafe(nil), Integer)

class Protocol::HTTP2::FlowControlError < ::Protocol::HTTP2::ProtocolError
  def initialize(message); end
end

module Protocol::HTTP2::FlowControlled
  def available_frame_size(maximum_frame_size = T.unsafe(nil)); end
  def available_size; end
  def consume_local_window(frame); end
  def consume_remote_window(frame); end
  def receive_window_update(frame); end
  def request_window_update; end
  def send_window_update(window_increment); end
  def update_local_window(frame); end
  def window_updated(size); end
end

class Protocol::HTTP2::Frame
  include(::Comparable)

  def initialize(stream_id = T.unsafe(nil), flags = T.unsafe(nil), type = T.unsafe(nil), length = T.unsafe(nil), payload = T.unsafe(nil)); end

  def <=>(other); end
  def apply(connection); end
  def clear_flags(mask); end
  def connection?; end
  def flag_set?(mask); end
  def flags; end
  def flags=(_arg0); end
  def header; end
  def inspect; end
  def length; end
  def length=(_arg0); end
  def pack(payload, maximum_size: T.unsafe(nil)); end
  def payload; end
  def payload=(_arg0); end
  def read(stream, maximum_frame_size = T.unsafe(nil)); end
  def read_header(stream); end
  def read_payload(stream); end
  def set_flags(mask); end
  def stream_id; end
  def stream_id=(_arg0); end
  def to_ary; end
  def type; end
  def type=(_arg0); end
  def unpack; end
  def valid_type?; end
  def write(stream); end
  def write_header(stream); end
  def write_payload(stream); end

  class << self
    def parse_header(buffer); end
  end
end

Protocol::HTTP2::Frame::HEADER_FORMAT = T.let(T.unsafe(nil), String)

Protocol::HTTP2::Frame::LENGTH_HISHIFT = T.let(T.unsafe(nil), Integer)

Protocol::HTTP2::Frame::LENGTH_LOMASK = T.let(T.unsafe(nil), Integer)

Protocol::HTTP2::Frame::STREAM_ID_MASK = T.let(T.unsafe(nil), Integer)

Protocol::HTTP2::Frame::VALID_LENGTH = T.let(T.unsafe(nil), Range)

Protocol::HTTP2::Frame::VALID_STREAM_ID = T.let(T.unsafe(nil), Range)

class Protocol::HTTP2::FrameSizeError < ::Protocol::HTTP2::ProtocolError
  def initialize(message); end
end

class Protocol::HTTP2::Framer
  def initialize(stream, frames = T.unsafe(nil)); end

  def close; end
  def closed?; end
  def read_connection_preface; end
  def read_frame(maximum_frame_size = T.unsafe(nil)); end
  def read_header; end
  def write_connection_preface; end
  def write_frame(frame); end
end

class Protocol::HTTP2::GoawayError < ::Protocol::HTTP2::ProtocolError
end

class Protocol::HTTP2::GoawayFrame < ::Protocol::HTTP2::Frame
  def apply(connection); end
  def connection?; end
  def pack(last_stream_id, error_code, data); end
  def unpack; end
end

Protocol::HTTP2::GoawayFrame::FORMAT = T.let(T.unsafe(nil), String)

Protocol::HTTP2::GoawayFrame::TYPE = T.let(T.unsafe(nil), Integer)

Protocol::HTTP2::HTTP_1_1_REQUIRED = T.let(T.unsafe(nil), Integer)

class Protocol::HTTP2::HandshakeError < ::Protocol::HTTP2::Error
end

class Protocol::HTTP2::HeaderError < ::Protocol::HTTP2::StreamClosed
  def initialize(message); end
end

class Protocol::HTTP2::HeadersFrame < ::Protocol::HTTP2::Frame
  include(::Protocol::HTTP2::Padded)
  include(::Protocol::HTTP2::Continued)

  def apply(connection); end
  def end_stream?; end
  def inspect; end
  def pack(priority, data, *arguments, **options); end
  def priority?; end
  def unpack; end
end

Protocol::HTTP2::HeadersFrame::TYPE = T.let(T.unsafe(nil), Integer)

Protocol::HTTP2::INADEQUATE_SECURITY = T.let(T.unsafe(nil), Integer)

Protocol::HTTP2::INTERNAL_ERROR = T.let(T.unsafe(nil), Integer)

class Protocol::HTTP2::LocalWindow < ::Protocol::HTTP2::Window
  def initialize(capacity = T.unsafe(nil), desired: T.unsafe(nil)); end

  def desired; end
  def desired=(_arg0); end
  def limited?; end
  def wanted; end
end

Protocol::HTTP2::MAXIMUM_ALLOWED_FRAME_SIZE = T.let(T.unsafe(nil), Integer)

Protocol::HTTP2::MAXIMUM_ALLOWED_WINDOW_SIZE = T.let(T.unsafe(nil), Integer)

Protocol::HTTP2::MINIMUM_ALLOWED_FRAME_SIZE = T.let(T.unsafe(nil), Integer)

Protocol::HTTP2::NO_ERROR = T.let(T.unsafe(nil), Integer)

Protocol::HTTP2::PADDED = T.let(T.unsafe(nil), Integer)

Protocol::HTTP2::PRIORITY = T.let(T.unsafe(nil), Integer)

Protocol::HTTP2::PROTOCOL_ERROR = T.let(T.unsafe(nil), Integer)

module Protocol::HTTP2::Padded
  def pack(data, padding_size: T.unsafe(nil), maximum_size: T.unsafe(nil)); end
  def padded?; end
  def unpack; end
end

class Protocol::HTTP2::PendingSettings
  def initialize(current = T.unsafe(nil)); end

  def acknowledge; end
  def append(changes); end
  def current; end
  def enable_push; end
  def header_table_size; end
  def initial_window_size; end
  def maximum_concurrent_streams; end
  def maximum_frame_size; end
  def maximum_header_list_size; end
  def pending; end
end

class Protocol::HTTP2::PingFrame < ::Protocol::HTTP2::Frame
  include(::Protocol::HTTP2::Acknowledgement)

  def acknowledge; end
  def apply(connection); end
  def connection?; end
  def read_payload(stream); end
end

Protocol::HTTP2::PingFrame::TYPE = T.let(T.unsafe(nil), Integer)

class Protocol::HTTP2::Priority < ::Struct
  def pack; end
  def weight=(value); end

  class << self
    def default(stream_dependency = T.unsafe(nil), weight = T.unsafe(nil)); end
    def unpack(data); end
  end
end

Protocol::HTTP2::Priority::EXCLUSIVE = T.let(T.unsafe(nil), Integer)

Protocol::HTTP2::Priority::FORMAT = T.let(T.unsafe(nil), String)

class Protocol::HTTP2::PriorityFrame < ::Protocol::HTTP2::Frame
  def apply(connection); end
  def pack(priority); end
  def priority; end
  def read_payload(stream); end
  def unpack; end
end

Protocol::HTTP2::PriorityFrame::TYPE = T.let(T.unsafe(nil), Integer)

class Protocol::HTTP2::ProtocolError < ::Protocol::HTTP2::Error
  def initialize(message, code = T.unsafe(nil)); end

  def code; end
end

class Protocol::HTTP2::PushPromiseFrame < ::Protocol::HTTP2::Frame
  include(::Protocol::HTTP2::Padded)
  include(::Protocol::HTTP2::Continued)

  def apply(connection); end
  def pack(stream_id, data, *arguments, **options); end
  def unpack; end
end

Protocol::HTTP2::PushPromiseFrame::FORMAT = T.let(T.unsafe(nil), String)

Protocol::HTTP2::PushPromiseFrame::TYPE = T.let(T.unsafe(nil), Integer)

Protocol::HTTP2::REFUSED_STREAM = T.let(T.unsafe(nil), Integer)

class Protocol::HTTP2::ResetStreamFrame < ::Protocol::HTTP2::Frame
  def apply(connection); end
  def pack(error_code = T.unsafe(nil)); end
  def read_payload(stream); end
  def unpack; end
end

Protocol::HTTP2::ResetStreamFrame::FORMAT = T.let(T.unsafe(nil), String)

Protocol::HTTP2::ResetStreamFrame::TYPE = T.let(T.unsafe(nil), Integer)

Protocol::HTTP2::STREAM_CLOSED = T.let(T.unsafe(nil), Integer)

class Protocol::HTTP2::Server < ::Protocol::HTTP2::Connection
  def initialize(framer); end

  def accept_push_promise_stream(stream_id, &block); end
  def enable_push?; end
  def local_stream_id?(id); end
  def read_connection_preface(settings = T.unsafe(nil)); end
  def remote_stream_id?(id); end
  def valid_remote_stream_id?(stream_id); end
end

class Protocol::HTTP2::Settings
  def initialize; end

  def difference(other); end
  def enable_connect_protocol; end
  def enable_connect_protocol=(value); end
  def enable_connect_protocol?; end
  def enable_push; end
  def enable_push=(value); end
  def enable_push?; end
  def header_table_size; end
  def header_table_size=(_arg0); end
  def initial_window_size; end
  def initial_window_size=(value); end
  def maximum_concurrent_streams; end
  def maximum_concurrent_streams=(_arg0); end
  def maximum_frame_size; end
  def maximum_frame_size=(value); end
  def maximum_header_list_size; end
  def maximum_header_list_size=(_arg0); end
  def update(changes); end
end

Protocol::HTTP2::Settings::ASSIGN = T.let(T.unsafe(nil), Array)

Protocol::HTTP2::Settings::ENABLE_CONNECT_PROTOCOL = T.let(T.unsafe(nil), Integer)

Protocol::HTTP2::Settings::ENABLE_PUSH = T.let(T.unsafe(nil), Integer)

Protocol::HTTP2::Settings::HEADER_TABLE_SIZE = T.let(T.unsafe(nil), Integer)

Protocol::HTTP2::Settings::INITIAL_WINDOW_SIZE = T.let(T.unsafe(nil), Integer)

Protocol::HTTP2::Settings::MAXIMUM_CONCURRENT_STREAMS = T.let(T.unsafe(nil), Integer)

Protocol::HTTP2::Settings::MAXIMUM_FRAME_SIZE = T.let(T.unsafe(nil), Integer)

Protocol::HTTP2::Settings::MAXIMUM_HEADER_LIST_SIZE = T.let(T.unsafe(nil), Integer)

class Protocol::HTTP2::SettingsFrame < ::Protocol::HTTP2::Frame
  include(::Protocol::HTTP2::Acknowledgement)

  def apply(connection); end
  def connection?; end
  def pack(settings = T.unsafe(nil)); end
  def read_payload(stream); end
  def unpack; end
end

Protocol::HTTP2::SettingsFrame::FORMAT = T.let(T.unsafe(nil), String)

Protocol::HTTP2::SettingsFrame::TYPE = T.let(T.unsafe(nil), Integer)

class Protocol::HTTP2::Stream
  include(::Protocol::HTTP2::FlowControlled)

  def initialize(connection, id, state = T.unsafe(nil)); end

  def accept_push_promise_stream(stream_id, headers); end
  def active?; end
  def close(error = T.unsafe(nil)); end
  def close!(error_code = T.unsafe(nil)); end
  def closed(error = T.unsafe(nil)); end
  def closed?; end
  def connection; end
  def consume_remote_window(frame); end
  def create_push_promise_stream(headers); end
  def dependency; end
  def id; end
  def ignore_data(frame); end
  def inspect; end
  def local_window; end
  def maximum_frame_size; end
  def open!; end
  def opened(error = T.unsafe(nil)); end
  def parent=(stream); end
  def priority; end
  def priority=(priority); end
  def process_data(frame); end
  def process_headers(frame); end
  def receive_data(frame); end
  def receive_headers(frame); end
  def receive_push_promise(frame); end
  def receive_reset_stream(frame); end
  def remote_window; end
  def reserved_local!; end
  def reserved_remote!; end
  def send_data(*arguments, **options); end
  def send_headers(*arguments); end
  def send_headers?; end
  def send_push_promise(headers); end
  def send_reset_stream(error_code = T.unsafe(nil)); end
  def state; end
  def state=(_arg0); end
  def to_s; end
  def weight; end
  def write_frame(frame); end

  protected

  def ignore_headers(frame); end

  private

  def write_data(data, flags = T.unsafe(nil), **options); end
  def write_headers(priority, headers, flags = T.unsafe(nil)); end
  def write_push_promise(stream_id, headers, flags = T.unsafe(nil), **options); end

  class << self
    def create(connection, id); end
  end
end

class Protocol::HTTP2::StreamClosed < ::Protocol::HTTP2::StreamError
  def initialize(message); end
end

class Protocol::HTTP2::StreamError < ::Protocol::HTTP2::ProtocolError
end

Protocol::HTTP2::TIMEOUT = T.let(T.unsafe(nil), Integer)

Protocol::HTTP2::VALID_WEIGHT = T.let(T.unsafe(nil), Range)

class Protocol::HTTP2::Window
  def initialize(capacity = T.unsafe(nil)); end

  def available; end
  def available?; end
  def capacity; end
  def capacity=(value); end
  def consume(amount); end
  def expand(amount); end
  def full?; end
  def limited?; end
  def to_s; end
  def used; end
  def wanted; end
end

class Protocol::HTTP2::WindowUpdateFrame < ::Protocol::HTTP2::Frame
  def apply(connection); end
  def pack(window_size_increment); end
  def read_payload(stream); end
  def unpack; end
end

Protocol::HTTP2::WindowUpdateFrame::FORMAT = T.let(T.unsafe(nil), String)

Protocol::HTTP2::WindowUpdateFrame::TYPE = T.let(T.unsafe(nil), Integer)
