# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `protocol-http2` gem.
# Please instead update this file by running `bin/tapioca gem protocol-http2`.

module Protocol; end
module Protocol::HTTP2; end
Protocol::HTTP2::ACKNOWLEDGEMENT = T.let(T.unsafe(nil), Integer)

module Protocol::HTTP2::Acknowledgement
  def acknowledge; end

  # @return [Boolean]
  def acknowledgement?; end
end

Protocol::HTTP2::CANCEL = T.let(T.unsafe(nil), Integer)
Protocol::HTTP2::COMPRESSION_ERROR = T.let(T.unsafe(nil), Integer)

# Default connection "fast-fail" preamble string as defined by the spec.
Protocol::HTTP2::CONNECTION_PREFACE_MAGIC = T.let(T.unsafe(nil), String)

Protocol::HTTP2::CONNECT_ERROR = T.let(T.unsafe(nil), Integer)

class Protocol::HTTP2::Client < ::Protocol::HTTP2::Connection
  # @return [Client] a new instance of Client
  def initialize(framer); end

  # @raise [ProtocolError]
  def create_push_promise_stream; end

  # @return [Boolean]
  def local_stream_id?(id); end

  def receive_push_promise(frame); end

  # @return [Boolean]
  def remote_stream_id?(id); end

  def send_connection_preface(settings = T.unsafe(nil)); end

  # @return [Boolean]
  def valid_remote_stream_id?(stream_id); end
end

class Protocol::HTTP2::Connection
  include ::Protocol::HTTP2::FlowControlled

  # @return [Connection] a new instance of Connection
  def initialize(framer, local_stream_id); end

  def [](id); end

  # Accept an incoming push promise from the other side of the connection.
  # On the client side, we accept push promise streams.
  # On the server side, existing streams create push promise streams.
  def accept_push_promise_stream(stream_id, &block); end

  # Accept an incoming stream from the other side of the connnection.
  # On the server side, we accept requests.
  def accept_stream(stream_id, &block); end

  # @return [Boolean]
  def client_stream_id?(id); end

  # Close the underlying framer and all streams.
  def close(error = T.unsafe(nil)); end

  # Transition the connection into the closed state.
  def close!; end

  # Whether the connection is effectively or actually closed.
  #
  # @return [Boolean]
  def closed?; end

  # @return [Boolean]
  def closed_stream_id?(id); end

  # Traverse active streams in order of priority and allow them to consume the available flow-control window.
  #
  # @param amount [Integer] the amount of data to write. Defaults to the current window capacity.
  def consume_window(size = T.unsafe(nil)); end

  def create_push_promise_stream(&block); end

  # Create a stream, defaults to an outgoing stream.
  # On the client side, we create requests.
  #
  # @return [Stream] the created stream.
  def create_stream(id = T.unsafe(nil), &block); end

  def decode_headers(data); end
  def delete(id); end

  # Returns the value of attribute dependencies.
  def dependencies; end

  # Returns the value of attribute dependency.
  def dependency; end

  def encode_headers(headers, buffer = T.unsafe(nil)); end

  # Returns the value of attribute framer.
  def framer; end

  def id; end

  # @return [Boolean]
  def idle_stream_id?(id); end

  # 6.8. GOAWAY
  # There is an inherent race condition between an endpoint starting new streams and the remote sending a GOAWAY frame. To deal with this case, the GOAWAY contains the stream identifier of the last peer-initiated stream that was or might be processed on the sending endpoint in this connection. For instance, if the server sends a GOAWAY frame, the identified stream is the highest-numbered stream initiated by the client.
  # Once sent, the sender will ignore frames sent on streams initiated by the receiver if the stream has an identifier higher than the included last stream identifier. Receivers of a GOAWAY frame MUST NOT open additional streams on the connection, although a new connection can be established for new streams.
  #
  # @return [Boolean]
  def ignore_frame?(frame); end

  # Current settings value for local and peer
  def local_settings; end

  # Current settings value for local and peer
  def local_settings=(_arg0); end

  # Our window for receiving data. When we receive data, it reduces this window.
  # If the window gets too small, we must send a window update.
  def local_window; end

  def maximum_concurrent_streams; end

  # The size of a frame payload is limited by the maximum size that a receiver advertises in the SETTINGS_MAX_FRAME_SIZE setting.
  def maximum_frame_size; end

  # Streams are identified with an unsigned 31-bit integer.  Streams initiated by a client MUST use odd-numbered stream identifiers; those initiated by the server MUST use even-numbered stream identifiers.  A stream identifier of zero (0x0) is used for connection control messages; the stream identifier of zero cannot be used to establish a new stream.
  def next_stream_id; end

  def open!; end

  # In addition to changing the flow-control window for streams that are not yet active, a SETTINGS frame can alter the initial flow-control window size for streams with active flow-control windows (that is, streams in the "open" or "half-closed (remote)" state).  When the value of SETTINGS_INITIAL_WINDOW_SIZE changes, a receiver MUST adjust the size of all stream flow-control windows that it maintains by the difference between the new value and the old value.
  #
  # @return [Boolean] whether the frame was an acknowledgement
  def process_settings(frame); end

  # Reads one frame from the network and processes. Processing the frame updates the state of the connection and related streams. If the frame triggers an error, e.g. a protocol error, the connection will typically emit a goaway frame and re-raise the exception. You should continue processing frames until the underlying connection is closed.
  def read_frame; end

  # @raise [ProtocolError]
  def receive_continuation(frame); end

  def receive_data(frame); end
  def receive_frame(frame); end
  def receive_goaway(frame); end

  # On the server side, starts a new request.
  def receive_headers(frame); end

  def receive_ping(frame); end

  # Sets the priority for an incoming stream.
  def receive_priority(frame); end

  # @raise [ProtocolError]
  def receive_push_promise(frame); end

  def receive_reset_stream(frame); end
  def receive_settings(frame); end
  def receive_window_update(frame); end

  # Returns the value of attribute remote_settings.
  def remote_settings; end

  # Sets the attribute remote_settings
  #
  # @param value the value to set the attribute remote_settings to.
  def remote_settings=(_arg0); end

  # The highest stream_id that has been successfully accepted by this connection.
  def remote_stream_id; end

  # Our window for sending data. When we send data, it reduces this window.
  def remote_window; end

  # Tell the remote end that the connection is being shut down. If the `error_code` is 0, this is a graceful shutdown. The other end of the connection should not make any new streams, but existing streams may be completed.
  def send_goaway(error_code = T.unsafe(nil), message = T.unsafe(nil)); end

  def send_ping(data); end
  def send_priority(stream_id, priority); end
  def send_settings(changes); end

  # @return [Boolean]
  def server_stream_id?(id); end

  # Connection state (:new, :open, :closed).
  def state; end

  # Connection state (:new, :open, :closed).
  def state=(_arg0); end

  # Returns the value of attribute streams.
  def streams; end

  def update_local_settings(changes); end
  def update_remote_settings(changes); end

  # @return [Boolean]
  def valid_remote_stream_id?; end

  def write_frame(frame); end

  # @yield [@framer]
  def write_frames; end
end

# The CONTINUATION frame is used to continue a sequence of header block fragments. Any number of CONTINUATION frames can be sent, as long as the preceding frame is on the same stream and is a HEADERS, PUSH_PROMISE, or CONTINUATION frame without the END_HEADERS flag set.
#
# +---------------------------------------------------------------+
# |                   Header Block Fragment (*)                 ...
# +---------------------------------------------------------------+
class Protocol::HTTP2::ContinuationFrame < ::Protocol::HTTP2::Frame
  include ::Protocol::HTTP2::Continued

  # This is only invoked if the continuation is received out of the normal flow.
  def apply(connection); end

  def inspect; end
end

Protocol::HTTP2::ContinuationFrame::TYPE = T.let(T.unsafe(nil), Integer)

module Protocol::HTTP2::Continued
  def initialize(*_arg0); end

  # Returns the value of attribute continuation.
  def continuation; end

  # Sets the attribute continuation
  #
  # @param value the value to set the attribute continuation to.
  def continuation=(_arg0); end

  # @return [Boolean]
  def end_headers?; end

  def pack(data, **options); end
  def read(stream, maximum_frame_size); end
  def unpack; end
  def write(stream); end
end

Protocol::HTTP2::DEFAULT_WEIGHT = T.let(T.unsafe(nil), Integer)

# DATA frames convey arbitrary, variable-length sequences of octets associated with a stream. One or more DATA frames are used, for instance, to carry HTTP request or response payloads.
#
# DATA frames MAY also contain padding. Padding can be added to DATA frames to obscure the size of messages.
#
# +---------------+
# |Pad Length? (8)|
# +---------------+-----------------------------------------------+
# |                            Data (*)                         ...
# +---------------------------------------------------------------+
# |                           Padding (*)                       ...
# +---------------------------------------------------------------+
class Protocol::HTTP2::DataFrame < ::Protocol::HTTP2::Frame
  include ::Protocol::HTTP2::Padded

  def apply(connection); end

  # @return [Boolean]
  def end_stream?; end

  def inspect; end
  def pack(data, *arguments, **options); end
end

Protocol::HTTP2::DataFrame::TYPE = T.let(T.unsafe(nil), Integer)

class Protocol::HTTP2::Dependency
  # @return [Dependency] a new instance of Dependency
  def initialize(connection, id, weight = T.unsafe(nil)); end

  def <=>(other); end
  def add_child(dependency); end

  # The dependent children.
  def children; end

  # The dependent children.
  def children=(_arg0); end

  def clear_cache!; end

  # The connection this stream belongs to.
  def connection; end

  # Traverse active streams in order of priority and allow them to consume the available flow-control window.
  #
  # @param amount [Integer] the amount of data to write. Defaults to the current window capacity.
  def consume_window(size); end

  def delete!; end

  # An exclusive flag allows for the insertion of a new level of dependencies.  The exclusive flag causes the stream to become the sole dependency of its parent stream, causing other dependencies to become dependent on the exclusive stream.
  #
  # @param parent [Dependency] the dependency which will be inserted, taking control of all current children.
  def exclusive_child(parent); end

  # Stream ID (odd for client initiated streams, even otherwise).
  def id; end

  def ordered_children; end

  # The parent dependency.
  def parent; end

  # The parent dependency.
  def parent=(_arg0); end

  def print_hierarchy(buffer, indent: T.unsafe(nil)); end

  # The current local priority of the stream.
  def priority(exclusive = T.unsafe(nil)); end

  # Change the priority of the stream both locally and remotely.
  def priority=(priority); end

  def process_priority(priority); end
  def receive_priority(frame); end
  def remove_child(dependency); end
  def send_priority(priority); end
  def stream; end
  def to_s; end
  def total_weight; end

  # The weight of the stream relative to other siblings.
  def weight; end

  # The weight of the stream relative to other siblings.
  def weight=(_arg0); end

  class << self
    def create(connection, id, priority = T.unsafe(nil)); end
  end
end

Protocol::HTTP2::END_HEADERS = T.let(T.unsafe(nil), Integer)
Protocol::HTTP2::END_STREAM = T.let(T.unsafe(nil), Integer)
Protocol::HTTP2::ENHANCE_YOUR_CALM = T.let(T.unsafe(nil), Integer)

# Status codes as defined by <https://tools.ietf.org/html/rfc7540#section-7>.
class Protocol::HTTP2::Error < ::Protocol::HTTP::Error; end

# Used by the endpoint to indicate that the stream is no longer needed.
Protocol::HTTP2::Error::CANCEL = T.let(T.unsafe(nil), Integer)

# The endpoint is unable to maintain the header compression context for the connection.
Protocol::HTTP2::Error::COMPRESSION_ERROR = T.let(T.unsafe(nil), Integer)

# The connection established in response to a CONNECT request was reset or abnormally closed.
Protocol::HTTP2::Error::CONNECT_ERROR = T.let(T.unsafe(nil), Integer)

# The endpoint detected that its peer is exhibiting a behavior that might be generating excessive load.
Protocol::HTTP2::Error::ENHANCE_YOUR_CALM = T.let(T.unsafe(nil), Integer)

# The endpoint detected that its peer violated the flow-control protocol.
Protocol::HTTP2::Error::FLOW_CONTROL_ERROR = T.let(T.unsafe(nil), Integer)

# The endpoint received a frame with an invalid size.
Protocol::HTTP2::Error::FRAME_SIZE_ERROR = T.let(T.unsafe(nil), Integer)

# The endpoint requires that HTTP/1.1 be used instead of HTTP/2.
Protocol::HTTP2::Error::HTTP_1_1_REQUIRED = T.let(T.unsafe(nil), Integer)

# The underlying transport has properties that do not meet minimum security requirements.
Protocol::HTTP2::Error::INADEQUATE_SECURITY = T.let(T.unsafe(nil), Integer)

# The endpoint encountered an unexpected internal error.
Protocol::HTTP2::Error::INTERNAL_ERROR = T.let(T.unsafe(nil), Integer)

# The associated condition is not a result of an error.  For example, a GOAWAY might include this code to indicate graceful shutdown of a connection.
Protocol::HTTP2::Error::NO_ERROR = T.let(T.unsafe(nil), Integer)

# The endpoint detected an unspecific protocol error.  This error is for use when a more specific error code is not available.
Protocol::HTTP2::Error::PROTOCOL_ERROR = T.let(T.unsafe(nil), Integer)

# The endpoint refused the stream prior to performing any application processing.
Protocol::HTTP2::Error::REFUSED_STREAM = T.let(T.unsafe(nil), Integer)

# The endpoint sent a SETTINGS frame but did not receive a response in a timely manner.
Protocol::HTTP2::Error::SETTINGS_TIMEOUT = T.let(T.unsafe(nil), Integer)

# The endpoint received a frame after a stream was half-closed.
Protocol::HTTP2::Error::STREAM_CLOSED = T.let(T.unsafe(nil), Integer)

Protocol::HTTP2::FLOW_CONTROL_ERROR = T.let(T.unsafe(nil), Integer)

# HTTP/2 frame type mapping as defined by the spec
Protocol::HTTP2::FRAMES = T.let(T.unsafe(nil), Array)

Protocol::HTTP2::FRAME_SIZE_ERROR = T.let(T.unsafe(nil), Integer)

# Raised on invalid flow control frame or command.
class Protocol::HTTP2::FlowControlError < ::Protocol::HTTP2::ProtocolError
  # @return [FlowControlError] a new instance of FlowControlError
  def initialize(message); end
end

module Protocol::HTTP2::FlowControlled
  # This could be negative if the window has been overused due to a change in initial window size.
  def available_frame_size(maximum_frame_size = T.unsafe(nil)); end

  def available_size; end
  def consume_local_window(frame); end

  # Keep track of the amount of data sent, and fail if is too much.
  def consume_remote_window(frame); end

  def receive_window_update(frame); end
  def request_window_update; end

  # Notify the remote end that we are prepared to receive more data:
  def send_window_update(window_increment); end

  def update_local_window(frame); end

  # The window has been expanded by the given amount.
  #
  # @param size [Integer] the maximum amount of data to send.
  # @return [Boolean] whether the window update was used or not.
  def window_updated(size); end
end

class Protocol::HTTP2::Frame
  include ::Comparable

  # @param length [Integer] the length of the payload, or nil if the header has not been read yet.
  # @return [Frame] a new instance of Frame
  def initialize(stream_id = T.unsafe(nil), flags = T.unsafe(nil), type = T.unsafe(nil), length = T.unsafe(nil), payload = T.unsafe(nil)); end

  def <=>(other); end
  def apply(connection); end
  def clear_flags(mask); end

  # Check if frame is a connection frame: SETTINGS, PING, GOAWAY, and any
  # frame addressed to stream ID = 0.
  #
  # @return [Boolean]
  def connection?; end

  # @return [Boolean]
  def flag_set?(mask); end

  # Returns the value of attribute flags.
  def flags; end

  # Sets the attribute flags
  #
  # @param value the value to set the attribute flags to.
  def flags=(_arg0); end

  # Generates common 9-byte frame header.
  # - http://tools.ietf.org/html/draft-ietf-httpbis-http2-16#section-4.1
  #
  # @return [String]
  def header; end

  def inspect; end

  # The generic frame header uses the following binary representation:
  #
  # +-----------------------------------------------+
  # |                 Length (24)                   |
  # +---------------+---------------+---------------+
  # |   Type (8)    |   Flags (8)   |
  # +-+-------------+---------------+-------------------------------+
  # |R|                 Stream Identifier (31)                      |
  # +=+=============================================================+
  # |                   Frame Payload (0...)                      ...
  # +---------------------------------------------------------------+
  def length; end

  # The generic frame header uses the following binary representation:
  #
  # +-----------------------------------------------+
  # |                 Length (24)                   |
  # +---------------+---------------+---------------+
  # |   Type (8)    |   Flags (8)   |
  # +-+-------------+---------------+-------------------------------+
  # |R|                 Stream Identifier (31)                      |
  # +=+=============================================================+
  # |                   Frame Payload (0...)                      ...
  # +---------------------------------------------------------------+
  def length=(_arg0); end

  def pack(payload, maximum_size: T.unsafe(nil)); end

  # Returns the value of attribute payload.
  def payload; end

  # Sets the attribute payload
  #
  # @param value the value to set the attribute payload to.
  def payload=(_arg0); end

  def read(stream, maximum_frame_size = T.unsafe(nil)); end
  def read_header(stream); end
  def read_payload(stream); end
  def set_flags(mask); end

  # Returns the value of attribute stream_id.
  def stream_id; end

  # Sets the attribute stream_id
  #
  # @param value the value to set the attribute stream_id to.
  def stream_id=(_arg0); end

  def to_ary; end

  # Returns the value of attribute type.
  def type; end

  # Sets the attribute type
  #
  # @param value the value to set the attribute type to.
  def type=(_arg0); end

  def unpack; end

  # @return [Boolean]
  def valid_type?; end

  def write(stream); end
  def write_header(stream); end
  def write_payload(stream); end

  class << self
    # Decodes common 9-byte header.
    #
    # @param buffer [String]
    def parse_header(buffer); end
  end
end

Protocol::HTTP2::Frame::HEADER_FORMAT = T.let(T.unsafe(nil), String)

# Used for generating 24-bit frame length:
Protocol::HTTP2::Frame::LENGTH_HISHIFT = T.let(T.unsafe(nil), Integer)

Protocol::HTTP2::Frame::LENGTH_LOMASK = T.let(T.unsafe(nil), Integer)
Protocol::HTTP2::Frame::STREAM_ID_MASK = T.let(T.unsafe(nil), Integer)

# The absolute maximum bounds for the length field:
Protocol::HTTP2::Frame::VALID_LENGTH = T.let(T.unsafe(nil), Range)

# Stream Identifier cannot be bigger than this:
# https://http2.github.stream/http2-spec/#rfc.section.4.1
Protocol::HTTP2::Frame::VALID_STREAM_ID = T.let(T.unsafe(nil), Range)

# When the frame payload does not match expectations.
class Protocol::HTTP2::FrameSizeError < ::Protocol::HTTP2::ProtocolError
  # @return [FrameSizeError] a new instance of FrameSizeError
  def initialize(message); end
end

class Protocol::HTTP2::Framer
  # @return [Framer] a new instance of Framer
  def initialize(stream, frames = T.unsafe(nil)); end

  def close; end

  # @return [Boolean]
  def closed?; end

  def read_connection_preface; end

  # @raise if the underlying IO fails for some reason.
  # @return [Frame] the frame that has been read from the underlying IO.
  def read_frame(maximum_frame_size = T.unsafe(nil)); end

  # @raise [EOFError]
  def read_header; end

  def write_connection_preface; end
  def write_frame(frame); end
end

class Protocol::HTTP2::GoawayError < ::Protocol::HTTP2::ProtocolError; end

# The GOAWAY frame is used to initiate shutdown of a connection or to signal serious error conditions. GOAWAY allows an endpoint to gracefully stop accepting new streams while still finishing processing of previously established streams. This enables administrative actions, like server maintenance.
#
# +-+-------------------------------------------------------------+
# |R|                  Last-Stream-ID (31)                        |
# +-+-------------------------------------------------------------+
# |                      Error Code (32)                          |
# +---------------------------------------------------------------+
# |                  Additional Debug Data (*)                    |
# +---------------------------------------------------------------+
class Protocol::HTTP2::GoawayFrame < ::Protocol::HTTP2::Frame
  def apply(connection); end

  # @return [Boolean]
  def connection?; end

  def pack(last_stream_id, error_code, data); end
  def unpack; end
end

Protocol::HTTP2::GoawayFrame::FORMAT = T.let(T.unsafe(nil), String)
Protocol::HTTP2::GoawayFrame::TYPE = T.let(T.unsafe(nil), Integer)
Protocol::HTTP2::HTTP_1_1_REQUIRED = T.let(T.unsafe(nil), Integer)

# Raised if connection header is missing or invalid indicating that
# this is an invalid HTTP 2.0 request - no frames are emitted and the
# connection must be aborted.
class Protocol::HTTP2::HandshakeError < ::Protocol::HTTP2::Error; end

class Protocol::HTTP2::HeaderError < ::Protocol::HTTP2::StreamClosed
  # @return [HeaderError] a new instance of HeaderError
  def initialize(message); end
end

# The HEADERS frame is used to open a stream, and additionally carries a header block fragment. HEADERS frames can be sent on a stream in the "idle", "reserved (local)", "open", or "half-closed (remote)" state.
#
# +---------------+
# |Pad Length? (8)|
# +-+-------------+-----------------------------------------------+
# |E|                 Stream Dependency? (31)                     |
# +-+-------------+-----------------------------------------------+
# |  Weight? (8)  |
# +-+-------------+-----------------------------------------------+
# |                   Header Block Fragment (*)                 ...
# +---------------------------------------------------------------+
# |                           Padding (*)                       ...
# +---------------------------------------------------------------+
class Protocol::HTTP2::HeadersFrame < ::Protocol::HTTP2::Frame
  include ::Protocol::HTTP2::Padded
  include ::Protocol::HTTP2::Continued

  def apply(connection); end

  # @return [Boolean]
  def end_stream?; end

  def inspect; end
  def pack(priority, data, *arguments, **options); end

  # @return [Boolean]
  def priority?; end

  def unpack; end
end

Protocol::HTTP2::HeadersFrame::TYPE = T.let(T.unsafe(nil), Integer)
Protocol::HTTP2::INADEQUATE_SECURITY = T.let(T.unsafe(nil), Integer)
Protocol::HTTP2::INTERNAL_ERROR = T.let(T.unsafe(nil), Integer)

# This is a window which efficiently maintains a desired capacity.
class Protocol::HTTP2::LocalWindow < ::Protocol::HTTP2::Window
  # @return [LocalWindow] a new instance of LocalWindow
  def initialize(capacity = T.unsafe(nil), desired: T.unsafe(nil)); end

  # Returns the value of attribute desired.
  def desired; end

  # Sets the attribute desired
  #
  # @param value the value to set the attribute desired to.
  def desired=(_arg0); end

  # @return [Boolean]
  def limited?; end

  def wanted; end
end

Protocol::HTTP2::MAXIMUM_ALLOWED_FRAME_SIZE = T.let(T.unsafe(nil), Integer)
Protocol::HTTP2::MAXIMUM_ALLOWED_WINDOW_SIZE = T.let(T.unsafe(nil), Integer)
Protocol::HTTP2::MINIMUM_ALLOWED_FRAME_SIZE = T.let(T.unsafe(nil), Integer)
Protocol::HTTP2::NO_ERROR = T.let(T.unsafe(nil), Integer)
Protocol::HTTP2::PADDED = T.let(T.unsafe(nil), Integer)
Protocol::HTTP2::PRIORITY = T.let(T.unsafe(nil), Integer)
Protocol::HTTP2::PROTOCOL_ERROR = T.let(T.unsafe(nil), Integer)

# Certain frames can have padding:
# https://http2.github.io/http2-spec/#padding
#
# +---------------+
# |Pad Length? (8)|
# +---------------+-----------------------------------------------+
# |                            Data (*)                         ...
# +---------------------------------------------------------------+
# |                           Padding (*)                       ...
# +---------------------------------------------------------------+
module Protocol::HTTP2::Padded
  def pack(data, padding_size: T.unsafe(nil), maximum_size: T.unsafe(nil)); end

  # @return [Boolean]
  def padded?; end

  def unpack; end
end

class Protocol::HTTP2::PendingSettings
  # @return [PendingSettings] a new instance of PendingSettings
  def initialize(current = T.unsafe(nil)); end

  def acknowledge; end
  def append(changes); end

  # Returns the value of attribute current.
  def current; end

  def enable_push; end
  def header_table_size; end
  def initial_window_size; end
  def maximum_concurrent_streams; end
  def maximum_frame_size; end
  def maximum_header_list_size; end

  # Returns the value of attribute pending.
  def pending; end
end

# The PING frame is a mechanism for measuring a minimal round-trip time from the sender, as well as determining whether an idle connection is still functional. PING frames can be sent from any endpoint.
#
# +---------------------------------------------------------------+
# |                                                               |
# |                      Opaque Data (64)                         |
# |                                                               |
# +---------------------------------------------------------------+
class Protocol::HTTP2::PingFrame < ::Protocol::HTTP2::Frame
  include ::Protocol::HTTP2::Acknowledgement

  def acknowledge; end
  def apply(connection); end

  # @return [Boolean]
  def connection?; end

  def read_payload(stream); end
end

Protocol::HTTP2::PingFrame::TYPE = T.let(T.unsafe(nil), Integer)

# Stream Dependency:  A 31-bit stream identifier for the stream that
# this stream depends on (see Section 5.3).  This field is only
# present if the PRIORITY flag is set.
class Protocol::HTTP2::Priority < ::Struct
  def pack; end

  # Sets the attribute weight
  #
  # @param value [Object] the value to set the attribute weight to.
  # @return [Object] the newly set value
  def weight=(value); end

  class << self
    # All streams are initially assigned a non-exclusive dependency on stream 0x0.  Pushed streams (Section 8.2) initially depend on their associated stream.  In both cases, streams are assigned a default weight of 16.
    def default(stream_dependency = T.unsafe(nil), weight = T.unsafe(nil)); end

    def unpack(data); end
  end
end

Protocol::HTTP2::Priority::EXCLUSIVE = T.let(T.unsafe(nil), Integer)
Protocol::HTTP2::Priority::FORMAT = T.let(T.unsafe(nil), String)

# The PRIORITY frame specifies the sender-advised priority of a stream. It can be sent in any stream state, including idle or closed streams.
#
# +-+-------------------------------------------------------------+
# |E|                  Stream Dependency (31)                     |
# +-+-------------+-----------------------------------------------+
# |   Weight (8)  |
# +-+-------------+
class Protocol::HTTP2::PriorityFrame < ::Protocol::HTTP2::Frame
  def apply(connection); end
  def pack(priority); end
  def priority; end
  def read_payload(stream); end
  def unpack; end
end

Protocol::HTTP2::PriorityFrame::TYPE = T.let(T.unsafe(nil), Integer)

# Raised by stream or connection handlers, results in GOAWAY frame
# which signals termination of the current connection. You *cannot*
# recover from this exception, or any exceptions subclassed from it.
class Protocol::HTTP2::ProtocolError < ::Protocol::HTTP2::Error
  # @return [ProtocolError] a new instance of ProtocolError
  def initialize(message, code = T.unsafe(nil)); end

  # Returns the value of attribute code.
  def code; end
end

# The PUSH_PROMISE frame is used to notify the peer endpoint in advance of streams the sender intends to initiate. The PUSH_PROMISE frame includes the unsigned 31-bit identifier of the stream the endpoint plans to create along with a set of headers that provide additional context for the stream.
#
# +---------------+
# |Pad Length? (8)|
# +-+-------------+-----------------------------------------------+
# |R|                  Promised Stream ID (31)                    |
# +-+-----------------------------+-------------------------------+
# |                   Header Block Fragment (*)                 ...
# +---------------------------------------------------------------+
# |                           Padding (*)                       ...
# +---------------------------------------------------------------+
class Protocol::HTTP2::PushPromiseFrame < ::Protocol::HTTP2::Frame
  include ::Protocol::HTTP2::Padded
  include ::Protocol::HTTP2::Continued

  def apply(connection); end
  def pack(stream_id, data, *arguments, **options); end
  def unpack; end
end

Protocol::HTTP2::PushPromiseFrame::FORMAT = T.let(T.unsafe(nil), String)
Protocol::HTTP2::PushPromiseFrame::TYPE = T.let(T.unsafe(nil), Integer)
Protocol::HTTP2::REFUSED_STREAM = T.let(T.unsafe(nil), Integer)

# The RST_STREAM frame allows for immediate termination of a stream. RST_STREAM is sent to request cancellation of a stream or to indicate that an error condition has occurred.
#
# +---------------------------------------------------------------+
# |                        Error Code (32)                        |
# +---------------------------------------------------------------+
class Protocol::HTTP2::ResetStreamFrame < ::Protocol::HTTP2::Frame
  def apply(connection); end
  def pack(error_code = T.unsafe(nil)); end
  def read_payload(stream); end
  def unpack; end
end

Protocol::HTTP2::ResetStreamFrame::FORMAT = T.let(T.unsafe(nil), String)
Protocol::HTTP2::ResetStreamFrame::TYPE = T.let(T.unsafe(nil), Integer)
Protocol::HTTP2::STREAM_CLOSED = T.let(T.unsafe(nil), Integer)

class Protocol::HTTP2::Server < ::Protocol::HTTP2::Connection
  # @return [Server] a new instance of Server
  def initialize(framer); end

  # @raise [ProtocolError]
  def accept_push_promise_stream(stream_id, &block); end

  # @return [Boolean]
  def enable_push?; end

  # @return [Boolean]
  def local_stream_id?(id); end

  def read_connection_preface(settings = T.unsafe(nil)); end

  # @return [Boolean]
  def remote_stream_id?(id); end

  # @return [Boolean]
  def valid_remote_stream_id?(stream_id); end
end

class Protocol::HTTP2::Settings
  # @return [Settings] a new instance of Settings
  def initialize; end

  def difference(other); end

  # Returns the value of attribute enable_connect_protocol.
  def enable_connect_protocol; end

  def enable_connect_protocol=(value); end

  # @return [Boolean]
  def enable_connect_protocol?; end

  # This setting can be used to disable server push. An endpoint MUST NOT send a PUSH_PROMISE frame if it receives this parameter set to a value of 0.
  def enable_push; end

  def enable_push=(value); end

  # @return [Boolean]
  def enable_push?; end

  # Allows the sender to inform the remote endpoint of the maximum size of the header compression table used to decode header blocks, in octets.
  def header_table_size; end

  # Allows the sender to inform the remote endpoint of the maximum size of the header compression table used to decode header blocks, in octets.
  def header_table_size=(_arg0); end

  # Indicates the sender's initial window size (in octets) for stream-level flow control.
  def initial_window_size; end

  def initial_window_size=(value); end

  # Indicates the maximum number of concurrent streams that the sender will allow.
  def maximum_concurrent_streams; end

  # Indicates the maximum number of concurrent streams that the sender will allow.
  def maximum_concurrent_streams=(_arg0); end

  # Indicates the size of the largest frame payload that the sender is willing to receive, in octets.
  def maximum_frame_size; end

  def maximum_frame_size=(value); end

  # This advisory setting informs a peer of the maximum size of header list that the sender is prepared to accept, in octets.
  def maximum_header_list_size; end

  # This advisory setting informs a peer of the maximum size of header list that the sender is prepared to accept, in octets.
  def maximum_header_list_size=(_arg0); end

  def update(changes); end
end

Protocol::HTTP2::Settings::ASSIGN = T.let(T.unsafe(nil), Array)
Protocol::HTTP2::Settings::ENABLE_CONNECT_PROTOCOL = T.let(T.unsafe(nil), Integer)
Protocol::HTTP2::Settings::ENABLE_PUSH = T.let(T.unsafe(nil), Integer)
Protocol::HTTP2::Settings::HEADER_TABLE_SIZE = T.let(T.unsafe(nil), Integer)
Protocol::HTTP2::Settings::INITIAL_WINDOW_SIZE = T.let(T.unsafe(nil), Integer)
Protocol::HTTP2::Settings::MAXIMUM_CONCURRENT_STREAMS = T.let(T.unsafe(nil), Integer)
Protocol::HTTP2::Settings::MAXIMUM_FRAME_SIZE = T.let(T.unsafe(nil), Integer)
Protocol::HTTP2::Settings::MAXIMUM_HEADER_LIST_SIZE = T.let(T.unsafe(nil), Integer)

# The SETTINGS frame conveys configuration parameters that affect how endpoints communicate, such as preferences and constraints on peer behavior. The SETTINGS frame is also used to acknowledge the receipt of those parameters. Individually, a SETTINGS parameter can also be referred to as a "setting".
#
# +-------------------------------+
# |       Identifier (16)         |
# +-------------------------------+-------------------------------+
# |                        Value (32)                             |
# +---------------------------------------------------------------+
class Protocol::HTTP2::SettingsFrame < ::Protocol::HTTP2::Frame
  include ::Protocol::HTTP2::Acknowledgement

  def apply(connection); end

  # @return [Boolean]
  def connection?; end

  def pack(settings = T.unsafe(nil)); end
  def read_payload(stream); end
  def unpack; end
end

Protocol::HTTP2::SettingsFrame::FORMAT = T.let(T.unsafe(nil), String)
Protocol::HTTP2::SettingsFrame::TYPE = T.let(T.unsafe(nil), Integer)

# A single HTTP 2.0 connection can multiplex multiple streams in parallel:
# multiple requests and responses can be in flight simultaneously and stream
# data can be interleaved and prioritized.
#
# This class encapsulates all of the state, transition, flow-control, and
# error management as defined by the HTTP 2.0 specification. All you have
# to do is subscribe to appropriate events (marked with ":" prefix in
# diagram below) and provide your application logic to handle request
# and response processing.
#
#                          +--------+
#                  send PP |        | recv PP
#                 ,--------|  idle  |--------.
#                /         |        |         \
#               v          +--------+          v
#        +----------+          |           +----------+
#        |          |          | send H /  |          |
# ,------| reserved |          | recv H    | reserved |------.
# |      | (local)  |          |           | (remote) |      |
# |      +----------+          v           +----------+      |
# |          |             +--------+             |          |
# |          |     recv ES |        | send ES     |          |
# |   send H |     ,-------|  open  |-------.     | recv H   |
# |          |    /        |        |        \    |          |
# |          v   v         +--------+         v   v          |
# |      +----------+          |           +----------+      |
# |      |   half   |          |           |   half   |      |
# |      |  closed  |          | send R /  |  closed  |      |
# |      | (remote) |          | recv R    | (local)  |      |
# |      +----------+          |           +----------+      |
# |           |                |                 |           |
# |           | send ES /      |       recv ES / |           |
# |           | send R /       v        send R / |           |
# |           | recv R     +--------+   recv R   |           |
# | send R /  `----------->|        |<-----------'  send R / |
# | recv R                 | closed |               recv R   |
# `----------------------->|        |<----------------------'
#                          +--------+
#
#    send:   endpoint sends this frame
#    recv:   endpoint receives this frame
#
#    H:  HEADERS frame (with implied CONTINUATIONs)
#    PP: PUSH_PROMISE frame (with implied CONTINUATIONs)
#    ES: END_STREAM flag
#    R:  RST_STREAM frame
#
# State transition methods use a trailing "!".
class Protocol::HTTP2::Stream
  include ::Protocol::HTTP2::FlowControlled

  # @return [Stream] a new instance of Stream
  def initialize(connection, id, state = T.unsafe(nil)); end

  # Override this function to implement your own push promise logic.
  def accept_push_promise_stream(stream_id, headers); end

  # @return [Boolean]
  def active?; end

  # Transition directly to closed state. Do not pass go, do not collect $200.
  # This method should only be used by `Connection#close`.
  def close(error = T.unsafe(nil)); end

  # Transition the stream into the closed state.
  #
  # @param error_code [Integer] the error code if the stream was closed due to a stream reset.
  def close!(error_code = T.unsafe(nil)); end

  # The stream has been closed. If closed due to a stream reset, the error will be set.
  def closed(error = T.unsafe(nil)); end

  # @return [Boolean]
  def closed?; end

  # The connection this stream belongs to.
  def connection; end

  def consume_remote_window(frame); end

  # Override this function to implement your own push promise logic.
  def create_push_promise_stream(headers); end

  # Returns the value of attribute dependency.
  def dependency; end

  # Stream ID (odd for client initiated streams, even otherwise).
  def id; end

  def ignore_data(frame); end
  def inspect; end

  # Returns the value of attribute local_window.
  def local_window; end

  def maximum_frame_size; end
  def open!; end

  # The stream has been opened.
  def opened(error = T.unsafe(nil)); end

  def parent=(stream); end
  def priority; end
  def priority=(priority); end

  # @return [String] the data that was received.
  def process_data(frame); end

  def process_headers(frame); end

  # DATA frames are subject to flow control and can only be sent when a stream is in the "open" or "half-closed (remote)" state.  The entire DATA frame payload is included in flow control, including the Pad Length and Padding fields if present.  If a DATA frame is received whose stream is not in "open" or "half-closed (local)" state, the recipient MUST respond with a stream error of type STREAM_CLOSED.
  def receive_data(frame); end

  def receive_headers(frame); end
  def receive_push_promise(frame); end
  def receive_reset_stream(frame); end

  # Returns the value of attribute remote_window.
  def remote_window; end

  def reserved_local!; end
  def reserved_remote!; end
  def send_data(*arguments, **options); end

  # The HEADERS frame is used to open a stream, and additionally carries a header block fragment. HEADERS frames can be sent on a stream in the "idle", "reserved (local)", "open", or "half-closed (remote)" state.
  def send_headers(*arguments); end

  # @return [Boolean]
  def send_headers?; end

  # Server push is semantically equivalent to a server responding to a request; however, in this case, that request is also sent by the server, as a PUSH_PROMISE frame.
  #
  # @param headers [Hash] contains a complete set of request header fields that the server attributes to the request.
  def send_push_promise(headers); end

  def send_reset_stream(error_code = T.unsafe(nil)); end

  # Stream state, e.g. `idle`, `closed`.
  def state; end

  # Stream state, e.g. `idle`, `closed`.
  def state=(_arg0); end

  def to_s; end
  def weight; end
  def write_frame(frame); end

  protected

  def ignore_headers(frame); end

  private

  def write_data(data, flags = T.unsafe(nil), **options); end
  def write_headers(priority, headers, flags = T.unsafe(nil)); end

  # A normal request is client request -> server response -> client.
  # A push promise is server request -> client -> server response -> client.
  # The server generates the same set of headers as if the client was sending a request, and sends these to the client. The client can reject the request by resetting the (new) stream. Otherwise, the server will start sending a response as if the client had send the request.
  def write_push_promise(stream_id, headers, flags = T.unsafe(nil), **options); end

  class << self
    def create(connection, id); end
  end
end

class Protocol::HTTP2::StreamClosed < ::Protocol::HTTP2::StreamError
  # @return [StreamClosed] a new instance of StreamClosed
  def initialize(message); end
end

class Protocol::HTTP2::StreamError < ::Protocol::HTTP2::ProtocolError; end
Protocol::HTTP2::TIMEOUT = T.let(T.unsafe(nil), Integer)
Protocol::HTTP2::VALID_WEIGHT = T.let(T.unsafe(nil), Range)

class Protocol::HTTP2::Window
  # @param capacity [Integer] The initial window size, typically from the settings.
  # @return [Window] a new instance of Window
  def initialize(capacity = T.unsafe(nil)); end

  # Returns the value of attribute available.
  def available; end

  # @return [Boolean]
  def available?; end

  # Returns the value of attribute capacity.
  def capacity; end

  # When the value of SETTINGS_INITIAL_WINDOW_SIZE changes, a receiver MUST adjust the size of all stream flow-control windows that it maintains by the difference between the new value and the old value.
  def capacity=(value); end

  def consume(amount); end
  def expand(amount); end

  # The window is completely full?
  #
  # @return [Boolean]
  def full?; end

  # @return [Boolean]
  def limited?; end

  def to_s; end

  # Returns the value of attribute used.
  def used; end

  def wanted; end
end

# The WINDOW_UPDATE frame is used to implement flow control.
#
# +-+-------------------------------------------------------------+
# |R|              Window Size Increment (31)                     |
# +-+-------------------------------------------------------------+
class Protocol::HTTP2::WindowUpdateFrame < ::Protocol::HTTP2::Frame
  def apply(connection); end
  def pack(window_size_increment); end
  def read_payload(stream); end
  def unpack; end
end

Protocol::HTTP2::WindowUpdateFrame::FORMAT = T.let(T.unsafe(nil), String)
Protocol::HTTP2::WindowUpdateFrame::TYPE = T.let(T.unsafe(nil), Integer)
