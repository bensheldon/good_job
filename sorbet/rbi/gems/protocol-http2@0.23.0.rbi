# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `protocol-http2` gem.
# Please instead update this file by running `bin/tapioca gem protocol-http2`.


# source://protocol-http2//lib/protocol/http2/error.rb#8
module Protocol; end

# source://protocol-http2//lib/protocol/http2/error.rb#9
module Protocol::HTTP2; end

# source://protocol-http2//lib/protocol/http2/ping_frame.rb#10
Protocol::HTTP2::ACKNOWLEDGEMENT = T.let(T.unsafe(nil), Integer)

# Provides acknowledgement functionality for frames that support it.
# This module handles setting and checking acknowledgement flags on frames.
#
# source://protocol-http2//lib/protocol/http2/ping_frame.rb#14
module Protocol::HTTP2::Acknowledgement
  # Create an acknowledgement frame for this frame.
  #
  # source://protocol-http2//lib/protocol/http2/ping_frame.rb#28
  def acknowledge; end

  # Mark this frame as an acknowledgement.
  #
  # source://protocol-http2//lib/protocol/http2/ping_frame.rb#22
  def acknowledgement!; end

  # Check if the frame is an acknowledgement.
  #
  # @return [Boolean]
  #
  # source://protocol-http2//lib/protocol/http2/ping_frame.rb#17
  def acknowledgement?; end
end

# source://protocol-http2//lib/protocol/http2/reset_stream_frame.rb#18
Protocol::HTTP2::CANCEL = T.let(T.unsafe(nil), Integer)

# source://protocol-http2//lib/protocol/http2/reset_stream_frame.rb#19
Protocol::HTTP2::COMPRESSION_ERROR = T.let(T.unsafe(nil), Integer)

# Default connection "fast-fail" preamble string as defined by the spec.
#
# source://protocol-http2//lib/protocol/http2/framer.rb#43
Protocol::HTTP2::CONNECTION_PREFACE = T.let(T.unsafe(nil), String)

# source://protocol-http2//lib/protocol/http2/reset_stream_frame.rb#20
Protocol::HTTP2::CONNECT_ERROR = T.let(T.unsafe(nil), Integer)

# Represents an HTTP/2 client connection.
# Manages client-side protocol semantics including stream ID allocation,
# connection preface handling, and push promise processing.
#
# source://protocol-http2//lib/protocol/http2/client.rb#13
class Protocol::HTTP2::Client < ::Protocol::HTTP2::Connection
  # Initialize a new HTTP/2 client connection.
  #
  # @return [Client] a new instance of Client
  #
  # source://protocol-http2//lib/protocol/http2/client.rb#16
  def initialize(framer); end

  # Clients cannot create push promise streams.
  #
  # @raise [ProtocolError]
  #
  # source://protocol-http2//lib/protocol/http2/client.rb#69
  def create_push_promise_stream; end

  # Check if the given stream ID represents a locally-initiated stream.
  # Client streams have odd numbered IDs.
  #
  # @return [Boolean]
  #
  # source://protocol-http2//lib/protocol/http2/client.rb#24
  def local_stream_id?(id); end

  # Process a push promise frame received from the server.
  #
  # source://protocol-http2//lib/protocol/http2/client.rb#76
  def receive_push_promise(frame); end

  # Check if the given stream ID represents a remotely-initiated stream.
  # Server streams have even numbered IDs.
  #
  # @return [Boolean]
  #
  # source://protocol-http2//lib/protocol/http2/client.rb#32
  def remote_stream_id?(id); end

  # Send the HTTP/2 connection preface and initial settings.
  # This must be called once when the connection is first established.
  #
  # source://protocol-http2//lib/protocol/http2/client.rb#49
  def send_connection_preface(settings = T.unsafe(nil)); end

  # Check if the given stream ID is valid for remote initiation.
  # Server-initiated streams must have even numbered IDs.
  #
  # @return [Boolean]
  #
  # source://protocol-http2//lib/protocol/http2/client.rb#40
  def valid_remote_stream_id?(stream_id); end
end

# This is the core connection class that handles HTTP/2 protocol semantics including
# stream management, settings negotiation, and frame processing.
#
# source://protocol-http2//lib/protocol/http2/connection.rb#17
class Protocol::HTTP2::Connection
  include ::Protocol::HTTP2::FlowControlled

  # Initialize a new HTTP/2 connection.
  #
  # @return [Connection] a new instance of Connection
  #
  # source://protocol-http2//lib/protocol/http2/connection.rb#23
  def initialize(framer, local_stream_id); end

  # Access streams by ID, with 0 returning the connection itself.
  #
  # source://protocol-http2//lib/protocol/http2/connection.rb#58
  def [](id); end

  # Accept an incoming push promise from the other side of the connection.
  # On the client side, we accept push promise streams.
  # On the server side, existing streams create push promise streams.
  #
  # source://protocol-http2//lib/protocol/http2/connection.rb#405
  def accept_push_promise_stream(stream_id, &block); end

  # Accept an incoming stream from the other side of the connnection.
  # On the server side, we accept requests.
  #
  # source://protocol-http2//lib/protocol/http2/connection.rb#394
  def accept_stream(stream_id, &block); end

  # Check if the given stream ID represents a client-initiated stream.
  # Client streams always have odd numbered IDs.
  #
  # @return [Boolean]
  #
  # source://protocol-http2//lib/protocol/http2/connection.rb#486
  def client_stream_id?(id); end

  # Close the underlying framer and all streams.
  #
  # source://protocol-http2//lib/protocol/http2/connection.rb#110
  def close(error = T.unsafe(nil)); end

  # Transition the connection into the closed state.
  #
  # source://protocol-http2//lib/protocol/http2/connection.rb#209
  def close!; end

  # Whether the connection is effectively or actually closed.
  #
  # @return [Boolean]
  #
  # source://protocol-http2//lib/protocol/http2/connection.rb#98
  def closed?; end

  # This is only valid if the stream doesn't exist in `@streams`.
  #
  # @return [Boolean]
  #
  # source://protocol-http2//lib/protocol/http2/connection.rb#520
  def closed_stream_id?(id); end

  # Traverse active streams and allow them to consume the available flow-control window.
  #
  # source://protocol-http2//lib/protocol/http2/connection.rb#546
  def consume_window(size = T.unsafe(nil)); end

  # Create a push promise stream.
  # This method should be overridden by client/server implementations.
  #
  # source://protocol-http2//lib/protocol/http2/connection.rb#428
  def create_push_promise_stream(&block); end

  # Create a stream, defaults to an outgoing stream.
  # On the client side, we create requests.
  #
  # @return [Stream] the created stream.
  #
  # source://protocol-http2//lib/protocol/http2/connection.rb#412
  def create_stream(id = T.unsafe(nil), &block); end

  # Decode headers using HPACK decompression.
  #
  # source://protocol-http2//lib/protocol/http2/connection.rb#133
  def decode_headers(data); end

  # Remove a stream from the active streams collection.
  #
  # source://protocol-http2//lib/protocol/http2/connection.rb#105
  def delete(id); end

  # Returns the value of attribute dependencies.
  #
  # source://protocol-http2//lib/protocol/http2/connection.rb#148
  def dependencies; end

  # Returns the value of attribute dependency.
  #
  # source://protocol-http2//lib/protocol/http2/connection.rb#150
  def dependency; end

  # Encode headers using HPACK compression.
  #
  # source://protocol-http2//lib/protocol/http2/connection.rb#126
  def encode_headers(headers, buffer = T.unsafe(nil)); end

  # Returns the value of attribute framer.
  #
  # source://protocol-http2//lib/protocol/http2/connection.rb#78
  def framer; end

  # The connection stream ID (always 0 for connection-level operations).
  #
  # source://protocol-http2//lib/protocol/http2/connection.rb#51
  def id; end

  # Check if the given stream ID represents an idle stream.
  #
  # @return [Boolean]
  #
  # source://protocol-http2//lib/protocol/http2/connection.rb#501
  def idle_stream_id?(id); end

  # 6.8. GOAWAY
  # There is an inherent race condition between an endpoint starting new streams and the remote sending a GOAWAY frame. To deal with this case, the GOAWAY contains the stream identifier of the last peer-initiated stream that was or might be processed on the sending endpoint in this connection. For instance, if the server sends a GOAWAY frame, the identified stream is the highest-numbered stream initiated by the client.
  # Once sent, the sender will ignore frames sent on streams initiated by the receiver if the stream has an identifier higher than the included last stream identifier. Receivers of a GOAWAY frame MUST NOT open additional streams on the connection, although a new connection can be established for new streams.
  #
  # @return [Boolean]
  #
  # source://protocol-http2//lib/protocol/http2/connection.rb#155
  def ignore_frame?(frame); end

  # Current settings value for local and peer
  #
  # source://protocol-http2//lib/protocol/http2/connection.rb#84
  def local_settings; end

  # Current settings value for local and peer
  #
  # source://protocol-http2//lib/protocol/http2/connection.rb#84
  def local_settings=(_arg0); end

  # Our window for receiving data. When we receive data, it reduces this window.
  # If the window gets too small, we must send a window update.
  #
  # source://protocol-http2//lib/protocol/http2/connection.rb#89
  def local_window; end

  # The maximum number of concurrent streams that this connection can initiate. This is a setting that can be changed by the remote peer.
  #
  # It is not the same as the number of streams that can be accepted by the connection. The number of streams that can be accepted is determined by the local settings, and the number of streams that can be initiated is determined by the remote settings.
  #
  # source://protocol-http2//lib/protocol/http2/connection.rb#74
  def maximum_concurrent_streams; end

  # The size of a frame payload is limited by the maximum size that a receiver advertises in the SETTINGS_MAX_FRAME_SIZE setting.
  #
  # source://protocol-http2//lib/protocol/http2/connection.rb#67
  def maximum_frame_size; end

  # Streams are identified with an unsigned 31-bit integer.  Streams initiated by a client MUST use odd-numbered stream identifiers; those initiated by the server MUST use even-numbered stream identifiers.  A stream identifier of zero (0x0) is used for connection control messages; the stream identifier of zero cannot be used to establish a new stream.
  #
  # source://protocol-http2//lib/protocol/http2/connection.rb#138
  def next_stream_id; end

  # Transition the connection to the open state.
  #
  # source://protocol-http2//lib/protocol/http2/connection.rb#316
  def open!; end

  # In addition to changing the flow-control window for streams that are not yet active, a SETTINGS frame can alter the initial flow-control window size for streams with active flow-control windows (that is, streams in the "open" or "half-closed (remote)" state).  When the value of SETTINGS_INITIAL_WINDOW_SIZE changes, a receiver MUST adjust the size of all stream flow-control windows that it maintains by the difference between the new value and the old value.
  #
  # @return [Boolean] whether the frame was an acknowledgement
  #
  # source://protocol-http2//lib/protocol/http2/connection.rb#291
  def process_settings(frame); end

  # Reads one frame from the network and processes. Processing the frame updates the state of the connection and related streams. If the frame triggers an error, e.g. a protocol error, the connection will typically emit a goaway frame and re-raise the exception. You should continue processing frames until the underlying connection is closed.
  #
  # source://protocol-http2//lib/protocol/http2/connection.rb#172
  def read_frame; end

  # Receive and process a CONTINUATION frame.
  #
  # @raise [ProtocolError]
  #
  # source://protocol-http2//lib/protocol/http2/connection.rb#581
  def receive_continuation(frame); end

  # Process a DATA frame from the remote peer.
  #
  # source://protocol-http2//lib/protocol/http2/connection.rb#372
  def receive_data(frame); end

  # Receive and process a generic frame (default handler).
  #
  # source://protocol-http2//lib/protocol/http2/connection.rb#587
  def receive_frame(frame); end

  # Process a GOAWAY frame from the remote peer.
  #
  # source://protocol-http2//lib/protocol/http2/connection.rb#228
  def receive_goaway(frame); end

  # On the server side, starts a new request.
  #
  # source://protocol-http2//lib/protocol/http2/connection.rb#433
  def receive_headers(frame); end

  # Process a PING frame from the remote peer.
  #
  # source://protocol-http2//lib/protocol/http2/connection.rb#352
  def receive_ping(frame); end

  # Receive and process a PRIORITY_UPDATE frame.
  #
  # source://protocol-http2//lib/protocol/http2/connection.rb#469
  def receive_priority_update(frame); end

  # Receive and process a PUSH_PROMISE frame.
  #
  # @raise [ProtocolError]
  #
  # source://protocol-http2//lib/protocol/http2/connection.rb#462
  def receive_push_promise(frame); end

  # Receive and process a RST_STREAM frame.
  #
  # source://protocol-http2//lib/protocol/http2/connection.rb#532
  def receive_reset_stream(frame); end

  # Receive and process a SETTINGS frame from the remote peer.
  #
  # source://protocol-http2//lib/protocol/http2/connection.rb#325
  def receive_settings(frame); end

  # Receive and process a WINDOW_UPDATE frame.
  #
  # source://protocol-http2//lib/protocol/http2/connection.rb#559
  def receive_window_update(frame); end

  # Returns the value of attribute remote_settings.
  #
  # source://protocol-http2//lib/protocol/http2/connection.rb#85
  def remote_settings; end

  # Sets the attribute remote_settings
  #
  # @param value the value to set the attribute remote_settings to.
  #
  # source://protocol-http2//lib/protocol/http2/connection.rb#85
  def remote_settings=(_arg0); end

  # The highest stream_id that has been successfully accepted by this connection.
  #
  # source://protocol-http2//lib/protocol/http2/connection.rb#95
  def remote_stream_id; end

  # Our window for sending data. When we send data, it reduces this window.
  #
  # source://protocol-http2//lib/protocol/http2/connection.rb#92
  def remote_window; end

  # Tell the remote end that the connection is being shut down. If the `error_code` is 0, this is a graceful shutdown. The other end of the connection should not make any new streams, but existing streams may be completed.
  #
  # source://protocol-http2//lib/protocol/http2/connection.rb#216
  def send_goaway(error_code = T.unsafe(nil), message = T.unsafe(nil)); end

  # Send a PING frame to the remote peer.
  #
  # source://protocol-http2//lib/protocol/http2/connection.rb#338
  def send_ping(data); end

  # Send updated settings to the remote peer.
  #
  # source://protocol-http2//lib/protocol/http2/connection.rb#199
  def send_settings(changes); end

  # Check if the given stream ID represents a server-initiated stream.
  # Server streams always have even numbered IDs.
  #
  # @return [Boolean]
  #
  # source://protocol-http2//lib/protocol/http2/connection.rb#494
  def server_stream_id?(id); end

  # Connection state (:new, :open, :closed).
  #
  # source://protocol-http2//lib/protocol/http2/connection.rb#81
  def state; end

  # Connection state (:new, :open, :closed).
  #
  # source://protocol-http2//lib/protocol/http2/connection.rb#81
  def state=(_arg0); end

  # Returns the value of attribute streams.
  #
  # source://protocol-http2//lib/protocol/http2/connection.rb#146
  def streams; end

  # Execute a block within a synchronized context.
  # This method provides a synchronization primitive for thread safety.
  #
  # source://protocol-http2//lib/protocol/http2/connection.rb#167
  def synchronize; end

  # Update local settings and adjust stream window capacities.
  #
  # source://protocol-http2//lib/protocol/http2/connection.rb#268
  def update_local_settings(changes); end

  # Update remote settings and adjust stream window capacities.
  #
  # source://protocol-http2//lib/protocol/http2/connection.rb#280
  def update_remote_settings(changes); end

  # Check if the given stream ID is valid for remote initiation.
  # This method should be overridden by client/server implementations.
  #
  # @return [Boolean]
  #
  # source://protocol-http2//lib/protocol/http2/connection.rb#388
  def valid_remote_stream_id?(stream_id); end

  # Write a single frame to the connection.
  #
  # source://protocol-http2//lib/protocol/http2/connection.rb#242
  def write_frame(frame); end

  # Write multiple frames within a synchronized block.
  #
  # source://protocol-http2//lib/protocol/http2/connection.rb#254
  def write_frames; end
end

# The CONTINUATION frame is used to continue a sequence of header block fragments. Any number of CONTINUATION frames can be sent, as long as the preceding frame is on the same stream and is a HEADERS, PUSH_PROMISE, or CONTINUATION frame without the END_HEADERS flag set.
#
# +---------------------------------------------------------------+
# +---------------------------------------------------------------+
#
# source://protocol-http2//lib/protocol/http2/continuation_frame.rb#121
class Protocol::HTTP2::ContinuationFrame < ::Protocol::HTTP2::Frame
  include ::Protocol::HTTP2::Continued

  # This is only invoked if the continuation is received out of the normal flow.
  #
  # source://protocol-http2//lib/protocol/http2/continuation_frame.rb#135
  def apply(connection); end

  # Get a string representation of the continuation frame.
  #
  # source://protocol-http2//lib/protocol/http2/continuation_frame.rb#141
  def inspect; end

  # Read the frame and any continuation frames from the stream.
  #
  # source://protocol-http2//lib/protocol/http2/continuation_frame.rb#130
  def read(stream, maximum_frame_size, limit = T.unsafe(nil)); end
end

# source://protocol-http2//lib/protocol/http2/continuation_frame.rb#124
Protocol::HTTP2::ContinuationFrame::TYPE = T.let(T.unsafe(nil), Integer)

# Module for frames that can be continued with CONTINUATION frames.
#
# source://protocol-http2//lib/protocol/http2/continuation_frame.rb#11
module Protocol::HTTP2::Continued
  # Initialize a continuable frame.
  #
  # source://protocol-http2//lib/protocol/http2/continuation_frame.rb#17
  def initialize(*_arg0); end

  # Returns the value of attribute continuation.
  #
  # source://protocol-http2//lib/protocol/http2/continuation_frame.rb#78
  def continuation; end

  # Sets the attribute continuation
  #
  # @param value the value to set the attribute continuation to.
  #
  # source://protocol-http2//lib/protocol/http2/continuation_frame.rb#78
  def continuation=(_arg0); end

  # Check if this frame has continuation frames.
  #
  # @return [Boolean]
  #
  # source://protocol-http2//lib/protocol/http2/continuation_frame.rb#25
  def continued?; end

  # Check if this is the last header block fragment.
  #
  # @return [Boolean]
  #
  # source://protocol-http2//lib/protocol/http2/continuation_frame.rb#31
  def end_headers?; end

  # Pack data into this frame, creating continuation frames if needed.
  #
  # source://protocol-http2//lib/protocol/http2/continuation_frame.rb#83
  def pack(data, **options); end

  # Read the frame and any continuation frames from the stream.
  #
  # There is an upper limit to the number of continuation frames that can be read to prevent resource exhaustion. If the limit is 0, only one frame will be read (the initial frame). Otherwise, the limit decrements with each continuation frame read.
  #
  # source://protocol-http2//lib/protocol/http2/continuation_frame.rb#42
  def read(stream, maximum_frame_size, limit = T.unsafe(nil)); end

  # Unpack data from this frame and any continuation frames.
  #
  # source://protocol-http2//lib/protocol/http2/continuation_frame.rb#106
  def unpack; end

  # Write the frame and any continuation frames to the stream.
  #
  # source://protocol-http2//lib/protocol/http2/continuation_frame.rb#70
  def write(stream); end
end

# source://protocol-http2//lib/protocol/http2/continuation_frame.rb#13
Protocol::HTTP2::Continued::LIMIT = T.let(T.unsafe(nil), Integer)

# DATA frames convey arbitrary, variable-length sequences of octets associated with a stream. One or more DATA frames are used, for instance, to carry HTTP request or response payloads.
#
# DATA frames MAY also contain padding. Padding can be added to DATA frames to obscure the size of messages.
#
# +---------------+
# |Pad Length? (8)|
# +---------------+-----------------------------------------------+
# +---------------------------------------------------------------+
# +---------------------------------------------------------------+
#
# source://protocol-http2//lib/protocol/http2/data_frame.rb#23
class Protocol::HTTP2::DataFrame < ::Protocol::HTTP2::Frame
  include ::Protocol::HTTP2::Padded

  # Apply this DATA frame to a connection for processing.
  #
  # source://protocol-http2//lib/protocol/http2/data_frame.rb#49
  def apply(connection); end

  # Check if this frame marks the end of the stream.
  #
  # @return [Boolean]
  #
  # source://protocol-http2//lib/protocol/http2/data_frame.rb#30
  def end_stream?; end

  # Provide a readable representation of the frame for debugging.
  #
  # source://protocol-http2//lib/protocol/http2/data_frame.rb#55
  def inspect; end

  # Pack data into the frame, handling empty data as stream end.
  #
  # source://protocol-http2//lib/protocol/http2/data_frame.rb#38
  def pack(data, *arguments, **options); end
end

# source://protocol-http2//lib/protocol/http2/data_frame.rb#26
Protocol::HTTP2::DataFrame::TYPE = T.let(T.unsafe(nil), Integer)

# source://protocol-http2//lib/protocol/http2/frame.rb#12
Protocol::HTTP2::END_HEADERS = T.let(T.unsafe(nil), Integer)

# source://protocol-http2//lib/protocol/http2/frame.rb#11
Protocol::HTTP2::END_STREAM = T.let(T.unsafe(nil), Integer)

# source://protocol-http2//lib/protocol/http2/reset_stream_frame.rb#21
Protocol::HTTP2::ENHANCE_YOUR_CALM = T.let(T.unsafe(nil), Integer)

# Status codes as defined by <https://tools.ietf.org/html/rfc7540#section-7>.
#
# source://protocol-http2//lib/protocol/http2/error.rb#11
class Protocol::HTTP2::Error < ::Protocol::HTTP::Error; end

# Used by the endpoint to indicate that the stream is no longer needed.
#
# source://protocol-http2//lib/protocol/http2/error.rb#37
Protocol::HTTP2::Error::CANCEL = T.let(T.unsafe(nil), Integer)

# The endpoint is unable to maintain the header compression context for the connection.
#
# source://protocol-http2//lib/protocol/http2/error.rb#40
Protocol::HTTP2::Error::COMPRESSION_ERROR = T.let(T.unsafe(nil), Integer)

# The connection established in response to a CONNECT request was reset or abnormally closed.
#
# source://protocol-http2//lib/protocol/http2/error.rb#43
Protocol::HTTP2::Error::CONNECT_ERROR = T.let(T.unsafe(nil), Integer)

# The endpoint detected that its peer is exhibiting a behavior that might be generating excessive load.
#
# source://protocol-http2//lib/protocol/http2/error.rb#46
Protocol::HTTP2::Error::ENHANCE_YOUR_CALM = T.let(T.unsafe(nil), Integer)

# The endpoint detected that its peer violated the flow-control protocol.
#
# source://protocol-http2//lib/protocol/http2/error.rb#22
Protocol::HTTP2::Error::FLOW_CONTROL_ERROR = T.let(T.unsafe(nil), Integer)

# The endpoint received a frame with an invalid size.
#
# source://protocol-http2//lib/protocol/http2/error.rb#31
Protocol::HTTP2::Error::FRAME_SIZE_ERROR = T.let(T.unsafe(nil), Integer)

# The endpoint requires that HTTP/1.1 be used instead of HTTP/2.
#
# source://protocol-http2//lib/protocol/http2/error.rb#52
Protocol::HTTP2::Error::HTTP_1_1_REQUIRED = T.let(T.unsafe(nil), Integer)

# The underlying transport has properties that do not meet minimum security requirements.
#
# source://protocol-http2//lib/protocol/http2/error.rb#49
Protocol::HTTP2::Error::INADEQUATE_SECURITY = T.let(T.unsafe(nil), Integer)

# The endpoint encountered an unexpected internal error.
#
# source://protocol-http2//lib/protocol/http2/error.rb#19
Protocol::HTTP2::Error::INTERNAL_ERROR = T.let(T.unsafe(nil), Integer)

# The associated condition is not a result of an error.  For example, a GOAWAY might include this code to indicate graceful shutdown of a connection.
#
# source://protocol-http2//lib/protocol/http2/error.rb#13
Protocol::HTTP2::Error::NO_ERROR = T.let(T.unsafe(nil), Integer)

# The endpoint detected an unspecific protocol error.  This error is for use when a more specific error code is not available.
#
# source://protocol-http2//lib/protocol/http2/error.rb#16
Protocol::HTTP2::Error::PROTOCOL_ERROR = T.let(T.unsafe(nil), Integer)

# The endpoint refused the stream prior to performing any application processing.
#
# source://protocol-http2//lib/protocol/http2/error.rb#34
Protocol::HTTP2::Error::REFUSED_STREAM = T.let(T.unsafe(nil), Integer)

# The endpoint sent a SETTINGS frame but did not receive a response in a timely manner.
#
# source://protocol-http2//lib/protocol/http2/error.rb#25
Protocol::HTTP2::Error::SETTINGS_TIMEOUT = T.let(T.unsafe(nil), Integer)

# The endpoint received a frame after a stream was half-closed.
#
# source://protocol-http2//lib/protocol/http2/error.rb#28
Protocol::HTTP2::Error::STREAM_CLOSED = T.let(T.unsafe(nil), Integer)

# source://protocol-http2//lib/protocol/http2/reset_stream_frame.rb#13
Protocol::HTTP2::FLOW_CONTROL_ERROR = T.let(T.unsafe(nil), Integer)

# HTTP/2 frame type mapping as defined by the spec
#
# source://protocol-http2//lib/protocol/http2/framer.rb#22
Protocol::HTTP2::FRAMES = T.let(T.unsafe(nil), Array)

# source://protocol-http2//lib/protocol/http2/reset_stream_frame.rb#16
Protocol::HTTP2::FRAME_SIZE_ERROR = T.let(T.unsafe(nil), Integer)

# Raised on invalid flow control frame or command.
#
# source://protocol-http2//lib/protocol/http2/error.rb#113
class Protocol::HTTP2::FlowControlError < ::Protocol::HTTP2::ProtocolError
  # Initialize a flow control error.
  #
  # @return [FlowControlError] a new instance of FlowControlError
  #
  # source://protocol-http2//lib/protocol/http2/error.rb#116
  def initialize(message); end
end

# Provides flow control functionality for HTTP/2 connections and streams.
# This module implements window-based flow control as defined in RFC 7540.
#
# source://protocol-http2//lib/protocol/http2/flow_controlled.rb#13
module Protocol::HTTP2::FlowControlled
  # This could be negative if the window has been overused due to a change in initial window size.
  #
  # source://protocol-http2//lib/protocol/http2/flow_controlled.rb#21
  def available_frame_size(maximum_frame_size = T.unsafe(nil)); end

  # Get the available window size for sending data.
  #
  # source://protocol-http2//lib/protocol/http2/flow_controlled.rb#16
  def available_size; end

  # Consume local window space for a received frame.
  #
  # source://protocol-http2//lib/protocol/http2/flow_controlled.rb#56
  def consume_local_window(frame); end

  # Keep track of the amount of data sent, and fail if is too much.
  #
  # source://protocol-http2//lib/protocol/http2/flow_controlled.rb#34
  def consume_remote_window(frame); end

  # Process a received WINDOW_UPDATE frame.
  #
  # source://protocol-http2//lib/protocol/http2/flow_controlled.rb#82
  def receive_window_update(frame); end

  # Request a window update if the local window is limited.
  #
  # source://protocol-http2//lib/protocol/http2/flow_controlled.rb#63
  def request_window_update; end

  # Notify the remote end that we are prepared to receive more data:
  #
  # source://protocol-http2//lib/protocol/http2/flow_controlled.rb#70
  def send_window_update(window_increment); end

  # Update the local window after receiving data.
  #
  # source://protocol-http2//lib/protocol/http2/flow_controlled.rb#49
  def update_local_window(frame); end

  # The window has been expanded by the given amount.
  #
  # @return [Boolean] whether the window update was used or not.
  #
  # source://protocol-http2//lib/protocol/http2/flow_controlled.rb#95
  def window_updated(size); end
end

# Represents the base class for all HTTP/2 frames.
# This class provides common functionality for frame parsing, serialization,
# and manipulation according to RFC 7540.
#
# source://protocol-http2//lib/protocol/http2/frame.rb#23
class Protocol::HTTP2::Frame
  include ::Comparable

  # @return [Frame] a new instance of Frame
  #
  # source://protocol-http2//lib/protocol/http2/frame.rb#41
  def initialize(stream_id = T.unsafe(nil), flags = T.unsafe(nil), type = T.unsafe(nil), length = T.unsafe(nil), payload = T.unsafe(nil)); end

  # Compare frames based on their essential properties.
  #
  # source://protocol-http2//lib/protocol/http2/frame.rb#58
  def <=>(other); end

  # Apply the frame to a connection for processing.
  #
  # source://protocol-http2//lib/protocol/http2/frame.rb#242
  def apply(connection); end

  # Clear specific flags on the frame.
  #
  # source://protocol-http2//lib/protocol/http2/frame.rb#113
  def clear_flags(mask); end

  # Check if frame is a connection frame: SETTINGS, PING, GOAWAY, and any
  # frame addressed to stream ID = 0.
  #
  # @return [Boolean] If this is a connection frame.
  #
  # source://protocol-http2//lib/protocol/http2/frame.rb#128
  def connection?; end

  # Check if specific flags are set on the frame.
  #
  # @return [Boolean]
  #
  # source://protocol-http2//lib/protocol/http2/frame.rb#120
  def flag_set?(mask); end

  # Returns the value of attribute flags.
  #
  # source://protocol-http2//lib/protocol/http2/frame.rb#82
  def flags; end

  # Sets the attribute flags
  #
  # @param value the value to set the attribute flags to.
  #
  # source://protocol-http2//lib/protocol/http2/frame.rb#82
  def flags=(_arg0); end

  # Generates common 9-byte frame header.
  # - http://tools.ietf.org/html/draft-ietf-httpbis-http2-16#section-4.1
  #
  # @return [String]
  #
  # source://protocol-http2//lib/protocol/http2/frame.rb#139
  def header; end

  # Provide a readable representation of the frame for debugging.
  #
  # source://protocol-http2//lib/protocol/http2/frame.rb#248
  def inspect; end

  # The generic frame header uses the following binary representation:
  #
  # +-----------------------------------------------+
  # +---------------+---------------+---------------+
  # +-+-------------+---------------+-------------------------------+
  # |R|                 Stream Identifier (31)                      |
  # +=+=============================================================+
  # +---------------------------------------------------------------+
  #
  # source://protocol-http2//lib/protocol/http2/frame.rb#80
  def length; end

  # The generic frame header uses the following binary representation:
  #
  # +-----------------------------------------------+
  # +---------------+---------------+---------------+
  # +-+-------------+---------------+-------------------------------+
  # |R|                 Stream Identifier (31)                      |
  # +=+=============================================================+
  # +---------------------------------------------------------------+
  #
  # source://protocol-http2//lib/protocol/http2/frame.rb#80
  def length=(_arg0); end

  # Pack payload data into the frame.
  #
  # source://protocol-http2//lib/protocol/http2/frame.rb#96
  def pack(payload, maximum_size: T.unsafe(nil)); end

  # Returns the value of attribute payload.
  #
  # source://protocol-http2//lib/protocol/http2/frame.rb#84
  def payload; end

  # Sets the attribute payload
  #
  # @param value the value to set the attribute payload to.
  #
  # source://protocol-http2//lib/protocol/http2/frame.rb#84
  def payload=(_arg0); end

  # Read the complete frame (header and payload) from a stream.
  #
  # source://protocol-http2//lib/protocol/http2/frame.rb#199
  def read(stream, maximum_frame_size = T.unsafe(nil)); end

  # Read the frame header from a stream.
  #
  # source://protocol-http2//lib/protocol/http2/frame.rb#174
  def read_header(stream); end

  # Read the frame payload from a stream.
  #
  # source://protocol-http2//lib/protocol/http2/frame.rb#186
  def read_payload(stream); end

  # Set specific flags on the frame.
  #
  # source://protocol-http2//lib/protocol/http2/frame.rb#107
  def set_flags(mask); end

  # Returns the value of attribute stream_id.
  #
  # source://protocol-http2//lib/protocol/http2/frame.rb#83
  def stream_id; end

  # Sets the attribute stream_id
  #
  # @param value the value to set the attribute stream_id to.
  #
  # source://protocol-http2//lib/protocol/http2/frame.rb#83
  def stream_id=(_arg0); end

  # Convert frame to array representation for comparison.
  #
  # source://protocol-http2//lib/protocol/http2/frame.rb#64
  def to_ary; end

  # Returns the value of attribute type.
  #
  # source://protocol-http2//lib/protocol/http2/frame.rb#81
  def type; end

  # Sets the attribute type
  #
  # @param value the value to set the attribute type to.
  #
  # source://protocol-http2//lib/protocol/http2/frame.rb#81
  def type=(_arg0); end

  # Unpack the frame payload data.
  #
  # source://protocol-http2//lib/protocol/http2/frame.rb#88
  def unpack; end

  # Check if the frame has a valid type identifier.
  #
  # @return [Boolean]
  #
  # source://protocol-http2//lib/protocol/http2/frame.rb#51
  def valid_type?; end

  # Write the complete frame (header and payload) to a stream.
  #
  # source://protocol-http2//lib/protocol/http2/frame.rb#224
  def write(stream); end

  # Write the frame header to a stream.
  #
  # source://protocol-http2//lib/protocol/http2/frame.rb#211
  def write_header(stream); end

  # Write the frame payload to a stream.
  #
  # source://protocol-http2//lib/protocol/http2/frame.rb#217
  def write_payload(stream); end

  class << self
    # Decodes common 9-byte header.
    #
    # source://protocol-http2//lib/protocol/http2/frame.rb#161
    def parse_header(buffer); end
  end
end

# source://protocol-http2//lib/protocol/http2/frame.rb#132
Protocol::HTTP2::Frame::HEADER_FORMAT = T.let(T.unsafe(nil), String)

# Used for generating 24-bit frame length:
#
# source://protocol-http2//lib/protocol/http2/frame.rb#34
Protocol::HTTP2::Frame::LENGTH_HISHIFT = T.let(T.unsafe(nil), Integer)

# source://protocol-http2//lib/protocol/http2/frame.rb#35
Protocol::HTTP2::Frame::LENGTH_LOMASK = T.let(T.unsafe(nil), Integer)

# source://protocol-http2//lib/protocol/http2/frame.rb#133
Protocol::HTTP2::Frame::STREAM_ID_MASK = T.let(T.unsafe(nil), Integer)

# The base class does not have any specific type index:
#
# source://protocol-http2//lib/protocol/http2/frame.rb#38
Protocol::HTTP2::Frame::TYPE = T.let(T.unsafe(nil), T.untyped)

# The absolute maximum bounds for the length field:
#
# source://protocol-http2//lib/protocol/http2/frame.rb#31
Protocol::HTTP2::Frame::VALID_LENGTH = T.let(T.unsafe(nil), Range)

# Stream Identifier cannot be bigger than this:
# https://http2.github.stream/http2-spec/#rfc.section.4.1
#
# source://protocol-http2//lib/protocol/http2/frame.rb#28
Protocol::HTTP2::Frame::VALID_STREAM_ID = T.let(T.unsafe(nil), Range)

# When the frame payload does not match expectations.
#
# source://protocol-http2//lib/protocol/http2/error.rb#95
class Protocol::HTTP2::FrameSizeError < ::Protocol::HTTP2::ProtocolError
  # Initialize a frame size error.
  #
  # @return [FrameSizeError] a new instance of FrameSizeError
  #
  # source://protocol-http2//lib/protocol/http2/error.rb#98
  def initialize(message); end
end

# Handles frame serialization and deserialization for HTTP/2 connections.
# This class manages the reading and writing of HTTP/2 frames to/from a stream.
#
# source://protocol-http2//lib/protocol/http2/framer.rb#47
class Protocol::HTTP2::Framer
  # Initialize a new framer with a stream and frame definitions.
  #
  # @return [Framer] a new instance of Framer
  #
  # source://protocol-http2//lib/protocol/http2/framer.rb#51
  def initialize(stream, frames = T.unsafe(nil)); end

  # Close the underlying stream.
  #
  # source://protocol-http2//lib/protocol/http2/framer.rb#62
  def close; end

  # Check if the underlying stream is closed.
  #
  # @return [Boolean]
  #
  # source://protocol-http2//lib/protocol/http2/framer.rb#68
  def closed?; end

  # Flush the underlying stream.
  #
  # source://protocol-http2//lib/protocol/http2/framer.rb#57
  def flush; end

  # Read and validate the HTTP/2 connection preface from the stream.
  #
  # source://protocol-http2//lib/protocol/http2/framer.rb#79
  def read_connection_preface; end

  # @raise if the underlying IO fails for some reason.
  # @return [Frame] the frame that has been read from the underlying IO.
  #
  # source://protocol-http2//lib/protocol/http2/framer.rb#91
  def read_frame(maximum_frame_size = T.unsafe(nil)); end

  # Read a frame header from the stream.
  #
  # @raise [EOFError]
  #
  # source://protocol-http2//lib/protocol/http2/framer.rb#123
  def read_header; end

  # Write the HTTP/2 connection preface to the stream.
  #
  # source://protocol-http2//lib/protocol/http2/framer.rb#73
  def write_connection_preface; end

  # Write a frame to the underlying IO.
  # After writing one or more frames, you should call flush to ensure the frames are sent to the remote peer.
  #
  # source://protocol-http2//lib/protocol/http2/framer.rb#112
  def write_frame(frame); end
end

# Represents a GOAWAY-related protocol error.
#
# source://protocol-http2//lib/protocol/http2/error.rb#91
class Protocol::HTTP2::GoawayError < ::Protocol::HTTP2::ProtocolError; end

# The GOAWAY frame is used to initiate shutdown of a connection or to signal serious error conditions. GOAWAY allows an endpoint to gracefully stop accepting new streams while still finishing processing of previously established streams. This enables administrative actions, like server maintenance.
#
# +-+-------------------------------------------------------------+
# |R|                  Last-Stream-ID (31)                        |
# +-+-------------------------------------------------------------+
# +---------------------------------------------------------------+
# +---------------------------------------------------------------+
#
# source://protocol-http2//lib/protocol/http2/goaway_frame.rb#20
class Protocol::HTTP2::GoawayFrame < ::Protocol::HTTP2::Frame
  # Apply this GOAWAY frame to a connection for processing.
  #
  # source://protocol-http2//lib/protocol/http2/goaway_frame.rb#50
  def apply(connection); end

  # Check if this frame applies to the connection level.
  #
  # @return [Boolean]
  #
  # source://protocol-http2//lib/protocol/http2/goaway_frame.rb#26
  def connection?; end

  # Pack GOAWAY frame data into payload.
  #
  # source://protocol-http2//lib/protocol/http2/goaway_frame.rb#44
  def pack(last_stream_id, error_code, data); end

  # Unpack the GOAWAY frame payload.
  #
  # source://protocol-http2//lib/protocol/http2/goaway_frame.rb#32
  def unpack; end
end

# source://protocol-http2//lib/protocol/http2/goaway_frame.rb#22
Protocol::HTTP2::GoawayFrame::FORMAT = T.let(T.unsafe(nil), String)

# source://protocol-http2//lib/protocol/http2/goaway_frame.rb#21
Protocol::HTTP2::GoawayFrame::TYPE = T.let(T.unsafe(nil), Integer)

# source://protocol-http2//lib/protocol/http2/reset_stream_frame.rb#23
Protocol::HTTP2::HTTP_1_1_REQUIRED = T.let(T.unsafe(nil), Integer)

# Raised if connection header is missing or invalid indicating that
# this is an invalid HTTP 2.0 request - no frames are emitted and the
# connection must be aborted.
#
# source://protocol-http2//lib/protocol/http2/error.rb#58
class Protocol::HTTP2::HandshakeError < ::Protocol::HTTP2::Error; end

# Represents a header processing error.
#
# source://protocol-http2//lib/protocol/http2/error.rb#104
class Protocol::HTTP2::HeaderError < ::Protocol::HTTP2::StreamClosed
  # Initialize a header error.
  #
  # @return [HeaderError] a new instance of HeaderError
  #
  # source://protocol-http2//lib/protocol/http2/error.rb#107
  def initialize(message); end
end

# The HEADERS frame is used to open a stream, and additionally carries a header block fragment. HEADERS frames can be sent on a stream in the "idle", "reserved (local)", "open", or "half-closed (remote)" state.
#
# +---------------+
# |Pad Length? (8)|
# +-+-------------+-----------------------------------------------+
# |E|                 Stream Dependency? (31)                     |
# +-+-------------+-----------------------------------------------+
# +-+-------------+-----------------------------------------------+
# +---------------------------------------------------------------+
# +---------------------------------------------------------------+
#
# source://protocol-http2//lib/protocol/http2/headers_frame.rb#26
class Protocol::HTTP2::HeadersFrame < ::Protocol::HTTP2::Frame
  include ::Protocol::HTTP2::Padded
  include ::Protocol::HTTP2::Continued

  # Apply this HEADERS frame to a connection for processing.
  #
  # source://protocol-http2//lib/protocol/http2/headers_frame.rb#70
  def apply(connection); end

  # Check if this frame ends the stream.
  #
  # @return [Boolean]
  #
  # source://protocol-http2//lib/protocol/http2/headers_frame.rb#39
  def end_stream?; end

  # Get a string representation of the headers frame.
  #
  # source://protocol-http2//lib/protocol/http2/headers_frame.rb#76
  def inspect; end

  # Pack header block data into the frame.
  #
  # source://protocol-http2//lib/protocol/http2/headers_frame.rb#60
  def pack(data, *arguments, **options); end

  # Check if this frame contains priority information.
  #
  # @return [Boolean]
  #
  # source://protocol-http2//lib/protocol/http2/headers_frame.rb#33
  def priority?; end

  # Unpack the header block fragment from the frame.
  #
  # source://protocol-http2//lib/protocol/http2/headers_frame.rb#45
  def unpack; end
end

# source://protocol-http2//lib/protocol/http2/headers_frame.rb#29
Protocol::HTTP2::HeadersFrame::TYPE = T.let(T.unsafe(nil), Integer)

# source://protocol-http2//lib/protocol/http2/reset_stream_frame.rb#22
Protocol::HTTP2::INADEQUATE_SECURITY = T.let(T.unsafe(nil), Integer)

# source://protocol-http2//lib/protocol/http2/reset_stream_frame.rb#12
Protocol::HTTP2::INTERNAL_ERROR = T.let(T.unsafe(nil), Integer)

# This is a window which efficiently maintains a desired capacity.
#
# source://protocol-http2//lib/protocol/http2/window.rb#97
class Protocol::HTTP2::LocalWindow < ::Protocol::HTTP2::Window
  # Initialize a local window with optional desired capacity.
  #
  # @return [LocalWindow] a new instance of LocalWindow
  #
  # source://protocol-http2//lib/protocol/http2/window.rb#101
  def initialize(capacity = T.unsafe(nil), desired: T.unsafe(nil)); end

  # The desired capacity of the window.
  #
  # source://protocol-http2//lib/protocol/http2/window.rb#110
  def desired; end

  # The desired capacity of the window.
  #
  # source://protocol-http2//lib/protocol/http2/window.rb#110
  def desired=(_arg0); end

  # Get a string representation of the local window.
  #
  # source://protocol-http2//lib/protocol/http2/window.rb#136
  def inspect; end

  # Check if the window is limited, considering desired capacity.
  #
  # @return [Boolean]
  #
  # source://protocol-http2//lib/protocol/http2/window.rb#125
  def limited?; end

  # Get the amount of window that should be reclaimed, considering desired capacity.
  #
  # source://protocol-http2//lib/protocol/http2/window.rb#114
  def wanted; end
end

# source://protocol-http2//lib/protocol/http2/frame.rb#18
Protocol::HTTP2::MAXIMUM_ALLOWED_FRAME_SIZE = T.let(T.unsafe(nil), Integer)

# source://protocol-http2//lib/protocol/http2/frame.rb#16
Protocol::HTTP2::MAXIMUM_ALLOWED_WINDOW_SIZE = T.let(T.unsafe(nil), Integer)

# source://protocol-http2//lib/protocol/http2/frame.rb#17
Protocol::HTTP2::MINIMUM_ALLOWED_FRAME_SIZE = T.let(T.unsafe(nil), Integer)

# source://protocol-http2//lib/protocol/http2/reset_stream_frame.rb#10
Protocol::HTTP2::NO_ERROR = T.let(T.unsafe(nil), Integer)

# source://protocol-http2//lib/protocol/http2/frame.rb#13
Protocol::HTTP2::PADDED = T.let(T.unsafe(nil), Integer)

# source://protocol-http2//lib/protocol/http2/frame.rb#14
Protocol::HTTP2::PRIORITY = T.let(T.unsafe(nil), Integer)

# source://protocol-http2//lib/protocol/http2/reset_stream_frame.rb#11
Protocol::HTTP2::PROTOCOL_ERROR = T.let(T.unsafe(nil), Integer)

# Certain frames can have padding:
# https://http2.github.io/http2-spec/#padding
#
# +---------------+
# |Pad Length? (8)|
# +---------------+-----------------------------------------------+
# +---------------------------------------------------------------+
# +---------------------------------------------------------------+
#
# Provides padding functionality for HTTP/2 frames.
# Padding can be used to obscure the actual size of frame payloads.
#
# source://protocol-http2//lib/protocol/http2/padded.rb#23
module Protocol::HTTP2::Padded
  # Pack data with optional padding into the frame.
  #
  # source://protocol-http2//lib/protocol/http2/padded.rb#34
  def pack(data, padding_size: T.unsafe(nil), maximum_size: T.unsafe(nil)); end

  # Check if the frame has padding enabled.
  #
  # @return [Boolean]
  #
  # source://protocol-http2//lib/protocol/http2/padded.rb#26
  def padded?; end

  # Unpack frame data, removing padding if present.
  #
  # source://protocol-http2//lib/protocol/http2/padded.rb#58
  def unpack; end
end

# Manages pending settings changes that haven't been acknowledged yet.
#
# source://protocol-http2//lib/protocol/http2/settings_frame.rb#157
class Protocol::HTTP2::PendingSettings
  # Initialize with current settings.
  #
  # @return [PendingSettings] a new instance of PendingSettings
  #
  # source://protocol-http2//lib/protocol/http2/settings_frame.rb#160
  def initialize(current = T.unsafe(nil)); end

  # Acknowledge the next set of pending changes.
  #
  # source://protocol-http2//lib/protocol/http2/settings_frame.rb#178
  def acknowledge; end

  # Append changes to the pending queue.
  #
  # source://protocol-http2//lib/protocol/http2/settings_frame.rb#172
  def append(changes); end

  # Returns the value of attribute current.
  #
  # source://protocol-http2//lib/protocol/http2/settings_frame.rb#167
  def current; end

  # Get the current CONNECT protocol enable setting.
  #
  # source://protocol-http2//lib/protocol/http2/settings_frame.rb#226
  def enable_connect_protocol; end

  # Get the current enable push setting.
  #
  # source://protocol-http2//lib/protocol/http2/settings_frame.rb#196
  def enable_push; end

  # Get the current header table size setting.
  #
  # source://protocol-http2//lib/protocol/http2/settings_frame.rb#190
  def header_table_size; end

  # Get the current initial window size setting.
  #
  # source://protocol-http2//lib/protocol/http2/settings_frame.rb#208
  def initial_window_size; end

  # Get the current maximum concurrent streams setting.
  #
  # source://protocol-http2//lib/protocol/http2/settings_frame.rb#202
  def maximum_concurrent_streams; end

  # Get the current maximum frame size setting.
  #
  # source://protocol-http2//lib/protocol/http2/settings_frame.rb#214
  def maximum_frame_size; end

  # Get the current maximum header list size setting.
  #
  # source://protocol-http2//lib/protocol/http2/settings_frame.rb#220
  def maximum_header_list_size; end

  # Returns the value of attribute pending.
  #
  # source://protocol-http2//lib/protocol/http2/settings_frame.rb#168
  def pending; end
end

# The PING frame is a mechanism for measuring a minimal round-trip time from the sender, as well as determining whether an idle connection is still functional. PING frames can be sent from any endpoint.
#
# +---------------------------------------------------------------+
# +---------------------------------------------------------------+
#
# source://protocol-http2//lib/protocol/http2/ping_frame.rb#46
class Protocol::HTTP2::PingFrame < ::Protocol::HTTP2::Frame
  include ::Protocol::HTTP2::Acknowledgement

  # Create an acknowledgement PING frame with the same payload.
  #
  # source://protocol-http2//lib/protocol/http2/ping_frame.rb#65
  def acknowledge; end

  # Apply this PING frame to a connection for processing.
  #
  # source://protocol-http2//lib/protocol/http2/ping_frame.rb#59
  def apply(connection); end

  # Check if this frame applies to the connection level.
  #
  # @return [Boolean]
  #
  # source://protocol-http2//lib/protocol/http2/ping_frame.rb#53
  def connection?; end

  # Read and validate the PING frame payload.
  #
  # source://protocol-http2//lib/protocol/http2/ping_frame.rb#76
  def read_payload(stream); end
end

# source://protocol-http2//lib/protocol/http2/ping_frame.rb#47
Protocol::HTTP2::PingFrame::TYPE = T.let(T.unsafe(nil), Integer)

# The PRIORITY_UPDATE frame is used by clients to signal the initial priority of a response, or to reprioritize a response or push stream. It carries the stream ID of the response and the priority in ASCII text, using the same representation as the Priority header field value.
#
# +-+-------------+-----------------------------------------------+
# |R|                 Prioritized Stream ID (31)                  |
# +-+-----------------------------+-------------------------------+
# +---------------------------------------------------------------+
#
# source://protocol-http2//lib/protocol/http2/priority_update_frame.rb#20
class Protocol::HTTP2::PriorityUpdateFrame < ::Protocol::HTTP2::Frame
  # Apply this PRIORITY_UPDATE frame to a connection for processing.
  #
  # source://protocol-http2//lib/protocol/http2/priority_update_frame.rb#44
  def apply(connection); end

  # Pack the prioritized stream ID and priority field value into the frame.
  #
  # source://protocol-http2//lib/protocol/http2/priority_update_frame.rb#38
  def pack(prioritized_stream_id, data, **options); end

  # Unpack the prioritized stream ID and priority field value.
  #
  # source://protocol-http2//lib/protocol/http2/priority_update_frame.rb#26
  def unpack; end
end

# source://protocol-http2//lib/protocol/http2/priority_update_frame.rb#22
Protocol::HTTP2::PriorityUpdateFrame::FORMAT = T.let(T.unsafe(nil), String)

# source://protocol-http2//lib/protocol/http2/priority_update_frame.rb#21
Protocol::HTTP2::PriorityUpdateFrame::TYPE = T.let(T.unsafe(nil), Integer)

# Raised by stream or connection handlers, results in GOAWAY frame
# which signals termination of the current connection. You *cannot*
# recover from this exception, or any exceptions subclassed from it.
#
# source://protocol-http2//lib/protocol/http2/error.rb#64
class Protocol::HTTP2::ProtocolError < ::Protocol::HTTP2::Error
  # Initialize a protocol error with message and error code.
  #
  # @return [ProtocolError] a new instance of ProtocolError
  #
  # source://protocol-http2//lib/protocol/http2/error.rb#68
  def initialize(message, code = T.unsafe(nil)); end

  # Returns the value of attribute code.
  #
  # source://protocol-http2//lib/protocol/http2/error.rb#74
  def code; end
end

# The PUSH_PROMISE frame is used to notify the peer endpoint in advance of streams the sender intends to initiate. The PUSH_PROMISE frame includes the unsigned 31-bit identifier of the stream the endpoint plans to create along with a set of headers that provide additional context for the stream.
#
# +---------------+
# |Pad Length? (8)|
# +-+-------------+-----------------------------------------------+
# |R|                  Promised Stream ID (31)                    |
# +-+-----------------------------+-------------------------------+
# +---------------------------------------------------------------+
# +---------------------------------------------------------------+
#
# source://protocol-http2//lib/protocol/http2/push_promise_frame.rb#24
class Protocol::HTTP2::PushPromiseFrame < ::Protocol::HTTP2::Frame
  include ::Protocol::HTTP2::Padded
  include ::Protocol::HTTP2::Continued

  # Apply this PUSH_PROMISE frame to a connection for processing.
  #
  # source://protocol-http2//lib/protocol/http2/push_promise_frame.rb#51
  def apply(connection); end

  # Pack the promised stream ID and header block data into the frame.
  #
  # source://protocol-http2//lib/protocol/http2/push_promise_frame.rb#45
  def pack(stream_id, data, *arguments, **options); end

  # Unpack the promised stream ID and header block fragment.
  #
  # source://protocol-http2//lib/protocol/http2/push_promise_frame.rb#32
  def unpack; end
end

# source://protocol-http2//lib/protocol/http2/push_promise_frame.rb#28
Protocol::HTTP2::PushPromiseFrame::FORMAT = T.let(T.unsafe(nil), String)

# source://protocol-http2//lib/protocol/http2/push_promise_frame.rb#27
Protocol::HTTP2::PushPromiseFrame::TYPE = T.let(T.unsafe(nil), Integer)

# source://protocol-http2//lib/protocol/http2/reset_stream_frame.rb#17
Protocol::HTTP2::REFUSED_STREAM = T.let(T.unsafe(nil), Integer)

# The RST_STREAM frame allows for immediate termination of a stream. RST_STREAM is sent to request cancellation of a stream or to indicate that an error condition has occurred.
#
# +---------------------------------------------------------------+
# +---------------------------------------------------------------+
#
# source://protocol-http2//lib/protocol/http2/reset_stream_frame.rb#31
class Protocol::HTTP2::ResetStreamFrame < ::Protocol::HTTP2::Frame
  # Apply this RST_STREAM frame to a connection for processing.
  #
  # source://protocol-http2//lib/protocol/http2/reset_stream_frame.rb#50
  def apply(connection); end

  # Pack an error code into the frame payload.
  #
  # source://protocol-http2//lib/protocol/http2/reset_stream_frame.rb#43
  def pack(error_code = T.unsafe(nil)); end

  # Read and validate the RST_STREAM frame payload.
  #
  # source://protocol-http2//lib/protocol/http2/reset_stream_frame.rb#57
  def read_payload(stream); end

  # Unpack the error code from the frame payload.
  #
  # source://protocol-http2//lib/protocol/http2/reset_stream_frame.rb#37
  def unpack; end
end

# source://protocol-http2//lib/protocol/http2/reset_stream_frame.rb#33
Protocol::HTTP2::ResetStreamFrame::FORMAT = T.let(T.unsafe(nil), String)

# source://protocol-http2//lib/protocol/http2/reset_stream_frame.rb#32
Protocol::HTTP2::ResetStreamFrame::TYPE = T.let(T.unsafe(nil), Integer)

# source://protocol-http2//lib/protocol/http2/reset_stream_frame.rb#15
Protocol::HTTP2::STREAM_CLOSED = T.let(T.unsafe(nil), Integer)

# Represents an HTTP/2 server connection.
# Manages server-side protocol semantics including stream ID allocation,
# connection preface handling, and settings negotiation.
#
# source://protocol-http2//lib/protocol/http2/server.rb#13
class Protocol::HTTP2::Server < ::Protocol::HTTP2::Connection
  # Initialize a new HTTP/2 server connection.
  #
  # @return [Server] a new instance of Server
  #
  # source://protocol-http2//lib/protocol/http2/server.rb#16
  def initialize(framer); end

  # Servers cannot accept push promise streams from clients.
  #
  # @raise [ProtocolError]
  #
  # source://protocol-http2//lib/protocol/http2/server.rb#67
  def accept_push_promise_stream(stream_id, &block); end

  # Check if server push is enabled by the client.
  #
  # @return [Boolean]
  #
  # source://protocol-http2//lib/protocol/http2/server.rb#73
  def enable_push?; end

  # Check if the given stream ID represents a locally-initiated stream.
  # Server streams have even numbered IDs.
  #
  # @return [Boolean]
  #
  # source://protocol-http2//lib/protocol/http2/server.rb#24
  def local_stream_id?(id); end

  # Read the HTTP/2 connection preface from the client and send initial settings.
  # This must be called once when the connection is first established.
  #
  # source://protocol-http2//lib/protocol/http2/server.rb#48
  def read_connection_preface(settings = T.unsafe(nil)); end

  # Check if the given stream ID represents a remotely-initiated stream.
  # Client streams have odd numbered IDs.
  #
  # @return [Boolean]
  #
  # source://protocol-http2//lib/protocol/http2/server.rb#32
  def remote_stream_id?(id); end

  # Check if the given stream ID is valid for remote initiation.
  # Client-initiated streams must have odd numbered IDs.
  #
  # @return [Boolean]
  #
  # source://protocol-http2//lib/protocol/http2/server.rb#40
  def valid_remote_stream_id?(stream_id); end
end

# HTTP/2 connection settings container and management.
#
# source://protocol-http2//lib/protocol/http2/settings_frame.rb#11
class Protocol::HTTP2::Settings
  # Initialize settings with default values from HTTP/2 specification.
  #
  # @return [Settings] a new instance of Settings
  #
  # source://protocol-http2//lib/protocol/http2/settings_frame.rb#35
  def initialize; end

  # Returns the value of attribute enable_connect_protocol.
  #
  # source://protocol-http2//lib/protocol/http2/settings_frame.rb#107
  def enable_connect_protocol; end

  # Set the CONNECT protocol enable flag.
  #
  # source://protocol-http2//lib/protocol/http2/settings_frame.rb#112
  def enable_connect_protocol=(value); end

  # Check if CONNECT protocol is enabled.
  #
  # @return [Boolean]
  #
  # source://protocol-http2//lib/protocol/http2/settings_frame.rb#122
  def enable_connect_protocol?; end

  # This setting can be used to disable server push. An endpoint MUST NOT send a PUSH_PROMISE frame if it receives this parameter set to a value of 0.
  #
  # source://protocol-http2//lib/protocol/http2/settings_frame.rb#52
  def enable_push; end

  # Set the server push enable flag.
  #
  # source://protocol-http2//lib/protocol/http2/settings_frame.rb#57
  def enable_push=(value); end

  # Check if server push is enabled.
  #
  # @return [Boolean]
  #
  # source://protocol-http2//lib/protocol/http2/settings_frame.rb#67
  def enable_push?; end

  # Allows the sender to inform the remote endpoint of the maximum size of the header compression table used to decode header blocks, in octets.
  #
  # source://protocol-http2//lib/protocol/http2/settings_frame.rb#49
  def header_table_size; end

  # Allows the sender to inform the remote endpoint of the maximum size of the header compression table used to decode header blocks, in octets.
  #
  # source://protocol-http2//lib/protocol/http2/settings_frame.rb#49
  def header_table_size=(_arg0); end

  # Indicates the sender's initial window size (in octets) for stream-level flow control.
  #
  # source://protocol-http2//lib/protocol/http2/settings_frame.rb#75
  def initial_window_size; end

  # Set the initial window size for stream-level flow control.
  #
  # source://protocol-http2//lib/protocol/http2/settings_frame.rb#80
  def initial_window_size=(value); end

  # Indicates the maximum number of concurrent streams that the sender will allow.
  #
  # source://protocol-http2//lib/protocol/http2/settings_frame.rb#72
  def maximum_concurrent_streams; end

  # Indicates the maximum number of concurrent streams that the sender will allow.
  #
  # source://protocol-http2//lib/protocol/http2/settings_frame.rb#72
  def maximum_concurrent_streams=(_arg0); end

  # Indicates the size of the largest frame payload that the sender is willing to receive, in octets.
  #
  # source://protocol-http2//lib/protocol/http2/settings_frame.rb#89
  def maximum_frame_size; end

  # Set the maximum frame size the sender is willing to receive.
  #
  # source://protocol-http2//lib/protocol/http2/settings_frame.rb#94
  def maximum_frame_size=(value); end

  # This advisory setting informs a peer of the maximum size of header list that the sender is prepared to accept, in octets.
  #
  # source://protocol-http2//lib/protocol/http2/settings_frame.rb#105
  def maximum_header_list_size; end

  # This advisory setting informs a peer of the maximum size of header list that the sender is prepared to accept, in octets.
  #
  # source://protocol-http2//lib/protocol/http2/settings_frame.rb#105
  def maximum_header_list_size=(_arg0); end

  # Returns the value of attribute no_rfc7540_priorities.
  #
  # source://protocol-http2//lib/protocol/http2/settings_frame.rb#126
  def no_rfc7540_priorities; end

  # Set the RFC 7540 priorities disable flag.
  #
  # source://protocol-http2//lib/protocol/http2/settings_frame.rb#131
  def no_rfc7540_priorities=(value); end

  # Check if RFC 7540 priorities are disabled.
  #
  # @return [Boolean]
  #
  # source://protocol-http2//lib/protocol/http2/settings_frame.rb#141
  def no_rfc7540_priorities?; end

  # Update settings with a hash of changes.
  #
  # source://protocol-http2//lib/protocol/http2/settings_frame.rb#147
  def update(changes); end
end

# source://protocol-http2//lib/protocol/http2/settings_frame.rb#21
Protocol::HTTP2::Settings::ASSIGN = T.let(T.unsafe(nil), Array)

# source://protocol-http2//lib/protocol/http2/settings_frame.rb#18
Protocol::HTTP2::Settings::ENABLE_CONNECT_PROTOCOL = T.let(T.unsafe(nil), Integer)

# source://protocol-http2//lib/protocol/http2/settings_frame.rb#13
Protocol::HTTP2::Settings::ENABLE_PUSH = T.let(T.unsafe(nil), Integer)

# source://protocol-http2//lib/protocol/http2/settings_frame.rb#12
Protocol::HTTP2::Settings::HEADER_TABLE_SIZE = T.let(T.unsafe(nil), Integer)

# source://protocol-http2//lib/protocol/http2/settings_frame.rb#15
Protocol::HTTP2::Settings::INITIAL_WINDOW_SIZE = T.let(T.unsafe(nil), Integer)

# source://protocol-http2//lib/protocol/http2/settings_frame.rb#14
Protocol::HTTP2::Settings::MAXIMUM_CONCURRENT_STREAMS = T.let(T.unsafe(nil), Integer)

# source://protocol-http2//lib/protocol/http2/settings_frame.rb#16
Protocol::HTTP2::Settings::MAXIMUM_FRAME_SIZE = T.let(T.unsafe(nil), Integer)

# source://protocol-http2//lib/protocol/http2/settings_frame.rb#17
Protocol::HTTP2::Settings::MAXIMUM_HEADER_LIST_SIZE = T.let(T.unsafe(nil), Integer)

# source://protocol-http2//lib/protocol/http2/settings_frame.rb#19
Protocol::HTTP2::Settings::NO_RFC7540_PRIORITIES = T.let(T.unsafe(nil), Integer)

# The SETTINGS frame conveys configuration parameters that affect how endpoints communicate, such as preferences and constraints on peer behavior. The SETTINGS frame is also used to acknowledge the receipt of those parameters. Individually, a SETTINGS parameter can also be referred to as a "setting".
#
# +-------------------------------+
# +-------------------------------+-------------------------------+
# +---------------------------------------------------------------+
#
# source://protocol-http2//lib/protocol/http2/settings_frame.rb#239
class Protocol::HTTP2::SettingsFrame < ::Protocol::HTTP2::Frame
  include ::Protocol::HTTP2::Acknowledgement

  # Apply this SETTINGS frame to a connection for processing.
  #
  # source://protocol-http2//lib/protocol/http2/settings_frame.rb#270
  def apply(connection); end

  # Check if this frame applies to the connection level.
  #
  # @return [Boolean]
  #
  # source://protocol-http2//lib/protocol/http2/settings_frame.rb#247
  def connection?; end

  # Pack settings parameters into the frame payload.
  #
  # source://protocol-http2//lib/protocol/http2/settings_frame.rb#264
  def pack(settings = T.unsafe(nil)); end

  # Read and validate the SETTINGS frame payload.
  #
  # source://protocol-http2//lib/protocol/http2/settings_frame.rb#278
  def read_payload(stream); end

  # Unpack settings parameters from the frame payload.
  #
  # source://protocol-http2//lib/protocol/http2/settings_frame.rb#253
  def unpack; end
end

# source://protocol-http2//lib/protocol/http2/settings_frame.rb#241
Protocol::HTTP2::SettingsFrame::FORMAT = T.let(T.unsafe(nil), String)

# source://protocol-http2//lib/protocol/http2/settings_frame.rb#240
Protocol::HTTP2::SettingsFrame::TYPE = T.let(T.unsafe(nil), Integer)

# A single HTTP/2 connection can multiplex multiple streams in parallel:
# multiple requests and responses can be in flight simultaneously and stream
# data can be interleaved and prioritized.
#
# This class encapsulates all of the state, transition, flow-control, and
# error management as defined by the HTTP 2.0 specification. All you have
# to do is subscribe to appropriate events (marked with ":" prefix in
# diagram below) and provide your application logic to handle request
# and response processing.
#
# ```
#                          
#                  send PP          recv PP
#                 idle  
#                                           
#                                   
#                             
#                             send H /            
#  reserved            recv H     reserved 
#        (local)                        (remote)       
#                                  
#                                               
#                recv ES          send ES               
#    send H      open      recv H   
#                                                     
#                                             
#                                  
#          half                           half         
#         closed             send R /    closed        
#        (remote)            recv R     (local)        
#                                  
#                                                        
#             send ES /             recv ES /            
#             send R /               send R /            
#             recv R        recv R              
#  send R /            send R / 
#  recv R                  closed                recv R   
#         
#                          
# ```
#
# - `send`: endpoint sends this frame
# - `recv`: endpoint receives this frame
#
# - H:  HEADERS frame (with implied CONTINUATIONs)
# - PP: PUSH_PROMISE frame (with implied CONTINUATIONs)
# - ES: END_STREAM flag
# - R:  RST_STREAM frame
#
# State transition methods use a trailing "!".
#
# source://protocol-http2//lib/protocol/http2/stream.rb#60
class Protocol::HTTP2::Stream
  include ::Protocol::HTTP2::FlowControlled

  # Initialize a new stream.
  #
  # @return [Stream] a new instance of Stream
  #
  # source://protocol-http2//lib/protocol/http2/stream.rb#79
  def initialize(connection, id, state = T.unsafe(nil)); end

  # Override this function to implement your own push promise logic.
  #
  # source://protocol-http2//lib/protocol/http2/stream.rb#444
  def accept_push_promise_stream(stream_id, headers); end

  # Check if the stream is active (not idle or closed).
  #
  # @return [Boolean]
  #
  # source://protocol-http2//lib/protocol/http2/stream.rb#120
  def active?; end

  # Transition directly to closed state. Do not pass go, do not collect $200.
  # This method should only be used by `Connection#close`.
  #
  # source://protocol-http2//lib/protocol/http2/stream.rb#132
  def close(error = T.unsafe(nil)); end

  # Transition the stream into the closed state.
  #
  # source://protocol-http2//lib/protocol/http2/stream.rb#248
  def close!(error_code = T.unsafe(nil)); end

  # The stream has been closed. If closed due to a stream reset, the error will be set.
  #
  # source://protocol-http2//lib/protocol/http2/stream.rb#243
  def closed(error = T.unsafe(nil)); end

  # Check if the stream is closed.
  #
  # @return [Boolean]
  #
  # source://protocol-http2//lib/protocol/http2/stream.rb#126
  def closed?; end

  # The connection this stream belongs to.
  #
  # source://protocol-http2//lib/protocol/http2/stream.rb#92
  def connection; end

  # Consume from the remote window for both stream and connection.
  #
  # source://protocol-http2//lib/protocol/http2/stream.rb#191
  def consume_remote_window(frame); end

  # Override this function to implement your own push promise logic.
  #
  # source://protocol-http2//lib/protocol/http2/stream.rb#422
  def create_push_promise_stream(headers); end

  # Stream ID (odd for client initiated streams, even otherwise).
  #
  # source://protocol-http2//lib/protocol/http2/stream.rb#95
  def id; end

  # Ignore data frame when in an invalid state.
  #
  # source://protocol-http2//lib/protocol/http2/stream.rb#331
  def ignore_data(frame); end

  # Get a string representation of the stream.
  #
  # source://protocol-http2//lib/protocol/http2/stream.rb#462
  def inspect; end

  # Returns the value of attribute local_window.
  #
  # source://protocol-http2//lib/protocol/http2/stream.rb#100
  def local_window; end

  # Get the maximum frame size for this stream.
  #
  # source://protocol-http2//lib/protocol/http2/stream.rb#108
  def maximum_frame_size; end

  # Open the stream by transitioning from idle to open state.
  #
  # source://protocol-http2//lib/protocol/http2/stream.rb#232
  def open!; end

  # Returns the value of attribute priority.
  #
  # source://protocol-http2//lib/protocol/http2/stream.rb#104
  def priority; end

  # Sets the attribute priority
  #
  # @param value the value to set the attribute priority to.
  #
  # source://protocol-http2//lib/protocol/http2/stream.rb#104
  def priority=(_arg0); end

  # @return [String] the data that was received.
  #
  # source://protocol-http2//lib/protocol/http2/stream.rb#325
  def process_data(frame); end

  # Process headers frame and decode the header block.
  #
  # source://protocol-http2//lib/protocol/http2/stream.rb#279
  def process_headers(frame); end

  # DATA frames are subject to flow control and can only be sent when a stream is in the "open" or "half-closed (remote)" state.  The entire DATA frame payload is included in flow control, including the Pad Length and Padding fields if present.  If a DATA frame is received whose stream is not in "open" or "half-closed (local)" state, the recipient MUST respond with a stream error of type STREAM_CLOSED.
  #
  # source://protocol-http2//lib/protocol/http2/stream.rb#336
  def receive_data(frame); end

  # Receive and process a headers frame on this stream.
  #
  # source://protocol-http2//lib/protocol/http2/stream.rb#292
  def receive_headers(frame); end

  # Receive and process a PUSH_PROMISE frame on this stream.
  #
  # source://protocol-http2//lib/protocol/http2/stream.rb#450
  def receive_push_promise(frame); end

  # Receive and process a RST_STREAM frame on this stream.
  #
  # source://protocol-http2//lib/protocol/http2/stream.rb#365
  def receive_reset_stream(frame); end

  # Returns the value of attribute remote_window.
  #
  # source://protocol-http2//lib/protocol/http2/stream.rb#101
  def remote_window; end

  # Transition stream to reserved local state.
  #
  # source://protocol-http2//lib/protocol/http2/stream.rb#398
  def reserved_local!; end

  # Transition stream to reserved remote state.
  #
  # source://protocol-http2//lib/protocol/http2/stream.rb#411
  def reserved_remote!; end

  # Send data over this stream.
  #
  # source://protocol-http2//lib/protocol/http2/stream.rb#211
  def send_data(*arguments, **options); end

  # The HEADERS frame is used to open a stream, and additionally carries a header block fragment. HEADERS frames can be sent on a stream in the "idle", "reserved (local)", "open", or "half-closed (remote)" state.
  #
  # source://protocol-http2//lib/protocol/http2/stream.rb#159
  def send_headers(*arguments); end

  # HEADERS frames can be sent on a stream in the "idle", "reserved (local)", "open", or "half-closed (remote)" state. Despite it's name, it can also be used for trailers.
  #
  # @return [Boolean]
  #
  # source://protocol-http2//lib/protocol/http2/stream.rb#140
  def send_headers?; end

  # Server push is semantically equivalent to a server responding to a request; however, in this case, that request is also sent by the server, as a PUSH_PROMISE frame.
  #
  # source://protocol-http2//lib/protocol/http2/stream.rb#428
  def send_push_promise(headers); end

  # Send a RST_STREAM frame to reset this stream.
  #
  # source://protocol-http2//lib/protocol/http2/stream.rb#263
  def send_reset_stream(error_code = T.unsafe(nil)); end

  # Stream state, e.g. `idle`, `closed`.
  #
  # source://protocol-http2//lib/protocol/http2/stream.rb#98
  def state; end

  # Stream state, e.g. `idle`, `closed`.
  #
  # source://protocol-http2//lib/protocol/http2/stream.rb#98
  def state=(_arg0); end

  # Write a frame to the connection for this stream.
  #
  # source://protocol-http2//lib/protocol/http2/stream.rb#114
  def write_frame(frame); end

  protected

  # source://protocol-http2//lib/protocol/http2/stream.rb#286
  def ignore_headers(frame); end

  private

  # source://protocol-http2//lib/protocol/http2/stream.rb#197
  def write_data(data, flags = T.unsafe(nil), **options); end

  # source://protocol-http2//lib/protocol/http2/stream.rb#144
  def write_headers(headers, flags = T.unsafe(nil)); end

  # A normal request is client request -> server response -> client.
  # A push promise is server request -> client -> server response -> client.
  # The server generates the same set of headers as if the client was sending a request, and sends these to the client. The client can reject the request by resetting the (new) stream. Otherwise, the server will start sending a response as if the client had send the request.
  #
  # source://protocol-http2//lib/protocol/http2/stream.rb#381
  def write_push_promise(stream_id, headers, flags = T.unsafe(nil), **options); end

  class << self
    # Create a new stream and add it to the connection.
    #
    # source://protocol-http2//lib/protocol/http2/stream.rb#67
    def create(connection, id); end
  end
end

# Represents an error for operations on closed streams.
#
# source://protocol-http2//lib/protocol/http2/error.rb#82
class Protocol::HTTP2::StreamClosed < ::Protocol::HTTP2::StreamError
  # Initialize a stream closed error.
  #
  # @return [StreamClosed] a new instance of StreamClosed
  #
  # source://protocol-http2//lib/protocol/http2/error.rb#85
  def initialize(message); end
end

# Represents an error specific to stream operations.
#
# source://protocol-http2//lib/protocol/http2/error.rb#78
class Protocol::HTTP2::StreamError < ::Protocol::HTTP2::ProtocolError; end

# source://protocol-http2//lib/protocol/http2/reset_stream_frame.rb#14
Protocol::HTTP2::TIMEOUT = T.let(T.unsafe(nil), Integer)

# Flow control window for managing HTTP/2 data flow.
#
# source://protocol-http2//lib/protocol/http2/window.rb#9
class Protocol::HTTP2::Window
  # Initialize a new flow control window.
  #
  # @return [Window] a new instance of Window
  #
  # source://protocol-http2//lib/protocol/http2/window.rb#15
  def initialize(capacity = T.unsafe(nil)); end

  # Returns the value of attribute available.
  #
  # source://protocol-http2//lib/protocol/http2/window.rb#52
  def available; end

  # Check if there is available window capacity.
  #
  # @return [Boolean]
  #
  # source://protocol-http2//lib/protocol/http2/window.rb#56
  def available?; end

  # Returns the value of attribute capacity.
  #
  # source://protocol-http2//lib/protocol/http2/window.rb#30
  def capacity; end

  # When the value of SETTINGS_INITIAL_WINDOW_SIZE changes, a receiver MUST adjust the size of all stream flow-control windows that it maintains by the difference between the new value and the old value.
  #
  # source://protocol-http2//lib/protocol/http2/window.rb#33
  def capacity=(value); end

  # Consume a specific amount from the available window.
  #
  # source://protocol-http2//lib/protocol/http2/window.rb#47
  def consume(amount); end

  # Expand the window by a specific amount.
  #
  # source://protocol-http2//lib/protocol/http2/window.rb#63
  def expand(amount); end

  # The window is completely full?
  #
  # @return [Boolean]
  #
  # source://protocol-http2//lib/protocol/http2/window.rb#25
  def full?; end

  # Get a string representation of the window.
  #
  # source://protocol-http2//lib/protocol/http2/window.rb#89
  def inspect; end

  # Check if the window is limited and needs updating.
  #
  # @return [Boolean]
  #
  # source://protocol-http2//lib/protocol/http2/window.rb#83
  def limited?; end

  # Get a string representation of the window.
  #
  # source://protocol-http2//lib/protocol/http2/window.rb#93
  def to_s; end

  # Returns the value of attribute used.
  #
  # source://protocol-http2//lib/protocol/http2/window.rb#29
  def used; end

  # Get the amount of window that should be reclaimed.
  #
  # source://protocol-http2//lib/protocol/http2/window.rb#77
  def wanted; end
end

# When an HTTP/2 connection is first established, new streams are created with an initial flow-control window size of 65,535 octets. The connection flow-control window is also 65,535 octets.
#
# source://protocol-http2//lib/protocol/http2/window.rb#11
Protocol::HTTP2::Window::DEFAULT_CAPACITY = T.let(T.unsafe(nil), Integer)

# The WINDOW_UPDATE frame is used to implement flow control.
#
# +-+-------------------------------------------------------------+
# |R|              Window Size Increment (31)                     |
# +-+-------------------------------------------------------------+
#
# source://protocol-http2//lib/protocol/http2/window_update_frame.rb#17
class Protocol::HTTP2::WindowUpdateFrame < ::Protocol::HTTP2::Frame
  # Apply this WINDOW_UPDATE frame to a connection for processing.
  #
  # source://protocol-http2//lib/protocol/http2/window_update_frame.rb#46
  def apply(connection); end

  # Pack a window size increment into the frame.
  #
  # source://protocol-http2//lib/protocol/http2/window_update_frame.rb#23
  def pack(window_size_increment); end

  # Read and validate the WINDOW_UPDATE frame payload.
  #
  # source://protocol-http2//lib/protocol/http2/window_update_frame.rb#36
  def read_payload(stream); end

  # Unpack the window size increment from the frame payload.
  #
  # source://protocol-http2//lib/protocol/http2/window_update_frame.rb#29
  def unpack; end
end

# source://protocol-http2//lib/protocol/http2/window_update_frame.rb#19
Protocol::HTTP2::WindowUpdateFrame::FORMAT = T.let(T.unsafe(nil), String)

# source://protocol-http2//lib/protocol/http2/window_update_frame.rb#18
Protocol::HTTP2::WindowUpdateFrame::TYPE = T.let(T.unsafe(nil), Integer)
