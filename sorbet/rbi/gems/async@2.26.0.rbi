# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `async` gem.
# Please instead update this file by running `bin/tapioca gem async`.


# Asynchronous programming framework.
#
# source://async//lib/async/version.rb#6
module Async; end

# A general purpose synchronisation primitive, which allows one task to wait for a number of other tasks to complete. It can be used in conjunction with {Semaphore}.
#
# source://async//lib/async/barrier.rb#14
class Async::Barrier
  # Initialize the barrier.
  #
  # @return [Barrier] a new instance of Barrier
  #
  # source://async//lib/async/barrier.rb#18
  def initialize(parent: T.unsafe(nil)); end

  # Execute a child task and add it to the barrier.
  #
  # source://async//lib/async/barrier.rb#45
  def async(*arguments, parent: T.unsafe(nil), **options, &block); end

  # Whether there are any tasks being held by the barrier.
  #
  # @return [Boolean]
  #
  # source://async//lib/async/barrier.rb#59
  def empty?; end

  # Number of tasks being held by the barrier.
  #
  # source://async//lib/async/barrier.rb#36
  def size; end

  # Stop all tasks held by the barrier.
  #
  # source://async//lib/async/barrier.rb#91
  def stop; end

  # All tasks which have been invoked into the barrier.
  #
  # source://async//lib/async/barrier.rb#41
  def tasks; end

  # Wait for all tasks to complete by invoking {Task#wait} on each waiting task, which may raise an error. As long as the task has completed, it will be removed from the barrier.
  #
  # source://async//lib/async/barrier.rb#68
  def wait; end
end

# source://async//lib/async/barrier.rb#25
class Async::Barrier::TaskNode < ::Async::List::Node
  # @return [TaskNode] a new instance of TaskNode
  #
  # source://async//lib/async/barrier.rb#26
  def initialize(task); end

  # Returns the value of attribute task.
  #
  # source://async//lib/async/barrier.rb#30
  def task; end
end

# A list of children tasks.
#
# source://async//lib/async/node.rb#14
class Async::Children < ::Async::List
  # Create an empty list of children tasks.
  #
  # @return [Children] a new instance of Children
  #
  # source://async//lib/async/node.rb#16
  def initialize; end

  # Adjust the number of transient children, assuming it has changed.
  #
  # Despite being public, this is not intended to be called directly. It is used internally by {Node#transient=}.
  #
  # source://async//lib/async/node.rb#42
  def adjust_transient_count(transient); end

  # Whether all children are considered finished. Ignores transient children.
  #
  # @return [Boolean]
  #
  # source://async//lib/async/node.rb#28
  def finished?; end

  # Whether the children is empty, preserved for compatibility.
  #
  # @return [Boolean]
  #
  # source://async//lib/async/node.rb#33
  def nil?; end

  # Some children may be marked as transient. Transient children do not prevent the parent from finishing.
  #
  # @return [Boolean]
  #
  # source://async//lib/async/node.rb#23
  def transients?; end

  private

  # source://async//lib/async/node.rb#52
  def added(node); end

  # source://async//lib/async/node.rb#60
  def removed(node); end
end

# A convenient wrapper around the internal monotonic clock.
#
# source://async//lib/async/clock.rb#9
class Async::Clock
  # Create a new clock with the initial total time.
  #
  # @return [Clock] a new instance of Clock
  #
  # source://async//lib/async/clock.rb#34
  def initialize(total = T.unsafe(nil)); end

  # Reset the total elapsed time. If the clock is currently running, reset the start time to now.
  #
  # source://async//lib/async/clock.rb#66
  def reset!; end

  # Start measuring a duration.
  #
  # source://async//lib/async/clock.rb#40
  def start!; end

  # Stop measuring a duration and append the duration to the current total.
  #
  # source://async//lib/async/clock.rb#45
  def stop!; end

  # The total elapsed time including any current duration.
  #
  # source://async//lib/async/clock.rb#55
  def total; end

  class << self
    # Measure the execution of a block of code.
    #
    # source://async//lib/async/clock.rb#18
    def measure; end

    # Get the current elapsed monotonic time.
    #
    # source://async//lib/async/clock.rb#11
    def now; end

    # Start measuring elapsed time from now.
    #
    # source://async//lib/async/clock.rb#28
    def start; end
  end
end

# A synchronization primitive, which allows fibers to wait until a particular condition is (edge) triggered.
#
# source://async//lib/async/condition.rb#13
class Async::Condition
  # Create a new condition.
  #
  # @return [Condition] a new instance of Condition
  #
  # source://async//lib/async/condition.rb#15
  def initialize; end

  # @deprecated Replaced by {#waiting?}
  # @return [Boolean]
  #
  # source://async//lib/async/condition.rb#44
  def empty?; end

  # Signal to a given task that it should resume operations.
  #
  # source://async//lib/async/condition.rb#57
  def signal(value = T.unsafe(nil)); end

  # Queue up the current fiber and wait on yielding the task.
  #
  # source://async//lib/async/condition.rb#37
  def wait; end

  # @return [Boolean]
  #
  # source://async//lib/async/condition.rb#51
  def waiting?; end

  protected

  # source://async//lib/async/condition.rb#71
  def exchange; end
end

# source://async//lib/async/condition.rb#19
class Async::Condition::FiberNode < ::Async::List::Node
  # @return [FiberNode] a new instance of FiberNode
  #
  # source://async//lib/async/condition.rb#20
  def initialize(fiber); end

  # @return [Boolean]
  #
  # source://async//lib/async/condition.rb#28
  def alive?; end

  # source://async//lib/async/condition.rb#24
  def transfer(*arguments); end
end

# A queue which limits the number of items that can be enqueued.
#
# source://async//lib/async/queue.rb#135
class Async::LimitedQueue < ::Async::Queue
  # Create a new limited queue.
  #
  # @return [LimitedQueue] a new instance of LimitedQueue
  #
  # source://async//lib/async/queue.rb#147
  def initialize(limit = T.unsafe(nil), full: T.unsafe(nil), **options); end

  # Close the queue, causing all waiting tasks to return `nil`. Any subsequent calls to {enqueue} will raise an exception.
  # Also signals all tasks waiting for the queue to be full.
  #
  # source://async//lib/async/queue.rb#159
  def close; end

  # Remove and return the next item from the queue.
  #
  # If the queue is empty, this method will block until an item is available.
  #
  # source://async//lib/async/queue.rb#212
  def dequeue; end

  # Add multiple items to the queue.
  #
  # If the queue is full, this method will block until there is space available.
  #
  # source://async//lib/async/queue.rb#190
  def enqueue(*items); end

  # Returns the value of attribute limit.
  #
  # source://async//lib/async/queue.rb#155
  def limit; end

  # @return [Boolean]
  #
  # source://async//lib/async/queue.rb#168
  def limited?; end

  # Add an item to the queue.
  #
  # If the queue is full, this method will block until there is space available.
  #
  # source://async//lib/async/queue.rb#177
  def push(item); end

  class << self
    # @private This exists purely for emitting a warning.
    #
    # source://async//lib/async/queue.rb#137
    def new(*_arg0, **_arg1, &_arg2); end
  end
end

# A general doublely linked list. This is used internally by {Async::Barrier} and {Async::Condition} to manage child tasks.
#
# source://async//lib/async/list.rb#8
class Async::List
  # Initialize a new, empty, list.
  #
  # @return [List] a new instance of List
  #
  # source://async//lib/async/list.rb#10
  def initialize; end

  # A callback that is invoked when an item is added to the list.
  #
  # source://async//lib/async/list.rb#50
  def added(node); end

  # Append a node to the end of the list.
  #
  # source://async//lib/async/list.rb#56
  def append(node); end

  # Iterate over each node in the linked list. It is generally safe to remove the current node, any previous node or any future node during iteration.
  #
  # source://async//lib/async/list.rb#176
  def each(&block); end

  # @return [Boolean]
  #
  # source://async//lib/async/list.rb#139
  def empty?; end

  # source://async//lib/async/list.rb#197
  def first; end

  # Returns the value of attribute head.
  #
  # source://async//lib/async/list.rb#41
  def head; end

  # Sets the attribute head
  #
  # @param value the value to set the attribute head to.
  #
  # source://async//lib/async/list.rb#41
  def head=(_arg0); end

  # Determine whether the given node is included in the list.
  #
  # @return [Boolean]
  #
  # source://async//lib/async/list.rb#188
  def include?(needle); end

  # source://async//lib/async/list.rb#22
  def inspect; end

  # source://async//lib/async/list.rb#214
  def last; end

  # Prepend a node to the start of the list.
  #
  # source://async//lib/async/list.rb#70
  def prepend(node); end

  # Remove the node. If it was already removed, this will raise an error.
  #
  # You should be careful to only remove nodes that are part of this list.
  #
  # source://async//lib/async/list.rb#118
  def remove(node); end

  # Remove the node if it is in a list.
  #
  # You should be careful to only remove nodes that are part of this list.
  #
  # @return [Boolean]
  #
  # source://async//lib/async/list.rb#104
  def remove?(node); end

  # A callback that is invoked when an item is removed from the list.
  #
  # source://async//lib/async/list.rb#94
  def removed(node); end

  # Shift the first node off the list, if it is not empty.
  #
  # source://async//lib/async/list.rb#231
  def shift; end

  # Returns the value of attribute size.
  #
  # source://async//lib/async/list.rb#47
  def size; end

  # Add the node, yield, and the remove the node.
  #
  # source://async//lib/async/list.rb#86
  def stack(node, &block); end

  # Returns the value of attribute tail.
  #
  # source://async//lib/async/list.rb#44
  def tail; end

  # Sets the attribute tail
  #
  # @param value the value to set the attribute tail to.
  #
  # source://async//lib/async/list.rb#44
  def tail=(_arg0); end

  # Fast, safe, unbounded accumulation of children.
  #
  # source://async//lib/async/list.rb#25
  def to_a; end

  # source://async//lib/async/list.rb#17
  def to_s; end

  private

  # source://async//lib/async/list.rb#127
  def remove!(node); end
end

# source://async//lib/async/list.rb#251
class Async::List::Iterator < ::Async::List::Node
  # @return [Iterator] a new instance of Iterator
  #
  # source://async//lib/async/list.rb#252
  def initialize(list); end

  # source://async//lib/async/list.rb#295
  def each; end

  # source://async//lib/async/list.rb#280
  def move_current; end

  # source://async//lib/async/list.rb#270
  def move_next; end

  # source://async//lib/async/list.rb#262
  def remove!; end

  class << self
    # source://async//lib/async/list.rb#305
    def each(list, &block); end
  end
end

# A linked list Node.
#
# source://async//lib/async/list.rb#238
class Async::List::Node
  # Returns the value of attribute head.
  #
  # source://async//lib/async/list.rb#239
  def head; end

  # Sets the attribute head
  #
  # @param value the value to set the attribute head to.
  #
  # source://async//lib/async/list.rb#239
  def head=(_arg0); end

  # source://async//lib/async/list.rb#248
  def inspect; end

  # Returns the value of attribute tail.
  #
  # source://async//lib/async/list.rb#240
  def tail; end

  # Sets the attribute tail
  #
  # @param value the value to set the attribute tail to.
  #
  # source://async//lib/async/list.rb#240
  def tail=(_arg0); end

  # source://async//lib/async/list.rb#243
  def to_s; end
end

# A node in a tree, used for implementing the task hierarchy.
#
# source://async//lib/async/node.rb#70
class Async::Node
  # Create a new node in the tree.
  #
  # @return [Node] a new instance of Node
  #
  # source://async//lib/async/node.rb#73
  def initialize(parent = T.unsafe(nil), annotation: T.unsafe(nil), transient: T.unsafe(nil)); end

  # Annotate the node with a description.
  #
  # source://async//lib/async/node.rb#142
  def annotate(annotation); end

  # Returns the value of attribute annotation.
  #
  # source://async//lib/async/node.rb#108
  def annotation; end

  # Provides a backtrace for nodes that have an active execution context.
  #
  # source://async//lib/async/node.rb#174
  def backtrace(*arguments); end

  # Returns the value of attribute children.
  #
  # source://async//lib/async/node.rb#105
  def children; end

  # Whether this node has any children.
  #
  # @return [Boolean]
  #
  # source://async//lib/async/node.rb#112
  def children?; end

  # If the node has a parent, and is {finished?}, then remove this node from
  # the parent.
  #
  # source://async//lib/async/node.rb#229
  def consume; end

  # A description of the node, including the annotation and object name.
  #
  # source://async//lib/async/node.rb#159
  def description; end

  # Whether the node can be consumed (deleted) safely. By default, checks if the children set is empty.
  #
  # @return [Boolean]
  #
  # source://async//lib/async/node.rb#223
  def finished?; end

  # @private
  #
  # source://async//lib/async/node.rb#96
  def head; end

  # @private
  #
  # source://async//lib/async/node.rb#96
  def head=(_arg0); end

  # source://async//lib/async/node.rb#184
  def inspect; end

  # Returns the value of attribute parent.
  #
  # source://async//lib/async/node.rb#102
  def parent; end

  # Change the parent of this node.
  #
  # source://async//lib/async/node.rb#190
  def parent=(parent); end

  # Print the hierarchy of the task tree from the given node.
  #
  # source://async//lib/async/node.rb#305
  def print_hierarchy(out = T.unsafe(nil), backtrace: T.unsafe(nil)); end

  # source://async//lib/async/node.rb#91
  def root; end

  # Attempt to stop the current node immediately, including all non-transient children. Invokes {#stop_children} to stop all children.
  #
  # source://async//lib/async/node.rb#284
  def stop(later = T.unsafe(nil)); end

  # Whether the node has been stopped.
  #
  # @return [Boolean]
  #
  # source://async//lib/async/node.rb#297
  def stopped?; end

  # @private
  #
  # source://async//lib/async/node.rb#99
  def tail; end

  # @private
  #
  # source://async//lib/async/node.rb#99
  def tail=(_arg0); end

  # Immediately terminate all children tasks, including transient tasks. Internally invokes `stop(false)` on all children. This should be considered a last ditch effort and is used when closing the scheduler.
  #
  # source://async//lib/async/node.rb#269
  def terminate; end

  # source://async//lib/async/node.rb#179
  def to_s; end

  # Change the transient state of the node.
  #
  # A transient node is not considered when determining if a node is finished, and propagates up if the parent is consumed.
  #
  # source://async//lib/async/node.rb#131
  def transient=(value); end

  # Represents whether a node is transient. Transient nodes are not considered
  # when determining if a node is finished. This is useful for tasks which are
  # internal to an object rather than explicit user concurrency. For example,
  # a child task which is pruning a connection pool is transient, because it
  # is not directly related to the parent task, and should not prevent the
  # parent task from finishing.
  #
  # @return [Boolean]
  #
  # source://async//lib/async/node.rb#122
  def transient?; end

  # Traverse the task tree.
  #
  # source://async//lib/async/node.rb#254
  def traverse(&block); end

  protected

  # source://async//lib/async/node.rb#209
  def add_child(child); end

  # source://async//lib/async/node.rb#215
  def remove_child(child); end

  # source://async//lib/async/node.rb#205
  def set_parent(parent); end

  # @yield [_self, level]
  # @yieldparam _self [Async::Node] the object that the method was called on
  #
  # source://async//lib/async/node.rb#260
  def traverse_recurse(level = T.unsafe(nil), &block); end

  private

  # source://async//lib/async/node.rb#317
  def print_backtrace(out, indent, node); end

  # Attempt to stop all non-transient children.
  #
  # source://async//lib/async/node.rb#290
  def stop_children(later = T.unsafe(nil)); end
end

# A synchronization primitive, which allows fibers to wait until a notification is received. Does not block the task which signals the notification. Waiting tasks are resumed on next iteration of the reactor.
#
# source://async//lib/async/notification.rb#11
class Async::Notification < ::Async::Condition
  # Signal to a given task that it should resume operations.
  #
  # source://async//lib/async/notification.rb#15
  def signal(value = T.unsafe(nil), task: T.unsafe(nil)); end
end

# source://async//lib/async/notification.rb#23
class Async::Notification::Signal < ::Struct
  # @return [Boolean]
  #
  # source://async//lib/async/notification.rb#24
  def alive?; end

  # source://async//lib/async/notification.rb#28
  def transfer; end

  # Returns the value of attribute value
  #
  # @return [Object] the current value of value
  #
  # source://async//lib/async/notification.rb#23
  def value; end

  # Sets the attribute value
  #
  # @param value [Object] the value to set the attribute value to.
  # @return [Object] the newly set value
  #
  # source://async//lib/async/notification.rb#23
  def value=(_); end

  # Returns the value of attribute waiting
  #
  # @return [Object] the current value of waiting
  #
  # source://async//lib/async/notification.rb#23
  def waiting; end

  # Sets the attribute waiting
  #
  # @param value [Object] the value to set the attribute waiting to.
  # @return [Object] the newly set value
  #
  # source://async//lib/async/notification.rb#23
  def waiting=(_); end

  class << self
    # source://async//lib/async/notification.rb#23
    def [](*_arg0); end

    # source://async//lib/async/notification.rb#23
    def inspect; end

    # source://async//lib/async/notification.rb#23
    def keyword_init?; end

    # source://async//lib/async/notification.rb#23
    def members; end

    # source://async//lib/async/notification.rb#23
    def new(*_arg0); end
  end
end

# source://async//lib/async/scheduler.rb#24
Async::Profiler = T.let(T.unsafe(nil), T.untyped)

# A queue which allows items to be processed in order.
#
# It has a compatible interface with {Notification} and {Condition}, except that it's multi-value.
#
# source://async//lib/async/queue.rb#17
class Async::Queue
  # Create a new queue.
  #
  # @return [Queue] a new instance of Queue
  #
  # source://async//lib/async/queue.rb#27
  def initialize(parent: T.unsafe(nil), available: T.unsafe(nil)); end

  # Compatibility with {::Queue#push}.
  #
  # source://async//lib/async/queue.rb#68
  def <<(item); end

  # Process each item in the queue.
  #
  # source://async//lib/async/queue.rb#109
  def async(parent: T.unsafe(nil), **options, &block); end

  # Close the queue, causing all waiting tasks to return `nil`. Any subsequent calls to {enqueue} will raise an exception.
  #
  # source://async//lib/async/queue.rb#35
  def close; end

  # Remove and return the next item from the queue.
  #
  # source://async//lib/async/queue.rb#84
  def dequeue; end

  # Enumerate each item in the queue.
  #
  # source://async//lib/async/queue.rb#116
  def each; end

  # @return [Boolean]
  #
  # source://async//lib/async/queue.rb#52
  def empty?; end

  # Add multiple items to the queue.
  #
  # source://async//lib/async/queue.rb#73
  def enqueue(*items); end

  # Returns the value of attribute items.
  #
  # source://async//lib/async/queue.rb#44
  def items; end

  # Compatibility with {::Queue#pop}.
  #
  # source://async//lib/async/queue.rb#97
  def pop; end

  # Add an item to the queue.
  #
  # source://async//lib/async/queue.rb#57
  def push(item); end

  # Signal the queue with a value, the same as {#enqueue}.
  #
  # source://async//lib/async/queue.rb#123
  def signal(value = T.unsafe(nil)); end

  # source://async//lib/async/queue.rb#47
  def size; end

  # Wait for an item to be available, the same as {#dequeue}.
  #
  # source://async//lib/async/queue.rb#128
  def wait; end
end

# An error raised when trying to enqueue items to a closed queue.
#
# source://async//lib/async/queue.rb#20
class Async::Queue::ClosedError < ::RuntimeError; end

# A wrapper around the the scheduler which binds it to the current thread automatically.
#
# source://async//lib/async/reactor.rb#12
class Async::Reactor < ::Async::Scheduler
  # Initialize the reactor and assign it to the current Fiber scheduler.
  #
  # @return [Reactor] a new instance of Reactor
  #
  # source://async//lib/async/reactor.rb#21
  def initialize(*_arg0, **_arg1, &_arg2); end

  # Close the reactor and remove it from the current Fiber scheduler.
  #
  # source://async//lib/async/reactor.rb#28
  def scheduler_close; end

  # source://async//lib/async/reactor.rb#32
  def sleep(*_arg0); end

  class << self
    # @deprecated Replaced by {Kernel::Async}.
    #
    # source://async//lib/async/reactor.rb#14
    def run(*_arg0, **_arg1, &_arg2); end
  end
end

# Handles scheduling of fibers. Implements the fiber scheduler interface.
#
# source://async//lib/async/scheduler.rb#28
class Async::Scheduler < ::Async::Node
  # Create a new scheduler.
  #
  # @return [Scheduler] a new instance of Scheduler
  #
  # source://async//lib/async/scheduler.rb#76
  def initialize(parent = T.unsafe(nil), selector: T.unsafe(nil), profiler: T.unsafe(nil), worker_pool: T.unsafe(nil)); end

  # Resolve the address of the given hostname.
  #
  # source://async//lib/async/scheduler.rb#291
  def address_resolve(hostname); end

  # Start an asynchronous task within the specified reactor. The task will be executed until the first blocking call, at which point it will yield and and this method will return.
  #
  # @deprecated Use {#run} or {Task#async} instead.
  #
  # source://async//lib/async/scheduler.rb#585
  def async(*arguments, **options, &block); end

  # Invoked when a fiber tries to perform a blocking operation which cannot continue. A corresponding call {unblock} must be performed to allow this fiber to continue.
  #
  # source://async//lib/async/scheduler.rb#230
  def block(blocker, timeout); end

  # Terminate all child tasks and close the scheduler.
  #
  # source://async//lib/async/scheduler.rb#148
  def close; end

  # @return [Boolean]
  #
  # source://async//lib/async/scheduler.rb#173
  def closed?; end

  # Create a new fiber and return it without starting execution.
  #
  # source://async//lib/async/scheduler.rb#599
  def fiber(*_arg0, **_arg1, &_arg2); end

  # Raise an exception on the specified fiber, waking up the event loop if necessary.
  #
  # source://async//lib/async/scheduler.rb#399
  def fiber_interrupt(fiber, exception); end

  # Interrupt the event loop and cause it to exit.
  #
  # source://async//lib/async/scheduler.rb#184
  def interrupt; end

  # Read from the specified IO into the buffer.
  #
  # source://async//lib/async/scheduler.rb#336
  def io_read(io, buffer, length, offset = T.unsafe(nil)); end

  # Wait for the specified IOs to become ready for the specified events.
  #
  # source://async//lib/async/scheduler.rb#421
  def io_select(*_arg0, **_arg1, &_arg2); end

  # Wait for the specified IO to become ready for the specified events.
  #
  # source://async//lib/async/scheduler.rb#306
  def io_wait(io, events, timeout = T.unsafe(nil)); end

  # Write the specified buffer to the IO.
  #
  # source://async//lib/async/scheduler.rb#360
  def io_write(io, buffer, length, offset = T.unsafe(nil)); end

  # Sleep for the specified duration.
  #
  # source://async//lib/async/scheduler.rb#275
  def kernel_sleep(duration = T.unsafe(nil)); end

  # Compute the scheduler load according to the busy and idle times that are updated by the run loop.
  #
  # source://async//lib/async/scheduler.rb#105
  def load; end

  # Wait for the specified process ID to exit.
  #
  # source://async//lib/async/scheduler.rb#413
  def process_wait(pid, flags); end

  # Schedule a fiber (or equivalent object) to be resumed on the next loop through the reactor.
  #
  # source://async//lib/async/scheduler.rb#201
  def push(fiber); end

  # Raise an exception on a specified fiber with the given arguments.
  #
  # This internally schedules the current fiber to be ready, before raising the exception, so that it will later resume execution.
  #
  # source://async//lib/async/scheduler.rb#211
  def raise(*_arg0, **_arg1, &_arg2); end

  # Resume execution of the specified fiber.
  #
  # source://async//lib/async/scheduler.rb#219
  def resume(fiber, *arguments); end

  # Run the reactor until all tasks are finished. Proxies arguments to {#async} immediately before entering the loop, if a block is provided.
  #
  # Forwards all parameters to {#async} if a block is given.
  #
  # source://async//lib/async/scheduler.rb#559
  def run(*_arg0, **_arg1, &_arg2); end

  # Run one iteration of the event loop.
  #
  # source://async//lib/async/scheduler.rb#480
  def run_once(timeout = T.unsafe(nil)); end

  # Invoked when the fiber scheduler is being closed.
  #
  # Executes the run loop until all tasks are finished, then closes the scheduler.
  #
  # source://async//lib/async/scheduler.rb#127
  def scheduler_close(error = T.unsafe(nil)); end

  # Stop all children, including transient children.
  #
  # source://async//lib/async/scheduler.rb#514
  def stop; end

  # Terminate all child tasks.
  #
  # source://async//lib/async/scheduler.rb#137
  def terminate; end

  # Invoke the block, but after the specified timeout, raise the specified exception with the given message. If the block runs to completion before the timeout occurs or there are no non-blocking operations after the timeout expires, the code will complete without any exception.
  #
  # source://async//lib/async/scheduler.rb#639
  def timeout_after(duration, exception, message, &block); end

  # source://async//lib/async/scheduler.rb#178
  def to_s; end

  # Transfer from the calling fiber to the event loop.
  #
  # source://async//lib/async/scheduler.rb#190
  def transfer; end

  # Unblock a fiber that was previously blocked.
  #
  # source://async//lib/async/scheduler.rb#259
  def unblock(blocker, fiber); end

  # Invoke the block, but after the specified timeout, raise {TimeoutError} in any currenly blocking operation. If the block runs to completion before the timeout occurs or there are no non-blocking operations after the timeout expires, the code will complete without any exception.
  #
  # source://async//lib/async/scheduler.rb#612
  def with_timeout(duration, exception = T.unsafe(nil), message = T.unsafe(nil), &block); end

  # Yield the current fiber and resume it on the next iteration of the event loop.
  #
  # source://async//lib/async/scheduler.rb#195
  def yield; end

  private

  # Checks and clears the interrupted state of the scheduler.
  #
  # @return [Boolean]
  #
  # source://async//lib/async/scheduler.rb#498
  def interrupted?; end

  # source://async//lib/async/scheduler.rb#520
  def run_loop(&block); end

  # Run one iteration of the event loop.
  #
  # When terminating the event loop, we already know we are finished. So we don't need to check the task tree. This is a logical requirement because `run_once` ignores transient tasks. For example, a single top level transient task is not enough to keep the reactor running, but during termination we must still process it in order to terminate child tasks.
  #
  # source://async//lib/async/scheduler.rb#436
  def run_once!(timeout = T.unsafe(nil)); end

  class << self
    # Whether the fiber scheduler is supported.
    #
    # @return [Boolean]
    #
    # source://async//lib/async/scheduler.rb#45
    def supported?; end
  end
end

# Used to augment the scheduler to add support for blocking operations.
#
# source://async//lib/async/scheduler.rb#50
module Async::Scheduler::BlockingOperationWait
  # Wait for the given work to be executed.
  #
  # source://async//lib/async/scheduler.rb#58
  def blocking_operation_wait(work); end
end

# Raised when an operation is attempted on a closed scheduler.
#
# source://async//lib/async/scheduler.rb#34
class Async::Scheduler::ClosedError < ::RuntimeError
  # Create a new error.
  #
  # @return [ClosedError] a new instance of ClosedError
  #
  # source://async//lib/async/scheduler.rb#38
  def initialize(message = T.unsafe(nil)); end
end

# Used to defer stopping the current task until later.
#
# source://async//lib/async/scheduler.rb#377
class Async::Scheduler::FiberInterrupt
  # Create a new stop later operation.
  #
  # @return [FiberInterrupt] a new instance of FiberInterrupt
  #
  # source://async//lib/async/scheduler.rb#381
  def initialize(fiber, exception); end

  # @return [Boolean]
  #
  # source://async//lib/async/scheduler.rb#387
  def alive?; end

  # Transfer control to the operation - this will stop the task.
  #
  # source://async//lib/async/scheduler.rb#392
  def transfer; end
end

# source://async//lib/async/scheduler.rb#29
Async::Scheduler::WORKER_POOL = T.let(T.unsafe(nil), T.untyped)

# source://async//lib/async/scheduler.rb#68
Async::Scheduler::WorkerPool = T.let(T.unsafe(nil), T.untyped)

# A synchronization primitive, which limits access to a given resource.
#
# source://async//lib/async/semaphore.rb#11
class Async::Semaphore
  # @return [Semaphore] a new instance of Semaphore
  #
  # source://async//lib/async/semaphore.rb#14
  def initialize(limit = T.unsafe(nil), parent: T.unsafe(nil)); end

  # Acquire the semaphore, block if we are at the limit.
  # If no block is provided, you must call release manually.
  #
  # source://async//lib/async/semaphore.rb#79
  def acquire; end

  # Run an async task. Will wait until the semaphore is ready until spawning and running the task.
  #
  # source://async//lib/async/semaphore.rb#61
  def async(*arguments, parent: T.unsafe(nil), **options); end

  # Whether trying to acquire this semaphore would block.
  #
  # @return [Boolean]
  #
  # source://async//lib/async/semaphore.rb#56
  def blocking?; end

  # The current number of tasks that have acquired the semaphore.
  #
  # source://async//lib/async/semaphore.rb#23
  def count; end

  # Is the semaphore currently acquired?
  #
  # @return [Boolean]
  #
  # source://async//lib/async/semaphore.rb#51
  def empty?; end

  # The maximum number of tasks that can acquire the semaphore.
  #
  # source://async//lib/async/semaphore.rb#26
  def limit; end

  # Allow setting the limit. This is useful for cases where the semaphore is used to limit the number of concurrent tasks, but the number of tasks is not known in advance or needs to be modified.
  #
  # On increasing the limit, some tasks may be immediately resumed. On decreasing the limit, some tasks may execute until the count is < than the limit.
  #
  # source://async//lib/async/semaphore.rb#36
  def limit=(limit); end

  # Release the semaphore. Must match up with a corresponding call to `acquire`. Will release waiting fibers in FIFO order.
  #
  # source://async//lib/async/semaphore.rb#94
  def release; end

  # The tasks waiting on this semaphore.
  #
  # source://async//lib/async/semaphore.rb#29
  def waiting; end

  private

  # Wait until the semaphore becomes available.
  #
  # source://async//lib/async/semaphore.rb#119
  def wait; end
end

# source://async//lib/async/semaphore.rb#104
class Async::Semaphore::FiberNode < ::Async::List::Node
  # @return [FiberNode] a new instance of FiberNode
  #
  # source://async//lib/async/semaphore.rb#105
  def initialize(fiber); end

  # source://async//lib/async/semaphore.rb#109
  def resume; end
end

# Raised when a task is explicitly stopped.
#
# source://async//lib/async/task.rb#21
class Async::Stop < ::Exception; end

# Used to defer stopping the current task until later.
#
# source://async//lib/async/task.rb#23
class Async::Stop::Later
  # Create a new stop later operation.
  #
  # @return [Later] a new instance of Later
  #
  # source://async//lib/async/task.rb#27
  def initialize(task); end

  # @return [Boolean]
  #
  # source://async//lib/async/task.rb#32
  def alive?; end

  # Transfer control to the operation - this will stop the task.
  #
  # source://async//lib/async/task.rb#37
  def transfer; end
end

# source://async//lib/async/task.rb#55
class Async::Task < ::Async::Node
  # Create a new task.
  #
  # @return [Task] a new instance of Task
  #
  # source://async//lib/async/task.rb#83
  def initialize(parent = T.unsafe(nil), finished: T.unsafe(nil), **options, &block); end

  # @return [Boolean]
  #
  # source://async//lib/async/task.rb#158
  def alive?; end

  # Annotate the task with a description.
  #
  # This will internally try to annotate the fiber if it is running, otherwise it will annotate the task itself.
  #
  # source://async//lib/async/task.rb#115
  def annotate(annotation, &block); end

  # source://async//lib/async/task.rb#124
  def annotation; end

  # Run an asynchronous task as a child of the current task.
  #
  # @raise [FinishedError]
  #
  # source://async//lib/async/task.rb#227
  def async(*arguments, **options, &block); end

  # source://async//lib/async/task.rb#106
  def backtrace(*arguments); end

  # Alias for {#completed?}.
  #
  # @return [Boolean]
  #
  # source://async//lib/async/task.rb#190
  def complete?; end

  # @return [Boolean]
  #
  # source://async//lib/async/task.rb#185
  def completed?; end

  # @return [Boolean]
  #
  # source://async//lib/async/task.rb#376
  def current?; end

  # Defer the handling of stop. During the execution of the given block, if a stop is requested, it will be deferred until the block exits. This is useful for ensuring graceful shutdown of servers and other long-running tasks. You should wrap the response handling code in a defer_stop block to ensure that the task is stopped when the response is complete but not before.
  #
  # You can nest calls to defer_stop, but the stop will only be deferred until the outermost block exits.
  #
  # If stop is invoked a second time, it will be immediately executed.
  #
  # source://async//lib/async/task.rb#325
  def defer_stop; end

  # @return [Boolean]
  #
  # source://async//lib/async/task.rb#175
  def failed?; end

  # Returns the value of attribute fiber.
  #
  # source://async//lib/async/task.rb#155
  def fiber; end

  # Whether we can remove this node from the reactor graph.
  #
  # @return [Boolean]
  #
  # source://async//lib/async/task.rb#164
  def finished?; end

  # source://async//lib/async/task.rb#101
  def reactor; end

  # Access the result of the task without waiting. May be nil if the task is not completed. Does not raise exceptions.
  #
  # source://async//lib/async/task.rb#267
  def result; end

  # Begin the execution of the task.
  #
  # source://async//lib/async/task.rb#200
  def run(*arguments); end

  # @return [Boolean]
  #
  # source://async//lib/async/task.rb#170
  def running?; end

  # @deprecated Prefer {Kernel#sleep} except when compatibility with `stable-v1` is required.
  #
  # source://async//lib/async/task.rb#138
  def sleep(duration = T.unsafe(nil)); end

  # Returns the value of attribute status.
  #
  # source://async//lib/async/task.rb#195
  def status; end

  # Stop the task and all of its children.
  #
  # If `later` is false, it means that `stop` has been invoked directly. When `later` is true, it means that `stop` is invoked by `stop_children` or some other indirect mechanism. In that case, if we encounter the "current" fiber, we can't stop it right away, as it's currently performing `#stop`. Stopping it immediately would interrupt the current stop traversal, so we need to schedule the stop to occur later.
  #
  # source://async//lib/async/task.rb#274
  def stop(later = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://async//lib/async/task.rb#358
  def stop_deferred?; end

  # @return [Boolean]
  #
  # source://async//lib/async/task.rb#180
  def stopped?; end

  # source://async//lib/async/task.rb#133
  def to_s; end

  # Retrieve the current result of the task. Will cause the caller to wait until result is available. If the task resulted in an unhandled error (derived from `StandardError`), this will be raised. If the task was stopped, this will return `nil`.
  #
  # Conceptually speaking, waiting on a task should return a result, and if it throws an exception, this is certainly an exceptional case that should represent a failure in your program, not an expected outcome. In other words, you should not design your programs to expect exceptions from `#wait` as a normal flow control, and prefer to catch known exceptions within the task itself and return a result that captures the intention of the failure, e.g. a `TimeoutError` might simply return `nil` or `false` to indicate that the operation did not generate a valid result (as a timeout was an expected outcome of the internal operation in this case).
  #
  # source://async//lib/async/task.rb#250
  def wait; end

  # Execute the given block of code, raising the specified exception if it exceeds the given duration during a non-blocking operation.
  #
  # source://async//lib/async/task.rb#145
  def with_timeout(duration, exception = T.unsafe(nil), message = T.unsafe(nil), &block); end

  # Yield back to the reactor and allow other fibers to execute.
  #
  # source://async//lib/async/task.rb#150
  def yield; end

  private

  # State transition into the completed state.
  #
  # source://async//lib/async/task.rb#403
  def completed!(result); end

  # State transition into the failed state.
  #
  # source://async//lib/async/task.rb#409
  def failed!(exception = T.unsafe(nil)); end

  # Finish the current task, moving any children to the parent.
  #
  # source://async//lib/async/task.rb#387
  def finish!; end

  # source://async//lib/async/task.rb#440
  def schedule(&block); end

  # source://async//lib/async/task.rb#434
  def stop!; end

  # source://async//lib/async/task.rb#414
  def stopped!; end

  # source://async//lib/async/task.rb#382
  def warn(*_arg0, **_arg1, &_arg2); end

  class << self
    # Lookup the {Task} for the current fiber. Raise `RuntimeError` if none is available.
    # @raises[RuntimeError] If task was not {set!} for the current fiber.
    #
    # source://async//lib/async/task.rb#365
    def current; end

    # Check if there is a task defined for the current fiber.
    #
    # @return [Boolean]
    #
    # source://async//lib/async/task.rb#371
    def current?; end

    # Run the given block of code in a task, asynchronously, in the given scheduler.
    #
    # source://async//lib/async/task.rb#74
    def run(scheduler, *arguments, **options, &block); end

    # @deprecated With no replacement.
    #
    # source://async//lib/async/task.rb#67
    def yield; end
  end
end

# Raised when a child task is created within a task that has finished execution.
#
# source://async//lib/async/task.rb#57
class Async::Task::FinishedError < ::RuntimeError
  # Create a new finished error.
  #
  # @return [FinishedError] a new instance of FinishedError
  #
  # source://async//lib/async/task.rb#61
  def initialize(message = T.unsafe(nil)); end
end

# Represents a flexible timeout that can be rescheduled or extended.
#
# source://async//lib/async/timeout.rb#9
class Async::Timeout
  # Initialize a new timeout.
  #
  # @return [Timeout] a new instance of Timeout
  #
  # source://async//lib/async/timeout.rb#11
  def initialize(timers, handle); end

  # Adjust the timeout by the specified duration.
  #
  # The duration is relative to the timeout time, e.g. adjusting the timeout by 5 increases the current duration by 5 seconds.
  #
  # source://async//lib/async/timeout.rb#36
  def adjust(duration); end

  # Cancel the timeout, preventing it from executing.
  #
  # source://async//lib/async/timeout.rb#59
  def cancel!; end

  # @return [Boolean]
  #
  # source://async//lib/async/timeout.rb#64
  def cancelled?; end

  # source://async//lib/async/timeout.rb#17
  def duration; end

  # Update the duration of the timeout.
  #
  # The duration is relative to the current time, e.g. setting the duration to 5 means the timeout will occur in 5 seconds from now.
  #
  # source://async//lib/async/timeout.rb#26
  def duration=(value); end

  # source://async//lib/async/timeout.rb#54
  def now; end

  # source://async//lib/async/timeout.rb#41
  def time; end

  # Assign a new time to the timeout, rescheduling it if necessary.
  #
  # source://async//lib/async/timeout.rb#49
  def time=(value); end

  private

  # Reschedule the timeout to occur at the specified time.
  #
  # source://async//lib/async/timeout.rb#76
  def reschedule(time); end
end

# Raised when attempting to reschedule a cancelled timeout.
#
# source://async//lib/async/timeout.rb#69
class Async::Timeout::CancelledError < ::RuntimeError; end

# Raised if a timeout occurs on a specific Fiber. Handled gracefully by `Task`.
#
# source://async//lib/async/task.rb#45
class Async::TimeoutError < ::StandardError
  # Create a new timeout error.
  #
  # @return [TimeoutError] a new instance of TimeoutError
  #
  # source://async//lib/async/task.rb#49
  def initialize(message = T.unsafe(nil)); end
end

# source://async//lib/async/version.rb#7
Async::VERSION = T.let(T.unsafe(nil), String)

# A synchronization primitive that allows one task to wait for another task to resolve a value.
#
# source://async//lib/async/variable.rb#10
class Async::Variable
  # Create a new variable.
  #
  # @return [Variable] a new instance of Variable
  #
  # source://async//lib/async/variable.rb#14
  def initialize(condition = T.unsafe(nil)); end

  # Resolve the value.
  #
  # Signals all waiting tasks.
  #
  # source://async//lib/async/variable.rb#24
  def resolve(value = T.unsafe(nil)); end

  # Whether the value has been resolved.
  #
  # @return [Boolean]
  #
  # source://async//lib/async/variable.rb#42
  def resolved?; end

  # Alias for {#wait}.
  #
  # source://async//lib/async/variable.rb#55
  def value; end

  # Alias for {#resolve}.
  #
  # source://async//lib/async/variable.rb#35
  def value=(value); end

  # Wait for the value to be resolved.
  #
  # source://async//lib/async/variable.rb#49
  def wait; end
end

# Extensions to all Ruby objects.
#
# source://async//lib/kernel/async.rb#8
module Kernel
  # Run the given block of code in a task, asynchronously, creating a reactor if necessary.
  #
  # The preferred method to invoke asynchronous behavior at the top level.
  #
  # - When invoked within an existing reactor task, it will run the given block
  # asynchronously. Will return the task once it has been scheduled.
  # - When invoked at the top level, will create and run a reactor, and invoke
  # the block as an asynchronous task. Will block until the reactor finishes
  # running.
  #
  # source://async//lib/kernel/async.rb#24
  def Async(*_arg0, **_arg1, &_arg2); end

  # Run the given block of code synchronously, but within a reactor if not already in one.
  #
  # source://async//lib/kernel/sync.rb#19
  def Sync(annotation: T.unsafe(nil), &block); end
end
