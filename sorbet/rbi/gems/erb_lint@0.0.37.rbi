# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `erb_lint` gem.
# Please instead update this file by running `bin/tapioca sync`.

# typed: true

module ERBLint
end

class ERBLint::Corrector
  def initialize(processed_source, offenses); end

  def corrected_content; end
  def corrections; end
  def corrector; end
  def diagnostics; end
  def offenses; end
  def processed_source; end
end

ERBLint::Corrector::BASE = RuboCop::Cop::Legacy::Corrector

class ERBLint::FileLoader
  def initialize(base_path); end

  def base_path; end
  def yaml(filename); end

  private

  def read_content(filename); end
end

class ERBLint::Linter
  def initialize(file_loader, config); end

  def add_offense(source_range, message, context = T.unsafe(nil)); end
  def clear_offenses; end
  def enabled?; end
  def excludes_file?(filename); end
  def offenses; end
  def run(_processed_source); end

  class << self
    def config_schema; end
    def config_schema=(_arg0); end
    def inherited(linter); end
    def simple_name; end
    def simple_name=(_arg0); end
    def support_autocorrect?; end
  end
end

class ERBLint::LinterConfig
  include(::SmartProperties)
  extend(::SmartProperties::ClassMethods)

  def initialize(config = T.unsafe(nil)); end

  def [](name); end
  def excludes_file?(filename); end
  def to_hash; end

  class << self
    def array_of?(klass); end
    def to_array_of(klass); end
  end
end

class ERBLint::LinterConfig::Error < ::StandardError
end

module ERBLint::LinterRegistry
  class << self
    def clear; end
    def find_by_name(name); end
    def included(linter_class); end
    def linters; end
    def load_custom_linters(directory = T.unsafe(nil)); end
  end
end

ERBLint::LinterRegistry::CUSTOM_LINTERS_DIR = T.let(T.unsafe(nil), String)

module ERBLint::Linters
end

class ERBLint::Linters::AllowedScriptType < ::ERBLint::Linter
  include(::ERBLint::LinterRegistry)

  def autocorrect(_processed_source, offense); end
  def run(processed_source); end
end

class ERBLint::Linters::AllowedScriptType::ConfigSchema < ::ERBLint::LinterConfig
end

class ERBLint::Linters::ClosingErbTagIndent < ::ERBLint::Linter
  include(::ERBLint::LinterRegistry)

  def autocorrect(_processed_source, offense); end
  def run(processed_source); end
end

ERBLint::Linters::ClosingErbTagIndent::END_SPACES = T.let(T.unsafe(nil), Regexp)

ERBLint::Linters::ClosingErbTagIndent::START_SPACES = T.let(T.unsafe(nil), Regexp)

class ERBLint::Linters::DeprecatedClasses < ::ERBLint::Linter
  include(::ERBLint::LinterRegistry)

  def initialize(file_loader, config); end

  def run(processed_source); end

  private

  def class_name_with_loc(processed_source); end
  def generate_offenses(class_name, range); end
  def process_nested_offenses(source:, offset:, parent_source:); end
  def script_tags(processed_source); end
  def tag_nodes(processed_source); end
  def tags(processed_source); end
  def text_tags_content(processed_source); end
  def violated_rules(class_name); end
end

class ERBLint::Linters::DeprecatedClasses::ConfigSchema < ::ERBLint::LinterConfig
end

class ERBLint::Linters::DeprecatedClasses::RuleSet
  include(::SmartProperties)
  extend(::SmartProperties::ClassMethods)
end

class ERBLint::Linters::ErbSafety < ::ERBLint::Linter
  include(::ERBLint::LinterRegistry)

  def initialize(file_loader, config); end

  def run(processed_source); end

  private

  def better_html_config; end
  def tester_classes; end
  def testers_for(parser); end
end

class ERBLint::Linters::ErbSafety::ConfigSchema < ::ERBLint::LinterConfig
end

class ERBLint::Linters::ExtraNewline < ::ERBLint::Linter
  include(::ERBLint::LinterRegistry)

  def autocorrect(_processed_source, offense); end
  def run(processed_source); end
end

ERBLint::Linters::ExtraNewline::EXTRA_NEWLINES = T.let(T.unsafe(nil), Regexp)

class ERBLint::Linters::FinalNewline < ::ERBLint::Linter
  include(::ERBLint::LinterRegistry)

  def initialize(file_loader, config); end

  def autocorrect(_processed_source, offense); end
  def run(processed_source); end
end

class ERBLint::Linters::FinalNewline::ConfigSchema < ::ERBLint::LinterConfig
end

class ERBLint::Linters::HardCodedString < ::ERBLint::Linter
  include(::ERBLint::LinterRegistry)

  def autocorrect(processed_source, offense); end
  def find_range(node, str); end
  def run(processed_source); end

  private

  def check_string?(str); end
  def corrector_i18n_load_path; end
  def load_corrector; end
  def message(string); end
  def non_text_tag?(processed_source, text_node); end
  def relevant_node(inner_node); end
end

ERBLint::Linters::HardCodedString::ALLOWED_CORRECTORS = T.let(T.unsafe(nil), Array)

ERBLint::Linters::HardCodedString::BLACK_LISTED_TEXT = T.let(T.unsafe(nil), Set)

class ERBLint::Linters::HardCodedString::ConfigSchema < ::ERBLint::LinterConfig
end

class ERBLint::Linters::HardCodedString::ForbiddenCorrector < ::StandardError
end

class ERBLint::Linters::HardCodedString::MissingCorrector < ::StandardError
end

class ERBLint::Linters::HardCodedString::MissingI18nLoadPath < ::StandardError
end

ERBLint::Linters::HardCodedString::NON_TEXT_TAGS = T.let(T.unsafe(nil), Set)

class ERBLint::Linters::NoJavascriptTagHelper < ::ERBLint::Linter
  include(::ERBLint::LinterRegistry)

  def autocorrect(processed_source, offense); end
  def run(processed_source); end

  private

  def correct_offense(processed_source, offense, corrector); end
end

class ERBLint::Linters::NoJavascriptTagHelper::ConfigSchema < ::ERBLint::LinterConfig
end

class ERBLint::Linters::ParserErrors < ::ERBLint::Linter
  include(::ERBLint::LinterRegistry)

  def run(processed_source); end
end

class ERBLint::Linters::RightTrim < ::ERBLint::Linter
  include(::ERBLint::LinterRegistry)

  def autocorrect(_processed_source, offense); end
  def run(processed_source); end
end

class ERBLint::Linters::RightTrim::ConfigSchema < ::ERBLint::LinterConfig
end

class ERBLint::Linters::Rubocop < ::ERBLint::Linter
  include(::ERBLint::LinterRegistry)

  def initialize(file_loader, config); end

  def autocorrect(_processed_source, offense); end
  def run(processed_source); end

  private

  def activate_team(processed_source, source, offset, code_node, team); end
  def add_offense(rubocop_offense, offense_range, correction, offset, bound_range); end
  def base_configs(inherit_from); end
  def build_team; end
  def config_from_hash(hash); end
  def cop_classes; end
  def descendant_nodes(processed_source); end
  def inspect_content(processed_source, erb_node); end
  def resolve_inheritance(hash, inherit_from); end
  def rubocop_processed_source(content, filename); end
  def tempfile_from(filename, content); end
end

ERBLint::Linters::Rubocop::BLOCK_EXPR = T.let(T.unsafe(nil), Regexp)

class ERBLint::Linters::Rubocop::ConfigSchema < ::ERBLint::LinterConfig
end

ERBLint::Linters::Rubocop::SUFFIX_EXPR = T.let(T.unsafe(nil), Regexp)

class ERBLint::Linters::RubocopText < ::ERBLint::Linters::Rubocop

  private

  def cop_classes; end
  def descendant_nodes(parser); end
end

class ERBLint::Linters::RubocopText::ConfigSchema < ::ERBLint::LinterConfig
end

class ERBLint::Linters::SelfClosingTag < ::ERBLint::Linter
  include(::ERBLint::LinterRegistry)

  def autocorrect(_processed_source, offense); end
  def run(processed_source); end
end

class ERBLint::Linters::SelfClosingTag::ConfigSchema < ::ERBLint::LinterConfig
end

ERBLint::Linters::SelfClosingTag::SELF_CLOSING_TAGS = T.let(T.unsafe(nil), Array)

class ERBLint::Linters::SpaceAroundErbTag < ::ERBLint::Linter
  include(::ERBLint::LinterRegistry)

  def autocorrect(_processed_source, offense); end
  def run(processed_source); end
end

ERBLint::Linters::SpaceAroundErbTag::END_SPACES = T.let(T.unsafe(nil), Regexp)

ERBLint::Linters::SpaceAroundErbTag::START_SPACES = T.let(T.unsafe(nil), Regexp)

class ERBLint::Linters::SpaceInHtmlTag < ::ERBLint::Linter
  include(::ERBLint::LinterRegistry)

  def autocorrect(_processed_source, offense); end
  def run(processed_source); end

  private

  def no_space(processed_source, range); end
  def process_attributes(processed_source, attributes); end
  def single_space(processed_source, range, accept_newline: T.unsafe(nil)); end
  def single_space_or_newline(processed_source, range); end
end

class ERBLint::Linters::SpaceIndentation < ::ERBLint::Linter
  include(::ERBLint::LinterRegistry)

  def autocorrect(_processed_source, offense); end
  def run(processed_source); end
end

class ERBLint::Linters::SpaceIndentation::ConfigSchema < ::ERBLint::LinterConfig
end

ERBLint::Linters::SpaceIndentation::START_SPACES = T.let(T.unsafe(nil), Regexp)

class ERBLint::Linters::TrailingWhitespace < ::ERBLint::Linter
  include(::ERBLint::LinterRegistry)

  def autocorrect(_processed_source, offense); end
  def run(processed_source); end
end

ERBLint::Linters::TrailingWhitespace::TRAILING_WHITESPACE = T.let(T.unsafe(nil), Regexp)

class ERBLint::Offense
  def initialize(linter, source_range, message, context = T.unsafe(nil)); end

  def ==(other); end
  def column; end
  def context; end
  def inspect; end
  def line_number; end
  def line_range; end
  def linter; end
  def message; end
  def source_range; end
end

class ERBLint::ProcessedSource
  def initialize(filename, file_content); end

  def ast; end
  def file_content; end
  def filename; end
  def parser; end
  def source_buffer; end
  def to_source_range(range); end
end

class ERBLint::Reporter
  def initialize(stats, autocorrect); end

  def preview; end
  def processed_files(*_arg0, &_arg1); end
  def show; end

  private

  def autocorrect; end
  def stats; end

  class << self
    def available_format?(format); end
    def available_formats; end
    def create_reporter(format, *args); end
  end
end

module ERBLint::Reporters
end

class ERBLint::Reporters::CompactReporter < ::ERBLint::Reporter
  def preview; end
  def show; end

  private

  def footer; end
  def format_offense(filename, offense); end
  def report_corrected_offenses; end
  def summary; end
end

class ERBLint::Reporters::MultilineReporter < ::ERBLint::Reporters::CompactReporter

  private

  def footer; end
  def format_offense(filename, offense); end
end

class ERBLint::Runner
  def initialize(file_loader, config); end

  def clear_offenses; end
  def offenses; end
  def run(processed_source); end
end

class ERBLint::RunnerConfig
  def initialize(config = T.unsafe(nil), file_loader = T.unsafe(nil)); end

  def for_linter(klass); end
  def global_exclude; end
  def merge(other_config); end
  def merge!(other_config); end
  def to_hash; end

  private

  def config_hash_for_linter(klass_name); end
  def linters_config; end
  def resolver; end

  class << self
    def default(default_enabled: T.unsafe(nil)); end
    def default_for(config); end
  end
end

class ERBLint::RunnerConfig::Error < ::StandardError
end

class ERBLint::RunnerConfigResolver
  def resolve_inheritance(hash, file_loader); end
  def resolve_inheritance_from_gems(hash, gems); end

  private

  def base_configs(file_loader, inherit_from); end
  def gem_config_path(gem_name, relative_config_path); end
end

class ERBLint::Stats
  def initialize(found: T.unsafe(nil), corrected: T.unsafe(nil), exceptions: T.unsafe(nil), linters: T.unsafe(nil), files: T.unsafe(nil), processed_files: T.unsafe(nil)); end

  def corrected; end
  def corrected=(_arg0); end
  def exceptions; end
  def exceptions=(_arg0); end
  def files; end
  def files=(_arg0); end
  def found; end
  def found=(_arg0); end
  def linters; end
  def linters=(_arg0); end
  def processed_files; end
  def processed_files=(_arg0); end
end

module ERBLint::Utils
end

class ERBLint::Utils::BlockMap
  def initialize(processed_source); end

  def connections; end
  def find_connected_nodes(other); end

  private

  def append(code); end
  def block?(source); end
  def build_map; end
  def current_pos; end
  def erb_ast; end
  def erb_nodes; end
  def extract_map_locations(node); end
  def find_entry(range); end
  def find_overlapping_pair; end
  def group_overlapping_connections; end
  def parser; end
  def rescue_locations(node); end
  def when_locations(node); end
end

class ERBLint::Utils::BlockMap::ConnectedErbNodes
  def initialize(type, nodes); end

  def &(other); end
  def concat(other); end
  def include?(other); end
  def inspect; end
  def nodes; end
  def type; end

  private

  def ordered(nodes); end
end

class ERBLint::Utils::BlockMap::Entry
  def initialize(node, ruby_range); end

  def contains_ruby_range?(range); end
  def erb_range; end
  def node; end
  def ruby_range; end
end

class ERBLint::Utils::BlockMap::ParseError < ::StandardError
end

class ERBLint::Utils::OffsetCorrector
  def initialize(processed_source, corrector, offset, bound_range); end

  def bound(pos); end
  def insert_after(range, content); end
  def insert_before(range, content); end
  def range_with_offset(node_or_range); end
  def remove(range); end
  def remove_leading(range, size); end
  def remove_preceding(range, size); end
  def remove_trailing(range, size); end
  def replace(range, content); end

  private

  def to_range(node_or_range); end
end

class ERBLint::Utils::RubyToERB
  class << self
    def escape_quote(str); end
    def html_options_to_tag_attributes(hash_node); end
    def ruby_to_erb(node, indicator = T.unsafe(nil), &block); end
  end
end

class ERBLint::Utils::RubyToERB::Error < ::StandardError
end

ERBLint::VERSION = T.let(T.unsafe(nil), String)
