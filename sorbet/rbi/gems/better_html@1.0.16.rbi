# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `better_html` gem.
# Please instead update this file by running `bin/tapioca gem better_html`.

module BetterHtml; end
module BetterHtml::AST; end

class BetterHtml::AST::Iterator
  # @return [Iterator] a new instance of Iterator
  def initialize(types, &block); end

  def traverse(node); end
  def traverse_all(nodes); end

  class << self
    def descendants(root_node, type); end
  end
end

class BetterHtml::AST::Node < ::AST::Node
  def descendants(*types); end

  # Returns the value of attribute loc.
  def loc; end

  def location; end
end

class BetterHtml::DontInterpolateHere < ::BetterHtml::InterpolatorError; end

class BetterHtml::Errors < ::Array
  def add(_arg0); end
end

class BetterHtml::HtmlError < ::RuntimeError; end
class BetterHtml::InterpolatorError < ::RuntimeError; end

class BetterHtml::Parser
  # @raise [ArgumentError]
  # @return [Parser] a new instance of Parser
  def initialize(buffer, template_language: T.unsafe(nil)); end

  def ast; end
  def inspect; end
  def nodes_with_type(*type); end
  def parser_errors; end

  # Returns the value of attribute template_language.
  def template_language; end

  private

  def build_attribute_name_node(tokens); end
  def build_attribute_node(tokens); end
  def build_attribute_value_node(tokens); end
  def build_cdata_node(tokens); end
  def build_comment_node(tokens); end
  def build_document_node; end
  def build_erb_node(tokens); end
  def build_interpolation_node(tokens); end

  # @raise [ArgumentError]
  def build_location(enumerable); end

  def build_lodash_node(tokens); end
  def build_nameless_attribute_node(tokens); end
  def build_node(type, tokens, pre: T.unsafe(nil), post: T.unsafe(nil)); end
  def build_tag_attributes_node(tokens); end
  def build_tag_name_node(tokens); end
  def build_tag_node(tokens); end
  def build_text_node(tokens); end
  def empty_location; end
  def shift_all(tokens, *types); end
  def shift_all_with_interpolation(tokens, *types); end
  def shift_between(tokens, start_type, end_type); end
  def shift_between_with_interpolation(tokens, start_type, end_type); end
  def shift_single(tokens, *types); end
  def shift_until(tokens, *types); end
  def shift_until_with_interpolation(tokens, *types); end
  def wrap_token(object); end
  def wrap_tokens(enumerable); end
end

class BetterHtml::Parser::Error < ::BetterHtml::HtmlError
  # @return [Error] a new instance of Error
  def initialize(message, location:); end

  # Returns the value of attribute location.
  def loc; end

  # Returns the value of attribute location.
  def location; end
end

BetterHtml::Parser::INTERPOLATION_TYPES = T.let(T.unsafe(nil), Array)
module BetterHtml::Tokenizer; end

class BetterHtml::Tokenizer::BaseErb < ::Erubi::Engine
  # @raise [ArgumentError]
  # @return [BaseErb] a new instance of BaseErb
  def initialize(buffer); end

  # Returns the value of attribute current_position.
  def current_position; end

  # Returns the value of attribute tokens.
  def tokens; end

  private

  def add_code(code); end
  def add_erb_tokens(ltrim, indicator, code, rtrim); end
  def add_expression(indicator, code); end
  def add_token(type, begin_pos, end_pos); end
  def append(text); end
end

BetterHtml::Tokenizer::BaseErb::EXPR_TRIM_MATCHER = T.let(T.unsafe(nil), Regexp)
BetterHtml::Tokenizer::BaseErb::REGEXP_WITHOUT_TRIM = T.let(T.unsafe(nil), Regexp)
BetterHtml::Tokenizer::BaseErb::STMT_TRIM_MATCHER = T.let(T.unsafe(nil), Regexp)

class BetterHtml::Tokenizer::HtmlErb < ::BetterHtml::Tokenizer::BaseErb
  # @return [HtmlErb] a new instance of HtmlErb
  def initialize(buffer); end

  def current_position; end

  # Returns the value of attribute parser.
  def parser; end

  private

  def add_text(text); end
  def append(text); end
end

class BetterHtml::Tokenizer::HtmlLodash
  # @return [HtmlLodash] a new instance of HtmlLodash
  def initialize(buffer); end

  def lodash_escape; end
  def lodash_escape=(val); end
  def lodash_evaluate; end
  def lodash_evaluate=(val); end
  def lodash_interpolate; end
  def lodash_interpolate=(val); end

  # Returns the value of attribute parser.
  def parser; end

  # Returns the value of attribute tokens.
  def tokens; end

  private

  def add_lodash_tokens(indicator, code); end
  def add_text(text); end
  def add_token(type, begin_pos: T.unsafe(nil), end_pos: T.unsafe(nil)); end
  def scan!; end
  def scan_pattern; end

  class << self
    def lodash_escape; end
    def lodash_escape=(val); end
    def lodash_evaluate; end
    def lodash_evaluate=(val); end
    def lodash_interpolate; end
    def lodash_interpolate=(val); end
  end
end

class BetterHtml::Tokenizer::JavascriptErb < ::BetterHtml::Tokenizer::BaseErb
  private

  def add_text(text); end
end

class BetterHtml::Tokenizer::Location < ::Parser::Source::Range
  # @raise [ArgumentError]
  # @return [Location] a new instance of Location
  def initialize(buffer, begin_pos, end_pos); end

  def adjust(begin_pos: T.unsafe(nil), end_pos: T.unsafe(nil)); end
  def begin; end
  def end; end
  def line_range; end
  def line_source_with_underline; end
  def offset(offset); end
  def range; end
  def resize(new_size); end
  def start_column; end
  def start_line; end
  def stop_column; end
  def stop_line; end
  def with(begin_pos: T.unsafe(nil), end_pos: T.unsafe(nil)); end
end

class BetterHtml::Tokenizer::Token
  # @return [Token] a new instance of Token
  def initialize(type:, loc:); end

  def inspect; end

  # Returns the value of attribute loc.
  def loc; end

  # Returns the value of attribute type.
  def type; end
end

class BetterHtml::Tokenizer::TokenArray
  # @return [TokenArray] a new instance of TokenArray
  def initialize(list); end

  # @return [Boolean]
  def any?; end

  def current; end

  # @return [Boolean]
  def empty?; end

  def last; end

  # @raise [RuntimeError]
  def pop; end

  # @raise [RuntimeError]
  def shift; end

  def size; end
  def trim(type); end
end

class BetterHtml::UnsafeHtmlError < ::BetterHtml::InterpolatorError; end
