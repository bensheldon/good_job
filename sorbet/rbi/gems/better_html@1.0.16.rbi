# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `better_html` gem.
# Please instead update this file by running `bin/tapioca sync`.

# typed: true

module BetterHtml
  class << self
    def config; end
    def config=(new_config); end
    def configure; end
  end
end

module BetterHtml::AST
end

class BetterHtml::AST::Iterator
  def initialize(types, &block); end

  def traverse(node); end
  def traverse_all(nodes); end

  class << self
    def descendants(root_node, type); end
  end
end

class BetterHtml::AST::Node < ::AST::Node
  def descendants(*types); end
  def loc; end
  def location; end
end

class BetterHtml::BetterErb
  def content_types; end
  def content_types=(val); end

  class << self
    def content_types; end
    def content_types=(val); end
    def prepend!; end
  end
end

module BetterHtml::BetterErb::ConditionalImplementation
  def call(template, source = T.unsafe(nil)); end

  private

  def generate(template, source); end
end

class BetterHtml::BetterErb::ErubiImplementation < ::ActionView::Template::Handlers::ERB::Erubi
  include(::BetterHtml::BetterErb::RuntimeChecks)

  def add_code(code); end
  def add_expression(indicator, code); end
  def add_text(text); end

  private

  def escape_text(text); end
end

module BetterHtml::BetterErb::RuntimeChecks
  def initialize(erb, config: T.unsafe(nil), **options); end

  def validate!; end

  private

  def add_expr_auto_escaped(src, code, auto_escape); end
  def block_check(src, code); end
  def build_location(line, column, length); end
  def check_attribute_name(type, start, stop, line, column); end
  def check_parser_errors; end
  def check_quoted_value(type, start, stop, line, column); end
  def check_tag_name(type, start, stop, line, column); end
  def check_token(type, *args); end
  def check_unquoted_value(type, start, stop, line, column); end
  def class_name; end
  def extract_line(line); end
  def parser_context; end
  def wrap_method; end
end

class BetterHtml::BetterErb::ValidatedOutputBuffer
  def html_safe; end
  def html_safe?; end
  def to_s; end

  class << self
    def wrap(output, context, code, auto_escape); end
  end
end

class BetterHtml::BetterErb::ValidatedOutputBuffer::Context
  def initialize(output, context, code, auto_escape); end

  def safe_after_attribute_name_append=(value); end
  def safe_after_equal_append=(value); end
  def safe_attribute_name_append=(value); end
  def safe_comment_append=(value); end
  def safe_none_append=(value); end
  def safe_quoted_value_append=(value); end
  def safe_rawtext_append=(value); end
  def safe_space_after_attribute_append=(value); end
  def safe_tag_append=(value); end
  def safe_tag_name_append=(value); end
  def safe_unquoted_value_append=(value); end

  private

  def auto_escape_html_safe_value(arg); end
  def properly_escaped(value); end
end

class BetterHtml::Config
  include(::SmartProperties)
  extend(::SmartProperties::ClassMethods)

  def javascript_attribute_name?(name); end
  def javascript_safe_method?(name); end
  def lodash_safe_javascript_expression?(code); end
end

class BetterHtml::DontInterpolateHere < ::BetterHtml::InterpolatorError
end

class BetterHtml::Errors < ::Array
  def add(_arg0); end
end

module BetterHtml::Helpers
  def html_attributes(args); end
end

class BetterHtml::HtmlAttributes
  def initialize(data); end

  def to_s; end
end

class BetterHtml::HtmlError < ::RuntimeError
end

class BetterHtml::InterpolatorError < ::RuntimeError
end

class BetterHtml::Parser
  def initialize(buffer, template_language: T.unsafe(nil)); end

  def ast; end
  def inspect; end
  def nodes_with_type(*type); end
  def parser_errors; end
  def template_language; end

  private

  def build_attribute_name_node(tokens); end
  def build_attribute_node(tokens); end
  def build_attribute_value_node(tokens); end
  def build_cdata_node(tokens); end
  def build_comment_node(tokens); end
  def build_document_node; end
  def build_erb_node(tokens); end
  def build_interpolation_node(tokens); end
  def build_location(enumerable); end
  def build_lodash_node(tokens); end
  def build_nameless_attribute_node(tokens); end
  def build_node(type, tokens, pre: T.unsafe(nil), post: T.unsafe(nil)); end
  def build_tag_attributes_node(tokens); end
  def build_tag_name_node(tokens); end
  def build_tag_node(tokens); end
  def build_text_node(tokens); end
  def empty_location; end
  def shift_all(tokens, *types); end
  def shift_all_with_interpolation(tokens, *types); end
  def shift_between(tokens, start_type, end_type); end
  def shift_between_with_interpolation(tokens, start_type, end_type); end
  def shift_single(tokens, *types); end
  def shift_until(tokens, *types); end
  def shift_until_with_interpolation(tokens, *types); end
  def wrap_token(object); end
  def wrap_tokens(enumerable); end
end

class BetterHtml::Parser::Error < ::BetterHtml::HtmlError
  def initialize(message, location:); end

  def loc; end
  def location; end
end

BetterHtml::Parser::INTERPOLATION_TYPES = T.let(T.unsafe(nil), Array)

class BetterHtml::Railtie < ::Rails::Railtie
end

module BetterHtml::TestHelper
end

class BetterHtml::TestHelper::RubyNode < ::BetterHtml::AST::Node
  def arguments; end
  def begin?; end
  def child_nodes; end
  def hash?; end
  def method_call?; end
  def method_name; end
  def method_name?(name); end
  def node?(current); end
  def pair?; end
  def receiver; end
  def return_values; end
  def static_return_value?; end
  def static_value?; end
  def type?(wanted_type); end

  class << self
    def parse(code); end
  end
end

BetterHtml::TestHelper::RubyNode::BLOCK_EXPR = T.let(T.unsafe(nil), Regexp)

class BetterHtml::TestHelper::RubyNode::Builder < ::Parser::Builders::Default
  def n(type, children, source_map); end
end

class BetterHtml::TestHelper::RubyNode::ParseError < ::RuntimeError
end

BetterHtml::TestHelper::RubyNode::STATIC_TYPES = T.let(T.unsafe(nil), Array)

module BetterHtml::TestHelper::SafeErb
end

class BetterHtml::TestHelper::SafeErb::AllowedScriptType < ::BetterHtml::TestHelper::SafeErb::Base
  def validate; end

  private

  def validate_type(tag); end
end

BetterHtml::TestHelper::SafeErb::AllowedScriptType::VALID_JAVASCRIPT_TAG_TYPES = T.let(T.unsafe(nil), Array)

class BetterHtml::TestHelper::SafeErb::Base
  def initialize(parser, config: T.unsafe(nil)); end

  def add_error(message, location:); end
  def errors; end

  protected

  def ast; end
  def erb_nodes(root_node); end
  def script_tags; end
end

class BetterHtml::TestHelper::SafeErb::NoJavascriptTagHelper < ::BetterHtml::TestHelper::SafeErb::Base
  def validate; end

  private

  def no_javascript_tag_helper(node); end
end

class BetterHtml::TestHelper::SafeErb::NoStatements < ::BetterHtml::TestHelper::SafeErb::Base
  def validate; end

  private

  def no_statements(node); end
end

class BetterHtml::TestHelper::SafeErb::ScriptInterpolation < ::BetterHtml::TestHelper::SafeErb::Base
  def validate; end

  private

  def validate_script(node); end
  def validate_script_interpolation(parent_node, ruby_node); end
end

class BetterHtml::TestHelper::SafeErb::TagInterpolation < ::BetterHtml::TestHelper::SafeErb::Base
  def validate; end

  private

  def handle_missing_safe_wrapper(parent_node, ruby_node, attr_name); end
  def nested_location(parent_node, ruby_node); end
  def no_html_tag?(node); end
  def no_unsafe_calls(parent_node, ruby_node); end
  def validate_attribute(attribute); end
  def validate_ruby_helper(parent_node, ruby_node); end
  def validate_ruby_helper_hash_entry(parent_node, ruby_node, key_prefix, key_node, value_node); end
  def validate_ruby_helper_hash_value(parent_node, ruby_node, attr_name, hash_value); end
  def validate_tag_interpolation(parent_node, ruby_node, attr_name); end
  def validate_text_node(text_node); end
end

BetterHtml::TestHelper::SafeErb::TagInterpolation::NO_HTML_TAGS = T.let(T.unsafe(nil), Array)

module BetterHtml::TestHelper::SafeErbTester
  def assert_erb_safety(data, **options); end
end

BetterHtml::TestHelper::SafeErbTester::SAFETY_TIPS = T.let(T.unsafe(nil), String)

class BetterHtml::TestHelper::SafetyError < ::BetterHtml::InterpolatorError
  def initialize(message, location:); end

  def location; end
end

module BetterHtml::Tokenizer
end

class BetterHtml::Tokenizer::BaseErb < ::Erubi::Engine
  def initialize(buffer); end

  def current_position; end
  def tokens; end

  private

  def add_code(code); end
  def add_erb_tokens(ltrim, indicator, code, rtrim); end
  def add_expression(indicator, code); end
  def add_token(type, begin_pos, end_pos); end
  def append(text); end
end

BetterHtml::Tokenizer::BaseErb::EXPR_TRIM_MATCHER = T.let(T.unsafe(nil), Regexp)

BetterHtml::Tokenizer::BaseErb::REGEXP_WITHOUT_TRIM = T.let(T.unsafe(nil), Regexp)

BetterHtml::Tokenizer::BaseErb::STMT_TRIM_MATCHER = T.let(T.unsafe(nil), Regexp)

class BetterHtml::Tokenizer::HtmlErb < ::BetterHtml::Tokenizer::BaseErb
  def initialize(buffer); end

  def current_position; end
  def parser; end

  private

  def add_text(text); end
  def append(text); end
end

class BetterHtml::Tokenizer::HtmlLodash
  def initialize(buffer); end

  def lodash_escape; end
  def lodash_escape=(val); end
  def lodash_evaluate; end
  def lodash_evaluate=(val); end
  def lodash_interpolate; end
  def lodash_interpolate=(val); end
  def parser; end
  def tokens; end

  private

  def add_lodash_tokens(indicator, code); end
  def add_text(text); end
  def add_token(type, begin_pos: T.unsafe(nil), end_pos: T.unsafe(nil)); end
  def scan!; end
  def scan_pattern; end

  class << self
    def lodash_escape; end
    def lodash_escape=(val); end
    def lodash_evaluate; end
    def lodash_evaluate=(val); end
    def lodash_interpolate; end
    def lodash_interpolate=(val); end
  end
end

class BetterHtml::Tokenizer::JavascriptErb < ::BetterHtml::Tokenizer::BaseErb

  private

  def add_text(text); end
end

class BetterHtml::Tokenizer::Location < ::Parser::Source::Range
  def initialize(buffer, begin_pos, end_pos); end

  def adjust(begin_pos: T.unsafe(nil), end_pos: T.unsafe(nil)); end
  def begin; end
  def end; end
  def line_range; end
  def line_source_with_underline; end
  def offset(offset); end
  def range; end
  def resize(new_size); end
  def start_column; end
  def start_line; end
  def stop_column; end
  def stop_line; end
  def with(begin_pos: T.unsafe(nil), end_pos: T.unsafe(nil)); end
end

class BetterHtml::Tokenizer::Token
  def initialize(type:, loc:); end

  def inspect; end
  def loc; end
  def type; end
end

class BetterHtml::Tokenizer::TokenArray
  def initialize(list); end

  def any?; end
  def current; end
  def empty?; end
  def last; end
  def pop; end
  def shift; end
  def size; end
  def trim(type); end
end

module BetterHtml::Tree
end

class BetterHtml::Tree::Attribute
  def initialize(node); end

  def equal_node; end
  def erb?; end
  def loc; end
  def name; end
  def name_node; end
  def node; end
  def value; end
  def value_node; end

  class << self
    def from_node(node); end
  end
end

class BetterHtml::Tree::AttributesList
  def initialize(list); end

  def [](name); end
  def each(&block); end

  class << self
    def from_nodes(nodes); end
  end
end

class BetterHtml::Tree::Tag
  def initialize(node); end

  def attributes; end
  def attributes_node; end
  def closing?; end
  def end_solidus; end
  def loc; end
  def name; end
  def name_node; end
  def node; end
  def self_closing?; end
  def start_solidus; end

  class << self
    def from_node(node); end
  end
end

class BetterHtml::UnsafeHtmlError < ::BetterHtml::InterpolatorError
end

BetterHtml::VERSION = T.let(T.unsafe(nil), String)
