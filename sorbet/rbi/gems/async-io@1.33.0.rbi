# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `async-io` gem.
# Please instead update this file by running `bin/tapioca gem async-io`.

module Async
  extend ::Console

  class << self
    # Invoke `Reactor.run` with all arguments/block.
    def run(*arguments, &block); end
  end
end

module Async::IO
  class << self
    def pipe; end

    # Convert a Ruby ::IO object to a wrapped instance:
    def try_convert(io, &block); end
  end
end

Async::IO::Address = Addrinfo

# This class will open and close the socket automatically.
class Async::IO::AddressEndpoint < ::Async::IO::Endpoint
  # @return [AddressEndpoint] a new instance of AddressEndpoint
  def initialize(address, **options); end

  # Returns the value of attribute address.
  def address; end

  # Bind a socket to the given address. If a block is given, the socket will be automatically closed when the block exits.
  #
  # @return [Socket] the bound socket
  # @yield [Socket] the bound socket
  def bind(&block); end

  # Connects a socket to the given address. If a block is given, the socket will be automatically closed when the block exits.
  #
  # @return [Socket] the connected socket
  def connect(&block); end

  def to_s; end
end

# The default block size for IO buffers. Defaults to 64KB (typical pipe buffer size).
Async::IO::BLOCK_SIZE = T.let(T.unsafe(nil), Integer)

class Async::IO::BasicSocket < ::Async::IO::Generic
  include ::Socket::Constants
  include ::Async::IO::Peer

  def close_read(*args, &block); end
  def close_write(*args, &block); end
  def connect_address(*args, &block); end
  def do_not_reverse_lookup(*args, &block); end
  def do_not_reverse_lookup=(*args, &block); end
  def getpeereid(*args, &block); end
  def getpeername(*args, &block); end
  def getsockname(*args, &block); end
  def getsockopt(*args, &block); end
  def local_address(*args, &block); end

  # Invokes `recv_nonblock` on the underlying {io}. If the operation would block, the current task is paused until the operation can succeed, at which point it's resumed and the operation is completed.
  def recv(*args); end

  def recv_nonblock(*args, exception: T.unsafe(nil)); end

  # Invokes `recvmsg_nonblock` on the underlying {io}. If the operation would block, the current task is paused until the operation can succeed, at which point it's resumed and the operation is completed.
  def recvmsg(*args); end

  def recvmsg_nonblock(*args, exception: T.unsafe(nil)); end
  def remote_address(*args, &block); end

  # Invokes `sendmsg_nonblock` on the underlying {io}. If the operation would block, the current task is paused until the operation can succeed, at which point it's resumed and the operation is completed.
  def send(*args); end

  # Invokes `sendmsg_nonblock` on the underlying {io}. If the operation would block, the current task is paused until the operation can succeed, at which point it's resumed and the operation is completed.
  def sendmsg(*args); end

  def sendmsg_nonblock(*args, exception: T.unsafe(nil)); end
  def setsockopt(*args, &block); end
  def shutdown(*args, &block); end
end

class Async::IO::Buffer < ::String
  # @return [Buffer] a new instance of Buffer
  def initialize; end

  def <<(string); end
  def concat(string); end
end

Async::IO::Buffer::BINARY = T.let(T.unsafe(nil), Encoding)

# Endpoints represent a way of connecting or binding to an address.
class Async::IO::Endpoint
  # @return [Endpoint] a new instance of Endpoint
  def initialize(**options); end

  # Accept connections from the specified endpoint.
  #
  # @param backlog [Integer] the number of connections to listen for.
  def accept(backlog = T.unsafe(nil), &block); end

  # Map all endpoints by invoking `#bind`.
  #
  # @yield the bound wrapper.
  def bound; end

  # Endpoints sometimes have multiple paths.
  #
  # @yield [Endpoint] Enumerate all discrete paths as endpoints.
  def each; end

  # @return [String] The hostname of the bound socket.
  def hostname; end

  # Controls SO_LINGER. The amount of time the socket will stay in the `TIME_WAIT` state after being closed.
  #
  # @return [Integer, nil] The value for SO_LINGER.
  def linger; end

  # @return [Address] the address to bind to before connecting.
  def local_address; end

  # Returns the value of attribute options.
  def options; end

  # Sets the attribute options
  #
  # @param value the value to set the attribute options to.
  def options=(_arg0); end

  # If `SO_REUSEADDR` is enabled on a socket prior to binding it, the socket can be successfully bound unless there is a conflict with another socket bound to exactly the same combination of source address and port. Additionally, when set, binding a socket to the address of an existing socket in `TIME_WAIT` is not an error.
  #
  # @return [Boolean] The value for `SO_REUSEADDR`.
  def reuse_address; end

  # If `SO_REUSEPORT` is enabled on a socket, the socket can be successfully bound even if there are existing sockets bound to the same address, as long as all prior bound sockets also had `SO_REUSEPORT` set before they were bound.
  #
  # @return [Boolean, nil] The value for `SO_REUSEPORT`.
  def reuse_port; end

  # @return [Numeric] The default timeout for socket operations.
  def timeout; end

  def with(**options); end

  class << self
    # Create an Endpoint instance by URI scheme. The host and port of the URI will be passed to the Endpoint factory method, along with any options.
    #
    # @param string [String] URI as string. Scheme will decide implementation used.
    # @param options keyword arguments passed through to {#initialize}
    # @see Endpoint.ssl ssl - invoked when parsing a URL with the ssl scheme "ssl://127.0.0.1"
    # @see Endpoint.tcp tcp - invoked when parsing a URL with the tcp scheme: "tcp://127.0.0.1"
    # @see Endpoint.udp udp - invoked when parsing a URL with the udp scheme: "udp://127.0.0.1"
    # @see Endpoint.unix unix - invoked when parsing a URL with the unix scheme: "unix://127.0.0.1"
    def parse(string, **options); end

    # @param args
    # @param ssl_context [OpenSSL::SSL::SSLContext, nil]
    # @param hostname [String, nil]
    # @param options keyword arguments passed through to {Endpoint.tcp}
    # @return [SSLEndpoint]
    def ssl(*args, ssl_context: T.unsafe(nil), hostname: T.unsafe(nil), **options); end

    # @param args nodename, service, family, socktype, protocol, flags. `socktype` will be set to Socket::SOCK_STREAM.
    # @param options keyword arguments passed on to {HostEndpoint#initialize}
    # @return [HostEndpoint]
    def tcp(*args, **options); end

    # @param args nodename, service, family, socktype, protocol, flags. `socktype` will be set to Socket::SOCK_DGRAM.
    # @param options keyword arguments passed on to {HostEndpoint#initialize}
    # @return [HostEndpoint]
    def udp(*args, **options); end
  end
end

# Represents an asynchronous IO within a reactor.
class Async::IO::Generic < ::Async::Wrapper
  extend ::Forwardable

  def <<(buffer); end
  def advise(*args, &block); end
  def autoclose=(*args, &block); end
  def autoclose?(*args, &block); end
  def binmode(*args, &block); end
  def binmode?(*args, &block); end
  def close_on_exec=(*args, &block); end
  def close_on_exec?(*args, &block); end
  def close_read(*args, &block); end
  def close_write(*args, &block); end
  def closed?(*args, &block); end

  # @return [Boolean]
  def connected?; end

  def dup; end
  def eof(*args, &block); end
  def eof?(*args, &block); end
  def external_encoding(*args, &block); end
  def fcntl(*args, &block); end
  def fdatasync(*args, &block); end
  def fileno(*args, &block); end
  def flush(*args, &block); end
  def fsync(*args, &block); end
  def internal_encoding(*args, &block); end
  def ioctl(*args, &block); end
  def isatty(*args, &block); end
  def nonblock; end
  def nonblock=(value); end

  # @return [Boolean]
  def nonblock?; end

  def nread(*args, &block); end
  def pathconf(*args, &block); end
  def pid(*args, &block); end
  def pos(*args, &block); end
  def pos=(*args, &block); end
  def pread(*args, &block); end
  def pwrite(*args, &block); end

  # Read `length` bytes of data from the underlying I/O. If length is unspecified, read everything.
  def read(length = T.unsafe(nil), buffer = T.unsafe(nil)); end

  def read_nonblock(*args, exception: T.unsafe(nil)); end
  def readpartial(*args, exception: T.unsafe(nil)); end
  def ready?(*args, &block); end
  def reopen(*args, &block); end
  def rewind(*args, &block); end
  def seek(*args, &block); end
  def set_encoding(*args, &block); end
  def set_encoding_by_bom(*args, &block); end
  def stat(*args, &block); end
  def sync(*args, &block); end
  def sync=(*args, &block); end

  # Read the specified number of bytes from the input stream. This is fast path.
  # Invokes `read_nonblock` on the underlying {io}. If the operation would block, the current task is paused until the operation can succeed, at which point it's resumed and the operation is completed.
  #
  # @example
  #   data = io.sysread(512)
  def sysread(*args); end

  def sysseek(*args, &block); end

  # Write entire buffer to output stream. This is fast path.
  # Invokes `write_nonblock` on the underlying {io}. If the operation would block, the current task is paused until the operation can succeed, at which point it's resumed and the operation is completed.
  #
  # @example
  #   io.syswrite("Hello World")
  def syswrite(*args); end

  def tell(*args, &block); end

  # Returns the value of attribute timeout.
  def timeout; end

  # Sets the attribute timeout
  #
  # @param value the value to set the attribute timeout to.
  def timeout=(_arg0); end

  def to_i(*args, &block); end
  def to_io(*args, &block); end
  def tty?(*args, &block); end
  def wait(timeout = T.unsafe(nil), mode = T.unsafe(nil)); end
  def write(buffer); end
  def write_nonblock(*args, exception: T.unsafe(nil)); end

  protected

  def async_send(*arguments, timeout: T.unsafe(nil)); end

  class << self
    # Instantiate a wrapped instance of the class, and optionally yield it to a given block, closing it afterwards.
    def wrap(*args); end

    def wrap_blocking_method(new_name, method_name, invert: T.unsafe(nil), &block); end

    # Returns the value of attribute wrapped_klass.
    def wrapped_klass; end

    def wraps(klass, *additional_methods); end
  end
end

Async::IO::Generic::WRAPPERS = T.let(T.unsafe(nil), Hash)

class Async::IO::HostEndpoint < ::Async::IO::Endpoint
  # @return [HostEndpoint] a new instance of HostEndpoint
  def initialize(specification, **options); end

  def address; end

  # Invokes the given block for every address which can be bound to.
  #
  # @return [Array<Socket>] an array of bound sockets
  # @yield [Socket] the bound socket
  def bind(&block); end

  # Try to connect to the given host by connecting to each address in sequence until a connection is made.
  #
  # @raise if no connection could complete successfully
  # @return [Socket] the connected socket
  # @yield [Socket] the socket which is being connected, may be invoked more than once
  def connect; end

  # @yield [AddressEndpoint] address endpoints by resolving the given host specification
  def each; end

  def hostname; end
  def to_s; end
end

class Async::IO::IPSocket < ::Async::IO::BasicSocket
  def addr(*args, &block); end
  def peeraddr(*args, &block); end

  # Invokes `recvfrom_nonblock` on the underlying {io}. If the operation would block, the current task is paused until the operation can succeed, at which point it's resumed and the operation is completed.
  def recvfrom(*args); end

  def recvfrom_nonblock(*args, exception: T.unsafe(nil)); end
end

# The maximum read size when appending to IO buffers. Defaults to 8MB.
Async::IO::MAXIMUM_READ_SIZE = T.let(T.unsafe(nil), Integer)

module Async::IO::Peer
  include ::Socket::Constants

  # Is it likely that the socket is still connected?
  # May return false positive, but won't return false negative.
  #
  # @return [Boolean]
  def connected?; end

  def eof; end

  # @return [Boolean]
  def eof?; end

  def protocol; end
  def sync; end

  # Best effort to set *_NODELAY if it makes sense. Swallows errors where possible.
  def sync=(value); end

  def type; end
end

class Async::IO::SSLEndpoint < ::Async::IO::Endpoint
  # @return [SSLEndpoint] a new instance of SSLEndpoint
  def initialize(endpoint, **options); end

  def address; end

  # Connect to the underlying endpoint and establish a SSL connection.
  #
  # @return [Socket] the connected socket
  # @yield [Socket] the socket which is being connected
  def bind; end

  def build_context(context = T.unsafe(nil)); end

  # Connect to the underlying endpoint and establish a SSL connection.
  #
  # @return [Socket] the connected socket
  # @yield [Socket] the socket which is being connected
  def connect(&block); end

  def context; end
  def each; end

  # Returns the value of attribute endpoint.
  def endpoint; end

  def hostname; end

  # Returns the value of attribute options.
  def options; end

  def params; end
  def to_s; end
end

Async::IO::SSLError = OpenSSL::SSL::SSLError

# We reimplement this from scratch because the native implementation doesn't expose the underlying server/context that we need to implement non-blocking accept.
class Async::IO::SSLServer
  include ::Async::IO::Server
  extend ::Forwardable

  # @return [SSLServer] a new instance of SSLServer
  def initialize(server, context); end

  def accept(task: T.unsafe(nil), **options); end
  def close(*args, &block); end
  def close_on_exec=(*args, &block); end

  # Returns the value of attribute context.
  def context; end

  def dup; end
  def fileno; end
  def getsockopt(*args, &block); end
  def listen(*args); end
  def local_address(*args, &block); end
  def reactor=(*args, &block); end

  # Returns the value of attribute server.
  def server; end

  def setsockopt(*args, &block); end
  def timeout(*args, &block); end
  def timeout=(*args, &block); end
end

# Asynchronous TCP socket wrapper.
class Async::IO::SSLSocket < ::Async::IO::Generic
  include ::Socket::Constants
  include ::Async::IO::Peer

  # @return [SSLSocket] a new instance of SSLSocket
  def initialize(socket, context); end

  # Invokes `accept_nonblock` on the underlying {io}. If the operation would block, the current task is paused until the operation can succeed, at which point it's resumed and the operation is completed.
  def accept(*args); end

  def accept_nonblock(*args, exception: T.unsafe(nil)); end
  def alpn_protocol(*args, &block); end
  def cert(*args, &block); end
  def cipher(*args, &block); end
  def client_ca(*args, &block); end
  def close_read; end
  def close_write; end

  # Invokes `connect_nonblock` on the underlying {io}. If the operation would block, the current task is paused until the operation can succeed, at which point it's resumed and the operation is completed.
  def connect(*args); end

  def connect_nonblock(*args, exception: T.unsafe(nil)); end
  def context(*args, &block); end
  def finished_message(*args, &block); end
  def getsockopt(*args, &block); end
  def hostname(*args, &block); end
  def hostname=(*args, &block); end
  def local_address; end
  def npn_protocol(*args, &block); end
  def peer_cert(*args, &block); end
  def peer_cert_chain(*args, &block); end
  def peer_finished_message(*args, &block); end
  def pending(*args, &block); end
  def post_connection_check(*args, &block); end
  def remote_address; end
  def session(*args, &block); end
  def session=(*args, &block); end
  def session_reused?(*args, &block); end
  def setsockopt(*args, &block); end
  def shutdown(how); end
  def ssl_version(*args, &block); end
  def state(*args, &block); end
  def sync_close(*args, &block); end
  def sync_close=(*args, &block); end
  def sysclose(*args, &block); end
  def tmp_key(*args, &block); end
  def verify_result(*args, &block); end

  class << self
    def connect(socket, context, hostname = T.unsafe(nil), &block); end
  end
end

# Backwards compatibility.
Async::IO::SecureEndpoint = Async::IO::SSLEndpoint

module Async::IO::Server
  def accept_each(timeout: T.unsafe(nil), task: T.unsafe(nil)); end
end

class Async::IO::Socket < ::Async::IO::BasicSocket
  include ::Async::IO::Server

  # @param duration [Numeric] the maximum time to wait for accepting a connection, if specified.
  def accept(timeout: T.unsafe(nil), task: T.unsafe(nil)); end

  # @param duration [Numeric] the maximum time to wait for accepting a connection, if specified.
  def accept_nonblock(timeout: T.unsafe(nil), task: T.unsafe(nil)); end

  def bind(*args, &block); end

  # @raise Errno::EAGAIN the connection failed due to the remote end being overloaded.
  def connect(*args); end

  # @raise Errno::EAGAIN the connection failed due to the remote end being overloaded.
  def connect_nonblock(*args); end

  def ipv6only!(*args, &block); end
  def listen(*args, &block); end

  # Invokes `recvfrom_nonblock` on the underlying {io}. If the operation would block, the current task is paused until the operation can succeed, at which point it's resumed and the operation is completed.
  def recvfrom(*args); end

  def recvfrom_nonblock(*args, exception: T.unsafe(nil)); end

  # @param duration [Numeric] the maximum time to wait for accepting a connection, if specified.
  def sysaccept(timeout: T.unsafe(nil), task: T.unsafe(nil)); end

  class << self
    # Bind to a local address and accept connections in a loop.
    def accept(*args, backlog: T.unsafe(nil), &block); end

    # Bind to a local address.
    #
    # @example
    #   socket = Async::IO::Socket.bind(Async::IO::Address.tcp("0.0.0.0", 9090))
    # @option protocol
    # @param local_address [Address] The local address to bind to.
    # @param protocol [Hash] a customizable set of options
    def bind(local_address, protocol: T.unsafe(nil), task: T.unsafe(nil), **options, &block); end

    # Build and wrap the underlying io.
    #
    # @option reuse_port
    # @option reuse_address
    # @param reuse_port [Hash] a customizable set of options
    # @param reuse_address [Hash] a customizable set of options
    def build(*args, timeout: T.unsafe(nil), reuse_address: T.unsafe(nil), reuse_port: T.unsafe(nil), linger: T.unsafe(nil), task: T.unsafe(nil)); end

    # Establish a connection to a given `remote_address`.
    #
    # @example
    #   socket = Async::IO::Socket.connect(Async::IO::Address.tcp("8.8.8.8", 53))
    # @option local_address
    # @param remote_address [Address] The remote address to connect to.
    # @param local_address [Hash] a customizable set of options
    def connect(remote_address, local_address: T.unsafe(nil), task: T.unsafe(nil), **options); end

    def pair(*args); end
  end
end

class Async::IO::Stream
  # @return [Stream] a new instance of Stream
  def initialize(io, block_size: T.unsafe(nil), maximum_read_size: T.unsafe(nil), sync: T.unsafe(nil), deferred: T.unsafe(nil)); end

  # Writes `string` to the stream and returns self.
  def <<(string); end

  # Returns the value of attribute block_size.
  def block_size; end

  # Best effort to flush any unwritten data, and then close the underling IO.
  def close; end

  def close_read; end
  def close_write; end

  # @return [Boolean]
  def closed?; end

  # @return [Boolean]
  def connected?; end

  # Returns true if the stream is at file which means there is no more data to be read.
  #
  # @return [Boolean]
  def eof; end

  # @raise [EOFError]
  def eof!; end

  # Returns true if the stream is at file which means there is no more data to be read.
  #
  # @return [Boolean]
  def eof?; end

  # Flushes buffered data to the stream.
  def flush; end

  def gets(separator = T.unsafe(nil), **options); end

  # Returns the value of attribute io.
  def io; end

  def peek; end
  def puts(*arguments, separator: T.unsafe(nil)); end

  # Reads `size` bytes from the stream. If size is not specified, read until end of file.
  def read(size = T.unsafe(nil)); end

  # @raise [exception]
  def read_exactly(size, exception: T.unsafe(nil)); end

  # Read at most `size` bytes from the stream. Will avoid reading from the underlying stream if possible.
  def read_partial(size = T.unsafe(nil)); end

  # Efficiently read data from the stream until encountering pattern.
  #
  # @param pattern [String] The pattern to match.
  # @return [String] The contents of the stream up until the pattern, which is consumed but not returned.
  def read_until(pattern, offset = T.unsafe(nil), chomp: T.unsafe(nil)); end

  # Read at most `size` bytes from the stream. Will avoid reading from the underlying stream if possible.
  def readpartial(size = T.unsafe(nil)); end

  # Writes `string` to the buffer. When the buffer is full or #sync is true the
  # buffer is flushed to the underlying `io`.
  #
  # @param string the string to write to the buffer.
  # @return the number of bytes appended to the buffer.
  def write(string); end

  private

  # Consumes at most `size` bytes from the buffer.
  #
  # @param size [Integer|nil] The amount of data to consume. If nil, consume entire buffer.
  def consume_read_buffer(size = T.unsafe(nil)); end

  # Fills the buffer from the underlying stream.
  def fill_read_buffer(size = T.unsafe(nil)); end

  class << self
    def open(path, mode = T.unsafe(nil), **options); end
  end
end

Async::IO::Stream::BLOCK_SIZE = T.let(T.unsafe(nil), Integer)
Async::VERSION = T.let(T.unsafe(nil), String)
