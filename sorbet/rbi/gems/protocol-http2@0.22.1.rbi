# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `protocol-http2` gem.
# Please instead update this file by running `bin/tapioca gem protocol-http2`.


# source://protocol-http2//lib/protocol/http2/error.rb#8
module Protocol; end

# source://protocol-http2//lib/protocol/http2/error.rb#9
module Protocol::HTTP2; end

# source://protocol-http2//lib/protocol/http2/ping_frame.rb#10
Protocol::HTTP2::ACKNOWLEDGEMENT = T.let(T.unsafe(nil), Integer)

# source://protocol-http2//lib/protocol/http2/ping_frame.rb#12
module Protocol::HTTP2::Acknowledgement
  # source://protocol-http2//lib/protocol/http2/ping_frame.rb#21
  def acknowledge; end

  # source://protocol-http2//lib/protocol/http2/ping_frame.rb#17
  def acknowledgement!; end

  # @return [Boolean]
  #
  # source://protocol-http2//lib/protocol/http2/ping_frame.rb#13
  def acknowledgement?; end
end

# source://protocol-http2//lib/protocol/http2/reset_stream_frame.rb#18
Protocol::HTTP2::CANCEL = T.let(T.unsafe(nil), Integer)

# source://protocol-http2//lib/protocol/http2/reset_stream_frame.rb#19
Protocol::HTTP2::COMPRESSION_ERROR = T.let(T.unsafe(nil), Integer)

# Default connection "fast-fail" preamble string as defined by the spec.
#
# source://protocol-http2//lib/protocol/http2/framer.rb#43
Protocol::HTTP2::CONNECTION_PREFACE = T.let(T.unsafe(nil), String)

# source://protocol-http2//lib/protocol/http2/reset_stream_frame.rb#20
Protocol::HTTP2::CONNECT_ERROR = T.let(T.unsafe(nil), Integer)

# source://protocol-http2//lib/protocol/http2/client.rb#10
class Protocol::HTTP2::Client < ::Protocol::HTTP2::Connection
  # @return [Client] a new instance of Client
  #
  # source://protocol-http2//lib/protocol/http2/client.rb#11
  def initialize(framer); end

  # @raise [ProtocolError]
  #
  # source://protocol-http2//lib/protocol/http2/client.rb#45
  def create_push_promise_stream; end

  # @return [Boolean]
  #
  # source://protocol-http2//lib/protocol/http2/client.rb#15
  def local_stream_id?(id); end

  # source://protocol-http2//lib/protocol/http2/client.rb#49
  def receive_push_promise(frame); end

  # @return [Boolean]
  #
  # source://protocol-http2//lib/protocol/http2/client.rb#19
  def remote_stream_id?(id); end

  # source://protocol-http2//lib/protocol/http2/client.rb#27
  def send_connection_preface(settings = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://protocol-http2//lib/protocol/http2/client.rb#23
  def valid_remote_stream_id?(stream_id); end
end

# source://protocol-http2//lib/protocol/http2/connection.rb#15
class Protocol::HTTP2::Connection
  include ::Protocol::HTTP2::FlowControlled

  # @return [Connection] a new instance of Connection
  #
  # source://protocol-http2//lib/protocol/http2/connection.rb#18
  def initialize(framer, local_stream_id); end

  # source://protocol-http2//lib/protocol/http2/connection.rb#48
  def [](id); end

  # Accept an incoming push promise from the other side of the connection.
  # On the client side, we accept push promise streams.
  # On the server side, existing streams create push promise streams.
  #
  # source://protocol-http2//lib/protocol/http2/connection.rb#350
  def accept_push_promise_stream(stream_id, &block); end

  # Accept an incoming stream from the other side of the connnection.
  # On the server side, we accept requests.
  #
  # source://protocol-http2//lib/protocol/http2/connection.rb#339
  def accept_stream(stream_id, &block); end

  # @return [Boolean]
  #
  # source://protocol-http2//lib/protocol/http2/connection.rb#417
  def client_stream_id?(id); end

  # Close the underlying framer and all streams.
  #
  # source://protocol-http2//lib/protocol/http2/connection.rb#97
  def close(error = T.unsafe(nil)); end

  # Transition the connection into the closed state.
  #
  # source://protocol-http2//lib/protocol/http2/connection.rb#184
  def close!; end

  # Whether the connection is effectively or actually closed.
  #
  # @return [Boolean]
  #
  # source://protocol-http2//lib/protocol/http2/connection.rb#88
  def closed?; end

  # This is only valid if the stream doesn't exist in `@streams`.
  #
  # @return [Boolean]
  #
  # source://protocol-http2//lib/protocol/http2/connection.rb#444
  def closed_stream_id?(id); end

  # Traverse active streams and allow them to consume the available flow-control window.
  #
  # source://protocol-http2//lib/protocol/http2/connection.rb#467
  def consume_window(size = T.unsafe(nil)); end

  # source://protocol-http2//lib/protocol/http2/connection.rb#369
  def create_push_promise_stream(&block); end

  # Create a stream, defaults to an outgoing stream.
  # On the client side, we create requests.
  #
  # @return [Stream] the created stream.
  #
  # source://protocol-http2//lib/protocol/http2/connection.rb#357
  def create_stream(id = T.unsafe(nil), &block); end

  # source://protocol-http2//lib/protocol/http2/connection.rb#113
  def decode_headers(data); end

  # source://protocol-http2//lib/protocol/http2/connection.rb#92
  def delete(id); end

  # Returns the value of attribute dependencies.
  #
  # source://protocol-http2//lib/protocol/http2/connection.rb#128
  def dependencies; end

  # Returns the value of attribute dependency.
  #
  # source://protocol-http2//lib/protocol/http2/connection.rb#130
  def dependency; end

  # source://protocol-http2//lib/protocol/http2/connection.rb#109
  def encode_headers(headers, buffer = T.unsafe(nil)); end

  # Returns the value of attribute framer.
  #
  # source://protocol-http2//lib/protocol/http2/connection.rb#68
  def framer; end

  # source://protocol-http2//lib/protocol/http2/connection.rb#44
  def id; end

  # @return [Boolean]
  #
  # source://protocol-http2//lib/protocol/http2/connection.rb#425
  def idle_stream_id?(id); end

  # 6.8. GOAWAY
  # There is an inherent race condition between an endpoint starting new streams and the remote sending a GOAWAY frame. To deal with this case, the GOAWAY contains the stream identifier of the last peer-initiated stream that was or might be processed on the sending endpoint in this connection. For instance, if the server sends a GOAWAY frame, the identified stream is the highest-numbered stream initiated by the client.
  # Once sent, the sender will ignore frames sent on streams initiated by the receiver if the stream has an identifier higher than the included last stream identifier. Receivers of a GOAWAY frame MUST NOT open additional streams on the connection, although a new connection can be established for new streams.
  #
  # @return [Boolean]
  #
  # source://protocol-http2//lib/protocol/http2/connection.rb#135
  def ignore_frame?(frame); end

  # Current settings value for local and peer
  #
  # source://protocol-http2//lib/protocol/http2/connection.rb#74
  def local_settings; end

  # Current settings value for local and peer
  #
  # source://protocol-http2//lib/protocol/http2/connection.rb#74
  def local_settings=(_arg0); end

  # Our window for receiving data. When we receive data, it reduces this window.
  # If the window gets too small, we must send a window update.
  #
  # source://protocol-http2//lib/protocol/http2/connection.rb#79
  def local_window; end

  # The maximum number of concurrent streams that this connection can initiate. This is a setting that can be changed by the remote peer.
  #
  # It is not the same as the number of streams that can be accepted by the connection. The number of streams that can be accepted is determined by the local settings, and the number of streams that can be initiated is determined by the remote settings.
  #
  # source://protocol-http2//lib/protocol/http2/connection.rb#64
  def maximum_concurrent_streams; end

  # The size of a frame payload is limited by the maximum size that a receiver advertises in the SETTINGS_MAX_FRAME_SIZE setting.
  #
  # source://protocol-http2//lib/protocol/http2/connection.rb#57
  def maximum_frame_size; end

  # Streams are identified with an unsigned 31-bit integer.  Streams initiated by a client MUST use odd-numbered stream identifiers; those initiated by the server MUST use even-numbered stream identifiers.  A stream identifier of zero (0x0) is used for connection control messages; the stream identifier of zero cannot be used to establish a new stream.
  #
  # source://protocol-http2//lib/protocol/http2/connection.rb#118
  def next_stream_id; end

  # source://protocol-http2//lib/protocol/http2/connection.rb#276
  def open!; end

  # In addition to changing the flow-control window for streams that are not yet active, a SETTINGS frame can alter the initial flow-control window size for streams with active flow-control windows (that is, streams in the "open" or "half-closed (remote)" state).  When the value of SETTINGS_INITIAL_WINDOW_SIZE changes, a receiver MUST adjust the size of all stream flow-control windows that it maintains by the difference between the new value and the old value.
  #
  # @return [Boolean] whether the frame was an acknowledgement
  #
  # source://protocol-http2//lib/protocol/http2/connection.rb#253
  def process_settings(frame); end

  # Reads one frame from the network and processes. Processing the frame updates the state of the connection and related streams. If the frame triggers an error, e.g. a protocol error, the connection will typically emit a goaway frame and re-raise the exception. You should continue processing frames until the underlying connection is closed.
  #
  # source://protocol-http2//lib/protocol/http2/connection.rb#149
  def read_frame; end

  # @raise [ProtocolError]
  #
  # source://protocol-http2//lib/protocol/http2/connection.rb#497
  def receive_continuation(frame); end

  # source://protocol-http2//lib/protocol/http2/connection.rb#321
  def receive_data(frame); end

  # source://protocol-http2//lib/protocol/http2/connection.rb#501
  def receive_frame(frame); end

  # source://protocol-http2//lib/protocol/http2/connection.rb#200
  def receive_goaway(frame); end

  # On the server side, starts a new request.
  #
  # source://protocol-http2//lib/protocol/http2/connection.rb#374
  def receive_headers(frame); end

  # source://protocol-http2//lib/protocol/http2/connection.rb#304
  def receive_ping(frame); end

  # source://protocol-http2//lib/protocol/http2/connection.rb#404
  def receive_priority_update(frame); end

  # @raise [ProtocolError]
  #
  # source://protocol-http2//lib/protocol/http2/connection.rb#400
  def receive_push_promise(frame); end

  # source://protocol-http2//lib/protocol/http2/connection.rb#453
  def receive_reset_stream(frame); end

  # source://protocol-http2//lib/protocol/http2/connection.rb#282
  def receive_settings(frame); end

  # source://protocol-http2//lib/protocol/http2/connection.rb#478
  def receive_window_update(frame); end

  # Returns the value of attribute remote_settings.
  #
  # source://protocol-http2//lib/protocol/http2/connection.rb#75
  def remote_settings; end

  # Sets the attribute remote_settings
  #
  # @param value the value to set the attribute remote_settings to.
  #
  # source://protocol-http2//lib/protocol/http2/connection.rb#75
  def remote_settings=(_arg0); end

  # The highest stream_id that has been successfully accepted by this connection.
  #
  # source://protocol-http2//lib/protocol/http2/connection.rb#85
  def remote_stream_id; end

  # Our window for sending data. When we send data, it reduces this window.
  #
  # source://protocol-http2//lib/protocol/http2/connection.rb#82
  def remote_window; end

  # Tell the remote end that the connection is being shut down. If the `error_code` is 0, this is a graceful shutdown. The other end of the connection should not make any new streams, but existing streams may be completed.
  #
  # source://protocol-http2//lib/protocol/http2/connection.rb#191
  def send_goaway(error_code = T.unsafe(nil), message = T.unsafe(nil)); end

  # source://protocol-http2//lib/protocol/http2/connection.rb#293
  def send_ping(data); end

  # source://protocol-http2//lib/protocol/http2/connection.rb#174
  def send_settings(changes); end

  # @return [Boolean]
  #
  # source://protocol-http2//lib/protocol/http2/connection.rb#421
  def server_stream_id?(id); end

  # Connection state (:new, :open, :closed).
  #
  # source://protocol-http2//lib/protocol/http2/connection.rb#71
  def state; end

  # Connection state (:new, :open, :closed).
  #
  # source://protocol-http2//lib/protocol/http2/connection.rb#71
  def state=(_arg0); end

  # Returns the value of attribute streams.
  #
  # source://protocol-http2//lib/protocol/http2/connection.rb#126
  def streams; end

  # source://protocol-http2//lib/protocol/http2/connection.rb#144
  def synchronize; end

  # source://protocol-http2//lib/protocol/http2/connection.rb#232
  def update_local_settings(changes); end

  # source://protocol-http2//lib/protocol/http2/connection.rb#242
  def update_remote_settings(changes); end

  # @return [Boolean]
  #
  # source://protocol-http2//lib/protocol/http2/connection.rb#333
  def valid_remote_stream_id?(stream_id); end

  # source://protocol-http2//lib/protocol/http2/connection.rb#212
  def write_frame(frame); end

  # source://protocol-http2//lib/protocol/http2/connection.rb#220
  def write_frames; end
end

# The CONTINUATION frame is used to continue a sequence of header block fragments. Any number of CONTINUATION frames can be sent, as long as the preceding frame is on the same stream and is a HEADERS, PUSH_PROMISE, or CONTINUATION frame without the END_HEADERS flag set.
#
# +---------------------------------------------------------------+
# +---------------------------------------------------------------+
#
# source://protocol-http2//lib/protocol/http2/continuation_frame.rb#93
class Protocol::HTTP2::ContinuationFrame < ::Protocol::HTTP2::Frame
  include ::Protocol::HTTP2::Continued

  # This is only invoked if the continuation is received out of the normal flow.
  #
  # source://protocol-http2//lib/protocol/http2/continuation_frame.rb#99
  def apply(connection); end

  # source://protocol-http2//lib/protocol/http2/continuation_frame.rb#103
  def inspect; end
end

# source://protocol-http2//lib/protocol/http2/continuation_frame.rb#96
Protocol::HTTP2::ContinuationFrame::TYPE = T.let(T.unsafe(nil), Integer)

# source://protocol-http2//lib/protocol/http2/continuation_frame.rb#10
module Protocol::HTTP2::Continued
  # source://protocol-http2//lib/protocol/http2/continuation_frame.rb#11
  def initialize(*_arg0); end

  # Returns the value of attribute continuation.
  #
  # source://protocol-http2//lib/protocol/http2/continuation_frame.rb#55
  def continuation; end

  # Sets the attribute continuation
  #
  # @param value the value to set the attribute continuation to.
  #
  # source://protocol-http2//lib/protocol/http2/continuation_frame.rb#55
  def continuation=(_arg0); end

  # @return [Boolean]
  #
  # source://protocol-http2//lib/protocol/http2/continuation_frame.rb#17
  def continued?; end

  # @return [Boolean]
  #
  # source://protocol-http2//lib/protocol/http2/continuation_frame.rb#21
  def end_headers?; end

  # source://protocol-http2//lib/protocol/http2/continuation_frame.rb#57
  def pack(data, **options); end

  # source://protocol-http2//lib/protocol/http2/continuation_frame.rb#25
  def read(stream, maximum_frame_size); end

  # source://protocol-http2//lib/protocol/http2/continuation_frame.rb#78
  def unpack; end

  # source://protocol-http2//lib/protocol/http2/continuation_frame.rb#47
  def write(stream); end
end

# DATA frames convey arbitrary, variable-length sequences of octets associated with a stream. One or more DATA frames are used, for instance, to carry HTTP request or response payloads.
#
# DATA frames MAY also contain padding. Padding can be added to DATA frames to obscure the size of messages.
#
# +---------------+
# |Pad Length? (8)|
# +---------------+-----------------------------------------------+
# +---------------------------------------------------------------+
# +---------------------------------------------------------------+
#
# source://protocol-http2//lib/protocol/http2/data_frame.rb#23
class Protocol::HTTP2::DataFrame < ::Protocol::HTTP2::Frame
  include ::Protocol::HTTP2::Padded

  # source://protocol-http2//lib/protocol/http2/data_frame.rb#41
  def apply(connection); end

  # @return [Boolean]
  #
  # source://protocol-http2//lib/protocol/http2/data_frame.rb#28
  def end_stream?; end

  # source://protocol-http2//lib/protocol/http2/data_frame.rb#45
  def inspect; end

  # source://protocol-http2//lib/protocol/http2/data_frame.rb#32
  def pack(data, *arguments, **options); end
end

# source://protocol-http2//lib/protocol/http2/data_frame.rb#26
Protocol::HTTP2::DataFrame::TYPE = T.let(T.unsafe(nil), Integer)

# source://protocol-http2//lib/protocol/http2/frame.rb#12
Protocol::HTTP2::END_HEADERS = T.let(T.unsafe(nil), Integer)

# source://protocol-http2//lib/protocol/http2/frame.rb#11
Protocol::HTTP2::END_STREAM = T.let(T.unsafe(nil), Integer)

# source://protocol-http2//lib/protocol/http2/reset_stream_frame.rb#21
Protocol::HTTP2::ENHANCE_YOUR_CALM = T.let(T.unsafe(nil), Integer)

# Status codes as defined by <https://tools.ietf.org/html/rfc7540#section-7>.
#
# source://protocol-http2//lib/protocol/http2/error.rb#11
class Protocol::HTTP2::Error < ::Protocol::HTTP::Error; end

# Used by the endpoint to indicate that the stream is no longer needed.
#
# source://protocol-http2//lib/protocol/http2/error.rb#37
Protocol::HTTP2::Error::CANCEL = T.let(T.unsafe(nil), Integer)

# The endpoint is unable to maintain the header compression context for the connection.
#
# source://protocol-http2//lib/protocol/http2/error.rb#40
Protocol::HTTP2::Error::COMPRESSION_ERROR = T.let(T.unsafe(nil), Integer)

# The connection established in response to a CONNECT request was reset or abnormally closed.
#
# source://protocol-http2//lib/protocol/http2/error.rb#43
Protocol::HTTP2::Error::CONNECT_ERROR = T.let(T.unsafe(nil), Integer)

# The endpoint detected that its peer is exhibiting a behavior that might be generating excessive load.
#
# source://protocol-http2//lib/protocol/http2/error.rb#46
Protocol::HTTP2::Error::ENHANCE_YOUR_CALM = T.let(T.unsafe(nil), Integer)

# The endpoint detected that its peer violated the flow-control protocol.
#
# source://protocol-http2//lib/protocol/http2/error.rb#22
Protocol::HTTP2::Error::FLOW_CONTROL_ERROR = T.let(T.unsafe(nil), Integer)

# The endpoint received a frame with an invalid size.
#
# source://protocol-http2//lib/protocol/http2/error.rb#31
Protocol::HTTP2::Error::FRAME_SIZE_ERROR = T.let(T.unsafe(nil), Integer)

# The endpoint requires that HTTP/1.1 be used instead of HTTP/2.
#
# source://protocol-http2//lib/protocol/http2/error.rb#52
Protocol::HTTP2::Error::HTTP_1_1_REQUIRED = T.let(T.unsafe(nil), Integer)

# The underlying transport has properties that do not meet minimum security requirements.
#
# source://protocol-http2//lib/protocol/http2/error.rb#49
Protocol::HTTP2::Error::INADEQUATE_SECURITY = T.let(T.unsafe(nil), Integer)

# The endpoint encountered an unexpected internal error.
#
# source://protocol-http2//lib/protocol/http2/error.rb#19
Protocol::HTTP2::Error::INTERNAL_ERROR = T.let(T.unsafe(nil), Integer)

# The associated condition is not a result of an error.  For example, a GOAWAY might include this code to indicate graceful shutdown of a connection.
#
# source://protocol-http2//lib/protocol/http2/error.rb#13
Protocol::HTTP2::Error::NO_ERROR = T.let(T.unsafe(nil), Integer)

# The endpoint detected an unspecific protocol error.  This error is for use when a more specific error code is not available.
#
# source://protocol-http2//lib/protocol/http2/error.rb#16
Protocol::HTTP2::Error::PROTOCOL_ERROR = T.let(T.unsafe(nil), Integer)

# The endpoint refused the stream prior to performing any application processing.
#
# source://protocol-http2//lib/protocol/http2/error.rb#34
Protocol::HTTP2::Error::REFUSED_STREAM = T.let(T.unsafe(nil), Integer)

# The endpoint sent a SETTINGS frame but did not receive a response in a timely manner.
#
# source://protocol-http2//lib/protocol/http2/error.rb#25
Protocol::HTTP2::Error::SETTINGS_TIMEOUT = T.let(T.unsafe(nil), Integer)

# The endpoint received a frame after a stream was half-closed.
#
# source://protocol-http2//lib/protocol/http2/error.rb#28
Protocol::HTTP2::Error::STREAM_CLOSED = T.let(T.unsafe(nil), Integer)

# source://protocol-http2//lib/protocol/http2/reset_stream_frame.rb#13
Protocol::HTTP2::FLOW_CONTROL_ERROR = T.let(T.unsafe(nil), Integer)

# HTTP/2 frame type mapping as defined by the spec
#
# source://protocol-http2//lib/protocol/http2/framer.rb#22
Protocol::HTTP2::FRAMES = T.let(T.unsafe(nil), Array)

# source://protocol-http2//lib/protocol/http2/reset_stream_frame.rb#16
Protocol::HTTP2::FRAME_SIZE_ERROR = T.let(T.unsafe(nil), Integer)

# Raised on invalid flow control frame or command.
#
# source://protocol-http2//lib/protocol/http2/error.rb#100
class Protocol::HTTP2::FlowControlError < ::Protocol::HTTP2::ProtocolError
  # @return [FlowControlError] a new instance of FlowControlError
  #
  # source://protocol-http2//lib/protocol/http2/error.rb#101
  def initialize(message); end
end

# source://protocol-http2//lib/protocol/http2/flow_controlled.rb#11
module Protocol::HTTP2::FlowControlled
  # This could be negative if the window has been overused due to a change in initial window size.
  #
  # source://protocol-http2//lib/protocol/http2/flow_controlled.rb#17
  def available_frame_size(maximum_frame_size = T.unsafe(nil)); end

  # source://protocol-http2//lib/protocol/http2/flow_controlled.rb#12
  def available_size; end

  # source://protocol-http2//lib/protocol/http2/flow_controlled.rb#48
  def consume_local_window(frame); end

  # Keep track of the amount of data sent, and fail if is too much.
  #
  # source://protocol-http2//lib/protocol/http2/flow_controlled.rb#30
  def consume_remote_window(frame); end

  # source://protocol-http2//lib/protocol/http2/flow_controlled.rb#70
  def receive_window_update(frame); end

  # source://protocol-http2//lib/protocol/http2/flow_controlled.rb#54
  def request_window_update; end

  # Notify the remote end that we are prepared to receive more data:
  #
  # source://protocol-http2//lib/protocol/http2/flow_controlled.rb#61
  def send_window_update(window_increment); end

  # source://protocol-http2//lib/protocol/http2/flow_controlled.rb#43
  def update_local_window(frame); end

  # The window has been expanded by the given amount.
  #
  # @return [Boolean] whether the window update was used or not.
  #
  # source://protocol-http2//lib/protocol/http2/flow_controlled.rb#83
  def window_updated(size); end
end

# source://protocol-http2//lib/protocol/http2/frame.rb#20
class Protocol::HTTP2::Frame
  include ::Comparable

  # @return [Frame] a new instance of Frame
  #
  # source://protocol-http2//lib/protocol/http2/frame.rb#38
  def initialize(stream_id = T.unsafe(nil), flags = T.unsafe(nil), type = T.unsafe(nil), length = T.unsafe(nil), payload = T.unsafe(nil)); end

  # source://protocol-http2//lib/protocol/http2/frame.rb#50
  def <=>(other); end

  # source://protocol-http2//lib/protocol/http2/frame.rb#199
  def apply(connection); end

  # source://protocol-http2//lib/protocol/http2/frame.rb#93
  def clear_flags(mask); end

  # Check if frame is a connection frame: SETTINGS, PING, GOAWAY, and any
  # frame addressed to stream ID = 0.
  #
  # @return [Boolean]
  #
  # source://protocol-http2//lib/protocol/http2/frame.rb#105
  def connection?; end

  # @return [Boolean]
  #
  # source://protocol-http2//lib/protocol/http2/frame.rb#97
  def flag_set?(mask); end

  # Returns the value of attribute flags.
  #
  # source://protocol-http2//lib/protocol/http2/frame.rb#72
  def flags; end

  # Sets the attribute flags
  #
  # @param value the value to set the attribute flags to.
  #
  # source://protocol-http2//lib/protocol/http2/frame.rb#72
  def flags=(_arg0); end

  # Generates common 9-byte frame header.
  # - http://tools.ietf.org/html/draft-ietf-httpbis-http2-16#section-4.1
  #
  # @return [String]
  #
  # source://protocol-http2//lib/protocol/http2/frame.rb#116
  def header; end

  # source://protocol-http2//lib/protocol/http2/frame.rb#203
  def inspect; end

  # The generic frame header uses the following binary representation:
  #
  # +-----------------------------------------------+
  # +---------------+---------------+---------------+
  # +-+-------------+---------------+-------------------------------+
  # |R|                 Stream Identifier (31)                      |
  # +=+=============================================================+
  # +---------------------------------------------------------------+
  #
  # source://protocol-http2//lib/protocol/http2/frame.rb#70
  def length; end

  # The generic frame header uses the following binary representation:
  #
  # +-----------------------------------------------+
  # +---------------+---------------+---------------+
  # +-+-------------+---------------+-------------------------------+
  # |R|                 Stream Identifier (31)                      |
  # +=+=============================================================+
  # +---------------------------------------------------------------+
  #
  # source://protocol-http2//lib/protocol/http2/frame.rb#70
  def length=(_arg0); end

  # source://protocol-http2//lib/protocol/http2/frame.rb#80
  def pack(payload, maximum_size: T.unsafe(nil)); end

  # Returns the value of attribute payload.
  #
  # source://protocol-http2//lib/protocol/http2/frame.rb#74
  def payload; end

  # Sets the attribute payload
  #
  # @param value the value to set the attribute payload to.
  #
  # source://protocol-http2//lib/protocol/http2/frame.rb#74
  def payload=(_arg0); end

  # source://protocol-http2//lib/protocol/http2/frame.rb#165
  def read(stream, maximum_frame_size = T.unsafe(nil)); end

  # source://protocol-http2//lib/protocol/http2/frame.rb#148
  def read_header(stream); end

  # source://protocol-http2//lib/protocol/http2/frame.rb#157
  def read_payload(stream); end

  # source://protocol-http2//lib/protocol/http2/frame.rb#89
  def set_flags(mask); end

  # Returns the value of attribute stream_id.
  #
  # source://protocol-http2//lib/protocol/http2/frame.rb#73
  def stream_id; end

  # Sets the attribute stream_id
  #
  # @param value the value to set the attribute stream_id to.
  #
  # source://protocol-http2//lib/protocol/http2/frame.rb#73
  def stream_id=(_arg0); end

  # source://protocol-http2//lib/protocol/http2/frame.rb#54
  def to_ary; end

  # Returns the value of attribute type.
  #
  # source://protocol-http2//lib/protocol/http2/frame.rb#71
  def type; end

  # Sets the attribute type
  #
  # @param value the value to set the attribute type to.
  #
  # source://protocol-http2//lib/protocol/http2/frame.rb#71
  def type=(_arg0); end

  # source://protocol-http2//lib/protocol/http2/frame.rb#76
  def unpack; end

  # @return [Boolean]
  #
  # source://protocol-http2//lib/protocol/http2/frame.rb#46
  def valid_type?; end

  # source://protocol-http2//lib/protocol/http2/frame.rb#183
  def write(stream); end

  # source://protocol-http2//lib/protocol/http2/frame.rb#175
  def write_header(stream); end

  # source://protocol-http2//lib/protocol/http2/frame.rb#179
  def write_payload(stream); end

  class << self
    # Decodes common 9-byte header.
    #
    # source://protocol-http2//lib/protocol/http2/frame.rb#138
    def parse_header(buffer); end
  end
end

# source://protocol-http2//lib/protocol/http2/frame.rb#109
Protocol::HTTP2::Frame::HEADER_FORMAT = T.let(T.unsafe(nil), String)

# Used for generating 24-bit frame length:
#
# source://protocol-http2//lib/protocol/http2/frame.rb#31
Protocol::HTTP2::Frame::LENGTH_HISHIFT = T.let(T.unsafe(nil), Integer)

# source://protocol-http2//lib/protocol/http2/frame.rb#32
Protocol::HTTP2::Frame::LENGTH_LOMASK = T.let(T.unsafe(nil), Integer)

# source://protocol-http2//lib/protocol/http2/frame.rb#110
Protocol::HTTP2::Frame::STREAM_ID_MASK = T.let(T.unsafe(nil), Integer)

# The base class does not have any specific type index:
#
# source://protocol-http2//lib/protocol/http2/frame.rb#35
Protocol::HTTP2::Frame::TYPE = T.let(T.unsafe(nil), T.untyped)

# The absolute maximum bounds for the length field:
#
# source://protocol-http2//lib/protocol/http2/frame.rb#28
Protocol::HTTP2::Frame::VALID_LENGTH = T.let(T.unsafe(nil), Range)

# Stream Identifier cannot be bigger than this:
# https://http2.github.stream/http2-spec/#rfc.section.4.1
#
# source://protocol-http2//lib/protocol/http2/frame.rb#25
Protocol::HTTP2::Frame::VALID_STREAM_ID = T.let(T.unsafe(nil), Range)

# When the frame payload does not match expectations.
#
# source://protocol-http2//lib/protocol/http2/error.rb#87
class Protocol::HTTP2::FrameSizeError < ::Protocol::HTTP2::ProtocolError
  # @return [FrameSizeError] a new instance of FrameSizeError
  #
  # source://protocol-http2//lib/protocol/http2/error.rb#88
  def initialize(message); end
end

# source://protocol-http2//lib/protocol/http2/framer.rb#45
class Protocol::HTTP2::Framer
  # @return [Framer] a new instance of Framer
  #
  # source://protocol-http2//lib/protocol/http2/framer.rb#46
  def initialize(stream, frames = T.unsafe(nil)); end

  # source://protocol-http2//lib/protocol/http2/framer.rb#55
  def close; end

  # @return [Boolean]
  #
  # source://protocol-http2//lib/protocol/http2/framer.rb#59
  def closed?; end

  # source://protocol-http2//lib/protocol/http2/framer.rb#51
  def flush; end

  # source://protocol-http2//lib/protocol/http2/framer.rb#67
  def read_connection_preface; end

  # @raise if the underlying IO fails for some reason.
  # @return [Frame] the frame that has been read from the underlying IO.
  #
  # source://protocol-http2//lib/protocol/http2/framer.rb#79
  def read_frame(maximum_frame_size = T.unsafe(nil)); end

  # @raise [EOFError]
  #
  # source://protocol-http2//lib/protocol/http2/framer.rb#108
  def read_header; end

  # source://protocol-http2//lib/protocol/http2/framer.rb#63
  def write_connection_preface; end

  # Write a frame to the underlying IO.
  # After writing one or more frames, you should call flush to ensure the frames are sent to the remote peer.
  #
  # source://protocol-http2//lib/protocol/http2/framer.rb#100
  def write_frame(frame); end
end

# source://protocol-http2//lib/protocol/http2/error.rb#83
class Protocol::HTTP2::GoawayError < ::Protocol::HTTP2::ProtocolError; end

# The GOAWAY frame is used to initiate shutdown of a connection or to signal serious error conditions. GOAWAY allows an endpoint to gracefully stop accepting new streams while still finishing processing of previously established streams. This enables administrative actions, like server maintenance.
#
# +-+-------------------------------------------------------------+
# |R|                  Last-Stream-ID (31)                        |
# +-+-------------------------------------------------------------+
# +---------------------------------------------------------------+
# +---------------------------------------------------------------+
#
# source://protocol-http2//lib/protocol/http2/goaway_frame.rb#20
class Protocol::HTTP2::GoawayFrame < ::Protocol::HTTP2::Frame
  # source://protocol-http2//lib/protocol/http2/goaway_frame.rb#40
  def apply(connection); end

  # @return [Boolean]
  #
  # source://protocol-http2//lib/protocol/http2/goaway_frame.rb#24
  def connection?; end

  # source://protocol-http2//lib/protocol/http2/goaway_frame.rb#36
  def pack(last_stream_id, error_code, data); end

  # source://protocol-http2//lib/protocol/http2/goaway_frame.rb#28
  def unpack; end
end

# source://protocol-http2//lib/protocol/http2/goaway_frame.rb#22
Protocol::HTTP2::GoawayFrame::FORMAT = T.let(T.unsafe(nil), String)

# source://protocol-http2//lib/protocol/http2/goaway_frame.rb#21
Protocol::HTTP2::GoawayFrame::TYPE = T.let(T.unsafe(nil), Integer)

# source://protocol-http2//lib/protocol/http2/reset_stream_frame.rb#23
Protocol::HTTP2::HTTP_1_1_REQUIRED = T.let(T.unsafe(nil), Integer)

# Raised if connection header is missing or invalid indicating that
# this is an invalid HTTP 2.0 request - no frames are emitted and the
# connection must be aborted.
#
# source://protocol-http2//lib/protocol/http2/error.rb#58
class Protocol::HTTP2::HandshakeError < ::Protocol::HTTP2::Error; end

# source://protocol-http2//lib/protocol/http2/error.rb#93
class Protocol::HTTP2::HeaderError < ::Protocol::HTTP2::StreamClosed
  # @return [HeaderError] a new instance of HeaderError
  #
  # source://protocol-http2//lib/protocol/http2/error.rb#94
  def initialize(message); end
end

# The HEADERS frame is used to open a stream, and additionally carries a header block fragment. HEADERS frames can be sent on a stream in the "idle", "reserved (local)", "open", or "half-closed (remote)" state.
#
# +---------------+
# |Pad Length? (8)|
# +-+-------------+-----------------------------------------------+
# |E|                 Stream Dependency? (31)                     |
# +-+-------------+-----------------------------------------------+
# +-+-------------+-----------------------------------------------+
# +---------------------------------------------------------------+
# +---------------------------------------------------------------+
#
# source://protocol-http2//lib/protocol/http2/headers_frame.rb#26
class Protocol::HTTP2::HeadersFrame < ::Protocol::HTTP2::Frame
  include ::Protocol::HTTP2::Padded
  include ::Protocol::HTTP2::Continued

  # source://protocol-http2//lib/protocol/http2/headers_frame.rb#58
  def apply(connection); end

  # @return [Boolean]
  #
  # source://protocol-http2//lib/protocol/http2/headers_frame.rb#35
  def end_stream?; end

  # source://protocol-http2//lib/protocol/http2/headers_frame.rb#62
  def inspect; end

  # source://protocol-http2//lib/protocol/http2/headers_frame.rb#50
  def pack(data, *arguments, **options); end

  # @return [Boolean]
  #
  # source://protocol-http2//lib/protocol/http2/headers_frame.rb#31
  def priority?; end

  # source://protocol-http2//lib/protocol/http2/headers_frame.rb#39
  def unpack; end
end

# source://protocol-http2//lib/protocol/http2/headers_frame.rb#29
Protocol::HTTP2::HeadersFrame::TYPE = T.let(T.unsafe(nil), Integer)

# source://protocol-http2//lib/protocol/http2/reset_stream_frame.rb#22
Protocol::HTTP2::INADEQUATE_SECURITY = T.let(T.unsafe(nil), Integer)

# source://protocol-http2//lib/protocol/http2/reset_stream_frame.rb#12
Protocol::HTTP2::INTERNAL_ERROR = T.let(T.unsafe(nil), Integer)

# This is a window which efficiently maintains a desired capacity.
#
# source://protocol-http2//lib/protocol/http2/window.rb#82
class Protocol::HTTP2::LocalWindow < ::Protocol::HTTP2::Window
  # @return [LocalWindow] a new instance of LocalWindow
  #
  # source://protocol-http2//lib/protocol/http2/window.rb#83
  def initialize(capacity = T.unsafe(nil), desired: T.unsafe(nil)); end

  # The desired capacity of the window.
  #
  # source://protocol-http2//lib/protocol/http2/window.rb#92
  def desired; end

  # The desired capacity of the window.
  #
  # source://protocol-http2//lib/protocol/http2/window.rb#92
  def desired=(_arg0); end

  # source://protocol-http2//lib/protocol/http2/window.rb#112
  def inspect; end

  # @return [Boolean]
  #
  # source://protocol-http2//lib/protocol/http2/window.rb#103
  def limited?; end

  # source://protocol-http2//lib/protocol/http2/window.rb#94
  def wanted; end
end

# source://protocol-http2//lib/protocol/http2/frame.rb#18
Protocol::HTTP2::MAXIMUM_ALLOWED_FRAME_SIZE = T.let(T.unsafe(nil), Integer)

# source://protocol-http2//lib/protocol/http2/frame.rb#16
Protocol::HTTP2::MAXIMUM_ALLOWED_WINDOW_SIZE = T.let(T.unsafe(nil), Integer)

# source://protocol-http2//lib/protocol/http2/frame.rb#17
Protocol::HTTP2::MINIMUM_ALLOWED_FRAME_SIZE = T.let(T.unsafe(nil), Integer)

# source://protocol-http2//lib/protocol/http2/reset_stream_frame.rb#10
Protocol::HTTP2::NO_ERROR = T.let(T.unsafe(nil), Integer)

# source://protocol-http2//lib/protocol/http2/frame.rb#13
Protocol::HTTP2::PADDED = T.let(T.unsafe(nil), Integer)

# source://protocol-http2//lib/protocol/http2/frame.rb#14
Protocol::HTTP2::PRIORITY = T.let(T.unsafe(nil), Integer)

# source://protocol-http2//lib/protocol/http2/reset_stream_frame.rb#11
Protocol::HTTP2::PROTOCOL_ERROR = T.let(T.unsafe(nil), Integer)

# Certain frames can have padding:
# https://http2.github.io/http2-spec/#padding
#
# +---------------+
# |Pad Length? (8)|
# +---------------+-----------------------------------------------+
# +---------------------------------------------------------------+
# +---------------------------------------------------------------+
#
# source://protocol-http2//lib/protocol/http2/padded.rb#21
module Protocol::HTTP2::Padded
  # source://protocol-http2//lib/protocol/http2/padded.rb#26
  def pack(data, padding_size: T.unsafe(nil), maximum_size: T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://protocol-http2//lib/protocol/http2/padded.rb#22
  def padded?; end

  # source://protocol-http2//lib/protocol/http2/padded.rb#47
  def unpack; end
end

# source://protocol-http2//lib/protocol/http2/settings_frame.rb#131
class Protocol::HTTP2::PendingSettings
  # @return [PendingSettings] a new instance of PendingSettings
  #
  # source://protocol-http2//lib/protocol/http2/settings_frame.rb#132
  def initialize(current = T.unsafe(nil)); end

  # source://protocol-http2//lib/protocol/http2/settings_frame.rb#147
  def acknowledge; end

  # source://protocol-http2//lib/protocol/http2/settings_frame.rb#142
  def append(changes); end

  # Returns the value of attribute current.
  #
  # source://protocol-http2//lib/protocol/http2/settings_frame.rb#139
  def current; end

  # source://protocol-http2//lib/protocol/http2/settings_frame.rb#181
  def enable_connect_protocol; end

  # source://protocol-http2//lib/protocol/http2/settings_frame.rb#161
  def enable_push; end

  # source://protocol-http2//lib/protocol/http2/settings_frame.rb#157
  def header_table_size; end

  # source://protocol-http2//lib/protocol/http2/settings_frame.rb#169
  def initial_window_size; end

  # source://protocol-http2//lib/protocol/http2/settings_frame.rb#165
  def maximum_concurrent_streams; end

  # source://protocol-http2//lib/protocol/http2/settings_frame.rb#173
  def maximum_frame_size; end

  # source://protocol-http2//lib/protocol/http2/settings_frame.rb#177
  def maximum_header_list_size; end

  # Returns the value of attribute pending.
  #
  # source://protocol-http2//lib/protocol/http2/settings_frame.rb#140
  def pending; end
end

# The PING frame is a mechanism for measuring a minimal round-trip time from the sender, as well as determining whether an idle connection is still functional. PING frames can be sent from any endpoint.
#
# +---------------------------------------------------------------+
# +---------------------------------------------------------------+
#
# source://protocol-http2//lib/protocol/http2/ping_frame.rb#39
class Protocol::HTTP2::PingFrame < ::Protocol::HTTP2::Frame
  include ::Protocol::HTTP2::Acknowledgement

  # source://protocol-http2//lib/protocol/http2/ping_frame.rb#52
  def acknowledge; end

  # source://protocol-http2//lib/protocol/http2/ping_frame.rb#48
  def apply(connection); end

  # @return [Boolean]
  #
  # source://protocol-http2//lib/protocol/http2/ping_frame.rb#44
  def connection?; end

  # source://protocol-http2//lib/protocol/http2/ping_frame.rb#60
  def read_payload(stream); end
end

# source://protocol-http2//lib/protocol/http2/ping_frame.rb#40
Protocol::HTTP2::PingFrame::TYPE = T.let(T.unsafe(nil), Integer)

# The PRIORITY_UPDATE frame is used by clients to signal the initial priority of a response, or to reprioritize a response or push stream. It carries the stream ID of the response and the priority in ASCII text, using the same representation as the Priority header field value.
#
# +-+-------------+-----------------------------------------------+
# |R|                 Prioritized Stream ID (31)                  |
# +-+-----------------------------+-------------------------------+
# +---------------------------------------------------------------+
#
# source://protocol-http2//lib/protocol/http2/priority_update_frame.rb#20
class Protocol::HTTP2::PriorityUpdateFrame < ::Protocol::HTTP2::Frame
  # source://protocol-http2//lib/protocol/http2/priority_update_frame.rb#36
  def apply(connection); end

  # source://protocol-http2//lib/protocol/http2/priority_update_frame.rb#32
  def pack(prioritized_stream_id, data, **options); end

  # source://protocol-http2//lib/protocol/http2/priority_update_frame.rb#24
  def unpack; end
end

# source://protocol-http2//lib/protocol/http2/priority_update_frame.rb#22
Protocol::HTTP2::PriorityUpdateFrame::FORMAT = T.let(T.unsafe(nil), String)

# source://protocol-http2//lib/protocol/http2/priority_update_frame.rb#21
Protocol::HTTP2::PriorityUpdateFrame::TYPE = T.let(T.unsafe(nil), Integer)

# Raised by stream or connection handlers, results in GOAWAY frame
# which signals termination of the current connection. You *cannot*
# recover from this exception, or any exceptions subclassed from it.
#
# source://protocol-http2//lib/protocol/http2/error.rb#64
class Protocol::HTTP2::ProtocolError < ::Protocol::HTTP2::Error
  # @return [ProtocolError] a new instance of ProtocolError
  #
  # source://protocol-http2//lib/protocol/http2/error.rb#65
  def initialize(message, code = T.unsafe(nil)); end

  # Returns the value of attribute code.
  #
  # source://protocol-http2//lib/protocol/http2/error.rb#71
  def code; end
end

# The PUSH_PROMISE frame is used to notify the peer endpoint in advance of streams the sender intends to initiate. The PUSH_PROMISE frame includes the unsigned 31-bit identifier of the stream the endpoint plans to create along with a set of headers that provide additional context for the stream.
#
# +---------------+
# |Pad Length? (8)|
# +-+-------------+-----------------------------------------------+
# |R|                  Promised Stream ID (31)                    |
# +-+-----------------------------+-------------------------------+
# +---------------------------------------------------------------+
# +---------------------------------------------------------------+
#
# source://protocol-http2//lib/protocol/http2/push_promise_frame.rb#24
class Protocol::HTTP2::PushPromiseFrame < ::Protocol::HTTP2::Frame
  include ::Protocol::HTTP2::Padded
  include ::Protocol::HTTP2::Continued

  # source://protocol-http2//lib/protocol/http2/push_promise_frame.rb#42
  def apply(connection); end

  # source://protocol-http2//lib/protocol/http2/push_promise_frame.rb#38
  def pack(stream_id, data, *arguments, **options); end

  # source://protocol-http2//lib/protocol/http2/push_promise_frame.rb#30
  def unpack; end
end

# source://protocol-http2//lib/protocol/http2/push_promise_frame.rb#28
Protocol::HTTP2::PushPromiseFrame::FORMAT = T.let(T.unsafe(nil), String)

# source://protocol-http2//lib/protocol/http2/push_promise_frame.rb#27
Protocol::HTTP2::PushPromiseFrame::TYPE = T.let(T.unsafe(nil), Integer)

# source://protocol-http2//lib/protocol/http2/reset_stream_frame.rb#17
Protocol::HTTP2::REFUSED_STREAM = T.let(T.unsafe(nil), Integer)

# The RST_STREAM frame allows for immediate termination of a stream. RST_STREAM is sent to request cancellation of a stream or to indicate that an error condition has occurred.
#
# +---------------------------------------------------------------+
# +---------------------------------------------------------------+
#
# source://protocol-http2//lib/protocol/http2/reset_stream_frame.rb#31
class Protocol::HTTP2::ResetStreamFrame < ::Protocol::HTTP2::Frame
  # source://protocol-http2//lib/protocol/http2/reset_stream_frame.rb#44
  def apply(connection); end

  # source://protocol-http2//lib/protocol/http2/reset_stream_frame.rb#39
  def pack(error_code = T.unsafe(nil)); end

  # source://protocol-http2//lib/protocol/http2/reset_stream_frame.rb#48
  def read_payload(stream); end

  # source://protocol-http2//lib/protocol/http2/reset_stream_frame.rb#35
  def unpack; end
end

# source://protocol-http2//lib/protocol/http2/reset_stream_frame.rb#33
Protocol::HTTP2::ResetStreamFrame::FORMAT = T.let(T.unsafe(nil), String)

# source://protocol-http2//lib/protocol/http2/reset_stream_frame.rb#32
Protocol::HTTP2::ResetStreamFrame::TYPE = T.let(T.unsafe(nil), Integer)

# source://protocol-http2//lib/protocol/http2/reset_stream_frame.rb#15
Protocol::HTTP2::STREAM_CLOSED = T.let(T.unsafe(nil), Integer)

# source://protocol-http2//lib/protocol/http2/server.rb#10
class Protocol::HTTP2::Server < ::Protocol::HTTP2::Connection
  # @return [Server] a new instance of Server
  #
  # source://protocol-http2//lib/protocol/http2/server.rb#11
  def initialize(framer); end

  # @raise [ProtocolError]
  #
  # source://protocol-http2//lib/protocol/http2/server.rb#43
  def accept_push_promise_stream(stream_id, &block); end

  # @return [Boolean]
  #
  # source://protocol-http2//lib/protocol/http2/server.rb#47
  def enable_push?; end

  # @return [Boolean]
  #
  # source://protocol-http2//lib/protocol/http2/server.rb#15
  def local_stream_id?(id); end

  # source://protocol-http2//lib/protocol/http2/server.rb#27
  def read_connection_preface(settings = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://protocol-http2//lib/protocol/http2/server.rb#19
  def remote_stream_id?(id); end

  # @return [Boolean]
  #
  # source://protocol-http2//lib/protocol/http2/server.rb#23
  def valid_remote_stream_id?(stream_id); end
end

# source://protocol-http2//lib/protocol/http2/settings_frame.rb#10
class Protocol::HTTP2::Settings
  # @return [Settings] a new instance of Settings
  #
  # source://protocol-http2//lib/protocol/http2/settings_frame.rb#33
  def initialize; end

  # Returns the value of attribute enable_connect_protocol.
  #
  # source://protocol-http2//lib/protocol/http2/settings_frame.rb#94
  def enable_connect_protocol; end

  # source://protocol-http2//lib/protocol/http2/settings_frame.rb#96
  def enable_connect_protocol=(value); end

  # @return [Boolean]
  #
  # source://protocol-http2//lib/protocol/http2/settings_frame.rb#104
  def enable_connect_protocol?; end

  # This setting can be used to disable server push. An endpoint MUST NOT send a PUSH_PROMISE frame if it receives this parameter set to a value of 0.
  #
  # source://protocol-http2//lib/protocol/http2/settings_frame.rb#50
  def enable_push; end

  # source://protocol-http2//lib/protocol/http2/settings_frame.rb#52
  def enable_push=(value); end

  # @return [Boolean]
  #
  # source://protocol-http2//lib/protocol/http2/settings_frame.rb#60
  def enable_push?; end

  # Allows the sender to inform the remote endpoint of the maximum size of the header compression table used to decode header blocks, in octets.
  #
  # source://protocol-http2//lib/protocol/http2/settings_frame.rb#47
  def header_table_size; end

  # Allows the sender to inform the remote endpoint of the maximum size of the header compression table used to decode header blocks, in octets.
  #
  # source://protocol-http2//lib/protocol/http2/settings_frame.rb#47
  def header_table_size=(_arg0); end

  # Indicates the sender's initial window size (in octets) for stream-level flow control.
  #
  # source://protocol-http2//lib/protocol/http2/settings_frame.rb#68
  def initial_window_size; end

  # source://protocol-http2//lib/protocol/http2/settings_frame.rb#70
  def initial_window_size=(value); end

  # Indicates the maximum number of concurrent streams that the sender will allow.
  #
  # source://protocol-http2//lib/protocol/http2/settings_frame.rb#65
  def maximum_concurrent_streams; end

  # Indicates the maximum number of concurrent streams that the sender will allow.
  #
  # source://protocol-http2//lib/protocol/http2/settings_frame.rb#65
  def maximum_concurrent_streams=(_arg0); end

  # Indicates the size of the largest frame payload that the sender is willing to receive, in octets.
  #
  # source://protocol-http2//lib/protocol/http2/settings_frame.rb#79
  def maximum_frame_size; end

  # source://protocol-http2//lib/protocol/http2/settings_frame.rb#81
  def maximum_frame_size=(value); end

  # This advisory setting informs a peer of the maximum size of header list that the sender is prepared to accept, in octets.
  #
  # source://protocol-http2//lib/protocol/http2/settings_frame.rb#92
  def maximum_header_list_size; end

  # This advisory setting informs a peer of the maximum size of header list that the sender is prepared to accept, in octets.
  #
  # source://protocol-http2//lib/protocol/http2/settings_frame.rb#92
  def maximum_header_list_size=(_arg0); end

  # Returns the value of attribute no_rfc7540_priorities.
  #
  # source://protocol-http2//lib/protocol/http2/settings_frame.rb#108
  def no_rfc7540_priorities; end

  # source://protocol-http2//lib/protocol/http2/settings_frame.rb#110
  def no_rfc7540_priorities=(value); end

  # @return [Boolean]
  #
  # source://protocol-http2//lib/protocol/http2/settings_frame.rb#118
  def no_rfc7540_priorities?; end

  # source://protocol-http2//lib/protocol/http2/settings_frame.rb#122
  def update(changes); end
end

# source://protocol-http2//lib/protocol/http2/settings_frame.rb#20
Protocol::HTTP2::Settings::ASSIGN = T.let(T.unsafe(nil), Array)

# source://protocol-http2//lib/protocol/http2/settings_frame.rb#17
Protocol::HTTP2::Settings::ENABLE_CONNECT_PROTOCOL = T.let(T.unsafe(nil), Integer)

# source://protocol-http2//lib/protocol/http2/settings_frame.rb#12
Protocol::HTTP2::Settings::ENABLE_PUSH = T.let(T.unsafe(nil), Integer)

# source://protocol-http2//lib/protocol/http2/settings_frame.rb#11
Protocol::HTTP2::Settings::HEADER_TABLE_SIZE = T.let(T.unsafe(nil), Integer)

# source://protocol-http2//lib/protocol/http2/settings_frame.rb#14
Protocol::HTTP2::Settings::INITIAL_WINDOW_SIZE = T.let(T.unsafe(nil), Integer)

# source://protocol-http2//lib/protocol/http2/settings_frame.rb#13
Protocol::HTTP2::Settings::MAXIMUM_CONCURRENT_STREAMS = T.let(T.unsafe(nil), Integer)

# source://protocol-http2//lib/protocol/http2/settings_frame.rb#15
Protocol::HTTP2::Settings::MAXIMUM_FRAME_SIZE = T.let(T.unsafe(nil), Integer)

# source://protocol-http2//lib/protocol/http2/settings_frame.rb#16
Protocol::HTTP2::Settings::MAXIMUM_HEADER_LIST_SIZE = T.let(T.unsafe(nil), Integer)

# source://protocol-http2//lib/protocol/http2/settings_frame.rb#18
Protocol::HTTP2::Settings::NO_RFC7540_PRIORITIES = T.let(T.unsafe(nil), Integer)

# The SETTINGS frame conveys configuration parameters that affect how endpoints communicate, such as preferences and constraints on peer behavior. The SETTINGS frame is also used to acknowledge the receipt of those parameters. Individually, a SETTINGS parameter can also be referred to as a "setting".
#
# +-------------------------------+
# +-------------------------------+-------------------------------+
# +---------------------------------------------------------------+
#
# source://protocol-http2//lib/protocol/http2/settings_frame.rb#194
class Protocol::HTTP2::SettingsFrame < ::Protocol::HTTP2::Frame
  include ::Protocol::HTTP2::Acknowledgement

  # source://protocol-http2//lib/protocol/http2/settings_frame.rb#217
  def apply(connection); end

  # @return [Boolean]
  #
  # source://protocol-http2//lib/protocol/http2/settings_frame.rb#200
  def connection?; end

  # source://protocol-http2//lib/protocol/http2/settings_frame.rb#213
  def pack(settings = T.unsafe(nil)); end

  # source://protocol-http2//lib/protocol/http2/settings_frame.rb#221
  def read_payload(stream); end

  # source://protocol-http2//lib/protocol/http2/settings_frame.rb#204
  def unpack; end
end

# source://protocol-http2//lib/protocol/http2/settings_frame.rb#196
Protocol::HTTP2::SettingsFrame::FORMAT = T.let(T.unsafe(nil), String)

# source://protocol-http2//lib/protocol/http2/settings_frame.rb#195
Protocol::HTTP2::SettingsFrame::TYPE = T.let(T.unsafe(nil), Integer)

# A single HTTP/2 connection can multiplex multiple streams in parallel:
# multiple requests and responses can be in flight simultaneously and stream
# data can be interleaved and prioritized.
#
# This class encapsulates all of the state, transition, flow-control, and
# error management as defined by the HTTP 2.0 specification. All you have
# to do is subscribe to appropriate events (marked with ":" prefix in
# diagram below) and provide your application logic to handle request
# and response processing.
#
# ```
#                          ┌────────┐
#                  send PP │        │ recv PP
#               ┌──────────┤  idle  ├──────────┐
#               │          │        │          │
#               ▼          └───┬────┘          ▼
#        ┌──────────┐          │           ┌──────────┐
#        │          │          │ send H /  │          │
# ┌──────┼ reserved │          │ recv H    │ reserved ├──────┐
# │      │ (local)  │          │           │ (remote) │      │
# │      └───┬──────┘          ▼           └──────┬───┘      │
# │          │             ┌────────┐             │          │
# │          │     recv ES │        │ send ES     │          │
# │   send H │   ┌─────────┤  open  ├─────────┐   │ recv H   │
# │          │   │         │        │         │   │          │
# │          ▼   ▼         └───┬────┘         ▼   ▼          │
# │      ┌──────────┐          │           ┌──────────┐      │
# │      │   half   │          │           │   half   │      │
# │      │  closed  │          │ send R /  │  closed  │      │
# │      │ (remote) │          │ recv R    │ (local)  │      │
# │      └────┬─────┘          │           └─────┬────┘      │
# │           │                │                 │           │
# │           │ send ES /      │       recv ES / │           │
# │           │ send R /       ▼        send R / │           │
# │           │ recv R     ┌────────┐   recv R   │           │
# │ send R /  └───────────►│        │◄───────────┘  send R / │
# │ recv R                 │ closed │               recv R   │
# └───────────────────────►│        │◄───────────────────────┘
#                          └────────┘
# ```
#
# - `send`: endpoint sends this frame
# - `recv`: endpoint receives this frame
#
# - H:  HEADERS frame (with implied CONTINUATIONs)
# - PP: PUSH_PROMISE frame (with implied CONTINUATIONs)
# - ES: END_STREAM flag
# - R:  RST_STREAM frame
#
# State transition methods use a trailing "!".
#
# source://protocol-http2//lib/protocol/http2/stream.rb#60
class Protocol::HTTP2::Stream
  include ::Protocol::HTTP2::FlowControlled

  # @return [Stream] a new instance of Stream
  #
  # source://protocol-http2//lib/protocol/http2/stream.rb#71
  def initialize(connection, id, state = T.unsafe(nil)); end

  # Override this function to implement your own push promise logic.
  #
  # source://protocol-http2//lib/protocol/http2/stream.rb#401
  def accept_push_promise_stream(stream_id, headers); end

  # @return [Boolean]
  #
  # source://protocol-http2//lib/protocol/http2/stream.rb#106
  def active?; end

  # Transition directly to closed state. Do not pass go, do not collect $200.
  # This method should only be used by `Connection#close`.
  #
  # source://protocol-http2//lib/protocol/http2/stream.rb#116
  def close(error = T.unsafe(nil)); end

  # Transition the stream into the closed state.
  #
  # source://protocol-http2//lib/protocol/http2/stream.rb#224
  def close!(error_code = T.unsafe(nil)); end

  # The stream has been closed. If closed due to a stream reset, the error will be set.
  #
  # source://protocol-http2//lib/protocol/http2/stream.rb#219
  def closed(error = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://protocol-http2//lib/protocol/http2/stream.rb#110
  def closed?; end

  # The connection this stream belongs to.
  #
  # source://protocol-http2//lib/protocol/http2/stream.rb#84
  def connection; end

  # source://protocol-http2//lib/protocol/http2/stream.rb#173
  def consume_remote_window(frame); end

  # Override this function to implement your own push promise logic.
  #
  # source://protocol-http2//lib/protocol/http2/stream.rb#379
  def create_push_promise_stream(headers); end

  # Stream ID (odd for client initiated streams, even otherwise).
  #
  # source://protocol-http2//lib/protocol/http2/stream.rb#87
  def id; end

  # source://protocol-http2//lib/protocol/http2/stream.rb#298
  def ignore_data(frame); end

  # source://protocol-http2//lib/protocol/http2/stream.rb#415
  def inspect; end

  # Returns the value of attribute local_window.
  #
  # source://protocol-http2//lib/protocol/http2/stream.rb#92
  def local_window; end

  # source://protocol-http2//lib/protocol/http2/stream.rb#98
  def maximum_frame_size; end

  # source://protocol-http2//lib/protocol/http2/stream.rb#208
  def open!; end

  # Returns the value of attribute priority.
  #
  # source://protocol-http2//lib/protocol/http2/stream.rb#96
  def priority; end

  # Sets the attribute priority
  #
  # @param value the value to set the attribute priority to.
  #
  # source://protocol-http2//lib/protocol/http2/stream.rb#96
  def priority=(_arg0); end

  # @return [String] the data that was received.
  #
  # source://protocol-http2//lib/protocol/http2/stream.rb#294
  def process_data(frame); end

  # source://protocol-http2//lib/protocol/http2/stream.rb#250
  def process_headers(frame); end

  # DATA frames are subject to flow control and can only be sent when a stream is in the "open" or "half-closed (remote)" state.  The entire DATA frame payload is included in flow control, including the Pad Length and Padding fields if present.  If a DATA frame is received whose stream is not in "open" or "half-closed (local)" state, the recipient MUST respond with a stream error of type STREAM_CLOSED.
  #
  # source://protocol-http2//lib/protocol/http2/stream.rb#303
  def receive_data(frame); end

  # source://protocol-http2//lib/protocol/http2/stream.rb#261
  def receive_headers(frame); end

  # source://protocol-http2//lib/protocol/http2/stream.rb#405
  def receive_push_promise(frame); end

  # source://protocol-http2//lib/protocol/http2/stream.rb#328
  def receive_reset_stream(frame); end

  # Returns the value of attribute remote_window.
  #
  # source://protocol-http2//lib/protocol/http2/stream.rb#93
  def remote_window; end

  # source://protocol-http2//lib/protocol/http2/stream.rb#358
  def reserved_local!; end

  # source://protocol-http2//lib/protocol/http2/stream.rb#368
  def reserved_remote!; end

  # source://protocol-http2//lib/protocol/http2/stream.rb#190
  def send_data(*arguments, **options); end

  # The HEADERS frame is used to open a stream, and additionally carries a header block fragment. HEADERS frames can be sent on a stream in the "idle", "reserved (local)", "open", or "half-closed (remote)" state.
  #
  # source://protocol-http2//lib/protocol/http2/stream.rb#143
  def send_headers(*arguments); end

  # HEADERS frames can be sent on a stream in the "idle", "reserved (local)", "open", or "half-closed (remote)" state. Despite it's name, it can also be used for trailers.
  #
  # @return [Boolean]
  #
  # source://protocol-http2//lib/protocol/http2/stream.rb#124
  def send_headers?; end

  # Server push is semantically equivalent to a server responding to a request; however, in this case, that request is also sent by the server, as a PUSH_PROMISE frame.
  #
  # source://protocol-http2//lib/protocol/http2/stream.rb#385
  def send_push_promise(headers); end

  # source://protocol-http2//lib/protocol/http2/stream.rb#237
  def send_reset_stream(error_code = T.unsafe(nil)); end

  # Stream state, e.g. `idle`, `closed`.
  #
  # source://protocol-http2//lib/protocol/http2/stream.rb#90
  def state; end

  # Stream state, e.g. `idle`, `closed`.
  #
  # source://protocol-http2//lib/protocol/http2/stream.rb#90
  def state=(_arg0); end

  # source://protocol-http2//lib/protocol/http2/stream.rb#102
  def write_frame(frame); end

  protected

  # source://protocol-http2//lib/protocol/http2/stream.rb#257
  def ignore_headers(frame); end

  private

  # source://protocol-http2//lib/protocol/http2/stream.rb#179
  def write_data(data, flags = T.unsafe(nil), **options); end

  # source://protocol-http2//lib/protocol/http2/stream.rb#128
  def write_headers(headers, flags = T.unsafe(nil)); end

  # A normal request is client request -> server response -> client.
  # A push promise is server request -> client -> server response -> client.
  # The server generates the same set of headers as if the client was sending a request, and sends these to the client. The client can reject the request by resetting the (new) stream. Otherwise, the server will start sending a response as if the client had send the request.
  #
  # source://protocol-http2//lib/protocol/http2/stream.rb#344
  def write_push_promise(stream_id, headers, flags = T.unsafe(nil), **options); end

  class << self
    # source://protocol-http2//lib/protocol/http2/stream.rb#63
    def create(connection, id); end
  end
end

# source://protocol-http2//lib/protocol/http2/error.rb#77
class Protocol::HTTP2::StreamClosed < ::Protocol::HTTP2::StreamError
  # @return [StreamClosed] a new instance of StreamClosed
  #
  # source://protocol-http2//lib/protocol/http2/error.rb#78
  def initialize(message); end
end

# source://protocol-http2//lib/protocol/http2/error.rb#74
class Protocol::HTTP2::StreamError < ::Protocol::HTTP2::ProtocolError; end

# source://protocol-http2//lib/protocol/http2/reset_stream_frame.rb#14
Protocol::HTTP2::TIMEOUT = T.let(T.unsafe(nil), Integer)

# source://protocol-http2//lib/protocol/http2/window.rb#8
class Protocol::HTTP2::Window
  # @return [Window] a new instance of Window
  #
  # source://protocol-http2//lib/protocol/http2/window.rb#13
  def initialize(capacity = T.unsafe(nil)); end

  # Returns the value of attribute available.
  #
  # source://protocol-http2//lib/protocol/http2/window.rb#48
  def available; end

  # @return [Boolean]
  #
  # source://protocol-http2//lib/protocol/http2/window.rb#50
  def available?; end

  # Returns the value of attribute capacity.
  #
  # source://protocol-http2//lib/protocol/http2/window.rb#28
  def capacity; end

  # When the value of SETTINGS_INITIAL_WINDOW_SIZE changes, a receiver MUST adjust the size of all stream flow-control windows that it maintains by the difference between the new value and the old value.
  #
  # source://protocol-http2//lib/protocol/http2/window.rb#31
  def capacity=(value); end

  # source://protocol-http2//lib/protocol/http2/window.rb#43
  def consume(amount); end

  # source://protocol-http2//lib/protocol/http2/window.rb#54
  def expand(amount); end

  # The window is completely full?
  #
  # @return [Boolean]
  #
  # source://protocol-http2//lib/protocol/http2/window.rb#23
  def full?; end

  # source://protocol-http2//lib/protocol/http2/window.rb#74
  def inspect; end

  # @return [Boolean]
  #
  # source://protocol-http2//lib/protocol/http2/window.rb#70
  def limited?; end

  # source://protocol-http2//lib/protocol/http2/window.rb#78
  def to_s; end

  # Returns the value of attribute used.
  #
  # source://protocol-http2//lib/protocol/http2/window.rb#27
  def used; end

  # source://protocol-http2//lib/protocol/http2/window.rb#66
  def wanted; end
end

# When an HTTP/2 connection is first established, new streams are created with an initial flow-control window size of 65,535 octets. The connection flow-control window is also 65,535 octets.
#
# source://protocol-http2//lib/protocol/http2/window.rb#10
Protocol::HTTP2::Window::DEFAULT_CAPACITY = T.let(T.unsafe(nil), Integer)

# The WINDOW_UPDATE frame is used to implement flow control.
#
# +-+-------------------------------------------------------------+
# |R|              Window Size Increment (31)                     |
# +-+-------------------------------------------------------------+
#
# source://protocol-http2//lib/protocol/http2/window_update_frame.rb#17
class Protocol::HTTP2::WindowUpdateFrame < ::Protocol::HTTP2::Frame
  # source://protocol-http2//lib/protocol/http2/window_update_frame.rb#37
  def apply(connection); end

  # source://protocol-http2//lib/protocol/http2/window_update_frame.rb#21
  def pack(window_size_increment); end

  # source://protocol-http2//lib/protocol/http2/window_update_frame.rb#29
  def read_payload(stream); end

  # source://protocol-http2//lib/protocol/http2/window_update_frame.rb#25
  def unpack; end
end

# source://protocol-http2//lib/protocol/http2/window_update_frame.rb#19
Protocol::HTTP2::WindowUpdateFrame::FORMAT = T.let(T.unsafe(nil), String)

# source://protocol-http2//lib/protocol/http2/window_update_frame.rb#18
Protocol::HTTP2::WindowUpdateFrame::TYPE = T.let(T.unsafe(nil), Integer)
