# typed: false

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `sord` gem.
# Please instead update this file by running `bin/tapioca gem sord`.

# typed: strong

module Sord; end

# Converts the current working directory's YARD registry into an type
# signature file.
# Converts the current working directory's YARD registry into an type
class Sord::Generator
  # Create a new generator.
  #
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @param options [Hash]
  # @return [void]
  def initialize(options); end

  # Given a YARD NamespaceObject, add lines defining either its class
  # and instance attributes and their signatures to the current file.
  #
  # @param item [YARD::CodeObjects::NamespaceObject]
  # @return [void]
  def add_attributes(item); end

  # Adds comments to an object based on a docstring.
  #
  # @param item [YARD::CodeObjects::NamespaceObject]
  # @param typed_object [Parlour::TypedObject]
  # @return [void]
  def add_comments(item, typed_object); end

  # Given a YARD NamespaceObject, add lines defining constants.
  #
  # @param item [YARD::CodeObjects::NamespaceObject]
  # @return [void]
  def add_constants(item); end

  # Given a YARD NamespaceObject, add lines defining its methods and their
  # signatures to the current file.
  #
  # @param item [YARD::CodeObjects::NamespaceObject]
  # @return [void]
  def add_methods(item); end

  # Given a YARD CodeObject, add lines defining its mixins (that is, extends
  # and includes) to the current file. Returns the number of mixins.
  #
  # @param item [YARD::CodeObjects::Base]
  # @return [Integer]
  def add_mixins(item); end

  # Given a YARD NamespaceObject, add lines defining its mixins, methods
  # and children to the file.
  #
  # @param item [YARD::CodeObjects::NamespaceObject]
  # @return [void]
  def add_namespace(item); end

  # Increment the method counter.
  #
  # @return [void]
  sig { void }
  def count_method; end

  # Increment the namespace counter.
  #
  # @return [void]
  sig { void }
  def count_namespace; end

  # Removes the last character of a default parameter value if it begins with
  # '-', working around a bug in YARD. (See lsegal/yard #894)
  #
  # @param default [String]
  # @return [String, nil]
  def fix_default_if_unary_minus(default); end

  # Populates the generator with the contents of the YARD registry, then
  # uses the loaded Parlour::Generator to generate the file. You must
  # load the YARD registry first!
  #
  # @return [void]
  sig { void }
  def generate; end

  # @return [Integer] The number of objects this generator has processed so
  #   far.
  sig { returns(Integer) }
  def object_count; end

  # Populates the generator with the contents of the YARD registry. You
  # must load the YARD registry first!
  #
  # @return [void]
  sig { void }
  def populate; end

  # Loads the YARD registry, populates the file, and prints any relevant
  # final logs.
  #
  # @return [void]
  sig { void }
  def run; end

  # Given two pairs of arrays representing method parameters, in the form
  # of ["variable_name", "default_value"], sort the parameters so they're
  # valid for Sorbet. Sorbet requires that, e.g. required kwargs go before
  # optional kwargs.
  #
  # @param pair1 [Array]
  # @param pair2 [Array]
  # @return Integer
  def sort_params(pair1, pair2); end

  # @return [Array<Array(String, YARD::CodeObjects::Base, Integer)>] The
  #   errors encountered by by the generator. Each element is of the form
  #   [message, item, line].
  def warnings; end
end

Sord::Generator::VALID_MODES = T.let(T.unsafe(nil), Array)

# Handles writing logs to stdout and any other classes which request them.
module Sord::Logging
  class << self
    # Adds a hook to the logger.
    #
    # @return [void]
    # @yieldparam kind [Symbol] The kind of log message this is.
    # @yieldparam msg [String] The log message to write.
    # @yieldparam item [YARD::CodeObjects::Base] The CodeObject which this log
    #   is associated with, if any. This is shown before the log message if it is
    #   specified.
    # @yieldreturn [void]
    sig { params(blk: T.proc.params(kind: Symbol, msg: String, item: YARD::CodeObjects::Base).void).void }
    def add_hook(&blk); end

    # Print a done message. This should be used when a process completes
    # successfully.
    #
    # @param msg [String] The log message to write.
    # @param item [YARD::CodeObjects::Base] The CodeObject which this log
    #   is associated with, if any. This is shown before the log message if it is
    #   specified.
    # @return [void]
    def done(msg, item = T.unsafe(nil), **opts); end

    # Print a duck-typing message. This should be used when the YARD
    # documentation contains duck typing, which isn't supported by Sorbet, so
    # it is substituted for something different.
    #
    # @param msg [String] The log message to write.
    # @param item [YARD::CodeObjects::Base] The CodeObject which this log
    #   is associated with, if any. This is shown before the log message if it is
    #   specified.
    # @return [void]
    def duck(msg, item = T.unsafe(nil), **opts); end

    # Gets the array of log messages types which should be processed. Any not on
    # this list will be discarded.
    #
    # @return [Array<Symbol>]
    # @return [void]
    sig { returns(T::Array[Symbol]) }
    def enabled_types; end

    # Sets the array of log messages types which should be processed. Any not on
    # this list will be discarded. This should be a subset of AVAILABLE_TYPES.
    #
    # @param value [Array<Symbol>]
    # @return [void]
    def enabled_types=(value); end

    # Print an error message. This should be used for things which require the
    # current process to stop.
    #
    # @param msg [String] The log message to write.
    # @param item [YARD::CodeObjects::Base] The CodeObject which this log
    #   is associated with, if any. This is shown before the log message if it is
    #   specified.
    # @return [void]
    def error(msg, item = T.unsafe(nil), **opts); end

    # A generic log message writer which is called by all other specific logging
    # methods. This shouldn't be called outside of the Logging class itself.
    #
    # @param kind [Symbol] The kind of log message this is.
    # @param header [String] The prefix for this log message. For consistency,
    #   it should be up to five uppercase characters wrapped in square brackets,
    #   with some unique colour applied.
    # @param msg [String] The log message to write.
    # @param item [YARD::CodeObjects::Base] The CodeObject which this log
    #   is associated with, if any. This is shown before the log message if it is
    #   specified.
    # @return [void]
    def generic(kind, header, msg, item, **opts); end

    # @return [Array<Proc>] The hooks registered on the logger.
    sig { returns(T::Array[Proc]) }
    def hooks; end

    # Print an infer message. This should be used when the user should be told
    # that some information has been filled in or guessed for them, and that
    # information is likely correct.
    #
    # @param msg [String] The log message to write.
    # @param item [YARD::CodeObjects::Base] The CodeObject which this log
    #   is associated with, if any. This is shown before the log message if it is
    #   specified.
    # @return [void]
    def infer(msg, item = T.unsafe(nil), **opts); end

    # Print an info message. This should be used for generic informational
    # messages which the user doesn't need to act on.
    #
    # @param msg [String] The log message to write.
    # @param item [YARD::CodeObjects::Base] The CodeObject which this log
    #   is associated with, if any. This is shown before the log message if it is
    #   specified.
    # @return [void]
    def info(msg, item = T.unsafe(nil), **opts); end

    # Invokes all registered hooks on the logger.
    #
    # @param kind [Symbol] The kind of log message this is.
    # @param msg [String] The log message to write.
    # @param item [YARD::CodeObjects::Base] The CodeObject which this log
    #   is associated with, if any. This is shown before the log message if it is
    #   specified.
    # @return [void]
    def invoke_hooks(kind, msg, item, **opts); end

    # Print an omit message. This should be used as a special type of warning
    # to alert the user that there is some information missing, but this
    # information is not critical to the completion of the process.
    #
    # @param msg [String] The log message to write.
    # @param item [YARD::CodeObjects::Base] The CodeObject which this log
    #   is associated with, if any. This is shown before the log message if it is
    #   specified.
    # @return [void]
    def omit(msg, item = T.unsafe(nil), **opts); end

    # Sets whether log messages should be printed or not.
    #
    # @param value [Boolean]
    # @return [void]
    def silent=(value); end

    # @return [Boolean] Whether log messages should be printed or not. This is
    #   used for testing.
    sig { returns(T::Boolean) }
    def silent?; end

    # Returns a boolean indicating whether a given array is a valid value for
    # #enabled_types.
    #
    # @param value [Array<Symbol>]
    # @return [void]
    def valid_types?(value); end

    # Print a warning message. This should be used for things which require the
    # user's attention but do not prevent the process from stopping.
    #
    # @param msg [String] The log message to write.
    # @param item [YARD::CodeObjects::Base] The CodeObject which this log
    #   is associated with, if any. This is shown before the log message if it is
    #   specified.
    # @return [void]
    def warn(msg, item = T.unsafe(nil), **opts); end
  end
end

# An array of all available logging types.
Sord::Logging::AVAILABLE_TYPES = T.let(T.unsafe(nil), Array)

class Sord::ParlourPlugin < ::Parlour::Plugin
  # @return [ParlourPlugin] a new instance of ParlourPlugin
  def initialize(options); end

  def generate(root); end

  # Returns the value of attribute options.
  def options; end

  # Returns the value of attribute parlour.
  def parlour; end

  # Sets the attribute parlour
  #
  # @param value the value to set the attribute parlour to.
  def parlour=(_arg0); end

  class << self
    sig { params(block: T.untyped).returns(T.untyped) }
    def with_clean_env(&block); end
  end
end

module Sord::Resolver
  class << self
    # @return [Array<String>]
    sig { returns(T::Array[String]) }
    def builtin_classes; end

    # @return [void]
    sig { void }
    def clear; end

    # @param name [String]
    # @return [String, nil]
    def path_for(name); end

    # @param name [String]
    # @return [Array<String>]
    def paths_for(name); end

    # @return [void]
    sig { void }
    def prepare; end

    # @param name [String]
    # @param item [Object]
    # @return [Boolean]
    def resolvable?(name, item); end
  end
end

# Contains methods to convert YARD types to Parlour types.
module Sord::TypeConverter
  class << self
    # Handles SORD_ERRORs.
    #
    # @param name [String, Parlour::Types::Type]
    # @param log_warning [String]
    # @param item [YARD::CodeObjects::Base]
    # @param replace_errors_with_untyped [Boolean]
    # @return [Parlour::Types::Type]
    def handle_sord_error(name, log_warning, item, replace_errors_with_untyped); end

    # Given a string of YARD type parameters (without angle brackets), splits
    # the string into an array of each type parameter.
    #
    # @param params [String] The type parameters.
    # @return [Array<String>] The split type parameters.
    def split_type_parameters(params); end

    # Converts a YARD type into a Parlour type.
    #
    # @param yard [Boolean, Array, String] The YARD type.
    # @param item [YARD::CodeObjects::Base] The CodeObject which the YARD type
    #   is associated with. This is used for logging and can be nil, but this
    #   will lead to less informative log messages.
    # @param replace_errors_with_untyped [Boolean] If true, T.untyped is used
    #   instead of SORD_ERROR_ constants for unknown types.
    # @param replace_unresolved_with_untyped [Boolean] If true, T.untyped is used
    #   when Sord is unable to resolve a constant.
    # @return [Parlour::Types::Type]
    def yard_to_parlour(yard, item = T.unsafe(nil), replace_errors_with_untyped = T.unsafe(nil), replace_unresolved_with_untyped = T.unsafe(nil)); end
  end
end

# Match duck types which require the object implement one or more methods,
# like '#foo', '#foo & #bar', '#foo&#bar&#baz', and '#foo&#bar&#baz&#foo_bar'.
Sord::TypeConverter::DUCK_TYPE_REGEX = T.let(T.unsafe(nil), Regexp)

# A regular expression which matches a Ruby namespace immediately followed
# by another Ruby namespace in angle brackets or curly braces.
# This is the format usually used in YARD to model generic
# types, such as "Array<String>", "Hash<String, Symbol>",
# "Hash{String => Symbol}", etc.
Sord::TypeConverter::GENERIC_TYPE_REGEX = T.let(T.unsafe(nil), Regexp)

# A regular expression which matches ordered lists in the format of
# either "Array(String, Symbol)" or "(String, Symbol)".
Sord::TypeConverter::ORDERED_LIST_REGEX = T.let(T.unsafe(nil), Regexp)

# A regular expression which matches the shorthand Array syntax,
# "<String>".
Sord::TypeConverter::SHORTHAND_ARRAY_SYNTAX = T.let(T.unsafe(nil), Regexp)

# A regular expression which matches the shorthand Hash syntax,
# "{String => Symbol}".
Sord::TypeConverter::SHORTHAND_HASH_SYNTAX = T.let(T.unsafe(nil), Regexp)

# A regular expression which matches Ruby namespaces and identifiers.
# "Foo", "Foo::Bar", and "::Foo::Bar" are all matches, whereas "Foo.Bar"
# or "Foo#bar" are not.
Sord::TypeConverter::SIMPLE_TYPE_REGEX = T.let(T.unsafe(nil), Regexp)

# Built in parlour single arg generics
Sord::TypeConverter::SINGLE_ARG_GENERIC_TYPES = T.let(T.unsafe(nil), Array)

Sord::VERSION = T.let(T.unsafe(nil), String)
