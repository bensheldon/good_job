# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `nokogiri` gem.
# Please instead update this file by running `bin/tapioca gem nokogiri`.

# Nokogiri parses and searches XML/HTML very quickly, and also has
# correctly implemented CSS3 selector support as well as XPath 1.0
# support.
#
# Parsing a document returns either a Nokogiri::XML::Document, or a
# Nokogiri::HTML4::Document depending on the kind of document you parse.
#
# Here is an example:
#
#   require 'nokogiri'
#   require 'open-uri'
#
#   # Get a Nokogiri::HTML4::Document for the page we’re interested in...
#
#   doc = Nokogiri::HTML4(URI.open('http://www.google.com/search?q=tenderlove'))
#
#   # Do funky things with it using Nokogiri::XML::Node methods...
#
#   ####
#   # Search for nodes by css
#   doc.css('h3.r a.l').each do |link|
#     puts link.content
#   end
#
# See Nokogiri::XML::Searchable#css for more information about CSS searching.
# See Nokogiri::XML::Searchable#xpath for more information about XPath searching.
module Nokogiri
  class << self
    # Parse HTML. Convenience method for Nokogiri::HTML4::Document.parse
    def HTML(input, url = T.unsafe(nil), encoding = T.unsafe(nil), options = T.unsafe(nil), &block); end

    # Parse HTML. Convenience method for Nokogiri::HTML4::Document.parse
    def HTML4(input, url = T.unsafe(nil), encoding = T.unsafe(nil), options = T.unsafe(nil), &block); end

    # Parse an HTML5 document. Convenience method for {Nokogiri::HTML5::Document.parse}
    #
    # @note HTML5 functionality is not available when running JRuby.
    # @since v1.12.0
    def HTML5(input, url = T.unsafe(nil), encoding = T.unsafe(nil), **options, &block); end

    # Parse a document and add the Slop decorator.  The Slop decorator
    # implements method_missing such that methods may be used instead of CSS
    # or XPath.  For example:
    #
    #   doc = Nokogiri::Slop(<<-eohtml)
    #     <html>
    #       <body>
    #         <p>first</p>
    #         <p>second</p>
    #       </body>
    #     </html>
    #   eohtml
    #   assert_equal('second', doc.html.body.p[1].text)
    def Slop(*args, &block); end

    # Parse XML.  Convenience method for Nokogiri::XML::Document.parse
    def XML(thing, url = T.unsafe(nil), encoding = T.unsafe(nil), options = T.unsafe(nil), &block); end

    # Create a Nokogiri::XSLT::Stylesheet with +stylesheet+.
    #
    # Example:
    #
    #   xslt = Nokogiri::XSLT(File.read(ARGV[0]))
    def XSLT(stylesheet, modules = T.unsafe(nil)); end

    def install_default_aliases; end

    # @return [Boolean]
    def jruby?; end

    # Create a new Nokogiri::XML::DocumentFragment
    def make(input = T.unsafe(nil), opts = T.unsafe(nil), &blk); end

    # Parse an HTML or XML document.  +string+ contains the document.
    def parse(string, url = T.unsafe(nil), encoding = T.unsafe(nil), options = T.unsafe(nil)); end

    # @return [Boolean]
    def uses_gumbo?; end

    # @return [Boolean]
    def uses_libxml?(requirement = T.unsafe(nil)); end
  end
end

module Nokogiri::CSS
  class << self
    # Parse this CSS selector in +selector+.  Returns an AST.
    def parse(selector); end

    # Get the XPath for +selector+.
    def xpath_for(selector, options = T.unsafe(nil)); end
  end
end

class Nokogiri::CSS::Node
  # Create a new Node with +type+ and +value+
  #
  # @return [Node] a new instance of Node
  def initialize(type, value); end

  # Accept +visitor+
  def accept(visitor); end

  # Find a node by type using +types+
  def find_by_type(types); end

  # Convert to array
  def to_a; end

  # Convert to_type
  def to_type; end

  # Convert this CSS node to xpath with +prefix+ using +visitor+
  def to_xpath(prefix = T.unsafe(nil), visitor = T.unsafe(nil)); end

  # Get the type of this node
  def type; end

  # Get the type of this node
  def type=(_arg0); end

  # Get the value of this node
  def value; end

  # Get the value of this node
  def value=(_arg0); end
end

Nokogiri::CSS::Node::ALLOW_COMBINATOR_ON_SELF = T.let(T.unsafe(nil), Array)

class Nokogiri::CSS::Parser < ::Racc::Parser
  # Create a new CSS parser with respect to +namespaces+
  #
  # @return [Parser] a new instance of Parser
  def initialize(namespaces = T.unsafe(nil)); end

  # reduce 0 omitted
  def _reduce_1(val, _values, result); end

  # reduce 10 omitted
  def _reduce_11(val, _values, result); end

  def _reduce_12(val, _values, result); end
  def _reduce_13(val, _values, result); end
  def _reduce_14(val, _values, result); end
  def _reduce_15(val, _values, result); end
  def _reduce_16(val, _values, result); end

  # reduce 17 omitted
  def _reduce_18(val, _values, result); end

  def _reduce_2(val, _values, result); end

  # reduce 19 omitted
  def _reduce_20(val, _values, result); end

  def _reduce_21(val, _values, result); end
  def _reduce_22(val, _values, result); end
  def _reduce_23(val, _values, result); end

  # reduce 24 omitted
  def _reduce_25(val, _values, result); end

  def _reduce_26(val, _values, result); end
  def _reduce_27(val, _values, result); end
  def _reduce_28(val, _values, result); end
  def _reduce_29(val, _values, result); end
  def _reduce_3(val, _values, result); end
  def _reduce_30(val, _values, result); end
  def _reduce_31(val, _values, result); end
  def _reduce_32(val, _values, result); end
  def _reduce_33(val, _values, result); end
  def _reduce_34(val, _values, result); end
  def _reduce_35(val, _values, result); end
  def _reduce_36(val, _values, result); end
  def _reduce_37(val, _values, result); end
  def _reduce_4(val, _values, result); end

  # reduce 39 omitted
  def _reduce_40(val, _values, result); end

  def _reduce_41(val, _values, result); end
  def _reduce_42(val, _values, result); end
  def _reduce_43(val, _values, result); end
  def _reduce_44(val, _values, result); end
  def _reduce_45(val, _values, result); end

  # reduce 47 omitted
  def _reduce_48(val, _values, result); end

  def _reduce_49(val, _values, result); end
  def _reduce_5(val, _values, result); end
  def _reduce_50(val, _values, result); end
  def _reduce_51(val, _values, result); end
  def _reduce_52(val, _values, result); end

  # reduce 57 omitted
  def _reduce_58(val, _values, result); end

  def _reduce_59(val, _values, result); end
  def _reduce_6(val, _values, result); end
  def _reduce_60(val, _values, result); end
  def _reduce_61(val, _values, result); end

  # reduce 62 omitted
  def _reduce_63(val, _values, result); end

  def _reduce_64(val, _values, result); end
  def _reduce_65(val, _values, result); end
  def _reduce_66(val, _values, result); end
  def _reduce_67(val, _values, result); end
  def _reduce_68(val, _values, result); end
  def _reduce_69(val, _values, result); end
  def _reduce_7(val, _values, result); end
  def _reduce_70(val, _values, result); end
  def _reduce_8(val, _values, result); end
  def _reduce_9(val, _values, result); end

  # reduce 75 omitted
  def _reduce_none(val, _values, result); end

  def next_token; end

  # On CSS parser error, raise an exception
  #
  # @raise [SyntaxError]
  def on_error(error_token_id, error_value, value_stack); end

  def parse(string); end
  def unescape_css_identifier(identifier); end
  def unescape_css_string(str); end

  # Get the xpath for +string+ using +options+
  def xpath_for(string, options = T.unsafe(nil)); end

  class << self
    # Get the css selector in +string+ from the cache
    def [](string); end

    # Set the css selector in +string+ in the cache to +value+
    def []=(string, value); end

    # Return a thread-local boolean indicating whether the CSS-to-XPath cache is active. (Default is `true`.)
    #
    # @return [Boolean]
    def cache_on?; end

    # Clear the cache
    def clear_cache(create_new_object = T.unsafe(nil)); end

    # Set a thread-local boolean to turn cacheing on and off. Truthy values turn the cache on, falsey values turn the cache off.
    def set_cache(value); end

    # Execute +block+ without cache
    def without_cache(&block); end
  end
end

Nokogiri::CSS::Parser::CACHE_SWITCH_NAME = T.let(T.unsafe(nil), Symbol)
Nokogiri::CSS::Parser::Racc_arg = T.let(T.unsafe(nil), Array)
Nokogiri::CSS::Parser::Racc_token_to_s_table = T.let(T.unsafe(nil), Array)
class Nokogiri::CSS::SyntaxError < ::Nokogiri::SyntaxError; end

class Nokogiri::CSS::Tokenizer
  def _next_token; end
  def action; end

  # Returns the value of attribute filename.
  def filename; end

  # Returns the value of attribute lineno.
  def lineno; end

  def load_file(filename); end
  def next_token; end
  def scan(str); end
  def scan_file(filename); end
  def scan_setup(str); end
  def scan_str(str); end

  # Returns the value of attribute state.
  def state; end

  # Sets the attribute state
  #
  # @param value the value to set the attribute state to.
  def state=(_arg0); end
end

class Nokogiri::CSS::Tokenizer::ScanError < ::StandardError; end

class Nokogiri::CSS::XPathVisitor
  def accept(node); end
  def visit_attribute_condition(node); end
  def visit_child_selector(node); end
  def visit_class_condition(node); end
  def visit_combinator(node); end
  def visit_conditional_selector(node); end
  def visit_descendant_selector(node); end
  def visit_direct_adjacent_selector(node); end
  def visit_element_name(node); end
  def visit_following_selector(node); end
  def visit_function(node); end
  def visit_id(node); end
  def visit_not(node); end
  def visit_pseudo_class(node); end

  private

  # use only ordinary xpath functions
  def css_class(hay, needle); end

  # use the builtin implementation
  def css_class_builtin(hay, needle); end

  # use only ordinary xpath functions
  def css_class_standard(hay, needle); end

  # @return [Boolean]
  def is_of_type_pseudo_class?(node); end

  # @raise [ArgumentError]
  def nth(node, options = T.unsafe(nil)); end

  def read_a_and_positive_b(values); end
end

class Nokogiri::CSS::XPathVisitorAlwaysUseBuiltins < ::Nokogiri::CSS::XPathVisitor
  private

  def css_class(hay, needle); end
end

class Nokogiri::CSS::XPathVisitorOptimallyUseBuiltins < ::Nokogiri::CSS::XPathVisitor
  private

  def css_class(hay, needle); end
end

module Nokogiri::Decorators; end

# The Slop decorator implements method missing such that a methods may be
# used instead of XPath or CSS.  See Nokogiri.Slop
module Nokogiri::Decorators::Slop
  # look for node with +name+.  See Nokogiri.Slop
  def method_missing(name, *args, &block); end

  private

  # @return [Boolean]
  def respond_to_missing?(name, include_private = T.unsafe(nil)); end
end

# The default XPath search context for Slop
Nokogiri::Decorators::Slop::XPATH_PREFIX = T.let(T.unsafe(nil), String)

class Nokogiri::EncodingHandler
  def name; end

  class << self
    def [](_arg0); end
    def alias(_arg0, _arg1); end
    def clear_aliases!; end
    def delete(_arg0); end
  end
end

module Nokogiri::Gumbo
  class << self
    def fragment(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5); end
    def parse(_arg0, _arg1, _arg2, _arg3, _arg4); end
  end
end

# The default maximum number of attributes per element.
Nokogiri::Gumbo::DEFAULT_MAX_ATTRIBUTES = T.let(T.unsafe(nil), Integer)

# The default maximum number of errors for parsing a document or a fragment.
Nokogiri::Gumbo::DEFAULT_MAX_ERRORS = T.let(T.unsafe(nil), Integer)

# The default maximum depth of the DOM tree produced by parsing a document
# or fragment.
Nokogiri::Gumbo::DEFAULT_MAX_TREE_DEPTH = T.let(T.unsafe(nil), Integer)

# @note This module/namespace is an alias for {Nokogiri::HTML4} as of v1.12.0. Before v1.12.0,
#   {Nokogiri::HTML4} did not exist, and this was the module/namespace for all HTML-related
#   classes.
Nokogiri::HTML = Nokogiri::HTML4

# @note Before v1.12.0, {Nokogiri::HTML4} did not exist, and {Nokogiri::HTML} was the module/namespace for parsing HTML.
# @since v1.12.0
module Nokogiri::HTML4
  class << self
    # Parse a fragment from +string+ in to a NodeSet.
    #
    # @since v1.12.0
    def fragment(string, encoding = T.unsafe(nil)); end

    # Parse HTML. Convenience method for Nokogiri::HTML4::Document.parse
    #
    # @since v1.12.0
    def parse(input, url = T.unsafe(nil), encoding = T.unsafe(nil), options = T.unsafe(nil), &block); end
  end
end

# Nokogiri HTML builder is used for building HTML documents.  It is very
# similar to the Nokogiri::XML::Builder.  In fact, you should go read the
# documentation for Nokogiri::XML::Builder before reading this
# documentation.
#
# == Synopsis:
#
# Create an HTML document with a body that has an onload attribute, and a
# span tag with a class of "bold" that has content of "Hello world".
#
#   builder = Nokogiri::HTML4::Builder.new do |doc|
#     doc.html {
#       doc.body(:onload => 'some_func();') {
#         doc.span.bold {
#           doc.text "Hello world"
#         }
#       }
#     }
#   end
#   puts builder.to_html
#
# The HTML builder inherits from the XML builder, so make sure to read the
# Nokogiri::XML::Builder documentation.
class Nokogiri::HTML4::Builder < ::Nokogiri::XML::Builder
  # Convert the builder to HTML
  def to_html; end
end

class Nokogiri::HTML4::Document < ::Nokogiri::XML::Document
  # Create a Nokogiri::XML::DocumentFragment from +tags+
  def fragment(tags = T.unsafe(nil)); end

  # Get the meta tag encoding for this document.  If there is no meta tag,
  # then nil is returned.
  def meta_encoding; end

  # Set the meta tag encoding for this document.
  #
  # If an meta encoding tag is already present, its content is
  # replaced with the given text.
  #
  # Otherwise, this method tries to create one at an appropriate
  # place supplying head and/or html elements as necessary, which
  # is inside a head element if any, and before any text node or
  # content element (typically <body>) if any.
  #
  # The result when trying to set an encoding that is different
  # from the document encoding is undefined.
  #
  # Beware in CRuby, that libxml2 automatically inserts a meta tag
  # into a head element.
  def meta_encoding=(encoding); end

  # Serialize Node using +options+.  Save options can also be set using a
  # block. See SaveOptions.
  #
  # These two statements are equivalent:
  #
  #  node.serialize(:encoding => 'UTF-8', :save_with => FORMAT | AS_XML)
  #
  # or
  #
  #   node.serialize(:encoding => 'UTF-8') do |config|
  #     config.format.as_xml
  #   end
  def serialize(options = T.unsafe(nil)); end

  # Get the title string of this document.  Return nil if there is
  # no title tag.
  def title; end

  # Set the title string of this document.
  #
  # If a title element is already present, its content is replaced
  # with the given text.
  #
  # Otherwise, this method tries to create one at an appropriate
  # place supplying head and/or html elements as necessary, which
  # is inside a head element if any, right after a meta
  # encoding/charset tag if any, and before any text node or
  # content element (typically <body>) if any.
  def title=(text); end

  def type; end

  private

  def meta_content_type; end
  def set_metadata_element(element); end

  class << self
    def new(*_arg0); end

    # Parse HTML.  +string_or_io+ may be a String, or any object that
    # responds to _read_ and _close_ such as an IO, or StringIO.
    # +url+ is resource where this document is located.  +encoding+ is the
    # encoding that should be used when processing the document. +options+
    # is a number that sets options in the parser, such as
    # Nokogiri::XML::ParseOptions::RECOVER.  See the constants in
    # Nokogiri::XML::ParseOptions.
    #
    # @yield [options]
    def parse(string_or_io, url = T.unsafe(nil), encoding = T.unsafe(nil), options = T.unsafe(nil)); end

    def read_io(_arg0, _arg1, _arg2, _arg3); end
    def read_memory(_arg0, _arg1, _arg2, _arg3); end
  end
end

class Nokogiri::HTML4::Document::EncodingFound < ::StandardError
  # @return [EncodingFound] a new instance of EncodingFound
  def initialize(encoding); end

  # Returns the value of attribute found_encoding.
  def found_encoding; end
end

class Nokogiri::HTML4::Document::EncodingReader
  # @return [EncodingReader] a new instance of EncodingReader
  def initialize(io); end

  # This method is used by the C extension so that
  # Nokogiri::HTML4::Document#read_io() does not leak memory when
  # EncodingFound is raised.
  def encoding_found; end

  def read(len); end

  class << self
    def detect_encoding(chunk); end
  end
end

class Nokogiri::HTML4::Document::EncodingReader::JumpSAXHandler < ::Nokogiri::HTML4::Document::EncodingReader::SAXHandler
  # @return [JumpSAXHandler] a new instance of JumpSAXHandler
  def initialize(jumptag); end

  def start_element(name, attrs = T.unsafe(nil)); end
end

class Nokogiri::HTML4::Document::EncodingReader::SAXHandler < ::Nokogiri::XML::SAX::Document
  # @return [SAXHandler] a new instance of SAXHandler
  def initialize; end

  # Returns the value of attribute encoding.
  def encoding; end

  def start_element(name, attrs = T.unsafe(nil)); end
end

class Nokogiri::HTML4::DocumentFragment < ::Nokogiri::XML::DocumentFragment
  # @return [DocumentFragment] a new instance of DocumentFragment
  def initialize(document, tags = T.unsafe(nil), ctx = T.unsafe(nil)); end

  class << self
    # Create a Nokogiri::XML::DocumentFragment from +tags+, using +encoding+
    def parse(tags, encoding = T.unsafe(nil)); end
  end
end

class Nokogiri::HTML4::ElementDescription
  # Is this element a block element?
  #
  # @return [Boolean]
  def block?; end

  def default_sub_element; end

  # @return [Boolean]
  def deprecated?; end

  def deprecated_attributes; end
  def description; end
  def empty?; end

  # @return [Boolean]
  def implied_end_tag?; end

  # @return [Boolean]
  def implied_start_tag?; end

  def inline?; end

  # Inspection information
  def inspect; end

  def name; end
  def optional_attributes; end
  def required_attributes; end

  # @return [Boolean]
  def save_end_tag?; end

  def sub_elements; end

  # Convert this description to a string
  def to_s; end

  private

  def default_desc; end

  class << self
    def [](_arg0); end
  end
end

Nokogiri::HTML4::ElementDescription::ACTION_ATTR = T.let(T.unsafe(nil), Array)
Nokogiri::HTML4::ElementDescription::ALIGN_ATTR = T.let(T.unsafe(nil), Array)
Nokogiri::HTML4::ElementDescription::ALT_ATTR = T.let(T.unsafe(nil), Array)
Nokogiri::HTML4::ElementDescription::APPLET_ATTRS = T.let(T.unsafe(nil), Array)
Nokogiri::HTML4::ElementDescription::AREA_ATTRS = T.let(T.unsafe(nil), Array)
Nokogiri::HTML4::ElementDescription::ATTRS = T.let(T.unsafe(nil), Array)
Nokogiri::HTML4::ElementDescription::A_ATTRS = T.let(T.unsafe(nil), Array)
Nokogiri::HTML4::ElementDescription::BASEFONT_ATTRS = T.let(T.unsafe(nil), Array)
Nokogiri::HTML4::ElementDescription::BGCOLOR_ATTR = T.let(T.unsafe(nil), Array)
Nokogiri::HTML4::ElementDescription::BLOCK = T.let(T.unsafe(nil), Array)
Nokogiri::HTML4::ElementDescription::BLOCKLI_ELT = T.let(T.unsafe(nil), Array)
Nokogiri::HTML4::ElementDescription::BODY_ATTRS = T.let(T.unsafe(nil), Array)
Nokogiri::HTML4::ElementDescription::BODY_CONTENTS = T.let(T.unsafe(nil), Array)
Nokogiri::HTML4::ElementDescription::BODY_DEPR = T.let(T.unsafe(nil), Array)
Nokogiri::HTML4::ElementDescription::BUTTON_ATTRS = T.let(T.unsafe(nil), Array)
Nokogiri::HTML4::ElementDescription::CELLHALIGN = T.let(T.unsafe(nil), Array)
Nokogiri::HTML4::ElementDescription::CELLVALIGN = T.let(T.unsafe(nil), Array)
Nokogiri::HTML4::ElementDescription::CLEAR_ATTRS = T.let(T.unsafe(nil), Array)
Nokogiri::HTML4::ElementDescription::COL_ATTRS = T.let(T.unsafe(nil), Array)
Nokogiri::HTML4::ElementDescription::COL_ELT = T.let(T.unsafe(nil), Array)
Nokogiri::HTML4::ElementDescription::COMPACT_ATTR = T.let(T.unsafe(nil), Array)
Nokogiri::HTML4::ElementDescription::COMPACT_ATTRS = T.let(T.unsafe(nil), Array)
Nokogiri::HTML4::ElementDescription::CONTENT_ATTR = T.let(T.unsafe(nil), Array)
Nokogiri::HTML4::ElementDescription::COREATTRS = T.let(T.unsafe(nil), Array)
Nokogiri::HTML4::ElementDescription::CORE_ATTRS = T.let(T.unsafe(nil), Array)
Nokogiri::HTML4::ElementDescription::CORE_I18N_ATTRS = T.let(T.unsafe(nil), Array)
Nokogiri::HTML4::ElementDescription::DIR_ATTR = T.let(T.unsafe(nil), Array)
Nokogiri::HTML4::ElementDescription::DL_CONTENTS = T.let(T.unsafe(nil), Array)

# This is filled in down below.
Nokogiri::HTML4::ElementDescription::DefaultDescriptions = T.let(T.unsafe(nil), Hash)

# Methods are defined protected by method_defined? because at
# this point the C-library or Java library is already loaded,
# and we don't want to clobber any methods that have been
# defined there.
Nokogiri::HTML4::ElementDescription::Desc = Struct

Nokogiri::HTML4::ElementDescription::EDIT_ATTRS = T.let(T.unsafe(nil), Array)
Nokogiri::HTML4::ElementDescription::EMBED_ATTRS = T.let(T.unsafe(nil), Array)
Nokogiri::HTML4::ElementDescription::EMPTY = T.let(T.unsafe(nil), Array)
Nokogiri::HTML4::ElementDescription::EVENTS = T.let(T.unsafe(nil), Array)
Nokogiri::HTML4::ElementDescription::FIELDSET_CONTENTS = T.let(T.unsafe(nil), Array)
Nokogiri::HTML4::ElementDescription::FLOW = T.let(T.unsafe(nil), Array)
Nokogiri::HTML4::ElementDescription::FLOW_PARAM = T.let(T.unsafe(nil), Array)

# Attributes defined and categorized
Nokogiri::HTML4::ElementDescription::FONTSTYLE = T.let(T.unsafe(nil), Array)

Nokogiri::HTML4::ElementDescription::FONT_ATTRS = T.let(T.unsafe(nil), Array)
Nokogiri::HTML4::ElementDescription::FORMCTRL = T.let(T.unsafe(nil), Array)
Nokogiri::HTML4::ElementDescription::FORM_ATTRS = T.let(T.unsafe(nil), Array)
Nokogiri::HTML4::ElementDescription::FORM_CONTENTS = T.let(T.unsafe(nil), Array)
Nokogiri::HTML4::ElementDescription::FRAMESET_ATTRS = T.let(T.unsafe(nil), Array)
Nokogiri::HTML4::ElementDescription::FRAMESET_CONTENTS = T.let(T.unsafe(nil), Array)
Nokogiri::HTML4::ElementDescription::FRAME_ATTRS = T.let(T.unsafe(nil), Array)
Nokogiri::HTML4::ElementDescription::HEADING = T.let(T.unsafe(nil), Array)
Nokogiri::HTML4::ElementDescription::HEAD_ATTRS = T.let(T.unsafe(nil), Array)
Nokogiri::HTML4::ElementDescription::HEAD_CONTENTS = T.let(T.unsafe(nil), Array)
Nokogiri::HTML4::ElementDescription::HREF_ATTRS = T.let(T.unsafe(nil), Array)
Nokogiri::HTML4::ElementDescription::HR_DEPR = T.let(T.unsafe(nil), Array)
Nokogiri::HTML4::ElementDescription::HTML_ATTRS = T.let(T.unsafe(nil), Array)
Nokogiri::HTML4::ElementDescription::HTML_CDATA = T.let(T.unsafe(nil), Array)
Nokogiri::HTML4::ElementDescription::HTML_CONTENT = T.let(T.unsafe(nil), Array)
Nokogiri::HTML4::ElementDescription::HTML_FLOW = T.let(T.unsafe(nil), Array)
Nokogiri::HTML4::ElementDescription::HTML_INLINE = T.let(T.unsafe(nil), Array)
Nokogiri::HTML4::ElementDescription::HTML_PCDATA = T.let(T.unsafe(nil), Array)
Nokogiri::HTML4::ElementDescription::I18N = T.let(T.unsafe(nil), Array)
Nokogiri::HTML4::ElementDescription::I18N_ATTRS = T.let(T.unsafe(nil), Array)
Nokogiri::HTML4::ElementDescription::IFRAME_ATTRS = T.let(T.unsafe(nil), Array)
Nokogiri::HTML4::ElementDescription::IMG_ATTRS = T.let(T.unsafe(nil), Array)
Nokogiri::HTML4::ElementDescription::INLINE = T.let(T.unsafe(nil), Array)
Nokogiri::HTML4::ElementDescription::INLINE_P = T.let(T.unsafe(nil), Array)
Nokogiri::HTML4::ElementDescription::INPUT_ATTRS = T.let(T.unsafe(nil), Array)
Nokogiri::HTML4::ElementDescription::LABEL_ATTR = T.let(T.unsafe(nil), Array)
Nokogiri::HTML4::ElementDescription::LABEL_ATTRS = T.let(T.unsafe(nil), Array)
Nokogiri::HTML4::ElementDescription::LANGUAGE_ATTR = T.let(T.unsafe(nil), Array)
Nokogiri::HTML4::ElementDescription::LEGEND_ATTRS = T.let(T.unsafe(nil), Array)
Nokogiri::HTML4::ElementDescription::LINK_ATTRS = T.let(T.unsafe(nil), Array)
Nokogiri::HTML4::ElementDescription::LIST = T.let(T.unsafe(nil), Array)
Nokogiri::HTML4::ElementDescription::LI_ELT = T.let(T.unsafe(nil), Array)
Nokogiri::HTML4::ElementDescription::MAP_CONTENTS = T.let(T.unsafe(nil), Array)
Nokogiri::HTML4::ElementDescription::META_ATTRS = T.let(T.unsafe(nil), Array)
Nokogiri::HTML4::ElementDescription::MODIFIER = T.let(T.unsafe(nil), Array)
Nokogiri::HTML4::ElementDescription::NAME_ATTR = T.let(T.unsafe(nil), Array)
Nokogiri::HTML4::ElementDescription::NOFRAMES_CONTENT = T.let(T.unsafe(nil), Array)
Nokogiri::HTML4::ElementDescription::OBJECT_ATTRS = T.let(T.unsafe(nil), Array)
Nokogiri::HTML4::ElementDescription::OBJECT_CONTENTS = T.let(T.unsafe(nil), Array)
Nokogiri::HTML4::ElementDescription::OBJECT_DEPR = T.let(T.unsafe(nil), Array)
Nokogiri::HTML4::ElementDescription::OL_ATTRS = T.let(T.unsafe(nil), Array)
Nokogiri::HTML4::ElementDescription::OPTGROUP_ATTRS = T.let(T.unsafe(nil), Array)
Nokogiri::HTML4::ElementDescription::OPTION_ATTRS = T.let(T.unsafe(nil), Array)
Nokogiri::HTML4::ElementDescription::OPTION_ELT = T.let(T.unsafe(nil), Array)
Nokogiri::HTML4::ElementDescription::PARAM_ATTRS = T.let(T.unsafe(nil), Array)
Nokogiri::HTML4::ElementDescription::PCDATA = T.let(T.unsafe(nil), Array)
Nokogiri::HTML4::ElementDescription::PHRASE = T.let(T.unsafe(nil), Array)
Nokogiri::HTML4::ElementDescription::PRE_CONTENT = T.let(T.unsafe(nil), Array)
Nokogiri::HTML4::ElementDescription::PROMPT_ATTRS = T.let(T.unsafe(nil), Array)
Nokogiri::HTML4::ElementDescription::QUOTE_ATTRS = T.let(T.unsafe(nil), Array)
Nokogiri::HTML4::ElementDescription::ROWS_COLS_ATTR = T.let(T.unsafe(nil), Array)
Nokogiri::HTML4::ElementDescription::SCRIPT_ATTRS = T.let(T.unsafe(nil), Array)
Nokogiri::HTML4::ElementDescription::SELECT_ATTRS = T.let(T.unsafe(nil), Array)
Nokogiri::HTML4::ElementDescription::SELECT_CONTENT = T.let(T.unsafe(nil), Array)
Nokogiri::HTML4::ElementDescription::SPECIAL = T.let(T.unsafe(nil), Array)
Nokogiri::HTML4::ElementDescription::SRC_ALT_ATTRS = T.let(T.unsafe(nil), Array)
Nokogiri::HTML4::ElementDescription::STYLE_ATTRS = T.let(T.unsafe(nil), Array)
Nokogiri::HTML4::ElementDescription::TABLE_ATTRS = T.let(T.unsafe(nil), Array)
Nokogiri::HTML4::ElementDescription::TABLE_CONTENTS = T.let(T.unsafe(nil), Array)
Nokogiri::HTML4::ElementDescription::TABLE_DEPR = T.let(T.unsafe(nil), Array)
Nokogiri::HTML4::ElementDescription::TALIGN_ATTRS = T.let(T.unsafe(nil), Array)
Nokogiri::HTML4::ElementDescription::TARGET_ATTR = T.let(T.unsafe(nil), Array)
Nokogiri::HTML4::ElementDescription::TEXTAREA_ATTRS = T.let(T.unsafe(nil), Array)
Nokogiri::HTML4::ElementDescription::TH_TD_ATTR = T.let(T.unsafe(nil), Array)
Nokogiri::HTML4::ElementDescription::TH_TD_DEPR = T.let(T.unsafe(nil), Array)
Nokogiri::HTML4::ElementDescription::TR_CONTENTS = T.let(T.unsafe(nil), Array)
Nokogiri::HTML4::ElementDescription::TR_ELT = T.let(T.unsafe(nil), Array)
Nokogiri::HTML4::ElementDescription::TYPE_ATTR = T.let(T.unsafe(nil), Array)
Nokogiri::HTML4::ElementDescription::UL_DEPR = T.let(T.unsafe(nil), Array)
Nokogiri::HTML4::ElementDescription::VERSION_ATTR = T.let(T.unsafe(nil), Array)
Nokogiri::HTML4::ElementDescription::WIDTH_ATTR = T.let(T.unsafe(nil), Array)
class Nokogiri::HTML4::EntityDescription < ::Struct; end

class Nokogiri::HTML4::EntityLookup
  # Look up entity with +name+
  def [](name); end

  def get(_arg0); end
end

# Instance of Nokogiri::HTML4::EntityLookup
#
# @since v1.12.0
Nokogiri::HTML4::NamedCharacters = T.let(T.unsafe(nil), Nokogiri::HTML4::EntityLookup)

# Nokogiri lets you write a SAX parser to process HTML but get HTML correction features.
#
# See Nokogiri::HTML4::SAX::Parser for a basic example of using a SAX parser with HTML.
#
# For more information on SAX parsers, see Nokogiri::XML::SAX
module Nokogiri::HTML4::SAX; end

# This class lets you perform SAX style parsing on HTML with HTML error correction.
#
# Here is a basic usage example:
#
#   class MyDoc < Nokogiri::XML::SAX::Document
#     def start_element name, attributes = []
#       puts "found a #{name}"
#     end
#   end
#
#   parser = Nokogiri::HTML4::SAX::Parser.new(MyDoc.new)
#   parser.parse(File.read(ARGV[0], mode: 'rb'))
#
# For more information on SAX parsers, see Nokogiri::XML::SAX
class Nokogiri::HTML4::SAX::Parser < ::Nokogiri::XML::SAX::Parser
  # Parse a file with +filename+
  #
  # @raise [ArgumentError]
  # @yield [ctx]
  def parse_file(filename, encoding = T.unsafe(nil)); end

  # Parse given +io+
  #
  # @yield [ctx]
  def parse_io(io, encoding = T.unsafe(nil)); end

  # Parse html stored in +data+ using +encoding+
  #
  # @raise [ArgumentError]
  # @yield [ctx]
  def parse_memory(data, encoding = T.unsafe(nil)); end
end

# Context for HTML SAX parsers. This class is usually not instantiated by the user. Instead,
# you should be looking at Nokogiri::HTML4::SAX::Parser
class Nokogiri::HTML4::SAX::ParserContext < ::Nokogiri::XML::SAX::ParserContext
  def parse_with(_arg0); end

  class << self
    def file(_arg0, _arg1); end
    def memory(_arg0, _arg1); end
    def new(thing, encoding = T.unsafe(nil)); end
  end
end

class Nokogiri::HTML4::SAX::PushParser < ::Nokogiri::XML::SAX::PushParser
  # @return [PushParser] a new instance of PushParser
  def initialize(doc = T.unsafe(nil), file_name = T.unsafe(nil), encoding = T.unsafe(nil)); end

  # Write a +chunk+ of HTML to the PushParser.  Any callback methods
  # that can be called will be called immediately.
  def <<(chunk, last_chunk = T.unsafe(nil)); end

  # The Nokogiri::HTML4::SAX::Document on which the PushParser will be
  # operating
  def document; end

  # The Nokogiri::HTML4::SAX::Document on which the PushParser will be
  # operating
  def document=(_arg0); end

  # Finish the parsing.  This method is only necessary for
  # Nokogiri::HTML4::SAX::Document#end_document to be called.
  def finish; end

  # Write a +chunk+ of HTML to the PushParser.  Any callback methods
  # that can be called will be called immediately.
  def write(chunk, last_chunk = T.unsafe(nil)); end

  private

  def initialize_native(_arg0, _arg1, _arg2); end
  def native_write(_arg0, _arg1); end
end

# == Usage
#
# Parse an HTML5 document:
#
#   doc = Nokogiri.HTML5(string)
#
# Parse an HTML5 fragment:
#
#   fragment = Nokogiri::HTML5.fragment(string)
#
# == Parsing options
#
# The document and fragment parsing methods support options that are different from Nokogiri's.
#
# - <tt>Nokogiri.HTML5(html, url = nil, encoding = nil, options = {})</tt>
# - <tt>Nokogiri::HTML5.parse(html, url = nil, encoding = nil, options = {})</tt>
# - <tt>Nokogiri::HTML5::Document.parse(html, url = nil, encoding = nil, options = {})</tt>
# - <tt>Nokogiri::HTML5.fragment(html, encoding = nil, options = {})</tt>
# - <tt>Nokogiri::HTML5::DocumentFragment.parse(html, encoding = nil, options = {})</tt>
#
# The three currently supported options are +:max_errors+, +:max_tree_depth+ and
# +:max_attributes+, described below.
#
# === Error reporting
#
# Nokogiri contains an experimental HTML5 parse error reporting facility. By default, no parse
# errors are reported but this can be configured by passing the +:max_errors+ option to
# {HTML5.parse} or {HTML5.fragment}.
#
# For example, this script:
#
#   doc = Nokogiri::HTML5.parse('<span/>Hi there!</span foo=bar />', max_errors: 10)
#   doc.errors.each do |err|
#     puts(err)
#   end
#
# Emits:
#
#   1:1: ERROR: Expected a doctype token
#   <span/>Hi there!</span foo=bar />
#   ^
#   1:1: ERROR: Start tag of nonvoid HTML element ends with '/>', use '>'.
#   <span/>Hi there!</span foo=bar />
#   ^
#   1:17: ERROR: End tag ends with '/>', use '>'.
#   <span/>Hi there!</span foo=bar />
#                   ^
#   1:17: ERROR: End tag contains attributes.
#   <span/>Hi there!</span foo=bar />
#                   ^
#
# Using <tt>max_errors: -1</tt> results in an unlimited number of errors being returned.
#
# The errors returned by {HTML5::Document#errors} are instances of {Nokogiri::XML::SyntaxError}.
#
# The {https://html.spec.whatwg.org/multipage/parsing.html#parse-errors HTML standard} defines a
# number of standard parse error codes. These error codes only cover the "tokenization" stage of
# parsing HTML. The parse errors in the "tree construction" stage do not have standardized error
# codes (yet).
#
# As a convenience to Nokogiri users, the defined error codes are available via
# {Nokogiri::XML::SyntaxError#str1} method.
#
#   doc = Nokogiri::HTML5.parse('<span/>Hi there!</span foo=bar />', max_errors: 10)
#   doc.errors.each do |err|
#     puts("#{err.line}:#{err.column}: #{err.str1}")
#   end
#   # => 1:1: generic-parser
#   #    1:1: non-void-html-element-start-tag-with-trailing-solidus
#   #    1:17: end-tag-with-trailing-solidus
#   #    1:17: end-tag-with-attributes
#
# Note that the first error is +generic-parser+ because it's an error from the tree construction
# stage and doesn't have a standardized error code.
#
# For the purposes of semantic versioning, the error messages, error locations, and error codes
# are not part of Nokogiri's public API. That is, these are subject to change without Nokogiri's
# major version number changing. These may be stabilized in the future.
#
# === Maximum tree depth
#
# The maximum depth of the DOM tree parsed by the various parsing methods is configurable by the
# +:max_tree_depth+ option. If the depth of the tree would exceed this limit, then an
# {::ArgumentError} is thrown.
#
# This limit (which defaults to <tt>Nokogiri::Gumbo::DEFAULT_MAX_TREE_DEPTH = 400</tt>) can be
# removed by giving the option <tt>max_tree_depth: -1</tt>.
#
#   html = '<!DOCTYPE html>' + '<div>' * 1000
#   doc = Nokogiri.HTML5(html)
#   # raises ArgumentError: Document tree depth limit exceeded
#   doc = Nokogiri.HTML5(html, max_tree_depth: -1)
#
# === Attribute limit per element
#
# The maximum number of attributes per DOM element is configurable by the +:max_attributes+
# option. If a given element would exceed this limit, then an {::ArgumentError} is thrown.
#
# This limit (which defaults to <tt>Nokogiri::Gumbo::DEFAULT_MAX_ATTRIBUTES = 400</tt>) can be
# removed by giving the option <tt>max_attributes: -1</tt>.
#
#   html = '<!DOCTYPE html><div ' + (1..1000).map { |x| "attr-#{x}" }.join(' ') + '>'
#   # "<!DOCTYPE html><div attr-1 attr-2 attr-3 ... attr-1000>"
#   doc = Nokogiri.HTML5(html)
#   # raises ArgumentError: Attributes per element limit exceeded
#   doc = Nokogiri.HTML5(html, max_attributes: -1)
#
# == HTML Serialization
#
# After parsing HTML, it may be serialized using any of the {Nokogiri::XML::Node} serialization
# methods. In particular, {XML::Node#serialize}, {XML::Node#to_html}, and {XML::Node#to_s} will
# serialize a given node and its children. (This is the equivalent of JavaScript's
# +Element.outerHTML+.) Similarly, {XML::Node#inner_html} will serialize the children of a given
# node. (This is the equivalent of JavaScript's +Element.innerHTML+.)
#
#   doc = Nokogiri::HTML5("<!DOCTYPE html><span>Hello world!</span>")
#   puts doc.serialize
#   # => <!DOCTYPE html><html><head></head><body><span>Hello world!</span></body></html>
#
# Due to quirks in how HTML is parsed and serialized, it's possible for a DOM tree to be
# serialized and then re-parsed, resulting in a different DOM.  Mostly, this happens with DOMs
# produced from invalid HTML. Unfortunately, even valid HTML may not survive serialization and
# re-parsing.
#
# In particular, a newline at the start of +pre+, +listing+, and +textarea+ elements is ignored by
# the parser.
#
#   doc = Nokogiri::HTML5(<<-EOF)
#   <!DOCTYPE html>
#   <pre>
#   Content</pre>
#   EOF
#   puts doc.at('/html/body/pre').serialize
#   # => <pre>Content</pre>
#
# In this case, the original HTML is semantically equivalent to the serialized version. If the
# +pre+, +listing+, or +textarea+ content starts with two newlines, the first newline will be
# stripped on the first parse and the second newline will be stripped on the second, leading to
# semantically different DOMs. Passing the parameter <tt>preserve_newline: true</tt> will cause
# two or more newlines to be preserved. (A single leading newline will still be removed.)
#
#   doc = Nokogiri::HTML5(<<-EOF)
#   <!DOCTYPE html>
#   <listing>
#
#   Content</listing>
#   EOF
#   puts doc.at('/html/body/listing').serialize(preserve_newline: true)
#   # => <listing>
#   #
#   #    Content</listing>
#
# == Encodings
#
# Nokogiri always parses HTML5 using {https://en.wikipedia.org/wiki/UTF-8 UTF-8}; however, the
# encoding of the input can be explicitly selected via the optional +encoding+ parameter. This is
# most useful when the input comes not from a string but from an IO object.
#
# When serializing a document or node, the encoding of the output string can be specified via the
# +:encoding+ options. Characters that cannot be encoded in the selected encoding will be encoded
# as {https://en.wikipedia.org/wiki/List_of_XML_and_HTML_character_entity_references HTML numeric
# entities}.
#
#   frag = Nokogiri::HTML5.fragment('<span>아는 길도 물어가라</span>')
#   puts html
#   # => <span>&#xc544;&#xb294; &#xae38;&#xb3c4; &#xbb3c;&#xc5b4;&#xac00;&#xb77c;</span>
#   frag = Nokogiri::HTML5.fragment(html)
#   puts frag.serialize
#   # => <span>아는 길도 물어가라</span>
#
# (There's a {https://bugs.ruby-lang.org/issues/15033 bug} in all current versions of Ruby that
# can cause the entity encoding to fail. Of the mandated supported encodings for HTML, the only
# encoding I'm aware of that has this bug is <tt>'ISO-2022-JP'</tt>. We recommend avoiding this
# encoding.)
#
# == Notes
#
# * The {Nokogiri::HTML5.fragment} function takes a string and parses it
#   as a HTML5 document.  The +<html>+, +<head>+, and +<body>+ elements are
#   removed from this document, and any children of these elements that remain
#   are returned as a {Nokogiri::HTML5::DocumentFragment}.
#
# * The {Nokogiri::HTML5.parse} function takes a string and passes it to the
#   <code>gumbo_parse_with_options</code> method, using the default options.
#   The resulting Gumbo parse tree is then walked.
#
# * Instead of uppercase element names, lowercase element names are produced.
#
# * Instead of returning +unknown+ as the element name for unknown tags, the
#   original tag name is returned verbatim.
#
# @note HTML5 functionality is not available when running JRuby.
# @since v1.12.0
module Nokogiri::HTML5
  class << self
    # @since v1.12.0
    def escape_text(text, encoding, attribute_mode); end

    # Parse a fragment from +string+. Convenience method for
    # {Nokogiri::HTML5::DocumentFragment.parse}.
    #
    # @since v1.12.0
    def fragment(string, encoding = T.unsafe(nil), **options); end

    # Fetch and parse a HTML document from the web, following redirects,
    # handling https, and determining the character encoding using HTML5
    # rules.  +uri+ may be a +String+ or a +URI+.  +options+ contains
    # http headers and special options.  Everything which is not a
    # special option is considered a header.  Special options include:
    #  * :follow_limit => number of redirects which are followed
    #  * :basic_auth => [username, password]
    #
    # @since v1.12.0
    def get(uri, options = T.unsafe(nil)); end

    # @since v1.12.0
    def get_impl(uri, options = T.unsafe(nil)); end

    # Parse an HTML 5 document. Convenience method for {Nokogiri::HTML5::Document.parse}
    #
    # @since v1.12.0
    def parse(string, url = T.unsafe(nil), encoding = T.unsafe(nil), **options, &block); end

    # @return [Boolean]
    # @since v1.12.0
    def prepend_newline?(node); end

    # @since v1.12.0
    def read_and_encode(string, encoding); end

    # Charset sniffing is a complex and controversial topic that understandably isn't done _by
    # default_ by the Ruby Net::HTTP library.  This being said, it is a very real problem for
    # consumers of HTML as the default for HTML is iso-8859-1, most "good" producers use utf-8, and
    # the Gumbo parser *only* supports utf-8.
    #
    # Accordingly, Nokogiri::HTML4::Document.parse provides limited encoding detection.  Following
    # this lead, Nokogiri::HTML5 attempts to do likewise, while attempting to more closely follow
    # the HTML5 standard.
    #
    # http://bugs.ruby-lang.org/issues/2567
    # http://www.w3.org/TR/html5/syntax.html#determining-the-character-encoding
    #
    # @since v1.12.0
    def reencode(body, content_type = T.unsafe(nil)); end

    # @since v1.12.0
    def serialize_node_internal(current_node, io, encoding, options); end
  end
end

# @note HTML5 functionality is not available when running JRuby.
# @since v1.12.0
class Nokogiri::HTML5::Document < ::Nokogiri::HTML4::Document
  # @since v1.12.0
  def fragment(tags = T.unsafe(nil)); end

  # @since v1.12.0
  def to_xml(options = T.unsafe(nil), &block); end

  class << self
    # @since v1.12.0
    def do_parse(string_or_io, url, encoding, options); end

    # @since v1.12.0
    # @yield [options]
    def parse(string_or_io, url = T.unsafe(nil), encoding = T.unsafe(nil), **options, &block); end

    # @raise [ArgumentError]
    # @since v1.12.0
    def read_io(io, url = T.unsafe(nil), encoding = T.unsafe(nil), **options); end

    # @raise [ArgumentError]
    # @since v1.12.0
    def read_memory(string, url = T.unsafe(nil), encoding = T.unsafe(nil), **options); end
  end
end

# @note HTML5 functionality is not available when running JRuby.
# @since v1.12.0
class Nokogiri::HTML5::DocumentFragment < ::Nokogiri::HTML4::DocumentFragment
  # Create a document fragment.
  #
  # @return [DocumentFragment] a new instance of DocumentFragment
  # @since v1.12.0
  def initialize(doc, tags = T.unsafe(nil), ctx = T.unsafe(nil), options = T.unsafe(nil)); end

  # @since v1.12.0
  def document; end

  # @since v1.12.0
  def document=(_arg0); end

  # @since v1.12.0
  def errors; end

  # @since v1.12.0
  def errors=(_arg0); end

  # @since v1.12.0
  def extract_params(params); end

  # @since v1.12.0
  def serialize(options = T.unsafe(nil), &block); end

  class << self
    # Parse a document fragment from +tags+, returning a Nodeset.
    #
    # @since v1.12.0
    def parse(tags, encoding = T.unsafe(nil), options = T.unsafe(nil)); end
  end
end

# HTML uses the XHTML namespace.
#
# @since v1.12.0
Nokogiri::HTML5::HTML_NAMESPACE = T.let(T.unsafe(nil), String)

# @since v1.12.0
Nokogiri::HTML5::MATHML_NAMESPACE = T.let(T.unsafe(nil), String)

# @note HTML5 functionality is not available when running JRuby.
# @since v1.12.0
module Nokogiri::HTML5::Node
  # @since v1.12.0
  def fragment(tags); end

  # @since v1.12.0
  def inner_html(options = T.unsafe(nil)); end

  # @since v1.12.0
  # @yield [config]
  def write_to(io, *options); end

  private

  # HTML elements can have attributes that contain colons.
  # Nokogiri::XML::Node#[]= treats names with colons as a prefixed QName
  # and tries to create an attribute in a namespace. This is especially
  # annoying with attribute names like xml:lang since libxml2 will
  # actually create the xml namespace if it doesn't exist already.
  #
  # @since v1.12.0
  def add_child_node_and_reparent_attrs(node); end
end

# @since v1.12.0
Nokogiri::HTML5::SVG_NAMESPACE = T.let(T.unsafe(nil), String)

# @since v1.12.0
Nokogiri::HTML5::XLINK_NAMESPACE = T.let(T.unsafe(nil), String)

# @since v1.12.0
Nokogiri::HTML5::XMLNS_NAMESPACE = T.let(T.unsafe(nil), String)

# @since v1.12.0
Nokogiri::HTML5::XML_NAMESPACE = T.let(T.unsafe(nil), String)

Nokogiri::LIBXML2_PATCHES = T.let(T.unsafe(nil), Array)
Nokogiri::LIBXML_COMPILED_VERSION = T.let(T.unsafe(nil), String)
Nokogiri::LIBXML_ICONV_ENABLED = T.let(T.unsafe(nil), TrueClass)
Nokogiri::LIBXML_LOADED_VERSION = T.let(T.unsafe(nil), String)
Nokogiri::LIBXML_MEMORY_MANAGEMENT = T.let(T.unsafe(nil), String)
Nokogiri::LIBXSLT_COMPILED_VERSION = T.let(T.unsafe(nil), String)
Nokogiri::LIBXSLT_DATETIME_ENABLED = T.let(T.unsafe(nil), TrueClass)
Nokogiri::LIBXSLT_LOADED_VERSION = T.let(T.unsafe(nil), String)
Nokogiri::LIBXSLT_PATCHES = T.let(T.unsafe(nil), Array)
Nokogiri::OTHER_LIBRARY_VERSIONS = T.let(T.unsafe(nil), String)
Nokogiri::PACKAGED_LIBRARIES = T.let(T.unsafe(nil), TrueClass)
class Nokogiri::SyntaxError < ::StandardError; end

module Nokogiri::Test
  class << self
    def __foreign_error_handler; end
  end
end

# The version of Nokogiri you are using
Nokogiri::VERSION = T.let(T.unsafe(nil), String)

# More complete version information about libxml
Nokogiri::VERSION_INFO = T.let(T.unsafe(nil), Hash)

class Nokogiri::VersionInfo
  include ::Singleton
  extend ::Singleton::SingletonClassMethods

  def compiled_libxml_version; end
  def compiled_libxslt_version; end
  def engine; end

  # @return [Boolean]
  def jruby?; end

  # @return [Boolean]
  def libxml2?; end

  # @return [Boolean]
  def libxml2_has_iconv?; end

  # @return [Boolean]
  def libxml2_precompiled?; end

  # @return [Boolean]
  def libxml2_using_packaged?; end

  # @return [Boolean]
  def libxml2_using_system?; end

  # @return [Boolean]
  def libxslt_has_datetime?; end

  def loaded_libxml_version; end
  def loaded_libxslt_version; end
  def ruby_minor; end
  def to_hash; end
  def to_markdown; end
  def warnings; end

  # @return [Boolean]
  def windows?; end
end

module Nokogiri::XML
  class << self
    # Parse an XML document using the Nokogiri::XML::Reader API.  See
    # Nokogiri::XML::Reader for mor information
    #
    # @yield [options]
    def Reader(string_or_io, url = T.unsafe(nil), encoding = T.unsafe(nil), options = T.unsafe(nil)); end

    # Create a new Nokogiri::XML::RelaxNG document from +string_or_io+.
    # See Nokogiri::XML::RelaxNG for an example.
    def RelaxNG(string_or_io, options = T.unsafe(nil)); end

    # Create a new Nokogiri::XML::Schema object using a +string_or_io+
    # object.
    def Schema(string_or_io, options = T.unsafe(nil)); end

    # Parse a fragment from +string+ in to a NodeSet.
    def fragment(string); end

    # Parse XML.  Convenience method for Nokogiri::XML::Document.parse
    def parse(thing, url = T.unsafe(nil), encoding = T.unsafe(nil), options = T.unsafe(nil), &block); end
  end
end

class Nokogiri::XML::Attr < ::Nokogiri::XML::Node
  def content=(_arg0); end
  def to_s; end
  def value; end
  def value=(_arg0); end

  private

  def inspect_attributes; end

  class << self
    def new(*_arg0); end
  end
end

# Represents an attribute declaration in a DTD
class Nokogiri::XML::AttributeDecl < ::Nokogiri::XML::Node
  def attribute_type; end
  def default; end
  def enumeration; end
  def inspect; end
end

# Nokogiri builder can be used for building XML and HTML documents.
#
# == Synopsis:
#
#   builder = Nokogiri::XML::Builder.new do |xml|
#     xml.root {
#       xml.products {
#         xml.widget {
#           xml.id_ "10"
#           xml.name "Awesome widget"
#         }
#       }
#     }
#   end
#   puts builder.to_xml
#
# Will output:
#
#   <?xml version="1.0"?>
#   <root>
#     <products>
#       <widget>
#         <id>10</id>
#         <name>Awesome widget</name>
#       </widget>
#     </products>
#   </root>
#
#
# === Builder scope
#
# The builder allows two forms.  When the builder is supplied with a block
# that has a parameter, the outside scope is maintained.  This means you
# can access variables that are outside your builder.  If you don't need
# outside scope, you can use the builder without the "xml" prefix like
# this:
#
#   builder = Nokogiri::XML::Builder.new do
#     root {
#       products {
#         widget {
#           id_ "10"
#           name "Awesome widget"
#         }
#       }
#     }
#   end
#
# == Special Tags
#
# The builder works by taking advantage of method_missing.  Unfortunately
# some methods are defined in ruby that are difficult or dangerous to
# remove.  You may want to create tags with the name "type", "class", and
# "id" for example.  In that case, you can use an underscore to
# disambiguate your tag name from the method call.
#
# Here is an example of using the underscore to disambiguate tag names from
# ruby methods:
#
#   @objects = [Object.new, Object.new, Object.new]
#
#   builder = Nokogiri::XML::Builder.new do |xml|
#     xml.root {
#       xml.objects {
#         @objects.each do |o|
#           xml.object {
#             xml.type_   o.type
#             xml.class_  o.class.name
#             xml.id_     o.id
#           }
#         end
#       }
#     }
#   end
#   puts builder.to_xml
#
# The underscore may be used with any tag name, and the last underscore
# will just be removed.  This code will output the following XML:
#
#   <?xml version="1.0"?>
#   <root>
#     <objects>
#       <object>
#         <type>Object</type>
#         <class>Object</class>
#         <id>48390</id>
#       </object>
#       <object>
#         <type>Object</type>
#         <class>Object</class>
#         <id>48380</id>
#       </object>
#       <object>
#         <type>Object</type>
#         <class>Object</class>
#         <id>48370</id>
#       </object>
#     </objects>
#   </root>
#
# == Tag Attributes
#
# Tag attributes may be supplied as method arguments.  Here is our
# previous example, but using attributes rather than tags:
#
#   @objects = [Object.new, Object.new, Object.new]
#
#   builder = Nokogiri::XML::Builder.new do |xml|
#     xml.root {
#       xml.objects {
#         @objects.each do |o|
#           xml.object(:type => o.type, :class => o.class, :id => o.id)
#         end
#       }
#     }
#   end
#   puts builder.to_xml
#
# === Tag Attribute Short Cuts
#
# A couple attribute short cuts are available when building tags.  The
# short cuts are available by special method calls when building a tag.
#
# This example builds an "object" tag with the class attribute "classy"
# and the id of "thing":
#
#   builder = Nokogiri::XML::Builder.new do |xml|
#     xml.root {
#       xml.objects {
#         xml.object.classy.thing!
#       }
#     }
#   end
#   puts builder.to_xml
#
# Which will output:
#
#   <?xml version="1.0"?>
#   <root>
#     <objects>
#       <object class="classy" id="thing"/>
#     </objects>
#   </root>
#
# All other options are still supported with this syntax, including
# blocks and extra tag attributes.
#
# == Namespaces
#
# Namespaces are added similarly to attributes.  Nokogiri::XML::Builder
# assumes that when an attribute starts with "xmlns", it is meant to be
# a namespace:
#
#   builder = Nokogiri::XML::Builder.new { |xml|
#     xml.root('xmlns' => 'default', 'xmlns:foo' => 'bar') do
#       xml.tenderlove
#     end
#   }
#   puts builder.to_xml
#
# Will output XML like this:
#
#   <?xml version="1.0"?>
#   <root xmlns:foo="bar" xmlns="default">
#     <tenderlove/>
#   </root>
#
# === Referencing declared namespaces
#
# Tags that reference non-default namespaces (i.e. a tag "foo:bar") can be
# built by using the Nokogiri::XML::Builder#[] method.
#
# For example:
#
#   builder = Nokogiri::XML::Builder.new do |xml|
#     xml.root('xmlns:foo' => 'bar') {
#       xml.objects {
#         xml['foo'].object.classy.thing!
#       }
#     }
#   end
#   puts builder.to_xml
#
# Will output this XML:
#
#   <?xml version="1.0"?>
#   <root xmlns:foo="bar">
#     <objects>
#       <foo:object class="classy" id="thing"/>
#     </objects>
#   </root>
#
# Note the "foo:object" tag.
#
# === Namespace inheritance
#
# In the Builder context, children will inherit their parent's namespace. This is the same
# behavior as if the underlying {XML::Document} set +namespace_inheritance+ to +true+:
#
#   result = Nokogiri::XML::Builder.new do |xml|
#     xml["soapenv"].Envelope("xmlns:soapenv" => "http://schemas.xmlsoap.org/soap/envelope/") do
#       xml.Header
#     end
#   end
#   result.doc.to_xml
#   # => <?xml version="1.0" encoding="utf-8"?>
#   #    <soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/">
#   #      <soapenv:Header/>
#   #    </soapenv:Envelope>
#
# Users may turn this behavior off by passing a keyword argument +namespace_inheritance:false+
# to the initializer:
#
#   result = Nokogiri::XML::Builder.new(namespace_inheritance: false) do |xml|
#     xml["soapenv"].Envelope("xmlns:soapenv" => "http://schemas.xmlsoap.org/soap/envelope/") do
#       xml.Header
#       xml["soapenv"].Body # users may explicitly opt into the namespace
#     end
#   end
#   result.doc.to_xml
#   # => <?xml version="1.0" encoding="utf-8"?>
#   #    <soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/">
#   #      <Header/>
#   #      <soapenv:Body/>
#   #    </soapenv:Envelope>
#
# For more information on namespace inheritance, please see {XML::Document#namespace_inheritance}
#
#
# == Document Types
#
# To create a document type (DTD), access use the Builder#doc method to get
# the current context document.  Then call Node#create_internal_subset to
# create the DTD node.
#
# For example, this Ruby:
#
#   builder = Nokogiri::XML::Builder.new do |xml|
#     xml.doc.create_internal_subset(
#       'html',
#       "-//W3C//DTD HTML 4.01 Transitional//EN",
#       "http://www.w3.org/TR/html4/loose.dtd"
#     )
#     xml.root do
#       xml.foo
#     end
#   end
#
#   puts builder.to_xml
#
# Will output this xml:
#
#   <?xml version="1.0"?>
#   <!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
#   <root>
#     <foo/>
#   </root>
class Nokogiri::XML::Builder
  # Create a new Builder object.  +options+ are sent to the top level
  # Document that is being built.
  #
  # Building a document with a particular encoding for example:
  #
  #   Nokogiri::XML::Builder.new(:encoding => 'UTF-8') do |xml|
  #     ...
  #   end
  #
  # @return [Builder] a new instance of Builder
  def initialize(options = T.unsafe(nil), root = T.unsafe(nil), &block); end

  # Append the given raw XML +string+ to the document
  def <<(string); end

  # Build a tag that is associated with namespace +ns+.  Raises an
  # ArgumentError if +ns+ has not been defined higher in the tree.
  def [](ns); end

  def arity; end
  def arity=(_arg0); end

  # Create a CDATA Node with content of +string+
  def cdata(string); end

  # Create a Comment Node with content of +string+
  def comment(string); end

  # A context object for use when the block has no arguments
  def context; end

  # A context object for use when the block has no arguments
  def context=(_arg0); end

  # The current Document object being built
  def doc; end

  # The current Document object being built
  def doc=(_arg0); end

  def method_missing(method, *args, &block); end

  # The parent of the current node being built
  def parent; end

  # The parent of the current node being built
  def parent=(_arg0); end

  # Create a Text Node with content of +string+
  def text(string); end

  # Convert this Builder object to XML
  def to_xml(*args); end

  private

  # Insert +node+ as a child of the current Node
  def insert(node, &block); end

  class << self
    # Create a builder with an existing root object.  This is for use when
    # you have an existing document that you would like to augment with
    # builder methods.  The builder context created will start with the
    # given +root+ node.
    #
    # For example:
    #
    #   doc = Nokogiri::XML(File.read('somedoc.xml'))
    #   Nokogiri::XML::Builder.with(doc.at_css('some_tag')) do |xml|
    #     # ... Use normal builder methods here ...
    #     xml.awesome # add the "awesome" tag below "some_tag"
    #   end
    def with(root, &block); end
  end
end

Nokogiri::XML::Builder::DEFAULT_DOCUMENT_OPTIONS = T.let(T.unsafe(nil), Hash)

class Nokogiri::XML::Builder::NodeBuilder
  # @return [NodeBuilder] a new instance of NodeBuilder
  def initialize(node, doc_builder); end

  def [](k); end
  def []=(k, v); end
  def method_missing(method, *args, &block); end
end

class Nokogiri::XML::CDATA < ::Nokogiri::XML::Text
  # Get the name of this CDATA node
  def name; end

  class << self
    def new(*_arg0); end
  end
end

class Nokogiri::XML::CharacterData < ::Nokogiri::XML::Node
  include ::Nokogiri::XML::PP::CharacterData
end

class Nokogiri::XML::Comment < ::Nokogiri::XML::CharacterData
  class << self
    def new(*_arg0); end
  end
end

class Nokogiri::XML::DTD < ::Nokogiri::XML::Node
  def attributes; end
  def each; end
  def elements; end
  def entities; end
  def external_id; end

  # @return [Boolean]
  def html5_dtd?; end

  # @return [Boolean]
  def html_dtd?; end

  def keys; end
  def notations; end
  def system_id; end
  def validate(_arg0); end
end

# Nokogiri::XML::Document is the main entry point for dealing with
# XML documents.  The Document is created by parsing an XML document.
# See Nokogiri::XML::Document.parse() for more information on parsing.
#
# For searching a Document, see Nokogiri::XML::Searchable#css and
# Nokogiri::XML::Searchable#xpath
class Nokogiri::XML::Document < ::Nokogiri::XML::Node
  # @return [Document] a new instance of Document
  def initialize(*args); end

  def <<(node_or_tags); end
  def add_child(node_or_tags); end
  def canonicalize(*_arg0); end
  def clone(*_arg0); end

  # Recursively get all namespaces from this node and its subtree and
  # return them as a hash.
  #
  # For example, given this document:
  #
  #   <root xmlns:foo="bar">
  #     <bar xmlns:hello="world" />
  #   </root>
  #
  # This method will return:
  #
  #   { 'xmlns:foo' => 'bar', 'xmlns:hello' => 'world' }
  #
  # WARNING: this method will clobber duplicate names in the keys.
  # For example, given this document:
  #
  #   <root xmlns:foo="bar">
  #     <bar xmlns:foo="baz" />
  #   </root>
  #
  # The hash returned will look like this: { 'xmlns:foo' => 'bar' }
  #
  # Non-prefixed default namespaces (as in "xmlns=") are not included
  # in the hash.
  #
  # Note that this method does an xpath lookup for nodes with
  # namespaces, and as a result the order may be dependent on the
  # implementation of the underlying XML library.
  def collect_namespaces; end

  # Create a CDATA Node containing +string+
  def create_cdata(string, &block); end

  # Create a Comment Node containing +string+
  def create_comment(string, &block); end

  # Create a new +Element+ with +name+ sharing GC lifecycle with the document, optionally
  # setting contents or attributes.
  #
  # Arguments may be passed to initialize the element:
  # - a +Hash+ argument will be used to set attributes
  # - a non-Hash object that responds to +#to_s+ will be used to set the new node's contents
  #
  # A block may be passed to mutate the node.
  #
  # @example An empty element without attributes
  #   doc.create_element("div")
  #   # => <div></div>
  # @example An element with contents
  #   doc.create_element("div", "contents")
  #   # => <div>contents</div>
  # @example An element with attributes
  #   doc.create_element("div", {"class" => "container"})
  #   # => <div class='container'></div>
  # @example An element with contents and attributes
  #   doc.create_element("div", "contents", {"class" => "container"})
  #   # => <div class='container'>contents</div>
  # @example Passing a block to mutate the element
  #   doc.create_element("div") { |node| node["class"] = "blue" if before_noon? }
  # @param name [String]
  # @param contents_or_attrs [#to_s, Hash]
  # @return [Nokogiri::XML::Element]
  # @yieldparam node [Nokogiri::XML::Element]
  def create_element(name, *contents_or_attrs, &block); end

  def create_entity(*_arg0); end

  # Create a Text Node with +string+
  def create_text_node(string, &block); end

  # Apply any decorators to +node+
  def decorate(node); end

  # Get the list of decorators given +key+
  def decorators(key); end

  # A reference to +self+
  def document; end

  def dup(*_arg0); end
  def encoding; end
  def encoding=(_arg0); end

  # A list of Nokogiri::XML::SyntaxError found when parsing a document
  def errors; end

  # A list of Nokogiri::XML::SyntaxError found when parsing a document
  def errors=(_arg0); end

  # Create a Nokogiri::XML::DocumentFragment from +tags+
  # Returns an empty fragment if +tags+ is nil.
  def fragment(tags = T.unsafe(nil)); end

  # The name of this document.  Always returns "document"
  def name; end

  # When true, reparented elements without a namespace will inherit their new parent's
  # namespace (if one exists). Defaults to +false+.
  #
  # @example Default behavior of namespace inheritance
  #   xml = <<~EOF
  #   <root xmlns:foo="http://nokogiri.org/default_ns/test/foo">
  #   <foo:parent>
  #   </foo:parent>
  #   </root>
  #   EOF
  #   doc = Nokogiri::XML(xml)
  #   parent = doc.at_xpath("//foo:parent", "foo" => "http://nokogiri.org/default_ns/test/foo")
  #   parent.add_child("<child></child>")
  #   doc.to_xml
  #   # => <?xml version="1.0"?>
  #   #    <root xmlns:foo="http://nokogiri.org/default_ns/test/foo">
  #   #      <foo:parent>
  #   #        <child/>
  #   #      </foo:parent>
  #   #    </root>
  # @example Setting namespace inheritance to +true+
  #   xml = <<~EOF
  #   <root xmlns:foo="http://nokogiri.org/default_ns/test/foo">
  #   <foo:parent>
  #   </foo:parent>
  #   </root>
  #   EOF
  #   doc = Nokogiri::XML(xml)
  #   doc.namespace_inheritance = true
  #   parent = doc.at_xpath("//foo:parent", "foo" => "http://nokogiri.org/default_ns/test/foo")
  #   parent.add_child("<child></child>")
  #   doc.to_xml
  #   # => <?xml version="1.0"?>
  #   #    <root xmlns:foo="http://nokogiri.org/default_ns/test/foo">
  #   #      <foo:parent>
  #   #        <foo:child/>
  #   #      </foo:parent>
  #   #    </root>
  # @return [Boolean]
  # @since v1.12.4
  def namespace_inheritance; end

  # When true, reparented elements without a namespace will inherit their new parent's
  # namespace (if one exists). Defaults to +false+.
  #
  # @example Default behavior of namespace inheritance
  #   xml = <<~EOF
  #   <root xmlns:foo="http://nokogiri.org/default_ns/test/foo">
  #   <foo:parent>
  #   </foo:parent>
  #   </root>
  #   EOF
  #   doc = Nokogiri::XML(xml)
  #   parent = doc.at_xpath("//foo:parent", "foo" => "http://nokogiri.org/default_ns/test/foo")
  #   parent.add_child("<child></child>")
  #   doc.to_xml
  #   # => <?xml version="1.0"?>
  #   #    <root xmlns:foo="http://nokogiri.org/default_ns/test/foo">
  #   #      <foo:parent>
  #   #        <child/>
  #   #      </foo:parent>
  #   #    </root>
  # @example Setting namespace inheritance to +true+
  #   xml = <<~EOF
  #   <root xmlns:foo="http://nokogiri.org/default_ns/test/foo">
  #   <foo:parent>
  #   </foo:parent>
  #   </root>
  #   EOF
  #   doc = Nokogiri::XML(xml)
  #   doc.namespace_inheritance = true
  #   parent = doc.at_xpath("//foo:parent", "foo" => "http://nokogiri.org/default_ns/test/foo")
  #   parent.add_child("<child></child>")
  #   doc.to_xml
  #   # => <?xml version="1.0"?>
  #   #    <root xmlns:foo="http://nokogiri.org/default_ns/test/foo">
  #   #      <foo:parent>
  #   #        <foo:child/>
  #   #      </foo:parent>
  #   #    </root>
  # @return [Boolean]
  # @since v1.12.4
  def namespace_inheritance=(_arg0); end

  # Get the hash of namespaces on the root Nokogiri::XML::Node
  def namespaces; end

  def remove_namespaces!; end
  def root; end
  def root=(_arg0); end

  # Explore a document with shortcut methods. See Nokogiri::Slop for details.
  #
  # Note that any nodes that have been instantiated before #slop!
  # is called will not be decorated with sloppy behavior. So, if you're in
  # irb, the preferred idiom is:
  #
  #   irb> doc = Nokogiri::Slop my_markup
  #
  # and not
  #
  #   irb> doc = Nokogiri::HTML my_markup
  #   ... followed by irb's implicit inspect (and therefore instantiation of every node) ...
  #   irb> doc.slop!
  #   ... which does absolutely nothing.
  def slop!; end

  def to_xml(*args, &block); end
  def url; end

  # Validate this Document against it's DTD.  Returns a list of errors on
  # the document or +nil+ when there is no DTD.
  def validate; end

  def version; end

  private

  def inspect_attributes; end

  class << self
    # @return [Boolean]
    def empty_doc?(string_or_io); end

    def new(*_arg0); end

    # Parse an XML file.
    #
    # +string_or_io+ may be a String, or any object that responds to
    # _read_ and _close_ such as an IO, or StringIO.
    #
    # +url+ (optional) is the URI where this document is located.
    #
    # +encoding+ (optional) is the encoding that should be used when processing
    # the document.
    #
    # +options+ (optional) is a configuration object that sets options during
    # parsing, such as Nokogiri::XML::ParseOptions::RECOVER. See the
    # Nokogiri::XML::ParseOptions for more information.
    #
    # +block+ (optional) is passed a configuration object on which
    # parse options may be set.
    #
    # By default, Nokogiri treats documents as untrusted, and so
    # does not attempt to load DTDs or access the network. See
    # Nokogiri::XML::ParseOptions for a complete list of options;
    # and that module's DEFAULT_XML constant for what's set (and not
    # set) by default.
    #
    # Nokogiri.XML() is a convenience method which will call this method.
    #
    # @yield [options]
    def parse(string_or_io, url = T.unsafe(nil), encoding = T.unsafe(nil), options = T.unsafe(nil)); end

    def read_io(_arg0, _arg1, _arg2, _arg3); end
    def read_memory(_arg0, _arg1, _arg2, _arg3); end
  end
end

Nokogiri::XML::Document::IMPLIED_XPATH_CONTEXTS = T.let(T.unsafe(nil), Array)
Nokogiri::XML::Document::NCNAME_CHAR = T.let(T.unsafe(nil), String)
Nokogiri::XML::Document::NCNAME_RE = T.let(T.unsafe(nil), Regexp)

# See http://www.w3.org/TR/REC-xml-names/#ns-decl for more details. Note that we're not
# attempting to handle unicode characters partly because libxml2 doesn't handle unicode
# characters in NCNAMEs.
Nokogiri::XML::Document::NCNAME_START_CHAR = T.let(T.unsafe(nil), String)

class Nokogiri::XML::DocumentFragment < ::Nokogiri::XML::Node
  # Create a new DocumentFragment from +tags+.
  #
  #  If +ctx+ is present, it is used as a context node for the
  #  subtree created, e.g., namespaces will be resolved relative
  #  to +ctx+.
  #
  # @return [DocumentFragment] a new instance of DocumentFragment
  def initialize(document, tags = T.unsafe(nil), ctx = T.unsafe(nil)); end

  # call-seq: css *rules, [namespace-bindings, custom-pseudo-class]
  #
  # Search this fragment for CSS +rules+. +rules+ must be one or more CSS
  # selectors. For example:
  #
  # For more information see Nokogiri::XML::Searchable#css
  def css(*args); end

  def dup; end

  # A list of Nokogiri::XML::SyntaxError found when parsing a document
  def errors; end

  def errors=(things); end
  def fragment(data); end

  # return the name for DocumentFragment
  def name; end

  # call-seq: search *paths, [namespace-bindings, xpath-variable-bindings, custom-handler-class]
  #
  # Search this fragment for +paths+. +paths+ must be one or more XPath or CSS queries.
  #
  # For more information see Nokogiri::XML::Searchable#search
  def search(*rules); end

  # Convert this DocumentFragment to a string
  def serialize; end

  # Convert this DocumentFragment to html
  # See Nokogiri::XML::NodeSet#to_html
  def to_html(*args); end

  # Convert this DocumentFragment to a string
  def to_s; end

  # Convert this DocumentFragment to xhtml
  # See Nokogiri::XML::NodeSet#to_xhtml
  def to_xhtml(*args); end

  # Convert this DocumentFragment to xml
  # See Nokogiri::XML::NodeSet#to_xml
  def to_xml(*args); end

  private

  # fix for issue 770
  def namespace_declarations(ctx); end

  class << self
    def new(*_arg0); end

    # Create a Nokogiri::XML::DocumentFragment from +tags+
    def parse(tags); end
  end
end

class Nokogiri::XML::Element < ::Nokogiri::XML::Node; end

# Represents the allowed content in an Element Declaration inside a DTD:
#
#   <?xml version="1.0"?><?TEST-STYLE PIDATA?>
#   <!DOCTYPE staff SYSTEM "staff.dtd" [
#      <!ELEMENT div1 (head, (p | list | note)*, div2*)>
#   ]>
#   </root>
#
# ElementContent represents the tree inside the <!ELEMENT> tag shown above
# that lists the possible content for the div1 tag.
class Nokogiri::XML::ElementContent
  # Get the children of this ElementContent node
  def children; end

  # Returns the value of attribute document.
  def document; end

  def name; end
  def occur; end
  def prefix; end
  def type; end

  private

  def c1; end
  def c2; end
end

Nokogiri::XML::ElementContent::ELEMENT = T.let(T.unsafe(nil), Integer)
Nokogiri::XML::ElementContent::MULT = T.let(T.unsafe(nil), Integer)

# Possible content occurrences
Nokogiri::XML::ElementContent::ONCE = T.let(T.unsafe(nil), Integer)

Nokogiri::XML::ElementContent::OPT = T.let(T.unsafe(nil), Integer)
Nokogiri::XML::ElementContent::OR = T.let(T.unsafe(nil), Integer)

# Possible definitions of type
Nokogiri::XML::ElementContent::PCDATA = T.let(T.unsafe(nil), Integer)

Nokogiri::XML::ElementContent::PLUS = T.let(T.unsafe(nil), Integer)
Nokogiri::XML::ElementContent::SEQ = T.let(T.unsafe(nil), Integer)

class Nokogiri::XML::ElementDecl < ::Nokogiri::XML::Node
  def content; end
  def element_type; end
  def inspect; end
  def prefix; end
end

class Nokogiri::XML::EntityDecl < ::Nokogiri::XML::Node
  def content; end
  def entity_type; end
  def external_id; end
  def inspect; end
  def original_content; end
  def system_id; end

  class << self
    def new(name, doc, *args); end
  end
end

Nokogiri::XML::EntityDecl::EXTERNAL_GENERAL_PARSED = T.let(T.unsafe(nil), Integer)
Nokogiri::XML::EntityDecl::EXTERNAL_GENERAL_UNPARSED = T.let(T.unsafe(nil), Integer)
Nokogiri::XML::EntityDecl::EXTERNAL_PARAMETER = T.let(T.unsafe(nil), Integer)
Nokogiri::XML::EntityDecl::INTERNAL_GENERAL = T.let(T.unsafe(nil), Integer)
Nokogiri::XML::EntityDecl::INTERNAL_PARAMETER = T.let(T.unsafe(nil), Integer)
Nokogiri::XML::EntityDecl::INTERNAL_PREDEFINED = T.let(T.unsafe(nil), Integer)

class Nokogiri::XML::EntityReference < ::Nokogiri::XML::Node
  def children; end
  def inspect_attributes; end

  class << self
    def new(*_arg0); end
  end
end

class Nokogiri::XML::Namespace
  include ::Nokogiri::XML::PP::Node

  # Returns the value of attribute document.
  def document; end

  def href; end
  def prefix; end

  private

  def inspect_attributes; end
end

# {Nokogiri::XML::Node} is your window to the fun filled world of dealing with XML and HTML
# tags. A {Nokogiri::XML::Node} may be treated similarly to a hash with regard to attributes. For
# example:
#
#   node = Nokogiri::XML::DocumentFragment.parse("<a href='#foo' id='link'>link</a>").at_css("a")
#   node.to_html # => "<a href=\"#foo\" id=\"link\">link</a>"
#   node['href'] # => "#foo"
#   node.keys # => ["href", "id"]
#   node.values # => ["#foo", "link"]
#   node['class'] = 'green' # => "green"
#   node.to_html # => "<a href=\"#foo\" id=\"link\" class=\"green\">link</a>"
#
# See the method group entitled "Working With Node Attributes" for the full set of methods.
#
# {Nokogiri::XML::Node} also has methods that let you move around your
# tree.  For navigating your tree, see:
#
# * {#parent}
# * {#children}
# * {#next}
# * {#previous}
#
# When printing or otherwise emitting a document or a node (and
# its subtree), there are a few methods you might want to use:
#
# * {#content}, {#text}, {#inner_text}, {#to_str}: These methods will all <b>emit plaintext</b>,
#   meaning that entities will be replaced (e.g., "&lt;" will be replaced with "<"), meaning
#   that any sanitizing will likely be un-done in the output.
#
# * {#to_s}, {#to_xml}, {#to_html}, {#inner_html}: These methods will all <b>emit
#   properly-escaped markup</b>, meaning that it's suitable for consumption by browsers,
#   parsers, etc.
#
# You may search this node's subtree using {#xpath} and {#css}
class Nokogiri::XML::Node
  include ::Nokogiri::HTML5::Node
  include ::Nokogiri::XML::PP::Node
  include ::Nokogiri::XML::Searchable
  include ::Enumerable

  # Create a new node with +name+ sharing GC lifecycle with +document+.
  #
  # @param name [String]
  # @param document [Nokogiri::XML::Document]
  # @return [Nokogiri::XML::Node]
  # @see Nokogiri::XML::Node.new
  # @yieldparam node [Nokogiri::XML::Node]
  def initialize(name, document); end

  # Add +node_or_tags+ as a child of this Node.
  # +node_or_tags+ can be a Nokogiri::XML::Node, a ::DocumentFragment, a ::NodeSet, or a string containing markup.
  #
  # Returns self, to support chaining of calls (e.g., root << child1 << child2)
  #
  # Also see related method +add_child+.
  def <<(node_or_tags); end

  # Compare two Node objects with respect to their Document.  Nodes from
  # different documents cannot be compared.
  def <=>(other); end

  # Test to see if this Node is equal to +other+
  def ==(other); end

  # Search this node's immediate children using CSS selector +selector+
  def >(selector); end

  # Get the attribute value for the attribute +name+
  def [](name); end

  # Set the attribute value for the attribute +name+ to +value+
  def []=(name, value); end

  # Accept a visitor.  This method calls "visit" on +visitor+ with self.
  def accept(visitor); end

  # Add +node_or_tags+ as a child of this Node.
  # +node_or_tags+ can be a Nokogiri::XML::Node, a ::DocumentFragment, a ::NodeSet, or a string containing markup.
  #
  # Returns the reparented node (if +node_or_tags+ is a Node), or NodeSet (if +node_or_tags+ is a DocumentFragment, NodeSet, or string).
  #
  # Also see related method +<<+.
  def add_child(node_or_tags); end

  # Ensure HTML CSS classes are present on a +Node+. Any CSS
  # classes in +names+ that already exist in the +Node+'s +class+
  # attribute are _not_ added. Note that any existing duplicates
  # in the +class+ attribute are not removed. Compare with
  # {#append_class}.
  #
  # This is a convenience function and is equivalent to:
  #   node.kwattr_add("class", names)
  #
  # @example Ensure that a +Node+ has CSS class "section"
  #   node                      # => <div></div>
  #   node.add_class("section") # => <div class="section"></div>
  #   node.add_class("section") # => <div class="section"></div> # duplicate not added
  # @example Ensure that a +Node+ has CSS classes "section" and "header", via a String argument.
  #   node                             # => <div class="section section"></div>
  #   node.add_class("section header") # => <div class="section section header"></div>
  #   # Note that the CSS class "section" is not added because it is already present.
  #   # Note also that the pre-existing duplicate CSS class "section" is not removed.
  # @example Ensure that a +Node+ has CSS classes "section" and "header", via an Array argument.
  #   node                                  # => <div></div>
  #   node.add_class(["section", "header"]) # => <div class="section header"></div>
  # @param names [String, Array<String>] CSS class names to be added to the Node's +class+
  #   attribute. May be a string containing whitespace-delimited
  #   names, or an Array of String names. Any class names already
  #   present will not be added. Any class names not present will
  #   be added. If no +class+ attribute exists, one is created.
  # @return [Node] Returns +self+ for ease of chaining method calls.
  # @see #kwattr_add
  # @see #classes
  # @see #append_class
  # @see #remove_class
  def add_class(names); end

  def add_namespace(_arg0, _arg1); end
  def add_namespace_definition(_arg0, _arg1); end

  # Insert +node_or_tags+ after this Node (as a sibling).
  # +node_or_tags+ can be a Nokogiri::XML::Node, a ::DocumentFragment, a ::NodeSet, or a string containing markup.
  #
  # Returns the reparented node (if +node_or_tags+ is a Node), or NodeSet (if +node_or_tags+ is a DocumentFragment, NodeSet, or string).
  #
  # Also see related method +after+.
  #
  # @raise [ArgumentError]
  def add_next_sibling(node_or_tags); end

  # Insert +node_or_tags+ before this Node (as a sibling).
  # +node_or_tags+ can be a Nokogiri::XML::Node, a ::DocumentFragment, a ::NodeSet, or a string containing markup.
  #
  # Returns the reparented node (if +node_or_tags+ is a Node), or NodeSet (if +node_or_tags+ is a DocumentFragment, NodeSet, or string).
  #
  # Also see related method +before+.
  #
  # @raise [ArgumentError]
  def add_previous_sibling(node_or_tags); end

  # Insert +node_or_tags+ after this node (as a sibling).
  # +node_or_tags+ can be a Nokogiri::XML::Node, a Nokogiri::XML::DocumentFragment, or a string containing markup.
  #
  # Returns self, to support chaining of calls.
  #
  # Also see related method +add_next_sibling+.
  def after(node_or_tags); end

  # Get a list of ancestor Node for this Node.  If +selector+ is given,
  # the ancestors must match +selector+
  def ancestors(selector = T.unsafe(nil)); end

  # Add HTML CSS classes to a +Node+, regardless of
  # duplication. Compare with {#add_class}.
  #
  # This is a convenience function and is equivalent to:
  #   node.kwattr_append("class", names)
  #
  # @example Append "section" to a +Node+'s CSS +class+ attriubute
  #   node                         # => <div></div>
  #   node.append_class("section") # => <div class="section"></div>
  #   node.append_class("section") # => <div class="section section"></div> # duplicate added!
  # @example Append "section" and "header" to a +Node+'s CSS +class+ attribute, via a String argument.
  #   node                                # => <div class="section section"></div>
  #   node.append_class("section header") # => <div class="section section section header"></div>
  #   # Note that the CSS class "section" is appended even though it is already present.
  # @example Append "section" and "header" to a +Node+'s CSS +class+ attribute, via an Array argument.
  #   node                                     # => <div></div>
  #   node.append_class(["section", "header"]) # => <div class="section header"></div>
  #   node.append_class(["section", "header"]) # => <div class="section header section header"></div>
  # @param names [String, Array<String>] CSS class names to be appended to the Node's +class+
  #   attribute. May be a string containing whitespace-delimited
  #   names, or an Array of String names. All class names passed
  #   in will be appended to the +class+ attribute even if they
  #   are already present in the attribute value. If no +class+
  #   attribute exists, one is created.
  # @return [Node] Returns +self+ for ease of chaining method calls.
  # @see #kwattr_append
  # @see #classes
  # @see #add_class
  # @see #remove_class
  def append_class(names); end

  # Get the attribute value for the attribute +name+
  def attr(name); end

  def attribute(_arg0); end
  def attribute_nodes; end
  def attribute_with_ns(_arg0, _arg1); end

  # Returns a hash containing the node's attributes.  The key is
  # the attribute name without any namespace, the value is a Nokogiri::XML::Attr
  # representing the attribute.
  # If you need to distinguish attributes with the same name, with different namespaces
  # use #attribute_nodes instead.
  def attributes; end

  # Insert +node_or_tags+ before this node (as a sibling).
  # +node_or_tags+ can be a Nokogiri::XML::Node, a ::DocumentFragment, a ::NodeSet, or a string containing markup.
  #
  # Returns self, to support chaining of calls.
  #
  # Also see related method +add_previous_sibling+.
  def before(node_or_tags); end

  def blank?; end
  def canonicalize(mode = T.unsafe(nil), inclusive_namespaces = T.unsafe(nil), with_comments = T.unsafe(nil)); end

  # Returns true if this is a CDATA
  #
  # @return [Boolean]
  def cdata?; end

  def child; end
  def children; end

  # Set the inner html for this Node +node_or_tags+
  # +node_or_tags+ can be a Nokogiri::XML::Node, a Nokogiri::XML::DocumentFragment, or a string containing markup.
  #
  # Returns the reparented node (if +node_or_tags+ is a Node), or NodeSet (if +node_or_tags+ is a DocumentFragment, NodeSet, or string).
  #
  # Also see related method +inner_html=+
  def children=(node_or_tags); end

  # Get the CSS class names of a Node.
  #
  # This is a convenience function and is equivalent to:
  #   node.kwattr_values("class")
  #
  # @example
  #   node         # => <div class="section title header"></div>
  #   node.classes # => ["section", "title", "header"]
  # @return [Array<String>] The CSS classes present in the Node's +class+ attribute. If
  #   the attribute is empty or non-existent, the return value is
  #   an empty array.
  # @see #kwattr_values
  # @see #add_class
  # @see #append_class
  # @see #remove_class
  def classes; end

  def clone(*_arg0); end

  # Returns true if this is a Comment
  #
  # @return [Boolean]
  def comment?; end

  def content; end

  # Set the Node's content to a Text node containing +string+. The string gets XML escaped, not interpreted as markup.
  def content=(string); end

  def create_external_subset(_arg0, _arg1, _arg2); end
  def create_internal_subset(_arg0, _arg1, _arg2); end

  # Get the path to this node as a CSS expression
  def css_path; end

  # Decorate this node with the decorators set up in this node's Document
  def decorate!; end

  # Adds a default namespace supplied as a string +url+ href, to self.
  # The consequence is as an xmlns attribute with supplied argument were
  # present in parsed XML.  A default namespace set with this method will
  # now show up in #attributes, but when this node is serialized to XML an
  # "xmlns" attribute will appear. See also #namespace and #namespace=
  def default_namespace=(url); end

  # Remove the attribute named +name+
  def delete(name); end

  # Fetch the Nokogiri::HTML4::ElementDescription for this node.  Returns
  # nil on XML documents and on unknown tags.
  def description; end

  # Do xinclude substitution on the subtree below node. If given a block, a
  # Nokogiri::XML::ParseOptions object initialized from +options+, will be
  # passed to it, allowing more convenient modification of the parser options.
  #
  # @yield [options]
  def do_xinclude(options = T.unsafe(nil)); end

  def document; end

  # Returns true if this is a Document
  #
  # @return [Boolean]
  def document?; end

  def dup(*_arg0); end

  # Iterate over each attribute name and value pair for this Node.
  def each; end

  # Returns true if this is an Element node
  #
  # @return [Boolean]
  def elem?; end

  # Returns true if this is an Element node
  #
  # @return [Boolean]
  def element?; end

  def element_children; end
  def elements; end
  def encode_special_chars(_arg0); end
  def external_subset; end
  def first_element_child; end

  # Create a DocumentFragment containing +tags+ that is relative to _this_
  # context node.
  def fragment(tags); end

  # Returns true if this is a DocumentFragment
  #
  # @return [Boolean]
  def fragment?; end

  # Get the attribute value for the attribute +name+
  def get_attribute(name); end

  def has_attribute?(_arg0); end

  # Returns true if this is an HTML4::Document node
  #
  # @return [Boolean]
  def html?; end

  # Get the inner_html for this node's Node#children
  def inner_html(options = T.unsafe(nil)); end

  # Set the inner html for this Node to +node_or_tags+
  # +node_or_tags+ can be a Nokogiri::XML::Node, a Nokogiri::XML::DocumentFragment, or a string containing markup.
  #
  # Returns self.
  #
  # Also see related method +children=+
  def inner_html=(node_or_tags); end

  def inner_text; end
  def internal_subset; end
  def key?(_arg0); end

  # Get the attribute names for this Node.
  def keys; end

  # Ensure that values are present in a keyword attribute.
  #
  # Any values in +keywords+ that already exist in the +Node+'s
  # attribute values are _not_ added. Note that any existing
  # duplicates in the attribute values are not removed. Compare
  # with {#kwattr_append}.
  #
  # A "keyword attribute" is a node attribute that contains a set
  # of space-delimited values. Perhaps the most familiar example
  # of this is the HTML +class+ attribute used to contain CSS
  # classes. But other keyword attributes exist, for instance
  # [`rel`](https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/rel).
  #
  # @example Ensure that a +Node+ has "nofollow" in its +rel+ attribute.
  #   node                               # => <a></a>
  #   node.kwattr_add("rel", "nofollow") # => <a rel="nofollow"></a>
  #   node.kwattr_add("rel", "nofollow") # => <a rel="nofollow"></a> # duplicate not added
  # @example Ensure that a +Node+ has "nofollow" and "noreferrer" in its +rel+ attribute, via a String argument.
  #   node                                          # => <a rel="nofollow nofollow"></a>
  #   node.kwattr_add("rel", "nofollow noreferrer") # => <a rel="nofollow nofollow noreferrer"></a>
  #   # Note that "nofollow" is not added because it is already present.
  #   # Note also that the pre-existing duplicate "nofollow" is not removed.
  # @example Ensure that a +Node+ has "nofollow" and "noreferrer" in its +rel+ attribute, via an Array argument.
  #   node                                               # => <a></a>
  #   node.kwattr_add("rel", ["nofollow", "noreferrer"]) # => <a rel="nofollow noreferrer"></a>
  # @param attribute_name [String] The name of the keyword attribute to be modified.
  # @param keywords [String, Array<String>] Keywords to be added to the attribute named
  #   +attribute_name+. May be a string containing
  #   whitespace-delimited values, or an Array of String
  #   values. Any values already present will not be added. Any
  #   values not present will be added. If the named attribute
  #   does not exist, it is created.
  # @return [Node] Returns +self+ for ease of chaining method calls.
  # @see #add_class
  # @see #kwattr_values
  # @see #kwattr_append
  # @see #kwattr_remove
  # @since v1.11.0
  def kwattr_add(attribute_name, keywords); end

  # Add keywords to a Node's keyword attribute, regardless of
  # duplication. Compare with {#kwattr_add}.
  #
  # A "keyword attribute" is a node attribute that contains a set
  # of space-delimited values. Perhaps the most familiar example
  # of this is the HTML +class+ attribute used to contain CSS
  # classes. But other keyword attributes exist, for instance
  # [`rel`](https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/rel).
  #
  # @example Append "nofollow" to the +rel+ attribute.
  #   node                                  # => <a></a>
  #   node.kwattr_append("rel", "nofollow") # => <a rel="nofollow"></a>
  #   node.kwattr_append("rel", "nofollow") # => <a rel="nofollow nofollow"></a> # duplicate added!
  # @example Append "nofollow" and "noreferrer" to the +rel+ attribute, via a String argument.
  #   node                                             # => <a rel="nofollow"></a>
  #   node.kwattr_append("rel", "nofollow noreferrer") # => <a rel="nofollow nofollow noreferrer"></a>
  #   # Note that "nofollow" is appended even though it is already present.
  # @example Append "nofollow" and "noreferrer" to the +rel+ attribute, via an Array argument.
  #   node                                                  # => <a></a>
  #   node.kwattr_append("rel", ["nofollow", "noreferrer"]) # => <a rel="nofollow noreferrer"></a>
  # @param attribute_name [String] The name of the keyword attribute to be modified.
  # @param keywords [String, Array<String>] Keywords to be added to the attribute named
  #   +attribute_name+. May be a string containing
  #   whitespace-delimited values, or an Array of String
  #   values. All values passed in will be appended to the named
  #   attribute even if they are already present in the
  #   attribute. If the named attribute does not exist, it is
  #   created.
  # @return [Node] Returns +self+ for ease of chaining method calls.
  # @see #append_class
  # @see #kwattr_values
  # @see #kwattr_add
  # @see #kwattr_remove
  # @since v1.11.0
  def kwattr_append(attribute_name, keywords); end

  # Remove keywords from a keyword attribute. Any matching
  # keywords that exist in the named attribute are removed,
  # including any multiple entries.
  #
  # If no keywords remain after this operation, or if +keywords+
  # is +nil+, the attribute is deleted from the node.
  #
  # A "keyword attribute" is a node attribute that contains a set
  # of space-delimited values. Perhaps the most familiar example
  # of this is the HTML +class+ attribute used to contain CSS
  # classes. But other keyword attributes exist, for instance
  # [`rel`](https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/rel).
  #
  # @example
  #   node                                    # => <a rel="nofollow noreferrer">link</a>
  #   node.kwattr_remove("rel", "nofollow")   # => <a rel="noreferrer">link</a>
  #   node.kwattr_remove("rel", "noreferrer") # => <a>link</a> # attribute is deleted when empty
  # @param attribute_name [String] The name of the keyword attribute to be modified.
  # @param keywords [String, Array<String>] Keywords to be removed from the attribute named
  #   +attribute_name+. May be a string containing
  #   whitespace-delimited values, or an Array of String
  #   values. Any keywords present in the named attribute will be
  #   removed. If no keywords remain, or if +keywords+ is nil, the
  #   attribute is deleted.
  # @return [Node] Returns +self+ for ease of chaining method calls.
  # @see #remove_class
  # @see #kwattr_values
  # @see #kwattr_add
  # @see #kwattr_append
  # @since v1.11.0
  def kwattr_remove(attribute_name, keywords); end

  # Retrieve values from a keyword attribute of a Node.
  #
  # A "keyword attribute" is a node attribute that contains a set
  # of space-delimited values. Perhaps the most familiar example
  # of this is the HTML +class+ attribute used to contain CSS
  # classes. But other keyword attributes exist, for instance
  # [`rel`](https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/rel).
  #
  # @example
  #   node                      # => <a rel="nofollow noopener external">link</a>
  #   node.kwattr_values("rel") # => ["nofollow", "noopener", "external"]
  # @param attribute_name [String] The name of the keyword attribute to be inspected.
  # @return [Array<String>] The values present in the Node's +attribute_name+
  #   attribute. If the attribute is empty or non-existent, the
  #   return value is an empty array.
  # @see #kwattr_remove
  # @see #kwattr_add
  # @see #classes
  # @see #kwattr_append
  # @since v1.11.0
  def kwattr_values(attribute_name); end

  def lang; end
  def lang=(_arg0); end
  def last_element_child; end
  def line; end
  def line=(_arg0); end

  # Returns true if this Node matches +selector+
  #
  # @return [Boolean]
  def matches?(selector); end

  def name; end
  def name=(_arg0); end
  def namespace; end

  # Set the default namespace on this node (as would be defined with an
  # "xmlns=" attribute in XML source), as a Namespace object +ns+. Note that
  # a Namespace added this way will NOT be serialized as an xmlns attribute
  # for this node. You probably want #default_namespace= instead, or perhaps
  # #add_namespace_definition with a nil prefix argument.
  def namespace=(ns); end

  def namespace_definitions; end
  def namespace_scopes; end
  def namespaced_key?(_arg0, _arg1); end

  # Returns a Hash of +{prefix => value}+ for all namespaces on this
  # node and its ancestors.
  #
  # This method returns the same namespaces as #namespace_scopes.
  #
  # Returns namespaces in scope for self -- those defined on self
  # element directly or any ancestor node -- as a Hash of
  # attribute-name/value pairs. Note that the keys in this hash
  # XML attributes that would be used to define this namespace,
  # such as "xmlns:prefix", not just the prefix. Default namespace
  # set on self will be included with key "xmlns". However,
  # default namespaces set on ancestor will NOT be, even if self
  # has no explicit default namespace.
  def namespaces; end

  def native_content=(_arg0); end
  def next; end

  # Insert +node_or_tags+ after this Node (as a sibling).
  # +node_or_tags+ can be a Nokogiri::XML::Node, a ::DocumentFragment, a ::NodeSet, or a string containing markup.
  #
  # Returns the reparented node (if +node_or_tags+ is a Node), or NodeSet (if +node_or_tags+ is a DocumentFragment, NodeSet, or string).
  #
  # Also see related method +after+.
  #
  # @raise [ArgumentError]
  def next=(node_or_tags); end

  def next_element; end
  def next_sibling; end
  def node_name; end
  def node_name=(_arg0); end
  def node_type; end
  def parent; end

  # Set the parent Node for this Node
  def parent=(parent_node); end

  # Parse +string_or_io+ as a document fragment within the context of
  # *this* node.  Returns a XML::NodeSet containing the nodes parsed from
  # +string_or_io+.
  #
  # @yield [options]
  def parse(string_or_io, options = T.unsafe(nil)); end

  def path; end
  def pointer_id; end

  # Add +node_or_tags+ as the first child of this Node.
  # +node_or_tags+ can be a Nokogiri::XML::Node, a ::DocumentFragment, a ::NodeSet, or a string containing markup.
  #
  # Returns the reparented node (if +node_or_tags+ is a Node), or NodeSet (if +node_or_tags+ is a DocumentFragment, NodeSet, or string).
  #
  # Also see related method +add_child+.
  def prepend_child(node_or_tags); end

  def previous; end

  # Insert +node_or_tags+ before this Node (as a sibling).
  # +node_or_tags+ can be a Nokogiri::XML::Node, a ::DocumentFragment, a ::NodeSet, or a string containing markup.
  #
  # Returns the reparented node (if +node_or_tags+ is a Node), or NodeSet (if +node_or_tags+ is a DocumentFragment, NodeSet, or string).
  #
  # Also see related method +before+.
  #
  # @raise [ArgumentError]
  def previous=(node_or_tags); end

  def previous_element; end
  def previous_sibling; end

  # Returns true if this is a ProcessingInstruction node
  #
  # @return [Boolean]
  def processing_instruction?; end

  # Is this a read only node?
  #
  # @return [Boolean]
  def read_only?; end

  def remove; end

  # Remove the attribute named +name+
  def remove_attribute(name); end

  # Remove HTML CSS classes from a +Node+. Any CSS classes in +names+ that
  # exist in the +Node+'s +class+ attribute are removed, including any
  # multiple entries.
  #
  # If no CSS classes remain after this operation, or if +names+ is
  # +nil+, the +class+ attribute is deleted from the node.
  #
  # This is a convenience function and is equivalent to:
  #   node.kwattr_remove("class", names)
  #
  # @example
  #   node                         # => <div class="section header"></div>
  #   node.remove_class("section") # => <div class="header"></div>
  #   node.remove_class("header")  # => <div></div> # attribute is deleted when empty
  # @param names [String, Array<String>] CSS class names to be removed from the Node's +class+ attribute. May
  #   be a string containing whitespace-delimited names, or an Array of
  #   String names. Any class names already present will be removed. If no
  #   CSS classes remain, the +class+ attribute is deleted.
  # @return [Node] Returns +self+ for ease of chaining method calls.
  # @see #kwattr_remove
  # @see #classes
  # @see #add_class
  # @see #append_class
  def remove_class(names = T.unsafe(nil)); end

  # Replace this Node with +node_or_tags+.
  # +node_or_tags+ can be a Nokogiri::XML::Node, a ::DocumentFragment, a ::NodeSet, or a string containing markup.
  #
  # Returns the reparented node (if +node_or_tags+ is a Node), or NodeSet (if +node_or_tags+ is a DocumentFragment, NodeSet, or string).
  #
  # Also see related method +swap+.
  def replace(node_or_tags); end

  # Serialize Node using +options+.  Save options can also be set using a
  # block. See SaveOptions.
  #
  # These two statements are equivalent:
  #
  #  node.serialize(:encoding => 'UTF-8', :save_with => FORMAT | AS_XML)
  #
  # or
  #
  #   node.serialize(:encoding => 'UTF-8') do |config|
  #     config.format.as_xml
  #   end
  def serialize(*args, &block); end

  # Set the attribute value for the attribute +name+ to +value+
  def set_attribute(name, value); end

  # Swap this Node for +node_or_tags+
  # +node_or_tags+ can be a Nokogiri::XML::Node, a ::DocumentFragment, a ::NodeSet, or a string containing markup.
  #
  # Returns self, to support chaining of calls.
  #
  # Also see related method +replace+.
  def swap(node_or_tags); end

  def text; end

  # Returns true if this is a Text node
  #
  # @return [Boolean]
  def text?; end

  # Serialize this Node to HTML
  #
  #   doc.to_html
  #
  # See Node#write_to for a list of +options+.  For formatted output,
  # use Node#to_xhtml instead.
  def to_html(options = T.unsafe(nil)); end

  # Turn this node in to a string.  If the document is HTML, this method
  # returns html.  If the document is XML, this method returns XML.
  def to_s; end

  def to_str; end

  # Serialize this Node to XHTML using +options+
  #
  #   doc.to_xhtml(:indent => 5, :encoding => 'UTF-8')
  #
  # See Node#write_to for a list of +options+
  def to_xhtml(options = T.unsafe(nil)); end

  # Serialize this Node to XML using +options+
  #
  #   doc.to_xml(:indent => 5, :encoding => 'UTF-8')
  #
  # See Node#write_to for a list of +options+
  def to_xml(options = T.unsafe(nil)); end

  # Yields self and all children to +block+ recursively.
  def traverse(&block); end

  def type; end
  def unlink; end

  # Does this Node's attributes include <value>
  #
  # @return [Boolean]
  def value?(value); end

  # Get the attribute values for this Node.
  def values; end

  # Add html around this node
  #
  # Returns self
  def wrap(html); end

  # Write Node as HTML to +io+ with +options+
  #
  # See Node#write_to for a list of +options+
  def write_html_to(io, options = T.unsafe(nil)); end

  # Write Node to +io+ with +options+. +options+ modify the output of
  # this method.  Valid options are:
  #
  # * +:encoding+ for changing the encoding
  # * +:indent_text+ the indentation text, defaults to one space
  # * +:indent+ the number of +:indent_text+ to use, defaults to 2
  # * +:save_with+ a combination of SaveOptions constants.
  #
  # To save with UTF-8 indented twice:
  #
  #   node.write_to(io, :encoding => 'UTF-8', :indent => 2)
  #
  # To save indented with two dashes:
  #
  #   node.write_to(io, :indent_text => '-', :indent => 2)
  #
  # @yield [config]
  def write_to(io, *options); end

  # Write Node as XHTML to +io+ with +options+
  #
  # See Node#write_to for a list of +options+
  def write_xhtml_to(io, options = T.unsafe(nil)); end

  # Write Node as XML to +io+ with +options+
  #
  #   doc.write_xml_to io, :encoding => 'UTF-8'
  #
  # See Node#write_to for a list of options
  def write_xml_to(io, options = T.unsafe(nil)); end

  # Returns true if this is an XML::Document node
  #
  # @return [Boolean]
  def xml?; end

  protected

  # @raise [ArgumentError]
  def coerce(data); end

  private

  def add_child_node(_arg0); end
  def add_child_node_and_reparent_attrs(node); end
  def add_next_sibling_node(_arg0); end
  def add_previous_sibling_node(_arg0); end
  def add_sibling(next_or_previous, node_or_tags); end
  def compare(_arg0); end
  def dump_html; end
  def get(_arg0); end
  def in_context(_arg0, _arg1); end
  def inspect_attributes; end
  def keywordify(keywords); end
  def native_write_to(_arg0, _arg1, _arg2, _arg3); end
  def process_xincludes(_arg0); end
  def replace_node(_arg0); end
  def set(_arg0, _arg1); end
  def set_namespace(_arg0); end
  def to_format(save_option, options); end
  def write_format_to(save_option, io, options); end

  class << self
    def new(*_arg0); end
  end
end

# Attribute declaration type
Nokogiri::XML::Node::ATTRIBUTE_DECL = T.let(T.unsafe(nil), Integer)

# Attribute node type
Nokogiri::XML::Node::ATTRIBUTE_NODE = T.let(T.unsafe(nil), Integer)

# CDATA node type, see {Nokogiri::XML::Node#cdata?}
Nokogiri::XML::Node::CDATA_SECTION_NODE = T.let(T.unsafe(nil), Integer)

# Comment node type, see {Nokogiri::XML::Node#comment?}
Nokogiri::XML::Node::COMMENT_NODE = T.let(T.unsafe(nil), Integer)

# DOCB document node type
Nokogiri::XML::Node::DOCB_DOCUMENT_NODE = T.let(T.unsafe(nil), Integer)

# Document fragment node type
Nokogiri::XML::Node::DOCUMENT_FRAG_NODE = T.let(T.unsafe(nil), Integer)

# Document node type, see {Nokogiri::XML::Node#xml?}
Nokogiri::XML::Node::DOCUMENT_NODE = T.let(T.unsafe(nil), Integer)

# Document type node type
Nokogiri::XML::Node::DOCUMENT_TYPE_NODE = T.let(T.unsafe(nil), Integer)

# DTD node type
Nokogiri::XML::Node::DTD_NODE = T.let(T.unsafe(nil), Integer)

# Element declaration type
Nokogiri::XML::Node::ELEMENT_DECL = T.let(T.unsafe(nil), Integer)

# Element node type, see {Nokogiri::XML::Node#element?}
Nokogiri::XML::Node::ELEMENT_NODE = T.let(T.unsafe(nil), Integer)

# Entity declaration type
Nokogiri::XML::Node::ENTITY_DECL = T.let(T.unsafe(nil), Integer)

# Entity node type
Nokogiri::XML::Node::ENTITY_NODE = T.let(T.unsafe(nil), Integer)

# Entity reference node type
Nokogiri::XML::Node::ENTITY_REF_NODE = T.let(T.unsafe(nil), Integer)

# HTML document node type, see {Nokogiri::XML::Node#html?}
Nokogiri::XML::Node::HTML_DOCUMENT_NODE = T.let(T.unsafe(nil), Integer)

# @private
Nokogiri::XML::Node::IMPLIED_XPATH_CONTEXTS = T.let(T.unsafe(nil), Array)

# Namespace declaration type
Nokogiri::XML::Node::NAMESPACE_DECL = T.let(T.unsafe(nil), Integer)

# Notation node type
Nokogiri::XML::Node::NOTATION_NODE = T.let(T.unsafe(nil), Integer)

# PI node type
Nokogiri::XML::Node::PI_NODE = T.let(T.unsafe(nil), Integer)

# Save options for serializing nodes
class Nokogiri::XML::Node::SaveOptions
  # Create a new SaveOptions object with +options+
  #
  # @return [SaveOptions] a new instance of SaveOptions
  def initialize(options = T.unsafe(nil)); end

  def as_html; end
  def as_html?; end
  def as_xhtml; end
  def as_xhtml?; end
  def as_xml; end
  def as_xml?; end
  def default_html; end
  def default_html?; end
  def default_xhtml; end
  def default_xhtml?; end
  def default_xml; end
  def default_xml?; end
  def format; end
  def format?; end
  def no_declaration; end
  def no_declaration?; end
  def no_empty_tags; end
  def no_empty_tags?; end
  def no_xhtml; end
  def no_xhtml?; end

  # Integer representation of the SaveOptions
  def options; end

  # Integer representation of the SaveOptions
  def to_i; end
end

# Save as HTML
Nokogiri::XML::Node::SaveOptions::AS_HTML = T.let(T.unsafe(nil), Integer)

# Save as XHTML
Nokogiri::XML::Node::SaveOptions::AS_XHTML = T.let(T.unsafe(nil), Integer)

# Save as XML
Nokogiri::XML::Node::SaveOptions::AS_XML = T.let(T.unsafe(nil), Integer)

# the default for HTML document
Nokogiri::XML::Node::SaveOptions::DEFAULT_HTML = T.let(T.unsafe(nil), Integer)

# the default for XHTML document
Nokogiri::XML::Node::SaveOptions::DEFAULT_XHTML = T.let(T.unsafe(nil), Integer)

# the default for XML documents
Nokogiri::XML::Node::SaveOptions::DEFAULT_XML = T.let(T.unsafe(nil), Integer)

# Format serialized xml
Nokogiri::XML::Node::SaveOptions::FORMAT = T.let(T.unsafe(nil), Integer)

# Do not include declarations
Nokogiri::XML::Node::SaveOptions::NO_DECLARATION = T.let(T.unsafe(nil), Integer)

# Do not include empty tags
Nokogiri::XML::Node::SaveOptions::NO_EMPTY_TAGS = T.let(T.unsafe(nil), Integer)

# Do not save XHTML
Nokogiri::XML::Node::SaveOptions::NO_XHTML = T.let(T.unsafe(nil), Integer)

# Text node type, see {Nokogiri::XML::Node#text?}
Nokogiri::XML::Node::TEXT_NODE = T.let(T.unsafe(nil), Integer)

# XInclude end type
Nokogiri::XML::Node::XINCLUDE_END = T.let(T.unsafe(nil), Integer)

# XInclude start type
Nokogiri::XML::Node::XINCLUDE_START = T.let(T.unsafe(nil), Integer)

# A NodeSet contains a list of Nokogiri::XML::Node objects.  Typically
# a NodeSet is return as a result of searching a Document via
# Nokogiri::XML::Searchable#css or Nokogiri::XML::Searchable#xpath
class Nokogiri::XML::NodeSet
  include ::Nokogiri::XML::Searchable
  include ::Enumerable

  # Create a NodeSet with +document+ defaulting to +list+
  #
  # @return [NodeSet] a new instance of NodeSet
  # @yield [_self]
  # @yieldparam _self [Nokogiri::XML::NodeSet] the object that the method was called on
  def initialize(document, list = T.unsafe(nil)); end

  # call-seq: search *paths, [namespace-bindings, xpath-variable-bindings, custom-handler-class]
  #
  # Search this object for +paths+, and return only the first
  # result. +paths+ must be one or more XPath or CSS queries.
  #
  # See Searchable#search for more information.
  #
  # Or, if passed an integer, index into the NodeSet:
  #
  #   node_set.at(3) # same as node_set[3]
  def %(*args); end

  def &(_arg0); end
  def +(_arg0); end
  def -(_arg0); end
  def <<(_arg0); end

  # Equality -- Two NodeSets are equal if the contain the same number
  # of elements and if each element is equal to the corresponding
  # element in the other NodeSet
  def ==(other); end

  # Search this NodeSet's nodes' immediate children using CSS selector +selector+
  def >(selector); end

  def [](*_arg0); end

  # Add the class attribute +name+ to all Node objects in the
  # NodeSet.
  #
  # See Nokogiri::XML::Node#add_class for more information.
  def add_class(name); end

  # Insert +datum+ after the last Node in this NodeSet
  def after(datum); end

  # Append the class attribute +name+ to all Node objects in the
  # NodeSet.
  #
  # See Nokogiri::XML::Node#append_class for more information.
  def append_class(name); end

  # call-seq: search *paths, [namespace-bindings, xpath-variable-bindings, custom-handler-class]
  #
  # Search this object for +paths+, and return only the first
  # result. +paths+ must be one or more XPath or CSS queries.
  #
  # See Searchable#search for more information.
  #
  # Or, if passed an integer, index into the NodeSet:
  #
  #   node_set.at(3) # same as node_set[3]
  def at(*args); end

  # Set attributes on each Node in the NodeSet, or get an
  # attribute from the first Node in the NodeSet.
  #
  # To get an attribute from the first Node in a NodeSet:
  #
  #   node_set.attr("href") # => "https://www.nokogiri.org"
  #
  # Note that an empty NodeSet will return nil when +#attr+ is called as a getter.
  #
  # To set an attribute on each node, +key+ can either be an
  # attribute name, or a Hash of attribute names and values. When
  # called as a setter, +#attr+ returns the NodeSet.
  #
  # If +key+ is an attribute name, then either +value+ or +block+
  # must be passed.
  #
  # If +key+ is a Hash then attributes will be set for each
  # key/value pair:
  #
  #   node_set.attr("href" => "https://www.nokogiri.org", "class" => "member")
  #
  # If +value+ is passed, it will be used as the attribute value
  # for all nodes:
  #
  #   node_set.attr("href", "https://www.nokogiri.org")
  #
  # If +block+ is passed, it will be called on each Node object in
  # the NodeSet and the return value used as the attribute value
  # for that node:
  #
  #   node_set.attr("class") { |node| node.name }
  def attr(key, value = T.unsafe(nil), &block); end

  # Set attributes on each Node in the NodeSet, or get an
  # attribute from the first Node in the NodeSet.
  #
  # To get an attribute from the first Node in a NodeSet:
  #
  #   node_set.attr("href") # => "https://www.nokogiri.org"
  #
  # Note that an empty NodeSet will return nil when +#attr+ is called as a getter.
  #
  # To set an attribute on each node, +key+ can either be an
  # attribute name, or a Hash of attribute names and values. When
  # called as a setter, +#attr+ returns the NodeSet.
  #
  # If +key+ is an attribute name, then either +value+ or +block+
  # must be passed.
  #
  # If +key+ is a Hash then attributes will be set for each
  # key/value pair:
  #
  #   node_set.attr("href" => "https://www.nokogiri.org", "class" => "member")
  #
  # If +value+ is passed, it will be used as the attribute value
  # for all nodes:
  #
  #   node_set.attr("href", "https://www.nokogiri.org")
  #
  # If +block+ is passed, it will be called on each Node object in
  # the NodeSet and the return value used as the attribute value
  # for that node:
  #
  #   node_set.attr("class") { |node| node.name }
  def attribute(key, value = T.unsafe(nil), &block); end

  # Insert +datum+ before the first Node in this NodeSet
  def before(datum); end

  # Returns a new NodeSet containing all the children of all the nodes in
  # the NodeSet
  def children; end

  def clone; end

  # call-seq: css *rules, [namespace-bindings, custom-pseudo-class]
  #
  # Search this node set for CSS +rules+. +rules+ must be one or more CSS
  # selectors. For example:
  #
  # For more information see Nokogiri::XML::Searchable#css
  def css(*args); end

  def delete(_arg0); end

  # The Document this NodeSet is associated with
  def document; end

  # The Document this NodeSet is associated with
  def document=(_arg0); end

  def dup; end

  # Iterate over each node, yielding  to +block+
  def each; end

  # Is this NodeSet empty?
  #
  # @return [Boolean]
  def empty?; end

  # Filter this list for nodes that match +expr+
  def filter(expr); end

  # Get the first element of the NodeSet.
  def first(n = T.unsafe(nil)); end

  def include?(_arg0); end

  # Returns the index of the first node in self that is == to +node+ or meets the given block. Returns nil if no match is found.
  def index(node = T.unsafe(nil)); end

  # Get the inner html of all contained Node objects
  def inner_html(*args); end

  # Get the inner text of all contained Node objects
  #
  # Note: This joins the text of all Node objects in the NodeSet:
  #
  #    doc = Nokogiri::XML('<xml><a><d>foo</d><d>bar</d></a></xml>')
  #    doc.css('d').text # => "foobar"
  #
  # Instead, if you want to return the text of all nodes in the NodeSet:
  #
  #    doc.css('d').map(&:text) # => ["foo", "bar"]
  #
  # See Nokogiri::XML::Node#content for more information.
  def inner_text; end

  # Return a nicely formated string representation
  def inspect; end

  # Get the last element of the NodeSet.
  def last; end

  def length; end

  # Removes the last element from set and returns it, or +nil+ if
  # the set is empty
  def pop; end

  def push(_arg0); end
  def remove; end

  # Remove the attributed named +name+ from all Node objects in the NodeSet
  def remove_attr(name); end

  # Remove the attributed named +name+ from all Node objects in the NodeSet
  def remove_attribute(name); end

  # Remove the class attribute +name+ from all Node objects in the
  # NodeSet.
  #
  # See Nokogiri::XML::Node#remove_class for more information.
  def remove_class(name = T.unsafe(nil)); end

  # Returns a new NodeSet containing all the nodes in the NodeSet
  # in reverse order
  def reverse; end

  # Set attributes on each Node in the NodeSet, or get an
  # attribute from the first Node in the NodeSet.
  #
  # To get an attribute from the first Node in a NodeSet:
  #
  #   node_set.attr("href") # => "https://www.nokogiri.org"
  #
  # Note that an empty NodeSet will return nil when +#attr+ is called as a getter.
  #
  # To set an attribute on each node, +key+ can either be an
  # attribute name, or a Hash of attribute names and values. When
  # called as a setter, +#attr+ returns the NodeSet.
  #
  # If +key+ is an attribute name, then either +value+ or +block+
  # must be passed.
  #
  # If +key+ is a Hash then attributes will be set for each
  # key/value pair:
  #
  #   node_set.attr("href" => "https://www.nokogiri.org", "class" => "member")
  #
  # If +value+ is passed, it will be used as the attribute value
  # for all nodes:
  #
  #   node_set.attr("href", "https://www.nokogiri.org")
  #
  # If +block+ is passed, it will be called on each Node object in
  # the NodeSet and the return value used as the attribute value
  # for that node:
  #
  #   node_set.attr("class") { |node| node.name }
  def set(key, value = T.unsafe(nil), &block); end

  # Returns the first element of the NodeSet and removes it.  Returns
  # +nil+ if the set is empty.
  def shift; end

  def size; end
  def slice(*_arg0); end

  # Get the inner text of all contained Node objects
  #
  # Note: This joins the text of all Node objects in the NodeSet:
  #
  #    doc = Nokogiri::XML('<xml><a><d>foo</d><d>bar</d></a></xml>')
  #    doc.css('d').text # => "foobar"
  #
  # Instead, if you want to return the text of all nodes in the NodeSet:
  #
  #    doc.css('d').map(&:text) # => ["foo", "bar"]
  #
  # See Nokogiri::XML::Node#content for more information.
  def text; end

  def to_a; end
  def to_ary; end

  # Convert this NodeSet to HTML
  def to_html(*args); end

  # Convert this NodeSet to a string.
  def to_s; end

  # Convert this NodeSet to XHTML
  def to_xhtml(*args); end

  # Convert this NodeSet to XML
  def to_xml(*args); end

  def unlink; end

  # Wrap this NodeSet with +html+
  def wrap(html); end

  # call-seq: xpath *paths, [namespace-bindings, variable-bindings, custom-handler-class]
  #
  # Search this node set for XPath +paths+. +paths+ must be one or more XPath
  # queries.
  #
  # For more information see Nokogiri::XML::Searchable#xpath
  def xpath(*args); end

  def |(_arg0); end
end

# @private
Nokogiri::XML::NodeSet::IMPLIED_XPATH_CONTEXTS = T.let(T.unsafe(nil), Array)

class Nokogiri::XML::Notation < ::Struct; end
module Nokogiri::XML::PP; end

module Nokogiri::XML::PP::CharacterData
  def inspect; end
  def pretty_print(pp); end
end

module Nokogiri::XML::PP::Node
  def inspect; end
  def pretty_print(pp); end
end

# Parse options for passing to Nokogiri.XML or Nokogiri.HTML
#
# == Building combinations of parse options
# You can build your own combinations of these parse options by using any of the following methods:
# *Note*: All examples attempt to set the +RECOVER+ & +NOENT+ options.
# [Ruby's bitwise operators] You can use the Ruby bitwise operators to set various combinations.
#   Nokogiri.XML('<content>Chapter 1</content', nil, nil, Nokogiri::XML::ParseOptions.new((1 << 0) | (1 << 1)))
# [Method chaining] Every option has an equivalent method in lowercase. You can chain these methods together to set various combinations.
#   Nokogiri.XML('<content>Chapter 1</content', nil, nil, Nokogiri::XML::ParseOptions.new.recover.noent)
# [Using Ruby Blocks] You can also setup parse combinations in the block passed to Nokogiri.XML or Nokogiri.HTML
#   Nokogiri.XML('<content>Chapter 1</content') {|config| config.recover.noent}
#
# == Removing particular parse options
# You can also remove options from an instance of +ParseOptions+ dynamically.
# Every option has an equivalent <code>no{option}</code> method in lowercase. You can call these methods on an instance of +ParseOptions+ to remove the option.
# Note that this is not available for +STRICT+.
#
#   # Setting the RECOVER & NOENT options...
#   options = Nokogiri::XML::ParseOptions.new.recover.noent
#   # later...
#   options.norecover # Removes the Nokogiri::XML::ParseOptions::RECOVER option
#   options.nonoent # Removes the Nokogiri::XML::ParseOptions::NOENT option
class Nokogiri::XML::ParseOptions
  # @return [ParseOptions] a new instance of ParseOptions
  def initialize(options = T.unsafe(nil)); end

  def ==(other); end
  def compact; end
  def compact?; end
  def default_html; end
  def default_html?; end
  def default_schema; end
  def default_schema?; end
  def default_xml; end
  def default_xml?; end
  def default_xslt; end
  def default_xslt?; end
  def dtdattr; end
  def dtdattr?; end
  def dtdload; end
  def dtdload?; end
  def dtdvalid; end
  def dtdvalid?; end
  def huge; end
  def huge?; end
  def inspect; end
  def nobasefix; end
  def nobasefix?; end
  def noblanks; end
  def noblanks?; end
  def nocdata; end
  def nocdata?; end
  def nocompact; end
  def nodefault_html; end
  def nodefault_schema; end
  def nodefault_xml; end
  def nodefault_xslt; end
  def nodict; end
  def nodict?; end
  def nodtdattr; end
  def nodtdload; end
  def nodtdvalid; end
  def noent; end
  def noent?; end
  def noerror; end
  def noerror?; end
  def nohuge; end
  def nonet; end
  def nonet?; end
  def nonobasefix; end
  def nonoblanks; end
  def nonocdata; end
  def nonodict; end
  def nonoent; end
  def nonoerror; end
  def nononet; end
  def nonowarning; end
  def nonoxincnode; end
  def nonsclean; end
  def noold10; end
  def nopedantic; end
  def norecover; end
  def nosax1; end
  def nowarning; end
  def nowarning?; end
  def noxinclude; end
  def noxincnode; end
  def noxincnode?; end
  def nsclean; end
  def nsclean?; end
  def old10; end
  def old10?; end

  # Returns the value of attribute options.
  def options; end

  # Sets the attribute options
  #
  # @param value the value to set the attribute options to.
  def options=(_arg0); end

  def pedantic; end
  def pedantic?; end
  def recover; end
  def recover?; end
  def sax1; end
  def sax1?; end
  def strict; end

  # @return [Boolean]
  def strict?; end

  # Returns the value of attribute options.
  def to_i; end

  def xinclude; end
  def xinclude?; end
end

# compact small text nodes; no modification of the tree allowed afterwards (will possibly crash if you try to modify the tree)
Nokogiri::XML::ParseOptions::COMPACT = T.let(T.unsafe(nil), Integer)

# the default options used for parsing HTML documents
Nokogiri::XML::ParseOptions::DEFAULT_HTML = T.let(T.unsafe(nil), Integer)

# the default options used for parsing XML schemas
Nokogiri::XML::ParseOptions::DEFAULT_SCHEMA = T.let(T.unsafe(nil), Integer)

# the default options used for parsing XML documents
Nokogiri::XML::ParseOptions::DEFAULT_XML = T.let(T.unsafe(nil), Integer)

# the default options used for parsing XSLT stylesheets
Nokogiri::XML::ParseOptions::DEFAULT_XSLT = T.let(T.unsafe(nil), Integer)

# Default DTD attributes
Nokogiri::XML::ParseOptions::DTDATTR = T.let(T.unsafe(nil), Integer)

# Load external subsets
Nokogiri::XML::ParseOptions::DTDLOAD = T.let(T.unsafe(nil), Integer)

# validate with the DTD
Nokogiri::XML::ParseOptions::DTDVALID = T.let(T.unsafe(nil), Integer)

# relax any hardcoded limit from the parser
Nokogiri::XML::ParseOptions::HUGE = T.let(T.unsafe(nil), Integer)

# do not fixup XINCLUDE xml:base uris
Nokogiri::XML::ParseOptions::NOBASEFIX = T.let(T.unsafe(nil), Integer)

# remove blank nodes
Nokogiri::XML::ParseOptions::NOBLANKS = T.let(T.unsafe(nil), Integer)

# merge CDATA as text nodes
Nokogiri::XML::ParseOptions::NOCDATA = T.let(T.unsafe(nil), Integer)

# Do not reuse the context dictionary
Nokogiri::XML::ParseOptions::NODICT = T.let(T.unsafe(nil), Integer)

# Substitute entities
Nokogiri::XML::ParseOptions::NOENT = T.let(T.unsafe(nil), Integer)

# suppress error reports
Nokogiri::XML::ParseOptions::NOERROR = T.let(T.unsafe(nil), Integer)

# Forbid network access. Recommended for dealing with untrusted documents.
Nokogiri::XML::ParseOptions::NONET = T.let(T.unsafe(nil), Integer)

# suppress warning reports
Nokogiri::XML::ParseOptions::NOWARNING = T.let(T.unsafe(nil), Integer)

# do not generate XINCLUDE START/END nodes
Nokogiri::XML::ParseOptions::NOXINCNODE = T.let(T.unsafe(nil), Integer)

# remove redundant namespaces declarations
Nokogiri::XML::ParseOptions::NSCLEAN = T.let(T.unsafe(nil), Integer)

# parse using XML-1.0 before update 5
Nokogiri::XML::ParseOptions::OLD10 = T.let(T.unsafe(nil), Integer)

# pedantic error reporting
Nokogiri::XML::ParseOptions::PEDANTIC = T.let(T.unsafe(nil), Integer)

# Recover from errors
Nokogiri::XML::ParseOptions::RECOVER = T.let(T.unsafe(nil), Integer)

# use the SAX1 interface internally
Nokogiri::XML::ParseOptions::SAX1 = T.let(T.unsafe(nil), Integer)

# Strict parsing
Nokogiri::XML::ParseOptions::STRICT = T.let(T.unsafe(nil), Integer)

# Implement XInclude substitution
Nokogiri::XML::ParseOptions::XINCLUDE = T.let(T.unsafe(nil), Integer)

class Nokogiri::XML::ProcessingInstruction < ::Nokogiri::XML::Node
  # @return [ProcessingInstruction] a new instance of ProcessingInstruction
  def initialize(document, name, content); end

  class << self
    def new(*_arg0); end
  end
end

# Nokogiri::XML::Reader parses an XML document similar to the way a cursor
# would move.  The Reader is given an XML document, and yields nodes
# to an each block.
#
# Here is an example of usage:
#
#   reader = Nokogiri::XML::Reader(<<-eoxml)
#     <x xmlns:tenderlove='http://tenderlovemaking.com/'>
#       <tenderlove:foo awesome='true'>snuggles!</tenderlove:foo>
#     </x>
#   eoxml
#
#   reader.each do |node|
#
#     # node is an instance of Nokogiri::XML::Reader
#     puts node.name
#
#   end
#
# Note that Nokogiri::XML::Reader#each can only be called once!!  Once
# the cursor moves through the entire document, you must parse the
# document again.  So make sure that you capture any information you
# need during the first iteration.
#
# The Reader parser is good for when you need the speed of a SAX parser,
# but do not want to write a Document handler.
class Nokogiri::XML::Reader
  include ::Enumerable

  # @return [Reader] a new instance of Reader
  def initialize(source, url = T.unsafe(nil), encoding = T.unsafe(nil)); end

  def attribute(_arg0); end
  def attribute_at(_arg0); end
  def attribute_count; end
  def attribute_nodes; end

  # Get the attributes of the current node as a Hash
  #
  # @return [Hash<String, String>] Attribute names and values
  def attributes; end

  def attributes?; end
  def base_uri; end
  def default?; end
  def depth; end

  # Move the cursor through the document yielding the cursor to the block
  def each; end

  def empty_element?; end

  # The encoding for the document
  def encoding; end

  # A list of errors encountered while parsing
  def errors; end

  # A list of errors encountered while parsing
  def errors=(_arg0); end

  def inner_xml; end
  def lang; end
  def local_name; end
  def name; end
  def namespace_uri; end
  def namespaces; end
  def node_type; end
  def outer_xml; end
  def prefix; end
  def read; end
  def self_closing?; end

  # The XML source
  def source; end

  def state; end
  def value; end
  def value?; end
  def xml_version; end

  class << self
    def from_io(*_arg0); end
    def from_memory(*_arg0); end
  end
end

# Attribute node type
Nokogiri::XML::Reader::TYPE_ATTRIBUTE = T.let(T.unsafe(nil), Integer)

# CDATA node type
Nokogiri::XML::Reader::TYPE_CDATA = T.let(T.unsafe(nil), Integer)

# Comment node type
Nokogiri::XML::Reader::TYPE_COMMENT = T.let(T.unsafe(nil), Integer)

# Document node type
Nokogiri::XML::Reader::TYPE_DOCUMENT = T.let(T.unsafe(nil), Integer)

# Document Fragment node type
Nokogiri::XML::Reader::TYPE_DOCUMENT_FRAGMENT = T.let(T.unsafe(nil), Integer)

# Document Type node type
Nokogiri::XML::Reader::TYPE_DOCUMENT_TYPE = T.let(T.unsafe(nil), Integer)

# Element node type
Nokogiri::XML::Reader::TYPE_ELEMENT = T.let(T.unsafe(nil), Integer)

# Element end node type
Nokogiri::XML::Reader::TYPE_END_ELEMENT = T.let(T.unsafe(nil), Integer)

# Entity end node type
Nokogiri::XML::Reader::TYPE_END_ENTITY = T.let(T.unsafe(nil), Integer)

# Entity node type
Nokogiri::XML::Reader::TYPE_ENTITY = T.let(T.unsafe(nil), Integer)

# Entity Reference node type
Nokogiri::XML::Reader::TYPE_ENTITY_REFERENCE = T.let(T.unsafe(nil), Integer)

Nokogiri::XML::Reader::TYPE_NONE = T.let(T.unsafe(nil), Integer)

# Notation node type
Nokogiri::XML::Reader::TYPE_NOTATION = T.let(T.unsafe(nil), Integer)

# PI node type
Nokogiri::XML::Reader::TYPE_PROCESSING_INSTRUCTION = T.let(T.unsafe(nil), Integer)

# Significant Whitespace node type
Nokogiri::XML::Reader::TYPE_SIGNIFICANT_WHITESPACE = T.let(T.unsafe(nil), Integer)

# Text node type
Nokogiri::XML::Reader::TYPE_TEXT = T.let(T.unsafe(nil), Integer)

# Whitespace node type
Nokogiri::XML::Reader::TYPE_WHITESPACE = T.let(T.unsafe(nil), Integer)

# XML Declaration node type
Nokogiri::XML::Reader::TYPE_XML_DECLARATION = T.let(T.unsafe(nil), Integer)

# Nokogiri::XML::RelaxNG is used for validating XML against a
# RelaxNG schema.
#
# == Synopsis
#
# Validate an XML document against a RelaxNG schema.  Loop over the errors
# that are returned and print them out:
#
#   schema  = Nokogiri::XML::RelaxNG(File.open(ADDRESS_SCHEMA_FILE))
#   doc     = Nokogiri::XML(File.open(ADDRESS_XML_FILE))
#
#   schema.validate(doc).each do |error|
#     puts error.message
#   end
#
# The list of errors are Nokogiri::XML::SyntaxError objects.
#
# NOTE: RelaxNG input is always treated as TRUSTED documents, meaning that they will cause the
# underlying parsing libraries to access network resources. This is counter to Nokogiri's
# "untrusted by default" security policy, but is a limitation of the underlying libraries.
class Nokogiri::XML::RelaxNG < ::Nokogiri::XML::Schema
  private

  def validate_document(_arg0); end

  class << self
    def from_document(*_arg0); end
    def read_memory(*_arg0); end
  end
end

# SAX Parsers are event driven parsers. Nokogiri provides two different event based parsers when
# dealing with XML. If you want to do SAX style parsing using HTML, check out
# Nokogiri::HTML4::SAX.
#
# The basic way a SAX style parser works is by creating a parser, telling the parser about the
# events we're interested in, then giving the parser some XML to process. The parser will notify
# you when it encounters events you said you would like to know about.
#
# To register for events, you simply subclass Nokogiri::XML::SAX::Document, and implement the
# methods for which you would like notification.
#
# For example, if I want to be notified when a document ends, and when an element starts, I
# would write a class like this:
#
#   class MyDocument < Nokogiri::XML::SAX::Document
#     def end_document
#       puts "the document has ended"
#     end
#
#     def start_element name, attributes = []
#       puts "#{name} started"
#     end
#   end
#
# Then I would instantiate a SAX parser with this document, and feed the parser some XML
#
#   # Create a new parser
#   parser = Nokogiri::XML::SAX::Parser.new(MyDocument.new)
#
#   # Feed the parser some XML
#   parser.parse(File.open(ARGV[0]))
#
# Now my document handler will be called when each node starts, and when then document ends. To
# see what kinds of events are available, take a look at Nokogiri::XML::SAX::Document.
#
# Two SAX parsers for XML are available, a parser that reads from a string or IO object as it
# feels necessary, and a parser that lets you spoon feed it XML. If you want to let Nokogiri
# deal with reading your XML, use the Nokogiri::XML::SAX::Parser. If you want to have fine grain
# control over the XML input, use the Nokogiri::XML::SAX::PushParser.
module Nokogiri::XML::SAX; end

# This class is used for registering types of events you are interested in handling. All of
# the methods on this class are available as possible events while parsing an XML document. To
# register for any particular event, just subclass this class and implement the methods you
# are interested in knowing about.
#
# To only be notified about start and end element events, write a class like this:
#
#   class MyDocument < Nokogiri::XML::SAX::Document
#     def start_element name, attrs = []
#       puts "#{name} started!"
#     end
#
#     def end_element name
#       puts "#{name} ended"
#     end
#   end
#
# You can use this event handler for any SAX style parser included with Nokogiri. See
# Nokogiri::XML::SAX, and Nokogiri::HTML4::SAX.
class Nokogiri::XML::SAX::Document
  # Called when cdata blocks are found
  # +string+ contains the cdata content
  def cdata_block(string); end

  # Characters read between a tag. This method might be called multiple
  # times given one contiguous string of characters.
  #
  # +string+ contains the character data
  def characters(string); end

  # Called when comments are encountered
  # +string+ contains the comment data
  def comment(string); end

  # Called when document ends parsing
  def end_document; end

  # Called at the end of an element
  # +name+ is the tag name
  def end_element(name); end

  # Called at the end of an element
  # +name+ is the element's name
  # +prefix+ is the namespace prefix associated with the element
  # +uri+ is the associated namespace URI
  def end_element_namespace(name, prefix = T.unsafe(nil), uri = T.unsafe(nil)); end

  # Called on document errors
  # +string+ contains the error
  def error(string); end

  # Called when processing instructions are found
  # +name+ is the target of the instruction
  # +content+ is the value of the instruction
  def processing_instruction(name, content); end

  # Called when document starts parsing
  def start_document; end

  # Called at the beginning of an element
  # * +name+ is the name of the tag
  # * +attrs+ are an assoc list of namespaces and attributes, e.g.:
  #     [ ["xmlns:foo", "http://sample.net"], ["size", "large"] ]
  def start_element(name, attrs = T.unsafe(nil)); end

  # Called at the beginning of an element
  # +name+ is the element name
  # +attrs+ is a list of attributes
  # +prefix+ is the namespace prefix for the element
  # +uri+ is the associated namespace URI
  # +ns+ is a hash of namespace prefix:urls associated with the element
  def start_element_namespace(name, attrs = T.unsafe(nil), prefix = T.unsafe(nil), uri = T.unsafe(nil), ns = T.unsafe(nil)); end

  # Called on document warnings
  # +string+ contains the warning
  def warning(string); end

  # Called when an XML declaration is parsed
  def xmldecl(version, encoding, standalone); end
end

# This parser is a SAX style parser that reads it's input as it
# deems necessary.  The parser takes a Nokogiri::XML::SAX::Document,
# an optional encoding, then given an XML input, sends messages to
# the Nokogiri::XML::SAX::Document.
#
# Here is an example of using this parser:
#
#   # Create a subclass of Nokogiri::XML::SAX::Document and implement
#   # the events we care about:
#   class MyDoc < Nokogiri::XML::SAX::Document
#     def start_element name, attrs = []
#       puts "starting: #{name}"
#     end
#
#     def end_element name
#       puts "ending: #{name}"
#     end
#   end
#
#   # Create our parser
#   parser = Nokogiri::XML::SAX::Parser.new(MyDoc.new)
#
#   # Send some XML to the parser
#   parser.parse(File.open(ARGV[0]))
#
# For more information about SAX parsers, see Nokogiri::XML::SAX.  Also
# see Nokogiri::XML::SAX::Document for the available events.
class Nokogiri::XML::SAX::Parser
  # Create a new Parser with +doc+ and +encoding+
  #
  # @return [Parser] a new instance of Parser
  def initialize(doc = T.unsafe(nil), encoding = T.unsafe(nil)); end

  # The Nokogiri::XML::SAX::Document where events will be sent.
  def document; end

  # The Nokogiri::XML::SAX::Document where events will be sent.
  def document=(_arg0); end

  # The encoding beings used for this document.
  def encoding; end

  # The encoding beings used for this document.
  def encoding=(_arg0); end

  # Parse given +thing+ which may be a string containing xml, or an
  # IO object.
  def parse(thing, &block); end

  # Parse a file with +filename+
  #
  # @raise [ArgumentError]
  # @yield [ctx]
  def parse_file(filename); end

  # Parse given +io+
  #
  # @yield [ctx]
  def parse_io(io, encoding = T.unsafe(nil)); end

  # @yield [ctx]
  def parse_memory(data); end

  private

  def check_encoding(encoding); end
end

class Nokogiri::XML::SAX::Parser::Attribute < ::Struct; end

# Encodinds this parser supports
Nokogiri::XML::SAX::Parser::ENCODINGS = T.let(T.unsafe(nil), Hash)

# Context for XML SAX parsers.  This class is usually not instantiated
# by the user.  Instead, you should be looking at
# Nokogiri::XML::SAX::Parser
class Nokogiri::XML::SAX::ParserContext
  def column; end
  def line; end
  def parse_with(_arg0); end
  def recovery; end
  def recovery=(_arg0); end
  def replace_entities; end
  def replace_entities=(_arg0); end

  class << self
    def file(_arg0); end
    def io(_arg0, _arg1); end
    def memory(_arg0); end
    def new(thing, encoding = T.unsafe(nil)); end
  end
end

# PushParser can parse a document that is fed to it manually.  It
# must be given a SAX::Document object which will be called with
# SAX events as the document is being parsed.
#
# Calling PushParser#<< writes XML to the parser, calling any SAX
# callbacks it can.
#
# PushParser#finish tells the parser that the document is finished
# and calls the end_document SAX method.
#
# Example:
#
#   parser = PushParser.new(Class.new(XML::SAX::Document) {
#     def start_document
#       puts "start document called"
#     end
#   }.new)
#   parser << "<div>hello<"
#   parser << "/div>"
#   parser.finish
class Nokogiri::XML::SAX::PushParser
  # Create a new PushParser with +doc+ as the SAX Document, providing
  # an optional +file_name+ and +encoding+
  #
  # @return [PushParser] a new instance of PushParser
  def initialize(doc = T.unsafe(nil), file_name = T.unsafe(nil), encoding = T.unsafe(nil)); end

  # Write a +chunk+ of XML to the PushParser.  Any callback methods
  # that can be called will be called immediately.
  def <<(chunk, last_chunk = T.unsafe(nil)); end

  # The Nokogiri::XML::SAX::Document on which the PushParser will be
  # operating
  def document; end

  # The Nokogiri::XML::SAX::Document on which the PushParser will be
  # operating
  def document=(_arg0); end

  # Finish the parsing.  This method is only necessary for
  # Nokogiri::XML::SAX::Document#end_document to be called.
  def finish; end

  def options; end
  def options=(_arg0); end
  def replace_entities; end
  def replace_entities=(_arg0); end

  # Write a +chunk+ of XML to the PushParser.  Any callback methods
  # that can be called will be called immediately.
  def write(chunk, last_chunk = T.unsafe(nil)); end

  private

  def initialize_native(_arg0, _arg1); end
  def native_write(_arg0, _arg1); end
end

# Nokogiri::XML::Schema is used for validating XML against a schema
# (usually from an xsd file).
#
# == Synopsis
#
# Validate an XML document against a Schema.  Loop over the errors that
# are returned and print them out:
#
#   xsd = Nokogiri::XML::Schema(File.read(PO_SCHEMA_FILE))
#   doc = Nokogiri::XML(File.read(PO_XML_FILE))
#
#   xsd.validate(doc).each do |error|
#     puts error.message
#   end
#
# The list of errors are Nokogiri::XML::SyntaxError objects.
#
# NOTE: As of v1.11.0, Schema treats inputs as UNTRUSTED by default, and so external entities
# are not resolved from the network (`http://` or `ftp://`). Previously, parsing treated
# documents as "trusted" by default which was counter to Nokogiri's "untrusted by default"
# security policy. If a document is trusted, then the caller may turn off the NONET option via
# the ParseOptions to re-enable external entity resolution over a network connection.
class Nokogiri::XML::Schema
  # Errors while parsing the schema file
  def errors; end

  # Errors while parsing the schema file
  def errors=(_arg0); end

  # The Nokogiri::XML::ParseOptions used to parse the schema
  def parse_options; end

  # The Nokogiri::XML::ParseOptions used to parse the schema
  def parse_options=(_arg0); end

  # Returns true if +thing+ is a valid Nokogiri::XML::Document or
  # file.
  #
  # @return [Boolean]
  def valid?(thing); end

  # Validate +thing+ against this schema.  +thing+ can be a
  # Nokogiri::XML::Document object, or a filename.  An Array of
  # Nokogiri::XML::SyntaxError objects found while validating the
  # +thing+ is returned.
  def validate(thing); end

  private

  def validate_document(_arg0); end
  def validate_file(_arg0); end

  class << self
    def from_document(*_arg0); end

    # Create a new Nokogiri::XML::Schema object using a +string_or_io+
    # object.
    def new(string_or_io, options = T.unsafe(nil)); end

    def read_memory(*_arg0); end
  end
end

# The Searchable module declares the interface used for searching your DOM.
#
#  It implements the public methods `search`, `css`, and `xpath`,
#  as well as allowing specific implementations to specialize some
#  of the important behaviors.
module Nokogiri::XML::Searchable
  # call-seq: search *paths, [namespace-bindings, xpath-variable-bindings, custom-handler-class]
  #
  # Search this object for +paths+, and return only the first
  # result. +paths+ must be one or more XPath or CSS queries.
  #
  # See Searchable#search for more information.
  def %(*args); end

  # call-seq: search *paths, [namespace-bindings, xpath-variable-bindings, custom-handler-class]
  #
  # Search this object for +paths+. +paths+ must be one or more XPath or CSS queries:
  #
  #   node.search("div.employee", ".//title")
  #
  # A hash of namespace bindings may be appended:
  #
  #   node.search('.//bike:tire', {'bike' => 'http://schwinn.com/'})
  #   node.search('bike|tire', {'bike' => 'http://schwinn.com/'})
  #
  # For XPath queries, a hash of variable bindings may also be
  # appended to the namespace bindings. For example:
  #
  #   node.search('.//address[@domestic=$value]', nil, {:value => 'Yes'})
  #
  # Custom XPath functions and CSS pseudo-selectors may also be
  # defined. To define custom functions create a class and
  # implement the function you want to define.  The first argument
  # to the method will be the current matching NodeSet.  Any other
  # arguments are ones that you pass in.  Note that this class may
  # appear anywhere in the argument list.  For example:
  #
  #   node.search('.//title[regex(., "\w+")]', 'div.employee:regex("[0-9]+")'
  #     Class.new {
  #       def regex node_set, regex
  #         node_set.find_all { |node| node['some_attribute'] =~ /#{regex}/ }
  #       end
  #     }.new
  #   )
  #
  # See Searchable#xpath and Searchable#css for further usage help.
  def /(*args); end

  # call-seq: search *paths, [namespace-bindings, xpath-variable-bindings, custom-handler-class]
  #
  # Search this object for +paths+, and return only the first
  # result. +paths+ must be one or more XPath or CSS queries.
  #
  # See Searchable#search for more information.
  def at(*args); end

  # call-seq: css *rules, [namespace-bindings, custom-pseudo-class]
  #
  # Search this object for CSS +rules+, and return only the first
  # match. +rules+ must be one or more CSS selectors.
  #
  # See Searchable#css for more information.
  def at_css(*args); end

  # call-seq: xpath *paths, [namespace-bindings, variable-bindings, custom-handler-class]
  #
  # Search this node for XPath +paths+, and return only the first
  # match. +paths+ must be one or more XPath queries.
  #
  # See Searchable#xpath for more information.
  def at_xpath(*args); end

  # call-seq: css *rules, [namespace-bindings, custom-pseudo-class]
  #
  # Search this object for CSS +rules+. +rules+ must be one or more CSS
  # selectors. For example:
  #
  #   node.css('title')
  #   node.css('body h1.bold')
  #   node.css('div + p.green', 'div#one')
  #
  # A hash of namespace bindings may be appended. For example:
  #
  #   node.css('bike|tire', {'bike' => 'http://schwinn.com/'})
  #
  # Custom CSS pseudo classes may also be defined.  To define
  # custom pseudo classes, create a class and implement the custom
  # pseudo class you want defined.  The first argument to the
  # method will be the current matching NodeSet.  Any other
  # arguments are ones that you pass in.  For example:
  #
  #   node.css('title:regex("\w+")', Class.new {
  #     def regex node_set, regex
  #       node_set.find_all { |node| node['some_attribute'] =~ /#{regex}/ }
  #     end
  #   }.new)
  #
  # Note that the CSS query string is case-sensitive with regards
  # to your document type. That is, if you're looking for "H1" in
  # an HTML document, you'll never find anything, since HTML tags
  # will match only lowercase CSS queries. However, "H1" might be
  # found in an XML document, where tags names are case-sensitive
  # (e.g., "H1" is distinct from "h1").
  def css(*args); end

  # call-seq: search *paths, [namespace-bindings, xpath-variable-bindings, custom-handler-class]
  #
  # Search this object for +paths+. +paths+ must be one or more XPath or CSS queries:
  #
  #   node.search("div.employee", ".//title")
  #
  # A hash of namespace bindings may be appended:
  #
  #   node.search('.//bike:tire', {'bike' => 'http://schwinn.com/'})
  #   node.search('bike|tire', {'bike' => 'http://schwinn.com/'})
  #
  # For XPath queries, a hash of variable bindings may also be
  # appended to the namespace bindings. For example:
  #
  #   node.search('.//address[@domestic=$value]', nil, {:value => 'Yes'})
  #
  # Custom XPath functions and CSS pseudo-selectors may also be
  # defined. To define custom functions create a class and
  # implement the function you want to define.  The first argument
  # to the method will be the current matching NodeSet.  Any other
  # arguments are ones that you pass in.  Note that this class may
  # appear anywhere in the argument list.  For example:
  #
  #   node.search('.//title[regex(., "\w+")]', 'div.employee:regex("[0-9]+")'
  #     Class.new {
  #       def regex node_set, regex
  #         node_set.find_all { |node| node['some_attribute'] =~ /#{regex}/ }
  #       end
  #     }.new
  #   )
  #
  # See Searchable#xpath and Searchable#css for further usage help.
  def search(*args); end

  # call-seq: xpath *paths, [namespace-bindings, variable-bindings, custom-handler-class]
  #
  # Search this node for XPath +paths+. +paths+ must be one or more XPath
  # queries.
  #
  #   node.xpath('.//title')
  #
  # A hash of namespace bindings may be appended. For example:
  #
  #   node.xpath('.//foo:name', {'foo' => 'http://example.org/'})
  #   node.xpath('.//xmlns:name', node.root.namespaces)
  #
  # A hash of variable bindings may also be appended to the namespace bindings. For example:
  #
  #   node.xpath('.//address[@domestic=$value]', nil, {:value => 'Yes'})
  #
  # Custom XPath functions may also be defined.  To define custom
  # functions create a class and implement the function you want
  # to define.  The first argument to the method will be the
  # current matching NodeSet.  Any other arguments are ones that
  # you pass in.  Note that this class may appear anywhere in the
  # argument list.  For example:
  #
  #   node.xpath('.//title[regex(., "\w+")]', Class.new {
  #     def regex node_set, regex
  #       node_set.find_all { |node| node['some_attribute'] =~ /#{regex}/ }
  #     end
  #   }.new)
  def xpath(*args); end

  private

  def css_internal(node, rules, handler, ns); end
  def css_rules_to_xpath(rules, ns); end
  def extract_params(params); end
  def xpath_impl(node, path, handler, ns, binds); end
  def xpath_internal(node, paths, handler, ns, binds); end
  def xpath_query_from_css_rule(rule, ns); end
end

# Regular expression used by Searchable#search to determine if a query
# string is CSS or XPath
Nokogiri::XML::Searchable::LOOKS_LIKE_XPATH = T.let(T.unsafe(nil), Regexp)

# This class provides information about XML SyntaxErrors.  These
# exceptions are typically stored on Nokogiri::XML::Document#errors.
class Nokogiri::XML::SyntaxError < ::Nokogiri::SyntaxError
  # Returns the value of attribute code.
  def code; end

  # Returns the value of attribute column.
  def column; end

  # Returns the value of attribute domain.
  def domain; end

  # return true if this is an error
  #
  # @return [Boolean]
  def error?; end

  # return true if this error is fatal
  #
  # @return [Boolean]
  def fatal?; end

  # Returns the value of attribute file.
  def file; end

  # Returns the value of attribute int1.
  def int1; end

  # Returns the value of attribute level.
  def level; end

  # Returns the value of attribute line.
  def line; end

  # return true if this is a non error
  #
  # @return [Boolean]
  def none?; end

  # Returns the value of attribute str1.
  def str1; end

  # Returns the value of attribute str2.
  def str2; end

  # Returns the value of attribute str3.
  def str3; end

  def to_s; end

  # return true if this is a warning
  #
  # @return [Boolean]
  def warning?; end

  private

  def level_to_s; end
  def location_to_s; end

  # @return [Boolean]
  def nil_or_zero?(attribute); end
end

class Nokogiri::XML::Text < ::Nokogiri::XML::CharacterData
  def content=(string); end

  class << self
    def new(*_arg0); end
  end
end

# Original C14N 1.0 spec canonicalization
Nokogiri::XML::XML_C14N_1_0 = T.let(T.unsafe(nil), Integer)

# C14N 1.1 spec canonicalization
Nokogiri::XML::XML_C14N_1_1 = T.let(T.unsafe(nil), Integer)

# Exclusive C14N 1.0 spec canonicalization
Nokogiri::XML::XML_C14N_EXCLUSIVE_1_0 = T.let(T.unsafe(nil), Integer)

module Nokogiri::XML::XPath; end

class Nokogiri::XML::XPath::SyntaxError < ::Nokogiri::XML::SyntaxError
  def to_s; end
end

class Nokogiri::XML::XPathContext
  def evaluate(*_arg0); end

  # Register namespaces in +namespaces+
  def register_namespaces(namespaces); end

  def register_ns(_arg0, _arg1); end
  def register_variable(_arg0, _arg1); end

  class << self
    def new(_arg0); end
  end
end

# See Nokogiri::XSLT::Stylesheet for creating and manipulating
# Stylesheet object.
module Nokogiri::XSLT
  class << self
    # Parse the stylesheet in +string+, register any +modules+
    def parse(string, modules = T.unsafe(nil)); end

    # Quote parameters in +params+ for stylesheet safety
    def quote_params(params); end

    def register(_arg0, _arg1); end
  end
end

# A Stylesheet represents an XSLT Stylesheet object.  Stylesheet creation
# is done through Nokogiri.XSLT.  Here is an example of transforming
# an XML::Document with a Stylesheet:
#
#   doc   = Nokogiri::XML(File.read('some_file.xml'))
#   xslt  = Nokogiri::XSLT(File.read('some_transformer.xslt'))
#
#   puts xslt.transform(doc)
#
# See Nokogiri::XSLT::Stylesheet#transform for more transformation
# information.
class Nokogiri::XSLT::Stylesheet
  # Apply an XSLT stylesheet to an XML::Document.
  # +params+ is an array of strings used as XSLT parameters.
  # returns serialized document
  def apply_to(document, params = T.unsafe(nil)); end

  def serialize(_arg0); end
  def transform(*_arg0); end

  class << self
    def parse_stylesheet_doc(_arg0); end
  end
end
