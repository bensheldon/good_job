# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `async-io` gem.
# Please instead update this file by running `bin/tapioca gem async-io`.

# source://async-io//lib/async/io/address.rb#25
module Async; end

# source://async-io//lib/async/io/address.rb#26
module Async::IO
  class << self
    # source://async-io//lib/async/io/generic.rb#43
    def pipe; end

    # Convert a Ruby ::IO object to a wrapped instance:
    #
    # source://async-io//lib/async/io/generic.rb#35
    def try_convert(io, &block); end
  end
end

# source://async-io//lib/async/io/address.rb#27
Async::IO::Address = Addrinfo

# This class will open and close the socket automatically.
#
# source://async-io//lib/async/io/address_endpoint.rb#28
class Async::IO::AddressEndpoint < ::Async::IO::Endpoint
  # @return [AddressEndpoint] a new instance of AddressEndpoint
  #
  # source://async-io//lib/async/io/address_endpoint.rb#29
  def initialize(address, **options); end

  # Returns the value of attribute address.
  #
  # source://async-io//lib/async/io/address_endpoint.rb#39
  def address; end

  # Bind a socket to the given address. If a block is given, the socket will be automatically closed when the block exits.
  #
  # @return [Socket] the bound socket
  # @yield [Socket] the bound socket
  #
  # source://async-io//lib/async/io/address_endpoint.rb#44
  def bind(&block); end

  # Connects a socket to the given address. If a block is given, the socket will be automatically closed when the block exits.
  #
  # @return [Socket] the connected socket
  #
  # source://async-io//lib/async/io/address_endpoint.rb#50
  def connect(&block); end

  # source://async-io//lib/async/io/address_endpoint.rb#35
  def to_s; end
end

# The default block size for IO buffers. Defaults to 64KB (typical pipe buffer size).
#
# source://async-io//lib/async/io/generic.rb#29
Async::IO::BLOCK_SIZE = T.let(T.unsafe(nil), Integer)

# source://async-io//lib/async/io/socket.rb#32
class Async::IO::BasicSocket < ::Async::IO::Generic
  include ::Socket::Constants
  include ::Async::IO::Peer

  # source://forwardable/1.3.3/forwardable.rb#231
  def close_read(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def close_write(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def connect_address(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def do_not_reverse_lookup(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def do_not_reverse_lookup=(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def getpeereid(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def getpeername(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def getsockname(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def getsockopt(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def local_address(*args, **_arg1, &block); end

  # Invokes `recv_nonblock` on the underlying {io}. If the operation would block, the current task is paused until the operation can succeed, at which point it's resumed and the operation is completed.
  #
  # source://async-io//lib/async/io/generic.rb#61
  def recv(*args); end

  # source://async-io//lib/async/io/generic.rb#68
  def recv_nonblock(*args, exception: T.unsafe(nil)); end

  # Invokes `recvmsg_nonblock` on the underlying {io}. If the operation would block, the current task is paused until the operation can succeed, at which point it's resumed and the operation is completed.
  #
  # source://async-io//lib/async/io/generic.rb#61
  def recvmsg(*args); end

  # source://async-io//lib/async/io/generic.rb#68
  def recvmsg_nonblock(*args, exception: T.unsafe(nil)); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def remote_address(*args, **_arg1, &block); end

  # Invokes `sendmsg_nonblock` on the underlying {io}. If the operation would block, the current task is paused until the operation can succeed, at which point it's resumed and the operation is completed.
  #
  # source://async-io//lib/async/io/generic.rb#61
  def send(*args); end

  # Invokes `sendmsg_nonblock` on the underlying {io}. If the operation would block, the current task is paused until the operation can succeed, at which point it's resumed and the operation is completed.
  #
  # source://async-io//lib/async/io/generic.rb#61
  def sendmsg(*args); end

  # source://async-io//lib/async/io/generic.rb#68
  def sendmsg_nonblock(*args, exception: T.unsafe(nil)); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def setsockopt(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def shutdown(*args, **_arg1, &block); end
end

# source://async-io//lib/async/io/buffer.rb#25
class Async::IO::Buffer < ::String
  # @return [Buffer] a new instance of Buffer
  #
  # source://async-io//lib/async/io/buffer.rb#28
  def initialize; end

  # source://async-io//lib/async/io/buffer.rb#34
  def <<(string); end

  # source://async-io//lib/async/io/buffer.rb#34
  def concat(string); end
end

# source://async-io//lib/async/io/buffer.rb#26
Async::IO::Buffer::BINARY = T.let(T.unsafe(nil), Encoding)

# Endpoints represent a way of connecting or binding to an address.
#
# source://async-io//lib/async/io/endpoint.rb#31
class Async::IO::Endpoint
  # @return [Endpoint] a new instance of Endpoint
  #
  # source://async-io//lib/async/io/endpoint.rb#32
  def initialize(**options); end

  # Accept connections from the specified endpoint.
  #
  # @param backlog [Integer] the number of connections to listen for.
  #
  # source://async-io//lib/async/io/endpoint.rb#89
  def accept(backlog = T.unsafe(nil), &block); end

  # Map all endpoints by invoking `#bind`.
  #
  # @yield the bound wrapper.
  #
  # source://async-io//lib/async/io/endpoint.rb#99
  def bound; end

  # Endpoints sometimes have multiple paths.
  #
  # @yield [Endpoint] Enumerate all discrete paths as endpoints.
  #
  # source://async-io//lib/async/io/endpoint.rb#81
  def each; end

  # @return [String] The hostname of the bound socket.
  #
  # source://async-io//lib/async/io/endpoint.rb#47
  def hostname; end

  # Controls SO_LINGER. The amount of time the socket will stay in the `TIME_WAIT` state after being closed.
  #
  # @return [Integer, nil] The value for SO_LINGER.
  #
  # source://async-io//lib/async/io/endpoint.rb#65
  def linger; end

  # @return [Address] the address to bind to before connecting.
  #
  # source://async-io//lib/async/io/endpoint.rb#75
  def local_address; end

  # Returns the value of attribute options.
  #
  # source://async-io//lib/async/io/endpoint.rb#44
  def options; end

  # Sets the attribute options
  #
  # @param value the value to set the attribute options to.
  #
  # source://async-io//lib/async/io/endpoint.rb#44
  def options=(_arg0); end

  # If `SO_REUSEADDR` is enabled on a socket prior to binding it, the socket can be successfully bound unless there is a conflict with another socket bound to exactly the same combination of source address and port. Additionally, when set, binding a socket to the address of an existing socket in `TIME_WAIT` is not an error.
  #
  # @return [Boolean] The value for `SO_REUSEADDR`.
  #
  # source://async-io//lib/async/io/endpoint.rb#59
  def reuse_address; end

  # If `SO_REUSEPORT` is enabled on a socket, the socket can be successfully bound even if there are existing sockets bound to the same address, as long as all prior bound sockets also had `SO_REUSEPORT` set before they were bound.
  #
  # @return [Boolean, nil] The value for `SO_REUSEPORT`.
  #
  # source://async-io//lib/async/io/endpoint.rb#53
  def reuse_port; end

  # @return [Numeric] The default timeout for socket operations.
  #
  # source://async-io//lib/async/io/endpoint.rb#70
  def timeout; end

  # source://async-io//lib/async/io/endpoint.rb#36
  def with(**options); end

  class << self
    # Create an Endpoint instance by URI scheme. The host and port of the URI will be passed to the Endpoint factory method, along with any options.
    #
    # @param string [String] URI as string. Scheme will decide implementation used.
    # @param options keyword arguments passed through to {#initialize}
    # @see Endpoint.ssl ssl - invoked when parsing a URL with the ssl scheme "ssl://127.0.0.1"
    # @see Endpoint.tcp tcp - invoked when parsing a URL with the tcp scheme: "tcp://127.0.0.1"
    # @see Endpoint.udp udp - invoked when parsing a URL with the udp scheme: "udp://127.0.0.1"
    # @see Endpoint.unix unix - invoked when parsing a URL with the unix scheme: "unix://127.0.0.1"
    #
    # source://async-io//lib/async/io/endpoint.rb#123
    def parse(string, **options); end

    # @param args
    # @param ssl_context [OpenSSL::SSL::SSLContext, nil]
    # @param hostname [String, nil]
    # @param options keyword arguments passed through to {Endpoint.tcp}
    # @return [SSLEndpoint]
    #
    # source://async-io//lib/async/io/ssl_endpoint.rb#114
    def ssl(*args, ssl_context: T.unsafe(nil), hostname: T.unsafe(nil), **options); end

    # @param args nodename, service, family, socktype, protocol, flags. `socktype` will be set to Socket::SOCK_STREAM.
    # @param options keyword arguments passed on to {HostEndpoint#initialize}
    # @return [HostEndpoint]
    #
    # source://async-io//lib/async/io/host_endpoint.rb#100
    def tcp(*args, **options); end

    # @param args nodename, service, family, socktype, protocol, flags. `socktype` will be set to Socket::SOCK_DGRAM.
    # @param options keyword arguments passed on to {HostEndpoint#initialize}
    # @return [HostEndpoint]
    #
    # source://async-io//lib/async/io/host_endpoint.rb#110
    def udp(*args, **options); end
  end
end

# Represents an asynchronous IO within a reactor.
#
# source://async-io//lib/async/io/generic.rb#48
class Async::IO::Generic < ::Async::Wrapper
  extend ::Forwardable

  # source://async-io//lib/async/io/generic.rb#170
  def <<(buffer); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def advise(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def autoclose=(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def autoclose?(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def binmode(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def binmode?(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def close_on_exec=(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def close_on_exec?(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def close_read(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def close_write(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def closed?(*args, **_arg1, &block); end

  # @return [Boolean]
  #
  # source://async-io//lib/async/io/generic.rb#206
  def connected?; end

  # source://async-io//lib/async/io/generic.rb#175
  def dup; end

  # source://forwardable/1.3.3/forwardable.rb#231
  def eof(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def eof?(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def external_encoding(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def fcntl(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def fdatasync(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def fileno(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def flush(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def fsync(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def internal_encoding(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def ioctl(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def isatty(*args, **_arg1, &block); end

  # source://async-io//lib/async/io/generic.rb#194
  def nonblock; end

  # source://async-io//lib/async/io/generic.rb#198
  def nonblock=(value); end

  # @return [Boolean]
  #
  # source://async-io//lib/async/io/generic.rb#202
  def nonblock?; end

  # source://forwardable/1.3.3/forwardable.rb#231
  def nread(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def path(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def pathconf(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def pid(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def pos(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def pos=(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def pread(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def pwrite(*args, **_arg1, &block); end

  # Read `length` bytes of data from the underlying I/O. If length is unspecified, read everything.
  #
  # source://async-io//lib/async/io/generic.rb#111
  def read(length = T.unsafe(nil), buffer = T.unsafe(nil)); end

  # source://async-io//lib/async/io/generic.rb#68
  def read_nonblock(*args, exception: T.unsafe(nil)); end

  # source://async-io//lib/async/io/generic.rb#68
  def readpartial(*args, exception: T.unsafe(nil)); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def ready?(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def reopen(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def rewind(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def seek(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def set_encoding(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def set_encoding_by_bom(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def stat(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def sync(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def sync=(*args, **_arg1, &block); end

  # Read the specified number of bytes from the input stream. This is fast path.
  # Invokes `read_nonblock` on the underlying {io}. If the operation would block, the current task is paused until the operation can succeed, at which point it's resumed and the operation is completed.
  #
  # @example
  #   data = io.sysread(512)
  #
  # source://async-io//lib/async/io/generic.rb#61
  def sysread(*args); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def sysseek(*args, **_arg1, &block); end

  # Write entire buffer to output stream. This is fast path.
  # Invokes `write_nonblock` on the underlying {io}. If the operation would block, the current task is paused until the operation can succeed, at which point it's resumed and the operation is completed.
  #
  # @example
  #   io.syswrite("Hello World")
  #
  # source://async-io//lib/async/io/generic.rb#61
  def syswrite(*args); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def tell(*args, **_arg1, &block); end

  # Returns the value of attribute timeout.
  #
  # source://async-io//lib/async/io/generic.rb#210
  def timeout; end

  # Sets the attribute timeout
  #
  # @param value the value to set the attribute timeout to.
  #
  # source://async-io//lib/async/io/generic.rb#210
  def timeout=(_arg0); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def to_i(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def to_io(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def to_path(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def tty?(*args, **_arg1, &block); end

  # source://async-io//lib/async/io/generic.rb#181
  def wait(timeout = T.unsafe(nil), mode = T.unsafe(nil)); end

  # source://async-io//lib/async/io/generic.rb#154
  def write(buffer); end

  # source://async-io//lib/async/io/generic.rb#68
  def write_nonblock(*args, exception: T.unsafe(nil)); end

  protected

  # source://async-io//lib/async/io/generic.rb#214
  def async_send(*arguments, timeout: T.unsafe(nil)); end

  class << self
    # Instantiate a wrapped instance of the class, and optionally yield it to a given block, closing it afterwards.
    #
    # source://async-io//lib/async/io/generic.rb#88
    def wrap(*args); end

    # source://async-io//lib/async/io/generic.rb#57
    def wrap_blocking_method(new_name, method_name, invert: T.unsafe(nil), &block); end

    # Returns the value of attribute wrapped_klass.
    #
    # source://async-io//lib/async/io/generic.rb#74
    def wrapped_klass; end

    # source://async-io//lib/async/io/generic.rb#76
    def wraps(klass, *additional_methods); end
  end
end

# source://async-io//lib/async/io/generic.rb#51
Async::IO::Generic::WRAPPERS = T.let(T.unsafe(nil), Hash)

# source://async-io//lib/async/io/host_endpoint.rb#27
class Async::IO::HostEndpoint < ::Async::IO::Endpoint
  # @return [HostEndpoint] a new instance of HostEndpoint
  #
  # source://async-io//lib/async/io/host_endpoint.rb#28
  def initialize(specification, **options); end

  # source://async-io//lib/async/io/host_endpoint.rb#40
  def address; end

  # Invokes the given block for every address which can be bound to.
  #
  # @return [Array<Socket>] an array of bound sockets
  # @yield [Socket] the bound socket
  #
  # source://async-io//lib/async/io/host_endpoint.rb#79
  def bind(&block); end

  # Try to connect to the given host by connecting to each address in sequence until a connection is made.
  #
  # @raise if no connection could complete successfully
  # @return [Socket] the connected socket
  # @yield [Socket] the socket which is being connected, may be invoked more than once
  #
  # source://async-io//lib/async/io/host_endpoint.rb#52
  def connect; end

  # @yield [AddressEndpoint] address endpoints by resolving the given host specification
  #
  # source://async-io//lib/async/io/host_endpoint.rb#86
  def each; end

  # source://async-io//lib/async/io/host_endpoint.rb#44
  def hostname; end

  # source://async-io//lib/async/io/host_endpoint.rb#34
  def to_s; end
end

# source://async-io//lib/async/io/socket.rb#192
class Async::IO::IPSocket < ::Async::IO::BasicSocket
  # source://forwardable/1.3.3/forwardable.rb#231
  def addr(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def peeraddr(*args, **_arg1, &block); end

  # Invokes `recvfrom_nonblock` on the underlying {io}. If the operation would block, the current task is paused until the operation can succeed, at which point it's resumed and the operation is completed.
  #
  # source://async-io//lib/async/io/generic.rb#61
  def recvfrom(*args); end

  # source://async-io//lib/async/io/generic.rb#68
  def recvfrom_nonblock(*args, exception: T.unsafe(nil)); end
end

# The maximum read size when appending to IO buffers. Defaults to 8MB.
#
# source://async-io//lib/async/io/generic.rb#32
Async::IO::MAXIMUM_READ_SIZE = T.let(T.unsafe(nil), Integer)

# source://async-io//lib/async/io/peer.rb#27
module Async::IO::Peer
  include ::Socket::Constants

  # Is it likely that the socket is still connected?
  # May return false positive, but won't return false negative.
  #
  # @return [Boolean]
  #
  # source://async-io//lib/async/io/peer.rb#32
  def connected?; end

  # source://async-io//lib/async/io/peer.rb#46
  def eof; end

  # @return [Boolean]
  #
  # source://async-io//lib/async/io/peer.rb#50
  def eof?; end

  # source://async-io//lib/async/io/peer.rb#84
  def protocol; end

  # source://async-io//lib/async/io/peer.rb#71
  def sync; end

  # Best effort to set *_NODELAY if it makes sense. Swallows errors where possible.
  #
  # source://async-io//lib/async/io/peer.rb#55
  def sync=(value); end

  # source://async-io//lib/async/io/peer.rb#80
  def type; end
end

# source://async-io//lib/async/io/ssl_endpoint.rb#28
class Async::IO::SSLEndpoint < ::Async::IO::Endpoint
  # @return [SSLEndpoint] a new instance of SSLEndpoint
  #
  # source://async-io//lib/async/io/ssl_endpoint.rb#29
  def initialize(endpoint, **options); end

  # source://async-io//lib/async/io/ssl_endpoint.rb#45
  def address; end

  # Connect to the underlying endpoint and establish a SSL connection.
  #
  # @return [Socket] the connected socket
  # @yield [Socket] the socket which is being connected
  #
  # source://async-io//lib/async/io/ssl_endpoint.rb#78
  def bind; end

  # source://async-io//lib/async/io/ssl_endpoint.rb#60
  def build_context(context = T.unsafe(nil)); end

  # Connect to the underlying endpoint and establish a SSL connection.
  #
  # @return [Socket] the connected socket
  # @yield [Socket] the socket which is being connected
  #
  # source://async-io//lib/async/io/ssl_endpoint.rb#91
  def connect(&block); end

  # source://async-io//lib/async/io/ssl_endpoint.rb#71
  def context; end

  # source://async-io//lib/async/io/ssl_endpoint.rb#95
  def each; end

  # Returns the value of attribute endpoint.
  #
  # source://async-io//lib/async/io/ssl_endpoint.rb#53
  def endpoint; end

  # source://async-io//lib/async/io/ssl_endpoint.rb#49
  def hostname; end

  # Returns the value of attribute options.
  #
  # source://async-io//lib/async/io/ssl_endpoint.rb#54
  def options; end

  # source://async-io//lib/async/io/ssl_endpoint.rb#56
  def params; end

  # source://async-io//lib/async/io/ssl_endpoint.rb#41
  def to_s; end
end

# source://async-io//lib/async/io/ssl_socket.rb#29
Async::IO::SSLError = OpenSSL::SSL::SSLError

# We reimplement this from scratch because the native implementation doesn't expose the underlying server/context that we need to implement non-blocking accept.
#
# source://async-io//lib/async/io/ssl_socket.rb#107
class Async::IO::SSLServer
  include ::Async::IO::Server
  extend ::Forwardable

  # @return [SSLServer] a new instance of SSLServer
  #
  # source://async-io//lib/async/io/ssl_socket.rb#110
  def initialize(server, context); end

  # source://async-io//lib/async/io/ssl_socket.rb#132
  def accept(task: T.unsafe(nil), **options); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def close(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def close_on_exec=(*args, **_arg1, &block); end

  # Returns the value of attribute context.
  #
  # source://async-io//lib/async/io/ssl_socket.rb#126
  def context; end

  # source://async-io//lib/async/io/ssl_socket.rb#119
  def dup; end

  # source://async-io//lib/async/io/ssl_socket.rb#115
  def fileno; end

  # source://forwardable/1.3.3/forwardable.rb#231
  def getsockopt(*args, **_arg1, &block); end

  # source://async-io//lib/async/io/ssl_socket.rb#128
  def listen(*args); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def local_address(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def reactor=(*args, **_arg1, &block); end

  # Returns the value of attribute server.
  #
  # source://async-io//lib/async/io/ssl_socket.rb#125
  def server; end

  # source://forwardable/1.3.3/forwardable.rb#231
  def setsockopt(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def timeout(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def timeout=(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def to_io(*args, **_arg1, &block); end
end

# Asynchronous TCP socket wrapper.
#
# source://async-io//lib/async/io/ssl_socket.rb#32
class Async::IO::SSLSocket < ::Async::IO::Generic
  include ::Socket::Constants
  include ::Async::IO::Peer

  # @return [SSLSocket] a new instance of SSLSocket
  #
  # source://async-io//lib/async/io/ssl_socket.rb#66
  def initialize(socket, context); end

  # Invokes `accept_nonblock` on the underlying {io}. If the operation would block, the current task is paused until the operation can succeed, at which point it's resumed and the operation is completed.
  #
  # source://async-io//lib/async/io/generic.rb#61
  def accept(*args); end

  # source://async-io//lib/async/io/generic.rb#68
  def accept_nonblock(*args, exception: T.unsafe(nil)); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def alpn_protocol(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def cert(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def cipher(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def client_ca(*args, **_arg1, &block); end

  # source://async-io//lib/async/io/ssl_socket.rb#96
  def close_read; end

  # source://async-io//lib/async/io/ssl_socket.rb#91
  def close_write; end

  # Invokes `connect_nonblock` on the underlying {io}. If the operation would block, the current task is paused until the operation can succeed, at which point it's resumed and the operation is completed.
  #
  # source://async-io//lib/async/io/generic.rb#61
  def connect(*args); end

  # source://async-io//lib/async/io/generic.rb#68
  def connect_nonblock(*args, exception: T.unsafe(nil)); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def context(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def export_keying_material(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def finished_message(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def getsockopt(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def hostname(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def hostname=(*args, **_arg1, &block); end

  # source://async-io//lib/async/io/ssl_socket.rb#83
  def local_address; end

  # source://forwardable/1.3.3/forwardable.rb#231
  def npn_protocol(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def peer_cert(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def peer_cert_chain(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def peer_finished_message(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def pending(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def post_connection_check(*args, **_arg1, &block); end

  # source://async-io//lib/async/io/ssl_socket.rb#87
  def remote_address; end

  # source://forwardable/1.3.3/forwardable.rb#231
  def session(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def session=(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def session_reused?(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def setsockopt(*args, **_arg1, &block); end

  # source://async-io//lib/async/io/ssl_socket.rb#100
  def shutdown(how); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def ssl_version(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def state(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def sync_close(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def sync_close=(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def sysclose(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def tmp_key(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def verify_result(*args, **_arg1, &block); end

  class << self
    # source://async-io//lib/async/io/ssl_socket.rb#38
    def connect(socket, context, hostname = T.unsafe(nil), &block); end
  end
end

# Backwards compatibility.
#
# source://async-io//lib/async/io/ssl_endpoint.rb#105
Async::IO::SecureEndpoint = Async::IO::SSLEndpoint

# source://async-io//lib/async/io/server.rb#27
module Async::IO::Server
  # source://async-io//lib/async/io/server.rb#28
  def accept_each(timeout: T.unsafe(nil), task: T.unsafe(nil)); end
end

# source://async-io//lib/async/io/socket.rb#44
class Async::IO::Socket < ::Async::IO::BasicSocket
  include ::Async::IO::Server

  # @param timeout [Numeric] the maximum time to wait for accepting a connection, if specified.
  #
  # source://async-io//lib/async/io/socket.rb#61
  def accept(timeout: T.unsafe(nil), task: T.unsafe(nil)); end

  # @param timeout [Numeric] the maximum time to wait for accepting a connection, if specified.
  #
  # source://async-io//lib/async/io/socket.rb#61
  def accept_nonblock(timeout: T.unsafe(nil), task: T.unsafe(nil)); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def bind(*args, **_arg1, &block); end

  # @raise Errno::EAGAIN the connection failed due to the remote end being overloaded.
  #
  # source://async-io//lib/async/io/socket.rb#50
  def connect(*args); end

  # @raise Errno::EAGAIN the connection failed due to the remote end being overloaded.
  #
  # source://async-io//lib/async/io/socket.rb#50
  def connect_nonblock(*args); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def ipv6only!(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def listen(*args, **_arg1, &block); end

  # Invokes `recvfrom_nonblock` on the underlying {io}. If the operation would block, the current task is paused until the operation can succeed, at which point it's resumed and the operation is completed.
  #
  # source://async-io//lib/async/io/generic.rb#61
  def recvfrom(*args); end

  # source://async-io//lib/async/io/generic.rb#68
  def recvfrom_nonblock(*args, exception: T.unsafe(nil)); end

  # @param timeout [Numeric] the maximum time to wait for accepting a connection, if specified.
  #
  # source://async-io//lib/async/io/socket.rb#61
  def sysaccept(timeout: T.unsafe(nil), task: T.unsafe(nil)); end

  class << self
    # Bind to a local address and accept connections in a loop.
    #
    # source://async-io//lib/async/io/socket.rb#177
    def accept(*args, backlog: T.unsafe(nil), &block); end

    # Bind to a local address.
    #
    # @example
    #   socket = Async::IO::Socket.bind(Async::IO::Address.tcp("0.0.0.0", 9090))
    # @option protocol
    # @param local_address [Address] The local address to bind to.
    # @param protocol [Hash] a customizable set of options
    #
    # source://async-io//lib/async/io/socket.rb#156
    def bind(local_address, protocol: T.unsafe(nil), task: T.unsafe(nil), **options, &block); end

    # Build and wrap the underlying io.
    #
    # @option reuse_port
    # @option reuse_address
    # @param reuse_port [Hash] a customizable set of options
    # @param reuse_address [Hash] a customizable set of options
    #
    # source://async-io//lib/async/io/socket.rb#86
    def build(*args, timeout: T.unsafe(nil), reuse_address: T.unsafe(nil), reuse_port: T.unsafe(nil), linger: T.unsafe(nil), task: T.unsafe(nil)); end

    # Establish a connection to a given `remote_address`.
    #
    # @example
    #   socket = Async::IO::Socket.connect(Async::IO::Address.tcp("8.8.8.8", 53))
    # @option local_address
    # @param remote_address [Address] The remote address to connect to.
    # @param local_address [Hash] a customizable set of options
    #
    # source://async-io//lib/async/io/socket.rb#118
    def connect(remote_address, local_address: T.unsafe(nil), task: T.unsafe(nil), **options); end

    # source://async-io//lib/async/io/socket.rb#187
    def pair(*args); end
  end
end

# source://async-io//lib/async/io/stream.rb#30
class Async::IO::Stream
  # @return [Stream] a new instance of Stream
  #
  # source://async-io//lib/async/io/stream.rb#45
  def initialize(io, block_size: T.unsafe(nil), maximum_read_size: T.unsafe(nil), sync: T.unsafe(nil), deferred: T.unsafe(nil)); end

  # Writes `string` to the stream and returns self.
  #
  # source://async-io//lib/async/io/stream.rb#185
  def <<(string); end

  # Returns the value of attribute block_size.
  #
  # source://async-io//lib/async/io/stream.rb#71
  def block_size; end

  # Best effort to flush any unwritten data, and then close the underling IO.
  #
  # source://async-io//lib/async/io/stream.rb#218
  def close; end

  # source://async-io//lib/async/io/stream.rb#207
  def close_read; end

  # source://async-io//lib/async/io/stream.rb#211
  def close_write; end

  # @return [Boolean]
  #
  # source://async-io//lib/async/io/stream.rb#203
  def closed?; end

  # @return [Boolean]
  #
  # source://async-io//lib/async/io/stream.rb#199
  def connected?; end

  # Returns true if the stream is at file which means there is no more data to be read.
  #
  # @return [Boolean]
  #
  # source://async-io//lib/async/io/stream.rb#231
  def eof; end

  # @raise [EOFError]
  #
  # source://async-io//lib/async/io/stream.rb#243
  def eof!; end

  # Returns true if the stream is at file which means there is no more data to be read.
  #
  # @return [Boolean]
  #
  # source://async-io//lib/async/io/stream.rb#231
  def eof?; end

  # Flushes buffered data to the stream.
  #
  # source://async-io//lib/async/io/stream.rb#154
  def flush; end

  # source://async-io//lib/async/io/stream.rb#149
  def gets(separator = T.unsafe(nil), **options); end

  # Returns the value of attribute io.
  #
  # source://async-io//lib/async/io/stream.rb#69
  def io; end

  # source://async-io//lib/async/io/stream.rb#143
  def peek; end

  # source://async-io//lib/async/io/stream.rb#191
  def puts(*arguments, separator: T.unsafe(nil)); end

  # Reads `size` bytes from the stream. If size is not specified, read until end of file.
  #
  # source://async-io//lib/async/io/stream.rb#74
  def read(size = T.unsafe(nil)); end

  # @raise [exception]
  #
  # source://async-io//lib/async/io/stream.rb#105
  def read_exactly(size, exception: T.unsafe(nil)); end

  # Read at most `size` bytes from the stream. Will avoid reading from the underlying stream if possible.
  #
  # source://async-io//lib/async/io/stream.rb#95
  def read_partial(size = T.unsafe(nil)); end

  # Efficiently read data from the stream until encountering pattern.
  #
  # @param pattern [String] The pattern to match.
  # @return [String] The contents of the stream up until the pattern, which is consumed but not returned.
  #
  # source://async-io//lib/async/io/stream.rb#124
  def read_until(pattern, offset = T.unsafe(nil), chomp: T.unsafe(nil)); end

  # source://async-io//lib/async/io/stream.rb#117
  def readpartial(size = T.unsafe(nil)); end

  # Writes `string` to the buffer. When the buffer is full or #sync is true the
  # buffer is flushed to the underlying `io`.
  #
  # @param string the string to write to the buffer.
  # @return the number of bytes appended to the buffer.
  #
  # source://async-io//lib/async/io/stream.rb#174
  def write(string); end

  private

  # Consumes at most `size` bytes from the buffer.
  #
  # @param size [Integer|nil] The amount of data to consume. If nil, consume entire buffer.
  #
  # source://async-io//lib/async/io/stream.rb#283
  def consume_read_buffer(size = T.unsafe(nil)); end

  # Fills the buffer from the underlying stream.
  #
  # source://async-io//lib/async/io/stream.rb#253
  def fill_read_buffer(size = T.unsafe(nil)); end

  class << self
    # source://async-io//lib/async/io/stream.rb#33
    def open(path, mode = T.unsafe(nil), **options); end
  end
end

# source://async-io//lib/async/io/stream.rb#31
Async::IO::Stream::BLOCK_SIZE = T.let(T.unsafe(nil), Integer)
