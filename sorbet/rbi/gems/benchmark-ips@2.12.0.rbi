# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `benchmark-ips` gem.
# Please instead update this file by running `bin/tapioca gem benchmark-ips`.

# Performance benchmarking library
#
# source://benchmark-ips//lib/benchmark/timing.rb#1
module Benchmark
  extend ::Benchmark::Compare
  extend ::Benchmark::IPS
end

# Functionality of performaing comparison between reports.
#
# Usage:
#
# Add +x.compare!+ to perform comparison between reports.
#
# Example:
#   > Benchmark.ips do |x|
#     x.report('Reduce using tag')     { [*1..10].reduce(:+) }
#     x.report('Reduce using to_proc') { [*1..10].reduce(&:+) }
#     x.compare!
#   end
#
#   Calculating -------------------------------------
#       Reduce using tag     19216 i/100ms
#   Reduce using to_proc     17437 i/100ms
#   -------------------------------------------------
#       Reduce using tag   278950.0 (±8.5%) i/s -    1402768 in   5.065112s
#   Reduce using to_proc   247295.4 (±8.0%) i/s -    1238027 in   5.037299s
#
#   Comparison:
#       Reduce using tag:   278950.0 i/s
#   Reduce using to_proc:   247295.4 i/s - 1.13x slower
#
# Besides regular Calculating report, this will also indicates which one is slower.
#
# +x.compare!+ also takes an +order: :baseline+ option.
#
# Example:
#  > Benchmark.ips do |x|
#   x.report('Reduce using block')   { [*1..10].reduce { |sum, n| sum + n } }
#   x.report('Reduce using tag')     { [*1..10].reduce(:+) }
#   x.report('Reduce using to_proc') { [*1..10].reduce(&:+) }
#   x.compare!(order: :baseline)
# end
#
# Calculating -------------------------------------
#   Reduce using block    886.202k (± 2.2%) i/s -      4.521M in   5.103774s
#     Reduce using tag      1.821M (± 1.6%) i/s -      9.111M in   5.004183s
# Reduce using to_proc    895.948k (± 1.6%) i/s -      4.528M in   5.055368s
#
# Comparison:
#   Reduce using block:   886202.5 i/s
#     Reduce using tag:  1821055.0 i/s - 2.05x  (± 0.00) faster
# Reduce using to_proc:   895948.1 i/s - same-ish: difference falls within error
#
# The first report is considered the baseline against which other reports are compared.
#
# source://benchmark-ips//lib/benchmark/compare.rb#51
module Benchmark::Compare
  # Compare between reports, prints out facts of each report:
  # runtime, comparative speed difference.
  #
  # @param entries [Array<Report::Entry>] Reports to compare.
  #
  # source://benchmark-ips//lib/benchmark/compare.rb#56
  def compare(*entries, order: T.unsafe(nil)); end
end

# Benchmark in iterations per second, no more guessing!
#
# @see https://github.com/evanphx/benchmark-ips
#
# source://benchmark-ips//lib/benchmark/ips/stats/stats_metric.rb#2
module Benchmark::IPS
  # Measure code in block, each code's benchmarked result will display in
  # iteration per second with standard deviation in given time.
  #
  # @param time [Integer] Specify how long should benchmark your code in seconds.
  # @param warmup [Integer] Specify how long should Warmup time run in seconds.
  # @return [Report]
  # @yield [job]
  #
  # source://benchmark-ips//lib/benchmark/ips.rb#30
  def ips(*args); end

  class << self
    # Set options for running the benchmarks.
    # :format => [:human, :raw]
    #    :human format narrows precision and scales results for readability
    #    :raw format displays 6 places of precision and exact iteration counts
    #
    # source://benchmark-ips//lib/benchmark/ips.rb#80
    def options; end
  end
end

# CODENAME of current version.
#
# source://benchmark-ips//lib/benchmark/ips.rb#23
Benchmark::IPS::CODENAME = T.let(T.unsafe(nil), String)

# source://benchmark-ips//lib/benchmark/ips.rb#84
module Benchmark::IPS::Helpers
  private

  # source://benchmark-ips//lib/benchmark/ips.rb#85
  def scale(value); end

  class << self
    # source://benchmark-ips//lib/benchmark/ips.rb#85
    def scale(value); end
  end
end

# Benchmark jobs.
#
# source://benchmark-ips//lib/benchmark/ips/job/entry.rb#4
class Benchmark::IPS::Job
  # Instantiate the Benchmark::IPS::Job.
  #
  # @return [Job] a new instance of Job
  #
  # source://benchmark-ips//lib/benchmark/ips/job.rb#67
  def initialize(opts = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://benchmark-ips//lib/benchmark/ips/job.rb#241
  def all_results_have_been_run?; end

  # source://benchmark-ips//lib/benchmark/ips/job.rb#245
  def clear_held_results; end

  # Determining whether to run comparison utility.
  #
  # @return [Boolean] true if needs to run compare.
  #
  # source://benchmark-ips//lib/benchmark/ips/job.rb#20
  def compare; end

  # Run comparison utility.
  #
  # source://benchmark-ips//lib/benchmark/ips/job.rb#124
  def compare!(order: T.unsafe(nil)); end

  # Return true if job needs to be compared.
  #
  # @return [Boolean] Need to compare?
  #
  # source://benchmark-ips//lib/benchmark/ips/job.rb#119
  def compare?; end

  # Confidence.
  #
  # @return [Integer]
  #
  # source://benchmark-ips//lib/benchmark/ips/job.rb#52
  def confidence; end

  # Confidence.
  #
  # @return [Integer]
  #
  # source://benchmark-ips//lib/benchmark/ips/job.rb#52
  def confidence=(_arg0); end

  # Job configuration options, set +@warmup+ and +@time+.
  #
  # @option opts
  # @option opts
  # @option iterations
  # @param opts [Hash] a customizable set of options
  # @param iterations [Hash] a customizable set of options
  #
  # source://benchmark-ips//lib/benchmark/ips/job.rb#95
  def config(opts); end

  # Create report by add entry to +@full_report+.
  #
  # @param label [String] Report item label.
  # @param measured_us [Integer] Measured time in microsecond.
  # @param iter [Integer] Iterations.
  # @param samples [Array<Float>] Sampled iterations per second.
  # @param cycles [Integer] Number of Cycles.
  # @return [Report::Entry] Entry with data.
  #
  # source://benchmark-ips//lib/benchmark/ips/job.rb#392
  def create_report(label, measured_us, iter, samples, cycles); end

  # source://benchmark-ips//lib/benchmark/ips/job.rb#364
  def create_stats(samples); end

  # Calculate the cycles needed to run for approx 100ms,
  # given the number of iterations to run the given time.
  #
  # @param time_msec [Float] Each iteration's time in ms.
  # @param iters [Integer] Iterations.
  # @return [Integer] Cycles per 100ms.
  #
  # source://benchmark-ips//lib/benchmark/ips/job.rb#193
  def cycles_per_100ms(time_msec, iters); end

  # Report object containing information about the run.
  #
  # @return [Report] the report object.
  #
  # source://benchmark-ips//lib/benchmark/ips/job.rb#28
  def full_report; end

  # Generate json from +@full_report+.
  #
  # source://benchmark-ips//lib/benchmark/ips/job.rb#381
  def generate_json; end

  # Determining whether to hold results between Ruby invocations
  #
  # @return [Boolean]
  #
  # source://benchmark-ips//lib/benchmark/ips/job.rb#24
  def hold; end

  # Hold after each iteration.
  #
  # @param held_path [String] File name to store hold file.
  #
  # source://benchmark-ips//lib/benchmark/ips/job.rb#137
  def hold!(held_path); end

  # Determining whether to hold results between Ruby invocations
  #
  # @return [Boolean]
  #
  # source://benchmark-ips//lib/benchmark/ips/job.rb#24
  def hold=(_arg0); end

  # Return true if results are held while multiple Ruby invocations
  #
  # @return [Boolean] Need to hold results between multiple Ruby invocations?
  #
  # source://benchmark-ips//lib/benchmark/ips/job.rb#131
  def hold?; end

  # Registers the given label and block pair in the job list.
  #
  # @param label [String] Label of benchmarked code.
  # @param str [String] Code to be benchmarked.
  # @param blk [Proc] Code to be benchmarked.
  # @raise [ArgumentError] Raises if str and blk are both present.
  # @raise [ArgumentError] Raises if str and blk are both absent.
  #
  # source://benchmark-ips//lib/benchmark/ips/job.rb#175
  def item(label = T.unsafe(nil), str = T.unsafe(nil), &blk); end

  # Warmup and calculation iterations.
  #
  # @return [Integer]
  #
  # source://benchmark-ips//lib/benchmark/ips/job.rb#44
  def iterations; end

  # Warmup and calculation iterations.
  #
  # @return [Integer]
  #
  # source://benchmark-ips//lib/benchmark/ips/job.rb#44
  def iterations=(_arg0); end

  # Calculate the interations per second given the number
  # of cycles run and the time in microseconds that elapsed.
  #
  # @param cycles [Integer] Cycles.
  # @param time_us [Integer] Time in microsecond.
  # @return [Float] Iteration per second.
  #
  # source://benchmark-ips//lib/benchmark/ips/job.rb#211
  def iterations_per_sec(cycles, time_us); end

  # Generate json to given path, defaults to "data.json".
  #
  # source://benchmark-ips//lib/benchmark/ips/job.rb#165
  def json!(path = T.unsafe(nil)); end

  # Return true if job needs to generate json.
  #
  # @return [Boolean] Need to generate json?
  #
  # source://benchmark-ips//lib/benchmark/ips/job.rb#160
  def json?; end

  # Two-element arrays, consisting of label and block pairs.
  #
  # @return [Array<Entry>] list of entries
  #
  # source://benchmark-ips//lib/benchmark/ips/job.rb#16
  def list; end

  # source://benchmark-ips//lib/benchmark/ips/job.rb#215
  def load_held_results; end

  # Silence output
  #
  # @return [Boolean]
  #
  # source://benchmark-ips//lib/benchmark/ips/job.rb#56
  def quiet; end

  # source://benchmark-ips//lib/benchmark/ips/job.rb#105
  def quiet=(val); end

  # Registers the given label and block pair in the job list.
  #
  # @param label [String] Label of benchmarked code.
  # @param str [String] Code to be benchmarked.
  # @param blk [Proc] Code to be benchmarked.
  # @raise [ArgumentError] Raises if str and blk are both present.
  # @raise [ArgumentError] Raises if str and blk are both absent.
  #
  # source://benchmark-ips//lib/benchmark/ips/job.rb#175
  def report(label = T.unsafe(nil), str = T.unsafe(nil), &blk); end

  # source://benchmark-ips//lib/benchmark/ips/job.rb#249
  def run; end

  # Run calculation.
  #
  # source://benchmark-ips//lib/benchmark/ips/job.rb#312
  def run_benchmark; end

  # Run comparison of entries in +@full_report+.
  #
  # source://benchmark-ips//lib/benchmark/ips/job.rb#376
  def run_comparison; end

  # Return true if items are to be run one at a time.
  # For the traditional hold, this is true
  #
  # @return [Boolean] Run just a single item?
  #
  # source://benchmark-ips//lib/benchmark/ips/job.rb#154
  def run_single?; end

  # Run warmup.
  #
  # source://benchmark-ips//lib/benchmark/ips/job.rb#267
  def run_warmup; end

  # Save interim results. Similar to hold, but all reports are run
  # The report label must change for each invocation.
  # One way to achieve this is to include the version in the label.
  #
  # @param held_path [String] File name to store hold file.
  #
  # source://benchmark-ips//lib/benchmark/ips/job.rb#146
  def save!(held_path); end

  # source://benchmark-ips//lib/benchmark/ips/job.rb#226
  def save_held_results; end

  # Statistics model.
  #
  # @return [Object]
  #
  # source://benchmark-ips//lib/benchmark/ips/job.rb#48
  def stats; end

  # Statistics model.
  #
  # @return [Object]
  #
  # source://benchmark-ips//lib/benchmark/ips/job.rb#48
  def stats=(_arg0); end

  # Suite
  #
  # @return [Benchmark::IPS::MultiReport]
  #
  # source://benchmark-ips//lib/benchmark/ips/job.rb#62
  def suite; end

  # source://benchmark-ips//lib/benchmark/ips/job.rb#113
  def suite=(suite); end

  # Calculation time setter and getter (in seconds).
  #
  # @return [Integer]
  #
  # source://benchmark-ips//lib/benchmark/ips/job.rb#40
  def time; end

  # Calculation time setter and getter (in seconds).
  #
  # @return [Integer]
  #
  # source://benchmark-ips//lib/benchmark/ips/job.rb#40
  def time=(_arg0); end

  # Calculate the time difference of before and after in microseconds.
  #
  # @param before [Time] time.
  # @param after [Time] time.
  # @return [Float] Time difference of before and after.
  #
  # source://benchmark-ips//lib/benchmark/ips/job.rb#202
  def time_us(before, after); end

  # Storing Iterations in time period.
  #
  # @return [Hash]
  #
  # source://benchmark-ips//lib/benchmark/ips/job.rb#32
  def timing; end

  # Warmup time setter and getter (in seconds).
  #
  # @return [Integer]
  #
  # source://benchmark-ips//lib/benchmark/ips/job.rb#36
  def warmup; end

  # Warmup time setter and getter (in seconds).
  #
  # @return [Integer]
  #
  # source://benchmark-ips//lib/benchmark/ips/job.rb#36
  def warmup=(_arg0); end
end

# Entries in Benchmark Jobs.
#
# source://benchmark-ips//lib/benchmark/ips/job/entry.rb#6
class Benchmark::IPS::Job::Entry
  # Instantiate the Benchmark::IPS::Job::Entry.
  #
  # @param label [#to_s] Label of Benchmarked code.
  # @param action [String, Proc] Code to be benchmarked.
  # @raise [ArgumentError] Raises when action is not String or not responding to +call+.
  # @return [Entry] a new instance of Entry
  #
  # source://benchmark-ips//lib/benchmark/ips/job/entry.rb#11
  def initialize(label, action); end

  # The benchmarking action.
  #
  # @return [String, Proc] Code to be called, could be String / Proc.
  #
  # source://benchmark-ips//lib/benchmark/ips/job/entry.rb#41
  def action; end

  # Call action by given times.
  #
  # @param times [Integer] Times to call +@action+.
  # @return [Integer] Number of times the +@action+ has been called.
  #
  # source://benchmark-ips//lib/benchmark/ips/job/entry.rb#46
  def call_times(times); end

  # source://benchmark-ips//lib/benchmark/ips/job/entry.rb#50
  def compile_block; end

  # source://benchmark-ips//lib/benchmark/ips/job/entry.rb#66
  def compile_block_with_manual_loop; end

  # Compile code into +call_times+ method.
  #
  # @param str [String] Code to be compiled.
  # @return [Symbol] :call_times.
  #
  # source://benchmark-ips//lib/benchmark/ips/job/entry.rb#79
  def compile_string(str); end

  # The label of benchmarking action.
  #
  # @return [#to_s] Label of action.
  #
  # source://benchmark-ips//lib/benchmark/ips/job/entry.rb#37
  def label; end
end

# The percentage of the expected runtime to allow
# before reporting a weird runtime
#
# source://benchmark-ips//lib/benchmark/ips/job.rb#11
Benchmark::IPS::Job::MAX_TIME_SKEW = T.let(T.unsafe(nil), Float)

# Microseconds per 100 millisecond.
#
# source://benchmark-ips//lib/benchmark/ips/job.rb#6
Benchmark::IPS::Job::MICROSECONDS_PER_100MS = T.let(T.unsafe(nil), Integer)

# Microseconds per second.
#
# source://benchmark-ips//lib/benchmark/ips/job.rb#8
Benchmark::IPS::Job::MICROSECONDS_PER_SECOND = T.let(T.unsafe(nil), Integer)

# source://benchmark-ips//lib/benchmark/ips/job/multi_report.rb#4
class Benchmark::IPS::Job::MultiReport
  # @param out [Array<StreamReport>] list of reports to send output
  # @return [MultiReport] a new instance of MultiReport
  #
  # source://benchmark-ips//lib/benchmark/ips/job/multi_report.rb#32
  def initialize(out = T.unsafe(nil)); end

  # @param report [StreamReport] report to accept input?
  #
  # source://benchmark-ips//lib/benchmark/ips/job/multi_report.rb#21
  def <<(report); end

  # source://benchmark-ips//lib/benchmark/ips/job/multi_report.rb#57
  def add_report(item, caller); end

  # @return [Boolean]
  #
  # source://benchmark-ips//lib/benchmark/ips/job/multi_report.rb#8
  def empty?; end

  # source://benchmark-ips//lib/benchmark/ips/job/multi_report.rb#61
  def footer; end

  # Returns the value of attribute out.
  #
  # source://benchmark-ips//lib/benchmark/ips/job/multi_report.rb#6
  def out; end

  # Sets the attribute out
  #
  # @param value the value to set the attribute out to.
  #
  # source://benchmark-ips//lib/benchmark/ips/job/multi_report.rb#6
  def out=(_arg0); end

  # source://benchmark-ips//lib/benchmark/ips/job/multi_report.rb#16
  def quiet!; end

  # @return [Boolean]
  #
  # source://benchmark-ips//lib/benchmark/ips/job/multi_report.rb#12
  def quiet?; end

  # source://benchmark-ips//lib/benchmark/ips/job/multi_report.rb#53
  def running(label, warmup); end

  # source://benchmark-ips//lib/benchmark/ips/job/multi_report.rb#49
  def start_running; end

  # source://benchmark-ips//lib/benchmark/ips/job/multi_report.rb#37
  def start_warming; end

  # source://benchmark-ips//lib/benchmark/ips/job/multi_report.rb#41
  def warming(label, warmup); end

  # source://benchmark-ips//lib/benchmark/ips/job/multi_report.rb#45
  def warmup_stats(warmup_time_us, timing); end
end

# source://benchmark-ips//lib/benchmark/ips/job.rb#12
Benchmark::IPS::Job::POW_2_30 = T.let(T.unsafe(nil), Integer)

# source://benchmark-ips//lib/benchmark/ips/job/stream_report.rb#4
class Benchmark::IPS::Job::StreamReport
  # @return [StreamReport] a new instance of StreamReport
  #
  # source://benchmark-ips//lib/benchmark/ips/job/stream_report.rb#5
  def initialize(stream = T.unsafe(nil)); end

  # source://benchmark-ips//lib/benchmark/ips/job/stream_report.rb#33
  def add_report(item, caller); end

  # source://benchmark-ips//lib/benchmark/ips/job/stream_report.rb#38
  def footer; end

  # source://benchmark-ips//lib/benchmark/ips/job/stream_report.rb#18
  def running(label, _warmup); end

  # source://benchmark-ips//lib/benchmark/ips/job/stream_report.rb#14
  def start_running; end

  # source://benchmark-ips//lib/benchmark/ips/job/stream_report.rb#10
  def start_warming; end

  # source://benchmark-ips//lib/benchmark/ips/job/stream_report.rb#18
  def warming(label, _warmup); end

  # source://benchmark-ips//lib/benchmark/ips/job/stream_report.rb#22
  def warmup_stats(_warmup_time_us, timing); end

  private

  # @return [Symbol] format used for benchmarking
  #
  # source://benchmark-ips//lib/benchmark/ips/job/stream_report.rb#47
  def format; end

  # Add padding to label's right if label's length < 20,
  # Otherwise add a new line and 20 whitespaces.
  #
  # @return [String] Right justified label.
  #
  # source://benchmark-ips//lib/benchmark/ips/job/stream_report.rb#54
  def rjust(label); end
end

# Report contains benchmarking entries.
# Perform operations like add new entry, run comparison between entries.
#
# source://benchmark-ips//lib/benchmark/ips/report.rb#8
class Benchmark::IPS::Report
  # Instantiate the Report.
  #
  # @return [Report] a new instance of Report
  #
  # source://benchmark-ips//lib/benchmark/ips/report.rb#135
  def initialize; end

  # Add entry to report.
  #
  # @param label [String] Entry label.
  # @param microseconds [Integer] Measured time in microsecond.
  # @param iters [Integer] Iterations.
  # @param stats [Object] Statistical results.
  # @param measurement_cycle [Integer] Number of cycles.
  # @return [Report::Entry] Last added entry.
  #
  # source://benchmark-ips//lib/benchmark/ips/report.rb#147
  def add_entry(label, microseconds, iters, stats, measurement_cycle); end

  # Entries data in array for generate json.
  # Each entry is a hash, consists of:
  #   name:   Entry#label
  #   ips:    Entry#ips
  #   stddev: Entry#ips_sd
  #   microseconds: Entry#microseconds
  #   iterations:   Entry#iterations
  #   cycles:       Entry#measurement_cycles
  #
  # @return [Array<Hash<Symbol,String|Float|Integer>] Array of hashes] Array<Hash<Symbol,String|Float|Integer>] Array of hashes
  #
  # source://benchmark-ips//lib/benchmark/ips/report.rb#163
  def data; end

  # Entry to represent each benchmarked code in Report.
  #
  # @return [Array<Report::Entry>] Entries in Report.
  #
  # source://benchmark-ips//lib/benchmark/ips/report.rb#132
  def entries; end

  # Generate json from Report#data to given path.
  #
  # @param path [String] path to generate json.
  #
  # source://benchmark-ips//lib/benchmark/ips/report.rb#185
  def generate_json(path); end

  # Run comparison of entries.
  #
  # source://benchmark-ips//lib/benchmark/ips/report.rb#179
  def run_comparison(order); end
end

# Represents benchmarking code data for Report.
#
# source://benchmark-ips//lib/benchmark/ips/report.rb#11
class Benchmark::IPS::Report::Entry
  # Instantiate the Benchmark::IPS::Report::Entry.
  #
  # @param label [#to_s] Label of entry.
  # @param us [Integer] Measured time in microsecond.
  # @param iters [Integer] Iterations.
  # @param stats [Object] Statistics.
  # @param cycles [Integer] Number of Cycles.
  # @return [Entry] a new instance of Entry
  #
  # source://benchmark-ips//lib/benchmark/ips/report.rb#18
  def initialize(label, us, iters, stats, cycles); end

  # Return Entry body text with left padding.
  # Body text contains information of iteration per second with
  # percentage of standard deviation, iterations in runtime.
  #
  # @return [String] Left justified body.
  #
  # source://benchmark-ips//lib/benchmark/ips/report.rb#88
  def body; end

  # Print entry to current standard output ($stdout).
  #
  # source://benchmark-ips//lib/benchmark/ips/report.rb#123
  def display; end

  # Return entry's standard deviation of iteration per second in percentage.
  #
  # @return [Float] +@ips_sd+ in percentage.
  #
  # source://benchmark-ips//lib/benchmark/ips/report.rb#78
  def error_percentage; end

  # Return header with padding if +@label+ is < length of 20.
  #
  # @return [String] Right justified header (+@label+).
  #
  # source://benchmark-ips//lib/benchmark/ips/report.rb#112
  def header; end

  # LEGACY: Iterations per second.
  #
  # @return [Float] number of iterations per second.
  #
  # source://benchmark-ips//lib/benchmark/ips/report.rb#45
  def ips; end

  # LEGACY: Standard deviation of iteration per second.
  #
  # @return [Float] standard deviation of iteration per second.
  #
  # source://benchmark-ips//lib/benchmark/ips/report.rb#51
  def ips_sd; end

  # Number of Iterations.
  #
  # @return [Integer] number of iterations.
  #
  # source://benchmark-ips//lib/benchmark/ips/report.rb#37
  def iterations; end

  # Label of entry.
  #
  # @return [String] the label of entry.
  #
  # source://benchmark-ips//lib/benchmark/ips/report.rb#29
  def label; end

  # Number of Cycles.
  #
  # @return [Integer] number of cycles.
  #
  # source://benchmark-ips//lib/benchmark/ips/report.rb#61
  def measurement_cycle; end

  # Measured time in microsecond.
  #
  # @return [Integer] number of microseconds.
  #
  # source://benchmark-ips//lib/benchmark/ips/report.rb#33
  def microseconds; end

  # Return entry's microseconds in seconds.
  #
  # @return [Float] +@microseconds+ in seconds.
  #
  # source://benchmark-ips//lib/benchmark/ips/report.rb#72
  def runtime; end

  # source://benchmark-ips//lib/benchmark/ips/report.rb#55
  def samples; end

  # Return entry's microseconds in seconds.
  #
  # @return [Float] +@microseconds+ in seconds.
  #
  # source://benchmark-ips//lib/benchmark/ips/report.rb#72
  def seconds; end

  # Control if the total time the job took is reported.
  # Typically this value is not significant because it's very
  # close to the expected time, so it's supressed by default.
  #
  # source://benchmark-ips//lib/benchmark/ips/report.rb#66
  def show_total_time!; end

  # Statistical summary of samples.
  #
  # @return [Object] statisical summary.
  #
  # source://benchmark-ips//lib/benchmark/ips/report.rb#41
  def stats; end

  # Return string repesentation of Entry object.
  #
  # @return [String] Header and body.
  #
  # source://benchmark-ips//lib/benchmark/ips/report.rb#118
  def to_s; end
end

# source://benchmark-ips//lib/benchmark/ips/stats/stats_metric.rb#3
module Benchmark::IPS::Stats; end

# source://benchmark-ips//lib/benchmark/ips/stats/bootstrap.rb#5
class Benchmark::IPS::Stats::Bootstrap
  include ::Benchmark::IPS::Stats::StatsMetric

  # @return [Bootstrap] a new instance of Bootstrap
  #
  # source://benchmark-ips//lib/benchmark/ips/stats/bootstrap.rb#9
  def initialize(samples, confidence); end

  # Average stat value
  #
  # @return [Float] central_tendency
  #
  # source://benchmark-ips//lib/benchmark/ips/stats/bootstrap.rb#22
  def central_tendency; end

  # Returns the value of attribute data.
  #
  # source://benchmark-ips//lib/benchmark/ips/stats/bootstrap.rb#7
  def data; end

  # source://benchmark-ips//lib/benchmark/ips/stats/bootstrap.rb#44
  def dependencies; end

  # Returns the value of attribute error.
  #
  # source://benchmark-ips//lib/benchmark/ips/stats/bootstrap.rb#7
  def error; end

  # source://benchmark-ips//lib/benchmark/ips/stats/bootstrap.rb#40
  def footer; end

  # Returns the value of attribute samples.
  #
  # source://benchmark-ips//lib/benchmark/ips/stats/bootstrap.rb#7
  def samples; end

  # Determines how much slower this stat is than the baseline stat
  # if this average is lower than the faster baseline, higher average is better (e.g. ips) (calculate accordingly)
  #
  # @param baseline [SD|Bootstrap] faster baseline
  #
  # source://benchmark-ips//lib/benchmark/ips/stats/bootstrap.rb#30
  def slowdown(baseline); end

  # source://benchmark-ips//lib/benchmark/ips/stats/bootstrap.rb#36
  def speedup(baseline); end
end

# source://benchmark-ips//lib/benchmark/ips/stats/sd.rb#5
class Benchmark::IPS::Stats::SD
  include ::Benchmark::IPS::Stats::StatsMetric

  # @return [SD] a new instance of SD
  #
  # source://benchmark-ips//lib/benchmark/ips/stats/sd.rb#9
  def initialize(samples); end

  # Average stat value
  #
  # @return [Float] central_tendency
  #
  # source://benchmark-ips//lib/benchmark/ips/stats/sd.rb#17
  def central_tendency; end

  # Returns the value of attribute error.
  #
  # source://benchmark-ips//lib/benchmark/ips/stats/sd.rb#7
  def error; end

  # source://benchmark-ips//lib/benchmark/ips/stats/sd.rb#37
  def footer; end

  # Returns the value of attribute samples.
  #
  # source://benchmark-ips//lib/benchmark/ips/stats/sd.rb#7
  def samples; end

  # Determines how much slower this stat is than the baseline stat
  # if this average is lower than the faster baseline, higher average is better (e.g. ips) (calculate accordingly)
  #
  # @param baseline [SD|Bootstrap] faster baseline
  #
  # source://benchmark-ips//lib/benchmark/ips/stats/sd.rb#25
  def slowdown(baseline); end

  # source://benchmark-ips//lib/benchmark/ips/stats/sd.rb#33
  def speedup(baseline); end
end

# source://benchmark-ips//lib/benchmark/ips/stats/stats_metric.rb#4
module Benchmark::IPS::Stats::StatsMetric
  # Return entry's standard deviation of iteration per second in percentage.
  #
  # @return [Float] +@ips_sd+ in percentage.
  #
  # source://benchmark-ips//lib/benchmark/ips/stats/stats_metric.rb#7
  def error_percentage; end

  # @return [Boolean]
  #
  # source://benchmark-ips//lib/benchmark/ips/stats/stats_metric.rb#11
  def overlaps?(baseline); end
end

# Benchmark-ips Gem version.
#
# source://benchmark-ips//lib/benchmark/ips.rb#20
Benchmark::IPS::VERSION = T.let(T.unsafe(nil), String)

# Perform caclulations on Timing results.
#
# source://benchmark-ips//lib/benchmark/timing.rb#3
module Benchmark::Timing
  class << self
    # source://benchmark-ips//lib/benchmark/timing.rb#54
    def add_second(t, s); end

    # Recycle used objects by starting Garbage Collector.
    #
    # source://benchmark-ips//lib/benchmark/timing.rb#35
    def clean_env; end

    # Calculate (arithmetic) mean of given samples.
    #
    # @param samples [Array] Samples to calculate mean.
    # @return [Float] Mean of given samples.
    #
    # source://benchmark-ips//lib/benchmark/timing.rb#10
    def mean(samples); end

    # source://benchmark-ips//lib/benchmark/timing.rb#49
    def now; end

    # Calculate standard deviation of given samples.
    #
    # @param samples [Array] Samples to calculate standard deviation.
    # @param m [Float] Optional mean (Expected value).
    # @return [Float] standard deviation of given samples.
    #
    # source://benchmark-ips//lib/benchmark/timing.rb#30
    def stddev(samples, m = T.unsafe(nil)); end

    # source://benchmark-ips//lib/benchmark/timing.rb#59
    def time_us(before, after); end

    # Calculate variance of given samples.
    #
    # @param m [Float] Optional mean (Expected value).
    # @return [Float] Variance of given samples.
    #
    # source://benchmark-ips//lib/benchmark/timing.rb#18
    def variance(samples, m = T.unsafe(nil)); end
  end
end

# Microseconds per second.
#
# source://benchmark-ips//lib/benchmark/timing.rb#5
Benchmark::Timing::MICROSECONDS_PER_SECOND = T.let(T.unsafe(nil), Integer)
