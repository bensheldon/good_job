# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `mixlib-config` gem.
# Please instead update this file by running `bin/tapioca gem mixlib-config`.

module Mixlib; end

module Mixlib::Config
  # Get the value of a config option
  #
  # === Parameters
  # config_option<Symbol>:: The config option to return
  #
  # === Returns
  # value:: The value of the config option
  #
  # === Raises
  # <UnknownConfigOptionError>:: If the config option does not exist and strict mode is on.
  def [](config_option); end

  # Set the value of a config option
  #
  # === Parameters
  # config_option<Symbol>:: The config option to set (within the [])
  # value:: The value for the config option
  #
  # === Returns
  # value:: The new value of the config option
  #
  # === Raises
  # <UnknownConfigOptionError>:: If the config option does not exist and strict mode is on.
  def []=(config_option, value); end

  # metaprogramming to ensure that the slot for method_symbol
  # gets set to value after any other logic is run
  #
  # === Parameters
  # method_symbol<Symbol>:: Name of the method (variable setter)
  # blk<Block>:: logic block to run in setting slot method_symbol to value
  # value<Object>:: Value to be set in config hash
  def config_attr_writer(method_symbol, &block); end

  # Allows you to create a new config context where you can define new
  # options with default values.
  #
  # This method allows you to open up the configurable more than once.
  #
  # For example:
  #
  # config_context :server_info do
  #   configurable(:url).defaults_to("http://localhost")
  # end
  #
  # === Parameters
  # symbol<Symbol>: the name of the context
  # block<Block>: a block that will be run in the context of this new config
  # class.
  def config_context(symbol, &block); end

  # Allows you to create a new hash of config contexts where you can define new
  # options with default values.
  #
  # This method allows you to open up the configurable more than once.
  #
  # For example:
  #
  # config_context_hash :listeners, :listener do
  #   configurable(:url).defaults_to("http://localhost")
  # end
  #
  # === Parameters
  # symbol<Symbol>: the plural name for contexts in the list
  # symbol<Symbol>: the singular name for contexts in the list
  # block<Block>: a block that will be run in the context of this new config
  # class.
  def config_context_hash(plural_symbol, singular_symbol, &block); end

  # Allows you to create a new list of config contexts where you can define new
  # options with default values.
  #
  # This method allows you to open up the configurable more than once.
  #
  # For example:
  #
  # config_context_list :listeners, :listener do
  #   configurable(:url).defaults_to("http://localhost")
  # end
  #
  # === Parameters
  # symbol<Symbol>: the plural name for contexts in the list
  # symbol<Symbol>: the singular name for contexts in the list
  # block<Block>: a block that will be run in the context of this new config
  # class.
  def config_context_list(plural_symbol, singular_symbol, &block); end

  # Gets or sets strict mode.  When strict mode is on, only values which
  # were specified with configurable(), default() or writes_with() may be
  # retrieved or set. Getting or setting anything else will cause
  # Mixlib::Config::UnknownConfigOptionError to be thrown.
  #
  # If this is set to :warn, unknown values may be get or set, but a warning
  # will be printed with Chef::Log.warn if this occurs.
  #
  # === Parameters
  # value<String>:: pass this value to set strict mode [optional]
  #
  # === Returns
  # Current value of config_strict_mode
  #
  # === Raises
  # <ArgumentError>:: if value is set to something other than true, false, or :warn
  def config_strict_mode(value = T.unsafe(nil)); end

  # Sets strict mode.  When strict mode is on, only values which
  # were specified with configurable(), default() or writes_with() may be
  # retrieved or set.  All other values
  #
  # If this is set to :warn, unknown values may be get or set, but a warning
  # will be printed with Chef::Log.warn if this occurs.
  #
  # === Parameters
  # value<String>:: pass this value to set strict mode [optional]
  #
  # === Raises
  # <ArgumentError>:: if value is set to something other than true, false, or :warn
  def config_strict_mode=(value); end

  # metaprogramming to set information about a config option.  This may be
  # used in one of two ways:
  #
  # 1. Block-based:
  # configurable(:attr) do
  #   defaults_to 4
  #   writes_value { |value| 10 }
  # end
  #
  # 2. Chain-based:
  # configurable(:attr).defaults_to(4).writes_value { |value| 10 }
  #
  # Currently supported configuration:
  #
  # defaults_to(value): value returned when configurable has no explicit value
  # defaults_to BLOCK: block is run when the configurable has no explicit value
  # writes_value BLOCK: block that is run to filter a value when it is being set
  #
  # === Parameters
  # symbol<Symbol>:: Name of the config option
  # default_value<Object>:: Default value [optional]
  # block<Block>:: Logic block that calculates default value [optional]
  #
  # === Returns
  # The value of the config option.
  def configurable(symbol, &block); end

  # Pass Mixlib::Config.configure() a block, and it will yield itself
  #
  # === Parameters
  # block<Block>:: A block that is called with self.configuration as the argument.
  #
  # @yield [configuration]
  def configure(&block); end

  # metaprogramming to set the default value for the given config option
  #
  # === Parameters
  # symbol<Symbol>:: Name of the config option
  # default_value<Object>:: Default value (can be unspecified)
  # block<Block>:: Logic block that calculates default value
  def default(symbol, default_value = T.unsafe(nil), &block); end

  # Resets a config option to its default.
  #
  # === Parameters
  # symbol<Symbol>:: Name of the config option
  def delete(symbol); end

  # Loads a given ruby file, and runs instance_eval against it in the context of the current
  # object.
  #
  # Raises an IOError if the file cannot be found, or is not readable.
  #
  # === Parameters
  # filename<String>:: A filename to read from
  def from_file(filename); end

  # Transforms a Hash into method-style configuration syntax to be processed
  #
  # === Parameters
  # hash<Hash>:: A Hash containing configuration
  def from_hash(hash); end

  # Parses valid JSON structure into Ruby
  #
  # === Parameters
  # filename<String>:: A filename to read from
  def from_json(filename); end

  def from_toml(filename); end

  # Parses valid YAML structure into Ruby so it can be ingested into the Class
  #
  # === Parameters
  # filename<String>:: A filename to read from
  def from_yaml(filename); end

  # Check if Mixlib::Config has a config option.
  #
  # === Parameters
  # key<Symbol>:: The config option to check for
  #
  # === Returns
  # <True>:: If the config option exists
  # <False>:: If the config option does not exist
  #
  # @return [Boolean]
  def has_key?(key); end

  # Creates a shallow copy of the internal hash
  # NOTE: remove this in 3.0 in favor of save.  This is completely useless
  # with default values and configuration_context.
  #
  # === Returns
  # result of Hash#dup
  def hash_dup; end

  def initialize_mixlib_config; end

  # @return [Boolean]
  def is_default?(key); end

  # Check if Mixlib::Config has a config option.
  #
  # === Parameters
  # key<Symbol>:: The config option to check for
  #
  # === Returns
  # <True>:: If the config option exists
  # <False>:: If the config option does not exist
  #
  # @return [Boolean]
  def key?(key); end

  # Return the set of config hash keys.
  # This *only* returns hash keys which have been set by the user.  In future
  # versions this will likely be removed in favor of something more explicit.
  # For now though, we want this to match has_key?
  #
  # === Returns
  # result of Hash#keys
  def keys; end

  # Merge an incoming hash with our config options
  #
  # === Parameters
  # hash<Hash>: a hash in the same format as output by save.
  #
  # === Returns
  # self
  def merge!(hash); end

  # Allows for simple lookups and setting of config options via method calls
  # on Mixlib::Config.  If there any arguments to the method, they are used to set
  # the value of the config option.  Otherwise, it's a simple get operation.
  #
  # === Parameters
  # method_symbol<Symbol>:: The method called.  Must match a config option.
  # *args:: Any arguments passed to the method
  #
  # === Returns
  # value:: The value of the config option.
  #
  # === Raises
  # <UnknownConfigOptionError>:: If the config option does not exist and strict mode is on.
  def method_missing(method_symbol, *args); end

  # Resets all config options to their defaults.
  def reset; end

  # Restore non-default values from the given hash.
  #
  # === Parameters
  # hash<Hash>: a hash in the same format as output by save.
  #
  # === Returns
  # self
  def restore(hash); end

  # Makes a copy of any non-default values.
  #
  # This returns a shallow copy of the hash; while the hash itself is
  # duplicated a la dup, modifying data inside arrays and hashes may modify
  # the original Config object.
  #
  # === Returns
  #
  # Hash of values the user has set.
  #
  # === Examples
  #
  # For example, this config class:
  #
  #     class MyConfig < Mixlib::Config
  #       default :will_be_set, 1
  #       default :will_be_set_to_default, 1
  #       default :will_not_be_set, 1
  #       configurable(:computed_value) { |x| x*2 }
  #       config_context :group do
  #         default :will_not_be_set, 1
  #       end
  #       config_context :group_never_set
  #     end
  #
  #     MyConfig.x = 2
  #     MyConfig.will_be_set = 2
  #     MyConfig.will_be_set_to_default = 1
  #     MyConfig.computed_value = 2
  #     MyConfig.group.x = 3
  #
  # produces this:
  #
  #     MyConfig.save == {
  #       :x => 2,
  #       :will_be_set => 2,
  #       :will_be_set_to_default => 1,
  #       :computed_value => 4,
  #       :group => {
  #         :x => 3
  #       }
  #     }
  def save(include_defaults = T.unsafe(nil)); end

  # Makes a copy of any non-default values.
  #
  # This returns a shallow copy of the hash; while the hash itself is
  # duplicated a la dup, modifying data inside arrays and hashes may modify
  # the original Config object.
  #
  # === Returns
  #
  # Hash of values the user has set.
  #
  # === Examples
  #
  # For example, this config class:
  #
  #     class MyConfig < Mixlib::Config
  #       default :will_be_set, 1
  #       default :will_be_set_to_default, 1
  #       default :will_not_be_set, 1
  #       configurable(:computed_value) { |x| x*2 }
  #       config_context :group do
  #         default :will_not_be_set, 1
  #       end
  #       config_context :group_never_set
  #     end
  #
  #     MyConfig.x = 2
  #     MyConfig.will_be_set = 2
  #     MyConfig.will_be_set_to_default = 1
  #     MyConfig.computed_value = 2
  #     MyConfig.group.x = 3
  #
  # produces this:
  #
  #     MyConfig.save == {
  #       :x => 2,
  #       :will_be_set => 2,
  #       :will_be_set_to_default => 1,
  #       :computed_value => 4,
  #       :group => {
  #         :x => 3
  #       }
  #     }
  def to_hash(include_defaults = T.unsafe(nil)); end

  protected

  # Given a (nested) Hash, apply it to the config object and any contexts.
  #
  # This is preferable to converting it to the string representation with
  # the #to_dotted_hash method above.
  #
  # === Parameters
  # hash<Hash>:: The hash to apply to the config oject
  def apply_nested_hash(hash); end

  private

  def define_attr_accessor_methods(symbol); end
  def define_context(definition_blocks); end
  def define_hash_attr_accessor_methods(plural_symbol, singular_symbol); end
  def define_list_attr_accessor_methods(plural_symbol, singular_symbol); end
  def internal_get(symbol); end
  def internal_get_or_set(symbol, *args); end

  # Internal dispatch setter for config values.
  #
  # === Parameters
  # symbol<Symbol>:: Name of the method (variable setter)
  # value<Object>:: Value to be set in config hash
  def internal_set(symbol, value); end

  # Given a (nested) Hash, turn it into a single top-level hash using dots as
  # nesting notation. This allows for direction translation into method-style
  # setting of Config.
  #
  # === Parameters
  # hash<Hash>:: The hash to "de-nestify"
  # recursive_key<String>:: The existing key to prepend going forward
  #
  # === Returns
  # value:: A single-depth Hash using dot notation to indicate nesting
  def to_dotted_hash(hash, recursive_key = T.unsafe(nil)); end

  class << self
    # @private
    def extended(base); end
  end
end

class Mixlib::Config::Configurable
  # @return [Configurable] a new instance of Configurable
  def initialize(symbol); end

  def default; end

  # Returns the value of attribute default_block.
  def default_block; end

  # @return [Boolean]
  def default_block?; end

  # Returns the value of attribute default_value.
  def default_value; end

  def defaults_to(default_value = T.unsafe(nil), &block); end
  def get(config); end

  # @return [Boolean]
  def has_default; end

  # @return [Boolean]
  def has_default?; end

  # @return [Boolean]
  def is_default?(config); end

  def set(config, value); end

  # Returns the value of attribute symbol.
  def symbol; end

  def writes_value(&block); end

  # @return [Boolean]
  def writes_value?; end

  private

  def safe_dup(e); end
end

Mixlib::Config::NOT_PASSED = T.let(T.unsafe(nil), Object)
class Mixlib::Config::ReopenedConfigContextWithConfigurableError < ::StandardError; end
class Mixlib::Config::ReopenedConfigurableWithConfigContextError < ::StandardError; end
class Mixlib::Config::UnknownConfigOptionError < ::StandardError; end
Mixlib::Config::VERSION = T.let(T.unsafe(nil), String)
