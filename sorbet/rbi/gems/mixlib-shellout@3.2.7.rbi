# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `mixlib-shellout` gem.
# Please instead update this file by running `bin/tapioca gem mixlib-shellout`.

module Mixlib; end

class Mixlib::ShellOut
  include ::Mixlib::ShellOut::Unix

  # === Arguments:
  # Takes a single command, or a list of command fragments. These are used
  # as arguments to Kernel.exec. See the Kernel.exec documentation for more
  # explanation of how arguments are evaluated. The last argument can be an
  # options Hash.
  # === Options:
  # If the last argument is a Hash, it is removed from the list of args passed
  # to exec and used as an options hash. The following options are available:
  # * +user+: the user the command should run as. if an integer is given, it is
  #   used as a uid. A string is treated as a username and resolved to a uid
  #   with Etc.getpwnam
  # * +group+: the group the command should run as. works similarly to +user+
  # * +cwd+: the directory to chdir to before running the command
  # * +umask+: a umask to set before running the command. If given as an Integer,
  #   be sure to use two leading zeros so it's parsed as Octal. A string will
  #   be treated as an octal integer
  # * +returns+:  one or more Integer values to use as valid exit codes for the
  #   subprocess. This only has an effect if you call +error!+ after
  #   +run_command+.
  # * +environment+: a Hash of environment variables to set before the command
  #   is run.
  # * +timeout+: a Numeric value for the number of seconds to wait on the
  #   child process before raising an Exception. This is calculated as the
  #   total amount of time that ShellOut waited on the child process without
  #   receiving any output (i.e., IO.select returned nil). Default is 600
  #   seconds. Note: the stdlib Timeout library is not used.
  # * +input+: A String of data to be passed to the subcommand. This is
  #   written to the child process' stdin stream before the process is
  #   launched. The child's stdin stream will be a pipe, so the size of input
  #   data should not exceed the system's default pipe capacity (4096 bytes
  #   is a safe value, though on newer Linux systems the capacity is 64k by
  #   default).
  # * +live_stream+: An IO or Logger-like object (must respond to the append
  #   operator +<<+) that will receive data as ShellOut reads it from the
  #   child process. Generally this is used to copy data from the child to
  #   the parent's stdout so that users may observe the progress of
  #   long-running commands.
  # * +login+: Whether to simulate a login (set secondary groups, primary group, environment
  #   variables etc) as done by the OS in an actual login
  # === Examples:
  # Invoke find(1) to search for .rb files:
  #   find = Mixlib::ShellOut.new("find . -name '*.rb'")
  #   find.run_command
  #   # If all went well, the results are on +stdout+
  #   puts find.stdout
  #   # find(1) prints diagnostic info to STDERR:
  #   puts "error messages" + find.stderr
  #   # Raise an exception if it didn't exit with 0
  #   find.error!
  # Run a command as the +www+ user with no extra ENV settings from +/tmp+
  #   cmd = Mixlib::ShellOut.new("apachectl", "start", :user => 'www', :env => nil, :cwd => '/tmp')
  #   cmd.run_command # etc.
  #
  # @return [ShellOut] a new instance of ShellOut
  def initialize(*command_args); end

  # The command to be executed.
  def command; end

  # Working directory for the subprocess. Normally set via options to new
  def cwd; end

  # Working directory for the subprocess. Normally set via options to new
  def cwd=(_arg0); end

  # Returns the value of attribute domain.
  def domain; end

  # Sets the attribute domain
  #
  # @param value the value to set the attribute domain to.
  def domain=(_arg0); end

  # Runs windows process with elevated privileges. Required for Powershell commands which need elevated privileges
  def elevated; end

  # Runs windows process with elevated privileges. Required for Powershell commands which need elevated privileges
  def elevated=(_arg0); end

  # Environment variables that will be set for the subcommand. Refer to the
  # documentation of new to understand how ShellOut interprets this.
  def environment; end

  # Environment variables that will be set for the subcommand. Refer to the
  # documentation of new to understand how ShellOut interprets this.
  def environment=(_arg0); end

  # If #error? is true, calls +invalid!+, which raises an Exception.
  # === Returns
  # nil::: always returns nil when it does not raise
  # === Raises
  # ::ShellCommandFailed::: via +invalid!+
  def error!; end

  # Checks the +exitstatus+ against the set of +valid_exit_codes+.
  # === Returns
  # +true+ if +exitstatus+ is not in the list of +valid_exit_codes+, false
  # otherwise.
  #
  # @return [Boolean]
  def error?; end

  # The amount of time the subcommand took to execute
  def execution_time; end

  # The exit status of the subprocess. Will be nil if the command is still
  # running or died without setting an exit status (e.g., terminated by
  # `kill -9`).
  def exitstatus; end

  # Creates a String showing the output of the command, including a banner
  # showing the exact command executed. Used by +invalid!+ to show command
  # results when the command exited with an unexpected status.
  def format_for_exception; end

  # The gid that the subprocess will switch to. If the group attribute is
  # given as a group name, it is converted to a gid by Etc.getgrnam
  # TODO migrate to shellout/unix.rb
  def gid; end

  # Group the command will run as. Normally set via options passed to new
  def group; end

  # Group the command will run as. Normally set via options passed to new
  def group=(_arg0); end

  # ShellOut will push data from :input down the stdin of the subprocess.
  # Normally set via options passed to new.
  # Default: nil
  def input; end

  # ShellOut will push data from :input down the stdin of the subprocess.
  # Normally set via options passed to new.
  # Default: nil
  def input=(_arg0); end

  def inspect; end

  # Raises a ShellCommandFailed exception, appending the
  # command's stdout, stderr, and exitstatus to the exception message.
  # === Arguments
  # +msg+:  A String to use as the basis of the exception message. The
  # default explanation is very generic, providing a more informative message
  # is highly encouraged.
  # === Raises
  # ShellCommandFailed  always
  #
  # @raise [ShellCommandFailed]
  def invalid!(msg = T.unsafe(nil)); end

  # When live_stderr is set, the stderr of the subprocess will be copied to it
  # as the subprocess is running.
  def live_stderr; end

  # When live_stderr is set, the stderr of the subprocess will be copied to it
  # as the subprocess is running.
  def live_stderr=(_arg0); end

  # When live_stdout is set, the stdout of the subprocess will be copied to it
  # as the subprocess is running.
  def live_stdout; end

  # When live_stdout is set, the stdout of the subprocess will be copied to it
  # as the subprocess is running.
  def live_stdout=(_arg0); end

  # Returns the stream that both is being used by both live_stdout and live_stderr, or nil
  def live_stream; end

  # A shortcut for setting both live_stdout and live_stderr, so that both the
  # stdout and stderr from the subprocess will be copied to the same stream as
  # the subprocess is running.
  def live_stream=(stream); end

  # The log level at which ShellOut should log.
  def log_level; end

  # The log level at which ShellOut should log.
  def log_level=(_arg0); end

  # A string which will be prepended to the log message.
  def log_tag; end

  # A string which will be prepended to the log message.
  def log_tag=(_arg0); end

  # If a logger is set, ShellOut will log a message before it executes the
  # command.
  def logger; end

  # If a logger is set, ShellOut will log a message before it executes the
  # command.
  def logger=(_arg0); end

  # Whether to simulate logon as the user. Normally set via options passed to new
  # Always enabled on windows
  def login; end

  # Whether to simulate logon as the user. Normally set via options passed to new
  # Always enabled on windows
  def login=(_arg0); end

  # Returns the value of attribute password.
  def password; end

  # Sets the attribute password
  #
  # @param value the value to set the attribute password to.
  def password=(_arg0); end

  # Returns the value of attribute process_status_pipe.
  def process_status_pipe; end

  # Run the command, writing the command's standard out and standard error
  # to +stdout+ and +stderr+, and saving its exit status object to +status+
  # === Returns
  # returns   +self+; +stdout+, +stderr+, +status+, and +exitstatus+ will be
  # populated with results of the command
  # === Raises
  # * Errno::EACCES  when you are not privileged to execute the command
  # * Errno::ENOENT  when the command is not available on the system (or not
  #   in the current $PATH)
  # * CommandTimeout  when the command does not complete
  #   within +timeout+ seconds (default: 600s)
  def run_command; end

  # Returns the value of attribute sensitive.
  def sensitive; end

  # Sets the attribute sensitive
  #
  # @param value the value to set the attribute sensitive to.
  def sensitive=(_arg0); end

  # A Process::Status (or ducktype) object collected when the subprocess is
  # reaped.
  def status; end

  # Data written to stderr by the subprocess
  def stderr; end

  # Returns the value of attribute stderr_pipe.
  def stderr_pipe; end

  # Returns the value of attribute stdin_pipe.
  def stdin_pipe; end

  # Data written to stdout by the subprocess
  def stdout; end

  # Returns the value of attribute stdout_pipe.
  def stdout_pipe; end

  def timeout; end

  # The maximum time this command is allowed to run. Usually set via options
  # to new
  def timeout=(_arg0); end

  # The uid that the subprocess will switch to. If the user attribute was
  # given as a username, it is converted to a uid by Etc.getpwnam
  # TODO migrate to shellout/unix.rb
  def uid; end

  # The umask that will be set for the subcommand.
  def umask; end

  # Set the umask that the subprocess will have. If given as a string, it
  # will be converted to an integer by String#oct.
  def umask=(new_umask); end

  # User the command will run as. Normally set via options passed to new
  def user; end

  # User the command will run as. Normally set via options passed to new
  def user=(_arg0); end

  # An Array of acceptable exit codes. #error? (and #error!) use this list
  # to determine if the command was successful. Normally set via options to new
  def valid_exit_codes; end

  # An Array of acceptable exit codes. #error? (and #error!) use this list
  # to determine if the command was successful. Normally set via options to new
  def valid_exit_codes=(_arg0); end

  # TODO remove
  def with_logon; end

  # TODO remove
  def with_logon=(_arg0); end

  private

  def parse_options(opts); end
  def validate_options(opts); end
end

class Mixlib::ShellOut::CommandTimeout < ::Mixlib::ShellOut::Error; end
Mixlib::ShellOut::DEFAULT_READ_TIMEOUT = T.let(T.unsafe(nil), Integer)
class Mixlib::ShellOut::EmptyWindowsCommand < ::Mixlib::ShellOut::ShellCommandFailed; end
class Mixlib::ShellOut::Error < ::RuntimeError; end
class Mixlib::ShellOut::InvalidCommandOption < ::Mixlib::ShellOut::Error; end
Mixlib::ShellOut::READ_SIZE = T.let(T.unsafe(nil), Integer)
Mixlib::ShellOut::READ_WAIT_TIME = T.let(T.unsafe(nil), Float)
class Mixlib::ShellOut::ShellCommandFailed < ::Mixlib::ShellOut::Error; end

module Mixlib::ShellOut::Unix
  # Helper method for sgids
  def all_seconderies; end

  # The environment variables that are deduced from simulating logon
  # Only valid if login is used
  def logon_environment; end

  # Merges the two environments for the process
  def process_environment; end

  # Run the command, writing the command's standard out and standard error
  # to +stdout+ and +stderr+, and saving its exit status object to +status+
  # === Returns
  # returns   +self+; +stdout+, +stderr+, +status+, and +exitstatus+ will be
  # populated with results of the command.
  # === Raises
  # * Errno::EACCES  when you are not privileged to execute the command
  # * Errno::ENOENT  when the command is not available on the system (or not
  #   in the current $PATH)
  # * Chef::Exceptions::CommandTimeout  when the command does not complete
  #   within +timeout+ seconds (default: 600s). When this happens, ShellOut
  #   will send a TERM and then KILL to the entire process group to ensure
  #   that any grandchild processes are terminated. If the invocation of
  #   the child process spawned multiple child processes (which commonly
  #   happens if the command is passed as a single string to be interpreted
  #   by bin/sh, and bin/sh is not bash), the exit status object may not
  #   contain the correct exit code of the process (of course there is no
  #   exit code if the command is killed by SIGKILL, also).
  def run_command; end

  # The secondary groups that the subprocess will switch to.
  # Currently valid only if login is used, and is set
  # to the user's secondary groups
  def sgids; end

  # Whether we're simulating a login shell
  #
  # @return [Boolean]
  def using_login?; end

  # Option validation that is unix specific
  def validate_options(opts); end

  private

  def attempt_buffer_read; end

  # Try to reap the child process but don't block if it isn't dead yet.
  def attempt_reap; end

  # Since we call setsid the child_pgid will be the child_pid, set to negative here
  # so it can be directly used in arguments to kill, wait, etc.
  def child_pgid; end

  def child_process_status; end
  def child_stderr; end
  def child_stdin; end
  def child_stdout; end
  def close_all_pipes; end
  def configure_parent_process_file_descriptors; end

  # Replace stdout, and stderr with pipes to the parent, and close the
  # reader side of the error marshaling side channel.
  #
  # If there is no input, close STDIN so when we exec,
  # the new program will know it's never getting input ever.
  def configure_subprocess_file_descriptors; end

  def fork_subprocess; end
  def initialize_ipc; end

  # Some patch levels of ruby in wide use (in particular the ruby 1.8.6 on OSX)
  # segfault when you IO.select a pipe that's reached eof. Weak sauce.
  def open_pipes; end

  # Attempt to get a Marshaled error from the side-channel.
  # If it's there, un-marshal it and raise. If it's not there,
  # assume everything went well.
  def propagate_pre_exec_failure; end

  def read_process_status_to_buffer; end
  def read_stderr_to_buffer; end
  def read_stdout_to_buffer; end

  # Unconditionally reap the child process. This is used in scenarios where
  # we can be confident the child will exit quickly, and has not spawned
  # and grandchild processes.
  def reap; end

  def reap_errant_child; end
  def set_cwd; end
  def set_environment; end
  def set_group; end
  def set_secondarygroups; end
  def set_umask; end
  def set_user; end

  # @return [Boolean]
  def should_reap?; end

  # Keep this unbuffered for now
  def write_to_child_stdin; end
end

# "1.8.7" as a frozen string. We use this with a hack that disables GC to
# avoid segfaults on Ruby 1.8.7, so we need to allocate the fewest
# objects we possibly can.
Mixlib::ShellOut::Unix::ONE_DOT_EIGHT_DOT_SEVEN = T.let(T.unsafe(nil), String)
