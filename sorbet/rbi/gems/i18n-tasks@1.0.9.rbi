# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `i18n-tasks` gem.
# Please instead update this file by running `bin/tapioca gem i18n-tasks`.

# define all the modules to be able to use ::
module I18n
  extend ::I18n::Base

  class << self
    def cache_key_digest; end
    def cache_key_digest=(key_digest); end
    def cache_namespace; end
    def cache_namespace=(namespace); end
    def cache_store; end
    def cache_store=(store); end

    # Returns the current fallbacks implementation. Defaults to +I18n::Locale::Fallbacks+.
    def fallbacks; end

    # Sets the current fallbacks implementation. Use this to set a different fallbacks implementation.
    def fallbacks=(fallbacks); end

    # Return String or raises MissingInterpolationArgument exception.
    # Missing argument's logic is handled by I18n.config.missing_interpolation_argument_handler.
    #
    # @raise [ReservedInterpolationKey]
    def interpolate(string, values); end

    def interpolate_hash(string, values); end
    def new_double_nested_cache; end

    # @return [Boolean]
    def perform_caching?; end

    # Marks a key as reserved. Reserved keys are used internally,
    # and can't also be used for interpolation. If you are using any
    # extra keys as I18n options, you should call I18n.reserve_key
    # before any I18n.translate (etc) calls are made.
    def reserve_key(key); end

    def reserved_keys_pattern; end
  end
end

I18n::DEFAULT_INTERPOLATION_PATTERNS = T.let(T.unsafe(nil), Array)
I18n::EMPTY_HASH = T.let(T.unsafe(nil), Hash)
I18n::INTERPOLATION_PATTERN = T.let(T.unsafe(nil), Regexp)
I18n::JSON = ActiveSupport::JSON
I18n::RESERVED_KEYS = T.let(T.unsafe(nil), Array)

module I18n::Tasks
  class << self
    # Add AST-matcher to i18n-tasks
    #
    # @param matcher_class_name
    # @return self
    def add_ast_matcher(matcher_class_name); end

    # Add commands to i18n-tasks
    #
    # @param commands_module [Module]
    # @return self
    def add_commands(commands_module); end

    # Add a scanner to the default configuration.
    #
    # @param scanner_class_name [String]
    # @param scanner_opts [Hash]
    # @return self
    def add_scanner(scanner_class_name, scanner_opts = T.unsafe(nil)); end

    def gem_path; end

    # Sets the attribute verbose
    #
    # @param value the value to set the attribute verbose to.
    def verbose=(_arg0); end

    # @return [Boolean]
    def verbose?; end
  end
end

class I18n::Tasks::BaseTask
  include ::I18n::Tasks::SplitKey
  include ::I18n::Tasks::KeyPatternMatching
  include ::I18n::Tasks::PluralKeys
  include ::I18n::Tasks::References
  include ::I18n::Tasks::HtmlKeys
  include ::I18n::Tasks::UsedKeys
  include ::I18n::Tasks::IgnoreKeys
  include ::I18n::Tasks::MissingKeys
  include ::I18n::Tasks::Interpolations
  include ::I18n::Tasks::UnusedKeys
  include ::I18n::Tasks::Translation
  include ::I18n::Tasks::Logging
  include ::I18n::Tasks::Configuration
  include ::I18n::Tasks::Data
  include ::I18n::Tasks::Stats

  # @return [BaseTask] a new instance of BaseTask
  def initialize(config_file: T.unsafe(nil), **config); end

  def inspect; end
end

# When this type of error is caught:
# 1. show error message of the backtrace
# 2. exit with non-zero exit code
class I18n::Tasks::CommandError < ::StandardError
  # @return [CommandError] a new instance of CommandError
  def initialize(error = T.unsafe(nil), message); end
end

module I18n::Tasks::Concurrent; end

# A thread-safe cache.
#
# @since 0.9.25
class I18n::Tasks::Concurrent::Cache
  # @return [Cache] a new instance of Cache
  # @since 0.9.25
  def initialize; end

  # @param key [Object]
  # @return [Object] Cached or computed value.
  # @since 0.9.25
  def fetch(key, &block); end
end

# A thread-safe memoized value.
# The given computation is guaranteed to be invoked at most once.
#
# @since 0.9.25
class I18n::Tasks::Concurrent::CachedValue
  # @param computation [Proc] The computation that returns the value to cache.
  # @return [CachedValue] a new instance of CachedValue
  # @since 0.9.25
  def initialize(&computation); end

  # @return [Object] Result of the computation.
  # @since 0.9.25
  def get; end

  private

  def get_result_volatile; end
  def set_result_volatile(value); end
end

# @since 0.9.25
I18n::Tasks::Concurrent::CachedValue::NULL = T.let(T.unsafe(nil), Object)

module I18n::Tasks::Configuration
  # @return [String] default i18n locale
  def base_locale; end

  # i18n-tasks config (defaults + config/i18n-tasks.yml)
  #
  # @return [Hash{String => String,Hash,Array}]
  def config; end

  def config=(conf); end
  def config_for_inspect; end

  # evaluated configuration (as the app sees it)
  def config_sections; end

  # data config
  #  @return [Hash<adapter: String, options: Hash>]
  def data_config; end

  def file_config; end
  def ignore_config(type = T.unsafe(nil)); end
  def internal_locale; end

  # @return [Array<String>] all available locales, base_locale is always first
  def locales; end

  # translation config
  #
  # @return [Hash{String => String,Hash,Array}]
  def translation_config; end

  private

  def to_hash_from_indifferent(value); end
end

I18n::Tasks::Configuration::CONFIG_FILES = T.let(T.unsafe(nil), Array)
I18n::Tasks::Configuration::DEFAULTS = T.let(T.unsafe(nil), Hash)
I18n::Tasks::Configuration::IGNORE_TYPES = T.let(T.unsafe(nil), Array)

module I18n::Tasks::Data
  def build_tree(hash); end

  # I18n data provider
  #
  # @see I18n::Tasks::Data::FileSystem
  def data; end

  def data_forest(locales = T.unsafe(nil)); end
  def empty_forest; end

  # @return [Boolean]
  def external_key?(key, locale = T.unsafe(nil)); end

  # whether the value for key exists in locale (defaults: base_locale)
  #
  # @return [Boolean]
  def key_value?(key, locale = T.unsafe(nil)); end

  def node(key, locale = T.unsafe(nil)); end

  # @param locales [Array<String>] locales to check. Default: all.
  # @return [Array<String>] paths to data that requires normalization
  def non_normalized_paths(locales: T.unsafe(nil)); end

  # Normalize all the locale data in the store (by writing to the store).
  #
  # @param locales [Array<String>] locales to normalize. Default: all.
  # @param force_pattern_router [Boolean] Whether to use pattern router regardless of the config.
  def normalize_store!(locales: T.unsafe(nil), force_pattern_router: T.unsafe(nil)); end

  def t(key, locale = T.unsafe(nil)); end
  def t_proc(locale = T.unsafe(nil)); end
  def tree(sel); end
end

module I18n::Tasks::Data::Adapter; end

module I18n::Tasks::Data::Adapter::JsonAdapter
  class << self
    # @return [String]
    def dump(tree, opts); end

    # @return [Hash] locale tree
    def parse(str, opts); end

    private

    def parse_opts(opts); end
  end
end

module I18n::Tasks::Data::Adapter::YamlAdapter
  class << self
    # @return [String]
    def dump(tree, options); end

    # @return [Hash] locale tree
    def parse(str, options); end

    # @return [String]
    def restore_emojis(yaml); end
  end
end

I18n::Tasks::Data::Adapter::YamlAdapter::EMOJI_REGEX = T.let(T.unsafe(nil), Regexp)
I18n::Tasks::Data::DATA_DEFAULTS = T.let(T.unsafe(nil), Hash)

module I18n::Tasks::Data::FileFormats
  mixes_in_class_methods ::I18n::Tasks::Data::FileFormats::ClassMethods

  def adapter_dump(tree, format); end
  def adapter_op(op, format, tree, config); end

  # @return [Hash]
  def adapter_parse(tree, format); end

  protected

  # @return [Hash]
  def load_file(path); end

  # @return [Boolean]
  def normalized?(path, tree); end

  def read_config(format); end

  # @return [String]
  def read_file(path); end

  def write_config(format); end
  def write_tree(path, tree, sort = T.unsafe(nil)); end

  class << self
    # @private
    def included(base); end
  end
end

module I18n::Tasks::Data::FileFormats::ClassMethods
  def adapter_by_name(name); end
  def adapter_name_for_path(path); end
  def adapter_names; end

  # @param pattern [String] File.fnmatch pattern
  # @param adapter [responds to parse(string)-] hash and dump(hash)->string]
  def register_adapter(name, pattern, adapter); end
end

class I18n::Tasks::Data::FileSystem < ::I18n::Tasks::Data::FileSystemBase; end

class I18n::Tasks::Data::FileSystemBase
  include ::I18n::Tasks::Data::FileFormats
  include ::I18n::Tasks::Logging
  extend ::I18n::Tasks::Data::FileFormats::ClassMethods

  # @return [FileSystemBase] a new instance of FileSystemBase
  def initialize(config = T.unsafe(nil)); end

  # @param locale [String, Symbol]
  # @return [::I18n::Tasks::Data::Siblings]
  def [](locale); end

  # set locale tree
  #
  # @param locale [String, Symbol]
  # @param tree [::I18n::Tasks::Data::Siblings]
  def []=(locale, tree); end

  # Get available locales from the list of file names to read
  def available_locales; end

  # Returns the value of attribute base_locale.
  def base_locale; end

  # Returns the value of attribute config.
  def config; end

  def config=(config); end

  # @param locale [String, Symbol]
  # @return [::I18n::Tasks::Data::Siblings]
  def external(locale); end

  # @param locale [String, Symbol]
  # @return [::I18n::Tasks::Data::Siblings]
  def get(locale); end

  # Returns the value of attribute locales.
  def locales; end

  # Sets the attribute locales
  #
  # @param value the value to set the attribute locales to.
  def locales=(_arg0); end

  def merge!(forest); end

  # @param locale [String]
  # @return [Array<String>] paths to files that are not normalized
  def non_normalized_paths(locale); end

  # @return self
  def reload; end

  def remove_by_key!(forest); end
  def router; end

  # Sets the attribute router
  #
  # @param value the value to set the attribute router to.
  def router=(_arg0); end

  # set locale tree
  #
  # @param locale [String, Symbol]
  # @param tree [::I18n::Tasks::Data::Siblings]
  def set(locale, tree); end

  def t(key, locale); end
  def with_router(router); end
  def write(forest); end

  protected

  def filter_nil_keys!(path, data, suffix = T.unsafe(nil)); end
  def read_locale(locale, paths: T.unsafe(nil)); end
end

I18n::Tasks::Data::FileSystemBase::DEFAULTS = T.let(T.unsafe(nil), Hash)
I18n::Tasks::Data::FileSystemBase::ROUTER_NAME_ALIASES = T.let(T.unsafe(nil), Hash)
module I18n::Tasks::Data::Router; end

# Keep the path, or infer from base locale
class I18n::Tasks::Data::Router::ConservativeRouter < ::I18n::Tasks::Data::Router::PatternRouter
  # @return [ConservativeRouter] a new instance of ConservativeRouter
  def initialize(adapter, config); end

  def route(locale, forest, &block); end

  protected

  # Returns the value of attribute adapter.
  def adapter; end

  # Returns the value of attribute base_locale.
  def base_locale; end

  def base_tree; end
  def key_path(locale, key); end

  # Returns the value of attribute locales.
  def locales; end
end

# Route based on key name
class I18n::Tasks::Data::Router::PatternRouter
  include ::I18n::Tasks::KeyPatternMatching

  # @example
  #   {write:
  #   # keys matched top to bottom
  #   [['devise.*', 'config/locales/devise.%{locale}.yml'],
  #   # default catch-all (same as ['*', 'config/locales/%{locale}.yml'])
  #   'config/locales/%{locale}.yml']}
  # @option data_config
  # @param data_config [Hash] a customizable set of options
  # @return [PatternRouter] a new instance of PatternRouter
  def initialize(_adapter, data_config); end

  # Route keys to destinations
  #
  # @param forest [I18n::Tasks::Data::Tree::Siblings] forest roots are locales.
  # @return [Hash] mapping of destination => [ [key, value], ... ]
  # @yieldparam dest_path [String]
  # @yieldparam tree_slice [I18n::Tasks::Data::Tree::Siblings]
  def route(locale, forest, &block); end

  # Returns the value of attribute routes.
  def routes; end

  private

  def compile_routes(routes); end
end

module I18n::Tasks::Data::Tree; end

class I18n::Tasks::Data::Tree::Node
  include ::Enumerable
  include ::I18n::Tasks::Data::Tree::Traversal

  # @return [Node] a new instance of Node
  def initialize(key:, value: T.unsafe(nil), data: T.unsafe(nil), parent: T.unsafe(nil), children: T.unsafe(nil), warn_about_add_children_to_leaf: T.unsafe(nil)); end

  def [](key); end
  def []=(full_key, node); end
  def append(nodes); end

  # append and reparent nodes
  def append!(nodes); end

  def attributes; end

  # Returns the value of attribute children.
  def children; end

  def children=(children); end

  # @return [Boolean]
  def children?; end

  def data; end

  # @return [Boolean]
  def data?; end

  def derive(new_attr = T.unsafe(nil)); end
  def each(&block); end
  def format_value_for_inspect(value); end
  def full_key(root: T.unsafe(nil)); end
  def get(key); end
  def inspect(level = T.unsafe(nil)); end

  # Returns the value of attribute key.
  def key; end

  # @return [Boolean]
  def leaf?; end

  # Returns the value of attribute parent.
  def parent; end

  # @return [Boolean]
  def parent?; end

  # @return [Boolean]
  def reference?; end

  def root; end

  # a node with key nil is considered Empty. this is to allow for using these nodes instead of nils
  #
  # @return [Boolean]
  def root?; end

  def set(full_key, node); end
  def to_hash(sort = T.unsafe(nil)); end
  def to_json(*_arg0, &_arg1); end
  def to_nodes; end
  def to_siblings; end
  def to_yaml(*_arg0, &_arg1); end

  # Returns the value of attribute value.
  def value; end

  # Sets the attribute value
  #
  # @param value the value to set the attribute value to.
  def value=(_arg0); end

  def value_or_children_hash; end
  def walk_from_root(&visitor); end
  def walk_to_root(&visitor); end

  protected

  def dirty!; end

  class << self
    # value can be a nested hash
    def from_key_value(key, value); end
  end
end

# A list of nodes
class I18n::Tasks::Data::Tree::Nodes
  include ::Enumerable
  include ::I18n::Tasks::Data::Tree::Traversal

  # @return [Nodes] a new instance of Nodes
  def initialize(opts = T.unsafe(nil)); end

  def +(nodes); end
  def <<(other); end
  def append(other); end
  def append!(other); end
  def attributes; end
  def blank?(*_arg0, &_arg1); end
  def children(&block); end
  def children?(*_arg0); end
  def derive(new_attr = T.unsafe(nil)); end
  def each(*_arg0, &_arg1); end
  def empty?(*_arg0, &_arg1); end
  def inspect; end

  # Returns the value of attribute list.
  def list; end

  def merge!(nodes); end
  def present?(*_arg0, &_arg1); end

  # methods below change state
  def remove!(node); end

  def size(*_arg0, &_arg1); end
  def to_a(*_arg0, &_arg1); end
  def to_hash(sort = T.unsafe(nil)); end
  def to_json(*_arg0, &_arg1); end
  def to_nodes; end
  def to_yaml(*_arg0, &_arg1); end

  protected

  def dirty!; end
end

# Siblings represents a subtree sharing a common parent
# in case of an empty parent (nil) it represents a forest
# siblings' keys are unique
class I18n::Tasks::Data::Tree::Siblings < ::I18n::Tasks::Data::Tree::Nodes
  include ::I18n::Tasks::SplitKey
  include ::I18n::Tasks::PluralKeys
  extend ::I18n::Tasks::SplitKey

  # @return [Siblings] a new instance of Siblings
  def initialize(opts = T.unsafe(nil)); end

  # @return [Node] by full key
  def [](full_key); end

  # add or replace node by full key
  def []=(full_key, node); end

  def append(nodes); end
  def append!(nodes); end
  def attributes; end

  # @return [Node] by full key
  def get(full_key); end

  # Returns the value of attribute key_to_node.
  def key_to_node; end

  def merge(nodes); end

  # @param on_leaves_merge [Proc] invoked when a leaf is merged with another leaf
  def merge!(nodes, on_leaves_merge: T.unsafe(nil)); end

  # @param on_leaves_merge [Proc] invoked when a leaf is merged with another leaf
  def merge_node!(node, on_leaves_merge: T.unsafe(nil)); end

  # @param from_pattern [Regexp]
  # @param to_pattern [Regexp]
  # @param root [Boolean]
  # @return [old key => new key]
  def mv_key!(from_pattern, to_pattern, root: T.unsafe(nil)); end

  # Returns the value of attribute parent.
  def parent; end

  # methods below change state
  def remove!(node); end

  # @param nodes [Enumerable] Modified in-place.
  def remove_nodes_and_emptied_ancestors(nodes); end

  # @param nodes [Enumerable] Modified in-place.
  def remove_nodes_and_emptied_ancestors!(nodes); end

  def rename_key(key, new_key); end
  def replace_node!(node, new_node); end

  # add or replace node by full key
  def set(full_key, node); end

  def set_root_key!(new_key, data = T.unsafe(nil)); end
  def subtract_by_key(other); end
  def subtract_by_key!(other); end
  def subtract_keys(keys); end
  def subtract_keys!(keys); end

  private

  # Adds all the ancestors that only contain the given nodes as descendants to the given nodes.
  #
  # @param nodes [Set] Modified in-place.
  def add_ancestors_that_only_contain_nodes!(nodes); end

  def conditionally_warn_add_children_to_leaf(node, children); end
  def find_nodes(keys); end
  def warn_add_children_to_leaf(node); end

  class << self
    # build forest from nested hash, e.g. {'es' => { 'common' => { name => 'Nombre', 'age' => 'Edad' } } }
    # this is the native i18n gem format
    def [](hash, opts = T.unsafe(nil)); end

    # @yield [forest]
    def build_forest(opts = T.unsafe(nil), &block); end

    # build forest from [[Full Key, Value]]
    def from_flat_pairs(pairs); end

    def from_key_attr(key_attrs, opts = T.unsafe(nil), &block); end
    def from_key_names(keys, opts = T.unsafe(nil), &block); end

    # @param key_occurrences [I18n::Tasks::Scanners::KeyOccurrences]
    # @return [Siblings]
    def from_key_occurrences(key_occurrences); end

    # build forest from nested hash, e.g. {'es' => { 'common' => { name => 'Nombre', 'age' => 'Edad' } } }
    # this is the native i18n gem format
    def from_nested_hash(hash, opts = T.unsafe(nil)); end

    def null; end

    private

    def parse_parent_opt!(opts); end
  end
end

# Any Enumerable that yields nodes can mix in this module
module I18n::Tasks::Data::Tree::Traversal
  def breadth_first(&visitor); end
  def depth_first(&visitor); end

  # @return [Set<I18n::Tasks::Data::Tree::Node>]
  def get_nodes_by_key_filter(root: T.unsafe(nil), &block); end

  def grep_keys(match, opts = T.unsafe(nil)); end

  # @return [Siblings]
  def intersect_keys(other_tree, key_opts = T.unsafe(nil), &block); end

  def key_names(root: T.unsafe(nil)); end
  def key_values(root: T.unsafe(nil)); end

  # @option root
  # @param root [Hash] a customizable set of options
  def keys(root: T.unsafe(nil), &visitor); end

  def leaves(&visitor); end
  def levels(&block); end
  def nodes(&block); end
  def root_key_value_data(sort = T.unsafe(nil)); end
  def root_key_values(sort = T.unsafe(nil)); end

  # @return [Siblings]
  def select_keys(root: T.unsafe(nil), &block); end

  # @return [Siblings]
  def select_keys!(root: T.unsafe(nil), &block); end

  # Select the nodes for which the block returns true. Pre-order traversal.
  #
  # @return [Siblings] a new tree
  def select_nodes(&block); end

  # Select the nodes for which the block returns true. Pre-order traversal.
  #
  # @return [Siblings] self
  def select_nodes!(&block); end

  def set_each_value!(val_pattern, key_pattern = T.unsafe(nil), &value_proc); end
end

module I18n::Tasks::HtmlKeys
  # @return [Boolean]
  def html_key?(full_key, locale); end
end

I18n::Tasks::HtmlKeys::HTML_KEY_PATTERN = T.let(T.unsafe(nil), Regexp)
I18n::Tasks::HtmlKeys::MAYBE_PLURAL_HTML_KEY_PATTERN = T.let(T.unsafe(nil), Regexp)

module I18n::Tasks::IgnoreKeys
  # whether to ignore the key
  # will also apply global ignore rules
  #
  # @param ignore_type [:missing, :unused, :eq_base]
  # @return [Boolean]
  def ignore_key?(key, ignore_type, locale = T.unsafe(nil)); end

  # @param type [nil, :missing, :unused, :eq_base] type
  # @param locale [String] only when type is :eq_base
  # @return [Regexp] a regexp that matches all the keys ignored for the type (and locale)
  def ignore_pattern(type, locale = T.unsafe(nil)); end
end

module I18n::Tasks::Interpolations
  def inconsistent_interpolations(locales: T.unsafe(nil), base_locale: T.unsafe(nil)); end

  class << self
    # Returns the value of attribute variable_regex.
    def variable_regex; end

    # Sets the attribute variable_regex
    #
    # @param value the value to set the attribute variable_regex to.
    def variable_regex=(_arg0); end
  end
end

module I18n::Tasks::KeyPatternMatching
  extend ::I18n::Tasks::KeyPatternMatching

  # convert pattern to regex
  # In patterns:
  #      *     is like .* in regexs
  #      :     matches a single key
  #   { a, b.c } match any in set, can use : and *, match is captured
  def compile_key_pattern(key_pattern); end

  # one regex to match any
  def compile_patterns_re(key_patterns); end

  def key_pattern_re_body(key_pattern); end
end

I18n::Tasks::KeyPatternMatching::MATCH_NOTHING = T.let(T.unsafe(nil), Regexp)

module I18n::Tasks::LocaleList
  private

  # @return locales converted to strings, with base locale first, the rest sorted alphabetically
  def normalize_locale_list(locales, base_locale, include_base = T.unsafe(nil)); end

  class << self
    # @return locales converted to strings, with base locale first, the rest sorted alphabetically
    def normalize_locale_list(locales, base_locale, include_base = T.unsafe(nil)); end
  end
end

module I18n::Tasks::LocalePathname
  class << self
    def replace_locale(path, from, to); end

    private

    def path_locale_re(locale); end
  end
end

module I18n::Tasks::Logging
  private

  def log_error(message); end
  def log_stderr(*args); end
  def log_verbose(message = T.unsafe(nil)); end
  def log_warn(message); end
  def program_name; end
  def warn_deprecated(message); end

  class << self
    def log_error(message); end
    def log_stderr(*args); end
    def log_verbose(message = T.unsafe(nil)); end
    def log_warn(message); end
    def program_name; end
    def warn_deprecated(message); end
  end
end

I18n::Tasks::Logging::MUTEX = T.let(T.unsafe(nil), Thread::Mutex)
I18n::Tasks::Logging::PROGRAM_NAME = T.let(T.unsafe(nil), String)

module I18n::Tasks::MissingKeys
  # @param forest [::I18n::Tasks::Data::Tree::Siblings]
  # @yield [::I18n::Tasks::Data::Tree::Node]
  # @yieldreturn [Boolean] whether to collapse the node
  def collapse_same_key_in_locales!(forest); end

  def eq_base_keys(opts = T.unsafe(nil)); end
  def equal_values_tree(locale, compare_to = T.unsafe(nil)); end

  # Loads rails-i18n pluralization config for the given locale.
  def load_rails_i18n_pluralization!(locale); end

  # @return [Boolean]
  def locale_key_missing?(locale, key); end

  def missing_diff_forest(locales, base = T.unsafe(nil)); end

  # keys present in compared_to, but not in locale
  def missing_diff_tree(locale, compared_to = T.unsafe(nil)); end

  # @param types [:used, :diff, :plural] all if `nil`.
  # @return [Siblings]
  def missing_keys(locales: T.unsafe(nil), types: T.unsafe(nil), base_locale: T.unsafe(nil)); end

  def missing_keys_types; end
  def missing_plural_forest(locales, _base = T.unsafe(nil)); end
  def missing_used_forest(locales, _base = T.unsafe(nil)); end

  # keys used in the code missing translations in locale
  def missing_used_tree(locale); end

  def required_plural_keys_for_locale(locale); end

  private

  def alternate_locale_from(locale); end
  def plural_keys_for_locale(locale); end
  def set_from_rails_i18n_pluralization(configuration, locale); end

  class << self
    def missing_keys_types; end
  end
end

I18n::Tasks::MissingKeys::MISSING_TYPES = T.let(T.unsafe(nil), Array)

module I18n::Tasks::PluralKeys
  def collapse_plural_nodes!(tree); end

  # @param key [String] i18n key
  # @param locale [String] to pull key data from
  # @return [String] the base form if the key is a specific plural form (e.g. apple for apple.many), the key otherwise.
  def depluralize_key(key, locale = T.unsafe(nil)); end

  # @return [Boolean]
  def non_plural_other?(s); end

  # @return [Boolean]
  def plural_forms?(s); end

  # @param tree [::I18n::Tasks::Data::Tree::Traversal]
  # @yieldparam node [::I18n::Tasks::Data::Tree::Node] plural node
  def plural_nodes(tree); end

  # @return [Boolean]
  def plural_suffix?(key); end
end

# Ref: http://cldr.unicode.org/index/cldr-spec/plural-rules
I18n::Tasks::PluralKeys::CLDR_CATEGORY_KEYS = T.let(T.unsafe(nil), Array)

I18n::Tasks::PluralKeys::PLURAL_KEY_RE = T.let(T.unsafe(nil), Regexp)
I18n::Tasks::PluralKeys::PLURAL_KEY_SUFFIXES = T.let(T.unsafe(nil), Set)

module I18n::Tasks::References
  # Given a raw usage tree and a tree of reference keys in the data, return 3 trees:
  # 1. Raw references -- a subset of the usages tree with keys that are reference key usages.
  # 2. Resolved references -- all the used references in their fully resolved form.
  # 3. Reference keys -- all the used reference keys.
  def process_references(usages, data_refs = T.unsafe(nil)); end

  private

  # @param ref_data [Hash]
  # @param new_resolved_refs [I18n::Tasks::Data::Tree::Siblings]
  def add_occurences!(ref_data, new_resolved_refs); end

  # Given a forest of references, merge trees into one tree, ensuring there are no conflicting references.
  #
  # @param roots [I18n::Tasks::Data::Tree::Siblings]
  # @return [I18n::Tasks::Data::Tree::Siblings]
  def merge_reference_trees(roots); end

  # @param ref [I18n::Tasks::Data::Tree::Node]
  # @param usage [I18n::Tasks::Data::Tree::Node]
  # @param raw_refs [I18n::Tasks::Data::Tree::Siblings]
  # @param resolved_refs [I18n::Tasks::Data::Tree::Siblings]
  # @param refs [I18n::Tasks::Data::Tree::Siblings]
  def process_leaf!(ref, usage, raw_refs, resolved_refs, refs); end

  # @param ref [I18n::Tasks::Data::Tree::Node]
  # @param usage [I18n::Tasks::Data::Tree::Node]
  # @param raw_refs [I18n::Tasks::Data::Tree::Siblings]
  # @param resolved_refs [I18n::Tasks::Data::Tree::Siblings]
  # @param refs [I18n::Tasks::Data::Tree::Siblings]
  def process_non_leaf!(ref, usage, raw_refs, resolved_refs, refs); end
end

module I18n::Tasks::Scanners; end
module I18n::Tasks::Scanners::AstMatchers; end

class I18n::Tasks::Scanners::AstMatchers::BaseMatcher
  # @return [BaseMatcher] a new instance of BaseMatcher
  def initialize(scanner:); end

  def convert_to_key_occurrences(send_node, method_name, location: T.unsafe(nil)); end

  protected

  # Extract an array as a single string.
  #
  # @param array_join_with [String] joiner of the array elements.
  # @param array_flatten [Boolean] if true, nested arrays are flattened,
  #   otherwise their source is copied and surrounded by #{}.
  # @param array_reject_blank [Boolean] if true, empty strings and `nil`s are skipped.
  # @return [String, nil] `nil` is returned only when a dynamic value is encountered in strict mode.
  def extract_array_as_string(node, array_join_with:, array_flatten: T.unsafe(nil), array_reject_blank: T.unsafe(nil)); end

  # Extract a hash pair with a given literal key.
  #
  # @param node [AST::Node] a node of type `:hash`.
  # @param key [String] node key as a string (indifferent symbol-string matching).
  # @return [AST::Node, nil] a node of type `:pair` or nil.
  def extract_hash_pair(node, key); end

  # If the node type is of `%i(sym str int false true)`, return the value as a string.
  # Otherwise, if `config[:strict]` is `false` and the type is of `%i(dstr dsym)`,
  # return the source as if it were a string.
  #
  # @param node [Parser::AST::Node]
  # @param array_join_with [String, nil] if set to a string, arrays will be processed and their elements joined.
  # @param array_flatten [Boolean] if true, nested arrays are flattened,
  #   otherwise their source is copied and surrounded by #{}. No effect unless `array_join_with` is set.
  # @param array_reject_blank [Boolean] if true, empty strings and `nil`s are skipped.
  #   No effect unless `array_join_with` is set.
  # @return [String, nil] `nil` is returned only when a dynamic value is encountered in strict mode
  #   or the node type is not supported.
  def extract_string(node, array_join_with: T.unsafe(nil), array_flatten: T.unsafe(nil), array_reject_blank: T.unsafe(nil)); end
end

class I18n::Tasks::Scanners::AstMatchers::MessageReceiversMatcher < ::I18n::Tasks::Scanners::AstMatchers::BaseMatcher
  # @return [MessageReceiversMatcher] a new instance of MessageReceiversMatcher
  def initialize(scanner:, receivers:, message:); end

  # @param send_node [Parser::AST::Node]
  # @param method_name [Symbol, nil]
  # @param location [Parser::Source::Map]
  # @return [nil, [key, Occurrence]] full absolute key name and the occurrence.
  def convert_to_key_occurrences(send_node, method_name, location: T.unsafe(nil)); end

  private

  def full_key(receiver:, key:, location:, calling_method:); end

  # @return [Boolean]
  def node_match?(node); end

  def process_options(node:, key:); end
end

class I18n::Tasks::Scanners::ErbAstProcessor
  include ::AST::Processor::Mixin

  # @return [ErbAstProcessor] a new instance of ErbAstProcessor
  def initialize; end

  # @param node [::Parser::AST::Node]
  # @return [::Parser::AST::Node]
  def handler_missing(node); end

  def on_code(node); end
  def process_and_extract_comments(ast); end

  private

  # Convert ERB-comments to ::Parser::Source::Comment and skip processing node
  #
  # @param node Parser::AST::Node Potential comment node
  # @return Parser::AST::Node or nil
  def handle_comment(node); end

  # @return [Boolean]
  def node?(node); end
end

# Scan for I18n.translate calls in ERB-file better-html and ASTs
class I18n::Tasks::Scanners::ErbAstScanner < ::I18n::Tasks::Scanners::RubyAstScanner
  # @return [ErbAstScanner] a new instance of ErbAstScanner
  def initialize(**args); end

  private

  # Convert BetterHtml nodes to Parser::AST::Node
  #
  # @param node BetterHtml::Parser::AST::Node
  # @return Parser::AST::Node
  def convert_better_html(node); end

  # Parse file on path and returns AST and comments.
  #
  # @param path Path to file to parse
  # @return [{Parser::AST::Node}, [Parser::Source::Comment]]
  def path_to_ast_and_comments(path); end
end

# A base class for a scanner that analyses files.
#
# @abstract The child must implement {#scan_file}.
# @since 0.9.0
class I18n::Tasks::Scanners::FileScanner < ::I18n::Tasks::Scanners::Scanner
  # @return [FileScanner] a new instance of FileScanner
  # @since 0.9.0
  def initialize(config: T.unsafe(nil), file_finder_provider: T.unsafe(nil), file_reader: T.unsafe(nil)); end

  # @since 0.9.0
  def config; end

  # @return [Array<Results::KeyOccurrences>] the keys found by this scanner and their occurrences.
  # @since 0.9.0
  def keys; end

  protected

  # @note This method is cached, it will only access the filesystem on the first invocation.
  # @since 0.9.0
  def find_files; end

  # Read a file. Reads of the same path are cached.
  #
  # @param path [String]
  # @return [String] file contents
  # @since 0.9.0
  def read_file(path); end

  # Extract all occurrences of translate calls from the file at the given path.
  #
  # @return [Array<[key, Results::KeyOccurrence]>] each occurrence found in the file
  # @since 0.9.0
  def scan_file(_path); end

  # Traverse the paths and yield the matching ones.
  #
  # @note This method is cached, it will only access the filesystem on the first invocation.
  # @since 0.9.0
  def traverse_files(&block); end
end

module I18n::Tasks::Scanners::Files; end

# Finds the files in the specified search paths with support for exclusion / inclusion patterns.
# Wraps a {FileFinder} and caches the results.
#
# @note This class is thread-safe. All methods are cached.
# @since 0.9.0
class I18n::Tasks::Scanners::Files::CachingFileFinder < ::I18n::Tasks::Scanners::Files::FileFinder
  # @param paths [Array<String>] {Find.find}-compatible paths to traverse,
  #   absolute or relative to the working directory.
  # @param only [Array<String>, nil] {File.fnmatch}-compatible patterns files to include.
  #   Files not matching any of the inclusion patterns will be excluded.
  # @param exclude [Arry<String>] {File.fnmatch}-compatible patterns of files to exclude.
  #   Files matching any of the exclusion patterns will be excluded even if they match an inclusion pattern.
  # @return [CachingFileFinder] a new instance of CachingFileFinder
  # @since 0.9.0
  def initialize(**args); end

  # @note This method is cached, it will only access the filesystem on the first invocation.
  # @return [Array<String>] found files
  # @since 0.9.0
  def find_files; end

  private

  # Traverse the paths and yield the matching ones.
  #
  # @note This method is cached, it will only access the filesystem on the first invocation.
  # @return [Array<of block results>]
  # @since 0.9.0
  # @yieldparam path [String] the path of the found file.
  def uncached_find_files; end
end

# Finds the files and provides their contents.
#
# @note This class is thread-safe. All methods are cached.
# @since 0.9.0
class I18n::Tasks::Scanners::Files::CachingFileFinderProvider
  # @param exclude [Array<String>]
  # @return [CachingFileFinderProvider] a new instance of CachingFileFinderProvider
  # @since 0.9.0
  def initialize(exclude: T.unsafe(nil)); end

  # Initialize a {CachingFileFinder} or get one from cache based on the constructor arguments.
  #
  # @param paths [Array<String>] {Find.find}-compatible paths to traverse,
  #   absolute or relative to the working directory.
  # @param only [Array<String>, nil] {File.fnmatch}-compatible patterns files to include.
  #   Files not matching any of the inclusion patterns will be excluded.
  # @param exclude [Arry<String>] {File.fnmatch}-compatible patterns of files to exclude.
  #   Files matching any of the exclusion patterns will be excluded even if they match an inclusion pattern.
  # @return [CachingFileFinder]
  # @since 0.9.0
  def get(**file_finder_args); end
end

# Reads the files in 'rb' mode and UTF-8 encoding.
# Wraps a {FileReader} and caches the results.
#
# @note This class is thread-safe. All methods are cached.
# @since 0.9.0
class I18n::Tasks::Scanners::Files::CachingFileReader < ::I18n::Tasks::Scanners::Files::FileReader
  # @return [CachingFileReader] a new instance of CachingFileReader
  # @since 0.9.0
  def initialize; end

  # Return the contents of the file at the given path.
  # The file is read in the 'rb' mode and UTF-8 encoding.
  #
  # @note This method is cached, it will only access the filesystem on the first invocation.
  # @param path [String] Path to the file, absolute or relative to the working directory.
  # @return [String] file contents
  # @since 0.9.0
  def read_file(path); end
end

# Finds the files in the specified search paths with support for exclusion / inclusion patterns.
#
# @since 0.9.0
class I18n::Tasks::Scanners::Files::FileFinder
  include ::I18n::Tasks::Logging

  # @param paths [Array<String>] {Find.find}-compatible paths to traverse,
  #   absolute or relative to the working directory.
  # @param only [Array<String>, nil] {File.fnmatch}-compatible patterns files to include.
  #   Files not matching any of the inclusion patterns will be excluded.
  # @param exclude [Arry<String>] {File.fnmatch}-compatible patterns of files to exclude.
  #   Files matching any of the exclusion patterns will be excluded even if they match an inclusion pattern.
  # @return [FileFinder] a new instance of FileFinder
  # @since 0.9.0
  def initialize(paths: T.unsafe(nil), only: T.unsafe(nil), exclude: T.unsafe(nil)); end

  # @return [Array<String>] found files
  # @since 0.9.0
  def find_files; end

  # Traverse the paths and yield the matching ones.
  #
  # @return [Array<of block results>]
  # @since 0.9.0
  # @yield [path]
  # @yieldparam path [String] the path of the found file.
  def traverse_files(&block); end

  private

  # @param path [String]
  # @param globs [Array<String>]
  # @return [Boolean]
  # @since 0.9.0
  def path_fnmatch_any?(path, globs); end
end

# Reads the files in 'rb' mode and UTF-8 encoding.
#
# @since 0.9.0
class I18n::Tasks::Scanners::Files::FileReader
  # Return the contents of the file at the given path.
  # The file is read in the 'rb' mode and UTF-8 encoding.
  #
  # @param path [String] Path to the file, absolute or relative to the working directory.
  # @return [String] file contents
  # @since 0.9.0
  def read_file(path); end
end

class I18n::Tasks::Scanners::LocalRubyParser
  # @return [LocalRubyParser] a new instance of LocalRubyParser
  def initialize(ignore_blocks: T.unsafe(nil)); end

  # Normalize location for comment
  #
  # @param comment [Parser::Source::Comment] A comment with local location
  # @param location [Parser::Source::Map] Global location for the parsed string
  # @return [Parser::Source::Comment]
  def normalize_comment_location(comment, location); end

  # @param node [Parser::AST::Node] Node in parsed code
  # @param location [Parser::Source::Map] Global location for the parsed string
  # @return [Parser::AST::Node]
  def normalize_location(node, location); end

  # Parse string and normalize location
  def parse(source, location: T.unsafe(nil)); end

  # Calculate location relative to a global location
  #
  # @param global_location [Parser::Source::Map] Global location where the code was parsed
  # @param local_location [Parser::Source::Map] Local location in the parsed string
  # @return [Parser::Source::Map]
  def updated_location(global_location, local_location); end
end

# ignore_blocks feature inspired by shopify/better-html
# https://github.com/Shopify/better-html/blob/087943ffd2a5877fa977d71532010b0c91239519/lib/better_html/test_helper/ruby_node.rb#L24
I18n::Tasks::Scanners::LocalRubyParser::BLOCK_EXPR = T.let(T.unsafe(nil), Regexp)

module I18n::Tasks::Scanners::OccurrenceFromPosition
  # Given a path to a file, its contents and a position in the file,
  # return a {Results::Occurrence} at the position until the end of the line.
  #
  # @param path [String]
  # @param contents [String] contents of the file at the path.
  # @param position [Integer] position just before the beginning of the match.
  # @return [Results::Occurrence]
  def occurrence_from_position(path, contents, position, raw_key: T.unsafe(nil)); end
end

# Maps the provided patterns to keys.
class I18n::Tasks::Scanners::PatternMapper < ::I18n::Tasks::Scanners::FileScanner
  include ::I18n::Tasks::Scanners::RelativeKeys
  include ::I18n::Tasks::Scanners::OccurrenceFromPosition
  include ::I18n::Tasks::Scanners::RubyKeyLiterals

  # @param patterns [Array<[String, String]> the list of pattern-key pairs
  # the patterns follow the regular expression syntax, with a syntax addition for matching
  # string/symbol literals: you can include %{key} in the pattern, and it will be converted to
  # a named capture group, capturing ruby strings and symbols, that can then be used in the key:
  #
  #     patterns: [['Spree\.t[( ]\s*%{key}', 'spree.%{key}']]
  #
  # All of the named capture groups are interpolated into the key with %{group_name} interpolations.] atterns [Array<[String, String]> the list of pattern-key pairs
  #   the patterns follow the regular expression syntax, with a syntax addition for matching
  #   string/symbol literals: you can include %{key} in the pattern, and it will be converted to
  #   a named capture group, capturing ruby strings and symbols, that can then be used in the key:
  #
  #   patterns: [['Spree\.t[( ]\s*%{key}', 'spree.%{key}']]
  #
  #   All of the named capture groups are interpolated into the key with %{group_name} interpolations.
  # @return [PatternMapper] a new instance of PatternMapper
  def initialize(config:, **args); end

  protected

  # @return [Array<[absolute key, Results::Occurrence]>]
  def scan_file(path); end

  private

  def configure_patterns(patterns); end
end

I18n::Tasks::Scanners::PatternMapper::KEY_GROUP = T.let(T.unsafe(nil), String)

# Scan for I18n.t usages using a simple regular expression.
class I18n::Tasks::Scanners::PatternScanner < ::I18n::Tasks::Scanners::FileScanner
  include ::I18n::Tasks::Scanners::RelativeKeys
  include ::I18n::Tasks::Scanners::OccurrenceFromPosition
  include ::I18n::Tasks::Scanners::RubyKeyLiterals

  # @return [PatternScanner] a new instance of PatternScanner
  def initialize(**args); end

  protected

  def closest_method(occurrence); end
  def default_pattern; end

  # @return [Boolean]
  def exclude_line?(line, path); end

  def first_argument_re; end

  # @return [Boolean]
  def key_relative_to_method?(path); end

  # @param match [MatchData]
  # @param path [String]
  # @return [String] full absolute key name
  def match_to_key(match, path, location); end

  # Extract i18n keys from file based on the pattern which must capture the key literal.
  #
  # @return [Array<[key, Results::Occurrence]>] each occurrence found in the file
  def scan_file(path); end

  # This method only exists for backwards compatibility with monkey-patches and plugins
  def translate_call_re; end

  # @return [Boolean]
  def valid_key?(key); end
end

I18n::Tasks::Scanners::PatternScanner::IGNORE_LINES = T.let(T.unsafe(nil), Hash)
I18n::Tasks::Scanners::PatternScanner::TRANSLATE_CALL_RE = T.let(T.unsafe(nil), Regexp)
I18n::Tasks::Scanners::PatternScanner::VALID_KEY_RE_DYNAMIC = T.let(T.unsafe(nil), Regexp)

# Scans for I18n.t(key, scope: ...) usages
# both scope: "literal", and scope: [:array, :of, 'literals'] forms are supported
# Caveat: scope is only detected when it is the first argument
class I18n::Tasks::Scanners::PatternWithScopeScanner < ::I18n::Tasks::Scanners::PatternScanner
  protected

  def default_pattern; end

  # match a limited subset of code expressions (no parenthesis, commas, etc)
  def expr_re; end

  # extract literal or array of literals
  # returns nil on any other input
  def extract_literal_or_array_of_literals(s); end

  # parse expressions with literals and variable
  def first_argument_re; end

  # Given
  #
  # @param match [MatchData]
  # @param path [String]
  # @return [String] full absolute key name with scope resolved if any
  def match_to_key(match, path, location); end

  # scope: literal or code expression or an array of these
  def scope_arg_re; end

  # strip literals, convert expressions to #{interpolations}
  def strip_literal(val); end
end

module I18n::Tasks::Scanners::RelativeKeys
  # @param key [String] relative i18n key (starts with a .)
  # @param path [String] path to the file containing the key
  # @param roots [Array<String>] paths to relative roots
  # @param calling_method [#call, Symbol, String, false, nil]
  # @return [String] absolute version of the key
  def absolute_key(key, path, roots: T.unsafe(nil), exclude_method_name_paths: T.unsafe(nil), calling_method: T.unsafe(nil)); end

  private

  # Expand a path and add a trailing {File::SEPARATOR}
  #
  # @param path [String] relative path
  # @return [String] absolute path, with a trailing {File::SEPARATOR}.
  def expand_path(path); end

  # Detect the appropriate relative path root
  #
  # @param path [String] /full/path
  # @param roots [Array<String>] array of full paths
  # @return [String] the closest ancestor root for path, with a trailing {File::SEPARATOR}.
  def path_root(path, roots); end

  # @param normalized_path [String] path/relative/to/a/root
  # @param calling_method [#call, Symbol, String, false, nil]
  def prefix(normalized_path, calling_method: T.unsafe(nil)); end
end

I18n::Tasks::Scanners::RelativeKeys::DOT = T.let(T.unsafe(nil), String)
module I18n::Tasks::Scanners::Results; end

# A scanned key and all its occurrences.
#
# @note This is a value type. Equality and hash code are determined from the attributes.
class I18n::Tasks::Scanners::Results::KeyOccurrences
  # @return [KeyOccurrences] a new instance of KeyOccurrences
  def initialize(key:, occurrences:); end

  def ==(other); end

  # @return [Boolean]
  def eql?(other); end

  def hash; end
  def inspect; end

  # @return [String] the key.
  def key; end

  # @return [Array<Occurrence>] the key's occurrences.
  def occurrences; end

  class << self
    # Merge {KeyOccurrences} in an {Enumerable<KeyOccurrences>} so that in the resulting {Array<KeyOccurrences>}:
    # * Each key occurs only once.
    # * {Occurrence}s from multiple instances of the key are merged.
    # * The order of keys is preserved, occurrences are ordered by {Occurrence#path}.
    #
    # @param keys_occurrences [Enumerable<KeyOccurrences>]
    # @return [Array<KeyOccurrences>] a new array.
    def merge_keys(keys_occurrences); end
  end
end

# The occurrence of some key in a file.
#
# @note This is a value type. Equality and hash code are determined from the attributes.
class I18n::Tasks::Scanners::Results::Occurrence
  # @param path [String]
  # @param pos [Integer]
  # @param line_num [Integer]
  # @param line_pos [Integer]
  # @param line [String]
  # @param raw_key [String, nil]
  # @param default_arg [String, nil]
  # @return [Occurrence] a new instance of Occurrence
  def initialize(path:, pos:, line_num:, line_pos:, line:, raw_key: T.unsafe(nil), default_arg: T.unsafe(nil)); end

  def ==(other); end

  # @return [String, nil] the value of the `default:` argument of the translate call.
  def default_arg; end

  # @return [Boolean]
  def eql?(other); end

  def hash; end
  def inspect; end

  # @return [String] the line of the occurrence, excluding the last LF or CRLF.
  def line; end

  # @return [Integer] line number of the occurrence, counting from 1.
  def line_num; end

  # @return [Integer] position of the start of the occurrence in the line, counting from 1.
  def line_pos; end

  # @return [String] source path relative to the current working directory.
  def path; end

  # @return [Integer] count of characters in the file before the occurrence.
  def pos; end

  # @return [String, nil] the raw key (for relative keys and references)
  def raw_key; end

  # @return [String, nil] the raw key (for relative keys and references)
  def raw_key=(_arg0); end

  class << self
    # @param raw_key [String]
    # @param range [Parser::Source::Range]
    # @param default_arg [String, nil]
    # @return [Results::Occurrence]
    def from_range(raw_key:, range:, default_arg: T.unsafe(nil)); end
  end
end

class I18n::Tasks::Scanners::RubyAstCallFinder
  include ::AST::Processor::Mixin

  # @param root_node [Parser::AST:Node]
  # @return [Pair<Parser::AST::Node, method_name as string>] for all nodes with :send type
  def collect_calls(root_node); end

  def handler_missing(node); end
  def on_def(node); end
  def on_send(send_node); end
end

# Scan for I18n.translate calls using whitequark/parser
class I18n::Tasks::Scanners::RubyAstScanner < ::I18n::Tasks::Scanners::FileScanner
  include ::I18n::Tasks::Scanners::RelativeKeys
  include ::AST::Sexp

  # @return [RubyAstScanner] a new instance of RubyAstScanner
  def initialize(**args); end

  protected

  # Convert {Parser::AST::Node} to occurrences.
  #
  # @param ast [Parser::Source::Comment]
  # @return [nil, [key, Occurrence]] full absolute key name and the occurrence.
  def ast_to_occurences(ast); end

  # Convert an array of {Parser::Source::Comment} to occurrences.
  #
  # @param path Path to file
  # @param ast Parser::AST::Node
  # @param comments [Parser::Source::Comment]
  # @return [nil, [key, Occurrence]] full absolute key name and the occurrence.
  def comments_to_occurences(path, ast, comments); end

  # @return [Boolean]
  def keys_relative_to_calling_method?(path); end

  # Create an {Parser::Source::Buffer} with the given contents.
  # The contents are assigned a {Parser::Source::Buffer#raw_source}.
  #
  # @param path [String] Path to assign as the buffer name.
  # @param contents [String]
  # @return [Parser::Source::Buffer] file contents
  def make_buffer(path, contents = T.unsafe(nil)); end

  # Parse file on path and returns AST and comments.
  #
  # @param path Path to file to parse
  # @return [{Parser::AST::Node}, [Parser::Source::Comment]]
  def path_to_ast_and_comments(path); end

  # Extract all occurrences of translate calls from the file at the given path.
  #
  # @return [Array<[key, Results::KeyOccurrence]>] each occurrence found in the file
  def scan_file(path); end

  def setup_matchers; end
end

I18n::Tasks::Scanners::RubyAstScanner::MAGIC_COMMENT_PREFIX = T.let(T.unsafe(nil), Regexp)

module I18n::Tasks::Scanners::RubyKeyLiterals
  # Match literals:
  # * String: '', "#{}"
  # * Symbol: :sym, :'', :"#{}"
  def literal_re; end

  # remove the leading colon and unwrap quotes from the key match
  #
  # @param literal [String] e.g: "key", 'key', or :key.
  # @return [String] key
  def strip_literal(literal); end

  # @return [Boolean]
  def valid_key?(key); end
end

I18n::Tasks::Scanners::RubyKeyLiterals::LITERAL_RE = T.let(T.unsafe(nil), Regexp)
I18n::Tasks::Scanners::RubyKeyLiterals::VALID_KEY_CHARS = T.let(T.unsafe(nil), Regexp)
I18n::Tasks::Scanners::RubyKeyLiterals::VALID_KEY_RE = T.let(T.unsafe(nil), Regexp)

# Describes the API of a scanner.
#
# @abstract
# @since 0.9.0
class I18n::Tasks::Scanners::Scanner
  # @abstract
  # @return [Array<Results::KeyOccurrences>] the keys found by this scanner and their occurrences.
  # @since 0.9.0
  def keys; end
end

# Run multiple {Scanner Scanners} and merge their results.
#
# @note The scanners are run concurrently. A thread is spawned per each scanner.
# @since 0.9.0
class I18n::Tasks::Scanners::ScannerMultiplexer < ::I18n::Tasks::Scanners::Scanner
  # @param scanners [Array<Scanner>]
  # @return [ScannerMultiplexer] a new instance of ScannerMultiplexer
  # @since 0.9.0
  def initialize(scanners:); end

  # Collect the results of all the scanners. Occurrences of a key from multiple scanners are merged.
  #
  # @note The scanners are run concurrently. A thread is spawned per each scanner.
  # @return [Array<Results::KeyOccurrences>] the keys found by this scanner and their occurrences.
  # @since 0.9.0
  def keys; end

  private

  # @return [Array<Array<Results::KeyOccurrences>>]
  # @since 0.9.0
  def collect_results; end
end

module I18n::Tasks::SplitKey
  private

  # yield each key part
  # dots inside braces or parenthesis are not split on
  def key_parts(key, &block); end

  def last_key_part(key); end

  # split a key by dots (.)
  # dots inside braces or parenthesis are not split on
  #
  # split_key 'a.b'      # => ['a', 'b']
  # split_key 'a.#{b.c}' # => ['a', '#{b.c}']
  # split_key 'a.b.c', 2 # => ['a', 'b.c']
  def split_key(key, max = T.unsafe(nil)); end

  class << self
    # yield each key part
    # dots inside braces or parenthesis are not split on
    def key_parts(key, &block); end

    def last_key_part(key); end

    # split a key by dots (.)
    # dots inside braces or parenthesis are not split on
    #
    # split_key 'a.b'      # => ['a', 'b']
    # split_key 'a.#{b.c}' # => ['a', '#{b.c}']
    # split_key 'a.b.c', 2 # => ['a', 'b.c']
    def split_key(key, max = T.unsafe(nil)); end
  end
end

I18n::Tasks::SplitKey::PARENS = T.let(T.unsafe(nil), Hash)
I18n::Tasks::SplitKey::PARENS_ZEROS = T.let(T.unsafe(nil), Array)

module I18n::Tasks::Stats
  def forest_stats(forest); end
end

module I18n::Tasks::StringInterpolation
  private

  def interpolate_soft(s, t = T.unsafe(nil)); end

  class << self
    def interpolate_soft(s, t = T.unsafe(nil)); end
  end
end

module I18n::Tasks::Translation
  # @param forest [I18n::Tasks::Tree::Siblings] to translate to the locales of its root nodes
  # @param from [String] locale
  # @param backend [:deepl, :google, :yandex]
  # @return [I18n::Tasks::Tree::Siblings] translated forest
  def translate_forest(forest, from:, backend: T.unsafe(nil)); end
end

module I18n::Tasks::Translators; end

class I18n::Tasks::Translators::BaseTranslator
  # @param i18n_tasks [I18n::Tasks::BaseTask]
  # @return [BaseTranslator] a new instance of BaseTranslator
  def initialize(i18n_tasks); end

  # @param forest [I18n::Tasks::Tree::Siblings] to translate to the locales of its root nodes
  # @param from [String] locale
  # @return [I18n::Tasks::Tree::Siblings] translated forest
  def translate_forest(forest, from); end

  protected

  # Prepare value for translation.
  #
  # @return [String, Array<String, nil>, nil] value for Google Translate or nil for non-string values
  def dump_value(value); end

  # @param list [Array<[String, Object]>] of key-value pairs
  # @return [Array<[String, Object]>] translated list
  def fetch_translations(list, opts); end

  # @param list [Array<[String, Object]>]
  # @param translated_values [Array<String>]
  # @return [Array<[String, Object]>] translated key-value pairs
  def from_values(list, translated_values); end

  # @abstract
  # @return [String]
  def no_results_error_message; end

  # @abstract
  # @return [Hash]
  def options_for_html; end

  # @abstract
  # @return [Hash]
  def options_for_plain; end

  # @abstract
  # @param options [Hash]
  # @return [Hash]
  def options_for_translate_values(options); end

  # Parse translated value from the each_translated enumerator
  #
  # @param untranslated [Object]
  # @param each_translated [Enumerator]
  # @return [Object] final translated value
  def parse_value(untranslated, each_translated); end

  def raise_interpolation_error(untranslated, translated, e); end

  # @param value [String]
  # @return [String] 'hello, %{name}' => 'hello, <round-trippable string>'
  def replace_interpolations(value); end

  # @param untranslated [String]
  # @param translated [String]
  # @return [String] 'hello, <round-trippable string>' => 'hello, %{name}'
  def restore_interpolations(untranslated, translated); end

  # @param list [Array<[String, Object]>] of key-value pairs
  # @return [Array<String>] values for translation extracted from list
  def to_values(list); end

  # @param list [Array<[String, Object]>] of key-value pairs
  # @return [Array<[String, Object]>] translated list
  def translate_pairs(list, opts); end

  # @abstract
  # @param list [Array<String>]
  # @param options [Hash]
  # @return [Array<String>]
  def translate_values(list, **options); end
end

I18n::Tasks::Translators::BaseTranslator::INTERPOLATION_KEY_RE = T.let(T.unsafe(nil), Regexp)
I18n::Tasks::Translators::BaseTranslator::UNTRANSLATABLE_STRING = T.let(T.unsafe(nil), String)

class I18n::Tasks::Translators::DeeplTranslator < ::I18n::Tasks::Translators::BaseTranslator
  # @return [DeeplTranslator] a new instance of DeeplTranslator
  def initialize(*_arg0); end

  protected

  def no_results_error_message; end
  def options_for_html; end
  def options_for_plain; end
  def options_for_translate_values(**options); end

  # @param value [String]
  # @return [String] 'hello, %{name}' => 'hello, <i18n>%{name}</i18n>'
  def replace_interpolations(value); end

  # @param untranslated [String]
  # @param translated [String]
  # @return [String] 'hello, <i18n>%{name}</i18n>' => 'hello, %{name}'
  def restore_interpolations(untranslated, translated); end

  def translate_values(list, from:, to:, **options); end

  private

  def configure_api_key!; end

  # Convert 'es-ES' to 'ES'
  def to_deepl_compatible_locale(locale); end
end

class I18n::Tasks::Translators::GoogleTranslator < ::I18n::Tasks::Translators::BaseTranslator
  # @return [GoogleTranslator] a new instance of GoogleTranslator
  def initialize(*_arg0); end

  protected

  def no_results_error_message; end
  def options_for_html; end
  def options_for_plain; end
  def options_for_translate_values(from:, to:, **options); end
  def translate_values(list, **options); end

  private

  def api_key; end

  # Convert 'es-ES' to 'es'
  def to_google_translate_compatible_locale(locale); end
end

I18n::Tasks::Translators::GoogleTranslator::SUPPORTED_LOCALES_WITH_REGION = T.let(T.unsafe(nil), Array)

class I18n::Tasks::Translators::YandexTranslator < ::I18n::Tasks::Translators::BaseTranslator
  # @return [YandexTranslator] a new instance of YandexTranslator
  def initialize(*_arg0); end

  protected

  def no_results_error_message; end
  def options_for_html; end
  def options_for_plain; end
  def options_for_translate_values(from:, to:, **options); end
  def translate_values(list, **options); end

  private

  def api_key; end

  # Convert 'es-ES' to 'es'
  def to_yandex_compatible_locale(locale); end

  def translator; end
end

module I18n::Tasks::UnusedKeys
  def unused_keys(locales: T.unsafe(nil), strict: T.unsafe(nil)); end

  # @param locale [String]
  # @param strict [Boolean] if true, do not match dynamic keys
  def unused_tree(locale: T.unsafe(nil), strict: T.unsafe(nil)); end
end

module I18n::Tasks::UsedKeys
  def caching_file_finder_provider; end
  def caching_file_reader; end
  def merge_scanner_configs(a, b); end
  def scanner(strict: T.unsafe(nil)); end
  def search_config; end

  # @return [Boolean] whether the key is potentially used in a code expression such as `t("category.#{category_key}")`
  def used_in_expr?(key); end

  def used_in_source_tree(key_filter: T.unsafe(nil), strict: T.unsafe(nil)); end

  # Find all keys in the source and return a forest with the keys in absolute form and their occurrences.
  #
  # @param key_filter [String] only return keys matching this pattern.
  # @param strict [Boolean] if true, dynamic keys are excluded (e.g. `t("category.#{ category.key }")`)
  # @param include_raw_references [Boolean] if true, includes reference usages as they appear in the source
  # @return [Data::Tree::Siblings]
  def used_tree(key_filter: T.unsafe(nil), strict: T.unsafe(nil), include_raw_references: T.unsafe(nil)); end

  private

  # keys in the source that end with a ., e.g. t("category.#{ cat.i18n_key }") or t("category." + category.key)
  #
  # @param replacement [String] for interpolated values.
  def expr_key_re(replacement: T.unsafe(nil)); end

  # Replace interpolations in dynamic keys such as "category.#{category.i18n_key}".
  #
  # @param key [String]
  # @param replacement [String]
  # @return [String]
  def replace_key_exp(key, replacement); end

  # @param strict [Boolean, nil]
  # @return [Boolean]
  def strict?(strict); end
end

I18n::Tasks::UsedKeys::ALWAYS_EXCLUDE = T.let(T.unsafe(nil), Array)
I18n::Tasks::UsedKeys::SEARCH_DEFAULTS = T.let(T.unsafe(nil), Hash)
I18n::Tasks::VERSION = T.let(T.unsafe(nil), String)
I18n::VERSION = T.let(T.unsafe(nil), String)
