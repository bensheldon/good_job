# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: true
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/protocol-http2/all/protocol-http2.rbi
#
# protocol-http2-0.14.2

module Protocol
end
module Protocol::HTTP2
end
class Protocol::HTTP2::Error < Protocol::HTTP::Error
end
class Protocol::HTTP2::HandshakeError < Protocol::HTTP2::Error
end
class Protocol::HTTP2::ProtocolError < Protocol::HTTP2::Error
  def code; end
  def initialize(message, code = nil); end
end
class Protocol::HTTP2::StreamError < Protocol::HTTP2::ProtocolError
end
class Protocol::HTTP2::StreamClosed < Protocol::HTTP2::StreamError
  def initialize(message); end
end
class Protocol::HTTP2::HeaderError < Protocol::HTTP2::StreamClosed
  def initialize(message); end
end
class Protocol::HTTP2::GoawayError < Protocol::HTTP2::ProtocolError
end
class Protocol::HTTP2::FrameSizeError < Protocol::HTTP2::ProtocolError
  def initialize(message); end
end
class Protocol::HTTP2::FlowControlError < Protocol::HTTP2::ProtocolError
  def initialize(message); end
end
class Protocol::HTTP2::Frame
  def <=>(other); end
  def apply(connection); end
  def clear_flags(mask); end
  def connection?; end
  def flag_set?(mask); end
  def flags; end
  def flags=(arg0); end
  def header; end
  def initialize(stream_id = nil, flags = nil, type = nil, length = nil, payload = nil); end
  def inspect; end
  def length; end
  def length=(arg0); end
  def pack(payload, maximum_size: nil); end
  def payload; end
  def payload=(arg0); end
  def read(stream, maximum_frame_size = nil); end
  def read_header(stream); end
  def read_payload(stream); end
  def self.parse_header(buffer); end
  def set_flags(mask); end
  def stream_id; end
  def stream_id=(arg0); end
  def to_ary; end
  def type; end
  def type=(arg0); end
  def unpack; end
  def valid_type?; end
  def write(stream); end
  def write_header(stream); end
  def write_payload(stream); end
  include Comparable
end
module Protocol::HTTP2::Padded
  def pack(data, padding_size: nil, maximum_size: nil); end
  def padded?; end
  def unpack; end
end
class Protocol::HTTP2::DataFrame < Protocol::HTTP2::Frame
  def apply(connection); end
  def end_stream?; end
  def inspect; end
  def pack(data, *arguments, **options); end
  include Protocol::HTTP2::Padded
end
module Protocol::HTTP2::Continued
  def continuation; end
  def continuation=(arg0); end
  def end_headers?; end
  def initialize(*arg0); end
  def pack(data, **options); end
  def read(stream, maximum_frame_size); end
  def unpack; end
  def write(stream); end
end
class Protocol::HTTP2::ContinuationFrame < Protocol::HTTP2::Frame
  def apply(connection); end
  def inspect; end
  include Protocol::HTTP2::Continued
end
class Anonymous_Struct_34 < Struct
  def exclusive; end
  def exclusive=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
  def stream_dependency; end
  def stream_dependency=(_); end
  def weight; end
  def weight=(_); end
end
class Protocol::HTTP2::Priority < Anonymous_Struct_34
  def pack; end
  def self.default(stream_dependency = nil, weight = nil); end
  def self.unpack(data); end
  def weight=(value); end
end
class Protocol::HTTP2::PriorityFrame < Protocol::HTTP2::Frame
  def apply(connection); end
  def pack(priority); end
  def priority; end
  def read_payload(stream); end
  def unpack; end
end
class Protocol::HTTP2::HeadersFrame < Protocol::HTTP2::Frame
  def apply(connection); end
  def end_stream?; end
  def inspect; end
  def pack(priority, data, *arguments, **options); end
  def priority?; end
  def unpack; end
  include Protocol::HTTP2::Continued
end
class Protocol::HTTP2::ResetStreamFrame < Protocol::HTTP2::Frame
  def apply(connection); end
  def pack(error_code = nil); end
  def read_payload(stream); end
  def unpack; end
end
module Protocol::HTTP2::Acknowledgement
  def acknowledge; end
  def acknowledgement?; end
end
class Protocol::HTTP2::PingFrame < Protocol::HTTP2::Frame
  def acknowledge; end
  def apply(connection); end
  def connection?; end
  def read_payload(stream); end
  include Protocol::HTTP2::Acknowledgement
end
class Protocol::HTTP2::Settings
  def difference(other); end
  def enable_connect_protocol; end
  def enable_connect_protocol=(value); end
  def enable_connect_protocol?; end
  def enable_push; end
  def enable_push=(value); end
  def enable_push?; end
  def header_table_size; end
  def header_table_size=(arg0); end
  def initial_window_size; end
  def initial_window_size=(value); end
  def initialize; end
  def maximum_concurrent_streams; end
  def maximum_concurrent_streams=(arg0); end
  def maximum_frame_size; end
  def maximum_frame_size=(value); end
  def maximum_header_list_size; end
  def maximum_header_list_size=(arg0); end
  def update(changes); end
end
class Protocol::HTTP2::PendingSettings
  def acknowledge; end
  def append(changes); end
  def current; end
  def enable_push; end
  def header_table_size; end
  def initial_window_size; end
  def initialize(current = nil); end
  def maximum_concurrent_streams; end
  def maximum_frame_size; end
  def maximum_header_list_size; end
  def pending; end
end
class Protocol::HTTP2::SettingsFrame < Protocol::HTTP2::Frame
  def apply(connection); end
  def connection?; end
  def pack(settings = nil); end
  def read_payload(stream); end
  def unpack; end
  include Protocol::HTTP2::Acknowledgement
end
class Protocol::HTTP2::PushPromiseFrame < Protocol::HTTP2::Frame
  def apply(connection); end
  def pack(stream_id, data, *arguments, **options); end
  def unpack; end
  include Protocol::HTTP2::Continued
end
class Protocol::HTTP2::GoawayFrame < Protocol::HTTP2::Frame
  def apply(connection); end
  def connection?; end
  def pack(last_stream_id, error_code, data); end
  def unpack; end
end
class Protocol::HTTP2::Window
  def available; end
  def available?; end
  def capacity; end
  def capacity=(value); end
  def consume(amount); end
  def expand(amount); end
  def full?; end
  def initialize(capacity = nil); end
  def limited?; end
  def to_s; end
  def used; end
  def wanted; end
end
class Protocol::HTTP2::LocalWindow < Protocol::HTTP2::Window
  def desired; end
  def desired=(arg0); end
  def initialize(capacity = nil, desired: nil); end
  def limited?; end
  def wanted; end
end
class Protocol::HTTP2::WindowUpdateFrame < Protocol::HTTP2::Frame
  def apply(connection); end
  def pack(window_size_increment); end
  def read_payload(stream); end
  def unpack; end
end
class Protocol::HTTP2::Framer
  def close; end
  def closed?; end
  def initialize(stream, frames = nil); end
  def read_connection_preface; end
  def read_frame(maximum_frame_size = nil); end
  def read_header; end
  def write_connection_preface; end
  def write_frame(frame); end
end
class Protocol::HTTP2::Dependency
  def <=>(other); end
  def add_child(dependency); end
  def children; end
  def children=(arg0); end
  def clear_cache!; end
  def connection; end
  def consume_window(size); end
  def delete!; end
  def exclusive_child(parent); end
  def id; end
  def initialize(connection, id, weight = nil); end
  def ordered_children; end
  def parent; end
  def parent=(arg0); end
  def print_hierarchy(buffer, indent: nil); end
  def priority(exclusive = nil); end
  def priority=(priority); end
  def process_priority(priority); end
  def receive_priority(frame); end
  def remove_child(dependency); end
  def self.create(connection, id, priority = nil); end
  def send_priority(priority); end
  def stream; end
  def to_s; end
  def total_weight; end
  def weight; end
  def weight=(arg0); end
end
module Protocol::HTTP2::FlowControlled
  def available_frame_size(maximum_frame_size = nil); end
  def available_size; end
  def consume_local_window(frame); end
  def consume_remote_window(frame); end
  def receive_window_update(frame); end
  def request_window_update; end
  def send_window_update(window_increment); end
  def update_local_window(frame); end
  def window_updated(size); end
end
class Protocol::HTTP2::Connection
  def [](id); end
  def accept_push_promise_stream(stream_id, &block); end
  def accept_stream(stream_id, &block); end
  def client_stream_id?(id); end
  def close!; end
  def close(error = nil); end
  def closed?; end
  def closed_stream_id?(id); end
  def consume_window(size = nil); end
  def create_push_promise_stream(&block); end
  def create_stream(id = nil, &block); end
  def decode_headers(data); end
  def delete(id); end
  def dependencies; end
  def dependency; end
  def encode_headers(headers, buffer = nil); end
  def framer; end
  def id; end
  def idle_stream_id?(id); end
  def ignore_frame?(frame); end
  def initialize(framer, local_stream_id); end
  def local_settings; end
  def local_settings=(arg0); end
  def local_window; end
  def maximum_concurrent_streams; end
  def maximum_frame_size; end
  def next_stream_id; end
  def open!; end
  def process_settings(frame); end
  def read_frame; end
  def receive_continuation(frame); end
  def receive_data(frame); end
  def receive_frame(frame); end
  def receive_goaway(frame); end
  def receive_headers(frame); end
  def receive_ping(frame); end
  def receive_priority(frame); end
  def receive_push_promise(frame); end
  def receive_reset_stream(frame); end
  def receive_settings(frame); end
  def receive_window_update(frame); end
  def remote_settings; end
  def remote_settings=(arg0); end
  def remote_stream_id; end
  def remote_window; end
  def send_goaway(error_code = nil, message = nil); end
  def send_ping(data); end
  def send_priority(stream_id, priority); end
  def send_settings(changes); end
  def server_stream_id?(id); end
  def state; end
  def state=(arg0); end
  def streams; end
  def update_local_settings(changes); end
  def update_remote_settings(changes); end
  def valid_remote_stream_id?; end
  def write_frame(frame); end
  def write_frames; end
  include Protocol::HTTP2::FlowControlled
end
class Protocol::HTTP2::Stream
  def accept_push_promise_stream(stream_id, headers); end
  def active?; end
  def close!(error_code = nil); end
  def close(error = nil); end
  def closed(error = nil); end
  def closed?; end
  def connection; end
  def consume_remote_window(frame); end
  def create_push_promise_stream(headers); end
  def dependency; end
  def id; end
  def ignore_data(frame); end
  def ignore_headers(frame); end
  def initialize(connection, id, state = nil); end
  def inspect; end
  def local_window; end
  def maximum_frame_size; end
  def open!; end
  def opened(error = nil); end
  def parent=(stream); end
  def priority; end
  def priority=(priority); end
  def process_data(frame); end
  def process_headers(frame); end
  def receive_data(frame); end
  def receive_headers(frame); end
  def receive_push_promise(frame); end
  def receive_reset_stream(frame); end
  def remote_window; end
  def reserved_local!; end
  def reserved_remote!; end
  def self.create(connection, id); end
  def send_data(*arguments, **options); end
  def send_headers(*arguments); end
  def send_headers?; end
  def send_push_promise(headers); end
  def send_reset_stream(error_code = nil); end
  def state; end
  def state=(arg0); end
  def to_s; end
  def weight; end
  def write_data(data, flags = nil, **options); end
  def write_frame(frame); end
  def write_headers(priority, headers, flags = nil); end
  def write_push_promise(stream_id, headers, flags = nil, **options); end
  include Protocol::HTTP2::FlowControlled
end
class Protocol::HTTP2::Client < Protocol::HTTP2::Connection
  def create_push_promise_stream; end
  def initialize(framer); end
  def local_stream_id?(id); end
  def receive_push_promise(frame); end
  def remote_stream_id?(id); end
  def send_connection_preface(settings = nil); end
  def valid_remote_stream_id?(stream_id); end
end
class Protocol::HTTP2::Server < Protocol::HTTP2::Connection
  def accept_push_promise_stream(stream_id, &block); end
  def enable_push?; end
  def initialize(framer); end
  def local_stream_id?(id); end
  def read_connection_preface(settings = nil); end
  def remote_stream_id?(id); end
  def valid_remote_stream_id?(stream_id); end
end
