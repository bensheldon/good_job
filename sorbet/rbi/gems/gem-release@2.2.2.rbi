# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `gem-release` gem.
# Please instead update this file by running `bin/tapioca gem gem-release`.

module Gem::Release; end
class Gem::Release::Abort < ::StandardError; end

module Gem::Release::Cmds
  class << self
    def [](cmd); end
  end
end

class Gem::Release::Cmds::Base < ::Struct
  include ::Gem::Release::Registry
  include ::Gem::Release::Registry::InstanceMethods
  include ::Gem::Release::Helper::String
  include ::Gem::Release::Helper::Hash
  include ::Gem::Release::Helper
  extend ::Gem::Release::Registry::ClassMethods
  extend ::Gem::Release::Helper::String

  # @return [Base] a new instance of Base
  def initialize(context, args, opts); end

  def config; end
  def defaults; end

  # Returns the value of attribute gem.
  def gem; end

  def in_dirs; end
  def in_gem_dirs; end

  # Returns the value of attribute opts
  #
  # @return [Object] the current value of opts
  def opts; end

  # @return [Boolean]
  def pretend?; end

  # @return [Boolean]
  def quiet?; end

  class << self
    def arg(name, summary); end
    def args; end
    def default(opt); end
    def descr(opt); end
    def description(description = T.unsafe(nil)); end

    # @private
    def inherited(cmd); end

    def opt(*args, &block); end
    def opts; end
    def summary(summary = T.unsafe(nil)); end
    def usage(usage = T.unsafe(nil)); end
  end
end

Gem::Release::Cmds::Base::DEFAULTS = T.let(T.unsafe(nil), Hash)

class Gem::Release::Cmds::Bootstrap < ::Gem::Release::Cmds::Base
  def run; end

  private

  def create_repo; end
  def data; end
  def executable; end
  def files; end
  def init_git; end
  def license; end
  def normalize(opts); end
  def opts; end
  def remote; end
  def scaffold; end
  def write(file); end
end

Gem::Release::Cmds::Bootstrap::CMDS = T.let(T.unsafe(nil), Hash)
Gem::Release::Cmds::Bootstrap::DEFAULTS = T.let(T.unsafe(nil), Hash)
Gem::Release::Cmds::Bootstrap::DESCR = T.let(T.unsafe(nil), Hash)
Gem::Release::Cmds::Bootstrap::FILES = T.let(T.unsafe(nil), Array)
Gem::Release::Cmds::Bootstrap::MSGS = T.let(T.unsafe(nil), Hash)

class Gem::Release::Cmds::Bump < ::Gem::Release::Cmds::Base
  def run; end

  private

  def branch; end
  def bump; end
  def checkout; end
  def commit; end
  def message; end
  def push; end

  # @return [Boolean]
  def push?; end

  def release(new_version); end
  def remote; end
  def reset; end
  def tag(new_version); end
  def validate; end
  def version; end
end

Gem::Release::Cmds::Bump::CMDS = T.let(T.unsafe(nil), Hash)
Gem::Release::Cmds::Bump::DEFAULTS = T.let(T.unsafe(nil), Hash)
Gem::Release::Cmds::Bump::DESCR = T.let(T.unsafe(nil), Hash)
Gem::Release::Cmds::Bump::MSGS = T.let(T.unsafe(nil), Hash)

class Gem::Release::Cmds::Gemspec < ::Gem::Release::Cmds::Base
  def run; end

  private

  def data; end
  def file; end
  def generate; end
  def templates; end
end

Gem::Release::Cmds::Gemspec::DEFAULTS = T.let(T.unsafe(nil), Hash)
Gem::Release::Cmds::Gemspec::DESCR = T.let(T.unsafe(nil), Hash)
Gem::Release::Cmds::Gemspec::MSGS = T.let(T.unsafe(nil), Hash)

class Gem::Release::Cmds::Github < ::Gem::Release::Cmds::Base
  def run; end

  private

  def data; end
  def descr; end
  def release; end
  def repo; end
  def repo_from(url); end
  def tag_name; end

  # @return [Boolean]
  def tagged?; end

  def token; end
  def validate; end
end

Gem::Release::Cmds::Github::MSGS = T.let(T.unsafe(nil), Hash)

class Gem::Release::Cmds::Release < ::Gem::Release::Cmds::Base
  def run; end

  private

  def build; end
  def cleanup; end
  def github; end
  def push; end
  def push_args; end
  def release; end
  def tag; end
  def target_version; end
  def validate; end
end

Gem::Release::Cmds::Release::CMDS = T.let(T.unsafe(nil), Hash)
Gem::Release::Cmds::Release::DEFAULTS = T.let(T.unsafe(nil), Hash)
Gem::Release::Cmds::Release::DESCR = T.let(T.unsafe(nil), Hash)

# endregion github
Gem::Release::Cmds::Release::MSGS = T.let(T.unsafe(nil), Hash)

class Gem::Release::Cmds::Runner < ::Struct
  def run; end

  private

  # Returns the value of attribute args
  #
  # @return [Object] the current value of args
  def args; end

  def config; end
  def const; end

  # Returns the value of attribute context
  #
  # @return [Object] the current value of context
  def context; end

  def except(hash, *keys); end

  # Returns the value of attribute opts
  #
  # @return [Object] the current value of opts
  def opts; end

  def run_cmd; end
  def success; end
end

class Gem::Release::Cmds::Tag < ::Gem::Release::Cmds::Base
  def run; end

  private

  # @return [Boolean]
  def exists?; end

  def push; end

  # @return [Boolean]
  def push?; end

  def remote; end
  def tag; end
  def tag_and_push; end
  def tag_name; end
  def target_version; end
  def validate; end
end

Gem::Release::Cmds::Tag::CMDS = T.let(T.unsafe(nil), Hash)
Gem::Release::Cmds::Tag::DEFAULTS = T.let(T.unsafe(nil), Hash)
Gem::Release::Cmds::Tag::DESCR = T.let(T.unsafe(nil), Hash)
Gem::Release::Cmds::Tag::MSGS = T.let(T.unsafe(nil), Hash)

class Gem::Release::Config
  include ::Gem::Release::Helper::Hash

  # @return [Config] a new instance of Config
  def initialize; end

  def [](key); end
  def common; end
  def for(key); end

  # Returns the value of attribute opts.
  def opts; end

  private

  def load; end
  def sources; end
end

class Gem::Release::Config::Env
  include ::Gem::Release::Helper::Hash

  def load; end

  private

  def cast(value); end
  def keys_for(key); end
  def to_hash(keys, value); end
  def vars; end
end

Gem::Release::Config::Env::FALSE = T.let(T.unsafe(nil), Regexp)
Gem::Release::Config::Env::PREFIX = T.let(T.unsafe(nil), String)
Gem::Release::Config::Env::TRUE = T.let(T.unsafe(nil), Regexp)

class Gem::Release::Config::Files
  include ::Gem::Release::Helper::Hash

  def load; end

  private

  def path; end
  def paths; end
end

Gem::Release::Config::Files::PATHS = T.let(T.unsafe(nil), Array)
Gem::Release::Config::SOURCES = T.let(T.unsafe(nil), Array)

class Gem::Release::Context
  # @return [Context] a new instance of Context
  def initialize(*args); end

  def abort(str); end

  # Returns the value of attribute config.
  def config; end

  # Sets the attribute config
  #
  # @param value the value to set the attribute config to.
  def config=(_arg0); end

  # Returns the value of attribute gem.
  def gem; end

  # Sets the attribute gem
  #
  # @param value the value to set the attribute gem to.
  def gem=(_arg0); end

  def gem_cmd(cmd, *args); end

  # Returns the value of attribute git.
  def git; end

  # Sets the attribute git
  #
  # @param value the value to set the attribute git to.
  def git=(_arg0); end

  def in_dirs(args, opts, &block); end
  def in_gem_dirs(args, opts, &block); end
  def run(cmd); end

  # Returns the value of attribute ui.
  def ui; end

  # Sets the attribute ui
  #
  # @param value the value to set the attribute ui to.
  def ui=(_arg0); end
end

class Gem::Release::Context::Gem
  # @return [Gem] a new instance of Gem
  def initialize(name); end

  def filename; end

  # Returns the value of attribute name.
  def name; end

  # Returns the value of attribute spec.
  def spec; end

  def spec_filename; end
  def version; end
end

class Gem::Release::Context::Gemspec < ::Struct
  # @return [Gemspec] a new instance of Gemspec
  def initialize(*_arg0); end

  # @return [Boolean]
  def exists?; end

  # Returns the value of attribute filename.
  def filename; end

  def gem_filename; end
  def gem_name; end
  def homepage; end
  def metadata; end
  def version; end

  private

  def filenames; end
  def gemspec; end
end

class Gem::Release::Context::Git
  # @return [Boolean]
  def clean?; end

  def remotes; end
  def tags; end
  def user_email; end
  def user_login; end
  def user_name; end
end

class Gem::Release::Context::Github
  include ::Gem::Release::Helper::Http

  # @return [Github] a new instance of Github
  def initialize(repo, data); end

  # Returns the value of attribute data.
  def data; end

  # @raise [Abort]
  def release; end

  # Returns the value of attribute repo.
  def repo; end

  private

  def body; end
  def headers; end

  # @return [Boolean]
  def pre?(version); end

  def url; end
end

Gem::Release::Context::Github::MSGS = T.let(T.unsafe(nil), Hash)
Gem::Release::Context::Github::URL = T.let(T.unsafe(nil), String)
class Gem::Release::Context::Paths < ::Struct; end

class Gem::Release::Context::Paths::Base < ::Struct
  def current; end
  def cwd; end
  def in_dir(dir, &block); end
end

class Gem::Release::Context::Paths::ByGemspecs < ::Gem::Release::Context::Paths::Base
  def in_dirs(&block); end

  private

  def by_gemspecs; end
  def by_names; end
  def dirs; end
  def gemspec; end
  def gemspecs(recurse = T.unsafe(nil)); end
  def name_for(path); end
end

class Gem::Release::Context::Paths::ByNames < ::Gem::Release::Context::Paths::Base
  def in_dirs(&block); end

  private

  def dir; end
  def dirs; end
  def dirs_by_names; end
end

module Gem::Release::Context::Ui
  class << self
    def new(opts); end
  end
end

class Gem::Release::Context::Ui::Base < ::Struct
  def puts(*str); end
  def stdout; end

  # Sets the attribute stdout
  #
  # @param value the value to set the attribute stdout to.
  def stdout=(_arg0); end
end

module Gem::Release::Context::Ui::Colors
  def colored(color, str); end
end

Gem::Release::Context::Ui::Colors::COLORS = T.let(T.unsafe(nil), Hash)

class Gem::Release::Context::Ui::Pipe < ::Gem::Release::Context::Ui::Base
  def announce(msg, args = T.unsafe(nil), _ = T.unsafe(nil)); end
  def cmd(*_arg0); end
  def error(msg, args = T.unsafe(nil), _ = T.unsafe(nil)); end
  def info(msg, args = T.unsafe(nil), _ = T.unsafe(nil)); end
  def notice(msg, args = T.unsafe(nil), _ = T.unsafe(nil)); end
  def success(*_arg0); end
  def warn(msg, args = T.unsafe(nil), _ = T.unsafe(nil)); end

  private

  def format_msg(msg, args); end
  def quote_spaced(str); end
end

class Gem::Release::Context::Ui::Quiet < ::Gem::Release::Context::Ui::Base
  def announce(*_arg0); end
  def cmd(*_arg0); end
  def error(*_arg0); end
  def info(*_arg0); end
  def notice(*_arg0); end
  def success(*_arg0); end
  def warn(*_arg0); end
end

class Gem::Release::Context::Ui::Tty < ::Gem::Release::Context::Ui::Base
  include ::Gem::Release::Context::Ui::Colors

  def announce(msg, args = T.unsafe(nil), msgs = T.unsafe(nil)); end
  def cmd(msg); end
  def error(msg, args = T.unsafe(nil), msgs = T.unsafe(nil)); end
  def info(msg, args = T.unsafe(nil), msgs = T.unsafe(nil)); end
  def notice(msg, args = T.unsafe(nil), msgs = T.unsafe(nil)); end
  def success(msg); end
  def warn(msg, args = T.unsafe(nil), msgs = T.unsafe(nil)); end

  private

  def colored(color, str); end
  def format_msg(msg, args, msgs); end
  def with_spacing(str, space); end
end

class Gem::Release::Data < ::Struct
  include ::Gem::Release::Helper::String

  def data; end

  private

  def bin_files; end
  def files; end
  def gem_name; end
  def gem_path; end
  def homepage; end
  def license; end
  def licenses; end
  def module_names; end
  def strategy; end
  def user_email; end
  def user_login; end
  def user_name; end
end

module Gem::Release::Files; end

class Gem::Release::Files::Template
  # @return [Template] a new instance of Template
  def initialize(source, target, data, opts); end

  # Returns the value of attribute data.
  def data; end

  # Sets the attribute data
  #
  # @param value the value to set the attribute data to.
  def data=(_arg0); end

  # @return [Boolean]
  def exists?; end

  def filename; end

  # Returns the value of attribute opts.
  def opts; end

  # Sets the attribute opts
  #
  # @param value the value to set the attribute opts to.
  def opts=(_arg0); end

  # Returns the value of attribute source.
  def source; end

  # Sets the attribute source
  #
  # @param value the value to set the attribute source to.
  def source=(_arg0); end

  # Returns the value of attribute target.
  def target; end

  # Sets the attribute target
  #
  # @param value the value to set the attribute target to.
  def target=(_arg0); end

  def write; end

  private

  def binding; end
  def context; end
  def render; end
  def template; end
end

class Gem::Release::Files::Template::Context < ::OpenStruct
  def define(type, &block); end
end

class Gem::Release::Files::Template::Context::Const < ::Struct
  def build(names, &block); end
  def define(&block); end
  def indent(str, level); end
end

Gem::Release::Files::Template::FILES = T.let(T.unsafe(nil), Hash)
Gem::Release::Files::Template::PATH = T.let(T.unsafe(nil), String)

class Gem::Release::Files::Templates < ::Struct
  def [](filename); end
  def all; end
  def builtin; end
  def custom; end
  def executable; end
  def license; end
  def templates_for(sources, files = T.unsafe(nil), opts = T.unsafe(nil)); end

  class << self
    def executable(target); end
    def license(name, data); end
  end
end

Gem::Release::Files::Templates::BUILTIN = T.let(T.unsafe(nil), Array)
Gem::Release::Files::Templates::CUSTOM = T.let(T.unsafe(nil), Array)
Gem::Release::Files::Templates::EXECUTABLE = T.let(T.unsafe(nil), Array)

class Gem::Release::Files::Templates::Group
  # @return [Group] a new instance of Group
  def initialize(groups, data, sources, files); end

  def all; end

  # Returns the value of attribute data.
  def data; end

  # Returns the value of attribute files.
  def files; end

  # Returns the value of attribute groups.
  def groups; end

  # Returns the value of attribute sources.
  def sources; end

  private

  def paths; end
  def paths_for(group); end
  def pattern; end
  def relative(file); end
end

Gem::Release::Files::Templates::LICENSE = T.let(T.unsafe(nil), Array)

class Gem::Release::Files::Version < ::Struct
  def bump; end

  # @return [Boolean]
  def exists?; end

  def from; end
  def path; end
  def to; end
  def to_h; end

  private

  def bumped; end
  def content; end

  # Returns the value of attribute name
  #
  # @return [Object] the current value of name
  def name; end

  # @raise [Abort]
  def not_found; end

  def number; end
  def path_to(path); end
  def paths; end
  def to_num(*args); end
end

Gem::Release::Files::Version::PRE_RELEASE = T.let(T.unsafe(nil), Regexp)
Gem::Release::Files::Version::RELEASE = T.let(T.unsafe(nil), Regexp)
Gem::Release::Files::Version::STAGES = T.let(T.unsafe(nil), Array)
Gem::Release::Files::Version::VERSION = T.let(T.unsafe(nil), Regexp)

module Gem::Release::Helper
  extend ::Forwardable

  def abort(msg, *args); end
  def announce(msg, *args); end
  def cmd(cmd, *args); end
  def error(msg, *args); end
  def gem(*args, &block); end
  def gem_cmd(cmd, *args); end
  def git(*args, &block); end
  def info(msg, *args); end
  def notice(msg, *args); end
  def run(cmd); end
  def ui(*args, &block); end
  def warn(msg, *args); end
end

module Gem::Release::Helper::Hash
  def deep_merge(hash, other); end
  def except(hash, *keys); end
  def only(hash, *keys); end
  def symbolize_keys(hash); end
end

Gem::Release::Helper::Hash::MERGER = T.let(T.unsafe(nil), Proc)

module Gem::Release::Helper::Http
  def post(url, body = T.unsafe(nil), headers = T.unsafe(nil)); end
end

class Gem::Release::Helper::Http::Client < ::Struct
  def request; end

  private

  def client; end
  def const; end
  def uri; end
end

module Gem::Release::Helper::String
  def camelize(str); end
  def underscore(str); end
  def wrap(str, width); end
end

class Gem::Release::Helper::Wrapper < ::Struct
  def apply; end

  private

  def wrap_lines(str); end
  def wrap_paragraph(str); end
end

Gem::Release::Helper::Wrapper::MARKDOWN = T.let(T.unsafe(nil), Regexp)

module Gem::Release::Registry
  include ::Gem::Release::Registry::InstanceMethods

  mixes_in_class_methods ::Gem::Release::Registry::ClassMethods

  class << self
    # @private
    def included(const); end
  end
end

module Gem::Release::Registry::ClassMethods
  def [](key); end
  def register(key); end
  def registry; end

  # Returns the value of attribute registry_key.
  def registry_key; end

  def underscore(string); end
end

module Gem::Release::Registry::InstanceMethods
  def registry_key; end
end

class Gem::Release::Registry::Registry
  def [](key); end
  def []=(key, object); end
  def cmds; end
  def registry; end
end

Gem::Release::STRATEGIES = T.let(T.unsafe(nil), Hash)
Gem::Release::VERSION = T.let(T.unsafe(nil), String)
module Gem::Release::Version; end

class Gem::Release::Version::Number < ::Struct
  def bump; end

  # @return [Boolean]
  def pre?; end

  private

  # @return [Boolean]
  def fresh_pre_release?; end

  # @return [Boolean]
  def from_pre_release?; end

  # @return [Boolean]
  def from_release?; end

  def from_stage; end
  def major; end
  def matches; end
  def minor; end
  def num; end

  # @raise [Abort]
  def parse; end

  def parts; end
  def patch; end

  # @return [Boolean]
  def same_stage?; end

  # @return [Boolean]
  def specific?; end

  def stage; end
  def stage_delim; end

  # Returns the value of attribute target
  #
  # @return [Object] the current value of target
  def target; end

  # @return [Boolean]
  def to?(*targets); end

  # @return [Boolean]
  def to_release?; end

  # @raise [Abort]
  def validate_stage; end
end

Gem::Release::Version::Number::NUMBER = T.let(T.unsafe(nil), Regexp)
Gem::Release::Version::Number::PRE_RELEASE = T.let(T.unsafe(nil), Regexp)
Gem::Release::Version::Number::STAGES = T.let(T.unsafe(nil), Array)
