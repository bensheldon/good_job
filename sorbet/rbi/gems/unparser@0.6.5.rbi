# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `unparser` gem.
# Please instead update this file by running `bin/tapioca gem unparser`.

# Library namespace
module Unparser
  class << self
    # Construct a parser buffer from string
    #
    # @param source [String]
    # @return [Parser::Source::Buffer]
    def buffer(source, identification = T.unsafe(nil)); end

    # Parse string into AST
    #
    # @param source [String]
    # @return [Parser::AST::Node, nil]
    def parse(source); end

    # Parse string into either syntax error or AST
    #
    # @param source [String]
    # @return [Either<Parser::SyntaxError, (Parser::ASTNode, nil)>]
    def parse_either(source); end

    # Parse string into AST, with comments
    #
    # @param source [String]
    # @return [Parser::AST::Node]
    def parse_with_comments(source); end

    # Parser instance that produces AST unparser understands
    #
    # @api private
    # @return [Parser::Base]
    def parser; end

    # Unparse an AST (and, optionally, comments) into a string
    #
    # @api public
    # @param node [Parser::AST::Node, nil]
    # @param comment_array [Array]
    # @raise InvalidNodeError
    #   if the node passed is invalid
    # @return [String]
    def unparse(node, comment_array = T.unsafe(nil)); end

    # Unparse capturing errors
    #
    # This is mostly useful for writing testing tools against unparser.
    #
    # @param node [Parser::AST::Node, nil]
    # @return [Either<Exception, String>]
    def unparse_either(node); end

    # Unparse with validation
    #
    # @param node [Parser::AST::Node, nil]
    # @param comment_array [Array]
    # @return [Either<Validation,String>]
    def unparse_validate(node, comment_array = T.unsafe(nil)); end
  end
end

# Namespace for AST processing tools
module Unparser::AST
  class << self
    # Return local variables that get assigned in scope
    #
    # @api private
    # @param node [Parser::AST::Node]
    # @return [Set<Symbol>]
    def local_variable_assignments(node); end

    # Return local variables read
    #
    # @api private
    # @param node [Parser::AST::Node]
    # @return [Set<Symbol>]
    def local_variable_reads(node); end

    # Test for local variable inherited scope reset
    #
    # @api private
    # @param node [Parser::AST::Node]
    # @return [Boolean]
    def not_close_scope?(node); end

    # Test for local variable scope reset
    #
    # @api private
    # @param node [Parser::AST::Node]
    # @return [Boolean]
    def not_reset_scope?(node); end
  end
end

# Nodes that assign a local variable
Unparser::AST::ASSIGN_NODES = T.let(T.unsafe(nil), Set)

Unparser::AST::CLOSE_NODES = T.let(T.unsafe(nil), Array)

# AST enumerator
class Unparser::AST::Enumerator
  include ::Enumerable
  include ::Unparser::Equalizer::Methods
  include ::Unparser::Adamantium
  include ::Unparser::Adamantium::InstanceMethods
  extend ::Unparser::Adamantium::ModuleMethods
  extend ::Unparser::Adamantium::ClassMethods

  # Return each node
  #
  # @api private
  # @return [Enumerator<Parser::AST::Node>] if no block given
  # @return [self] otherwise
  def each(&block); end

  # Return nodes selected by type
  #
  # @api private
  # @param type [Symbol]
  # @return [Enumerable<Parser::AST::Node>]
  def type(type); end

  # Return nodes selected by types
  #
  # @api private
  # @param types [Enumerable<Symbol>]
  # @return [Enumerable<Parser::AST::Node>]
  def types(types); end

  class << self
    # Return new instance
    #
    # @api private
    # @param node [Parser::AST::Node]
    # @param controller [#call(node)]
    # @return [Enumerator]
    def new(node, controller = T.unsafe(nil)); end

    private

    # Return frozne set of objects
    #
    # @api private
    # @param enumerable [Enumerable]
    # @return [Set]
    def set(enumerable); end

    # Return nodes of type
    #
    # @api private
    # @param node [Parser::AST::Node]
    # @param type [Symbol]
    # @return [Enumerable<Parser::AST::Node]] Enumerable<Parser::AST::Node]
    def type(node, type); end
  end
end

Unparser::AST::FIRST_CHILD = T.let(T.unsafe(nil), Proc)
Unparser::AST::INHERIT_NODES = T.let(T.unsafe(nil), Array)

# Calculated local variable scope for a given node
class Unparser::AST::LocalVariableScope
  include ::Unparser::Equalizer::Methods
  include ::Unparser::Adamantium
  include ::Unparser::Adamantium::InstanceMethods
  include ::Enumerable
  extend ::Unparser::Adamantium::ModuleMethods
  extend ::Unparser::Adamantium::ClassMethods

  # Initialize object
  #
  # @api private
  # @param node [Parser::AST::Node]
  # @return [undefined]
  def initialize(node); end

  # Test if local variable was first at given assignment
  #
  # @api private
  # @param node [Parser::AST::Node]
  # @return [Boolean]
  def first_assignment?(node); end

  # Test if local variables where first assigned in body and read by conditional
  #
  # @api private
  # @param body [Parser::AST::Node]
  # @param condition [Parser::AST::Node]
  # @return [Boolean]
  def first_assignment_in?(left, right); end

  # Test if local variable is defined for given node
  #
  # @api private
  # @param node [Parser::AST::Node]
  # @param name [Symbol]
  # @return [Boolean]
  def local_variable_defined_for_node?(node, name); end

  private

  def match(needle); end
end

# Local variable scope enumerator
class Unparser::AST::LocalVariableScopeEnumerator
  include ::Enumerable

  # Initialize object
  #
  # @api private
  # @return [undefined]
  def initialize; end

  # Enumerate local variable scope scope
  #
  # @api private
  # @return [self] if block given
  # @return [Enumerator<Array<Symbol>>] ]
  #   otherwise
  def each(node, &block); end

  private

  def current; end
  def define(name); end
  def enter(node); end
  def leave(node); end
  def pop; end
  def push_inherit; end
  def push_reset; end

  # @yield [node, current.dup, before]
  def visit(node, &block); end

  class << self
    # Enumerate each node with its local variable scope
    #
    # @api private
    # @param node [Parser::AST::Node]
    # @return [self]
    def each(node, &block); end
  end
end

Unparser::AST::RESET_NODES = T.let(T.unsafe(nil), Array)
Unparser::AST::TAUTOLOGY = T.let(T.unsafe(nil), Proc)

# Controlled AST walker walking the AST in deeth first search with pre order
class Unparser::AST::Walker
  include ::Unparser::Equalizer::Methods

  # Call walker with node
  #
  # @api private
  # @param node [Parser::AST::Node]
  # @return [undefined]
  def call(node); end

  class << self
    # Call ast walker
    #
    # @api private
    # @param node [Parser::AST::Node]
    # @return [self]
    def call(node, controller = T.unsafe(nil), &block); end
  end
end

# Module to allow class and methods to be abstract
#
# Original code before vendoring and reduction from: https://github.com/dkubb/abstract_type.
module Unparser::AbstractType
  mixes_in_class_methods ::Unparser::AbstractType::AbstractMethodDeclarations

  class << self
    private

    # Define the new method on the abstract type
    #
    # Ensures that the instance cannot be of the abstract type
    # and must be a descendant.
    #
    # @api private
    # @param abstract_class [Class]
    # @return [undefined]
    def create_new_method(abstract_class); end

    # Hook called when module is included
    #
    # @api private
    # @param descendant [Module] the module or class including AbstractType
    # @return [undefined]
    def included(descendant); end
  end
end

module Unparser::AbstractType::AbstractMethodDeclarations
  # Create abstract instance methods
  #
  # @api public
  # @example
  #   class Foo
  #   include AbstractType
  #
  #   # Create an abstract instance method
  #   abstract_method :some_method
  #   end
  # @param names [Array<#to_s>]
  # @return [self]
  def abstract_method(*names); end

  # Create abstract singleton methods
  #
  # @api private
  # @example
  #   class Foo
  #   include AbstractType
  #
  #   # Create an abstract instance method
  #   abstract_singleton_method :some_method
  #   end
  # @param names [Array<#to_s>]
  # @return [self]
  def abstract_singleton_method(*names); end

  private

  # Create abstract instance method
  #
  # @api private
  # @param name [#to_s] the name of the method to create
  # @return [undefined]
  def create_abstract_instance_method(name); end

  # Create abstract singleton method
  #
  # @api private
  # @param name [#to_s] the name of the method to create
  # @return [undefined]
  def create_abstract_singleton_method(name); end
end

# Allows objects to be made immutable
#
# Original code before vendoring and reduction from: https://github.com/dkubb/adamantium.
module Unparser::Adamantium
  include ::Unparser::Adamantium::InstanceMethods

  mixes_in_class_methods ::Unparser::Adamantium::ModuleMethods
  mixes_in_class_methods ::Unparser::Adamantium::ClassMethods

  class << self
    private

    # ModuleMethods
    def included(descendant); end
  end
end

# Methods mixed in to adamantium classes
module Unparser::Adamantium::ClassMethods
  # Instantiate a new frozen object
  #
  # @api public
  # @return [Object]
  def new(*_arg0); end
end

module Unparser::Adamantium::InstanceMethods
  # A noop #dup for immutable objects
  #
  # @api public
  # @return [self]
  def dup; end

  # Freeze the object
  #
  # @api public
  # @return [Object]
  def freeze; end

  private

  def memoized_method_cache; end
end

# Storage for memoized methods
class Unparser::Adamantium::Memory
  # Initialize the memory storage for memoized methods
  #
  # @api private
  # @return [undefined]
  def initialize(values); end

  # Fetch the value from memory, or evaluate if it does not exist
  #
  # @api public
  # @param name [Symbol]
  # @yieldreturn [Object] the value to memoize
  def fetch(name); end
end

# Build the memoized method
class Unparser::Adamantium::MethodBuilder
  # Initialize an object to build a memoized method
  #
  # @api private
  # @param descendant [Module]
  # @param method_name [Symbol]
  # @return [undefined]
  def initialize(descendant, method_name); end

  # Build a new memoized method
  #
  # @api public
  # @example
  #   method_builder.call  # => creates new method
  # @return [UnboundMethod]
  def call; end

  private

  def assert_arity(arity); end
  def create_memoized_method; end
  def remove_original_method; end
  def set_method_visibility; end
  def visibility; end
end

# Raised when a block is passed to a memoized method
class Unparser::Adamantium::MethodBuilder::BlockNotAllowedError < ::ArgumentError
  # Initialize a block not allowed exception
  #
  # @api private
  # @param descendant [Module]
  # @param method [Symbol]
  # @return [BlockNotAllowedError] a new instance of BlockNotAllowedError
  def initialize(descendant, method); end
end

# Raised when the method arity is invalid
class Unparser::Adamantium::MethodBuilder::InvalidArityError < ::ArgumentError
  # Initialize an invalid arity exception
  #
  # @api private
  # @param descendant [Module]
  # @param method [Symbol]
  # @param arity [Integer]
  # @return [InvalidArityError] a new instance of InvalidArityError
  def initialize(descendant, method, arity); end
end

# Methods mixed in to adamantium modules
module Unparser::Adamantium::ModuleMethods
  # Memoize a list of methods
  #
  # @api public
  # @param methods [Array<#to_s>] a list of methods to memoize
  # @return [self]
  def memoize(*methods); end

  # Test if method is memoized
  #
  # @param name [Symbol]
  # @return [Bool]
  def memoized?(method_name); end

  # Return unmemoized instance method
  #
  # @api public
  # @param name [Symbol]
  # @raise [NameError] raised if the method is unknown
  # @return [UnboundMethod] the memoized method
  def unmemoized_instance_method(method_name); end

  private

  def memoize_method(method_name); end
  def memoized_methods; end
end

# Original code before vendoring and reduction from: https://github.com/mbj/anima.
class Unparser::Anima < ::Module
  include ::Unparser::Equalizer::Methods
  include ::Unparser::Adamantium
  include ::Unparser::Adamantium::InstanceMethods
  extend ::Unparser::Adamantium::ModuleMethods
  extend ::Unparser::Adamantium::ClassMethods

  # Initialize object
  #
  #
  # @return [undefined]
  def initialize(*names); end

  # Return new anima with attributes added
  #
  # @example
  #   anima = Anima.new(:foo)
  #   anima.add(:bar) # equals Anima.new(:foo, :bar)
  # @return [Anima]
  def add(*names); end

  # Return attribute names
  #
  # @return [Enumerable<Symbol>]
  def attribute_names(&block); end

  # Return names
  #
  # @return [AttributeSet]
  def attributes; end

  # Return attributes hash for instance
  #
  # @param object [Object]
  # @return [Hash]
  def attributes_hash(object); end

  # Initialize instance
  #
  # @param object [Object]
  # @param attribute_hash [Hash]
  # @return [self]
  def initialize_instance(object, attribute_hash); end

  # Return new anima with attributes removed
  #
  # @example
  #   anima = Anima.new(:foo, :bar)
  #   anima.remove(:bar) # equals Anima.new(:foo)
  # @return [Anima]
  def remove(*names); end

  private

  # Fail unless keys in +attribute_hash+ matches #attribute_names
  #
  # @param klass [Class] the class being initialized
  # @param attribute_hash [Hash] the attributes to initialize +object+ with
  # @raise [Error]
  # @return [undefined]
  def assert_known_attributes(klass, attribute_hash); end

  # Infect the instance with anima
  #
  # @param scope [Class, Module]
  # @return [undefined]
  def included(descendant); end

  # Return new instance
  #
  # @param attributes [Enumerable<Symbol>]
  # @return [Anima]
  def new(attributes); end
end

# An attribute
class Unparser::Anima::Attribute
  include ::Unparser::Equalizer::Methods
  include ::Unparser::Adamantium
  include ::Unparser::Adamantium::InstanceMethods
  extend ::Unparser::Adamantium::ModuleMethods
  extend ::Unparser::Adamantium::ClassMethods

  # Initialize attribute
  #
  # @param name [Symbol]
  # @return [Attribute] a new instance of Attribute
  def initialize(name); end

  # Get attribute value from object
  #
  # @param object [Object]
  # @return [Object]
  def get(object); end

  # Return instance variable name
  #
  # @return [Symbol]
  def instance_variable_name; end

  # Load attribute
  #
  # @param object [Object]
  # @param attributes [Hash]
  # @return [self]
  def load(object, attributes); end

  # Return attribute name
  #
  # @return [Symbol]
  def name; end

  # Set attribute value in object
  #
  # @param object [Object]
  # @param value [Object]
  # @return [self]
  def set(object, value); end
end

# Abstract base class for anima errors
class Unparser::Anima::Error < ::RuntimeError
  # Initialize object
  #
  # @param klass [Class] the class being initialized
  # @param missing [Enumerable<Symbol>]
  # @param unknown [Enumerable<Symbol>]
  # @return [undefined]
  def initialize(klass, missing, unknown); end
end

Unparser::Anima::Error::FORMAT = T.let(T.unsafe(nil), String)

# Static instance methods for anima infected classes
module Unparser::Anima::InstanceMethods
  # Initialize an anima infected object
  #
  #
  # @param attributes [#to_h] a hash that matches anima defined attributes
  # @return [undefined]
  def initialize(attributes); end

  # Return a hash representation of an anima infected object
  #
  # @api public
  # @example
  #   anima.to_h # => { :foo => : bar }
  # @return [Hash]
  def to_h; end

  # Return updated instance
  #
  # @api public
  # @example
  #   klass = Class.new do
  #   include Anima.new(:foo, :bar)
  #   end
  #
  #   foo = klass.new(:foo => 1, :bar => 2)
  #   updated = foo.with(:foo => 3)
  #   updated.foo # => 3
  #   updated.bar # => 2
  # @param attributes [Hash]
  # @return [Anima]
  def with(attributes); end
end

# Buffer used to emit into
class Unparser::Buffer
  # Initialize object
  #
  # @api private
  # @return [undefined]
  def initialize; end

  # Append string
  #
  # @api private
  # @param string [String]
  # @return [self]
  def append(string); end

  # Append a string without an indentation prefix
  #
  # @api private
  # @param string [String]
  # @return [self]
  def append_without_prefix(string); end

  # Capture the content written to the buffer within the block
  #
  # @api private
  # @return [String]
  def capture_content; end

  # Return content of buffer
  #
  # @api private
  # @return [String]
  def content; end

  # Test for a fresh line
  #
  # @api private
  # @return [Boolean]
  def fresh_line?; end

  # Increase indent
  #
  # @api private
  # @return [self]
  def indent; end

  # Write newline
  #
  # @api private
  # @return [self]
  def nl; end

  def root_indent; end

  # Decrease indent
  #
  # @api private
  # @return [self]
  def unindent; end

  # Write raw fragment to buffer
  #
  # Does not do indentation logic.
  #
  # @param fragment [String]
  # @return [self]
  def write(fragment); end

  private

  def prefix; end
end

Unparser::Buffer::INDENT_SPACE = T.let(T.unsafe(nil), String)
Unparser::Buffer::NL = T.let(T.unsafe(nil), String)

# Unparser specific AST builder defaulting to modern AST format
class Unparser::Builder < ::Parser::Builders::Default
  # @return [Builder] a new instance of Builder
  def initialize; end
end

# Unparser CLI implementation
class Unparser::CLI
  # Initialize object
  #
  # @api private
  # @param arguments [Array<String>]
  # @return [undefined]
  def initialize(arguments); end

  # Add options
  #
  #
  # @api private
  # @param builder [OptionParser]
  # @return [undefined]
  def add_options(builder); end

  # Return exit status
  #
  # @api private
  # @return [Integer]
  def exit_status; end

  private

  def effective_targets; end
  def process_target(target); end
  def targets(file_name); end

  class << self
    # Run CLI
    #
    # @api private
    # @param arguments [Array<String>]
    # @return [Integer] the exit status
    def run(*arguments); end
  end
end

Unparser::CLI::EXIT_FAILURE = T.let(T.unsafe(nil), Integer)
Unparser::CLI::EXIT_SUCCESS = T.let(T.unsafe(nil), Integer)

class Unparser::CLI::Target
  include ::Unparser::AbstractType
  extend ::Unparser::AbstractType::AbstractMethodDeclarations

  class << self
    def new(*args, &block); end
  end
end

# Path target
class Unparser::CLI::Target::Path < ::Unparser::CLI::Target
  include ::Unparser::Equalizer::Methods

  # Literal for this target
  #
  # @return [Validation]
  def literal_validation; end

  # Validation for this target
  #
  # @return [Validation]
  def validation; end
end

# String target
class Unparser::CLI::Target::String
  include ::Unparser::Equalizer::Methods

  # Literal for this target
  #
  # @return [Validation]
  def literal_validation; end

  # Validation for this target
  #
  # @return [Validation]
  def validation; end
end

# Class to colorize strings
class Unparser::Color
  include ::Unparser::Equalizer::Methods
  include ::Unparser::Adamantium
  include ::Unparser::Adamantium::InstanceMethods
  extend ::Unparser::Adamantium::ModuleMethods
  extend ::Unparser::Adamantium::ClassMethods

  # Format text with color
  #
  # @param text [String]
  # @return [String]
  def format(text); end
end

Unparser::Color::GREEN = T.let(T.unsafe(nil), Unparser::Color)
Unparser::Color::NONE = T.let(T.unsafe(nil), T.untyped)
Unparser::Color::RED = T.let(T.unsafe(nil), Unparser::Color)

# Holds the comments that remain to be emitted
class Unparser::Comments
  # Initialize object
  #
  # @api private
  # @param comments [Array]
  # @return [undefined]
  def initialize(comments); end

  # Consume part or all of the node
  #
  # @api private
  # @param node [Parser::AST::Node]
  # @param source_part [Symbol]
  # @return [undefined]
  def consume(node, source_part = T.unsafe(nil)); end

  # Proxy to singleton
  #
  # NOTICE:
  #   Delegating to stateless helpers is a pattern I saw many times in our code.
  #   Maybe we should make another helper module? include SingletonDelegator.new(:source_range) ?
  #
  # @api private
  # @return [undefined]
  def source_range(*arguments); end

  # Take all remaining comments
  #
  # @api private
  # @return [Array]
  def take_all; end

  # Take comments appear in the source before the specified part of the node
  #
  # @api private
  # @param node [Parser::AST::Node]
  # @param source_part [Symbol]
  # @return [Array]
  def take_before(node, source_part); end

  # Take end-of-line comments
  #
  # @api private
  # @return [Array]
  def take_eol_comments; end

  private

  def take_up_to_line(line); end
  def take_while; end
  def unshift_documents(comments); end

  class << self
    # Return source location part
    #
    # FIXME: This method should not be needed. It does to much inline signalling.
    #
    # :reek:ManualDispatch
    #
    # @api private
    # @param node [Parser::AST::Node]
    # @param part [Symbol]
    # @return [Parser::Source::Range] if present
    # @return [nil] otherwise
    def source_range(node, part); end
  end
end

# A mixin to define a composition
#
# Original code before vendoring and reduction from: https://github.com/mbj/concord.
class Unparser::Concord < ::Module
  include ::Unparser::Equalizer::Methods
  include ::Unparser::Adamantium
  include ::Unparser::Adamantium::InstanceMethods
  extend ::Unparser::Adamantium::ModuleMethods
  extend ::Unparser::Adamantium::ClassMethods

  # Initialize object
  #
  #
  # @api private
  # @return [undefined]
  def initialize(*names); end

  # Return names
  #
  # @api private
  # @return [Enumerable<Symbol>]
  def names; end

  private

  # Define equalizer
  #
  # @api private
  # @return [undefined]
  def define_equalizer; end

  # Define initialize method
  #
  # @api private
  # @return [undefined]
  def define_initialize; end

  # Define readers
  #
  # @api private
  # @return [undefined]
  def define_readers; end

  # Return instance variable names
  #
  # @api private
  # @return [String]
  def instance_variable_names; end
end

# The maximum number of objects the hosting class is composed of
Unparser::Concord::MAX_NR_OF_OBJECTS = T.let(T.unsafe(nil), Integer)

# Mixin for public attribute readers
class Unparser::Concord::Public < ::Unparser::Concord
  # Hook called when module is included
  #
  # @api private
  # @param descendant [Class, Module]
  # @return [undefined]
  def included(descendant); end
end

# All unparser constants maybe included in other libraries.
module Unparser::Constants; end

# All binary operators of the ruby language
Unparser::Constants::BINARY_OPERATORS = T.let(T.unsafe(nil), Set)

Unparser::Constants::KEYWORDS = T.let(T.unsafe(nil), Set)
Unparser::Constants::K_ALIAS = T.let(T.unsafe(nil), String)
Unparser::Constants::K_AND = T.let(T.unsafe(nil), String)
Unparser::Constants::K_BEGIN = T.let(T.unsafe(nil), String)
Unparser::Constants::K_BREAK = T.let(T.unsafe(nil), String)
Unparser::Constants::K_CASE = T.let(T.unsafe(nil), String)
Unparser::Constants::K_CLASS = T.let(T.unsafe(nil), String)
Unparser::Constants::K_DEF = T.let(T.unsafe(nil), String)
Unparser::Constants::K_DEFINE = T.let(T.unsafe(nil), String)
Unparser::Constants::K_DEFINED = T.let(T.unsafe(nil), String)

# Keywords
Unparser::Constants::K_DO = T.let(T.unsafe(nil), String)

Unparser::Constants::K_EEND = T.let(T.unsafe(nil), String)
Unparser::Constants::K_ELSE = T.let(T.unsafe(nil), String)
Unparser::Constants::K_ELSIF = T.let(T.unsafe(nil), String)
Unparser::Constants::K_ENCODING = T.let(T.unsafe(nil), String)
Unparser::Constants::K_END = T.let(T.unsafe(nil), String)
Unparser::Constants::K_ENSURE = T.let(T.unsafe(nil), String)
Unparser::Constants::K_FALSE = T.let(T.unsafe(nil), String)
Unparser::Constants::K_FILE = T.let(T.unsafe(nil), String)
Unparser::Constants::K_FOR = T.let(T.unsafe(nil), String)
Unparser::Constants::K_IF = T.let(T.unsafe(nil), String)
Unparser::Constants::K_IN = T.let(T.unsafe(nil), String)
Unparser::Constants::K_MODULE = T.let(T.unsafe(nil), String)
Unparser::Constants::K_NEXT = T.let(T.unsafe(nil), String)
Unparser::Constants::K_NIL = T.let(T.unsafe(nil), String)
Unparser::Constants::K_NOT = T.let(T.unsafe(nil), String)
Unparser::Constants::K_OR = T.let(T.unsafe(nil), String)
Unparser::Constants::K_POSTEXE = T.let(T.unsafe(nil), String)
Unparser::Constants::K_PREEXE = T.let(T.unsafe(nil), String)
Unparser::Constants::K_REDO = T.let(T.unsafe(nil), String)
Unparser::Constants::K_RESCUE = T.let(T.unsafe(nil), String)
Unparser::Constants::K_RETRY = T.let(T.unsafe(nil), String)
Unparser::Constants::K_RETURN = T.let(T.unsafe(nil), String)
Unparser::Constants::K_SELF = T.let(T.unsafe(nil), String)
Unparser::Constants::K_SUPER = T.let(T.unsafe(nil), String)
Unparser::Constants::K_THEN = T.let(T.unsafe(nil), String)
Unparser::Constants::K_TRUE = T.let(T.unsafe(nil), String)
Unparser::Constants::K_UNDEF = T.let(T.unsafe(nil), String)
Unparser::Constants::K_UNLESS = T.let(T.unsafe(nil), String)
Unparser::Constants::K_UNTIL = T.let(T.unsafe(nil), String)
Unparser::Constants::K_WHEN = T.let(T.unsafe(nil), String)
Unparser::Constants::K_WHILE = T.let(T.unsafe(nil), String)
Unparser::Constants::K_YIELD = T.let(T.unsafe(nil), String)

# All unary operators of the ruby language
Unparser::Constants::UNARY_OPERATORS = T.let(T.unsafe(nil), Set)

# DSL to help defining emitters
module Unparser::DSL
  private

  def children(*names); end
  def define_child(name, index); end
  def define_group(name, range); end
  def define_remaining_children(names); end
end

# Class to create diffs from source code
class Unparser::Diff
  include ::Unparser::Equalizer::Methods
  include ::Unparser::Adamantium
  include ::Unparser::Adamantium::InstanceMethods
  extend ::Unparser::Adamantium::ModuleMethods
  extend ::Unparser::Adamantium::ClassMethods

  # Colorized unified source diff between old and new
  #
  # @return [String] if there is a diff
  # @return [nil] otherwise
  def colorized_diff(&block); end

  # Unified source diff between old and new
  #
  # @return [String] if there is exactly one diff
  # @return [nil] otherwise
  def diff(&block); end

  private

  def diffs; end
  def hunks; end
  def max_length; end
  def minimized_hunk; end

  class << self
    # Build new object from source strings
    #
    # @param old [String]
    # @param new [String]
    # @return [Diff]
    def build(old, new); end

    private

    def colorize_line(line); end

    # Break up source into lines
    #
    # @param source [String]
    # @return [Array<String>]
    def lines(source); end
  end
end

Unparser::Diff::ADDITION = T.let(T.unsafe(nil), String)
Unparser::Diff::DELETION = T.let(T.unsafe(nil), String)
Unparser::Diff::NEWLINE = T.let(T.unsafe(nil), String)
Unparser::EMPTY_ARRAY = T.let(T.unsafe(nil), Array)
Unparser::EMPTY_STRING = T.let(T.unsafe(nil), String)

# RequireBLock
class Unparser::Either
  include ::Unparser::RequireBlock
  include ::Unparser::Equalizer::Methods
  include ::Unparser::Adamantium
  include ::Unparser::Adamantium::InstanceMethods
  extend ::Unparser::Adamantium::ModuleMethods
  extend ::Unparser::Adamantium::ClassMethods

  # Test for left constructor
  #
  # @return [Boolean]
  def left?; end

  # Test for right constructor
  #
  # @return [Boolean]
  def right?; end

  class << self
    # Execute block and wrap error in left
    #
    # @param exception [Class<Exception>]
    # @return [Either<Exception, Object>]
    def wrap_error(*exceptions); end
  end
end

class Unparser::Either::Left < ::Unparser::Either
  # Evaluate applicative block
  #
  # @return [Either::Left<Object>]
  def bind(&block); end

  # Evaluate left side of branch
  #
  # @param left [#call]
  # @param _right [#call]
  def either(left, _right); end

  # Evaluate functor block
  #
  # @return [Either::Left<Object>]
  def fmap(&block); end

  # Unwrap value from left
  #
  # @return [Object]
  def from_left; end

  # Unwrap value from right
  #
  # @return [Object]
  def from_right; end

  # Map over left value
  #
  # @return [Either::Right<Object>]
  def lmap; end
end

# Left
class Unparser::Either::Right < ::Unparser::Either
  # Evaluate applicative block
  #
  # @return [Either<Object>]
  # @yield [value]
  def bind; end

  # Evaluate right side of branch
  #
  # @param _left [#call]
  # @param right [#call]
  def either(_left, right); end

  # Evaluate functor block
  #
  # @return [Either::Right<Object>]
  def fmap; end

  # Unwrap value from left
  #
  # @return [Object]
  def from_left; end

  # Unwrap value from right
  #
  # @return [Object]
  def from_right; end

  # Map over left value
  #
  # @return [Either::Right<Object>]
  def lmap(&block); end
end

# Emitter base class
class Unparser::Emitter
  include ::Unparser::NodeHelpers
  include ::Unparser::Generation
  include ::Unparser::Constants
  include ::Unparser::AbstractType
  include ::Unparser::Adamantium
  include ::Unparser::Adamantium::InstanceMethods
  include ::Unparser::Anima::InstanceMethods
  include ::Unparser::Equalizer::Methods
  extend ::Unparser::AbstractType::AbstractMethodDeclarations
  extend ::Unparser::Adamantium::ModuleMethods
  extend ::Unparser::Adamantium::ClassMethods
  extend ::Unparser::DSL

  def buffer; end
  def comments; end

  # Dispatch node write as statement
  #
  # @api private
  # @return [undefined]
  def dispatch(*_arg0); end

  def emit_mlhs; end
  def local_variable_scope; end
  def node; end

  # LocalVariableRoot
  def node_type; end

  class << self
    def anima; end

    # Return emitter
    #
    #
    # @api private
    # @return [Emitter]
    def emitter(buffer:, comments:, node:, local_variable_scope:); end

    def new(*args, &block); end

    private

    # Register emitter for type
    #
    # @api private
    # @param types [Symbol]
    # @return [undefined]
    def handle(*types); end
  end
end

# Emitter for alias nodes
class Unparser::Emitter::Alias < ::Unparser::Emitter
  private

  def dispatch; end
  def remaining_children; end
  def source; end
  def target; end
end

# Arguments emitter
class Unparser::Emitter::Args < ::Unparser::Emitter
  def emit_block_arguments; end
  def emit_def_arguments; end
  def emit_lambda_arguments; end

  private

  def emit_shadowargs; end
  def normal_arguments(&block); end
  def shadowargs(&block); end
end

# Argument emitter
class Unparser::Emitter::Argument < ::Unparser::Emitter
  private

  def dispatch; end
  def name; end
  def remaining_children; end
end

# Array literal emitter
class Unparser::Emitter::Array < ::Unparser::Emitter
  def emit_heredoc_reminders; end

  private

  def dispatch; end
  def emitters(&block); end
end

# Emitter for array patterns
class Unparser::Emitter::ArrayPattern < ::Unparser::Emitter
  private

  def dispatch; end
  def emit_member(node); end
end

# Base class for assignment emitters
class Unparser::Emitter::Assignment < ::Unparser::Emitter
  def emit_heredoc_reminders; end
  def emit_left(*_arg0); end
  def symbol_name; end

  private

  def dispatch; end
  def emit_right; end
end

Unparser::Emitter::Assignment::BINARY_OPERATOR = T.let(T.unsafe(nil), Array)

# Constant assignment emitter
class Unparser::Emitter::Assignment::Constant < ::Unparser::Emitter::Assignment
  private

  def base; end
  def emit_left; end
  def name; end
  def remaining_children; end
  def right; end
end

# Variable assignment emitter
class Unparser::Emitter::Assignment::Variable < ::Unparser::Emitter::Assignment
  private

  def emit_left; end
  def name; end
  def remaining_children; end
  def right; end
end

# Emitter for begin nodes
class Unparser::Emitter::Begin < ::Unparser::Emitter
  def emit_heredoc_reminders; end

  private

  def body; end
  def dispatch; end
  def remaining_children; end
end

# Non send binary operator / keyword emitter
class Unparser::Emitter::Binary < ::Unparser::Emitter
  private

  def dispatch; end
  def writer(&block); end
end

# Base class for and and or op-assign
class Unparser::Emitter::BinaryAssign < ::Unparser::Emitter
  def emit_heredoc_reminders; end

  private

  def dispatch; end
  def expression; end
  def remaining_children; end
  def target; end
end

Unparser::Emitter::BinaryAssign::MAP = T.let(T.unsafe(nil), Hash)

# Block emitter
class Unparser::Emitter::Block < ::Unparser::Emitter
  private

  def arguments; end
  def body; end
  def dispatch; end
  def emit_block_arguments; end
  def emit_lambda_arguments; end
  def emit_send_target; end
  def emit_target; end

  # @return [Boolean]
  def need_do?; end

  # @return [Boolean]
  def numblock?; end

  def remaining_children; end
  def target; end
  def target_writer(&block); end
  def write_close; end
  def write_open; end
end

# Block pass node emitter
class Unparser::Emitter::BlockPass < ::Unparser::Emitter
  private

  def dispatch; end
  def name; end
  def remaining_children; end
end

# Emitter for toplevel constant reference nodes
class Unparser::Emitter::CBase < ::Unparser::Emitter
  private

  # Perform dispatch
  #
  # @api private
  # @return [undefined]
  def dispatch; end
end

# Emitter for case nodes
class Unparser::Emitter::Case < ::Unparser::Emitter
  private

  def condition; end
  def dispatch; end
  def emit_condition; end
  def emit_else; end
  def emit_whens; end
  def remaining_children; end
  def whens(&block); end
end

# Emitter for case guards
class Unparser::Emitter::CaseGuard < ::Unparser::Emitter
  private

  def condition; end
  def dispatch; end
  def remaining_children; end
end

Unparser::Emitter::CaseGuard::MAP = T.let(T.unsafe(nil), Hash)

# Emitter for case matches
class Unparser::Emitter::CaseMatch < ::Unparser::Emitter
  private

  def dispatch; end
  def else_branch; end
  def emit_else_branch; end
  def patterns(&block); end
  def remaining_children; end
  def target; end
end

# Emitter for class nodes
class Unparser::Emitter::Class < ::Unparser::Emitter
  include ::Unparser::Emitter::LocalVariableRoot

  def local_variable_scope(&block); end

  private

  def body; end
  def dispatch; end
  def emit_superclass; end
  def name; end
  def remaining_children; end
  def superclass; end
end

# Emitter for constant access
class Unparser::Emitter::Const < ::Unparser::Emitter
  private

  def dispatch; end
  def emit_scope; end
  def name; end
  def remaining_children; end
  def scope; end
end

# Emitter for const pattern node
class Unparser::Emitter::ConstPattern < ::Unparser::Emitter
  private

  def const; end
  def dispatch; end
  def pattern; end
  def remaining_children; end
end

# Dynamic string emitter
class Unparser::Emitter::DStr < ::Unparser::Emitter
  def emit_heredoc_reminders; end

  private

  def dispatch; end
end

# Dynamic symbol literal emitter
class Unparser::Emitter::DSym < ::Unparser::Emitter
  private

  def dispatch; end
  def emit_begin_child(component); end
  def emit_str_child(value); end
end

# Emitter for def node
class Unparser::Emitter::Def < ::Unparser::Emitter
  include ::Unparser::Emitter::LocalVariableRoot

  def local_variable_scope(&block); end

  private

  def body(*_arg0); end
  def dispatch; end
  def emit_arguments; end
  def emit_name(*_arg0); end
end

# Instance def emitter
class Unparser::Emitter::Def::Instance < ::Unparser::Emitter::Def
  private

  def arguments; end
  def body; end
  def emit_name; end
  def name; end
  def remaining_children; end
end

# Emitter for defines on singleton
class Unparser::Emitter::Def::Singleton < ::Unparser::Emitter::Def
  private

  def arguments; end
  def body; end
  def emit_name; end
  def name; end
  def remaining_children; end
  def subject; end

  # @return [Boolean]
  def subject_without_parens?; end
end

# Emitter for defined? nodes
class Unparser::Emitter::Defined < ::Unparser::Emitter
  private

  def dispatch; end
  def remaining_children; end
  def subject; end
end

# Emitter for in pattern nodes
class Unparser::Emitter::FindPattern < ::Unparser::Emitter
  private

  def dispatch; end
end

# Emitter for flip flops
class Unparser::Emitter::FlipFlop < ::Unparser::Emitter
  def symbol_name; end

  private

  def dispatch; end
  def left; end
  def remaining_children; end
  def right; end
end

Unparser::Emitter::FlipFlop::MAP = T.let(T.unsafe(nil), Hash)
Unparser::Emitter::FlipFlop::SYMBOLS = T.let(T.unsafe(nil), Hash)

# Emiter for float literals
class Unparser::Emitter::Float < ::Unparser::Emitter
  private

  def dispatch; end
  def remaining_children; end
  def value; end
end

Unparser::Emitter::Float::INFINITY = T.let(T.unsafe(nil), Float)
Unparser::Emitter::Float::NEG_INFINITY = T.let(T.unsafe(nil), Float)

# Emitter control flow modifiers
class Unparser::Emitter::FlowModifier < ::Unparser::Emitter
  def emit_heredoc_reminders; end

  private

  def dispatch; end
  def emit_arguments; end
end

Unparser::Emitter::FlowModifier::MAP = T.let(T.unsafe(nil), Hash)

# Emitter for for nodes
class Unparser::Emitter::For < ::Unparser::Emitter
  private

  def assignment; end
  def body; end
  def condition; end
  def dispatch; end
  def emit_condition; end
  def remaining_children; end
end

# Emitter for Hash literals
class Unparser::Emitter::Hash < ::Unparser::Emitter
  def emit_heredoc_reminders; end
  def emit_last_argument_hash; end

  private

  def dispatch; end
  def emit_hash_body; end
  def emit_heredoc_reminder_member(node); end
end

# Emitter for hash patterns
class Unparser::Emitter::HashPattern < ::Unparser::Emitter
  def emit_const_pattern; end

  private

  def dispatch; end
  def emit_hash_body; end
  def emit_match_var(node); end
  def emit_member(node); end
  def emit_pair(node); end
  def write_symbol_body(symbol); end
end

# Base class for pre and postexe emitters
class Unparser::Emitter::Hookexe < ::Unparser::Emitter
  private

  def body; end
  def dispatch; end
  def remaining_children; end
end

Unparser::Emitter::Hookexe::MAP = T.let(T.unsafe(nil), Hash)

# Emitter if nodes
class Unparser::Emitter::If < ::Unparser::Emitter
  def emit_ternary; end

  private

  def condition; end
  def dispatch; end
  def else_branch; end
  def emit_condition; end
  def emit_else_branch; end
  def emit_if_branch; end
  def emit_normal; end
  def emit_postcondition; end
  def if_branch; end
  def keyword; end

  # @return [Boolean]
  def postcondition?; end

  def remaining_children; end

  # @return [Boolean]
  def unless?; end
end

# Emitter for in pattern nodes
class Unparser::Emitter::InMatch < ::Unparser::Emitter
  private

  def dispatch; end
  def pattern; end
  def remaining_children; end
  def target; end
end

# Emitter for in pattern nodes
class Unparser::Emitter::InPattern < ::Unparser::Emitter
  private

  def branch; end
  def dispatch; end
  def else_branch; end
  def remaining_children; end
  def target; end
  def unless_guard; end
end

# Emitter for send to index references
class Unparser::Emitter::Index < ::Unparser::Emitter
  private

  def dispatch; end
  def emit_receiver; end
end

# Emitter for assign to index nodes
class Unparser::Emitter::Index::Assign < ::Unparser::Emitter::Index
  def dispatch; end
  def emit_heredoc_reminders; end
  def emit_mlhs; end

  private

  def emit_operation(indices); end
end

Unparser::Emitter::Index::Assign::NO_VALUE_PARENT = T.let(T.unsafe(nil), Set)
Unparser::Emitter::Index::Assign::VALUE_RANGE = T.let(T.unsafe(nil), Range)

class Unparser::Emitter::Index::Reference < ::Unparser::Emitter::Index
  private

  def emit_operation; end
  def indices(&block); end
end

# Emitter for explicit begins
class Unparser::Emitter::KWBegin < ::Unparser::Emitter
  private

  def dispatch; end
  def emit_multiple_body; end
end

# Optional keyword argument emitter
class Unparser::Emitter::KeywordOptional < ::Unparser::Emitter
  private

  def dispatch; end
  def name; end
  def remaining_children; end
  def value; end
end

# Emitter for splats
class Unparser::Emitter::KwSplat < ::Unparser::Emitter
  private

  def dispatch; end
  def remaining_children; end
  def subject; end
end

# Keyword argument emitter
class Unparser::Emitter::Kwarg < ::Unparser::Emitter
  private

  def dispatch; end
  def name; end
  def remaining_children; end
end

class Unparser::Emitter::Kwargs < ::Unparser::Emitter
  def dispatch; end
end

# Emitter for lambda nodes
class Unparser::Emitter::Lambda < ::Unparser::Emitter
  private

  def dispatch; end
end

module Unparser::Emitter::LocalVariableRoot
  # Return local variable root
  #
  # @api private
  # @return [Parser::AST::Node]
  def local_variable_scope; end

  class << self
    # @private
    def included(descendant); end
  end
end

# Emitter for multiple assignment nodes
class Unparser::Emitter::MASGN < ::Unparser::Emitter
  private

  def dispatch; end
  def remaining_children; end
  def source; end
  def target; end
end

# Emitter for multiple assignment left hand side
class Unparser::Emitter::MLHS < ::Unparser::Emitter
  private

  def dispatch; end
  def emit_many; end
  def emit_one_child_mlhs; end
end

Unparser::Emitter::MLHS::NO_COMMA = T.let(T.unsafe(nil), Array)

# Base class for special match node emitters
class Unparser::Emitter::Match < ::Unparser::Emitter; end

# Emitter for match current line
class Unparser::Emitter::Match::CurrentLine < ::Unparser::Emitter::Match
  private

  def dispatch; end
  def regexp; end
  def remaining_children; end
end

# Emitter for match with local variable assignment
class Unparser::Emitter::Match::Lvasgn < ::Unparser::Emitter::Match
  private

  def dispatch; end
  def lvasgn; end
  def regexp; end
  def remaining_children; end
end

# Emitter for in pattern nodes
class Unparser::Emitter::MatchAlt < ::Unparser::Emitter
  private

  def dispatch; end
  def left; end
  def remaining_children; end
  def right; end
end

# Emitter for in pattern nodes
class Unparser::Emitter::MatchAs < ::Unparser::Emitter
  private

  def dispatch; end
  def left; end
  def remaining_children; end
  def right; end
end

# Emitter for in pattern nodes
class Unparser::Emitter::MatchPattern < ::Unparser::Emitter
  private

  def dispatch; end
  def pattern; end
  def remaining_children; end
  def target; end
end

# Modern ast format emits `match_pattern`
# node on single line pre 3.0, but 3.0+ uses `match_pattern_p`
Unparser::Emitter::MatchPattern::SYMBOL = T.let(T.unsafe(nil), String)

class Unparser::Emitter::MatchPatternP < ::Unparser::Emitter
  private

  def dispatch; end
  def pattern; end
  def remaining_children; end
  def target; end
end

# Emiter for match rest nodes
class Unparser::Emitter::MatchRest < ::Unparser::Emitter
  def dispatch; end
  def emit_array_pattern; end
  def emit_hash_pattern; end

  private

  def emit_match_var; end
  def match_var; end
  def remaining_children; end
end

# Emitter for in pattern nodes
class Unparser::Emitter::MatchVar < ::Unparser::Emitter
  private

  def dispatch; end
  def name; end
  def remaining_children; end
end

# Emitter for module nodes
class Unparser::Emitter::Module < ::Unparser::Emitter
  include ::Unparser::Emitter::LocalVariableRoot

  def local_variable_scope(&block); end

  private

  def body; end
  def dispatch; end
  def name; end
  def remaining_children; end
end

# Emitter for block and kwrestarg arguments
class Unparser::Emitter::Morearg < ::Unparser::Emitter
  private

  def dispatch; end
  def name; end
  def remaining_children; end
end

Unparser::Emitter::Morearg::MAP = T.let(T.unsafe(nil), Hash)
Unparser::Emitter::NO_INDENT = T.let(T.unsafe(nil), Array)

# Emitter for nth_ref nodes (regexp captures)
class Unparser::Emitter::NthRef < ::Unparser::Emitter
  private

  def dispatch; end
  def name; end
  def remaining_children; end
end

Unparser::Emitter::NthRef::PREFIX = T.let(T.unsafe(nil), String)

# Emitter for op assign
class Unparser::Emitter::OpAssign < ::Unparser::Emitter
  private

  def dispatch; end
  def emit_operator; end
  def operator; end
  def remaining_children; end
  def target; end
  def value; end
end

# Optional argument emitter
class Unparser::Emitter::Optarg < ::Unparser::Emitter
  private

  def dispatch; end
  def name; end
  def remaining_children; end
  def value; end
end

# Emitter for key value pairs in hash literals or kwargs
class Unparser::Emitter::Pair < ::Unparser::Emitter
  private

  # @return [Boolean]
  def colon?(key); end

  def dispatch; end
  def key; end
  def remaining_children; end
  def value; end
end

Unparser::Emitter::Pair::BAREWORD = T.let(T.unsafe(nil), Regexp)

# Emitter for pin nodes
class Unparser::Emitter::Pin < ::Unparser::Emitter
  private

  def dispatch; end
  def remaining_children; end
  def target; end
end

# Emitter for postconditions
class Unparser::Emitter::Post < ::Unparser::Emitter
  private

  def body; end
  def condition; end
  def dispatch; end
  def remaining_children; end
end

Unparser::Emitter::Post::MAP = T.let(T.unsafe(nil), Hash)

# Base class for primitive emitters
class Unparser::Emitter::Primitive < ::Unparser::Emitter
  private

  def remaining_children; end
  def value; end
end

# Emitter for complex literals
class Unparser::Emitter::Primitive::Complex < ::Unparser::Emitter::Primitive
  private

  def dispatch; end
  def emit_imaginary; end
  def imaginary_node; end
end

Unparser::Emitter::Primitive::Complex::MAP = T.let(T.unsafe(nil), Hash)
Unparser::Emitter::Primitive::Complex::RATIONAL_FORMAT = T.let(T.unsafe(nil), String)

# Emitter for primitives based on Object#inspect
class Unparser::Emitter::Primitive::Inspect < ::Unparser::Emitter::Primitive
  private

  def dispatch; end
end

# Emiter for numeric literals
class Unparser::Emitter::Primitive::Numeric < ::Unparser::Emitter::Primitive
  private

  def dispatch; end
end

# Emitter for rational literals
class Unparser::Emitter::Primitive::Rational < ::Unparser::Emitter::Primitive
  private

  def dispatch; end
  def write_rational(value); end
end

Unparser::Emitter::Primitive::Rational::RATIONAL_FORMAT = T.let(T.unsafe(nil), String)

# Progarg emitter
class Unparser::Emitter::Procarg < ::Unparser::Emitter
  private

  def dispatch; end

  # @return [Boolean]
  def needs_parens?; end
end

Unparser::Emitter::Procarg::PARENS = T.let(T.unsafe(nil), Array)

# Registry for node emitters
Unparser::Emitter::REGISTRY = T.let(T.unsafe(nil), Hash)

# Range emitters
class Unparser::Emitter::Range < ::Unparser::Emitter
  def symbol_name; end

  private

  def begin_node; end
  def dispatch; end
  def end_node; end
  def remaining_children; end
end

Unparser::Emitter::Range::SYMBOLS = T.let(T.unsafe(nil), Hash)
Unparser::Emitter::Range::TOKENS = T.let(T.unsafe(nil), Hash)

# Emitter for regexp literals
class Unparser::Emitter::Regexp < ::Unparser::Emitter
  private

  def body(&block); end
  def dispatch; end
  def emit_body(node); end
  def emit_options; end
end

# Emitter for while and until nodes
class Unparser::Emitter::Repetition < ::Unparser::Emitter
  private

  def body; end
  def condition; end
  def dispatch; end
  def emit_keyword; end
  def emit_normal; end
  def emit_postcontrol; end

  # @return [Boolean]
  def postcontrol?; end

  def remaining_children; end
end

Unparser::Emitter::Repetition::MAP = T.let(T.unsafe(nil), Hash)

# Emitter for rescue nodes
class Unparser::Emitter::Rescue < ::Unparser::Emitter
  private

  def dispatch; end
end

# Rest argument emitter
class Unparser::Emitter::Restarg < ::Unparser::Emitter
  private

  def dispatch; end
  def name; end
  def remaining_children; end
end

# Root emitter a special case
class Unparser::Emitter::Root < ::Unparser::Emitter
  include ::Unparser::Emitter::LocalVariableRoot

  def dispatch; end
  def local_variable_scope(&block); end
end

Unparser::Emitter::Root::END_NL = T.let(T.unsafe(nil), Array)

# Emitter for sclass nodes
class Unparser::Emitter::SClass < ::Unparser::Emitter
  private

  def body; end
  def dispatch; end
  def object; end
  def remaining_children; end
end

# Emitter for send
class Unparser::Emitter::Send < ::Unparser::Emitter
  def emit_heredoc_reminders; end
  def emit_mlhs; end

  private

  def dispatch; end
  def writer(&block); end
end

# Emitter for simple nodes that generate a single token
class Unparser::Emitter::Simple < ::Unparser::Emitter
  private

  def dispatch; end
end

Unparser::Emitter::Simple::MAP = T.let(T.unsafe(nil), Hash)

# Emitter for splats
class Unparser::Emitter::Splat < ::Unparser::Emitter
  def emit_mlhs; end

  private

  def dispatch; end
  def remaining_children; end
  def subject; end
  def subject_emitter(&block); end
end

# Emitter for super nodes
class Unparser::Emitter::Super < ::Unparser::Emitter
  private

  def dispatch; end
end

# Emitter for undef nodes
class Unparser::Emitter::Undef < ::Unparser::Emitter
  private

  def dispatch; end
end

# Emitter for various variable accesses
class Unparser::Emitter::Variable < ::Unparser::Emitter
  private

  def dispatch; end
  def name; end
  def remaining_children; end
end

# Emitter for when nodes
class Unparser::Emitter::When < ::Unparser::Emitter
  private

  def captures(&block); end
  def dispatch; end
  def emit_captures; end
end

# Dynamic execute string literal emitter
class Unparser::Emitter::XStr < ::Unparser::Emitter
  private

  def dispatch; end
  def emit_begin(component); end
  def emit_heredoc; end
  def emit_string(value); end
  def emit_xstr; end
  def escape_xstr(input); end

  # @return [Boolean]
  def heredoc?; end
end

# Emitter for yield node
class Unparser::Emitter::Yield < ::Unparser::Emitter
  private

  def dispatch; end
end

# Define equality, equivalence and inspection methods
#
# Original code before vendoring and reduction from: https://github.com/dkubb/equalizer.
class Unparser::Equalizer < ::Module
  # Initialize an Equalizer with the given keys
  #
  # Will use the keys with which it is initialized to define #cmp?,
  # #hash, and #inspect
  #
  #
  # @api private
  # @param keys [Array<Symbol>]
  # @return [undefined]
  def initialize(*keys); end

  private

  def define_cmp_method; end
  def define_hash_method; end
  def define_inspect_method; end
  def define_methods; end
  def included(descendant); end
end

# The comparison methods
module Unparser::Equalizer::Methods
  # Compare the object with other object for equivalency
  #
  # @api public
  # @example
  #   object == other  # => true or false
  # @param other [Object] the other object to compare with
  # @return [Boolean]
  def ==(other); end

  # Compare the object with other object for equality
  #
  # @api public
  # @example
  #   object.eql?(other)  # => true or false
  # @param other [Object] the other object to compare with
  # @return [Boolean]
  def eql?(other); end
end

module Unparser::Generation
  def emit_heredoc_reminders; end
  def symbol_name; end
  def write_to_buffer; end

  private

  def children; end
  def conditional_parentheses(flag, &block); end
  def delimited(nodes, delimiter = T.unsafe(nil), &block); end
  def emit_body(node, indent: T.unsafe(nil)); end
  def emit_body_ensure_rescue(node); end
  def emit_body_inner(node); end
  def emit_body_member(node); end
  def emit_body_rescue(node); end
  def emit_comments(comments); end
  def emit_comments_before(source_part = T.unsafe(nil)); end
  def emit_ensure(node); end
  def emit_eof_comments; end
  def emit_eol_comments; end
  def emit_join(nodes, emit_node, emit_delimiter); end
  def emit_optional_body(node, indent: T.unsafe(nil)); end
  def emit_optional_body_ensure_rescue(node); end
  def emit_rescue_postcontrol(node); end
  def emit_rescue_regular(node); end
  def emitter(node); end
  def first_child; end
  def indented; end
  def k_end; end
  def nl; end
  def parentheses(open = T.unsafe(nil), close = T.unsafe(nil)); end
  def visit(node); end
  def visit_deep(node); end
  def with_comments; end
  def write(*strings); end
  def writer_with(klass, node); end
  def ws; end
end

Unparser::Generation::EXTRA_NL = T.let(T.unsafe(nil), Array)

# Error raised when unparser encounters an invalid AST
class Unparser::InvalidNodeError < ::RuntimeError
  # @return [InvalidNodeError] a new instance of InvalidNodeError
  def initialize(message, node); end

  # Returns the value of attribute node.
  def node; end
end

module Unparser::NodeDetails
  include ::Unparser::NodeHelpers
  include ::Unparser::Constants

  private

  def children; end

  class << self
    # @private
    def included(descendant); end
  end
end

class Unparser::NodeDetails::Send
  include ::Unparser::NodeHelpers
  include ::Unparser::Constants
  include ::Unparser::NodeDetails
  include ::Unparser::Equalizer::Methods
  include ::Unparser::Adamantium
  include ::Unparser::Adamantium::InstanceMethods
  extend ::Unparser::Adamantium::ModuleMethods
  extend ::Unparser::Adamantium::ClassMethods
  extend ::Unparser::DSL

  def arguments(&block); end

  # @return [Boolean]
  def arguments?; end

  # @return [Boolean]
  def assignment?(&block); end

  # @return [Boolean]
  def assignment_operator?; end

  # @return [Boolean]
  def binary_syntax_allowed?; end

  def non_assignment_selector; end
  def receiver; end
  def selector; end

  # @return [Boolean]
  def selector_binary_operator?; end

  # @return [Boolean]
  def selector_unary_operator?; end

  def string_selector(&block); end

  private

  def remaining_children; end
end

Unparser::NodeDetails::Send::ASSIGN_SUFFIX = T.let(T.unsafe(nil), String)
Unparser::NodeDetails::Send::NON_ASSIGN_RANGE = T.let(T.unsafe(nil), Range)

module Unparser::NodeHelpers
  # Helper for building nodes
  #
  # @api private
  # @param type [Symbol]
  # @param children [Array]
  # @return [Parser::AST::Node]
  def n(type, children = T.unsafe(nil)); end

  # @return [Boolean]
  def n?(type, node); end

  # Helper for building nodes
  #
  # @api private
  # @param type [Symbol]
  # @param children [Parser::AST::Node]
  # @return [Parser::AST::Node]
  def s(type, *children); end

  def unwrap_single_begin(node); end

  private

  def n_arg?(node); end
  def n_args?(node); end
  def n_array?(node); end
  def n_array_pattern?(node); end
  def n_begin?(node); end
  def n_block?(node); end
  def n_cbase?(node); end
  def n_const?(node); end
  def n_dstr?(node); end
  def n_empty_else?(node); end
  def n_ensure?(node); end
  def n_hash?(node); end
  def n_hash_pattern?(node); end
  def n_if?(node); end
  def n_in_pattern?(node); end
  def n_int?(node); end
  def n_kwarg?(node); end
  def n_kwargs?(node); end
  def n_kwsplat?(node); end
  def n_lambda?(node); end
  def n_match_rest?(node); end
  def n_pair?(node); end
  def n_rescue?(node); end
  def n_send?(node); end
  def n_shadowarg?(node); end
  def n_splat?(node); end
  def n_str?(node); end
  def n_sym?(node); end
end

module Unparser::RequireBlock
  private

  # Raise error unless block is provided
  #
  # @raise [MissingBlockError] if no block is given
  # @return [self]
  def require_block; end
end

class Unparser::UnknownNodeError < ::ArgumentError; end

# Validation of unparser results
class Unparser::Validation
  include ::Unparser::Anima::InstanceMethods
  include ::Unparser::Equalizer::Methods
  include ::Unparser::Adamantium
  include ::Unparser::Adamantium::InstanceMethods
  extend ::Unparser::Adamantium::ModuleMethods
  extend ::Unparser::Adamantium::ClassMethods

  def generated_node; end
  def generated_source; end
  def identification; end
  def original_node; end
  def original_source; end

  # Return error report
  #
  # @api private
  # @return [String]
  def report(&block); end

  # Test if source could be unparsed successfully
  #
  # @api private
  # @return [Boolean]
  def success?; end

  private

  def make_report(label, attribute_name); end
  def node_diff_report; end
  def report_exception(exception); end

  class << self
    def anima; end

    # Create validator from node
    #
    # @param original_node [Parser::AST::Node]
    # @return [Validator]
    def from_node(original_node); end

    # Create validator from file
    #
    # @param path [Pathname]
    # @return [Validator]
    def from_path(path); end

    # Create validator from string
    #
    # @param original_source [String]
    # @return [Validator]
    def from_string(original_source); end

    private

    def const_unit(_value); end
  end
end

class Unparser::Validation::Literal < ::Unparser::Validation
  def report; end

  # @return [Boolean]
  def success?; end

  private

  def source_diff_report; end
end

module Unparser::Writer
  include ::Unparser::NodeHelpers
  include ::Unparser::Generation
  include ::Unparser::Anima::InstanceMethods
  include ::Unparser::Equalizer::Methods

  mixes_in_class_methods ::Unparser::DSL

  class << self
    # @private
    def included(descendant); end
  end
end

class Unparser::Writer::Binary
  include ::Unparser::Adamantium
  include ::Unparser::Adamantium::InstanceMethods
  include ::Unparser::NodeHelpers
  include ::Unparser::Generation
  include ::Unparser::Writer
  include ::Unparser::Anima::InstanceMethods
  include ::Unparser::Equalizer::Methods
  extend ::Unparser::Adamantium::ModuleMethods
  extend ::Unparser::Adamantium::ClassMethods
  extend ::Unparser::DSL

  def buffer; end
  def comments; end
  def dispatch; end
  def emit_operator; end
  def local_variable_scope; end
  def node; end
  def symbol_name; end

  private

  def effective_symbol; end
  def emit_with(map); end
  def keyword_symbol; end
  def left; end
  def left_emitter(&block); end
  def operator_symbol; end
  def remaining_children; end
  def right; end
  def right_emitter(&block); end

  class << self
    def anima; end
  end
end

Unparser::Writer::Binary::KEYWORD_SYMBOLS = T.let(T.unsafe(nil), Hash)
Unparser::Writer::Binary::KEYWORD_TOKENS = T.let(T.unsafe(nil), Hash)
Unparser::Writer::Binary::MAP = T.let(T.unsafe(nil), Hash)
Unparser::Writer::Binary::NEED_KEYWORD = T.let(T.unsafe(nil), Array)
Unparser::Writer::Binary::OPERATOR_SYMBOLS = T.let(T.unsafe(nil), Hash)
Unparser::Writer::Binary::OPERATOR_TOKENS = T.let(T.unsafe(nil), Hash)

class Unparser::Writer::DynamicString
  include ::Unparser::Adamantium
  include ::Unparser::Adamantium::InstanceMethods
  include ::Unparser::NodeHelpers
  include ::Unparser::Generation
  include ::Unparser::Writer
  include ::Unparser::Anima::InstanceMethods
  include ::Unparser::Equalizer::Methods
  extend ::Unparser::Adamantium::ModuleMethods
  extend ::Unparser::Adamantium::ClassMethods
  extend ::Unparser::DSL

  def buffer; end
  def comments; end
  def dispatch; end
  def emit_heredoc_reminder; end
  def local_variable_scope; end
  def node; end

  private

  # @return [Boolean]
  def breakpoint?(child, current); end

  def classify(node); end
  def classify_str(node); end
  def emit_body(children); end
  def emit_dstr; end
  def emit_dynamic(child); end
  def emit_dynamic_component(node); end
  def emit_heredoc_body; end
  def emit_heredoc_footer; end
  def emit_heredoc_header; end
  def emit_normal_heredoc_body; end
  def emit_segment(children, index); end
  def emit_squiggly_heredoc_body; end
  def escape_dynamic(string); end

  # @return [Boolean]
  def heredoc?; end

  def heredoc_header; end

  # @return [Boolean]
  def heredoc_pattern?; end

  # @return [Boolean]
  def heredoc_pattern_2?; end

  # @return [Boolean]
  def heredoc_pattern_3?; end

  # @return [Boolean]
  def nl_last_child?; end

  def segments; end

  # @return [Boolean]
  def str_empty?(node); end

  # @return [Boolean]
  def str_nl?(node); end

  # @return [Boolean]
  def str_ws?(node); end

  class << self
    def anima; end
  end
end

Unparser::Writer::DynamicString::FLAT_INTERPOLATION = T.let(T.unsafe(nil), Set)
Unparser::Writer::DynamicString::PATTERNS_2 = T.let(T.unsafe(nil), Array)
Unparser::Writer::DynamicString::PATTERNS_3 = T.let(T.unsafe(nil), Array)

# Writer for rescue bodies
class Unparser::Writer::Resbody
  include ::Unparser::NodeHelpers
  include ::Unparser::Generation
  include ::Unparser::Writer
  include ::Unparser::Anima::InstanceMethods
  include ::Unparser::Equalizer::Methods
  extend ::Unparser::DSL

  def buffer; end
  def comments; end
  def emit_postcontrol; end
  def emit_regular; end
  def local_variable_scope; end
  def node; end

  private

  def assignment; end
  def body; end
  def emit_assignment; end
  def emit_exception; end
  def exception; end
  def remaining_children; end

  class << self
    def anima; end
  end
end

class Unparser::Writer::Rescue
  include ::Unparser::Adamantium
  include ::Unparser::Adamantium::InstanceMethods
  include ::Unparser::NodeHelpers
  include ::Unparser::Generation
  include ::Unparser::Writer
  include ::Unparser::Anima::InstanceMethods
  include ::Unparser::Equalizer::Methods
  extend ::Unparser::Adamantium::ModuleMethods
  extend ::Unparser::Adamantium::ClassMethods
  extend ::Unparser::DSL

  def buffer; end
  def comments; end
  def emit_heredoc_reminders; end
  def emit_postcontrol; end
  def emit_regular; end
  def local_variable_scope; end
  def node; end

  private

  def body; end
  def else_node; end
  def emit_rescue_body(node); end
  def remaining_children; end
  def rescue_bodies(&block); end
  def rescue_body; end

  class << self
    def anima; end
  end
end

# Writer for send
class Unparser::Writer::Send
  include ::Unparser::NodeHelpers
  include ::Unparser::Generation
  include ::Unparser::Constants
  include ::Unparser::Adamantium
  include ::Unparser::Adamantium::InstanceMethods
  include ::Unparser::Writer
  include ::Unparser::Anima::InstanceMethods
  include ::Unparser::Equalizer::Methods
  extend ::Unparser::Adamantium::ModuleMethods
  extend ::Unparser::Adamantium::ClassMethods
  extend ::Unparser::DSL

  def buffer; end
  def comments; end
  def dispatch; end
  def emit_heredoc_reminders; end
  def emit_mlhs; end
  def emit_selector; end
  def local_variable_scope; end
  def node; end

  private

  def arguments; end

  # @return [Boolean]
  def avoid_clash?; end

  def details(&block); end
  def effective_writer(&block); end
  def effective_writer_class; end
  def emit_arguments; end
  def emit_heredoc_reminder(argument); end
  def emit_normal_arguments; end
  def emit_operator; end
  def emit_send_regular(node); end

  # @return [Boolean]
  def local_variable_clash?; end

  # @return [Boolean]
  def parses_as_constant?; end

  def receiver; end
  def remaining_children; end
  def selector; end

  # @return [Boolean]
  def write_as_attribute_assignment?; end

  class << self
    def anima; end
  end
end

# Writer for send as attribute assignment
class Unparser::Writer::Send::AttributeAssignment < ::Unparser::Writer::Send
  def dispatch; end
  def emit_send_mlhs; end

  private

  def emit_attribute; end
  def emit_receiver; end
  def first_argument; end
  def receiver; end
  def remaining_children; end
  def selector; end
end

# Writer for binary sends
class Unparser::Writer::Send::Binary < ::Unparser::Writer::Send
  def dispatch; end

  private

  def emit_operator; end
  def emit_right; end
end

Unparser::Writer::Send::INDEX_ASSIGN = T.let(T.unsafe(nil), Symbol)
Unparser::Writer::Send::INDEX_REFERENCE = T.let(T.unsafe(nil), Symbol)
Unparser::Writer::Send::OPERATORS = T.let(T.unsafe(nil), Hash)

# Writer for "regular" receiver.selector(arguments...) case
class Unparser::Writer::Send::Regular < ::Unparser::Writer::Send
  def dispatch; end
  def emit_arguments_without_heredoc_body; end
  def emit_receiver; end
  def emit_send_mlhs; end
end

# Writer for unary sends
class Unparser::Writer::Send::Unary < ::Unparser::Writer::Send
  def dispatch; end
end

Unparser::Writer::Send::Unary::MAP = T.let(T.unsafe(nil), Hash)
