# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `rubocop-rails` gem.
# Please instead update this file by running `bin/tapioca sync`.

# typed: true

module RuboCop
end

module RuboCop::Cop
end

module RuboCop::Cop::ActiveRecordHelper
  extend(::RuboCop::AST::NodePattern::Macros)

  def external_dependency_checksum; end
  def find_belongs_to(param0); end
  def find_set_table_name(param0); end
  def foreign_key_of(belongs_to); end
  def in_where?(node); end
  def resolve_relation_into_column(name:, class_node:, table:); end
  def schema; end
  def table_name(class_node); end
end

RuboCop::Cop::ActiveRecordHelper::WHERE_METHODS = T.let(T.unsafe(nil), Array)

module RuboCop::Cop::EnforceSuperclass
  def on_class(node); end
  def on_send(node); end

  private

  def register_offense(offense_node); end

  class << self
    def included(base); end
  end
end

module RuboCop::Cop::IndexMethod
  def on_block(node); end
  def on_csend(node); end
  def on_send(node); end

  private

  def execute_correction(corrector, node, correction); end
  def extract_captures(match); end
  def handle_possible_offense(node, match, match_desc); end
  def new_method_name; end
  def on_bad_each_with_object(_node); end
  def on_bad_hash_brackets_map(_node); end
  def on_bad_map_to_h(_node); end
  def on_bad_to_h(_node); end
  def prepare_correction(node); end
end

class RuboCop::Cop::IndexMethod::Autocorrection < ::Struct
  def block_node; end
  def block_node=(_); end
  def leading; end
  def leading=(_); end
  def match; end
  def match=(_); end
  def set_new_arg_name(transformed_argname, corrector); end
  def set_new_body_expression(transforming_body_expr, corrector); end
  def set_new_method_name(new_method_name, corrector); end
  def strip_prefix_and_suffix(node, corrector); end
  def trailing; end
  def trailing=(_); end

  class << self
    def [](*_arg0); end
    def from_each_with_object(node, match); end
    def from_hash_brackets_map(node, match); end
    def from_map_to_h(node, match); end
    def from_to_h(node, match); end
    def inspect; end
    def members; end
    def new(*_arg0); end
  end
end

class RuboCop::Cop::IndexMethod::Captures < ::Struct
  def noop_transformation?; end
  def transformed_argname; end
  def transformed_argname=(_); end
  def transforming_body_expr; end
  def transforming_body_expr=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def members; end
    def new(*_arg0); end
  end
end

RuboCop::Cop::IndexMethod::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

module RuboCop::Cop::Rails
end

class RuboCop::Cop::Rails::ActionFilter < ::RuboCop::Cop::Base
  include(::RuboCop::Cop::ConfigurableEnforcedStyle)
  extend(::RuboCop::Cop::AutoCorrector)

  def on_block(node); end
  def on_send(node); end

  private

  def bad_methods; end
  def check_method_node(node); end
  def good_methods; end
  def preferred_method(method); end
end

RuboCop::Cop::Rails::ActionFilter::ACTION_METHODS = T.let(T.unsafe(nil), Array)

RuboCop::Cop::Rails::ActionFilter::FILTER_METHODS = T.let(T.unsafe(nil), Array)

RuboCop::Cop::Rails::ActionFilter::MSG = T.let(T.unsafe(nil), String)

RuboCop::Cop::Rails::ActionFilter::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Rails::ActiveRecordAliases < ::RuboCop::Cop::Base
  extend(::RuboCop::Cop::AutoCorrector)

  def on_csend(node); end
  def on_send(node); end
end

RuboCop::Cop::Rails::ActiveRecordAliases::ALIASES = T.let(T.unsafe(nil), Hash)

RuboCop::Cop::Rails::ActiveRecordAliases::MSG = T.let(T.unsafe(nil), String)

RuboCop::Cop::Rails::ActiveRecordAliases::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Rails::ActiveRecordCallbacksOrder < ::RuboCop::Cop::Base
  extend(::RuboCop::Cop::AutoCorrector)

  def on_class(class_node); end

  private

  def autocorrect(corrector, node); end
  def begin_pos_with_comment(node); end
  def buffer; end
  def callback?(node); end
  def defined_callbacks(class_node); end
  def end_position_for(node); end
  def inline_comment?(comment); end
  def left_siblings_of(node); end
  def siblings_of(node); end
  def source_range_with_comment(node); end
  def start_line_position(node); end
end

RuboCop::Cop::Rails::ActiveRecordCallbacksOrder::CALLBACKS_IN_ORDER = T.let(T.unsafe(nil), Array)

RuboCop::Cop::Rails::ActiveRecordCallbacksOrder::CALLBACKS_ORDER_MAP = T.let(T.unsafe(nil), Hash)

RuboCop::Cop::Rails::ActiveRecordCallbacksOrder::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Rails::ActiveRecordOverride < ::RuboCop::Cop::Base
  def on_def(node); end

  private

  def active_model?(parent_class_name); end
  def callback_names(method_name); end
  def find_parent_class_name(node); end
  def message(method_name); end
end

RuboCop::Cop::Rails::ActiveRecordOverride::ACTIVE_RECORD_CLASSES = T.let(T.unsafe(nil), Array)

RuboCop::Cop::Rails::ActiveRecordOverride::BAD_METHODS = T.let(T.unsafe(nil), Array)

RuboCop::Cop::Rails::ActiveRecordOverride::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Rails::ActiveSupportAliases < ::RuboCop::Cop::Base
  extend(::RuboCop::Cop::AutoCorrector)

  def append(param0 = T.unsafe(nil)); end
  def ends_with?(param0 = T.unsafe(nil)); end
  def on_send(node); end
  def prepend(param0 = T.unsafe(nil)); end
  def starts_with?(param0 = T.unsafe(nil)); end
end

RuboCop::Cop::Rails::ActiveSupportAliases::ALIASES = T.let(T.unsafe(nil), Hash)

RuboCop::Cop::Rails::ActiveSupportAliases::MSG = T.let(T.unsafe(nil), String)

RuboCop::Cop::Rails::ActiveSupportAliases::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Rails::AfterCommitOverride < ::RuboCop::Cop::Base
  def on_class(class_node); end

  private

  def after_commit_callback?(node); end
  def class_send_nodes(class_node); end
  def each_after_commit_callback(class_node); end
  def named_callback?(node); end
end

RuboCop::Cop::Rails::AfterCommitOverride::AFTER_COMMIT_CALLBACKS = T.let(T.unsafe(nil), Array)

RuboCop::Cop::Rails::AfterCommitOverride::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Rails::ApplicationController < ::RuboCop::Cop::Base
  include(::RuboCop::Cop::EnforceSuperclass)
  extend(::RuboCop::Cop::AutoCorrector)

  def class_definition(param0 = T.unsafe(nil)); end
  def class_new_definition(param0 = T.unsafe(nil)); end
end

RuboCop::Cop::Rails::ApplicationController::BASE_PATTERN = T.let(T.unsafe(nil), String)

RuboCop::Cop::Rails::ApplicationController::MSG = T.let(T.unsafe(nil), String)

RuboCop::Cop::Rails::ApplicationController::SUPERCLASS = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Rails::ApplicationJob < ::RuboCop::Cop::Base
  include(::RuboCop::Cop::EnforceSuperclass)
  extend(::RuboCop::Cop::AutoCorrector)
  extend(::RuboCop::Cop::TargetRailsVersion)

  def autocorrect(node); end
  def class_definition(param0 = T.unsafe(nil)); end
  def class_new_definition(param0 = T.unsafe(nil)); end
end

RuboCop::Cop::Rails::ApplicationJob::BASE_PATTERN = T.let(T.unsafe(nil), String)

RuboCop::Cop::Rails::ApplicationJob::MSG = T.let(T.unsafe(nil), String)

RuboCop::Cop::Rails::ApplicationJob::SUPERCLASS = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Rails::ApplicationMailer < ::RuboCop::Cop::Base
  include(::RuboCop::Cop::EnforceSuperclass)
  extend(::RuboCop::Cop::AutoCorrector)
  extend(::RuboCop::Cop::TargetRailsVersion)

  def class_definition(param0 = T.unsafe(nil)); end
  def class_new_definition(param0 = T.unsafe(nil)); end
end

RuboCop::Cop::Rails::ApplicationMailer::BASE_PATTERN = T.let(T.unsafe(nil), String)

RuboCop::Cop::Rails::ApplicationMailer::MSG = T.let(T.unsafe(nil), String)

RuboCop::Cop::Rails::ApplicationMailer::SUPERCLASS = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Rails::ApplicationRecord < ::RuboCop::Cop::Base
  include(::RuboCop::Cop::EnforceSuperclass)
  extend(::RuboCop::Cop::AutoCorrector)
  extend(::RuboCop::Cop::TargetRailsVersion)

  def class_definition(param0 = T.unsafe(nil)); end
  def class_new_definition(param0 = T.unsafe(nil)); end
end

RuboCop::Cop::Rails::ApplicationRecord::BASE_PATTERN = T.let(T.unsafe(nil), String)

RuboCop::Cop::Rails::ApplicationRecord::MSG = T.let(T.unsafe(nil), String)

RuboCop::Cop::Rails::ApplicationRecord::SUPERCLASS = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Rails::ArelStar < ::RuboCop::Cop::Base
  extend(::RuboCop::Cop::AutoCorrector)

  def on_send(node); end
  def star_bracket?(param0 = T.unsafe(nil)); end
end

RuboCop::Cop::Rails::ArelStar::MSG = T.let(T.unsafe(nil), String)

RuboCop::Cop::Rails::ArelStar::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Rails::AssertNot < ::RuboCop::Cop::Base
  extend(::RuboCop::Cop::AutoCorrector)

  def offensive?(param0 = T.unsafe(nil)); end
  def on_send(node); end

  private

  def corrected_source(source); end
end

RuboCop::Cop::Rails::AssertNot::MSG = T.let(T.unsafe(nil), String)

RuboCop::Cop::Rails::AssertNot::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Rails::AttributeDefaultBlockValue < ::RuboCop::Cop::Base
  extend(::RuboCop::Cop::AutoCorrector)

  def attribute(param0 = T.unsafe(nil)); end
  def default_attribute(param0 = T.unsafe(nil)); end
  def on_send(node); end
end

RuboCop::Cop::Rails::AttributeDefaultBlockValue::MSG = T.let(T.unsafe(nil), String)

RuboCop::Cop::Rails::AttributeDefaultBlockValue::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

RuboCop::Cop::Rails::AttributeDefaultBlockValue::TYPE_OFFENDERS = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Rails::BelongsTo < ::RuboCop::Cop::Base
  extend(::RuboCop::Cop::AutoCorrector)
  extend(::RuboCop::Cop::TargetRailsVersion)

  def match_belongs_to_with_options(param0 = T.unsafe(nil)); end
  def on_send(node); end
end

RuboCop::Cop::Rails::BelongsTo::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

RuboCop::Cop::Rails::BelongsTo::SUPERFLOUS_REQUIRE_FALSE_MSG = T.let(T.unsafe(nil), String)

RuboCop::Cop::Rails::BelongsTo::SUPERFLOUS_REQUIRE_TRUE_MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Rails::Blank < ::RuboCop::Cop::Base
  extend(::RuboCop::Cop::AutoCorrector)

  def defining_blank?(param0 = T.unsafe(nil)); end
  def nil_or_empty?(param0 = T.unsafe(nil)); end
  def not_present?(param0 = T.unsafe(nil)); end
  def on_if(node); end
  def on_or(node); end
  def on_send(node); end
  def unless_present?(param0 = T.unsafe(nil)); end

  private

  def autocorrect(corrector, node); end
  def replacement(node); end
  def unless_condition(node, method_call); end
end

RuboCop::Cop::Rails::Blank::MSG_NIL_OR_EMPTY = T.let(T.unsafe(nil), String)

RuboCop::Cop::Rails::Blank::MSG_NOT_PRESENT = T.let(T.unsafe(nil), String)

RuboCop::Cop::Rails::Blank::MSG_UNLESS_PRESENT = T.let(T.unsafe(nil), String)

RuboCop::Cop::Rails::Blank::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Rails::BulkChangeTable < ::RuboCop::Cop::Base
  def on_def(node); end
  def on_send(node); end

  private

  def add_offense_for_alter_methods(node); end
  def add_offense_for_change_table(node); end
  def call_to_combinable_alter_method?(child_node); end
  def combinable_alter_methods; end
  def combinable_transformations; end
  def database; end
  def database_from_yaml; end
  def database_yaml; end
  def include_bulk_options?(node); end
  def support_bulk_alter?; end
end

class RuboCop::Cop::Rails::BulkChangeTable::AlterMethodsRecorder
  def initialize; end

  def flush; end
  def offensive_nodes; end
  def process(new_node); end
end

RuboCop::Cop::Rails::BulkChangeTable::COMBINABLE_ALTER_METHODS = T.let(T.unsafe(nil), Array)

RuboCop::Cop::Rails::BulkChangeTable::COMBINABLE_TRANSFORMATIONS = T.let(T.unsafe(nil), Array)

RuboCop::Cop::Rails::BulkChangeTable::MIGRATION_METHODS = T.let(T.unsafe(nil), Array)

RuboCop::Cop::Rails::BulkChangeTable::MSG_FOR_ALTER_METHODS = T.let(T.unsafe(nil), String)

RuboCop::Cop::Rails::BulkChangeTable::MSG_FOR_CHANGE_TABLE = T.let(T.unsafe(nil), String)

RuboCop::Cop::Rails::BulkChangeTable::MYSQL = T.let(T.unsafe(nil), String)

RuboCop::Cop::Rails::BulkChangeTable::MYSQL_COMBINABLE_ALTER_METHODS = T.let(T.unsafe(nil), Array)

RuboCop::Cop::Rails::BulkChangeTable::MYSQL_COMBINABLE_TRANSFORMATIONS = T.let(T.unsafe(nil), Array)

RuboCop::Cop::Rails::BulkChangeTable::POSTGRESQL = T.let(T.unsafe(nil), String)

RuboCop::Cop::Rails::BulkChangeTable::POSTGRESQL_COMBINABLE_ALTER_METHODS = T.let(T.unsafe(nil), Array)

RuboCop::Cop::Rails::BulkChangeTable::POSTGRESQL_COMBINABLE_TRANSFORMATIONS = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Rails::ContentTag < ::RuboCop::Cop::Base
  include(::RuboCop::Cop::RangeHelp)
  extend(::RuboCop::Cop::AutoCorrector)
  extend(::RuboCop::Cop::TargetRailsVersion)

  def on_send(node); end

  private

  def autocorrect(corrector, node); end
  def correction_range(node); end
  def method_name?(node); end
end

RuboCop::Cop::Rails::ContentTag::MSG = T.let(T.unsafe(nil), String)

RuboCop::Cop::Rails::ContentTag::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Rails::CreateTableWithTimestamps < ::RuboCop::Cop::Base
  def create_table_with_block?(param0 = T.unsafe(nil)); end
  def create_table_with_timestamps_proc?(param0 = T.unsafe(nil)); end
  def created_at_or_updated_at_included?(param0); end
  def on_send(node); end
  def timestamps_included?(param0); end

  private

  def time_columns_included?(node); end
end

RuboCop::Cop::Rails::CreateTableWithTimestamps::MSG = T.let(T.unsafe(nil), String)

RuboCop::Cop::Rails::CreateTableWithTimestamps::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Rails::Date < ::RuboCop::Cop::Base
  include(::RuboCop::Cop::ConfigurableEnforcedStyle)

  def on_const(node); end
  def on_csend(node); end
  def on_send(node); end

  private

  def bad_days; end
  def bad_methods; end
  def check_date_node(node); end
  def check_deprecated_methods(node); end
  def extract_method_chain(node); end
  def good_days; end
  def good_methods; end
  def method_send?(node); end
  def safe_chain?(node); end
  def safe_to_time?(node); end
end

RuboCop::Cop::Rails::Date::BAD_DAYS = T.let(T.unsafe(nil), Array)

RuboCop::Cop::Rails::Date::DEPRECATED_METHODS = T.let(T.unsafe(nil), Array)

RuboCop::Cop::Rails::Date::DEPRECATED_MSG = T.let(T.unsafe(nil), String)

RuboCop::Cop::Rails::Date::MSG = T.let(T.unsafe(nil), String)

RuboCop::Cop::Rails::Date::MSG_SEND = T.let(T.unsafe(nil), String)

RuboCop::Cop::Rails::Date::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Rails::DefaultScope < ::RuboCop::Cop::Base
  def class_method_definition?(param0 = T.unsafe(nil)); end
  def eigenclass_method_definition?(param0 = T.unsafe(nil)); end
  def method_call?(param0 = T.unsafe(nil)); end
  def on_defs(node); end
  def on_sclass(node); end
  def on_send(node); end
end

RuboCop::Cop::Rails::DefaultScope::MSG = T.let(T.unsafe(nil), String)

RuboCop::Cop::Rails::DefaultScope::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Rails::Delegate < ::RuboCop::Cop::Base
  extend(::RuboCop::Cop::AutoCorrector)

  def delegate?(param0 = T.unsafe(nil)); end
  def on_def(node); end

  private

  def arguments_match?(arg_array, body); end
  def include_prefix_case?; end
  def method_name_matches?(method_name, body); end
  def prefixed_method_name(body); end
  def private_or_protected_before(line); end
  def private_or_protected_delegation(node); end
  def private_or_protected_inline(line); end
  def register_offense(node); end
  def trivial_delegate?(def_node); end
end

RuboCop::Cop::Rails::Delegate::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Rails::DelegateAllowBlank < ::RuboCop::Cop::Base
  extend(::RuboCop::Cop::AutoCorrector)

  def allow_blank_option(param0 = T.unsafe(nil)); end
  def on_send(node); end
end

RuboCop::Cop::Rails::DelegateAllowBlank::MSG = T.let(T.unsafe(nil), String)

RuboCop::Cop::Rails::DelegateAllowBlank::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Rails::DynamicFindBy < ::RuboCop::Cop::Base
  extend(::RuboCop::Cop::AutoCorrector)

  def on_csend(node); end
  def on_send(node); end

  private

  def allowed_invocation?(node); end
  def allowed_method?(node); end
  def allowed_receiver?(node); end
  def autocorrect(corrector, node); end
  def autocorrect_argument_keywords(corrector, node, keywords); end
  def autocorrect_method_name(corrector, node); end
  def column_keywords(method); end
  def static_method_name(method_name); end
  def whitelisted?(node); end
end

RuboCop::Cop::Rails::DynamicFindBy::METHOD_PATTERN = T.let(T.unsafe(nil), Regexp)

RuboCop::Cop::Rails::DynamicFindBy::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Rails::EnumHash < ::RuboCop::Cop::Base
  extend(::RuboCop::Cop::AutoCorrector)

  def array_pair?(param0 = T.unsafe(nil)); end
  def enum?(param0 = T.unsafe(nil)); end
  def on_send(node); end

  private

  def enum_name(key); end
  def source(elem); end
end

RuboCop::Cop::Rails::EnumHash::MSG = T.let(T.unsafe(nil), String)

RuboCop::Cop::Rails::EnumHash::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Rails::EnumUniqueness < ::RuboCop::Cop::Base
  include(::RuboCop::Cop::Duplication)

  def enum?(param0 = T.unsafe(nil)); end
  def enum_values(param0 = T.unsafe(nil)); end
  def on_send(node); end

  private

  def enum_name(key); end
end

RuboCop::Cop::Rails::EnumUniqueness::MSG = T.let(T.unsafe(nil), String)

RuboCop::Cop::Rails::EnumUniqueness::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Rails::EnvironmentComparison < ::RuboCop::Cop::Base
  extend(::RuboCop::Cop::AutoCorrector)

  def comparing_str_env_with_rails_env_on_lhs?(param0 = T.unsafe(nil)); end
  def comparing_str_env_with_rails_env_on_rhs?(param0 = T.unsafe(nil)); end
  def comparing_sym_env_with_rails_env_on_lhs?(param0 = T.unsafe(nil)); end
  def comparing_sym_env_with_rails_env_on_rhs?(param0 = T.unsafe(nil)); end
  def content(param0 = T.unsafe(nil)); end
  def on_send(node); end

  private

  def autocorrect(corrector, node); end
  def build_predicate_method(node); end
  def build_predicate_method_for_rails_env_on_lhs(node); end
  def build_predicate_method_for_rails_env_on_rhs(node); end
  def rails_env_on_lhs?(node); end
end

RuboCop::Cop::Rails::EnvironmentComparison::MSG = T.let(T.unsafe(nil), String)

RuboCop::Cop::Rails::EnvironmentComparison::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

RuboCop::Cop::Rails::EnvironmentComparison::SYM_MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Rails::Exit < ::RuboCop::Cop::Base
  include(::RuboCop::Cop::ConfigurableEnforcedStyle)

  def on_send(node); end

  private

  def offending_node?(node); end
  def right_argument_count?(arg_nodes); end
  def right_receiver?(receiver_node); end
end

RuboCop::Cop::Rails::Exit::EXPLICIT_RECEIVERS = T.let(T.unsafe(nil), Array)

RuboCop::Cop::Rails::Exit::MSG = T.let(T.unsafe(nil), String)

RuboCop::Cop::Rails::Exit::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Rails::FilePath < ::RuboCop::Cop::Base
  include(::RuboCop::Cop::ConfigurableEnforcedStyle)
  include(::RuboCop::Cop::RangeHelp)

  def file_join_nodes?(param0 = T.unsafe(nil)); end
  def on_dstr(node); end
  def on_send(node); end
  def rails_root_join_nodes?(param0 = T.unsafe(nil)); end
  def rails_root_nodes?(param0); end

  private

  def check_for_file_join_with_rails_root(node); end
  def check_for_rails_root_join_with_slash_separated_path(node); end
  def check_for_rails_root_join_with_string_arguments(node); end
  def message(_range); end
  def register_offense(node); end
  def string_with_slash?(node); end
end

RuboCop::Cop::Rails::FilePath::MSG_ARGUMENTS = T.let(T.unsafe(nil), String)

RuboCop::Cop::Rails::FilePath::MSG_SLASHES = T.let(T.unsafe(nil), String)

RuboCop::Cop::Rails::FilePath::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Rails::FindBy < ::RuboCop::Cop::Base
  include(::RuboCop::Cop::RangeHelp)
  extend(::RuboCop::Cop::AutoCorrector)

  def on_csend(node); end
  def on_send(node); end
  def where_first?(param0 = T.unsafe(nil)); end

  private

  def autocorrect(corrector, node); end
end

RuboCop::Cop::Rails::FindBy::MSG = T.let(T.unsafe(nil), String)

RuboCop::Cop::Rails::FindBy::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Rails::FindById < ::RuboCop::Cop::Base
  include(::RuboCop::Cop::RangeHelp)
  extend(::RuboCop::Cop::AutoCorrector)

  def find_by?(param0 = T.unsafe(nil)); end
  def on_send(node); end
  def where_take?(param0 = T.unsafe(nil)); end

  private

  def build_find_by_bad_method(node, id_value); end
  def build_good_method(id_value); end
  def build_where_take_bad_method(id_value); end
  def find_by_offense_range(node); end
  def register_offense(range, id_value, bad_method); end
  def where_take_offense_range(node, where); end
end

RuboCop::Cop::Rails::FindById::MSG = T.let(T.unsafe(nil), String)

RuboCop::Cop::Rails::FindById::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Rails::FindEach < ::RuboCop::Cop::Base
  extend(::RuboCop::Cop::AutoCorrector)

  def on_send(node); end

  private

  def ignored?(node); end
end

RuboCop::Cop::Rails::FindEach::MSG = T.let(T.unsafe(nil), String)

RuboCop::Cop::Rails::FindEach::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

RuboCop::Cop::Rails::FindEach::SCOPE_METHODS = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Rails::HasAndBelongsToMany < ::RuboCop::Cop::Base
  def on_send(node); end
end

RuboCop::Cop::Rails::HasAndBelongsToMany::MSG = T.let(T.unsafe(nil), String)

RuboCop::Cop::Rails::HasAndBelongsToMany::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Rails::HasManyOrHasOneDependent < ::RuboCop::Cop::Base
  def active_resource_class?(param0); end
  def association_with_options?(param0 = T.unsafe(nil)); end
  def association_without_options?(param0 = T.unsafe(nil)); end
  def dependent_option?(param0 = T.unsafe(nil)); end
  def on_send(node); end
  def present_option?(param0 = T.unsafe(nil)); end
  def with_options_block(param0 = T.unsafe(nil)); end

  private

  def active_resource?(node); end
  def contain_valid_options_in_with_options_block?(node); end
  def valid_options?(options); end
  def valid_options_in_with_options_block?(node); end
end

RuboCop::Cop::Rails::HasManyOrHasOneDependent::MSG = T.let(T.unsafe(nil), String)

RuboCop::Cop::Rails::HasManyOrHasOneDependent::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Rails::HelperInstanceVariable < ::RuboCop::Cop::Base
  def form_builder_class?(param0 = T.unsafe(nil)); end
  def on_ivar(node); end
  def on_ivasgn(node); end

  private

  def inherit_form_builder?(node); end
end

RuboCop::Cop::Rails::HelperInstanceVariable::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Rails::HttpPositionalArguments < ::RuboCop::Cop::Base
  extend(::RuboCop::Cop::AutoCorrector)
  extend(::RuboCop::Cop::TargetRailsVersion)

  def http_request?(param0 = T.unsafe(nil)); end
  def kwsplat_hash?(param0 = T.unsafe(nil)); end
  def on_send(node); end

  private

  def convert_hash_data(data, type); end
  def correction(node); end
  def correction_template(node); end
  def format_arg?(node); end
  def needs_conversion?(data); end
  def special_keyword_arg?(node); end
end

RuboCop::Cop::Rails::HttpPositionalArguments::KEYWORD_ARGS = T.let(T.unsafe(nil), Array)

RuboCop::Cop::Rails::HttpPositionalArguments::MSG = T.let(T.unsafe(nil), String)

RuboCop::Cop::Rails::HttpPositionalArguments::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Rails::HttpStatus < ::RuboCop::Cop::Base
  include(::RuboCop::Cop::ConfigurableEnforcedStyle)
  extend(::RuboCop::Cop::AutoCorrector)

  def http_status(param0 = T.unsafe(nil)); end
  def on_send(node); end
  def status_code(param0 = T.unsafe(nil)); end

  private

  def checker_class; end
end

class RuboCop::Cop::Rails::HttpStatus::NumericStyleChecker
  def initialize(node); end

  def message; end
  def node; end
  def offensive?; end
  def preferred_style; end

  private

  def number; end
  def permitted_symbol?; end
  def symbol; end
end

RuboCop::Cop::Rails::HttpStatus::NumericStyleChecker::DEFAULT_MSG = T.let(T.unsafe(nil), String)

RuboCop::Cop::Rails::HttpStatus::NumericStyleChecker::MSG = T.let(T.unsafe(nil), String)

RuboCop::Cop::Rails::HttpStatus::NumericStyleChecker::PERMITTED_STATUS = T.let(T.unsafe(nil), Array)

RuboCop::Cop::Rails::HttpStatus::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Rails::HttpStatus::SymbolicStyleChecker
  def initialize(node); end

  def message; end
  def node; end
  def offensive?; end
  def preferred_style; end

  private

  def custom_http_status_code?; end
  def number; end
  def symbol; end
end

RuboCop::Cop::Rails::HttpStatus::SymbolicStyleChecker::DEFAULT_MSG = T.let(T.unsafe(nil), String)

RuboCop::Cop::Rails::HttpStatus::SymbolicStyleChecker::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Rails::IgnoredSkipActionFilterOption < ::RuboCop::Cop::Base
  def filter_options(param0 = T.unsafe(nil)); end
  def on_send(node); end

  private

  def if_and_except?(options); end
  def if_and_only?(options); end
  def options_hash(options); end
end

RuboCop::Cop::Rails::IgnoredSkipActionFilterOption::FILTERS = T.let(T.unsafe(nil), Array)

RuboCop::Cop::Rails::IgnoredSkipActionFilterOption::MSG = T.let(T.unsafe(nil), String)

RuboCop::Cop::Rails::IgnoredSkipActionFilterOption::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Rails::IndexBy < ::RuboCop::Cop::Base
  include(::RuboCop::Cop::IndexMethod)
  extend(::RuboCop::Cop::AutoCorrector)

  def on_bad_each_with_object(param0 = T.unsafe(nil)); end
  def on_bad_hash_brackets_map(param0 = T.unsafe(nil)); end
  def on_bad_map_to_h(param0 = T.unsafe(nil)); end
  def on_bad_to_h(param0 = T.unsafe(nil)); end

  private

  def new_method_name; end
end

class RuboCop::Cop::Rails::IndexWith < ::RuboCop::Cop::Base
  include(::RuboCop::Cop::IndexMethod)
  extend(::RuboCop::Cop::AutoCorrector)
  extend(::RuboCop::Cop::TargetRailsVersion)

  def on_bad_each_with_object(param0 = T.unsafe(nil)); end
  def on_bad_hash_brackets_map(param0 = T.unsafe(nil)); end
  def on_bad_map_to_h(param0 = T.unsafe(nil)); end
  def on_bad_to_h(param0 = T.unsafe(nil)); end

  private

  def new_method_name; end
end

class RuboCop::Cop::Rails::Inquiry < ::RuboCop::Cop::Base
  def on_send(node); end
end

RuboCop::Cop::Rails::Inquiry::MSG = T.let(T.unsafe(nil), String)

RuboCop::Cop::Rails::Inquiry::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Rails::InverseOf < ::RuboCop::Cop::Base
  def as_option?(param0 = T.unsafe(nil)); end
  def association_recv_arguments(param0 = T.unsafe(nil)); end
  def conditions_option?(param0 = T.unsafe(nil)); end
  def foreign_key_option?(param0 = T.unsafe(nil)); end
  def inverse_of_nil_option?(param0 = T.unsafe(nil)); end
  def inverse_of_option?(param0 = T.unsafe(nil)); end
  def on_send(node); end
  def options_contain_inverse_of?(options); end
  def options_from_argument(param0 = T.unsafe(nil)); end
  def options_ignoring_inverse_of?(options); end
  def options_requiring_inverse_of?(options); end
  def polymorphic_option?(param0 = T.unsafe(nil)); end
  def same_context_in_with_options?(arg, recv); end
  def scope?(arguments); end
  def through_option?(param0 = T.unsafe(nil)); end
  def with_options_arguments(recv, node); end

  private

  def message(options); end
end

RuboCop::Cop::Rails::InverseOf::NIL_MSG = T.let(T.unsafe(nil), String)

RuboCop::Cop::Rails::InverseOf::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

RuboCop::Cop::Rails::InverseOf::SPECIFY_MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Rails::LexicallyScopedActionFilter < ::RuboCop::Cop::Base
  def on_send(node); end
  def only_or_except_filter_methods(param0 = T.unsafe(nil)); end

  private

  def array_values(node); end
  def message(methods, parent); end
end

RuboCop::Cop::Rails::LexicallyScopedActionFilter::FILTERS = T.let(T.unsafe(nil), Array)

RuboCop::Cop::Rails::LexicallyScopedActionFilter::MSG = T.let(T.unsafe(nil), String)

RuboCop::Cop::Rails::LexicallyScopedActionFilter::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Rails::LinkToBlank < ::RuboCop::Cop::Base
  extend(::RuboCop::Cop::AutoCorrector)

  def blank_target?(param0 = T.unsafe(nil)); end
  def includes_noopener?(param0 = T.unsafe(nil)); end
  def on_send(node); end
  def rel_node?(param0 = T.unsafe(nil)); end

  private

  def add_rel(send_node, offence_node, corrector); end
  def append_to_rel(rel_node, corrector); end
  def autocorrect(corrector, send_node, node, option_nodes); end
  def contains_noopener?(value); end
end

RuboCop::Cop::Rails::LinkToBlank::MSG = T.let(T.unsafe(nil), String)

RuboCop::Cop::Rails::LinkToBlank::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Rails::MailerName < ::RuboCop::Cop::Base
  extend(::RuboCop::Cop::AutoCorrector)

  def class_definition?(param0 = T.unsafe(nil)); end
  def class_new_definition?(param0 = T.unsafe(nil)); end
  def mailer_base_class?(param0 = T.unsafe(nil)); end
  def on_class(node); end
  def on_send(node); end

  private

  def autocorrect(corrector, node); end
  def mailer_suffix?(mailer_name); end
end

RuboCop::Cop::Rails::MailerName::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Rails::MatchRoute < ::RuboCop::Cop::Base
  extend(::RuboCop::Cop::AutoCorrector)

  def match_method_call?(param0 = T.unsafe(nil)); end
  def on_send(node); end
  def routes_draw?(param0 = T.unsafe(nil)); end

  private

  def extract_via(node); end
  def http_method?(method); end
  def http_method_and_options(node); end
  def register_offense(node, http_method); end
  def replacement(path_node, options_node); end
  def via_pair(node); end
  def within_routes?(node); end
end

RuboCop::Cop::Rails::MatchRoute::HTTP_METHODS = T.let(T.unsafe(nil), Array)

RuboCop::Cop::Rails::MatchRoute::MSG = T.let(T.unsafe(nil), String)

RuboCop::Cop::Rails::MatchRoute::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Rails::NegateInclude < ::RuboCop::Cop::Base
  extend(::RuboCop::Cop::AutoCorrector)

  def negate_include_call?(param0 = T.unsafe(nil)); end
  def on_send(node); end
end

RuboCop::Cop::Rails::NegateInclude::MSG = T.let(T.unsafe(nil), String)

RuboCop::Cop::Rails::NegateInclude::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Rails::NotNullColumn < ::RuboCop::Cop::Base
  def add_not_null_column?(param0 = T.unsafe(nil)); end
  def add_not_null_reference?(param0 = T.unsafe(nil)); end
  def default_option?(param0 = T.unsafe(nil)); end
  def null_false?(param0 = T.unsafe(nil)); end
  def on_send(node); end

  private

  def check_add_column(node); end
  def check_add_reference(node); end
  def check_pairs(pairs); end
end

RuboCop::Cop::Rails::NotNullColumn::MSG = T.let(T.unsafe(nil), String)

RuboCop::Cop::Rails::NotNullColumn::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Rails::OrderById < ::RuboCop::Cop::Base
  include(::RuboCop::Cop::RangeHelp)

  def on_send(node); end
  def order_by_id?(param0 = T.unsafe(nil)); end

  private

  def offense_range(node); end
end

RuboCop::Cop::Rails::OrderById::MSG = T.let(T.unsafe(nil), String)

RuboCop::Cop::Rails::OrderById::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Rails::Output < ::RuboCop::Cop::Base
  def io_output?(param0 = T.unsafe(nil)); end
  def on_send(node); end
  def output?(param0 = T.unsafe(nil)); end

  private

  def match_gvar?(sym); end
end

RuboCop::Cop::Rails::Output::MSG = T.let(T.unsafe(nil), String)

RuboCop::Cop::Rails::Output::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Rails::OutputSafety < ::RuboCop::Cop::Base
  def on_csend(node); end
  def on_send(node); end

  private

  def looks_like_rails_html_safe?(node); end
  def looks_like_rails_raw?(node); end
  def looks_like_rails_safe_concat?(node); end
  def non_interpolated_string?(node); end
end

RuboCop::Cop::Rails::OutputSafety::MSG = T.let(T.unsafe(nil), String)

RuboCop::Cop::Rails::OutputSafety::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Rails::Pick < ::RuboCop::Cop::Base
  extend(::RuboCop::Cop::AutoCorrector)
  extend(::RuboCop::Cop::TargetRailsVersion)

  def on_send(node); end
  def pick_candidate?(param0 = T.unsafe(nil)); end

  private

  def message(receiver); end
end

RuboCop::Cop::Rails::Pick::MSG = T.let(T.unsafe(nil), String)

RuboCop::Cop::Rails::Pick::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Rails::Pluck < ::RuboCop::Cop::Base
  extend(::RuboCop::Cop::AutoCorrector)
  extend(::RuboCop::Cop::TargetRailsVersion)

  def on_block(node); end
  def pluck_candidate?(param0 = T.unsafe(nil)); end

  private

  def message(method, argument, element, value); end
  def offense_range(node); end
end

RuboCop::Cop::Rails::Pluck::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Rails::PluckId < ::RuboCop::Cop::Base
  include(::RuboCop::Cop::RangeHelp)
  include(::RuboCop::Cop::ActiveRecordHelper)
  extend(::RuboCop::Cop::AutoCorrector)

  def on_send(node); end
  def pluck_id_call?(param0 = T.unsafe(nil)); end

  private

  def offense_range(node); end
end

RuboCop::Cop::Rails::PluckId::MSG = T.let(T.unsafe(nil), String)

RuboCop::Cop::Rails::PluckId::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Rails::PluckInWhere < ::RuboCop::Cop::Base
  include(::RuboCop::Cop::ActiveRecordHelper)
  include(::RuboCop::Cop::ConfigurableEnforcedStyle)
  extend(::RuboCop::Cop::AutoCorrector)

  def on_send(node); end

  private

  def root_receiver(node); end
end

RuboCop::Cop::Rails::PluckInWhere::MSG = T.let(T.unsafe(nil), String)

RuboCop::Cop::Rails::PluckInWhere::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Rails::PluralizationGrammar < ::RuboCop::Cop::Base
  extend(::RuboCop::Cop::AutoCorrector)

  def on_send(node); end

  private

  def correct_method(method_name); end
  def duration_method?(method_name); end
  def literal_number?(node); end
  def message(number, method_name); end
  def offense?(node); end
  def plural_method?(method_name); end
  def plural_receiver?(number); end
  def pluralize(method_name); end
  def singular_method?(method_name); end
  def singular_receiver?(number); end
  def singularize(method_name); end
end

RuboCop::Cop::Rails::PluralizationGrammar::MSG = T.let(T.unsafe(nil), String)

RuboCop::Cop::Rails::PluralizationGrammar::PLURAL_DURATION_METHODS = T.let(T.unsafe(nil), Hash)

RuboCop::Cop::Rails::PluralizationGrammar::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

RuboCop::Cop::Rails::PluralizationGrammar::SINGULAR_DURATION_METHODS = T.let(T.unsafe(nil), Hash)

class RuboCop::Cop::Rails::Presence < ::RuboCop::Cop::Base
  include(::RuboCop::Cop::RangeHelp)
  extend(::RuboCop::Cop::AutoCorrector)

  def on_if(node); end
  def redundant_negative_receiver_and_other(param0 = T.unsafe(nil)); end
  def redundant_receiver_and_other(param0 = T.unsafe(nil)); end

  private

  def build_source_for_or_method(other); end
  def ignore_if_node?(node); end
  def ignore_other_node?(node); end
  def message(node, receiver, other); end
  def register_offense(node, receiver, other); end
  def replacement(receiver, other); end
end

RuboCop::Cop::Rails::Presence::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Rails::Present < ::RuboCop::Cop::Base
  extend(::RuboCop::Cop::AutoCorrector)

  def autocorrect(corrector, node); end
  def exists_and_not_empty?(param0 = T.unsafe(nil)); end
  def not_blank?(param0 = T.unsafe(nil)); end
  def on_and(node); end
  def on_if(node); end
  def on_or(node); end
  def on_send(node); end
  def unless_blank?(param0 = T.unsafe(nil)); end

  private

  def replacement(node); end
  def unless_condition(node, method_call); end
end

RuboCop::Cop::Rails::Present::MSG_EXISTS_AND_NOT_EMPTY = T.let(T.unsafe(nil), String)

RuboCop::Cop::Rails::Present::MSG_NOT_BLANK = T.let(T.unsafe(nil), String)

RuboCop::Cop::Rails::Present::MSG_UNLESS_BLANK = T.let(T.unsafe(nil), String)

RuboCop::Cop::Rails::Present::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Rails::RakeEnvironment < ::RuboCop::Cop::Base
  extend(::RuboCop::Cop::AutoCorrector)

  def on_block(node); end
  def task_definition?(param0 = T.unsafe(nil)); end

  private

  def correct_task_dependency(task_name); end
  def task_name(node); end
  def with_dependencies?(node); end
  def with_hash_style_dependencies?(hash_node); end
end

RuboCop::Cop::Rails::RakeEnvironment::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Rails::ReadWriteAttribute < ::RuboCop::Cop::Base
  extend(::RuboCop::Cop::AutoCorrector)

  def on_send(node); end
  def read_write_attribute?(param0 = T.unsafe(nil)); end

  private

  def message(node); end
  def read_attribute_replacement(node); end
  def write_attribute_replacement(node); end
end

RuboCop::Cop::Rails::ReadWriteAttribute::MSG = T.let(T.unsafe(nil), String)

RuboCop::Cop::Rails::ReadWriteAttribute::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Rails::RedundantAllowNil < ::RuboCop::Cop::Base
  include(::RuboCop::Cop::RangeHelp)
  extend(::RuboCop::Cop::AutoCorrector)

  def on_send(node); end

  private

  def find_allow_nil_and_allow_blank(node); end
  def next_sibling(node); end
  def node_beg(node); end
  def node_end(node); end
  def previous_sibling(node); end
  def register_offense(allow_nil, message); end
end

RuboCop::Cop::Rails::RedundantAllowNil::MSG_ALLOW_NIL_FALSE = T.let(T.unsafe(nil), String)

RuboCop::Cop::Rails::RedundantAllowNil::MSG_SAME = T.let(T.unsafe(nil), String)

RuboCop::Cop::Rails::RedundantAllowNil::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Rails::RedundantForeignKey < ::RuboCop::Cop::Base
  include(::RuboCop::Cop::RangeHelp)
  extend(::RuboCop::Cop::AutoCorrector)

  def association_with_foreign_key(param0 = T.unsafe(nil)); end
  def on_send(node); end

  private

  def default_foreign_key(node, association_type, association_name, options); end
  def find_as_option(options); end
  def redundant?(node, association_type, association_name, options, foreign_key); end
end

RuboCop::Cop::Rails::RedundantForeignKey::MSG = T.let(T.unsafe(nil), String)

RuboCop::Cop::Rails::RedundantForeignKey::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Rails::RedundantReceiverInWithOptions < ::RuboCop::Cop::Base
  include(::RuboCop::Cop::RangeHelp)
  extend(::RuboCop::Cop::AutoCorrector)

  def all_block_nodes_in(param0); end
  def all_send_nodes_in(param0); end
  def on_block(node); end
  def with_options?(param0 = T.unsafe(nil)); end

  private

  def autocorrect(corrector, node); end
  def block_argument_range(node); end
  def same_value?(arg_node, recv_node); end
  def search_begin_pos_of_space_before_block_argument(begin_pos); end
end

RuboCop::Cop::Rails::RedundantReceiverInWithOptions::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Rails::ReflectionClassName < ::RuboCop::Cop::Base
  def association_with_reflection(param0 = T.unsafe(nil)); end
  def on_send(node); end
  def reflection_class_name(param0 = T.unsafe(nil)); end
end

RuboCop::Cop::Rails::ReflectionClassName::MSG = T.let(T.unsafe(nil), String)

RuboCop::Cop::Rails::ReflectionClassName::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Rails::RefuteMethods < ::RuboCop::Cop::Base
  include(::RuboCop::Cop::ConfigurableEnforcedStyle)
  extend(::RuboCop::Cop::AutoCorrector)

  def offensive?(param0 = T.unsafe(nil)); end
  def on_send(node); end

  private

  def bad_method?(method_name); end
  def convert_good_method(bad_method); end
  def offense_message(method_name); end
end

RuboCop::Cop::Rails::RefuteMethods::ASSERT_NOT_METHODS = T.let(T.unsafe(nil), Array)

RuboCop::Cop::Rails::RefuteMethods::CORRECTIONS = T.let(T.unsafe(nil), Hash)

RuboCop::Cop::Rails::RefuteMethods::MSG = T.let(T.unsafe(nil), String)

RuboCop::Cop::Rails::RefuteMethods::REFUTE_METHODS = T.let(T.unsafe(nil), Array)

RuboCop::Cop::Rails::RefuteMethods::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Rails::RelativeDateConstant < ::RuboCop::Cop::Base
  include(::RuboCop::Cop::RangeHelp)
  extend(::RuboCop::Cop::AutoCorrector)

  def on_casgn(node); end
  def on_masgn(node); end
  def on_or_asgn(node); end
  def relative_date?(param0 = T.unsafe(nil)); end
  def relative_date_assignment?(param0 = T.unsafe(nil)); end
  def relative_date_or_assignment?(param0 = T.unsafe(nil)); end

  private

  def autocorrect(corrector, node); end
  def message(method_name); end
  def offense_range(name, value); end
end

RuboCop::Cop::Rails::RelativeDateConstant::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Rails::RenderInline < ::RuboCop::Cop::Base
  def on_send(node); end
  def render_with_inline_option?(param0 = T.unsafe(nil)); end
end

RuboCop::Cop::Rails::RenderInline::MSG = T.let(T.unsafe(nil), String)

RuboCop::Cop::Rails::RenderInline::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Rails::RenderPlainText < ::RuboCop::Cop::Base
  extend(::RuboCop::Cop::AutoCorrector)

  def on_send(node); end
  def render_plain_text?(param0 = T.unsafe(nil)); end

  private

  def compatible_content_type?(node); end
  def find_content_type(node); end
  def replacement(rest_options, option_value); end
end

RuboCop::Cop::Rails::RenderPlainText::MSG = T.let(T.unsafe(nil), String)

RuboCop::Cop::Rails::RenderPlainText::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Rails::RequestReferer < ::RuboCop::Cop::Base
  include(::RuboCop::Cop::ConfigurableEnforcedStyle)
  extend(::RuboCop::Cop::AutoCorrector)

  def on_send(node); end
  def referer?(param0 = T.unsafe(nil)); end

  private

  def message(_range); end
  def wrong_method_name; end
end

RuboCop::Cop::Rails::RequestReferer::MSG = T.let(T.unsafe(nil), String)

RuboCop::Cop::Rails::RequestReferer::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Rails::ReversibleMigration < ::RuboCop::Cop::Base
  def change_table_call(param0 = T.unsafe(nil)); end
  def drop_table_call(param0 = T.unsafe(nil)); end
  def irreversible_schema_statement_call(param0 = T.unsafe(nil)); end
  def on_block(node); end
  def on_send(node); end
  def remove_column_call(param0 = T.unsafe(nil)); end
  def remove_columns_call(param0 = T.unsafe(nil)); end
  def remove_foreign_key_call(param0 = T.unsafe(nil)); end
  def remove_index_call(param0 = T.unsafe(nil)); end

  private

  def all_hash_key?(args, *keys); end
  def check_change_table_node(node, block); end
  def check_change_table_offense(receiver, node); end
  def check_drop_table_node(node); end
  def check_irreversible_schema_statement_node(node); end
  def check_remove_column_node(node); end
  def check_remove_columns_node(node); end
  def check_remove_foreign_key_node(node); end
  def check_remove_index_node(node); end
  def check_reversible_hash_node(node); end
  def reversible_change_table_call?(node); end
  def within_change_method?(node); end
  def within_reversible_or_up_only_block?(node); end
end

RuboCop::Cop::Rails::ReversibleMigration::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Rails::SafeNavigation < ::RuboCop::Cop::Base
  include(::RuboCop::Cop::RangeHelp)
  extend(::RuboCop::Cop::AutoCorrector)

  def on_send(node); end
  def try_call(param0 = T.unsafe(nil)); end

  private

  def autocorrect(corrector, node); end
  def replacement(method, params); end
end

RuboCop::Cop::Rails::SafeNavigation::MSG = T.let(T.unsafe(nil), String)

RuboCop::Cop::Rails::SafeNavigation::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Rails::SafeNavigationWithBlank < ::RuboCop::Cop::Base
  extend(::RuboCop::Cop::AutoCorrector)

  def on_if(node); end
  def safe_navigation_blank_in_conditional?(param0 = T.unsafe(nil)); end
end

RuboCop::Cop::Rails::SafeNavigationWithBlank::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Rails::SaveBang < ::RuboCop::Cop::Base
  include(::RuboCop::Cop::NegativeConditional)
  extend(::RuboCop::Cop::AutoCorrector)

  def after_leaving_scope(scope, _variable_table); end
  def check_assignment(assignment); end
  def on_csend(node); end
  def on_send(node); end

  private

  def allowed_receiver?(node); end
  def argument?(node); end
  def array_parent(node); end
  def assignable_node(node); end
  def call_to_persisted?(node); end
  def check_used_in_condition_or_compound_boolean(node); end
  def checked_immediately?(node); end
  def conditional?(parent); end
  def const_matches?(const, allowed_const); end
  def expected_signature?(node); end
  def explicit_return?(node); end
  def find_method_with_sibling_index(node, sibling_index = T.unsafe(nil)); end
  def hash_parent(node); end
  def implicit_return?(node); end
  def in_condition_or_compound_boolean?(node); end
  def operator_or_single_negative?(node); end
  def persist_method?(node, methods = T.unsafe(nil)); end
  def persisted_referenced?(assignment); end
  def receiver_chain_matches?(node, allowed_receiver); end
  def register_offense(node, msg); end
  def return_value_assigned?(node); end
  def right_assignment_node(assignment); end

  class << self
    def joining_forces; end
  end
end

RuboCop::Cop::Rails::SaveBang::CREATE_CONDITIONAL_MSG = T.let(T.unsafe(nil), String)

RuboCop::Cop::Rails::SaveBang::CREATE_MSG = T.let(T.unsafe(nil), String)

RuboCop::Cop::Rails::SaveBang::CREATE_PERSIST_METHODS = T.let(T.unsafe(nil), Array)

RuboCop::Cop::Rails::SaveBang::MODIFY_PERSIST_METHODS = T.let(T.unsafe(nil), Array)

RuboCop::Cop::Rails::SaveBang::MSG = T.let(T.unsafe(nil), String)

RuboCop::Cop::Rails::SaveBang::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Rails::ScopeArgs < ::RuboCop::Cop::Base
  def on_send(node); end
  def scope?(param0 = T.unsafe(nil)); end
end

RuboCop::Cop::Rails::ScopeArgs::MSG = T.let(T.unsafe(nil), String)

RuboCop::Cop::Rails::ScopeArgs::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Rails::ShortI18n < ::RuboCop::Cop::Base
  include(::RuboCop::Cop::ConfigurableEnforcedStyle)
  extend(::RuboCop::Cop::AutoCorrector)

  def long_i18n?(param0 = T.unsafe(nil)); end
  def on_send(node); end
end

RuboCop::Cop::Rails::ShortI18n::MSG = T.let(T.unsafe(nil), String)

RuboCop::Cop::Rails::ShortI18n::PREFERRED_METHODS = T.let(T.unsafe(nil), Hash)

RuboCop::Cop::Rails::ShortI18n::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Rails::SkipsModelValidations < ::RuboCop::Cop::Base
  def initialize(*_arg0); end

  def good_insert?(param0 = T.unsafe(nil)); end
  def good_touch?(param0 = T.unsafe(nil)); end
  def on_csend(node); end
  def on_send(node); end

  private

  def allowed_method?(node); end
  def allowed_methods; end
  def forbidden_methods; end
  def message(node); end
end

RuboCop::Cop::Rails::SkipsModelValidations::METHODS_WITH_ARGUMENTS = T.let(T.unsafe(nil), Array)

RuboCop::Cop::Rails::SkipsModelValidations::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Rails::SquishedSQLHeredocs < ::RuboCop::Cop::Base
  include(::RuboCop::Cop::Heredoc)
  extend(::RuboCop::Cop::AutoCorrector)

  def on_heredoc(node); end

  private

  def message(node); end
  def offense_detected?(node); end
  def sql_heredoc?(node); end
  def using_squish?(node); end
end

RuboCop::Cop::Rails::SquishedSQLHeredocs::MSG = T.let(T.unsafe(nil), String)

RuboCop::Cop::Rails::SquishedSQLHeredocs::SQL = T.let(T.unsafe(nil), String)

RuboCop::Cop::Rails::SquishedSQLHeredocs::SQUISH = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Rails::TimeZone < ::RuboCop::Cop::Base
  include(::RuboCop::Cop::ConfigurableEnforcedStyle)
  extend(::RuboCop::Cop::AutoCorrector)

  def on_const(node); end

  private

  def acceptable_methods(klass, method_name, node); end
  def autocorrect(corrector, node); end
  def autocorrect_time_new(node, corrector); end
  def build_message(klass, method_name, node); end
  def check_localtime(node); end
  def check_time_node(klass, node); end
  def extract_method_chain(node); end
  def flexible?; end
  def good_methods; end
  def method_from_time_class?(node); end
  def method_send?(node); end
  def need_check_localtime?(chain); end
  def not_danger_chain?(chain); end
  def offset_provided?(node); end
  def remove_redundant_in_time_zone(corrector, node); end
  def safe_method(method_name, node); end
  def strict?; end
end

RuboCop::Cop::Rails::TimeZone::ACCEPTED_METHODS = T.let(T.unsafe(nil), Array)

RuboCop::Cop::Rails::TimeZone::DANGEROUS_METHODS = T.let(T.unsafe(nil), Array)

RuboCop::Cop::Rails::TimeZone::GOOD_METHODS = T.let(T.unsafe(nil), Array)

RuboCop::Cop::Rails::TimeZone::MSG = T.let(T.unsafe(nil), String)

RuboCop::Cop::Rails::TimeZone::MSG_ACCEPTABLE = T.let(T.unsafe(nil), String)

RuboCop::Cop::Rails::TimeZone::MSG_LOCALTIME = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Rails::UniqBeforePluck < ::RuboCop::Cop::Base
  include(::RuboCop::Cop::ConfigurableEnforcedStyle)
  include(::RuboCop::Cop::RangeHelp)
  extend(::RuboCop::Cop::AutoCorrector)

  def aggressive_node_match(param0 = T.unsafe(nil)); end
  def conservative_node_match(param0 = T.unsafe(nil)); end
  def on_send(node); end

  private

  def dot_method_begin_pos(method, node); end
  def dot_method_with_whitespace(method, node); end
  def style_parameter_name; end
end

RuboCop::Cop::Rails::UniqBeforePluck::MSG = T.let(T.unsafe(nil), String)

RuboCop::Cop::Rails::UniqBeforePluck::NEWLINE = T.let(T.unsafe(nil), String)

RuboCop::Cop::Rails::UniqBeforePluck::PATTERN = T.let(T.unsafe(nil), String)

RuboCop::Cop::Rails::UniqBeforePluck::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Rails::UniqueValidationWithoutIndex < ::RuboCop::Cop::Base
  include(::RuboCop::Cop::ActiveRecordHelper)

  def on_send(node); end

  private

  def array_node_to_array(node); end
  def class_node(node); end
  def column_names(node); end
  def column_names_from_scope(node); end
  def condition_part?(node); end
  def find_schema_information(node); end
  def find_scope(pairs); end
  def include_column_names_in_expression_index?(index, column_names); end
  def unfreeze_scope(scope); end
  def uniqueness_part(node); end
  def with_index?(klass, table, names); end
end

RuboCop::Cop::Rails::UniqueValidationWithoutIndex::MSG = T.let(T.unsafe(nil), String)

RuboCop::Cop::Rails::UniqueValidationWithoutIndex::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Rails::UnknownEnv < ::RuboCop::Cop::Base
  def on_send(node); end
  def rails_env?(param0 = T.unsafe(nil)); end
  def unknown_environment_equal?(param0 = T.unsafe(nil)); end
  def unknown_environment_predicate?(param0 = T.unsafe(nil)); end

  private

  def collect_variable_like_names(_scope); end
  def environments; end
  def message(name); end
  def unknown_env_name?(name); end
  def unknown_env_predicate?(name); end
end

RuboCop::Cop::Rails::UnknownEnv::MSG = T.let(T.unsafe(nil), String)

RuboCop::Cop::Rails::UnknownEnv::MSG_SIMILAR = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Rails::Validation < ::RuboCop::Cop::Base
  extend(::RuboCop::Cop::AutoCorrector)

  def on_send(node); end

  private

  def braced_options(options); end
  def correct_validate_type(corrector, node); end
  def correct_validate_type_for_array(corrector, node, arguments, loc); end
  def correct_validate_type_for_hash(corrector, node, arguments); end
  def frozen_array_argument?(argument); end
  def message(node); end
  def preferred_method(method); end
  def validate_type(node); end
end

RuboCop::Cop::Rails::Validation::ALLOWLIST = T.let(T.unsafe(nil), Array)

RuboCop::Cop::Rails::Validation::MSG = T.let(T.unsafe(nil), String)

RuboCop::Cop::Rails::Validation::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

RuboCop::Cop::Rails::Validation::TYPES = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Rails::WhereEquals < ::RuboCop::Cop::Base
  include(::RuboCop::Cop::RangeHelp)
  extend(::RuboCop::Cop::AutoCorrector)

  def on_send(node); end
  def where_method_call?(param0 = T.unsafe(nil)); end

  private

  def build_good_method(column, value); end
  def extract_column_and_value(template_node, value_node); end
  def offense_range(node); end
end

RuboCop::Cop::Rails::WhereEquals::EQ_ANONYMOUS_RE = T.let(T.unsafe(nil), Regexp)

RuboCop::Cop::Rails::WhereEquals::EQ_NAMED_RE = T.let(T.unsafe(nil), Regexp)

RuboCop::Cop::Rails::WhereEquals::IN_ANONYMOUS_RE = T.let(T.unsafe(nil), Regexp)

RuboCop::Cop::Rails::WhereEquals::IN_NAMED_RE = T.let(T.unsafe(nil), Regexp)

RuboCop::Cop::Rails::WhereEquals::IS_NULL_RE = T.let(T.unsafe(nil), Regexp)

RuboCop::Cop::Rails::WhereEquals::MSG = T.let(T.unsafe(nil), String)

RuboCop::Cop::Rails::WhereEquals::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Rails::WhereExists < ::RuboCop::Cop::Base
  include(::RuboCop::Cop::ConfigurableEnforcedStyle)
  extend(::RuboCop::Cop::AutoCorrector)

  def exists_with_args?(param0 = T.unsafe(nil)); end
  def on_send(node); end
  def where_exists_call?(param0 = T.unsafe(nil)); end

  private

  def build_good_method(args); end
  def build_good_method_exists(args); end
  def build_good_method_where(args); end
  def convertable_args?(args); end
  def correction_range(node); end
  def exists_style?; end
  def find_offenses(node, &block); end
  def where_style?; end
end

RuboCop::Cop::Rails::WhereExists::MSG = T.let(T.unsafe(nil), String)

RuboCop::Cop::Rails::WhereExists::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Rails::WhereNot < ::RuboCop::Cop::Base
  include(::RuboCop::Cop::RangeHelp)
  extend(::RuboCop::Cop::AutoCorrector)

  def on_send(node); end
  def where_method_call?(param0 = T.unsafe(nil)); end

  private

  def build_good_method(column, value); end
  def extract_column_and_value(template_node, value_node); end
  def offense_range(node); end
end

RuboCop::Cop::Rails::WhereNot::IS_NOT_NULL_RE = T.let(T.unsafe(nil), Regexp)

RuboCop::Cop::Rails::WhereNot::MSG = T.let(T.unsafe(nil), String)

RuboCop::Cop::Rails::WhereNot::NOT_EQ_ANONYMOUS_RE = T.let(T.unsafe(nil), Regexp)

RuboCop::Cop::Rails::WhereNot::NOT_EQ_NAMED_RE = T.let(T.unsafe(nil), Regexp)

RuboCop::Cop::Rails::WhereNot::NOT_IN_ANONYMOUS_RE = T.let(T.unsafe(nil), Regexp)

RuboCop::Cop::Rails::WhereNot::NOT_IN_NAMED_RE = T.let(T.unsafe(nil), Regexp)

RuboCop::Cop::Rails::WhereNot::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

module RuboCop::Cop::TargetRailsVersion
  def minimum_target_rails_version(version); end
  def support_target_rails_version?(version); end
end

RuboCop::NodePattern = RuboCop::AST::NodePattern

RuboCop::ProcessedSource = RuboCop::AST::ProcessedSource

module RuboCop::Rails
end

RuboCop::Rails::CONFIG = T.let(T.unsafe(nil), Hash)

module RuboCop::Rails::Inject
  class << self
    def defaults!; end
  end
end

module RuboCop::Rails::SchemaLoader
  extend(::RuboCop::Rails::SchemaLoader)

  def db_schema_path; end
  def load(target_ruby_version); end
  def reset!; end

  private

  def load!(target_ruby_version); end
  def parse(path, target_ruby_version); end
end

class RuboCop::Rails::SchemaLoader::AddIndex < ::RuboCop::Rails::SchemaLoader::Index
  def initialize(node); end

  def table_name; end
end

class RuboCop::Rails::SchemaLoader::Column
  def initialize(node); end

  def name; end
  def not_null; end
  def type; end

  private

  def analyze_keywords!(node); end
end

class RuboCop::Rails::SchemaLoader::Index
  def initialize(node); end

  def columns; end
  def expression; end
  def name; end
  def unique; end

  private

  def analyze_keywords!(node); end
  def build_columns_or_expr(columns); end
end

class RuboCop::Rails::SchemaLoader::Schema
  def initialize(ast); end

  def add_indicies; end
  def add_indicies_by(table_name:); end
  def table_by(name:); end
  def tables; end

  private

  def build!(ast); end
  def each_add_index(ast); end
  def each_table(ast); end
end

class RuboCop::Rails::SchemaLoader::Table
  def initialize(node); end

  def columns; end
  def indices; end
  def name; end
  def with_column?(name:); end

  private

  def build_columns(node); end
  def build_indices(node); end
  def each_content(node, &block); end
end

module RuboCop::Rails::Version
  class << self
    def document_version; end
  end
end

RuboCop::Rails::Version::STRING = T.let(T.unsafe(nil), String)

RuboCop::Token = RuboCop::AST::Token
