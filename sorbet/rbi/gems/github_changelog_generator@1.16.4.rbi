# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `github_changelog_generator` gem.
# Please instead update this file by running `bin/tapioca gem github_changelog_generator`.

# The main module, where placed all classes (now, at least)
module GitHubChangelogGenerator; end

class GitHubChangelogGenerator::ArgvParser
  # @return [ArgvParser] a new instance of ArgvParser
  def initialize(options = T.unsafe(nil)); end

  # Returns the value of attribute options.
  def options; end

  def parse!(argv); end
  def parser; end

  class << self
    def banner; end
  end
end

# Main class and entry point for this script.
class GitHubChangelogGenerator::ChangelogGenerator
  # Class, responsible for whole changelog generation cycle
  #
  # @return initialised instance of ChangelogGenerator
  def initialize; end

  # The entry point of this script to generate changelog
  #
  # @raise [ChangelogGeneratorError] Is thrown when one of specified tags was not found in list of tags.
  def run; end
end

# Default error for ChangelogGenerator
class GitHubChangelogGenerator::ChangelogGeneratorError < ::StandardError; end

# This class generates the content for a single changelog entry. An entry is
# generally either for a specific tagged release or the collection of
# unreleased changes.
#
# An entry is comprised of header text followed by a series of sections
# relating to the entry.
#
# @see GitHubChangelogGenerator::Generator
# @see GitHubChangelogGenerator::Section
class GitHubChangelogGenerator::Entry
  # @return [Entry] a new instance of Entry
  def initialize(options = T.unsafe(nil)); end

  # Returns the value of attribute content.
  def content; end

  # Generates log entry with header and body
  #
  # @param pull_requests [Array] List or PR's in new section
  # @param issues [Array] List of issues in new section
  # @param newer_tag_name [String] Name of the newer tag. Could be nil for `Unreleased` section.
  # @param newer_tag_link [String] Name of the newer tag. Could be "HEAD" for `Unreleased` section.
  # @param newer_tag_time [Time] Time of the newer tag
  # @param older_tag_name [Hash, nil] Older tag, used for the links. Could be nil for last tag.
  # @return [String] Ready and parsed section content.
  def generate_entry_for_tag(pull_requests, issues, newer_tag_name, newer_tag_link, newer_tag_time, older_tag_name); end

  def line_labels_for(issue); end

  private

  # Creates a section for issues/PRs with no labels or no mapped labels.
  #
  # @param issues [Array]
  # @return [Nil]
  def add_unmapped_section(issues); end

  # Creates section objects for this entry.
  #
  # @return [Nil]
  def create_sections; end

  # Default sections to used when --configure-sections is not set.
  #
  # @return [Array] Section objects.
  def default_sections; end

  # Generates complete body text for a tag (without a header)
  #
  # @param pull_requests [Array]
  # @param issues [Array]
  # @return [String] Content generated from sections of sorted issues & PRs.
  def generate_body(pull_requests, issues); end

  # Generates header text for an entry.
  #
  # @param newer_tag_name [String] The name of a newer tag
  # @param newer_tag_link [String] Used for URL generation. Could be same as #newer_tag_name or some specific value, like HEAD
  # @param newer_tag_time [Time] Time when the newer tag was created
  # @param older_tag_name [String] The name of an older tag; used for URLs.
  # @param project_url [String] URL for the current project.
  # @return [String] Header text content.
  def generate_header(newer_tag_name, newer_tag_link, newer_tag_time, older_tag_name, project_url); end

  # Turns the argument from the commandline of --configure-sections or
  # --add-sections into an array of Section objects.
  #
  # @param sections_desc [String, Hash] Either string or hash describing sections
  # @return [Array] Parsed section objects.
  def parse_sections(sections_desc); end

  # Sorts issues and PRs into entry sections by labels and lack of labels.
  #
  # @param pull_requests [Array]
  # @param issues [Array]
  # @return [Nil]
  def sort_into_sections(pull_requests, issues); end

  # Iterates through sections and sorts labeled issues into them based on
  # the label mapping. Returns any unmapped or unlabeled issues.
  #
  # @param issues [Array] Issues or pull requests.
  # @return [Array] Issues that were not mapped into any sections.
  def sort_labeled_issues(issues); end
end

class GitHubChangelogGenerator::FileParserChooser
  # @return [FileParserChooser] a new instance of FileParserChooser
  def initialize(options); end

  def parse!(_argv); end
  def resolve_path; end
end

# This class is the high-level code for gathering issues and PRs for a github
# repository and generating a CHANGELOG.md file. A changelog is made up of a
# series of "entries" of all tagged releases, plus an extra entry for the
# unreleased changes. Entries are made up of various organizational
# "sections," and sections contain the github issues and PRs.
#
# So the changelog contains entries, entries contain sections, and sections
# contain issues and PRs.
#
# @see GitHubChangelogGenerator::Entry
# @see GitHubChangelogGenerator::Section
class GitHubChangelogGenerator::Generator
  # A Generator responsible for all logic, related with changelog generation from ready-to-parse issues
  #
  # Example:
  #   generator = GitHubChangelogGenerator::Generator.new
  #   content = generator.compound_changelog
  #
  # @return [Generator] a new instance of Generator
  def initialize(options = T.unsafe(nil)); end

  # Adds a key "first_occurring_tag" to each PR with a value of the oldest
  # tag that a PR's merge commit occurs in in the git history. This should
  # indicate the release of each PR by git's history regardless of dates and
  # divergent branches.
  #
  # @param tags [Array] The tags sorted by time, newest to oldest.
  # @param prs [Array] The PRs to discover the tags of.
  # @return [Nil] No return; PRs are updated in-place.
  def add_first_occurring_tag_to_prs(tags, prs); end

  # Associate merged PRs by the SHA detected in github comments of the form
  # "rebased commit: <sha>". For use when the merge_commit_sha is not in the
  # actual git history due to rebase.
  #
  # @param tags [Array] The tags sorted by time, newest to oldest.
  # @param prs_left [Array] The PRs not yet associated with any tag or branch.
  # @return [Array] PRs without rebase comments.
  def associate_rebase_comment_prs(tags, prs_left, total); end

  # Associate merged PRs by the HEAD of the release branch. If no
  # --release-branch was specified, then the github default branch is used.
  #
  # @param prs_left [Array] PRs not associated with any tag.
  # @param total [Integer] The total number of PRs to associate; used for verbose printing.
  # @return [Array] PRs without their merge_commit_sha in the branch.
  def associate_release_branch_prs(prs_left, total); end

  # Associate merged PRs by the merge SHA contained in each tag. If the
  # merge_commit_sha is not found in any tag's history, skip association.
  #
  # @param tags [Array] The tags sorted by time, newest to oldest.
  # @param prs [Array] The PRs to associate.
  # @return [Array] PRs without their merge_commit_sha in a tag.
  def associate_tagged_prs(tags, prs, total); end

  # PRs to include in this section will be >= [Left Tag Date] and <= [Right Tag Date]
  #
  # @param section_tags [Array] are the tags that need a subsection output
  # @param filtered_tags [Array] is the list of filtered tags ordered from newest -> oldest
  # @return [Hash] key is the tag to output, value is an array of [Left Tag, Right Tag]
  def build_tag_section_mapping(section_tags, filtered_tags); end

  # Main function to start changelog generation
  #
  # @return [String] Generated changelog file
  def compound_changelog; end

  # Method filter issues, that belong only specified tag range
  #
  # @param issues [Array] issues to filter
  # @param hash_key [Symbol] key of date value default is :actual_date
  # @param older_tag [Hash, Nil] all issues before this tag date will be excluded. May be nil, if it's first tag
  # @param newer_tag [Hash, Nil] all issue after this tag will be excluded. May be nil for unreleased section
  # @return [Array] filtered issues
  def delete_by_time(issues, hash_key = T.unsafe(nil), older_tag = T.unsafe(nil), newer_tag = T.unsafe(nil)); end

  # Find correct closed dates, if issues was closed by commits
  def detect_actual_closed_dates(issues); end

  # Detect link, name and time for specified tag.
  #
  # @param newer_tag [Hash] newer tag. Can be nil, if it's Unreleased section.
  # @return [Array] link, name and time of the tag
  def detect_link_tag_time(newer_tag); end

  def due_tag; end
  def ensure_older_tag(older_tag, newer_tag); end

  # delete all issues with labels from options[:exclude_labels] array
  #
  # @param issues [Array]
  # @return [Array] filtered array
  def exclude_issues_by_labels(issues); end

  # Only include issues without labels if options[:add_issues_wo_labels]
  #
  # @param issues [Array]
  # @return [Array] filtered array
  def exclude_issues_without_labels(issues); end

  # fetch, filter tags, fetch dates and sort them in time order
  def fetch_and_filter_tags; end

  # Fetch event for issues and pull requests
  #
  # @return [Array] array of fetched issues
  def fetch_events_for_issues_and_pr; end

  # Async fetching of all tags dates
  def fetch_tags_dates(tags); end

  # General filtered function
  #
  # @param all_issues [Array] PRs or issues
  # @return [Array] filtered issues
  def filter_array_by_labels(all_issues); end

  # @param issues [Object]
  # @todo Document this
  def filter_by_include_labels(issues); end

  # @return [Array] filtered issues accourding milestone
  def filter_by_milestone(filtered_issues, tag_name, all_issues); end

  # Method filter issues, that belong only specified tag range
  #
  # @param issues [Array] issues to filter
  # @param newer_tag [Hash, Nil] Tag to find PRs of. May be nil for unreleased section
  # @return [Array] filtered issues
  def filter_by_tag(issues, newer_tag = T.unsafe(nil)); end

  # @param all_tags [Array] all tags
  # @return [Array] filtered tags according :due_tag option
  def filter_due_tag(all_tags); end

  # @param all_tags [Array] all tags
  # @return [Array] filtered tags according :exclude_tags or :exclude_tags_regex option
  def filter_excluded_tags(all_tags); end

  # @param all_tags [Array] all tags
  # @return [Array] filtered tags according to :include_tags_regex option
  def filter_included_tags(all_tags); end

  # This method filter only merged PR and
  # fetch missing required attributes for pull requests
  # :merged_at - is a date, when issue PR was merged.
  # More correct to use merged date, rather than closed date.
  def filter_merged_pull_requests(pull_requests); end

  # @param all_tags [Array] all tags
  # @return [Array] filtered tags according :since_tag option
  def filter_since_tag(all_tags); end

  # @param items [Array] Issues & PRs to filter when without labels
  # @return [Array] Issues & PRs without labels or empty array if
  #   add_issues_wo_labels or add_pr_wo_labels are false
  def filter_wo_labels(items); end

  # Returns the value of attribute filtered_tags.
  def filtered_tags; end

  # Sets the attribute filtered_tags
  #
  # @param value the value to set the attribute filtered_tags to.
  def filtered_tags=(_arg0); end

  # Fill :actual_date parameter of specified issue by closed date of the commit, if it was closed by commit.
  #
  # @param issue [Hash]
  def find_closed_date_by_commit(issue); end

  # Add all issues, that should be in that tag, according milestone
  #
  # @param all_issues [Array]
  # @param tag_name [String]
  # @return [Array] issues with milestone #tag_name
  def find_issues_to_add(all_issues, tag_name); end

  # Filter issues according labels
  #
  # @return [Array] Filtered issues
  def get_filtered_issues(issues); end

  # This method fetches missing params for PR and filter them by specified options
  # It include add all PR's with labels from options[:include_labels] array
  # And exclude all from :exclude_labels array.
  #
  # @return [Array] filtered PR's
  def get_filtered_pull_requests(pull_requests); end

  # Return tags after filtering tags in lists provided by option: --exclude-tags
  #
  # @return [Array]
  def get_filtered_tags(all_tags); end

  # Returns date for given GitHub Tag hash
  #
  # Memoize the date by tag name.
  #
  # @param tag_name [Hash]
  # @raise [ChangelogGeneratorError]
  # @return [Time] time of specified tag
  def get_time_of_tag(tag_name); end

  # Include issues with labels, specified in :include_labels
  #
  # @param issues [Array] to filter
  # @return [Array] filtered array of issues
  def include_issues_by_labels(issues); end

  # Returns the value of attribute options.
  def options; end

  # Sets the attribute options
  #
  # @param value the value to set the attribute options to.
  def options=(_arg0); end

  # @return [Array] array with removed issues, that contain milestones with same name as a tag
  def remove_issues_in_milestones(filtered_issues); end

  # Set closed date from this issue
  #
  # @param event [Hash]
  # @param issue [Hash]
  def set_date_from_event(event, issue); end

  # @return [Object] try to find newest tag using #Reader and :base option if specified otherwise returns nil
  def since_tag; end

  # Sort all tags by date, newest to oldest
  def sort_tags_by_date(tags); end

  # Returns the value of attribute sorted_tags.
  def sorted_tags; end

  # Sets the attribute sorted_tags
  #
  # @param value the value to set the attribute sorted_tags to.
  def sorted_tags=(_arg0); end

  # @return [Boolean]
  def tag_newer_old_tag?(older_tag_time, time); end

  # @return [Boolean]
  def tag_older_new_tag?(newer_tag_time, time); end

  # Returns the value of attribute tag_section_mapping.
  def tag_section_mapping; end

  # Sets the attribute tag_section_mapping
  #
  # @param value the value to set the attribute tag_section_mapping to.
  def tag_section_mapping=(_arg0); end

  def version_of_first_item; end

  private

  def apply_exclude_tags(all_tags); end
  def apply_exclude_tags_regex(all_tags); end

  # Fetches @pull_requests and @issues and filters them based on options.
  #
  # @return [Nil] No return.
  def fetch_issues_and_pr; end

  def filter_exact_tags(all_tags); end

  # Filters issues and pull requests based on, respectively, `actual_date`
  # and `merged_at` timestamp fields. `actual_date` is the detected form of
  # `closed_at` based on merge event SHA commit times.
  #
  # @return [Array] filtered issues and pull requests
  def filter_issues_for_tags(newer_tag, older_tag); end

  def filter_tags_with_regex(all_tags, regex, regex_option_name); end

  # The full cycle of generation for whole project
  #
  # @return [String] All entries in the changelog
  def generate_entries_for_all_tags; end

  # Generate log only between 2 specified tags
  #
  # @param older_tag [String] all issues before this tag date will be excluded. May be nil, if it's first tag
  # @param newer_tag [String] all issue after this tag will be excluded. May be nil for unreleased section
  def generate_entry_between_tags(older_tag, newer_tag); end

  def generate_unreleased_entry; end

  # Add template messages to given string. Previously added
  # messages of the same wording are removed.
  #
  # @param log [String]
  def insert_fixed_string(log); end

  # Remove the previously assigned fixed message.
  #
  # @param log [String] Old lines are fixed
  def remove_old_fixed_string(log); end

  # Detect if a sha occurs in the --release-branch. Uses the github repo
  # default branch if not specified.
  #
  # @param sha [String] SHA to check.
  # @return [Boolean] True if SHA is in the branch git history.
  def sha_in_release_branch?(sha); end

  def warn_if_nonmatching_regex(all_tags, regex, regex_option_name); end
  def warn_if_tag_not_found(all_tags, tag); end
end

GitHubChangelogGenerator::Generator::CREDIT_LINE = T.let(T.unsafe(nil), String)

module GitHubChangelogGenerator::Helper
  class << self
    # Returns the value of attribute log.
    def log; end

    # @return [Boolean] true if the currently running program is a unit test
    def test?; end
  end
end

# A Fetcher responsible for all requests to GitHub and all basic manipulation with related data
# (such as filtering, validating, e.t.c)
#
# Example:
# fetcher = GitHubChangelogGenerator::OctoFetcher.new(options)
class GitHubChangelogGenerator::OctoFetcher
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @param options [Hash] Options passed in
  # @return [OctoFetcher] a new instance of OctoFetcher
  def initialize(options = T.unsafe(nil)); end

  # Returns the number of pages for a API call
  #
  # @param request_options [Object]
  # @param method [Object]
  # @param client [Object]
  # @return [Integer] number of pages for this API call in total
  def calculate_pages(client, method, request_options); end

  def client; end
  def client_options; end
  def closed_pr_options; end

  # Fetch all commits
  #
  # @return [Array] Commits in a repo.
  def commits; end

  # @param name [String]
  # @return [Array<String>]
  def commits_in_branch(name); end

  def connection_options; end

  # @return [String] Default branch of the repo
  def default_branch; end

  # This method fetch all closed issues and separate them to pull requests and pure issues
  # (pull request is kind of issue in term of GitHub)
  #
  # @return [Tuple] with (issues [Array <Hash>], pull-requests [Array <Hash>])
  def fetch_closed_issues_and_pr; end

  # Fetch all pull requests. We need them to detect :merged_at parameter
  #
  # @return [Array <Hash>] all pull requests
  def fetch_closed_pull_requests; end

  # Fetch comments for PRs and add them to "comments"
  #
  # @param prs [Array] The array of PRs.
  # @return [Void] No return; PRs are updated in-place.
  def fetch_comments_async(prs); end

  # Fetch commit for specified event
  #
  # @param commit_id [String] the SHA of a commit to fetch
  # @return [Hash]
  def fetch_commit(commit_id); end

  # Fetch tag time from repo
  #
  # @param tag [Hash] GitHub data item about a Tag
  # @return [Time] time of specified tag
  def fetch_date_of_tag(tag); end

  # Fetch event for all issues and add them to 'events'
  #
  # @param issues [Array]
  # @return [Void]
  def fetch_events_async(issues); end

  # Fetch all SHAs occurring in or before a given tag and add them to
  # "shas_in_tag"
  #
  # @param tags [Array] The array of tags.
  # @return void
  def fetch_tag_shas(tags); end

  # Fetch all tags from repo
  #
  # @return [Array <Hash>] array of tags
  def get_all_tags; end

  # Fill input array with tags
  #
  # @return [Array <Hash>] array of tags in repo
  def github_fetch_tags; end

  def middleware; end

  # Return the oldest commit in a repo
  #
  # @return [Hash] Oldest commit in the github git history.
  def oldest_commit; end

  private

  # This is wrapper with rescue block
  #
  # @param block [Proc]
  # @return [Object] returns exactly the same, what you put in the block, but wrap it with begin-rescue block
  def check_github_response; end

  # @param shas [Set]
  # @param sha [Object]
  def commits_in_tag(sha, shas = T.unsafe(nil)); end

  # Presents the exception, and the aborts with the message.
  #
  # @param message [Object]
  # @param error [Object]
  def fail_with_message(error, message); end

  # Returns GitHub token. First try to use variable, provided by --token option,
  # otherwise try to fetch it from CHANGELOG_GITHUB_TOKEN env variable.
  #
  # @return [String]
  def fetch_github_token; end

  # Iterates through all pages until there are no more :next pages to follow
  # yields the result per page
  #
  # @param client [Octokit::Client]
  # @param method [String] (eg. 'tags')
  # @param arguments [Array]
  # @param parent [Async::Semaphore]
  # @param options [Hash]
  # @return [void]
  # @yield [Sawyer::Resource] An OctoKit-provided response (which can be empty)
  def iterate_pages(client, method, *arguments, parent: T.unsafe(nil), **options); end

  # Print long line with spaces on same line to clear prev message
  def print_empty_line; end

  # Print specified line on the same string
  #
  # @param log_string [String]
  def print_in_same_line(log_string); end

  # Returns Hash of all querystring variables in given URI.
  #
  # @param uri [String] eg. https://api.github.com/repositories/43914960/tags?page=37&foo=1
  # @return [Hash] of all GET variables. eg. { 'page' => 37, 'foo' => 1 }
  def querystring_as_hash(uri); end

  # @param indata [Object]
  def stringify_keys_deep(indata); end

  # @param msg [Object]
  def sys_abort(msg); end

  # @return [String] helper to return Github "user/project"
  def user_project; end
end

GitHubChangelogGenerator::OctoFetcher::CHANGELOG_GITHUB_TOKEN = T.let(T.unsafe(nil), String)
GitHubChangelogGenerator::OctoFetcher::DEFAULT_REQUEST_OPTIONS = T.let(T.unsafe(nil), Hash)
GitHubChangelogGenerator::OctoFetcher::GH_RATE_LIMIT_EXCEEDED_MSG = T.let(T.unsafe(nil), String)
GitHubChangelogGenerator::OctoFetcher::MAXIMUM_CONNECTIONS = T.let(T.unsafe(nil), Integer)
GitHubChangelogGenerator::OctoFetcher::MAX_FORBIDDEN_RETRIES = T.let(T.unsafe(nil), Integer)

# Exception raised to warn about moved repositories.
class GitHubChangelogGenerator::OctoFetcher::MovedPermanentlyError < ::RuntimeError; end

GitHubChangelogGenerator::OctoFetcher::NO_TOKEN_PROVIDED = T.let(T.unsafe(nil), String)
GitHubChangelogGenerator::OctoFetcher::PER_PAGE_NUMBER = T.let(T.unsafe(nil), Integer)

# This class wraps Options, and knows a list of known options. Others options
# will raise exceptions.
class GitHubChangelogGenerator::Options < ::SimpleDelegator
  # @param values [Hash]
  # @raise [UnsupportedOptionError] if given values contain unknown options
  # @return [Options] a new instance of Options
  def initialize(values); end

  # Set option key to val.
  #
  # @param key [Symbol]
  # @param val [Object]
  # @raise [UnsupportedOptionError] when trying to set an unknown option
  def []=(key, val); end

  # Boolean method for whether the user is using add_sections
  #
  # @return [Boolean]
  def add_sections?; end

  # Boolean method for whether the user is using configure_sections
  #
  # @return [Boolean]
  def configure_sections?; end

  # Loads the configured Ruby files from the --require option.
  def load_custom_ruby_files; end

  # Pretty-prints a censored options hash, if :verbose.
  def print_options; end

  # @return [Hash]
  def to_hash; end

  # @return [Boolean] whether write to `:output`
  def write_to_file?; end

  private

  # Returns a censored options hash.
  #
  # @return [Hash] The GitHub `:token` key is censored in the output.
  def censored_values; end

  # @return [Boolean]
  def supported_option?(key); end

  def unsupported_options; end
  def values; end
end

# List of valid option names
GitHubChangelogGenerator::Options::KNOWN_OPTIONS = T.let(T.unsafe(nil), Array)

# Raised on initializing with unknown keys in the values hash,
# and when trying to store a value on an unknown key.
class GitHubChangelogGenerator::Options::UnsupportedOptionError < ::ArgumentError; end

class GitHubChangelogGenerator::Parser
  class << self
    def abort_if_user_and_project_not_given!(options); end

    # @return [Options] Default options
    def default_options; end

    def parse_options(argv = T.unsafe(nil)); end
  end
end

class GitHubChangelogGenerator::ParserError < ::StandardError; end

# ParserFile is a configuration file reader which sets options in the
# given Hash.
#
# In your project's root, you can put a file named
# <tt>.github_changelog_generator</tt> to override defaults.
#
# Example:
#   header_label=# My Super Changelog
#   ; Comments are allowed
#   future-release=5.0.0
#   # Ruby-style comments, too
#   since-tag=1.0.0
#
# The configuration format is <tt>some-key=value</tt> or <tt>some_key=value</tt>.
class GitHubChangelogGenerator::ParserFile
  # @param options [Hash] options to be configured from file contents
  # @param io [nil, IO] configuration file handle
  # @return [ParserFile] a new instance of ParserFile
  def initialize(options, io = T.unsafe(nil)); end

  # Sets options using configuration file content
  def parse!; end

  private

  def convert_value(value, option_name); end

  # Returns a the option name as a symbol and its string value sans newlines.
  #
  # @param line [String] unparsed line from config file
  # @return [Array<Symbol, String>]
  def extract_pair(line); end

  # Returns true if the line starts with a pound sign or a semi-colon.
  #
  # @return [Boolean]
  def non_configuration_line?(line); end

  def option_key_for(option_name); end
  def parse_line!(line, line_number); end
end

GitHubChangelogGenerator::ParserFile::IRREGULAR_OPTIONS = T.let(T.unsafe(nil), Hash)
GitHubChangelogGenerator::ParserFile::KNOWN_ARRAY_KEYS = T.let(T.unsafe(nil), Array)
GitHubChangelogGenerator::ParserFile::KNOWN_INTEGER_KEYS = T.let(T.unsafe(nil), Array)

# A Reader to read an existing ChangeLog file and return a structured object
#
# Example:
#   reader = GitHubChangelogGenerator::Reader.new
#   content = reader.read('./CHANGELOG.md')
class GitHubChangelogGenerator::Reader
  # @return [Reader] a new instance of Reader
  def initialize(options = T.unsafe(nil)); end

  # Parse the given ChangeLog data into a list of Hashes
  #
  # @param data [String] File data from the ChangeLog.md
  # @return [Array<Hash>] Parsed data, e.g. [{ 'version' => ..., 'url' => ..., 'date' => ..., 'content' => ...}, ...]
  def parse(data); end

  # Parse a single heading and return a Hash
  #
  # The following heading structures are currently valid:
  # - ## [v1.0.2](https://github.com/zanui/chef-thumbor/tree/v1.0.1) (2015-03-24)
  # - ## [v1.0.2](https://github.com/zanui/chef-thumbor/tree/v1.0.1)
  # - ## [v1.0.2] (2015-03-24)
  # - ## [v1.0.2]
  # - ## v1.0.2 (2015-03-24)
  # - ## v1.0.2
  #
  # @param heading [String] Heading from the ChangeLog File
  # @return [Hash] Returns a structured Hash with version, url and date
  def parse_heading(heading); end

  def read(file_path); end
end

# This class generates the content for a single section of a changelog entry.
# It turns the tagged issues and PRs into a well-formatted list of changes to
# be later incorporated into a changelog entry.
#
# @see GitHubChangelogGenerator::Entry
class GitHubChangelogGenerator::Section
  # @return [Section] a new instance of Section
  def initialize(opts = T.unsafe(nil)); end

  # @return [Boolean]
  def body_only; end

  # Returns the content of a section.
  #
  # @return [String] Generated section content
  def generate_content; end

  # @return [Array<Hash>]
  def issues; end

  # @return [Array<String>]
  def labels; end

  # @return [String]
  def name; end

  # @return [String]
  def name=(_arg0); end

  # @return [Options]
  def options; end

  # @return [String] a merge prefix, or an issue prefix
  def prefix; end

  private

  def body_till_first_break(body); end

  # Encapsulate characters to make Markdown look as expected.
  #
  # @param string [String]
  # @return [String] encapsulated input string
  def encapsulate_string(string); end

  # Parse issue and generate single line formatted issue line.
  #
  # Example output:
  # - Add coveralls integration [\#223](https://github.com/github-changelog-generator/github-changelog-generator/pull/223) (@github-changelog-generator)
  #
  # @param issue [Hash] Fetched issue from GitHub
  # @return [String] Markdown-formatted single issue
  def get_string_for_issue(issue); end

  def issue_line_with_body(line, issue); end
  def issue_line_with_user(line, issue); end
end

GitHubChangelogGenerator::Section::ENCAPSULATED_CHARACTERS = T.let(T.unsafe(nil), Array)
GitHubChangelogGenerator::VERSION = T.let(T.unsafe(nil), String)
