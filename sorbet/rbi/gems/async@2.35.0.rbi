# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `async` gem.
# Please instead update this file by running `bin/tapioca gem async`.


# Asynchronous programming framework.
#
# source://async//lib/async/version.rb#6
module Async; end

# A general purpose synchronisation primitive, which allows one task to wait for a number of other tasks to complete. It can be used in conjunction with {Semaphore}.
#
# source://async//lib/async/barrier.rb#14
class Async::Barrier
  # Initialize the barrier.
  #
  # @return [Barrier] a new instance of Barrier
  #
  # source://async//lib/async/barrier.rb#18
  def initialize(parent: T.unsafe(nil)); end

  # Execute a child task and add it to the barrier.
  #
  # source://async//lib/async/barrier.rb#45
  def async(*arguments, parent: T.unsafe(nil), **options, &block); end

  # Whether there are any tasks being held by the barrier.
  #
  # @return [Boolean]
  #
  # source://async//lib/async/barrier.rb#61
  def empty?; end

  # Number of tasks being held by the barrier.
  #
  # source://async//lib/async/barrier.rb#36
  def size; end

  # Stop all tasks held by the barrier.
  #
  # source://async//lib/async/barrier.rb#93
  def stop; end

  # All tasks which have been invoked into the barrier.
  #
  # source://async//lib/async/barrier.rb#41
  def tasks; end

  # Wait for all tasks to complete by invoking {Task#wait} on each waiting task, which may raise an error. As long as the task has completed, it will be removed from the barrier.
  #
  # source://async//lib/async/barrier.rb#70
  def wait; end
end

# source://async//lib/async/barrier.rb#25
class Async::Barrier::TaskNode < ::Async::List::Node
  # @return [TaskNode] a new instance of TaskNode
  #
  # source://async//lib/async/barrier.rb#26
  def initialize(task); end

  # Returns the value of attribute task.
  #
  # source://async//lib/async/barrier.rb#30
  def task; end
end

# A list of children tasks.
#
# source://async//lib/async/node.rb#15
class Async::Children < ::Async::List
  # Create an empty list of children tasks.
  #
  # @return [Children] a new instance of Children
  #
  # source://async//lib/async/node.rb#17
  def initialize; end

  # Adjust the number of transient children, assuming it has changed.
  #
  # Despite being public, this is not intended to be called directly. It is used internally by {Node#transient=}.
  #
  # source://async//lib/async/node.rb#43
  def adjust_transient_count(transient); end

  # Whether all children are considered finished. Ignores transient children.
  #
  # @return [Boolean]
  #
  # source://async//lib/async/node.rb#29
  def finished?; end

  # Whether the children is empty, preserved for compatibility.
  #
  # @return [Boolean]
  #
  # source://async//lib/async/node.rb#34
  def nil?; end

  # Some children may be marked as transient. Transient children do not prevent the parent from finishing.
  #
  # @return [Boolean]
  #
  # source://async//lib/async/node.rb#24
  def transients?; end

  private

  # source://async//lib/async/node.rb#53
  def added(node); end

  # source://async//lib/async/node.rb#61
  def removed(node); end
end

# A convenient wrapper around the internal monotonic clock.
#
# source://async//lib/async/clock.rb#9
class Async::Clock
  # Create a new clock with the initial total time.
  #
  # @return [Clock] a new instance of Clock
  #
  # source://async//lib/async/clock.rb#34
  def initialize(total = T.unsafe(nil)); end

  # Reset the total elapsed time. If the clock is currently running, reset the start time to now.
  #
  # source://async//lib/async/clock.rb#66
  def reset!; end

  # Start measuring a duration.
  #
  # source://async//lib/async/clock.rb#40
  def start!; end

  # Stop measuring a duration and append the duration to the current total.
  #
  # source://async//lib/async/clock.rb#45
  def stop!; end

  # The total elapsed time including any current duration.
  #
  # source://async//lib/async/clock.rb#55
  def total; end

  class << self
    # Measure the execution of a block of code.
    #
    # source://async//lib/async/clock.rb#18
    def measure; end

    # Get the current elapsed monotonic time.
    #
    # source://async//lib/async/clock.rb#11
    def now; end

    # Start measuring elapsed time from now.
    #
    # source://async//lib/async/clock.rb#28
    def start; end
  end
end

# A synchronization primitive, which allows fibers to wait until a particular condition is (edge) triggered.
#
# source://async//lib/async/condition.rb#13
class Async::Condition
  # Create a new condition.
  #
  # @return [Condition] a new instance of Condition
  #
  # source://async//lib/async/condition.rb#15
  def initialize; end

  # @return [Boolean]
  #
  # source://async//lib/async/condition.rb#26
  def empty?; end

  # Signal to a given task that it should resume operations.
  #
  # source://async//lib/async/condition.rb#37
  def signal(value = T.unsafe(nil)); end

  # Queue up the current fiber and wait on yielding the task.
  #
  # source://async//lib/async/condition.rb#21
  def wait; end

  # @return [Boolean]
  #
  # source://async//lib/async/condition.rb#31
  def waiting?; end

  protected

  # source://async//lib/async/condition.rb#53
  def exchange; end
end

# Private module that hooks into Process._fork to handle fork events.
#
# If `Scheduler#process_fork` hook is adopted in Ruby 4, this code can be removed after Ruby < 4 is no longer supported.
#
# source://async//lib/async/fork_handler.rb#11
module Async::ForkHandler
  # source://async//lib/async/fork_handler.rb#12
  def _fork(&block); end
end

# A load balancing mechanism that can be used process work when the system is idle.
#
# source://async//lib/async/idler.rb#8
class Async::Idler
  # Create a new idler.
  #
  # @return [Idler] a new instance of Idler
  #
  # source://async//lib/async/idler.rb#16
  def initialize(maximum_load = T.unsafe(nil), backoff: T.unsafe(nil), parent: T.unsafe(nil)); end

  # Wait until the system is idle, then execute the given block in a new task.
  #
  # source://async//lib/async/idler.rb#33
  def async(*arguments, parent: T.unsafe(nil), **options, &block); end

  # Wait until the system is idle, according to the maximum load specified.
  #
  # If the scheduler is overloaded, this method will sleep for an exponentially increasing amount of time.
  #
  # source://async//lib/async/idler.rb#43
  def wait; end
end

# A thread-safe queue which limits the number of items that can be enqueued.
#
# source://async//lib/async/queue.rb#129
class Async::LimitedQueue < ::Async::Queue
  # Create a new limited queue.
  #
  # @return [LimitedQueue] a new instance of LimitedQueue
  #
  # source://async//lib/async/queue.rb#141
  def initialize(limit = T.unsafe(nil), **options); end

  # source://async//lib/async/queue.rb#146
  def limit; end

  # @return [Boolean]
  #
  # source://async//lib/async/queue.rb#151
  def limited?; end

  class << self
    # @private This exists purely for emitting a warning.
    #
    # source://async//lib/async/queue.rb#131
    def new(*_arg0, **_arg1, &_arg2); end
  end
end

# A general doublely linked list. This is used internally by {Async::Barrier} and {Async::Condition} to manage child tasks.
#
# source://async//lib/async/list.rb#9
class Async::List
  # Initialize a new, empty, list.
  #
  # @return [List] a new instance of List
  #
  # source://async//lib/async/list.rb#11
  def initialize; end

  # A callback that is invoked when an item is added to the list.
  #
  # source://async//lib/async/list.rb#51
  def added(node); end

  # Append a node to the end of the list.
  #
  # source://async//lib/async/list.rb#57
  def append(node); end

  # Iterate over each node in the linked list. It is generally safe to remove the current node, any previous node or any future node during iteration.
  #
  # source://async//lib/async/list.rb#177
  def each(&block); end

  # @return [Boolean]
  #
  # source://async//lib/async/list.rb#140
  def empty?; end

  # source://async//lib/async/list.rb#198
  def first; end

  # Returns the value of attribute head.
  #
  # source://async//lib/async/list.rb#42
  def head; end

  # Sets the attribute head
  #
  # @param value the value to set the attribute head to.
  #
  # source://async//lib/async/list.rb#42
  def head=(_arg0); end

  # Determine whether the given node is included in the list.
  #
  # @return [Boolean]
  #
  # source://async//lib/async/list.rb#189
  def include?(needle); end

  # source://async//lib/async/list.rb#23
  def inspect; end

  # source://async//lib/async/list.rb#215
  def last; end

  # Prepend a node to the start of the list.
  #
  # source://async//lib/async/list.rb#71
  def prepend(node); end

  # Remove the node. If it was already removed, this will raise an error.
  #
  # You should be careful to only remove nodes that are part of this list.
  #
  # source://async//lib/async/list.rb#119
  def remove(node); end

  # Remove the node if it is in a list.
  #
  # You should be careful to only remove nodes that are part of this list.
  #
  # @return [Boolean]
  #
  # source://async//lib/async/list.rb#105
  def remove?(node); end

  # A callback that is invoked when an item is removed from the list.
  #
  # source://async//lib/async/list.rb#95
  def removed(node); end

  # Shift the first node off the list, if it is not empty.
  #
  # source://async//lib/async/list.rb#232
  def shift; end

  # Returns the value of attribute size.
  #
  # source://async//lib/async/list.rb#48
  def size; end

  # Add the node, yield, and the remove the node.
  #
  # source://async//lib/async/list.rb#87
  def stack(node, &block); end

  # Returns the value of attribute tail.
  #
  # source://async//lib/async/list.rb#45
  def tail; end

  # Sets the attribute tail
  #
  # @param value the value to set the attribute tail to.
  #
  # source://async//lib/async/list.rb#45
  def tail=(_arg0); end

  # Fast, safe, unbounded accumulation of children.
  #
  # source://async//lib/async/list.rb#26
  def to_a; end

  # source://async//lib/async/list.rb#18
  def to_s; end

  private

  # source://async//lib/async/list.rb#128
  def remove!(node); end
end

# source://async//lib/async/list.rb#252
class Async::List::Iterator < ::Async::List::Node
  # @return [Iterator] a new instance of Iterator
  #
  # source://async//lib/async/list.rb#253
  def initialize(list); end

  # source://async//lib/async/list.rb#296
  def each; end

  # source://async//lib/async/list.rb#281
  def move_current; end

  # source://async//lib/async/list.rb#271
  def move_next; end

  # source://async//lib/async/list.rb#263
  def remove!; end

  class << self
    # source://async//lib/async/list.rb#306
    def each(list, &block); end
  end
end

# A linked list Node.
#
# source://async//lib/async/list.rb#239
class Async::List::Node
  # Returns the value of attribute head.
  #
  # source://async//lib/async/list.rb#240
  def head; end

  # Sets the attribute head
  #
  # @param value the value to set the attribute head to.
  #
  # source://async//lib/async/list.rb#240
  def head=(_arg0); end

  # source://async//lib/async/list.rb#249
  def inspect; end

  # Returns the value of attribute tail.
  #
  # source://async//lib/async/list.rb#241
  def tail; end

  # Sets the attribute tail
  #
  # @param value the value to set the attribute tail to.
  #
  # source://async//lib/async/list.rb#241
  def tail=(_arg0); end

  # source://async//lib/async/list.rb#244
  def to_s; end
end

# A node in a tree, used for implementing the task hierarchy.
#
# source://async//lib/async/node.rb#71
class Async::Node
  # Create a new node in the tree.
  #
  # @return [Node] a new instance of Node
  #
  # source://async//lib/async/node.rb#74
  def initialize(parent = T.unsafe(nil), annotation: T.unsafe(nil), transient: T.unsafe(nil)); end

  # Annotate the node with a description.
  #
  # source://async//lib/async/node.rb#143
  def annotate(annotation); end

  # Returns the value of attribute annotation.
  #
  # source://async//lib/async/node.rb#109
  def annotation; end

  # Provides a backtrace for nodes that have an active execution context.
  #
  # source://async//lib/async/node.rb#175
  def backtrace(*arguments); end

  # Returns the value of attribute children.
  #
  # source://async//lib/async/node.rb#106
  def children; end

  # Whether this node has any children.
  #
  # @return [Boolean]
  #
  # source://async//lib/async/node.rb#113
  def children?; end

  # If the node has a parent, and is {finished?}, then remove this node from
  # the parent.
  #
  # source://async//lib/async/node.rb#231
  def consume; end

  # A description of the node, including the annotation and object name.
  #
  # source://async//lib/async/node.rb#160
  def description; end

  # Whether the node can be consumed (deleted) safely. By default, checks if the children set is empty.
  #
  # @return [Boolean]
  #
  # source://async//lib/async/node.rb#225
  def finished?; end

  # @private
  #
  # source://async//lib/async/node.rb#97
  def head; end

  # @private
  #
  # source://async//lib/async/node.rb#97
  def head=(_arg0); end

  # source://async//lib/async/node.rb#185
  def inspect; end

  # Returns the value of attribute parent.
  #
  # source://async//lib/async/node.rb#103
  def parent; end

  # Change the parent of this node.
  #
  # source://async//lib/async/node.rb#191
  def parent=(parent); end

  # Print the hierarchy of the task tree from the given node.
  #
  # source://async//lib/async/node.rb#307
  def print_hierarchy(out = T.unsafe(nil), backtrace: T.unsafe(nil)); end

  # source://async//lib/async/node.rb#92
  def root; end

  # Attempt to stop the current node immediately, including all non-transient children. Invokes {#stop_children} to stop all children.
  #
  # source://async//lib/async/node.rb#286
  def stop(later = T.unsafe(nil)); end

  # Whether the node has been stopped.
  #
  # @return [Boolean]
  #
  # source://async//lib/async/node.rb#299
  def stopped?; end

  # @private
  #
  # source://async//lib/async/node.rb#100
  def tail; end

  # @private
  #
  # source://async//lib/async/node.rb#100
  def tail=(_arg0); end

  # Immediately terminate all children tasks, including transient tasks. Internally invokes `stop(false)` on all children. This should be considered a last ditch effort and is used when closing the scheduler.
  #
  # source://async//lib/async/node.rb#271
  def terminate; end

  # source://async//lib/async/node.rb#180
  def to_s; end

  # Change the transient state of the node.
  #
  # A transient node is not considered when determining if a node is finished, and propagates up if the parent is consumed.
  #
  # source://async//lib/async/node.rb#132
  def transient=(value); end

  # Represents whether a node is transient. Transient nodes are not considered
  # when determining if a node is finished. This is useful for tasks which are
  # internal to an object rather than explicit user concurrency. For example,
  # a child task which is pruning a connection pool is transient, because it
  # is not directly related to the parent task, and should not prevent the
  # parent task from finishing.
  #
  # @return [Boolean]
  #
  # source://async//lib/async/node.rb#123
  def transient?; end

  # Traverse the task tree.
  #
  # source://async//lib/async/node.rb#256
  def traverse(&block); end

  protected

  # source://async//lib/async/node.rb#210
  def add_child(child); end

  # source://async//lib/async/node.rb#216
  def remove_child(child); end

  # source://async//lib/async/node.rb#206
  def set_parent(parent); end

  # @yield [_self, level]
  # @yieldparam _self [Async::Node] the object that the method was called on
  #
  # source://async//lib/async/node.rb#262
  def traverse_recurse(level = T.unsafe(nil), &block); end

  private

  # source://async//lib/async/node.rb#319
  def print_backtrace(out, indent, node); end

  # Attempt to stop all non-transient children.
  #
  # source://async//lib/async/node.rb#292
  def stop_children(later = T.unsafe(nil)); end
end

# A synchronization primitive, which allows fibers to wait until a notification is received. Does not block the task which signals the notification. Waiting tasks are resumed on next iteration of the reactor.
#
# source://async//lib/async/notification.rb#11
class Async::Notification < ::Async::Condition
  # Signal to a given task that it should resume operations.
  #
  # source://async//lib/async/notification.rb#15
  def signal(value = T.unsafe(nil)); end
end

# source://async//lib/async/notification.rb#23
class Async::Notification::Signal < ::Struct
  # @return [Boolean]
  #
  # source://async//lib/async/notification.rb#24
  def alive?; end

  # Returns the value of attribute ready
  #
  # @return [Object] the current value of ready
  #
  # source://async//lib/async/notification.rb#23
  def ready; end

  # Sets the attribute ready
  #
  # @param value [Object] the value to set the attribute ready to.
  # @return [Object] the newly set value
  #
  # source://async//lib/async/notification.rb#23
  def ready=(_); end

  # source://async//lib/async/notification.rb#28
  def transfer; end

  # Returns the value of attribute value
  #
  # @return [Object] the current value of value
  #
  # source://async//lib/async/notification.rb#23
  def value; end

  # Sets the attribute value
  #
  # @param value [Object] the value to set the attribute value to.
  # @return [Object] the newly set value
  #
  # source://async//lib/async/notification.rb#23
  def value=(_); end

  class << self
    # source://async//lib/async/notification.rb#23
    def [](*_arg0); end

    # source://async//lib/async/notification.rb#23
    def inspect; end

    # source://async//lib/async/notification.rb#23
    def keyword_init?; end

    # source://async//lib/async/notification.rb#23
    def members; end

    # source://async//lib/async/notification.rb#23
    def new(*_arg0); end
  end
end

# source://async//lib/async/scheduler.rb#25
Async::Profiler = T.let(T.unsafe(nil), T.untyped)

# A promise represents a value that will be available in the future.
# Unlike Condition, once resolved (or rejected), all future waits return immediately
# with the stored value or raise the stored exception.
#
# This is thread-safe and integrates with the fiber scheduler.
#
# source://async//lib/async/promise.rb#15
class Async::Promise
  # Create a new promise.
  #
  # @return [Promise] a new instance of Promise
  #
  # source://async//lib/async/promise.rb#17
  def initialize; end

  # Cancel the promise, indicating cancellation.
  # All current and future waiters will receive nil.
  # Can only be called on pending promises - no-op if already resolved.
  #
  # source://async//lib/async/promise.rb#150
  def cancel(exception = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://async//lib/async/promise.rb#43
  def cancelled?; end

  # @return [Boolean]
  #
  # source://async//lib/async/promise.rb#53
  def completed?; end

  # @return [Boolean]
  #
  # source://async//lib/async/promise.rb#48
  def failed?; end

  # Resolve the promise with the result of the block.
  # If the block raises an exception, the promise will be rejected.
  # If the promise was already resolved, the block will not be called.
  #
  # source://async//lib/async/promise.rb#170
  def fulfill(&block); end

  # Reject the promise with an exception.
  # All current and future waiters will receive this exception.
  # Can only be called once - subsequent calls are ignored.
  #
  # source://async//lib/async/promise.rb#129
  def reject(exception); end

  # Resolve the promise with a value.
  # All current and future waiters will receive this value.
  # Can only be called once - subsequent calls are ignored.
  #
  # source://async//lib/async/promise.rb#110
  def resolve(value); end

  # @private For internal use by Task.
  #
  # source://async//lib/async/promise.rb#38
  def resolved; end

  # @return [Boolean]
  #
  # source://async//lib/async/promise.rb#32
  def resolved?; end

  # Artificially mark that someone is waiting (useful for suppressing warnings).
  #
  # @private Internal use only.
  #
  # source://async//lib/async/promise.rb#64
  def suppress_warnings!; end

  # Non-blocking access to the current value. Returns nil if not yet resolved.
  # Does not raise exceptions even if the promise was rejected or cancelled.
  # For resolved promises, returns the raw stored value (result, exception, or cancel exception).
  #
  # source://async//lib/async/promise.rb#73
  def value; end

  # Wait for the promise to be resolved and return the value.
  # If already resolved, returns immediately. If rejected, raises the stored exception.
  #
  # source://async//lib/async/promise.rb#82
  def wait; end

  # @return [Boolean]
  #
  # source://async//lib/async/promise.rb#58
  def waiting?; end

  class << self
    # If a promise is given, fulfill it with the result of the block.
    # If no promise is given, simply yield to the block.
    # This is useful for methods that may optionally take a promise to fulfill.
    #
    # source://async//lib/async/promise.rb#194
    def fulfill(promise, &block); end
  end
end

# Exception used to indicate cancellation.
#
# source://async//lib/async/promise.rb#144
class Async::Promise::Cancel < ::Exception; end

# A thread-safe queue which allows items to be processed in order.
#
# This implementation uses Thread::Queue internally for thread safety while
# maintaining compatibility with the fiber scheduler.
#
# It has a compatible interface with {Notification} and {Condition}, except that it's multi-value.
#
# source://async//lib/async/queue.rb#22
class Async::Queue
  # Create a new thread-safe queue.
  #
  # @return [Queue] a new instance of Queue
  #
  # source://async//lib/async/queue.rb#31
  def initialize(parent: T.unsafe(nil), delegate: T.unsafe(nil)); end

  # Compatibility with {::Queue#push}.
  #
  # source://async//lib/async/queue.rb#69
  def <<(item); end

  # Process each item in the queue.
  #
  # source://async//lib/async/queue.rb#102
  def async(parent: T.unsafe(nil), **options, &block); end

  # Close the queue, causing all waiting tasks to return `nil`. Any subsequent calls to {enqueue} will raise an exception.
  #
  # source://async//lib/async/queue.rb#42
  def close; end

  # @return [Boolean]
  #
  # source://async//lib/async/queue.rb#37
  def closed?; end

  # Remove and return the next item from the queue.
  #
  # source://async//lib/async/queue.rb#83
  def dequeue(timeout: T.unsafe(nil)); end

  # Enumerate each item in the queue.
  #
  # source://async//lib/async/queue.rb#109
  def each; end

  # @return [Boolean]
  #
  # source://async//lib/async/queue.rb#52
  def empty?; end

  # Add multiple items to the queue.
  #
  # source://async//lib/async/queue.rb#74
  def enqueue(*items); end

  # Compatibility with {::Queue#pop}.
  #
  # source://async//lib/async/queue.rb#90
  def pop(timeout: T.unsafe(nil)); end

  # Add an item to the queue.
  #
  # source://async//lib/async/queue.rb#62
  def push(item); end

  # Signal the queue with a value, the same as {#enqueue}.
  #
  # source://async//lib/async/queue.rb#116
  def signal(value = T.unsafe(nil)); end

  # source://async//lib/async/queue.rb#47
  def size; end

  # Wait for an item to be available, the same as {#dequeue}.
  #
  # source://async//lib/async/queue.rb#121
  def wait; end

  # source://async//lib/async/queue.rb#57
  def waiting_count; end
end

# An error raised when trying to enqueue items to a closed queue.
#
# source://async//lib/async/queue.rb#25
class Async::Queue::ClosedError < ::RuntimeError; end

# A wrapper around the the scheduler which binds it to the current thread automatically.
#
# source://async//lib/async/reactor.rb#12
class Async::Reactor < ::Async::Scheduler
  # Initialize the reactor and assign it to the current Fiber scheduler.
  #
  # @return [Reactor] a new instance of Reactor
  #
  # source://async//lib/async/reactor.rb#21
  def initialize(*_arg0, **_arg1, &_arg2); end

  # Close the reactor and remove it from the current Fiber scheduler.
  #
  # source://async//lib/async/reactor.rb#28
  def scheduler_close; end

  # source://async//lib/async/reactor.rb#32
  def sleep(*_arg0); end

  class << self
    # @deprecated Replaced by {Kernel::Async}.
    #
    # source://async//lib/async/reactor.rb#14
    def run(*_arg0, **_arg1, &_arg2); end
  end
end

# Handles scheduling of fibers. Implements the fiber scheduler interface.
#
# source://async//lib/async/scheduler.rb#29
class Async::Scheduler < ::Async::Node
  # Create a new scheduler.
  #
  # @return [Scheduler] a new instance of Scheduler
  #
  # source://async//lib/async/scheduler.rb#77
  def initialize(parent = T.unsafe(nil), selector: T.unsafe(nil), profiler: T.unsafe(nil), worker_pool: T.unsafe(nil)); end

  # Resolve the address of the given hostname.
  #
  # source://async//lib/async/scheduler.rb#294
  def address_resolve(hostname); end

  # Start an asynchronous task within the specified reactor. The task will be executed until the first blocking call, at which point it will yield and and this method will return.
  #
  # @deprecated Use {#run} or {Task#async} instead.
  #
  # source://async//lib/async/scheduler.rb#588
  def async(*arguments, **options, &block); end

  # Invoked when a fiber tries to perform a blocking operation which cannot continue. A corresponding call {unblock} must be performed to allow this fiber to continue.
  #
  # source://async//lib/async/scheduler.rb#233
  def block(blocker, timeout); end

  # Terminate all child tasks and close the scheduler.
  #
  # source://async//lib/async/scheduler.rb#149
  def close; end

  # @return [Boolean]
  #
  # source://async//lib/async/scheduler.rb#176
  def closed?; end

  # Create a new fiber and return it without starting execution.
  #
  # source://async//lib/async/scheduler.rb#603
  def fiber(*_arg0, **_arg1, &_arg2); end

  # Raise an exception on the specified fiber, waking up the event loop if necessary.
  #
  # source://async//lib/async/scheduler.rb#402
  def fiber_interrupt(fiber, exception); end

  # Interrupt the event loop and cause it to exit.
  #
  # source://async//lib/async/scheduler.rb#187
  def interrupt; end

  # Read from the specified IO into the buffer.
  #
  # source://async//lib/async/scheduler.rb#339
  def io_read(io, buffer, length, offset = T.unsafe(nil)); end

  # Wait for the specified IOs to become ready for the specified events.
  #
  # source://async//lib/async/scheduler.rb#424
  def io_select(*_arg0, **_arg1, &_arg2); end

  # Wait for the specified IO to become ready for the specified events.
  #
  # source://async//lib/async/scheduler.rb#309
  def io_wait(io, events, timeout = T.unsafe(nil)); end

  # Write the specified buffer to the IO.
  #
  # source://async//lib/async/scheduler.rb#363
  def io_write(io, buffer, length, offset = T.unsafe(nil)); end

  # Sleep for the specified duration.
  #
  # source://async//lib/async/scheduler.rb#278
  def kernel_sleep(duration = T.unsafe(nil)); end

  # Compute the scheduler load according to the busy and idle times that are updated by the run loop.
  #
  # source://async//lib/async/scheduler.rb#106
  def load; end

  # Handle fork in the child process. This method is called automatically when `Process.fork` is invoked.
  #
  # The child process starts with a clean slate - no scheduler is set. Users can create a new scheduler if needed.
  #
  # source://async//lib/async/scheduler.rb#654
  def process_fork; end

  # Wait for the specified process ID to exit.
  #
  # source://async//lib/async/scheduler.rb#416
  def process_wait(pid, flags); end

  # Schedule a fiber (or equivalent object) to be resumed on the next loop through the reactor.
  #
  # source://async//lib/async/scheduler.rb#204
  def push(fiber); end

  # Raise an exception on a specified fiber with the given arguments.
  #
  # This internally schedules the current fiber to be ready, before raising the exception, so that it will later resume execution.
  #
  # source://async//lib/async/scheduler.rb#214
  def raise(*_arg0, **_arg1, &_arg2); end

  # Resume execution of the specified fiber.
  #
  # source://async//lib/async/scheduler.rb#222
  def resume(fiber, *arguments); end

  # Run the reactor until all tasks are finished. Proxies arguments to {#async} immediately before entering the loop, if a block is provided.
  #
  # Forwards all parameters to {#async} if a block is given.
  #
  # source://async//lib/async/scheduler.rb#562
  def run(*_arg0, **_arg1, &_arg2); end

  # Run one iteration of the event loop.
  #
  # source://async//lib/async/scheduler.rb#483
  def run_once(timeout = T.unsafe(nil)); end

  # Invoked when the fiber scheduler is being closed.
  #
  # Executes the run loop until all tasks are finished, then closes the scheduler.
  #
  # source://async//lib/async/scheduler.rb#128
  def scheduler_close(error = T.unsafe(nil)); end

  # Stop all children, including transient children.
  #
  # source://async//lib/async/scheduler.rb#517
  def stop; end

  # Terminate all child tasks.
  #
  # source://async//lib/async/scheduler.rb#138
  def terminate; end

  # Invoke the block, but after the specified timeout, raise the specified exception with the given message. If the block runs to completion before the timeout occurs or there are no non-blocking operations after the timeout expires, the code will complete without any exception.
  #
  # source://async//lib/async/scheduler.rb#643
  def timeout_after(duration, exception, message, &block); end

  # source://async//lib/async/scheduler.rb#181
  def to_s; end

  # Transfer from the calling fiber to the event loop.
  #
  # source://async//lib/async/scheduler.rb#193
  def transfer; end

  # Unblock a fiber that was previously blocked.
  #
  # source://async//lib/async/scheduler.rb#262
  def unblock(blocker, fiber); end

  # Invoke the block, but after the specified timeout, raise {TimeoutError} in any currenly blocking operation. If the block runs to completion before the timeout occurs or there are no non-blocking operations after the timeout expires, the code will complete without any exception.
  #
  # source://async//lib/async/scheduler.rb#616
  def with_timeout(duration, exception = T.unsafe(nil), message = T.unsafe(nil), &block); end

  # Yield the current fiber and resume it on the next iteration of the event loop.
  #
  # source://async//lib/async/scheduler.rb#198
  def yield; end

  private

  # Checks and clears the interrupted state of the scheduler.
  #
  # @return [Boolean]
  #
  # source://async//lib/async/scheduler.rb#501
  def interrupted?; end

  # source://async//lib/async/scheduler.rb#523
  def run_loop(&block); end

  # Run one iteration of the event loop.
  #
  # When terminating the event loop, we already know we are finished. So we don't need to check the task tree. This is a logical requirement because `run_once` ignores transient tasks. For example, a single top level transient task is not enough to keep the reactor running, but during termination we must still process it in order to terminate child tasks.
  #
  # source://async//lib/async/scheduler.rb#439
  def run_once!(timeout = T.unsafe(nil)); end

  class << self
    # Whether the fiber scheduler is supported.
    #
    # @return [Boolean]
    #
    # source://async//lib/async/scheduler.rb#46
    def supported?; end
  end
end

# Used to augment the scheduler to add support for blocking operations.
#
# source://async//lib/async/scheduler.rb#51
module Async::Scheduler::BlockingOperationWait
  # Wait for the given work to be executed.
  #
  # source://async//lib/async/scheduler.rb#59
  def blocking_operation_wait(work); end
end

# Raised when an operation is attempted on a closed scheduler.
#
# source://async//lib/async/scheduler.rb#35
class Async::Scheduler::ClosedError < ::RuntimeError
  # Create a new error.
  #
  # @return [ClosedError] a new instance of ClosedError
  #
  # source://async//lib/async/scheduler.rb#39
  def initialize(message = T.unsafe(nil)); end
end

# Used to defer stopping the current task until later.
#
# source://async//lib/async/scheduler.rb#380
class Async::Scheduler::FiberInterrupt
  # Create a new stop later operation.
  #
  # @return [FiberInterrupt] a new instance of FiberInterrupt
  #
  # source://async//lib/async/scheduler.rb#384
  def initialize(fiber, exception); end

  # @return [Boolean]
  #
  # source://async//lib/async/scheduler.rb#390
  def alive?; end

  # Transfer control to the operation - this will stop the task.
  #
  # source://async//lib/async/scheduler.rb#395
  def transfer; end
end

# source://async//lib/async/scheduler.rb#30
Async::Scheduler::WORKER_POOL = T.let(T.unsafe(nil), T.untyped)

# source://async//lib/async/scheduler.rb#69
Async::Scheduler::WorkerPool = T.let(T.unsafe(nil), T.untyped)

# A synchronization primitive, which limits access to a given resource.
#
# source://async//lib/async/semaphore.rb#11
class Async::Semaphore
  # @return [Semaphore] a new instance of Semaphore
  #
  # source://async//lib/async/semaphore.rb#14
  def initialize(limit = T.unsafe(nil), parent: T.unsafe(nil)); end

  # Acquire the semaphore, block if we are at the limit.
  # If no block is provided, you must call release manually.
  #
  # source://async//lib/async/semaphore.rb#79
  def acquire; end

  # Run an async task. Will wait until the semaphore is ready until spawning and running the task.
  #
  # source://async//lib/async/semaphore.rb#61
  def async(*arguments, parent: T.unsafe(nil), **options); end

  # Whether trying to acquire this semaphore would block.
  #
  # @return [Boolean]
  #
  # source://async//lib/async/semaphore.rb#56
  def blocking?; end

  # The current number of tasks that have acquired the semaphore.
  #
  # source://async//lib/async/semaphore.rb#23
  def count; end

  # Is the semaphore currently acquired?
  #
  # @return [Boolean]
  #
  # source://async//lib/async/semaphore.rb#51
  def empty?; end

  # The maximum number of tasks that can acquire the semaphore.
  #
  # source://async//lib/async/semaphore.rb#26
  def limit; end

  # Allow setting the limit. This is useful for cases where the semaphore is used to limit the number of concurrent tasks, but the number of tasks is not known in advance or needs to be modified.
  #
  # On increasing the limit, some tasks may be immediately resumed. On decreasing the limit, some tasks may execute until the count is < than the limit.
  #
  # source://async//lib/async/semaphore.rb#36
  def limit=(limit); end

  # Release the semaphore. Must match up with a corresponding call to `acquire`. Will release waiting fibers in FIFO order.
  #
  # source://async//lib/async/semaphore.rb#94
  def release; end

  # The tasks waiting on this semaphore.
  #
  # source://async//lib/async/semaphore.rb#29
  def waiting; end

  private

  # Wait until the semaphore becomes available.
  #
  # source://async//lib/async/semaphore.rb#119
  def wait; end
end

# source://async//lib/async/semaphore.rb#104
class Async::Semaphore::FiberNode < ::Async::List::Node
  # @return [FiberNode] a new instance of FiberNode
  #
  # source://async//lib/async/semaphore.rb#105
  def initialize(fiber); end

  # source://async//lib/async/semaphore.rb#109
  def resume; end
end

# Raised when a task is explicitly stopped.
#
# source://async//lib/async/stop.rb#11
class Async::Stop < ::Exception
  # Create a new stop operation.
  #
  # This is a compatibility method for Ruby versions before 3.5 where cause is not propagated correctly when using {Fiber#raise}
  #
  # @return [Stop] a new instance of Stop
  #
  # source://async//lib/async/stop.rb#43
  def initialize(message = T.unsafe(nil)); end

  # This is a compatibility method for Ruby versions before 3.5 where cause is not propagated correctly when using {Fiber#raise}, we explicitly capture the cause here.
  #
  # source://async//lib/async/stop.rb#55
  def cause; end
end

# Represents the source of the stop operation.
#
# source://async//lib/async/stop.rb#13
class Async::Stop::Cause < ::Exception
  class << self
    # source://async//lib/async/stop.rb#16
    def backtrace; end

    # Create a new cause of the stop operation, with the given message.
    #
    # source://async//lib/async/stop.rb#30
    def for(message = T.unsafe(nil)); end
  end
end

# Used to defer stopping the current task until later.
#
# source://async//lib/async/stop.rb#61
class Async::Stop::Later
  # Create a new stop later operation.
  #
  # @return [Later] a new instance of Later
  #
  # source://async//lib/async/stop.rb#66
  def initialize(task, cause = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://async//lib/async/stop.rb#72
  def alive?; end

  # Transfer control to the operation - this will stop the task.
  #
  # source://async//lib/async/stop.rb#77
  def transfer; end
end

# source://async//lib/async/task.rb#35
class Async::Task < ::Async::Node
  # Create a new task.
  #
  # @return [Task] a new instance of Task
  #
  # source://async//lib/async/task.rb#63
  def initialize(parent = T.unsafe(nil), finished: T.unsafe(nil), **options, &block); end

  # @return [Boolean]
  #
  # source://async//lib/async/task.rb#148
  def alive?; end

  # Annotate the task with a description.
  #
  # This will internally try to annotate the fiber if it is running, otherwise it will annotate the task itself.
  #
  # source://async//lib/async/task.rb#105
  def annotate(annotation, &block); end

  # source://async//lib/async/task.rb#114
  def annotation; end

  # Run an asynchronous task as a child of the current task.
  #
  # @raise [FinishedError]
  #
  # source://async//lib/async/task.rb#229
  def async(*arguments, **options, &block); end

  # source://async//lib/async/task.rb#96
  def backtrace(*arguments); end

  # Alias for {#completed?}.
  #
  # @return [Boolean]
  #
  # source://async//lib/async/task.rb#180
  def complete?; end

  # @return [Boolean]
  #
  # source://async//lib/async/task.rb#175
  def completed?; end

  # @return [Boolean]
  #
  # source://async//lib/async/task.rb#389
  def current?; end

  # Defer the handling of stop. During the execution of the given block, if a stop is requested, it will be deferred until the block exits. This is useful for ensuring graceful shutdown of servers and other long-running tasks. You should wrap the response handling code in a defer_stop block to ensure that the task is stopped when the response is complete but not before.
  #
  # You can nest calls to defer_stop, but the stop will only be deferred until the outermost block exits.
  #
  # If stop is invoked a second time, it will be immediately executed.
  #
  # source://async//lib/async/task.rb#338
  def defer_stop; end

  # @return [Boolean]
  #
  # source://async//lib/async/task.rb#165
  def failed?; end

  # Returns the value of attribute fiber.
  #
  # source://async//lib/async/task.rb#145
  def fiber; end

  # Whether we can remove this node from the reactor graph.
  #
  # @return [Boolean]
  #
  # source://async//lib/async/task.rb#154
  def finished?; end

  # source://async//lib/async/task.rb#91
  def reactor; end

  # Access the result of the task without waiting. May be nil if the task is not completed. Does not raise exceptions.
  #
  # source://async//lib/async/task.rb#266
  def result; end

  # Begin the execution of the task.
  #
  # source://async//lib/async/task.rb#201
  def run(*arguments); end

  # @return [Boolean]
  #
  # source://async//lib/async/task.rb#160
  def running?; end

  # @deprecated Prefer {Kernel#sleep} except when compatibility with `stable-v1` is required.
  #
  # source://async//lib/async/task.rb#128
  def sleep(duration = T.unsafe(nil)); end

  # source://async//lib/async/task.rb#185
  def status; end

  # Stop the task and all of its children.
  #
  # If `later` is false, it means that `stop` has been invoked directly. When `later` is true, it means that `stop` is invoked by `stop_children` or some other indirect mechanism. In that case, if we encounter the "current" fiber, we can't stop it right away, as it's currently performing `#stop`. Stopping it immediately would interrupt the current stop traversal, so we need to schedule the stop to occur later.
  #
  # source://async//lib/async/task.rb#282
  def stop(later = T.unsafe(nil), cause: T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://async//lib/async/task.rb#371
  def stop_deferred?; end

  # @return [Boolean]
  #
  # source://async//lib/async/task.rb#170
  def stopped?; end

  # source://async//lib/async/task.rb#123
  def to_s; end

  # Retrieve the current result of the task. Will cause the caller to wait until result is available. If the task resulted in an unhandled error (derived from `StandardError`), this will be raised. If the task was stopped, this will return `nil`.
  #
  # Conceptually speaking, waiting on a task should return a result, and if it throws an exception, this is certainly an exceptional case that should represent a failure in your program, not an expected outcome. In other words, you should not design your programs to expect exceptions from `#wait` as a normal flow control, and prefer to catch known exceptions within the task itself and return a result that captures the intention of the failure, e.g. a `TimeoutError` might simply return `nil` or `false` to indicate that the operation did not generate a valid result (as a timeout was an expected outcome of the internal operation in this case).
  #
  # source://async//lib/async/task.rb#253
  def wait; end

  # Execute the given block of code, raising the specified exception if it exceeds the given duration during a non-blocking operation.
  #
  # source://async//lib/async/task.rb#135
  def with_timeout(duration, exception = T.unsafe(nil), message = T.unsafe(nil), &block); end

  # Yield back to the reactor and allow other fibers to execute.
  #
  # source://async//lib/async/task.rb#140
  def yield; end

  private

  # State transition into the completed state.
  #
  # source://async//lib/async/task.rb#410
  def completed!(result); end

  # State transition into the failed state.
  #
  # source://async//lib/async/task.rb#416
  def failed!(exception = T.unsafe(nil)); end

  # Finish the current task, moving any children to the parent.
  #
  # source://async//lib/async/task.rb#400
  def finish!; end

  # source://async//lib/async/task.rb#449
  def schedule(&block); end

  # source://async//lib/async/task.rb#443
  def stop!; end

  # source://async//lib/async/task.rb#421
  def stopped!; end

  # source://async//lib/async/task.rb#395
  def warn(*_arg0, **_arg1, &_arg2); end

  class << self
    # Lookup the {Task} for the current fiber. Raise `RuntimeError` if none is available.
    # @raises[RuntimeError] If task was not {set!} for the current fiber.
    #
    # source://async//lib/async/task.rb#378
    def current; end

    # Check if there is a task defined for the current fiber.
    #
    # @return [Boolean]
    #
    # source://async//lib/async/task.rb#384
    def current?; end

    # Run the given block of code in a task, asynchronously, in the given scheduler.
    #
    # source://async//lib/async/task.rb#54
    def run(scheduler, *arguments, **options, &block); end

    # @deprecated With no replacement.
    #
    # source://async//lib/async/task.rb#47
    def yield; end
  end
end

# Raised when a child task is created within a task that has finished execution.
#
# source://async//lib/async/task.rb#37
class Async::Task::FinishedError < ::RuntimeError
  # Create a new finished error.
  #
  # @return [FinishedError] a new instance of FinishedError
  #
  # source://async//lib/async/task.rb#41
  def initialize(message = T.unsafe(nil)); end
end

# Represents a flexible timeout that can be rescheduled or extended.
#
# source://async//lib/async/timeout.rb#9
class Async::Timeout
  # Initialize a new timeout.
  #
  # @return [Timeout] a new instance of Timeout
  #
  # source://async//lib/async/timeout.rb#11
  def initialize(timers, handle); end

  # Adjust the timeout by the specified duration.
  #
  # The duration is relative to the timeout time, e.g. adjusting the timeout by 5 increases the current duration by 5 seconds.
  #
  # source://async//lib/async/timeout.rb#36
  def adjust(duration); end

  # Cancel the timeout, preventing it from executing.
  #
  # source://async//lib/async/timeout.rb#59
  def cancel!; end

  # @return [Boolean]
  #
  # source://async//lib/async/timeout.rb#64
  def cancelled?; end

  # source://async//lib/async/timeout.rb#17
  def duration; end

  # Update the duration of the timeout.
  #
  # The duration is relative to the current time, e.g. setting the duration to 5 means the timeout will occur in 5 seconds from now.
  #
  # source://async//lib/async/timeout.rb#26
  def duration=(value); end

  # source://async//lib/async/timeout.rb#54
  def now; end

  # source://async//lib/async/timeout.rb#41
  def time; end

  # Assign a new time to the timeout, rescheduling it if necessary.
  #
  # source://async//lib/async/timeout.rb#49
  def time=(value); end

  private

  # Reschedule the timeout to occur at the specified time.
  #
  # source://async//lib/async/timeout.rb#76
  def reschedule(time); end
end

# Raised when attempting to reschedule a cancelled timeout.
#
# source://async//lib/async/timeout.rb#69
class Async::Timeout::CancelledError < ::RuntimeError; end

# Raised if a timeout occurs on a specific Fiber. Handled gracefully by `Task`.
#
# source://async//lib/async/task.rb#25
class Async::TimeoutError < ::StandardError
  # Create a new timeout error.
  #
  # @return [TimeoutError] a new instance of TimeoutError
  #
  # source://async//lib/async/task.rb#29
  def initialize(message = T.unsafe(nil)); end
end

# source://async//lib/async/version.rb#7
Async::VERSION = T.let(T.unsafe(nil), String)

# A synchronization primitive that allows one task to wait for another task to resolve a value.
#
# @deprecated Use {Async::Promise} instead.
#
# source://async//lib/async/variable.rb#13
class Async::Variable
  # Create a new variable.
  #
  # @return [Variable] a new instance of Variable
  #
  # source://async//lib/async/variable.rb#17
  def initialize(condition = T.unsafe(nil)); end

  # Resolve the value.
  #
  # Signals all waiting tasks.
  #
  # source://async//lib/async/variable.rb#29
  def resolve(value = T.unsafe(nil)); end

  # Whether the value has been resolved.
  #
  # @return [Boolean]
  #
  # source://async//lib/async/variable.rb#47
  def resolved?; end

  # Alias for {#wait}.
  #
  # source://async//lib/async/variable.rb#60
  def value; end

  # Alias for {#resolve}.
  #
  # source://async//lib/async/variable.rb#40
  def value=(value); end

  # Wait for the value to be resolved.
  #
  # source://async//lib/async/variable.rb#54
  def wait; end
end

# Extensions to all Ruby objects.
#
# source://async//lib/kernel/async.rb#8
module Kernel
  # Run the given block of code in a task, asynchronously, creating a reactor if necessary.
  #
  # The preferred method to invoke asynchronous behavior at the top level.
  #
  # - When invoked within an existing reactor task, it will run the given block
  # asynchronously. Will return the task once it has been scheduled.
  # - When invoked at the top level, will create and run a reactor, and invoke
  # the block as an asynchronous task. Will block until the reactor finishes
  # running.
  #
  # source://async//lib/kernel/async.rb#24
  def Async(*_arg0, **_arg1, &_arg2); end

  # Create a barrier, yield it to the block, and then wait for all tasks to complete.
  #
  # If no scheduler is running, one will be created automatically for the duration of the block.
  #
  # By default, the barrier uses an `Async::Idler` to manage load, but this can be overridden by providing a different parent or `nil` to disable load management.
  #
  # source://async//lib/kernel/barrier.rb#20
  def Barrier(parent: T.unsafe(nil), **options); end

  # Run the given block of code synchronously, but within a reactor if not already in one.
  #
  # source://async//lib/kernel/sync.rb#20
  def Sync(annotation: T.unsafe(nil), &block); end
end

module Process
  extend ::ActiveSupport::ForkTracker::CoreExt
  extend ::Async::ForkHandler
end
