# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `protocol-http` gem.
# Please instead update this file by running `bin/tapioca gem protocol-http`.


# source://protocol-http//lib/protocol/http/body/readable.rb#7
module Protocol; end

# source://protocol-http//lib/protocol/http/body/readable.rb#8
module Protocol::HTTP; end

# Represents a bad request error (as opposed to a server error).
# This is used to indicate that the request was malformed or invalid.
#
# source://protocol-http//lib/protocol/http/error.rb#14
module Protocol::HTTP::BadRequest; end

# source://protocol-http//lib/protocol/http/body/readable.rb#9
module Protocol::HTTP::Body; end

# A body which buffers all its contents.
#
# source://protocol-http//lib/protocol/http/body/buffered.rb#14
class Protocol::HTTP::Body::Buffered < ::Protocol::HTTP::Body::Readable
  # Initialize the buffered body with some chunks.
  #
  # @return [Buffered] a new instance of Buffered
  #
  # source://protocol-http//lib/protocol/http/body/buffered.rb#51
  def initialize(chunks = T.unsafe(nil), length = T.unsafe(nil)); end

  # A rewindable body wraps some other body. Convert it to a buffered body. The buffered body will share the same chunks as the rewindable body.
  #
  # source://protocol-http//lib/protocol/http/body/buffered.rb#64
  def buffered; end

  # Returns the value of attribute chunks.
  #
  # source://protocol-http//lib/protocol/http/body/buffered.rb#59
  def chunks; end

  # Clear the buffered chunks.
  #
  # source://protocol-http//lib/protocol/http/body/buffered.rb#85
  def clear; end

  # Ensure that future reads return `nil`, but allow for rewinding.
  #
  # source://protocol-http//lib/protocol/http/body/buffered.rb#78
  def close(error = T.unsafe(nil)); end

  # Close the body for writing. This is a no-op.
  #
  # source://protocol-http//lib/protocol/http/body/buffered.rb#132
  def close_write(error); end

  # Discard the body. Invokes {#close}.
  #
  # source://protocol-http//lib/protocol/http/body/buffered.rb#121
  def discard; end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/body/buffered.rb#97
  def empty?; end

  # Finish the body, this is a no-op.
  #
  # source://protocol-http//lib/protocol/http/body/buffered.rb#71
  def finish; end

  # Inspect the buffered body.
  #
  # source://protocol-http//lib/protocol/http/body/buffered.rb#155
  def inspect; end

  # The length of the body. Will compute and cache the length of the body, if it was not provided.
  #
  # source://protocol-http//lib/protocol/http/body/buffered.rb#92
  def length; end

  # Read the next chunk from the buffered body.
  #
  # source://protocol-http//lib/protocol/http/body/buffered.rb#110
  def read; end

  # Whether the body is ready to be read.
  #
  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/body/buffered.rb#103
  def ready?; end

  # Rewind the body to the beginning, causing a subsequent read to return the first chunk.
  #
  # source://protocol-http//lib/protocol/http/body/buffered.rb#144
  def rewind; end

  # Whether the body can be rewound.
  #
  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/body/buffered.rb#139
  def rewindable?; end

  # Write a chunk to the buffered body.
  #
  # source://protocol-http//lib/protocol/http/body/buffered.rb#127
  def write(chunk); end

  class << self
    # Read the entire body into a buffered representation.
    #
    # source://protocol-http//lib/protocol/http/body/buffered.rb#37
    def read(body); end

    # Tries to wrap an object in a {Buffered} instance.
    #
    # For compatibility, also accepts anything that behaves like an `Array(String)`.
    #
    # source://protocol-http//lib/protocol/http/body/buffered.rb#21
    def wrap(object); end
  end
end

# Invokes a callback once the body has completed, either successfully or due to an error.
#
# source://protocol-http//lib/protocol/http/body/completable.rb#12
class Protocol::HTTP::Body::Completable < ::Protocol::HTTP::Body::Wrapper
  # Initialize the completable body with a callback.
  #
  # @return [Completable] a new instance of Completable
  #
  # source://protocol-http//lib/protocol/http/body/completable.rb#29
  def initialize(body, callback); end

  # Close the body and invoke the callback. If an error is given, it is passed to the callback.
  #
  # The calback is only invoked once, and before `super` is invoked.
  #
  # source://protocol-http//lib/protocol/http/body/completable.rb#48
  def close(error = T.unsafe(nil)); end

  # Rewind the body, is not supported.
  #
  # source://protocol-http//lib/protocol/http/body/completable.rb#41
  def rewind; end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/body/completable.rb#36
  def rewindable?; end

  class << self
    # Wrap a message body with a callback. If the body is empty, the callback is invoked immediately.
    #
    # source://protocol-http//lib/protocol/http/body/completable.rb#17
    def wrap(message, &block); end
  end
end

# Represents a body suitable for HEAD requests, in other words, a body that is empty and has a known length.
#
# source://protocol-http//lib/protocol/http/body/head.rb#13
class Protocol::HTTP::Body::Head < ::Protocol::HTTP::Body::Readable
  # Initialize the head body with the given length.
  #
  # @return [Head] a new instance of Head
  #
  # source://protocol-http//lib/protocol/http/body/head.rb#38
  def initialize(length); end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/body/head.rb#43
  def empty?; end

  # source://protocol-http//lib/protocol/http/body/head.rb#53
  def length; end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/body/head.rb#48
  def ready?; end

  class << self
    # Create a head body for the given body, capturing its length and then closing it.
    #
    # If a body is provided, the length is determined from the body, and the body is closed.
    # If no body is provided, and the content length is provided, a head body is created with that length.
    # This is useful for creating a head body when you only know the content length but not the actual body, which may happen in adapters for HTTP applications where the application may not provide a body for HEAD requests, but the content length is known.
    #
    # source://protocol-http//lib/protocol/http/body/head.rb#23
    def for(body, length = T.unsafe(nil)); end
  end
end

# Represents a readable input streams.
#
# There are two major modes of operation:
#
# 1. Reading chunks using {read} (or {each}/{join}), until the body is empty, or
# 2. Streaming chunks using {call}, which writes chunks to a provided output stream.
#
# In both cases, reading can fail, for example if the body represents a streaming upload, and the connection is lost. In this case, {read} will raise some kind of error, or the stream will be closed with an error.
#
# At any point, you can use {close} to close the stream and release any resources, or {discard} to read all remaining data without processing it which may allow the underlying connection to be reused (but can be slower).
#
# source://protocol-http//lib/protocol/http/body/readable.rb#20
class Protocol::HTTP::Body::Readable
  # Convert the body to a hash suitable for serialization. This won't include the contents of the body, but will include metadata such as the length, streamability, and readiness, etc.
  #
  # source://protocol-http//lib/protocol/http/body/readable.rb#173
  def as_json(*_arg0, **_arg1, &_arg2); end

  # Return a buffered representation of this body.
  #
  # This method must return a buffered body if `#rewindable?`.
  #
  # source://protocol-http//lib/protocol/http/body/readable.rb#67
  def buffered; end

  # Invoke the body with the given stream.
  #
  # The default implementation simply writes each chunk to the stream. If the body is not ready, it will be flushed after each chunk. Closes the stream when finished or if an error occurs.
  #
  # Write the body to the given stream.
  #
  # source://protocol-http//lib/protocol/http/body/readable.rb#138
  def call(stream); end

  # Close the stream immediately. After invoking this method, the stream should be considered closed, and all internal resources should be released.
  #
  # If an error occured while handling the output, it can be passed as an argument. This may be propagated to the client, for example the client may be informed that the stream was not fully read correctly.
  #
  # Invoking {read} after {close} will return `nil`.
  #
  # source://protocol-http//lib/protocol/http/body/readable.rb#28
  def close(error = T.unsafe(nil)); end

  # Discard the body as efficiently as possible.
  #
  # The default implementation simply reads all chunks until the body is empty.
  #
  # Useful for discarding the body when it is not needed, but preserving the underlying connection.
  #
  # source://protocol-http//lib/protocol/http/body/readable.rb#165
  def discard; end

  # Enumerate all chunks until finished, then invoke {close}.
  #
  # Closes the stream when finished or if an error occurs.
  #
  # source://protocol-http//lib/protocol/http/body/readable.rb#92
  def each; end

  # Optimistically determine whether read (may) return any data.
  #
  # - If this returns true, then calling read will definitely return nil.
  # - If this returns false, then calling read may return nil.
  #
  # @return [Boolean] Whether the stream is empty.
  #
  # source://protocol-http//lib/protocol/http/body/readable.rb#37
  def empty?; end

  # Read all remaining chunks into a buffered body and close the underlying input.
  #
  # source://protocol-http//lib/protocol/http/body/readable.rb#155
  def finish; end

  # Read all remaining chunks into a single binary string using `#each`.
  #
  # source://protocol-http//lib/protocol/http/body/readable.rb#109
  def join; end

  # The total length of the body, if known.
  #
  # source://protocol-http//lib/protocol/http/body/readable.rb#74
  def length; end

  # Read the next available chunk.
  #
  # source://protocol-http//lib/protocol/http/body/readable.rb#82
  def read; end

  # Whether calling read will return a chunk of data without blocking. We prefer pessimistic implementation, and thus default to `false`.
  #
  # @return [Boolean] Whether the stream is ready (read will not block).
  #
  # source://protocol-http//lib/protocol/http/body/readable.rb#44
  def ready?; end

  # Rewind the stream to the beginning.
  #
  # source://protocol-http//lib/protocol/http/body/readable.rb#58
  def rewind; end

  # Whether the stream can be rewound using {rewind}.
  #
  # @return [Boolean] Whether the stream is rewindable.
  #
  # source://protocol-http//lib/protocol/http/body/readable.rb#51
  def rewindable?; end

  # Whether to prefer streaming the body using {call} rather than reading it using {read} or {each}.
  #
  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/body/readable.rb#126
  def stream?; end

  # Convert the body to JSON.
  #
  # source://protocol-http//lib/protocol/http/body/readable.rb#186
  def to_json(*_arg0, **_arg1, &_arg2); end
end

# General operations for interacting with a request or response body.
#
# This module is included in both {Request} and {Response}.
#
# source://protocol-http//lib/protocol/http/body/reader.rb#13
module Protocol::HTTP::Body::Reader
  # Whether there is a body?
  #
  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/body/reader.rb#98
  def body?; end

  # Buffer the entire request/response body.
  #
  # source://protocol-http//lib/protocol/http/body/reader.rb#61
  def buffered!; end

  # Close the connection as quickly as possible. Discards body. May close the underlying connection if necessary to terminate the stream.
  #
  # source://protocol-http//lib/protocol/http/body/reader.rb#88
  def close(error = T.unsafe(nil)); end

  # Discard the body as efficiently as possible.
  #
  # source://protocol-http//lib/protocol/http/body/reader.rb#49
  def discard; end

  # Read chunks from the body.
  #
  # source://protocol-http//lib/protocol/http/body/reader.rb#17
  def each(&block); end

  # Gracefully finish reading the body. This will buffer the remainder of the body.
  #
  # source://protocol-http//lib/protocol/http/body/reader.rb#39
  def finish; end

  # Reads the entire request/response body.
  #
  # source://protocol-http//lib/protocol/http/body/reader.rb#27
  def read; end

  # Write the body of the response to the given file path.
  #
  # source://protocol-http//lib/protocol/http/body/reader.rb#75
  def save(path, mode = T.unsafe(nil), **options); end
end

# The input stream is an IO-like object which contains the raw HTTP POST data. When applicable, its external encoding must be “ASCII-8BIT” and it must be opened in binary mode, for Ruby 1.9 compatibility. The input stream must respond to gets, each, read and rewind.
#
# source://protocol-http//lib/protocol/http/body/stream.rb#13
class Protocol::HTTP::Body::Stream
  include ::Protocol::HTTP::Body::Stream::Reader

  # Initialize the stream with the given input and output.
  #
  # @raise [ArgumentError]
  # @return [Stream] a new instance of Stream
  #
  # source://protocol-http//lib/protocol/http/body/stream.rb#21
  def initialize(input = T.unsafe(nil), output = T.unsafe(nil)); end

  # Write data to the stream using {write}.
  #
  # source://protocol-http//lib/protocol/http/body/stream.rb#318
  def <<(buffer); end

  # Close the input and output bodies.
  #
  # source://protocol-http//lib/protocol/http/body/stream.rb#375
  def close(error = T.unsafe(nil)); end

  # Close the input body.
  #
  # If, while processing the data that was read from this stream, an error is encountered, it should be passed to this method.
  #
  # source://protocol-http//lib/protocol/http/body/stream.rb#349
  def close_read(error = T.unsafe(nil)); end

  # Close the output body.
  #
  # If, while generating the data that is written to this stream, an error is encountered, it should be passed to this method.
  #
  # source://protocol-http//lib/protocol/http/body/stream.rb#364
  def close_write(error = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/body/stream.rb#385
  def closed?; end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/body/stream.rb#390
  def empty?; end

  # Flush the output stream.
  #
  # This is currently a no-op.
  #
  # source://protocol-http//lib/protocol/http/body/stream.rb#341
  def flush; end

  # Returns the value of attribute input.
  #
  # source://protocol-http//lib/protocol/http/body/stream.rb#35
  def input; end

  # Returns the value of attribute output.
  #
  # source://protocol-http//lib/protocol/http/body/stream.rb#38
  def output; end

  # Write lines to the stream.
  #
  # The current implementation buffers the lines and writes them in a single operation.
  #
  # source://protocol-http//lib/protocol/http/body/stream.rb#328
  def puts(*arguments, separator: T.unsafe(nil)); end

  # Write data to the underlying stream.
  #
  # source://protocol-http//lib/protocol/http/body/stream.rb#297
  def write(buffer); end

  # Write data to the stream using {write}.
  #
  # Provided for compatibility with IO-like objects.
  #
  # source://protocol-http//lib/protocol/http/body/stream.rb#313
  def write_nonblock(buffer, exception: T.unsafe(nil)); end

  private

  # Read the next chunk of data from the input stream.
  #
  # source://protocol-http//lib/protocol/http/body/stream.rb#400
  def read_next; end
end

# The default line separator, used by {gets}.
#
# source://protocol-http//lib/protocol/http/body/stream.rb#15
Protocol::HTTP::Body::Stream::NEWLINE = T.let(T.unsafe(nil), String)

# This provides a read-only interface for data, which is surprisingly tricky to implement correctly.
#
# source://protocol-http//lib/protocol/http/body/stream.rb#41
module Protocol::HTTP::Body::Stream::Reader
  # Iterate over each chunk of data from the input stream.
  #
  # source://protocol-http//lib/protocol/http/body/stream.rb#146
  def each(&block); end

  # Read a single line from the stream.
  #
  # source://protocol-http//lib/protocol/http/body/stream.rb#226
  def gets(separator = T.unsafe(nil), limit = T.unsafe(nil), chomp: T.unsafe(nil)); end

  # Read data from the underlying stream.
  #
  # If given a non-negative length, it will read at most that many bytes from the stream. If the stream is at EOF, it will return nil.
  #
  # If the length is not given, it will read all data until EOF, or return an empty string if the stream is already at EOF.
  #
  # If buffer is given, then the read data will be placed into buffer instead of a newly created String object.
  #
  # source://protocol-http//lib/protocol/http/body/stream.rb#53
  def read(length = T.unsafe(nil), buffer = T.unsafe(nil)); end

  # Read data from the stream without blocking if possible.
  #
  # source://protocol-http//lib/protocol/http/body/stream.rb#163
  def read_nonblock(length, buffer = T.unsafe(nil), exception: T.unsafe(nil)); end

  # Read some bytes from the stream.
  #
  # If the length is given, at most length bytes will be read. Otherwise, one chunk of data from the underlying stream will be read.
  #
  # Will avoid reading from the underlying stream if there is buffered data available.
  #
  # source://protocol-http//lib/protocol/http/body/stream.rb#101
  def read_partial(length = T.unsafe(nil), buffer = T.unsafe(nil)); end

  # Read data from the stream until encountering pattern.
  #
  # source://protocol-http//lib/protocol/http/body/stream.rb#195
  def read_until(pattern, offset = T.unsafe(nil), chomp: T.unsafe(nil)); end

  # Similar to {read_partial} but raises an `EOFError` if the stream is at EOF.
  #
  # source://protocol-http//lib/protocol/http/body/stream.rb#139
  def readpartial(length, buffer = T.unsafe(nil)); end
end

# Wrapping body instance. Typically you'd override `#read`.
#
# source://protocol-http//lib/protocol/http/body/wrapper.rb#12
class Protocol::HTTP::Body::Wrapper < ::Protocol::HTTP::Body::Readable
  # Initialize the wrapper with the given body.
  #
  # @return [Wrapper] a new instance of Wrapper
  #
  # source://protocol-http//lib/protocol/http/body/wrapper.rb#26
  def initialize(body); end

  # Convert the body to a hash suitable for serialization.
  #
  # source://protocol-http//lib/protocol/http/body/wrapper.rb#86
  def as_json(*_arg0, **_arg1, &_arg2); end

  # Returns the value of attribute body.
  #
  # source://protocol-http//lib/protocol/http/body/wrapper.rb#31
  def body; end

  # Forwards to the wrapped body.
  #
  # source://protocol-http//lib/protocol/http/body/wrapper.rb#54
  def buffered; end

  # Close the body.
  #
  # source://protocol-http//lib/protocol/http/body/wrapper.rb#36
  def close(error = T.unsafe(nil)); end

  # Forwards to the wrapped body.
  #
  # source://protocol-http//lib/protocol/http/body/wrapper.rb#79
  def discard; end

  # Forwards to the wrapped body.
  #
  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/body/wrapper.rb#44
  def empty?; end

  # Inspect the wrapped body. The wrapper, by default, is transparent.
  #
  # source://protocol-http//lib/protocol/http/body/wrapper.rb#103
  def inspect; end

  # Forwards to the wrapped body.
  #
  # source://protocol-http//lib/protocol/http/body/wrapper.rb#69
  def length; end

  # Forwards to the wrapped body.
  #
  # source://protocol-http//lib/protocol/http/body/wrapper.rb#74
  def read; end

  # Forwards to the wrapped body.
  #
  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/body/wrapper.rb#49
  def ready?; end

  # Forwards to the wrapped body.
  #
  # source://protocol-http//lib/protocol/http/body/wrapper.rb#59
  def rewind; end

  # Forwards to the wrapped body.
  #
  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/body/wrapper.rb#64
  def rewindable?; end

  # Convert the body to JSON.
  #
  # source://protocol-http//lib/protocol/http/body/wrapper.rb#96
  def to_json(*_arg0, **_arg1, &_arg2); end

  class << self
    # Wrap the body of the given message in a new instance of this class.
    #
    # source://protocol-http//lib/protocol/http/body/wrapper.rb#17
    def wrap(message); end
  end
end

# A dynamic body which you can write to and read from.
#
# source://protocol-http//lib/protocol/http/body/writable.rb#12
class Protocol::HTTP::Body::Writable < ::Protocol::HTTP::Body::Readable
  # Initialize the writable body.
  #
  # @return [Writable] a new instance of Writable
  #
  # source://protocol-http//lib/protocol/http/body/writable.rb#21
  def initialize(length = T.unsafe(nil), queue: T.unsafe(nil)); end

  # Stop generating output; cause the next call to write to fail with the given error. Does not prevent existing chunks from being read. In other words, this indicates both that no more data will be or should be written to the body.
  #
  # source://protocol-http//lib/protocol/http/body/writable.rb#34
  def close(error = T.unsafe(nil)); end

  # Signal that no more data will be written to the body.
  #
  # source://protocol-http//lib/protocol/http/body/writable.rb#98
  def close_write(error = T.unsafe(nil)); end

  # Whether the body is closed. A closed body can not be written to or read from.
  #
  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/body/writable.rb#46
  def closed?; end

  # Indicates whether the body is empty. This can occur if the body has been closed, or if the producer has invoked {close_write} and the reader has consumed all available chunks.
  #
  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/body/writable.rb#58
  def empty?; end

  # Inspect the body.
  #
  # source://protocol-http//lib/protocol/http/body/writable.rb#167
  def inspect; end

  # Returns the value of attribute length.
  #
  # source://protocol-http//lib/protocol/http/body/writable.rb#29
  def length; end

  # Create an output wrapper which can be used to write chunks to the body.
  #
  # If a block is given, and the block raises an error, the error will used to close the body by invoking {close} with the error.
  #
  # source://protocol-http//lib/protocol/http/body/writable.rb#148
  def output; end

  # Read the next available chunk.
  #
  # source://protocol-http//lib/protocol/http/body/writable.rb#66
  def read; end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/body/writable.rb#51
  def ready?; end

  # Write a single chunk to the body. Signal completion by calling {close_write}.
  #
  # source://protocol-http//lib/protocol/http/body/writable.rb#86
  def write(chunk); end

  private

  # source://protocol-http//lib/protocol/http/body/writable.rb#178
  def status; end
end

# An error indicating that the body has been closed and no further writes are allowed.
#
# source://protocol-http//lib/protocol/http/body/writable.rb#14
class Protocol::HTTP::Body::Writable::Closed < ::StandardError; end

# The output interface for writing chunks to the body.
#
# source://protocol-http//lib/protocol/http/body/writable.rb#104
class Protocol::HTTP::Body::Writable::Output
  # Initialize the output with the given writable body.
  #
  # @return [Output] a new instance of Output
  #
  # source://protocol-http//lib/protocol/http/body/writable.rb#108
  def initialize(writable); end

  # Write a chunk to the body.
  #
  # source://protocol-http//lib/protocol/http/body/writable.rb#123
  def <<(chunk); end

  # Close the output stream.
  #
  # If an error is given, the error will be used to close the body by invoking {close} with the error. Otherwise, only the write side of the body will be closed.
  #
  # source://protocol-http//lib/protocol/http/body/writable.rb#130
  def close(error = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/body/writable.rb#114
  def closed?; end

  # Write a chunk to the body.
  #
  # source://protocol-http//lib/protocol/http/body/writable.rb#119
  def write(chunk); end
end

# Represents an individual cookie key-value pair.
#
# source://protocol-http//lib/protocol/http/cookie.rb#12
class Protocol::HTTP::Cookie
  # Initialize the cookie with the given name, value, and directives.
  #
  # @return [Cookie] a new instance of Cookie
  #
  # source://protocol-http//lib/protocol/http/cookie.rb#18
  def initialize(name, value, directives); end

  # Returns the value of attribute directives.
  #
  # source://protocol-http//lib/protocol/http/cookie.rb#31
  def directives; end

  # Encode the name of the cookie.
  #
  # source://protocol-http//lib/protocol/http/cookie.rb#34
  def encoded_name; end

  # Encode the value of the cookie.
  #
  # source://protocol-http//lib/protocol/http/cookie.rb#39
  def encoded_value; end

  # Returns the value of attribute name.
  #
  # source://protocol-http//lib/protocol/http/cookie.rb#25
  def name; end

  # Convert the cookie to a string.
  #
  # source://protocol-http//lib/protocol/http/cookie.rb#46
  def to_s; end

  # Returns the value of attribute value.
  #
  # source://protocol-http//lib/protocol/http/cookie.rb#28
  def value; end

  class << self
    # Parse a string into a cookie.
    #
    # source://protocol-http//lib/protocol/http/cookie.rb#71
    def parse(string); end

    # Parse a list of strings into a hash of directives.
    #
    # source://protocol-http//lib/protocol/http/cookie.rb#88
    def parse_directives(strings); end
  end
end

# Raised when a singleton (e.g. `content-length`) header is duplicated in a request or response.
#
# source://protocol-http//lib/protocol/http/error.rb#18
class Protocol::HTTP::DuplicateHeaderError < ::Protocol::HTTP::Error
  include ::Protocol::HTTP::BadRequest

  # @return [DuplicateHeaderError] a new instance of DuplicateHeaderError
  #
  # source://protocol-http//lib/protocol/http/error.rb#22
  def initialize(key); end

  # Returns the value of attribute key.
  #
  # source://protocol-http//lib/protocol/http/error.rb#27
  def key; end
end

# A generic, HTTP protocol error.
#
# source://protocol-http//lib/protocol/http/error.rb#9
class Protocol::HTTP::Error < ::StandardError; end

# source://protocol-http//lib/protocol/http/header/split.rb#8
module Protocol::HTTP::Header; end

# The `accept-content-type` header represents a list of content-types that the client can accept.
#
# source://protocol-http//lib/protocol/http/header/accept.rb#14
class Protocol::HTTP::Header::Accept < ::Array
  # Parse the `accept` header value into a list of content types.
  #
  # @return [Accept] a new instance of Accept
  #
  # source://protocol-http//lib/protocol/http/header/accept.rb#73
  def initialize(value = T.unsafe(nil)); end

  # Adds one or more comma-separated values to the header.
  #
  # The input string is split into distinct entries and appended to the array.
  #
  # source://protocol-http//lib/protocol/http/header/accept.rb#84
  def <<(value); end

  # Parse the `accept` header.
  #
  # source://protocol-http//lib/protocol/http/header/accept.rb#98
  def media_ranges; end

  # Serializes the stored values into a comma-separated string.
  #
  # source://protocol-http//lib/protocol/http/header/accept.rb#91
  def to_s; end

  private

  # source://protocol-http//lib/protocol/http/header/accept.rb#106
  def parse_media_range(value); end
end

# source://protocol-http//lib/protocol/http/header/accept.rb#27
Protocol::HTTP::Header::Accept::MEDIA_RANGE = T.let(T.unsafe(nil), Regexp)

# A single entry in the Accept: header, which includes a mime type and associated parameters. A media range can include wild cards, but a media type is a specific type and subtype.
#
# source://protocol-http//lib/protocol/http/header/accept.rb#32
class Protocol::HTTP::Header::Accept::MediaRange < ::Struct
  # Create a new media range.
  #
  # @return [MediaRange] a new instance of MediaRange
  #
  # source://protocol-http//lib/protocol/http/header/accept.rb#38
  def initialize(type, subtype = T.unsafe(nil), parameters = T.unsafe(nil)); end

  # Compare the media range with another media range or a string, based on the quality factor.
  #
  # source://protocol-http//lib/protocol/http/header/accept.rb#43
  def <=>(other); end

  # Returns the value of attribute parameters
  #
  # @return [Object] the current value of parameters
  #
  # source://protocol-http//lib/protocol/http/header/accept.rb#32
  def parameters; end

  # Sets the attribute parameters
  #
  # @param value [Object] the value to set the attribute parameters to.
  # @return [Object] the newly set value
  #
  # source://protocol-http//lib/protocol/http/header/accept.rb#32
  def parameters=(_); end

  # The quality factor associated with the media range, which is used to determine the order of preference.
  #
  # source://protocol-http//lib/protocol/http/header/accept.rb#65
  def quality_factor; end

  # Returns the value of attribute subtype
  #
  # @return [Object] the current value of subtype
  #
  # source://protocol-http//lib/protocol/http/header/accept.rb#32
  def subtype; end

  # Sets the attribute subtype
  #
  # @param value [Object] the value to set the attribute subtype to.
  # @return [Object] the newly set value
  #
  # source://protocol-http//lib/protocol/http/header/accept.rb#32
  def subtype=(_); end

  # The string representation of the media range, including the type, subtype, and any parameters.
  #
  # source://protocol-http//lib/protocol/http/header/accept.rb#56
  def to_s; end

  # The string representation of the media range, including the type, subtype, and any parameters.
  #
  # source://protocol-http//lib/protocol/http/header/accept.rb#60
  def to_str; end

  # Returns the value of attribute type
  #
  # @return [Object] the current value of type
  #
  # source://protocol-http//lib/protocol/http/header/accept.rb#32
  def type; end

  # Sets the attribute type
  #
  # @param value [Object] the value to set the attribute type to.
  # @return [Object] the newly set value
  #
  # source://protocol-http//lib/protocol/http/header/accept.rb#32
  def type=(_); end

  private

  # source://protocol-http//lib/protocol/http/header/accept.rb#47
  def parameters_string; end

  class << self
    # source://protocol-http//lib/protocol/http/header/accept.rb#32
    def [](*_arg0); end

    # source://protocol-http//lib/protocol/http/header/accept.rb#32
    def inspect; end

    # source://protocol-http//lib/protocol/http/header/accept.rb#32
    def keyword_init?; end

    # source://protocol-http//lib/protocol/http/header/accept.rb#32
    def members; end

    # source://protocol-http//lib/protocol/http/header/accept.rb#32
    def new(*_arg0); end
  end
end

# source://protocol-http//lib/protocol/http/header/accept.rb#29
Protocol::HTTP::Header::Accept::PARAMETER = T.let(T.unsafe(nil), Regexp)

# source://protocol-http//lib/protocol/http/header/accept.rb#25
class Protocol::HTTP::Header::Accept::ParseError < ::Protocol::HTTP::Error; end

# Regular expression used to split values on commas, with optional surrounding whitespace, taking into account quoted strings.
#
# source://protocol-http//lib/protocol/http/header/accept.rb#16
Protocol::HTTP::Header::Accept::SEPARATOR = T.let(T.unsafe(nil), Regexp)

# The `accept-charset` header represents a list of character sets that the client can accept.
#
# source://protocol-http//lib/protocol/http/header/accept_charset.rb#14
class Protocol::HTTP::Header::AcceptCharset < ::Protocol::HTTP::Header::Split
  # Parse the `accept-charset` header value into a list of character sets.
  #
  # source://protocol-http//lib/protocol/http/header/accept_charset.rb#33
  def charsets; end
end

# https://tools.ietf.org/html/rfc7231#section-5.3.3
#
# source://protocol-http//lib/protocol/http/header/accept_charset.rb#18
Protocol::HTTP::Header::AcceptCharset::CHARSET = T.let(T.unsafe(nil), Regexp)

# source://protocol-http//lib/protocol/http/header/accept_charset.rb#20
class Protocol::HTTP::Header::AcceptCharset::Charset < ::Struct
  # source://protocol-http//lib/protocol/http/header/accept_charset.rb#25
  def <=>(other); end

  # Returns the value of attribute name
  #
  # @return [Object] the current value of name
  #
  # source://protocol-http//lib/protocol/http/header/accept_charset.rb#20
  def name; end

  # Sets the attribute name
  #
  # @param value [Object] the value to set the attribute name to.
  # @return [Object] the newly set value
  #
  # source://protocol-http//lib/protocol/http/header/accept_charset.rb#20
  def name=(_); end

  # Returns the value of attribute q
  #
  # @return [Object] the current value of q
  #
  # source://protocol-http//lib/protocol/http/header/accept_charset.rb#20
  def q; end

  # Sets the attribute q
  #
  # @param value [Object] the value to set the attribute q to.
  # @return [Object] the newly set value
  #
  # source://protocol-http//lib/protocol/http/header/accept_charset.rb#20
  def q=(_); end

  # source://protocol-http//lib/protocol/http/header/accept_charset.rb#21
  def quality_factor; end

  class << self
    # source://protocol-http//lib/protocol/http/header/accept_charset.rb#20
    def [](*_arg0); end

    # source://protocol-http//lib/protocol/http/header/accept_charset.rb#20
    def inspect; end

    # source://protocol-http//lib/protocol/http/header/accept_charset.rb#20
    def keyword_init?; end

    # source://protocol-http//lib/protocol/http/header/accept_charset.rb#20
    def members; end

    # source://protocol-http//lib/protocol/http/header/accept_charset.rb#20
    def new(*_arg0); end
  end
end

# source://protocol-http//lib/protocol/http/header/accept_charset.rb#15
class Protocol::HTTP::Header::AcceptCharset::ParseError < ::Protocol::HTTP::Error; end

# The `accept-encoding` header represents a list of encodings that the client can accept.
#
# source://protocol-http//lib/protocol/http/header/accept_encoding.rb#14
class Protocol::HTTP::Header::AcceptEncoding < ::Protocol::HTTP::Header::Split
  # Parse the `accept-encoding` header value into a list of encodings.
  #
  # source://protocol-http//lib/protocol/http/header/accept_encoding.rb#36
  def encodings; end
end

# https://tools.ietf.org/html/rfc7231#section-5.3.4
#
# source://protocol-http//lib/protocol/http/header/accept_encoding.rb#21
Protocol::HTTP::Header::AcceptEncoding::ENCODING = T.let(T.unsafe(nil), Regexp)

# source://protocol-http//lib/protocol/http/header/accept_encoding.rb#23
class Protocol::HTTP::Header::AcceptEncoding::Encoding < ::Struct
  # source://protocol-http//lib/protocol/http/header/accept_encoding.rb#28
  def <=>(other); end

  # Returns the value of attribute name
  #
  # @return [Object] the current value of name
  #
  # source://protocol-http//lib/protocol/http/header/accept_encoding.rb#23
  def name; end

  # Sets the attribute name
  #
  # @param value [Object] the value to set the attribute name to.
  # @return [Object] the newly set value
  #
  # source://protocol-http//lib/protocol/http/header/accept_encoding.rb#23
  def name=(_); end

  # Returns the value of attribute q
  #
  # @return [Object] the current value of q
  #
  # source://protocol-http//lib/protocol/http/header/accept_encoding.rb#23
  def q; end

  # Sets the attribute q
  #
  # @param value [Object] the value to set the attribute q to.
  # @return [Object] the newly set value
  #
  # source://protocol-http//lib/protocol/http/header/accept_encoding.rb#23
  def q=(_); end

  # source://protocol-http//lib/protocol/http/header/accept_encoding.rb#24
  def quality_factor; end

  class << self
    # source://protocol-http//lib/protocol/http/header/accept_encoding.rb#23
    def [](*_arg0); end

    # source://protocol-http//lib/protocol/http/header/accept_encoding.rb#23
    def inspect; end

    # source://protocol-http//lib/protocol/http/header/accept_encoding.rb#23
    def keyword_init?; end

    # source://protocol-http//lib/protocol/http/header/accept_encoding.rb#23
    def members; end

    # source://protocol-http//lib/protocol/http/header/accept_encoding.rb#23
    def new(*_arg0); end
  end
end

# source://protocol-http//lib/protocol/http/header/accept_encoding.rb#15
class Protocol::HTTP::Header::AcceptEncoding::ParseError < ::Protocol::HTTP::Error; end

# https://tools.ietf.org/html/rfc7231#section-5.3.1
#
# source://protocol-http//lib/protocol/http/header/accept_encoding.rb#18
Protocol::HTTP::Header::AcceptEncoding::QVALUE = T.let(T.unsafe(nil), Regexp)

# The `accept-language` header represents a list of languages that the client can accept.
#
# source://protocol-http//lib/protocol/http/header/accept_language.rb#14
class Protocol::HTTP::Header::AcceptLanguage < ::Protocol::HTTP::Header::Split
  # Parse the `accept-language` header value into a list of languages.
  #
  # source://protocol-http//lib/protocol/http/header/accept_language.rb#39
  def languages; end
end

# https://greenbytes.de/tech/webdav/rfc7231.html#quality.values
#
# source://protocol-http//lib/protocol/http/header/accept_language.rb#24
Protocol::HTTP::Header::AcceptLanguage::LANGUAGE = T.let(T.unsafe(nil), Regexp)

# source://protocol-http//lib/protocol/http/header/accept_language.rb#26
class Protocol::HTTP::Header::AcceptLanguage::Language < ::Struct
  # source://protocol-http//lib/protocol/http/header/accept_language.rb#31
  def <=>(other); end

  # Returns the value of attribute name
  #
  # @return [Object] the current value of name
  #
  # source://protocol-http//lib/protocol/http/header/accept_language.rb#26
  def name; end

  # Sets the attribute name
  #
  # @param value [Object] the value to set the attribute name to.
  # @return [Object] the newly set value
  #
  # source://protocol-http//lib/protocol/http/header/accept_language.rb#26
  def name=(_); end

  # Returns the value of attribute q
  #
  # @return [Object] the current value of q
  #
  # source://protocol-http//lib/protocol/http/header/accept_language.rb#26
  def q; end

  # Sets the attribute q
  #
  # @param value [Object] the value to set the attribute q to.
  # @return [Object] the newly set value
  #
  # source://protocol-http//lib/protocol/http/header/accept_language.rb#26
  def q=(_); end

  # source://protocol-http//lib/protocol/http/header/accept_language.rb#27
  def quality_factor; end

  class << self
    # source://protocol-http//lib/protocol/http/header/accept_language.rb#26
    def [](*_arg0); end

    # source://protocol-http//lib/protocol/http/header/accept_language.rb#26
    def inspect; end

    # source://protocol-http//lib/protocol/http/header/accept_language.rb#26
    def keyword_init?; end

    # source://protocol-http//lib/protocol/http/header/accept_language.rb#26
    def members; end

    # source://protocol-http//lib/protocol/http/header/accept_language.rb#26
    def new(*_arg0); end
  end
end

# https://tools.ietf.org/html/rfc3066#section-2.1
#
# source://protocol-http//lib/protocol/http/header/accept_language.rb#18
Protocol::HTTP::Header::AcceptLanguage::NAME = T.let(T.unsafe(nil), Regexp)

# source://protocol-http//lib/protocol/http/header/accept_language.rb#15
class Protocol::HTTP::Header::AcceptLanguage::ParseError < ::Protocol::HTTP::Error; end

# https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.9
#
# source://protocol-http//lib/protocol/http/header/accept_language.rb#21
Protocol::HTTP::Header::AcceptLanguage::QVALUE = T.let(T.unsafe(nil), Regexp)

# Used for basic authorization.
#
# ~~~ ruby
# headers.add('authorization', Authorization.basic("my_username", "my_password"))
# ~~~
#
# TODO Support other authorization mechanisms, e.g. bearer token.
#
# source://protocol-http//lib/protocol/http/header/authorization.rb#17
class Protocol::HTTP::Header::Authorization < ::String
  # Splits the header into the credentials.
  #
  # source://protocol-http//lib/protocol/http/header/authorization.rb#21
  def credentials; end

  class << self
    # Generate a new basic authorization header, encoding the given username and password.
    #
    # source://protocol-http//lib/protocol/http/header/authorization.rb#30
    def basic(username, password); end
  end
end

# Represents the `cache-control` header, which is a list of cache directives.
#
# source://protocol-http//lib/protocol/http/header/cache_control.rb#13
class Protocol::HTTP::Header::CacheControl < ::Protocol::HTTP::Header::Split
  # Initializes the cache control header with the given value. The value is expected to be a comma-separated string of cache directives.
  #
  # @return [CacheControl] a new instance of CacheControl
  #
  # source://protocol-http//lib/protocol/http/header/cache_control.rb#50
  def initialize(value = T.unsafe(nil)); end

  # Adds a directive to the Cache-Control header. The value will be normalized to lowercase before being added.
  #
  # source://protocol-http//lib/protocol/http/header/cache_control.rb#57
  def <<(value); end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/header/cache_control.rb#67
  def dynamic?; end

  # source://protocol-http//lib/protocol/http/header/cache_control.rb#107
  def max_age; end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/header/cache_control.rb#97
  def must_revalidate?; end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/header/cache_control.rb#87
  def no_cache?; end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/header/cache_control.rb#92
  def no_store?; end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/header/cache_control.rb#77
  def private?; end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/header/cache_control.rb#102
  def proxy_revalidate?; end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/header/cache_control.rb#82
  def public?; end

  # source://protocol-http//lib/protocol/http/header/cache_control.rb#112
  def s_maxage; end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/header/cache_control.rb#62
  def static?; end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/header/cache_control.rb#72
  def streaming?; end

  private

  # Finds and parses an integer value from a directive.
  #
  # source://protocol-http//lib/protocol/http/header/cache_control.rb#122
  def find_integer_value(value_name); end
end

# The `dynamic` directive is a custom directive used to indicate that the resource is generated dynamically and may change frequently, requiring shorter caching periods.
#
# source://protocol-http//lib/protocol/http/header/cache_control.rb#36
Protocol::HTTP::Header::CacheControl::DYNAMIC = T.let(T.unsafe(nil), String)

# The `max-age` directive indicates the maximum amount of time, in seconds, that a response is considered fresh.
#
# source://protocol-http//lib/protocol/http/header/cache_control.rb#27
Protocol::HTTP::Header::CacheControl::MAX_AGE = T.let(T.unsafe(nil), String)

# The `must-revalidate` directive indicates that once a response becomes stale, caches must not use it to satisfy subsequent requests without revalidating it with the origin server.
#
# source://protocol-http//lib/protocol/http/header/cache_control.rb#42
Protocol::HTTP::Header::CacheControl::MUST_REVALIDATE = T.let(T.unsafe(nil), String)

# The `no-cache` directive indicates that caches must revalidate the response with the origin server before serving it to clients.
#
# source://protocol-http//lib/protocol/http/header/cache_control.rb#21
Protocol::HTTP::Header::CacheControl::NO_CACHE = T.let(T.unsafe(nil), String)

# The `no-store` directive indicates that caches must not store the response under any circumstances.
#
# source://protocol-http//lib/protocol/http/header/cache_control.rb#24
Protocol::HTTP::Header::CacheControl::NO_STORE = T.let(T.unsafe(nil), String)

# The `private` directive indicates that the response is intended for a single user and must not be stored by shared caches.
#
# source://protocol-http//lib/protocol/http/header/cache_control.rb#15
Protocol::HTTP::Header::CacheControl::PRIVATE = T.let(T.unsafe(nil), String)

# The `proxy-revalidate` directive is similar to `must-revalidate` but applies only to shared caches.
#
# source://protocol-http//lib/protocol/http/header/cache_control.rb#45
Protocol::HTTP::Header::CacheControl::PROXY_REVALIDATE = T.let(T.unsafe(nil), String)

# The `public` directive indicates that the response may be stored by any cache, even if it would normally be considered non-cacheable.
#
# source://protocol-http//lib/protocol/http/header/cache_control.rb#18
Protocol::HTTP::Header::CacheControl::PUBLIC = T.let(T.unsafe(nil), String)

# The `static` directive is a custom directive often used to indicate that the resource is immutable or rarely changes, allowing longer caching periods.
#
# source://protocol-http//lib/protocol/http/header/cache_control.rb#33
Protocol::HTTP::Header::CacheControl::STATIC = T.let(T.unsafe(nil), String)

# The `streaming` directive is a custom directive used to indicate that the resource is intended for progressive or chunked delivery, such as live video streams.
#
# source://protocol-http//lib/protocol/http/header/cache_control.rb#39
Protocol::HTTP::Header::CacheControl::STREAMING = T.let(T.unsafe(nil), String)

# The `s-maxage` directive is similar to `max-age` but applies only to shared caches. If both `s-maxage` and `max-age` are present, `s-maxage` takes precedence in shared caches.
#
# source://protocol-http//lib/protocol/http/header/cache_control.rb#30
Protocol::HTTP::Header::CacheControl::S_MAXAGE = T.let(T.unsafe(nil), String)

# Represents the `connection` HTTP header, which controls options for the current connection.
#
# The `connection` header is used to specify control options such as whether the connection should be kept alive, closed, or upgraded to a different protocol.
#
# source://protocol-http//lib/protocol/http/header/connection.rb#15
class Protocol::HTTP::Header::Connection < ::Protocol::HTTP::Header::Split
  # Initializes the connection header with the given value. The value is expected to be a comma-separated string of directives.
  #
  # @return [Connection] a new instance of Connection
  #
  # source://protocol-http//lib/protocol/http/header/connection.rb#28
  def initialize(value = T.unsafe(nil)); end

  # Adds a directive to the `connection` header. The value will be normalized to lowercase before being added.
  #
  # source://protocol-http//lib/protocol/http/header/connection.rb#35
  def <<(value); end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/header/connection.rb#45
  def close?; end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/header/connection.rb#40
  def keep_alive?; end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/header/connection.rb#50
  def upgrade?; end
end

# The `close` directive indicates that the connection should be closed after the current request and response are complete.
#
# source://protocol-http//lib/protocol/http/header/connection.rb#20
Protocol::HTTP::Header::Connection::CLOSE = T.let(T.unsafe(nil), String)

# The `keep-alive` directive indicates that the connection should remain open for future requests or responses, avoiding the overhead of opening a new connection.
#
# source://protocol-http//lib/protocol/http/header/connection.rb#17
Protocol::HTTP::Header::Connection::KEEP_ALIVE = T.let(T.unsafe(nil), String)

# The `upgrade` directive indicates that the connection should be upgraded to a different protocol, as specified in the `Upgrade` header.
#
# source://protocol-http//lib/protocol/http/header/connection.rb#23
Protocol::HTTP::Header::Connection::UPGRADE = T.let(T.unsafe(nil), String)

# The `cookie` header contains stored HTTP cookies previously sent by the server with the `set-cookie` header.
#
# It is used by clients to send key-value pairs representing stored cookies back to the server.
#
# source://protocol-http//lib/protocol/http/header/cookie.rb#15
class Protocol::HTTP::Header::Cookie < ::Protocol::HTTP::Header::Multiple
  # Parses the `cookie` header into a hash of cookie names and their corresponding cookie objects.
  #
  # source://protocol-http//lib/protocol/http/header/cookie.rb#19
  def to_h; end
end

# The `date` header represents the date and time at which the message was originated.
#
# This header is typically included in HTTP responses and follows the format defined in RFC 9110.
#
# source://protocol-http//lib/protocol/http/header/date.rb#14
class Protocol::HTTP::Header::Date < ::String
  # Replaces the current value of the `date` header with the specified value.
  #
  # source://protocol-http//lib/protocol/http/header/date.rb#18
  def <<(value); end

  # Converts the `date` header value to a `Time` object.
  #
  # source://protocol-http//lib/protocol/http/header/date.rb#25
  def to_time; end
end

# The `etag` header represents the entity tag for a resource.
#
# The `etag` header provides a unique identifier for a specific version of a resource, typically used for cache validation or conditional requests. It can be either a strong or weak validator as defined in RFC 9110.
#
# source://protocol-http//lib/protocol/http/header/etag.rb#12
class Protocol::HTTP::Header::ETag < ::String
  # Replaces the current value of the `etag` header with the specified value.
  #
  # source://protocol-http//lib/protocol/http/header/etag.rb#16
  def <<(value); end

  # Checks whether the `etag` is a weak validator.
  #
  # Weak validators indicate semantically equivalent content but may not be byte-for-byte identical.
  #
  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/header/etag.rb#25
  def weak?; end
end

# The `etags` header represents a list of entity tags (ETags) for resources.
#
# The `etags` header is used for conditional requests to compare the current version of a resource with previously stored versions. It supports both strong and weak validators, as well as the wildcard character (`*`) to indicate a match for any resource.
#
# source://protocol-http//lib/protocol/http/header/etags.rb#15
class Protocol::HTTP::Header::ETags < ::Protocol::HTTP::Header::Split
  # Checks if the specified ETag matches the `etags` header.
  #
  # This method returns `true` if the wildcard is present or if the exact ETag is found in the list. Note that this implementation is not strictly compliant with the RFC-specified format.
  #
  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/header/etags.rb#31
  def match?(etag); end

  # Checks for a strong match with the specified ETag, useful with the `if-match` header.
  #
  # A strong match requires that the ETag in the header list matches the specified ETag and that neither is a weak validator.
  #
  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/header/etags.rb#41
  def strong_match?(etag); end

  # Checks for a weak match with the specified ETag, useful with the `if-none-match` header.
  #
  # A weak match allows for semantically equivalent content, including weak validators and their strong counterparts.
  #
  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/header/etags.rb#51
  def weak_match?(etag); end

  # Checks if the `etags` header contains the wildcard (`*`) character.
  #
  # The wildcard character matches any resource version, regardless of its actual value.
  #
  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/header/etags.rb#21
  def wildcard?; end

  private

  # Converts a weak tag to its strong counterpart or vice versa.
  #
  # source://protocol-http//lib/protocol/http/header/etags.rb#61
  def opposite_tag(etag); end

  # Checks if the given ETag is a weak validator.
  #
  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/header/etags.rb#69
  def weak_tag?(tag); end
end

# Represents headers that can contain multiple distinct values separated by newline characters.
#
# This isn't a specific header but is used as a base for headers that store multiple values, such as cookies. The values are split and stored as an array internally, and serialized back to a newline-separated string when needed.
#
# source://protocol-http//lib/protocol/http/header/multiple.rb#12
class Protocol::HTTP::Header::Multiple < ::Array
  # Initializes the multiple header with the given value. As the header key-value pair can only contain one value, the value given here is added to the internal array, and subsequent values can be added using the `<<` operator.
  #
  # @return [Multiple] a new instance of Multiple
  #
  # source://protocol-http//lib/protocol/http/header/multiple.rb#16
  def initialize(value); end

  # Serializes the stored values into a newline-separated string.
  #
  # source://protocol-http//lib/protocol/http/header/multiple.rb#25
  def to_s; end
end

# Represents the `priority` header, used to indicate the relative importance of an HTTP request.
#
# The `priority` header allows clients to express their preference for how resources should be prioritized by the server. It supports directives like `u=` to specify the urgency level of a request, and `i` to indicate whether a response can be delivered incrementally. The urgency levels range from 0 (highest priority) to 7 (lowest priority), while the `i` directive is a boolean flag.
#
# source://protocol-http//lib/protocol/http/header/priority.rb#14
class Protocol::HTTP::Header::Priority < ::Protocol::HTTP::Header::Split
  # Initialize the priority header with the given value.
  #
  # @return [Priority] a new instance of Priority
  #
  # source://protocol-http//lib/protocol/http/header/priority.rb#18
  def initialize(value = T.unsafe(nil)); end

  # Add a value to the priority header.
  #
  # source://protocol-http//lib/protocol/http/header/priority.rb#25
  def <<(value); end

  # Checks if the response should be delivered incrementally.
  #
  # The `i` directive, when present, indicates that the response can be delivered incrementally as data becomes available.
  #
  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/header/priority.rb#51
  def incremental?; end

  # The urgency level, if specified using `u=`. 0 is the highest priority, and 7 is the lowest.
  #
  # Note that when duplicate Dictionary keys are encountered, all but the last instance are ignored.
  #
  # source://protocol-http//lib/protocol/http/header/priority.rb#37
  def urgency(default = T.unsafe(nil)); end
end

# The default urgency level if not specified.
#
# source://protocol-http//lib/protocol/http/header/priority.rb#30
Protocol::HTTP::Header::Priority::DEFAULT_URGENCY = T.let(T.unsafe(nil), Integer)

# source://protocol-http//lib/protocol/http/header/quoted_string.rb#12
Protocol::HTTP::Header::QUOTED_STRING = T.let(T.unsafe(nil), Regexp)

# https://tools.ietf.org/html/rfc7231#section-5.3.1
#
# source://protocol-http//lib/protocol/http/header/quoted_string.rb#15
Protocol::HTTP::Header::QVALUE = T.let(T.unsafe(nil), Regexp)

# Handling of HTTP quoted strings.
#
# source://protocol-http//lib/protocol/http/header/quoted_string.rb#18
module Protocol::HTTP::Header::QuotedString
  class << self
    # Quote a string for HTTP header values if required.
    #
    # source://protocol-http//lib/protocol/http/header/quoted_string.rb#38
    def quote(value, force = T.unsafe(nil)); end

    # Unquote a "quoted-string" value according to <https://tools.ietf.org/html/rfc7230#section-3.2.6>. It should already match the QUOTED_STRING pattern above by the parser.
    #
    # source://protocol-http//lib/protocol/http/header/quoted_string.rb#20
    def unquote(value, normalize_whitespace = T.unsafe(nil)); end
  end
end

# source://protocol-http//lib/protocol/http/header/quoted_string.rb#33
Protocol::HTTP::Header::QuotedString::QUOTES_REQUIRED = T.let(T.unsafe(nil), Regexp)

# The `set-cookie` header sends cookies from the server to the user agent.
#
# It is used to store cookies on the client side, which are then sent back to the server in subsequent requests using the `cookie` header.
#
# source://protocol-http//lib/protocol/http/header/cookie.rb#31
class Protocol::HTTP::Header::SetCookie < ::Protocol::HTTP::Header::Cookie; end

# Represents headers that can contain multiple distinct values separated by commas.
#
# This isn't a specific header  class is a utility for handling headers with comma-separated values, such as `accept`, `cache-control`, and other similar headers. The values are split and stored as an array internally, and serialized back to a comma-separated string when needed.
#
# source://protocol-http//lib/protocol/http/header/split.rb#12
class Protocol::HTTP::Header::Split < ::Array
  # Initializes a `Split` header with the given value. If the value is provided, it is split into distinct entries and stored as an array.
  #
  # @return [Split] a new instance of Split
  #
  # source://protocol-http//lib/protocol/http/header/split.rb#19
  def initialize(value = T.unsafe(nil)); end

  # Adds one or more comma-separated values to the header.
  #
  # The input string is split into distinct entries and appended to the array.
  #
  # source://protocol-http//lib/protocol/http/header/split.rb#32
  def <<(value); end

  # Serializes the stored values into a comma-separated string.
  #
  # source://protocol-http//lib/protocol/http/header/split.rb#39
  def to_s; end

  protected

  # source://protocol-http//lib/protocol/http/header/split.rb#45
  def reverse_find(&block); end
end

# Regular expression used to split values on commas, with optional surrounding whitespace.
#
# source://protocol-http//lib/protocol/http/header/split.rb#14
Protocol::HTTP::Header::Split::COMMA = T.let(T.unsafe(nil), Regexp)

# According to https://tools.ietf.org/html/rfc7231#appendix-C
#
# source://protocol-http//lib/protocol/http/header/quoted_string.rb#10
Protocol::HTTP::Header::TOKEN = T.let(T.unsafe(nil), Regexp)

# Represents the `vary` header, which specifies the request headers a server considers when determining the response.
#
# The `vary` header is used in HTTP responses to indicate which request headers affect the selected response. It allows caches to differentiate stored responses based on specific request headers.
#
# source://protocol-http//lib/protocol/http/header/vary.rb#14
class Protocol::HTTP::Header::Vary < ::Protocol::HTTP::Header::Split
  # Initializes a `Vary` header with the given value. The value is split into distinct entries and converted to lowercase for normalization.
  #
  # @return [Vary] a new instance of Vary
  #
  # source://protocol-http//lib/protocol/http/header/vary.rb#18
  def initialize(value); end

  # Adds one or more comma-separated values to the `vary` header. The values are converted to lowercase for normalization.
  #
  # source://protocol-http//lib/protocol/http/header/vary.rb#25
  def <<(value); end
end

# Headers are an array of key-value pairs. Some header keys represent multiple values.
#
# source://protocol-http//lib/protocol/http/headers.rb#33
class Protocol::HTTP::Headers
  # Initialize the headers with the specified fields.
  #
  # @return [Headers] a new instance of Headers
  #
  # source://protocol-http//lib/protocol/http/headers.rb#68
  def initialize(fields = T.unsafe(nil), indexed = T.unsafe(nil)); end

  # Compare this object to another object. May depend on the order of the fields.
  #
  # source://protocol-http//lib/protocol/http/headers.rb#374
  def ==(other); end

  # Get the value of the specified header key.
  #
  # source://protocol-http//lib/protocol/http/headers.rb#347
  def [](key); end

  # Add the specified header key value pair.
  #
  # source://protocol-http//lib/protocol/http/headers.rb#211
  def []=(key, value); end

  # Add the specified header key value pair.
  #
  # source://protocol-http//lib/protocol/http/headers.rb#200
  def add(key, value); end

  # Compute a hash table of headers, where the keys are normalized to lower case and the values are normalized according to the policy for that header.
  #
  # source://protocol-http//lib/protocol/http/headers.rb#362
  def as_json; end

  # Clear all headers.
  #
  # source://protocol-http//lib/protocol/http/headers.rb#87
  def clear; end

  # Delete all header values for the given key, and return the merged value.
  #
  # source://protocol-http//lib/protocol/http/headers.rb#298
  def delete(key); end

  # Enumerate all header keys and values.
  #
  # source://protocol-http//lib/protocol/http/headers.rb#163
  def each(&block); end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/headers.rb#154
  def empty?; end

  # Extract the specified keys from the headers.
  #
  # source://protocol-http//lib/protocol/http/headers.rb#182
  def extract(keys); end

  # Returns the value of attribute fields.
  #
  # source://protocol-http//lib/protocol/http/headers.rb#109
  def fields; end

  # Flatten trailer into the headers, returning a new instance of {Headers}.
  #
  # source://protocol-http//lib/protocol/http/headers.rb#104
  def flatten; end

  # Flatten trailer into the headers, in-place.
  #
  # source://protocol-http//lib/protocol/http/headers.rb#94
  def flatten!; end

  # Freeze the headers, and ensure the indexed hash is generated.
  #
  # source://protocol-http//lib/protocol/http/headers.rb#141
  def freeze; end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/headers.rb#168
  def include?(key); end

  # Inspect the headers.
  #
  # source://protocol-http//lib/protocol/http/headers.rb#367
  def inspect; end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/headers.rb#172
  def key?(key); end

  # source://protocol-http//lib/protocol/http/headers.rb#175
  def keys; end

  # Merge the headers into a new instance of {Headers}.
  #
  # source://protocol-http//lib/protocol/http/headers.rb#233
  def merge(headers); end

  # Merge the headers into this instance.
  #
  # source://protocol-http//lib/protocol/http/headers.rb#224
  def merge!(headers); end

  # Set the specified header key to the specified value, replacing any existing header keys with the same name.
  #
  # source://protocol-http//lib/protocol/http/headers.rb#217
  def set(key, value); end

  # Compute a hash table of headers, where the keys are normalized to lower case and the values are normalized according to the policy for that header.
  #
  # source://protocol-http//lib/protocol/http/headers.rb#354
  def to_h; end

  # Enumerate all headers in the trailer, if there are any.
  #
  # source://protocol-http//lib/protocol/http/headers.rb#132
  def trailer(&block); end

  # Record the current headers, and prepare to add trailers.
  #
  # This method is typically used after headers are sent to capture any additional headers which should then be sent as trailers.
  #
  # A sender that intends to generate one or more trailer fields in a message should generate a trailer header field in the header section of that message to indicate which fields might be present in the trailers.
  #
  # source://protocol-http//lib/protocol/http/headers.rb#125
  def trailer!(&block); end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/headers.rb#112
  def trailer?; end

  protected

  # Merge the value into the hash according to the policy for the given key.
  #
  # source://protocol-http//lib/protocol/http/headers.rb#327
  def merge_into(hash, key, value); end

  private

  # Initialize a copy of the headers.
  #
  # source://protocol-http//lib/protocol/http/headers.rb#79
  def initialize_dup(other); end

  class << self
    # Construct an instance from a headers Array or Hash. No-op if already an instance of `Headers`. If the underlying array is frozen, it will be duped.
    #
    # @return [Headers] an instance of headers.
    #
    # source://protocol-http//lib/protocol/http/headers.rb#42
    def [](headers); end
  end
end

# Used for merging objects into a sequential list of headers. Normalizes header keys and values.
#
# source://protocol-http//lib/protocol/http/headers.rb#386
class Protocol::HTTP::Headers::Merged
  include ::Enumerable

  # Construct a merged list of headers.
  #
  # @return [Merged] a new instance of Merged
  #
  # source://protocol-http//lib/protocol/http/headers.rb#392
  def initialize(*all); end

  # Add a new set of headers to the merged list.
  #
  # source://protocol-http//lib/protocol/http/headers.rb#414
  def <<(headers); end

  # Clear the references to all headers.
  #
  # source://protocol-http//lib/protocol/http/headers.rb#407
  def clear; end

  # Enumerate all headers in the merged list.
  #
  # source://protocol-http//lib/protocol/http/headers.rb#425
  def each(&block); end

  # source://protocol-http//lib/protocol/http/headers.rb#397
  def fields; end

  # source://protocol-http//lib/protocol/http/headers.rb#402
  def flatten; end
end

# source://protocol-http//lib/protocol/http/headers.rb#35
Protocol::HTTP::Headers::Multiple = Protocol::HTTP::Header::Multiple

# The policy for various headers, including how they are merged and normalized.
#
# source://protocol-http//lib/protocol/http/headers.rb#238
Protocol::HTTP::Headers::POLICY = T.let(T.unsafe(nil), Hash)

# source://protocol-http//lib/protocol/http/headers.rb#34
Protocol::HTTP::Headers::Split = Protocol::HTTP::Header::Split

# source://protocol-http//lib/protocol/http/headers.rb#37
Protocol::HTTP::Headers::TRAILER = T.let(T.unsafe(nil), String)

# Provides a convenient interface for commonly supported HTTP methods.
#
#
# These methods are defined in this module using lower case names. They are for convenience only and you should not overload those methods.
#
# See <https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods> for more details.
#
# source://protocol-http//lib/protocol/http/methods.rb#25
class Protocol::HTTP::Methods
  # source://protocol-http//lib/protocol/http/methods.rb#78
  def connect(*arguments, **options); end

  # source://protocol-http//lib/protocol/http/methods.rb#78
  def delete(*arguments, **options); end

  # source://protocol-http//lib/protocol/http/methods.rb#78
  def get(*arguments, **options); end

  # source://protocol-http//lib/protocol/http/methods.rb#78
  def head(*arguments, **options); end

  # source://protocol-http//lib/protocol/http/methods.rb#78
  def options(*arguments, **options); end

  # source://protocol-http//lib/protocol/http/methods.rb#78
  def patch(*arguments, **options); end

  # source://protocol-http//lib/protocol/http/methods.rb#78
  def post(*arguments, **options); end

  # source://protocol-http//lib/protocol/http/methods.rb#78
  def put(*arguments, **options); end

  # source://protocol-http//lib/protocol/http/methods.rb#78
  def trace(*arguments, **options); end

  class << self
    # Enumerate all HTTP methods.
    #
    # source://protocol-http//lib/protocol/http/methods.rb#69
    def each; end

    # Check if the given name is a valid HTTP method, according to this module.
    #
    # Note that this method only knows about the methods defined in this module, however there are many other methods defined in different specifications.
    #
    # @return [Boolean]
    #
    # source://protocol-http//lib/protocol/http/methods.rb#58
    def valid?(name); end
  end
end

# The CONNECT method establishes a tunnel to the server identified by the target resource.
#
# source://protocol-http//lib/protocol/http/methods.rb#42
Protocol::HTTP::Methods::CONNECT = T.let(T.unsafe(nil), String)

# The DELETE method deletes the specified resource.
#
# source://protocol-http//lib/protocol/http/methods.rb#39
Protocol::HTTP::Methods::DELETE = T.let(T.unsafe(nil), String)

# The GET method requests a representation of the specified resource. Requests using GET should only retrieve data.
#
# source://protocol-http//lib/protocol/http/methods.rb#27
Protocol::HTTP::Methods::GET = T.let(T.unsafe(nil), String)

# The HEAD method asks for a response identical to a GET request, but without the response body.
#
# source://protocol-http//lib/protocol/http/methods.rb#30
Protocol::HTTP::Methods::HEAD = T.let(T.unsafe(nil), String)

# The OPTIONS method describes the communication options for the target resource.
#
# source://protocol-http//lib/protocol/http/methods.rb#45
Protocol::HTTP::Methods::OPTIONS = T.let(T.unsafe(nil), String)

# The PATCH method applies partial modifications to a resource.
#
# source://protocol-http//lib/protocol/http/methods.rb#51
Protocol::HTTP::Methods::PATCH = T.let(T.unsafe(nil), String)

# The POST method submits an entity to the specified resource, often causing a change in state or side effects on the server.
#
# source://protocol-http//lib/protocol/http/methods.rb#33
Protocol::HTTP::Methods::POST = T.let(T.unsafe(nil), String)

# The PUT method replaces all current representations of the target resource with the request payload.
#
# source://protocol-http//lib/protocol/http/methods.rb#36
Protocol::HTTP::Methods::PUT = T.let(T.unsafe(nil), String)

# The TRACE method performs a message loop-back test along the path to the target resource.
#
# source://protocol-http//lib/protocol/http/methods.rb#48
Protocol::HTTP::Methods::TRACE = T.let(T.unsafe(nil), String)

# Provide a well defined, cached representation of a peer (address).
#
# source://protocol-http//lib/protocol/http/peer.rb#9
class Protocol::HTTP::Peer
  # Initialize the peer with the given address.
  #
  # @return [Peer] a new instance of Peer
  #
  # source://protocol-http//lib/protocol/http/peer.rb#22
  def initialize(address); end

  # Returns the value of attribute address.
  #
  # source://protocol-http//lib/protocol/http/peer.rb#31
  def address; end

  # Returns the value of attribute ip_address.
  #
  # source://protocol-http//lib/protocol/http/peer.rb#34
  def ip_address; end

  # Returns the value of attribute address.
  #
  # source://protocol-http//lib/protocol/http/peer.rb#36
  def remote_address; end

  class << self
    # Create a new peer object for the given IO object, using the remote address if available.
    #
    # source://protocol-http//lib/protocol/http/peer.rb#13
    def for(io); end
  end
end

# Represents an HTTP request which can be used both server and client-side.
#
# ~~~ ruby
# require 'protocol/http'
#
# # Long form:
# Protocol::HTTP::Request.new("http", "example.com", "GET", "/index.html", "HTTP/1.1", Protocol::HTTP::Headers[["accept", "text/html"]])
#
# # Short form:
# Protocol::HTTP::Request["GET", "/index.html", {"accept" => "text/html"}]
# ~~~
#
# source://protocol-http//lib/protocol/http/request.rb#25
class Protocol::HTTP::Request
  include ::Protocol::HTTP::Body::Reader

  # Initialize the request.
  #
  # @return [Request] a new instance of Request
  #
  # source://protocol-http//lib/protocol/http/request.rb#39
  def initialize(scheme = T.unsafe(nil), authority = T.unsafe(nil), method = T.unsafe(nil), path = T.unsafe(nil), version = T.unsafe(nil), headers = T.unsafe(nil), body = T.unsafe(nil), protocol = T.unsafe(nil), interim_response = T.unsafe(nil)); end

  # Convert the request to a hash, suitable for serialization.
  #
  # source://protocol-http//lib/protocol/http/request.rb#143
  def as_json(*_arg0, **_arg1, &_arg2); end

  # Returns the value of attribute authority.
  #
  # source://protocol-http//lib/protocol/http/request.rb#55
  def authority; end

  # Sets the attribute authority
  #
  # @param value the value to set the attribute authority to.
  #
  # source://protocol-http//lib/protocol/http/request.rb#55
  def authority=(_arg0); end

  # Returns the value of attribute body.
  #
  # source://protocol-http//lib/protocol/http/request.rb#70
  def body; end

  # Sets the attribute body
  #
  # @param value the value to set the attribute body to.
  #
  # source://protocol-http//lib/protocol/http/request.rb#70
  def body=(_arg0); end

  # Send the request to the given connection.
  #
  # source://protocol-http//lib/protocol/http/request.rb#86
  def call(connection); end

  # Whether this is a CONNECT request: typically used to establish a tunnel.
  #
  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/request.rb#117
  def connect?; end

  # Whether this is a HEAD request: no body is expected in the response.
  #
  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/request.rb#112
  def head?; end

  # Returns the value of attribute headers.
  #
  # source://protocol-http//lib/protocol/http/request.rb#67
  def headers; end

  # Sets the attribute headers
  #
  # @param value the value to set the attribute headers to.
  #
  # source://protocol-http//lib/protocol/http/request.rb#67
  def headers=(_arg0); end

  # Whether the request can be replayed without side-effects.
  #
  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/request.rb#136
  def idempotent?; end

  # Returns the value of attribute interim_response.
  #
  # source://protocol-http//lib/protocol/http/request.rb#76
  def interim_response; end

  # Sets the attribute interim_response
  #
  # @param value the value to set the attribute interim_response to.
  #
  # source://protocol-http//lib/protocol/http/request.rb#76
  def interim_response=(_arg0); end

  # Returns the value of attribute method.
  #
  # source://protocol-http//lib/protocol/http/request.rb#58
  def method; end

  # Sets the attribute method
  #
  # @param value the value to set the attribute method to.
  #
  # source://protocol-http//lib/protocol/http/request.rb#58
  def method=(_arg0); end

  # Register a callback to be called when an interim response is received.
  #
  # source://protocol-http//lib/protocol/http/request.rb#100
  def on_interim_response(&block); end

  # Returns the value of attribute path.
  #
  # source://protocol-http//lib/protocol/http/request.rb#61
  def path; end

  # Sets the attribute path
  #
  # @param value the value to set the attribute path to.
  #
  # source://protocol-http//lib/protocol/http/request.rb#61
  def path=(_arg0); end

  # A request that is generated by a server, may choose to include the peer (address) associated with the request. It should be implemented by a sub-class.
  #
  # source://protocol-http//lib/protocol/http/request.rb#81
  def peer; end

  # Returns the value of attribute protocol.
  #
  # source://protocol-http//lib/protocol/http/request.rb#73
  def protocol; end

  # Sets the attribute protocol
  #
  # @param value the value to set the attribute protocol to.
  #
  # source://protocol-http//lib/protocol/http/request.rb#73
  def protocol=(_arg0); end

  # Returns the value of attribute scheme.
  #
  # source://protocol-http//lib/protocol/http/request.rb#52
  def scheme; end

  # Sets the attribute scheme
  #
  # @param value the value to set the attribute scheme to.
  #
  # source://protocol-http//lib/protocol/http/request.rb#52
  def scheme=(_arg0); end

  # Send an interim response back to the origin of this request, if possible.
  #
  # source://protocol-http//lib/protocol/http/request.rb#91
  def send_interim_response(status, headers); end

  # Convert the request to JSON.
  #
  # source://protocol-http//lib/protocol/http/request.rb#159
  def to_json(*_arg0, **_arg1, &_arg2); end

  # Summarize the request as a string.
  #
  # source://protocol-http//lib/protocol/http/request.rb#166
  def to_s; end

  # Returns the value of attribute version.
  #
  # source://protocol-http//lib/protocol/http/request.rb#64
  def version; end

  # Sets the attribute version
  #
  # @param value the value to set the attribute version to.
  #
  # source://protocol-http//lib/protocol/http/request.rb#64
  def version=(_arg0); end

  class << self
    # A short-cut method which exposes the main request variables that you'd typically care about.
    #
    # source://protocol-http//lib/protocol/http/request.rb#127
    def [](method, path = T.unsafe(nil), _headers = T.unsafe(nil), _body = T.unsafe(nil), scheme: T.unsafe(nil), authority: T.unsafe(nil), headers: T.unsafe(nil), body: T.unsafe(nil), protocol: T.unsafe(nil), interim_response: T.unsafe(nil)); end
  end
end

# Represents an HTTP response which can be used both server and client-side.
#
# ~~~ ruby
# require 'protocol/http'
#
# # Long form:
# Protocol::HTTP::Response.new("http/1.1", 200, Protocol::HTTP::Headers[["content-type", "text/html"]], Protocol::HTTP::Body::Buffered.wrap("Hello, World!"))
#
# # Short form:
# Protocol::HTTP::Response[200, {"content-type" => "text/html"}, ["Hello, World!"]]
# ~~~
#
# source://protocol-http//lib/protocol/http/response.rb#22
class Protocol::HTTP::Response
  include ::Protocol::HTTP::Body::Reader

  # Create a new response.
  #
  # @return [Response] a new instance of Response
  #
  # source://protocol-http//lib/protocol/http/response.rb#32
  def initialize(version = T.unsafe(nil), status = T.unsafe(nil), headers = T.unsafe(nil), body = T.unsafe(nil), protocol = T.unsafe(nil)); end

  # Convert the response to a hash suitable for serialization.
  #
  # source://protocol-http//lib/protocol/http/response.rb#157
  def as_json(*_arg0, **_arg1, &_arg2); end

  # Whether the status is 400 (bad request).
  #
  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/response.rb#119
  def bad_request?; end

  # Returns the value of attribute body.
  #
  # source://protocol-http//lib/protocol/http/response.rb#50
  def body; end

  # Sets the attribute body
  #
  # @param value the value to set the attribute body to.
  #
  # source://protocol-http//lib/protocol/http/response.rb#50
  def body=(_arg0); end

  # Whether the status is 100 (continue).
  #
  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/response.rb#68
  def continue?; end

  # Whether the status is considered a failure.
  #
  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/response.rb#114
  def failure?; end

  # Whether the status is considered final. Note that 101 is considered final.
  #
  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/response.rb#78
  def final?; end

  # Returns the value of attribute headers.
  #
  # source://protocol-http//lib/protocol/http/response.rb#47
  def headers; end

  # Sets the attribute headers
  #
  # @param value the value to set the attribute headers to.
  #
  # source://protocol-http//lib/protocol/http/response.rb#47
  def headers=(_arg0); end

  # Whether the response is considered a hijack: the connection has been taken over by the application and the server should not send any more data.
  #
  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/response.rb#63
  def hijack?; end

  # Whether the status is considered informational.
  #
  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/response.rb#73
  def informational?; end

  # Whether the status is 500 (internal server error).
  #
  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/response.rb#124
  def internal_server_error?; end

  # Whether the status is 304 (not modified).
  #
  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/response.rb#104
  def not_modified?; end

  # Whether the status is 200 (ok).
  #
  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/response.rb#84
  def ok?; end

  # Whether the status is 206 (partial content).
  #
  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/response.rb#94
  def partial?; end

  # A response that is generated by a client, may choose to include the peer (address) associated with the response. It should be implemented by a sub-class.
  #
  # source://protocol-http//lib/protocol/http/response.rb#58
  def peer; end

  # Whether the status is 307 (temporary redirect) and should preserve the method of the request when following the redirect.
  #
  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/response.rb#109
  def preserve_method?; end

  # Returns the value of attribute protocol.
  #
  # source://protocol-http//lib/protocol/http/response.rb#53
  def protocol; end

  # Sets the attribute protocol
  #
  # @param value the value to set the attribute protocol to.
  #
  # source://protocol-http//lib/protocol/http/response.rb#53
  def protocol=(_arg0); end

  # Whether the status is considered a redirection.
  #
  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/response.rb#99
  def redirection?; end

  # Whether the status is 500 (internal server error).
  #
  # @deprecated Use {#internal_server_error?} instead.
  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/response.rb#129
  def server_failure?; end

  # Returns the value of attribute status.
  #
  # source://protocol-http//lib/protocol/http/response.rb#44
  def status; end

  # Sets the attribute status
  #
  # @param value the value to set the attribute status to.
  #
  # source://protocol-http//lib/protocol/http/response.rb#44
  def status=(_arg0); end

  # Whether the status is considered successful.
  #
  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/response.rb#89
  def success?; end

  # Implicit conversion to an array.
  #
  # source://protocol-http//lib/protocol/http/response.rb#184
  def to_ary; end

  # Convert the response to JSON.
  #
  # source://protocol-http//lib/protocol/http/response.rb#170
  def to_json(*_arg0, **_arg1, &_arg2); end

  # Summarise the response as a string.
  #
  # source://protocol-http//lib/protocol/http/response.rb#177
  def to_s; end

  # Returns the value of attribute version.
  #
  # source://protocol-http//lib/protocol/http/response.rb#41
  def version; end

  # Sets the attribute version
  #
  # @param value the value to set the attribute version to.
  #
  # source://protocol-http//lib/protocol/http/response.rb#41
  def version=(_arg0); end

  class << self
    # A short-cut method which exposes the main response variables that you'd typically care about. It follows the same order as the `Rack` response tuple, but also includes the protocol.
    #
    # ~~~ ruby
    # 	Response[200, {"content-type" => "text/html"}, ["Hello, World!"]]
    # ~~~
    #
    # source://protocol-http//lib/protocol/http/response.rb#140
    def [](status, _headers = T.unsafe(nil), _body = T.unsafe(nil), headers: T.unsafe(nil), body: T.unsafe(nil), protocol: T.unsafe(nil)); end

    # Create a response for the given exception.
    #
    # source://protocol-http//lib/protocol/http/response.rb#150
    def for_exception(exception); end
  end
end

# Helpers for working with URLs.
#
# source://protocol-http//lib/protocol/http/url.rb#10
module Protocol::HTTP::URL
  class << self
    # Assign a value to a nested hash.
    #
    # source://protocol-http//lib/protocol/http/url.rb#98
    def assign(keys, value, parent); end

    # Decode a URL-encoded query string into a hash.
    #
    # source://protocol-http//lib/protocol/http/url.rb#124
    def decode(string, maximum = T.unsafe(nil), symbolize_keys: T.unsafe(nil)); end

    # Encodes a hash or array into a query string. This method is used to encode query parameters in a URL. For example, `{"a" => 1, "b" => 2}` is encoded as `a=1&b=2`.
    #
    # source://protocol-http//lib/protocol/http/url.rb#49
    def encode(value, prefix = T.unsafe(nil)); end

    # Escapes a string using percent encoding, e.g. `a b` -> `a%20b`.
    #
    # source://protocol-http//lib/protocol/http/url.rb#15
    def escape(string, encoding = T.unsafe(nil)); end

    # Escapes non-path characters using percent encoding. In other words, this method escapes characters that are not allowed in a URI path segment. According to RFC 3986 Section 3.3 (https://tools.ietf.org/html/rfc3986#section-3.3), a valid path segment consists of "pchar" characters. This method percent-encodes characters that are not "pchar" characters.
    #
    # source://protocol-http//lib/protocol/http/url.rb#38
    def escape_path(path); end

    # Scan a string for URL-encoded key/value pairs.
    #
    # source://protocol-http//lib/protocol/http/url.rb#72
    def scan(string); end

    # Split a key into parts, e.g. `a[b][c]` -> `["a", "b", "c"]`.
    #
    # source://protocol-http//lib/protocol/http/url.rb#86
    def split(name); end

    # Unescapes a percent encoded string, e.g. `a%20b` -> `a b`.
    #
    # source://protocol-http//lib/protocol/http/url.rb#25
    def unescape(string, encoding = T.unsafe(nil)); end
  end
end

# Matches characters that are not allowed in a URI path segment. According to RFC 3986 Section 3.3 (https://tools.ietf.org/html/rfc3986#section-3.3), a valid path segment consists of "pchar" characters. This pattern identifies characters that must be percent-encoded when included in a URI path segment.
#
# source://protocol-http//lib/protocol/http/url.rb#32
Protocol::HTTP::URL::NON_PATH_CHARACTER_PATTERN = T.let(T.unsafe(nil), Regexp)
